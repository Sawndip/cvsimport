head	1.56;
access;
symbols
	binutils-2_20_1:1.50
	sid-snapshot-20100401:1.55
	gdb_7_1-2010-03-18-release:1.54
	sid-snapshot-20100301:1.54
	gdb_7_1-branch:1.54.0.2
	gdb_7_1-2010-02-18-branchpoint:1.54
	sid-snapshot-20100201:1.54
	sid-snapshot-20100101:1.53
	gdb_7_0_1-2009-12-22-release:1.50
	sid-snapshot-20091201:1.52
	sid-snapshot-20091101:1.50
	binutils-2_20:1.50
	gdb_7_0-2009-10-06-release:1.50
	sid-snapshot-20091001:1.50
	gdb_7_0-branch:1.50.0.4
	gdb_7_0-2009-09-16-branchpoint:1.50
	arc-sim-20090309:1.45
	binutils-arc-20081103-branch:1.45.0.22
	binutils-arc-20081103-branchpoint:1.45
	binutils-2_20-branch:1.50.0.2
	binutils-2_20-branchpoint:1.50
	sid-snapshot-20090901:1.50
	sid-snapshot-20090801:1.49
	msnyder-checkpoint-072509-branch:1.49.0.4
	msnyder-checkpoint-072509-branchpoint:1.49
	sid-snapshot-20090701:1.49
	dje-cgen-play1-branch:1.49.0.2
	dje-cgen-play1-branchpoint:1.49
	sid-snapshot-20090601:1.48
	sid-snapshot-20090501:1.47
	sid-snapshot-20090401:1.46
	arc-20081103-branch:1.45.0.20
	arc-20081103-branchpoint:1.45
	arc-insight_6_8-branch:1.45.0.18
	arc-insight_6_8-branchpoint:1.45
	insight_6_8-branch:1.45.0.16
	insight_6_8-branchpoint:1.45
	sid-snapshot-20090301:1.46
	binutils-2_19_1:1.45
	sid-snapshot-20090201:1.45
	sid-snapshot-20090101:1.45
	reverse-20081226-branch:1.45.0.14
	reverse-20081226-branchpoint:1.45
	sid-snapshot-20081201:1.45
	multiprocess-20081120-branch:1.45.0.12
	multiprocess-20081120-branchpoint:1.45
	sid-snapshot-20081101:1.45
	binutils-2_19:1.45
	sid-snapshot-20081001:1.45
	reverse-20080930-branch:1.45.0.10
	reverse-20080930-branchpoint:1.45
	binutils-2_19-branch:1.45.0.8
	binutils-2_19-branchpoint:1.45
	sid-snapshot-20080901:1.45
	sid-snapshot-20080801:1.45
	reverse-20080717-branch:1.45.0.6
	reverse-20080717-branchpoint:1.45
	sid-snapshot-20080701:1.45
	msnyder-reverse-20080609-branch:1.45.0.4
	msnyder-reverse-20080609-branchpoint:1.45
	drow-reverse-20070409-branch:1.41.0.2
	drow-reverse-20070409-branchpoint:1.41
	sid-snapshot-20080601:1.45
	sid-snapshot-20080501:1.45
	sid-snapshot-20080403:1.45
	sid-snapshot-20080401:1.45
	gdb_6_8-2008-03-27-release:1.45
	sid-snapshot-20080301:1.45
	gdb_6_8-branch:1.45.0.2
	gdb_6_8-2008-02-26-branchpoint:1.45
	sid-snapshot-20080201:1.44
	sid-snapshot-20080101:1.43
	sid-snapshot-20071201:1.43
	sid-snapshot-20071101:1.43
	gdb_6_7_1-2007-10-29-release:1.43
	gdb_6_7-2007-10-10-release:1.43
	sid-snapshot-20071001:1.43
	gdb_6_7-branch:1.43.0.4
	gdb_6_7-2007-09-07-branchpoint:1.43
	binutils-2_18:1.43
	binutils-2_18-branch:1.43.0.2
	binutils-2_18-branchpoint:1.43
	insight_6_6-20070208-release:1.40
	binutils-csl-coldfire-4_1-32:1.38
	binutils-csl-sourcerygxx-4_1-32:1.38
	gdb_6_6-2006-12-18-release:1.40
	binutils-csl-innovasic-fido-3_4_4-33:1.38
	binutils-csl-sourcerygxx-3_4_4-32:1.33
	binutils-csl-coldfire-4_1-30:1.38
	binutils-csl-sourcerygxx-4_1-30:1.38
	binutils-csl-coldfire-4_1-28:1.38
	binutils-csl-sourcerygxx-4_1-29:1.38
	binutils-csl-sourcerygxx-4_1-28:1.38
	gdb_6_6-branch:1.40.0.2
	gdb_6_6-2006-11-15-branchpoint:1.40
	binutils-csl-arm-2006q3-27:1.38
	binutils-csl-sourcerygxx-4_1-27:1.38
	binutils-csl-arm-2006q3-26:1.38
	binutils-csl-sourcerygxx-4_1-26:1.38
	binutils-csl-sourcerygxx-4_1-25:1.38
	binutils-csl-sourcerygxx-4_1-24:1.38
	binutils-csl-sourcerygxx-4_1-23:1.38
	insight_6_5-20061003-release:1.39
	gdb-csl-symbian-6_4_50_20060226-12:1.37
	binutils-csl-sourcerygxx-4_1-21:1.38
	binutils-csl-arm-2006q3-21:1.38
	binutils-csl-sourcerygxx-4_1-22:1.38
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.38
	binutils-csl-sourcerygxx-4_1-20:1.38
	binutils-csl-arm-2006q3-19:1.38
	binutils-csl-sourcerygxx-4_1-19:1.38
	binutils-csl-sourcerygxx-4_1-18:1.38
	binutils-csl-renesas-4_1-9:1.38
	gdb-csl-sourcerygxx-3_4_4-25:1.37
	binutils-csl-sourcerygxx-3_4_4-25:1.33
	nickrob-async-20060828-mergepoint:1.40
	gdb-csl-symbian-6_4_50_20060226-11:1.37
	binutils-csl-renesas-4_1-8:1.38
	binutils-csl-renesas-4_1-7:1.38
	binutils-csl-renesas-4_1-6:1.38
	gdb-csl-sourcerygxx-4_1-17:1.37
	binutils-csl-sourcerygxx-4_1-17:1.38
	gdb-csl-20060226-branch-local-2:1.37
	gdb-csl-sourcerygxx-4_1-14:1.37
	binutils-csl-sourcerygxx-4_1-14:1.38
	binutils-csl-sourcerygxx-4_1-15:1.38
	gdb-csl-sourcerygxx-4_1-13:1.37
	binutils-csl-sourcerygxx-4_1-13:1.38
	binutils-2_17:1.38
	gdb-csl-sourcerygxx-4_1-12:1.37
	binutils-csl-sourcerygxx-4_1-12:1.38
	gdb-csl-sourcerygxx-3_4_4-21:1.37
	binutils-csl-sourcerygxx-3_4_4-21:1.38
	gdb_6_5-20060621-release:1.39
	binutils-csl-wrs-linux-3_4_4-24:1.33
	binutils-csl-wrs-linux-3_4_4-23:1.33
	gdb-csl-sourcerygxx-4_1-9:1.37
	binutils-csl-sourcerygxx-4_1-9:1.38
	gdb-csl-sourcerygxx-4_1-8:1.37
	binutils-csl-sourcerygxx-4_1-8:1.38
	gdb-csl-sourcerygxx-4_1-7:1.37
	binutils-csl-sourcerygxx-4_1-7:1.38
	gdb-csl-arm-2006q1-6:1.37
	binutils-csl-arm-2006q1-6:1.38
	gdb-csl-sourcerygxx-4_1-6:1.37
	binutils-csl-sourcerygxx-4_1-6:1.38
	binutils-csl-wrs-linux-3_4_4-22:1.33
	gdb-csl-symbian-6_4_50_20060226-10:1.37
	gdb-csl-symbian-6_4_50_20060226-9:1.37
	gdb-csl-symbian-6_4_50_20060226-8:1.37
	gdb-csl-coldfire-4_1-11:1.37
	binutils-csl-coldfire-4_1-11:1.38
	gdb-csl-sourcerygxx-3_4_4-19:1.37
	binutils-csl-sourcerygxx-3_4_4-19:1.38
	gdb-csl-coldfire-4_1-10:1.37
	gdb_6_5-branch:1.39.0.4
	gdb_6_5-2006-05-14-branchpoint:1.39
	binutils-csl-coldfire-4_1-10:1.38
	gdb-csl-sourcerygxx-4_1-5:1.37
	binutils-csl-sourcerygxx-4_1-5:1.38
	nickrob-async-20060513-branch:1.39.0.2
	nickrob-async-20060513-branchpoint:1.39
	gdb-csl-sourcerygxx-4_1-4:1.37
	binutils-csl-sourcerygxx-4_1-4:1.38
	msnyder-reverse-20060502-branch:1.38.0.10
	msnyder-reverse-20060502-branchpoint:1.38
	binutils-csl-wrs-linux-3_4_4-21:1.33
	gdb-csl-morpho-4_1-4:1.37
	binutils-csl-morpho-4_1-4:1.38
	gdb-csl-sourcerygxx-3_4_4-17:1.37
	binutils-csl-sourcerygxx-3_4_4-17:1.38
	binutils-csl-wrs-linux-3_4_4-20:1.33
	readline_5_1-import-branch:1.38.0.8
	readline_5_1-import-branchpoint:1.38
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.37
	binutils-2_17-branch:1.38.0.6
	binutils-2_17-branchpoint:1.38
	gdb-csl-symbian-20060226-branch:1.37.0.16
	gdb-csl-symbian-20060226-branchpoint:1.37
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.37
	msnyder-reverse-20060331-branch:1.38.0.4
	msnyder-reverse-20060331-branchpoint:1.38
	binutils-csl-2_17-branch:1.38.0.2
	binutils-csl-2_17-branchpoint:1.38
	gdb-csl-available-20060303-branch:1.37.0.14
	gdb-csl-available-20060303-branchpoint:1.37
	gdb-csl-20060226-branch:1.37.0.12
	gdb-csl-20060226-branchpoint:1.37
	gdb_6_4-20051202-release:1.37
	msnyder-fork-checkpoint-branch:1.37.0.10
	msnyder-fork-checkpoint-branchpoint:1.37
	gdb-csl-gxxpro-6_3-branch:1.37.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.37
	gdb_6_4-branch:1.37.0.6
	gdb_6_4-2005-11-01-branchpoint:1.37
	gdb-csl-arm-20051020-branch:1.37.0.4
	gdb-csl-arm-20051020-branchpoint:1.37
	binutils-csl-gxxpro-3_4-branch:1.33.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.33
	binutils-2_16_1:1.33
	msnyder-tracepoint-checkpoint-branch:1.37.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.37
	gdb-csl-arm-20050325-2005-q1b:1.33
	binutils-csl-arm-2005q1b:1.33
	binutils-2_16:1.33
	gdb-csl-arm-20050325-2005-q1a:1.33
	binutils-csl-arm-2005q1a:1.33
	csl-arm-20050325-branch:1.33.0.6
	csl-arm-20050325-branchpoint:1.33
	binutils-csl-arm-2005q1-branch:1.33.0.4
	binutils-csl-arm-2005q1-branchpoint:1.33
	binutils-2_16-branch:1.33.0.2
	binutils-2_16-branchpoint:1.33
	csl-arm-2004-q3d:1.32
	gdb_6_3-20041109-release:1.32
	gdb_6_3-branch:1.32.0.2
	gdb_6_3-20041019-branchpoint:1.32
	csl-arm-2004-q3:1.31
	drow_intercu-merge-20040921:1.31
	drow_intercu-merge-20040915:1.31
	jimb-gdb_6_2-e500-branch:1.30.0.6
	jimb-gdb_6_2-e500-branchpoint:1.30
	gdb_6_2-20040730-release:1.30
	gdb_6_2-branch:1.30.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.30
	gdb_6_1_1-20040616-release:1.26
	binutils-2_15:1.26
	binutils-2_15-branchpoint:1.26
	csl-arm-2004-q1a:1.28
	csl-arm-2004-q1:1.26
	gdb_6_1-2004-04-05-release:1.26
	drow_intercu-merge-20040402:1.26
	drow_intercu-merge-20040327:1.26
	ezannoni_pie-20040323-branch:1.26.0.14
	ezannoni_pie-20040323-branchpoint:1.26
	cagney_tramp-20040321-mergepoint:1.26
	cagney_tramp-20040309-branch:1.26.0.12
	cagney_tramp-20040309-branchpoint:1.26
	gdb_6_1-branch:1.26.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.26
	drow_intercu-20040221-branch:1.26.0.8
	drow_intercu-20040221-branchpoint:1.26
	binutils-2_15-branch:1.26.0.6
	cagney_bfdfile-20040213-branch:1.26.0.4
	cagney_bfdfile-20040213-branchpoint:1.26
	drow-cplus-merge-20040208:1.26
	carlton_dictionary-20040126-merge:1.26
	cagney_bigcore-20040122-branch:1.26.0.2
	cagney_bigcore-20040122-branchpoint:1.26
	drow-cplus-merge-20040113:1.26
	csl-arm-2003-q4:1.26
	drow-cplus-merge-20031224:1.26
	drow-cplus-merge-20031220:1.26
	carlton_dictionary-20031215-merge:1.26
	drow-cplus-merge-20031214:1.26
	carlton-dictionary-20031111-merge:1.26
	gdb_6_0-2003-10-04-release:1.23
	kettenis_sparc-20030918-branch:1.24.0.6
	kettenis_sparc-20030918-branchpoint:1.24
	carlton_dictionary-20030917-merge:1.24
	ezannoni_pie-20030916-branchpoint:1.24
	ezannoni_pie-20030916-branch:1.24.0.4
	cagney_x86i386-20030821-branch:1.24.0.2
	cagney_x86i386-20030821-branchpoint:1.24
	carlton_dictionary-20030805-merge:1.24
	carlton_dictionary-20030627-merge:1.24
	gdb_6_0-branch:1.23.0.36
	gdb_6_0-2003-06-23-branchpoint:1.23
	jimb-ppc64-linux-20030613-branch:1.23.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.23
	binutils-2_14:1.23
	cagney_convert-20030606-branch:1.23.0.32
	cagney_convert-20030606-branchpoint:1.23
	cagney_writestrings-20030508-branch:1.23.0.30
	cagney_writestrings-20030508-branchpoint:1.23
	jimb-ppc64-linux-20030528-branch:1.23.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.23
	carlton_dictionary-20030523-merge:1.23
	cagney_fileio-20030521-branch:1.23.0.26
	cagney_fileio-20030521-branchpoint:1.23
	kettenis_i386newframe-20030517-mergepoint:1.23
	jimb-ppc64-linux-20030509-branch:1.23.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.23
	kettenis_i386newframe-20030504-mergepoint:1.23
	carlton_dictionary-20030430-merge:1.23
	binutils-2_14-branch:1.23.0.22
	binutils-2_14-branchpoint:1.23
	kettenis_i386newframe-20030419-branch:1.23.0.20
	kettenis_i386newframe-20030419-branchpoint:1.23
	carlton_dictionary-20030416-merge:1.23
	cagney_frameaddr-20030409-mergepoint:1.23
	kettenis_i386newframe-20030406-branch:1.23.0.18
	kettenis_i386newframe-20030406-branchpoint:1.23
	cagney_frameaddr-20030403-branchpoint:1.23
	cagney_frameaddr-20030403-branch:1.23.0.16
	cagney_framebase-20030330-mergepoint:1.23
	cagney_framebase-20030326-branch:1.23.0.14
	cagney_framebase-20030326-branchpoint:1.23
	cagney_lazyid-20030317-branch:1.23.0.12
	cagney_lazyid-20030317-branchpoint:1.23
	kettenis-i386newframe-20030316-mergepoint:1.23
	offbyone-20030313-branch:1.23.0.10
	offbyone-20030313-branchpoint:1.23
	kettenis-i386newframe-20030308-branch:1.23.0.8
	kettenis-i386newframe-20030308-branchpoint:1.23
	carlton_dictionary-20030305-merge:1.23
	cagney_offbyone-20030303-branch:1.23.0.6
	cagney_offbyone-20030303-branchpoint:1.23
	carlton_dictionary-20030207-merge:1.23
	interps-20030202-branch:1.23.0.4
	interps-20030202-branchpoint:1.23
	cagney-unwind-20030108-branch:1.23.0.2
	cagney-unwind-20030108-branchpoint:1.23
	binutils-2_13_2_1:1.20.2.2
	binutils-2_13_2:1.20.2.2
	carlton_dictionary-20021223-merge:1.23
	gdb_5_3-2002-12-12-release:1.21
	carlton_dictionary-20021115-merge:1.22
	binutils-2_13_1:1.20.2.2
	kseitz_interps-20021105-merge:1.22
	kseitz_interps-20021103-merge:1.21
	drow-cplus-merge-20021020:1.21
	drow-cplus-merge-20021025:1.21
	carlton_dictionary-20021025-merge:1.21
	carlton_dictionary-20021011-merge:1.21
	drow-cplus-branch:1.21.0.12
	drow-cplus-branchpoint:1.21
	kseitz_interps-20020930-merge:1.21
	carlton_dictionary-20020927-merge:1.21
	carlton_dictionary-branch:1.21.0.10
	carlton_dictionary-20020920-branchpoint:1.21
	sid-20020905-branchpoint:1.21
	sid-20020905-branch:1.21.0.8
	gdb_5_3-branch:1.21.0.6
	gdb_5_3-2002-09-04-branchpoint:1.21
	kseitz_interps-20020829-merge:1.21
	cagney_sysregs-20020825-branch:1.21.0.4
	cagney_sysregs-20020825-branchpoint:1.21
	readline_4_3-import-branch:1.21.0.2
	readline_4_3-import-branchpoint:1.21
	binutils-2_13:1.20
	gdb_5_2_1-2002-07-23-release:1.16
	binutils-2_13-branchpoint:1.20
	binutils-2_13-branch:1.20.0.2
	kseitz_interps-20020528-branch:1.18.0.2
	kseitz_interps-20020528-branchpoint:1.18
	cagney_regbuf-20020515-branch:1.17.0.4
	cagney_regbuf-20020515-branchpoint:1.17
	binutils-2_12_1:1.16
	jimb-macro-020506-branch:1.17.0.2
	jimb-macro-020506-branchpoint:1.17
	gdb_5_2-2002-04-29-release:1.16
	binutils-2_12:1.16
	gdb_5_2-branch:1.16.0.4
	gdb_5_2-2002-03-03-branchpoint:1.16
	binutils-2_12-branch:1.16.0.2
	binutils-2_12-branchpoint:1.16
	gdb_5_1_1-2002-01-24-release:1.12
	gdb_5_1_0_1-2002-01-03-release:1.12
	cygnus_cvs_20020108_pre:1.16
	gdb_5_1_0_1-2002-01-03-branch:1.12.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.12
	gdb_5_1-2001-11-21-release:1.12
	gdb_s390-2001-09-26-branch:1.12.0.4
	gdb_s390-2001-09-26-branchpoint:1.12
	gdb_5_1-2001-07-29-branch:1.12.0.2
	gdb_5_1-2001-07-29-branchpoint:1.12
	binutils-2_11_2:1.8.2.2
	binutils-2_11_1:1.8.2.2
	binutils-2_11:1.8
	x86_64versiong3:1.10
	binutils-2_11-branch:1.8.0.2
	insight-precleanup-2001-01-01:1.8
	binutils-2_10_1:1.6
	binutils-2_10:1.6
	gdb-premipsmulti-2000-06-06-branch:1.7.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.7
	gdb_5_0-2000-05-19-release:1.6
	gdb_4_18_2-2000-05-18-release:1.6
	gdb_4_95_1-2000-05-11-snapshot:1.6
	gdb_4_95_0-2000-04-27-snapshot:1.6
	gdb_5_0-2000-04-10-branch:1.6.0.4
	gdb_5_0-2000-04-10-branchpoint:1.6
	binutils-2_10-branch:1.6.0.2
	binutils-2_10-branchpoint:1.6
	binutils_latest_snapshot:1.55
	repo-unification-2000-02-06:1.6
	binu_ss_19990721:1.4
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.56
date	2010.04.14.09.24.59;	author gingold;	state dead;
branches;
next	1.55;

1.55
date	2010.04.01.09.47.14;	author gingold;	state Exp;
branches;
next	1.54;

1.54
date	2010.01.27.16.43.27;	author gingold;	state Exp;
branches;
next	1.53;

1.53
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.24.13.13.43;	author gingold;	state Exp;
branches;
next	1.51;

1.51
date	2009.11.23.14.41.31;	author pbrook;	state Exp;
branches;
next	1.50;

1.50
date	2009.09.01.13.10.45;	author gingold;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.23.13.48.38;	author gingold;	state Exp;
branches;
next	1.48;

1.48
date	2009.05.27.13.31.23;	author nathan;	state Exp;
branches;
next	1.47;

1.47
date	2009.04.16.23.06.59;	author rsandifo;	state Exp;
branches;
next	1.46;

1.46
date	2009.02.23.09.28.43;	author gingold;	state Exp;
branches;
next	1.45;

1.45
date	2008.02.20.17.42.36;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2008.01.07.17.53.03;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2007.07.03.14.26.43;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2007.03.26.12.23.03;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.23.17.44.55;	author fnf;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.04.15.53.41;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.04.07.19.39;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2005.04.21.07.45.38;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2005.02.24.13.34.38;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.08.14.54.02;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2004.07.21.15.42.58;	author hjl;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.24.04.46.26;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.17.16.40.01;	author bwilson;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.30.14.23.40;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.22.14.45.31;	author jakub;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.04.10.41.52;	author amodra;	state Exp;
branches
	1.26.8.1;
next	1.25;

1.25
date	2003.10.16.04.11.09;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.25.06.40.21;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.04.21.44.36;	author kkojima;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.30.05.49.24;	author amodra;	state Exp;
branches
	1.21.10.1
	1.21.12.1;
next	1.20;

1.20
date	2002.06.25.06.21.54;	author amodra;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2002.06.05.03.43.11;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.15.00.18.58;	author amodra;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2002.04.04.19.53.38;	author drow;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2002.01.06.07.30.35;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.13.03.52.25;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.23.15.45.19;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.11.12.23.47;	author jakub;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.16.19.22.12;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.13.22.39.17;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.23.16.48.10;	author kazu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.05.01.05.02.57;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	99.12.10.18.51.35;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.12.10.01.41.22;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	99.07.19.14.55.16;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.07.12.10.30.17;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.07.35.20;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.06.11.10.04.21;	author amodra;	state Exp;
branches;
next	;

1.17.4.1
date	2002.06.15.16.42.42;	author cagney;	state Exp;
branches;
next	;

1.18.2.1
date	2002.06.20.01.31.16;	author kseitz;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.07.22.21.46.49;	author kseitz;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2002.08.09.18.34.18;	author kseitz;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2002.11.05.20.33.26;	author ezannoni;	state Exp;
branches;
next	;

1.20.2.1
date	2002.09.23.22.12.42;	author drow;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.11.06.04.34.59;	author drow;	state Exp;
branches;
next	;

1.21.10.1
date	2002.11.15.19.18.29;	author carlton;	state Exp;
branches;
next	1.21.10.2;

1.21.10.2
date	2002.12.23.19.38.01;	author carlton;	state Exp;
branches;
next	1.21.10.3;

1.21.10.3
date	2003.06.27.21.49.31;	author carlton;	state Exp;
branches;
next	1.21.10.4;

1.21.10.4
date	2003.11.11.23.50.31;	author carlton;	state Exp;
branches;
next	;

1.21.12.1
date	2003.12.14.20.26.53;	author drow;	state Exp;
branches;
next	;

1.26.8.1
date	2004.09.16.17.00.38;	author drow;	state Exp;
branches;
next	;


desc
@@


1.56
log
@2010-04-14  Tristan Gingold  <gingold@@adacore.com>

	* Makefile.am (BFD32_BACKENDS): Remove vms-gsd.lo, vms-hdr.lo,
	vms-tir.lo, vms.lo and add vms-alpha.lo
	(BFD32_BACKENDS_CFILES): Remove vms-gsd.c, vms-hdr.c,
	vms-tir.c, vms.c and add vms-alpha.c
	* Makefile.in: Regenerate.
	* configure.in (TDEFINES): Adjust file list for vms_alpha_vec.
	Remove vms_vax_vec.
	* configure: Regenerate.
	* targets.c (vms_vax_vec): Remove the declaration.
	(_bfd_target_vector): Remove vms_vax_vec.
	* vms-alpha.c: New file.
	* vms-gsd.c: Removed, rewritten in vms-alpha.c
	* vms-hdr.c: Ditto.
	* vms-tir.c: Ditto.
	* vms.c: Ditto.
	* vms-misc.c: Fix indentation and comments.  Replace most of
	#if VMS_DEBUG/vms_debug with vms_debug2.
	(_bfd_vms_hash_newfunc): Moved to vms-alpha.c
	(hash_string): Ditto.
	(_bfd_vms_length_hash_symbol): Ditto.
	(maybe_adjust_record_pointer_for_object): Ditto.
	(_bfd_vms_get_object_record): Ditto.
	(vms_get_remaining_object_record): Ditto.
	(_bfd_vms_push): Ditto.
	(_bfd_vms_pop): Ditto.
	(_bfd_vms_get_header_values): Removed.
	(_bfd_vms_get_first_record): Removed.
	(vms_get_remaining_image_record): Removed.
	(new_symbol): Removed.
	(_bfd_vms_enter_symbol): Removed.
	(_bfd_vms_save_sized_string): Use memcpy instead of strncpy.
	(_bfd_vms_output_begin): Remove rechead parameter.  Replace bfd
	parameter with struct vms_rec_wr.
	(_bfd_vms_output_push): Removed and replaced by ...
	(_bfd_vms_output_begin_subrec): ... new function.
	(_bfd_vms_output_alignment): Replace bfd parameter with
	struct vms_rec_wr, and adjust.
	(_bfd_vms_output_check): Ditto
	(_bfd_vms_output_byte): Ditto.
	(_bfd_vms_output_short): Ditto.
	(_bfd_vms_output_long): Ditto.
	(_bfd_vms_output_quad): Ditto.
	(_bfd_vms_output_counted): Ditto.
	(_bfd_vms_output_dump): Ditto.
	(_bfd_vms_output_fill): Ditto.
	(_bfd_vms_output_pop): Removed and replaced by ...
	(_bfd_vms_output_end_subrec): ... new function.
	(_bfd_vms_output_flush): Removed.
	(_bfd_vms_output_align): New function.
	(_bfd_vms_output_end): Add recwr parameter.  Adjust for this new
	parameter.
	(vms_convert_to_var): New function imported from vms.c
	(vms_convert_to_var_1): Ditto.
	(vms_convert_to_var_unix_filename): Ditto.
	(vms_get_module_name): Ditto.
	(get_vms_time_string): Ditto.
	(vms_time_to_time_t): Ditto.
	(vms_rawtime_to_time_t): Ditto.
	* vms.h: All macros for the VMS file format are now in include/vms.
	Prototypes for vms.c, vms-gsd.c, vms-misc.c, vms-hdr.c, vms-tir.c
	have been removed.
	(struct vms_symbol_struct, struct stack_struct): Moved to vms-alpha.c
	(struct fileinfo, struct srecinfo, struct lineinfo): Ditto.
	(struct funcinfo, struct vms_private_data_struct): Ditto.
	(struct vms_section_data_struct): Ditto.
	(struct vms_rec_rd, stryct vms_rec_wr): New declarations.
	(vms_get_module_name, get_vms_time_string): New declarations.
	(vms_time_to_time_t, vms_rawtime_to_time_t): Ditto.
	(_bfd_vms_output_begin_subrec, _bfd_vms_output_end_subrec): Ditto.
	(_bfd_vms_save_sized_string, _bfd_vms_save_counted_string): Adjusted.
	(_bfd_vms_output_begin, _bfd_vms_output_alignment): Ditto.
	(_bfd_vms_output_end,_bfd_vms_output_check): Ditto.
	(_bfd_vms_output_byte, _bfd_vms_output_short): Ditto.
	(_bfd_vms_output_long, _bfd_vms_output_quad): Ditto.
	(_bfd_vms_output_counted, _bfd_vms_output_dump): Ditto.
	(_bfd_vms_output_fill): Ditto.
	(bfd_vms_set_section_flags): Ditto.
@
text
@/* vms.c -- BFD back-end for VAX (openVMS/VAX) and
   EVAX (openVMS/Alpha) files.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009 Free Software Foundation, Inc.

   Main file.

   Written by Klaus K"ampf (kkaempf@@rmi.de)

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#ifdef VMS
#include <rms.h>
#include <unixlib.h>
#include <starlet.h>
#define RME$C_SETRFM 0x00000001
#include <unistd.h>
#endif

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"

#include "vms.h"

static bfd_boolean vms_initialize (bfd *);
static bfd_boolean fill_section_ptr (struct bfd_hash_entry *, PTR);
static bfd_boolean vms_fixup_sections (bfd *);
static bfd_boolean copy_symbols (struct bfd_hash_entry *, PTR);
static bfd_reloc_status_type reloc_nil (bfd *, arelent *, asymbol *, PTR,
					asection *, bfd *, char **);
static int vms_slurp_module (bfd *abfd);
static int vms_slurp_image (bfd *abfd);
static const struct bfd_target *vms_object_p (bfd *abfd);
static bfd_boolean vms_mkobject (bfd *abfd);
static bfd_boolean vms_write_object_contents (bfd *abfd);
static void free_reloc_stream (bfd *abfd, asection *section, void *data);
static bfd_boolean vms_close_and_cleanup (bfd *abfd);
static bfd_boolean vms_new_section_hook (bfd *abfd, asection *section);
static bfd_boolean vms_get_section_contents
  (bfd *abfd, asection *section, PTR x1, file_ptr x2, bfd_size_type x3);
static long vms_get_symtab_upper_bound (bfd *abfd);
static long vms_canonicalize_symtab (bfd *abfd, asymbol **symbols);
static void vms_print_symbol (bfd *abfd, PTR file, asymbol *symbol,
			      bfd_print_symbol_type how);
static void vms_get_symbol_info (bfd *abfd, asymbol *symbol, symbol_info *ret);
static bfd_boolean vms_bfd_is_local_label_name (bfd *abfd, const char *);
static bfd_boolean vms_find_nearest_line
  (bfd *abfd, asection *section, asymbol **symbols, bfd_vma offset,
   const char **file, const char **func, unsigned int *line);
static void alloc_reloc_stream (bfd *abfd, asection *section,
				void *alloc_error);
static bfd_boolean vms_slurp_reloc_table (bfd *abfd, asection *section,
					  asymbol **symbols);
static long vms_get_reloc_upper_bound (bfd *abfd, asection *sect);
static long vms_canonicalize_reloc (bfd *abfd, asection *srcsec,
				    arelent **location, asymbol **symbols);
static const struct reloc_howto_struct *vms_bfd_reloc_type_lookup
  (bfd *abfd, bfd_reloc_code_real_type code);
static bfd_boolean vms_set_arch_mach
  (bfd *abfd, enum bfd_architecture arch, unsigned long mach);
static bfd_boolean vms_set_section_contents
  (bfd *abfd, asection *section, const PTR location, file_ptr offset,
   bfd_size_type count);

#define vms_bfd_is_target_special_symbol ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
#define vms_make_empty_symbol             _bfd_generic_make_empty_symbol
#define vms_bfd_link_just_syms            _bfd_generic_link_just_syms
#define vms_bfd_copy_link_hash_symbol_type \
  _bfd_generic_copy_link_hash_symbol_type
#define vms_bfd_is_group_section          bfd_generic_is_group_section
#define vms_bfd_discard_group             bfd_generic_discard_group
#define vms_section_already_linked        _bfd_generic_section_already_linked
#define vms_bfd_define_common_symbol      bfd_generic_define_common_symbol
#define vms_bfd_copy_private_header_data  _bfd_generic_bfd_copy_private_header_data
#define vms_get_synthetic_symtab          _bfd_nodynamic_get_synthetic_symtab

#define vms_bfd_copy_private_bfd_data	  _bfd_generic_bfd_copy_private_bfd_data
#define vms_bfd_free_cached_info	  _bfd_generic_bfd_free_cached_info
#define vms_bfd_copy_private_section_data _bfd_generic_bfd_copy_private_section_data
#define vms_bfd_copy_private_symbol_data  _bfd_generic_bfd_copy_private_symbol_data
#define vms_bfd_set_private_flags         _bfd_generic_bfd_set_private_flags
#define vms_bfd_merge_private_bfd_data    _bfd_generic_bfd_merge_private_bfd_data
#define vms_get_section_contents_in_window _bfd_generic_get_section_contents_in_window
#define vms_read_minisymbols               _bfd_generic_read_minisymbols
#define vms_minisymbol_to_symbol           _bfd_generic_minisymbol_to_symbol
#define vms_get_lineno                     _bfd_nosymbols_get_lineno
#define vms_find_inliner_info              _bfd_nosymbols_find_inliner_info
#define vms_bfd_make_debug_symbol          _bfd_nosymbols_bfd_make_debug_symbol

#ifdef VMS_DEBUG
/* Cause debug info to be emitted for the structure.  */
struct vms_private_data_struct _vms_private_data_struct_dummy;
struct vms_section_data_struct _vms_section_data_struct_dummy;
#endif

extern const bfd_target vms_vax_vec;
extern const bfd_target vms_alpha_vec;

/* Initialize private data  */
static bfd_boolean
vms_initialize (bfd * abfd)
{
  bfd_size_type amt;

  bfd_set_start_address (abfd, (bfd_vma) -1);

  amt = sizeof (struct vms_private_data_struct);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;

  if (bfd_get_flavour (abfd) == bfd_target_ovax_flavour)
    PRIV (is_vax) = TRUE;

  PRIV (file_format) = FF_UNKNOWN;

  amt = sizeof (struct stack_struct) * STACKSIZE;
  PRIV (stack) = bfd_alloc (abfd, amt);
  if (PRIV (stack) == NULL)
    goto error_ret1;

  amt = sizeof (struct bfd_hash_table);
  PRIV (vms_symbol_table) = bfd_alloc (abfd, amt);
  if (PRIV (vms_symbol_table) == NULL)
    goto error_ret1;

  if (!bfd_hash_table_init (PRIV (vms_symbol_table), _bfd_vms_hash_newfunc,
			    sizeof (vms_symbol_entry)))
    goto error_ret1;

  amt = MAX_OUTREC_SIZE;
  PRIV (output_buf) = bfd_alloc (abfd, amt);
  if (PRIV (output_buf) == NULL)
    goto error_ret2;

  PRIV (length_pos) = 2;

  return TRUE;

 error_ret2:
  bfd_hash_table_free (PRIV (vms_symbol_table));
 error_ret1:
  bfd_release (abfd, abfd->tdata.any);
  abfd->tdata.any = NULL;
  return FALSE;
}

struct pair
{
  unsigned int section_count;
  asection **sections;
};

/* Fill symbol->section with section pointer.

   symbol->section is filled with the section index for defined symbols
   during reading the GSD/EGSD section.  But we need the pointer to the
   bfd section later.

   It has the correct value for referenced (undefined section) symbols.

   Called from bfd_hash_traverse in vms_fixup_sections.  */

static bfd_boolean
fill_section_ptr (struct bfd_hash_entry *entry, void *sections)
{
  asymbol *sym = ((vms_symbol_entry *)entry)->symbol;
  struct pair *data = (struct pair *)sections;
  unsigned long sec = (unsigned long)sym->section;

  vms_debug2 ((6, "fill_section_ptr: sym %p, sec %lu\n", sym, sec));

  if (sec < data->section_count)
    {
      sym->section = data->sections[sec];

      if (strcmp (sym->name, sym->section->name) == 0)
	sym->flags |= BSF_SECTION_SYM;
    }
  else if (sec == (unsigned long)-1)
    sym->section = &bfd_und_section;

  return TRUE;
}

/* Fixup section pointers in symbols.  */
static bfd_boolean
vms_fixup_sections (bfd * abfd)
{
  struct pair data;

  if (PRIV (fixup_done))
    return TRUE;

  data.section_count = PRIV (section_count);
  data.sections = PRIV (sections);
  bfd_hash_traverse (PRIV (vms_symbol_table), fill_section_ptr, &data);

  PRIV (fixup_done) = TRUE;
  return TRUE;
}

/* Slurp an ordered set of VMS object records.  */
int
_bfd_vms_slurp_object_records (bfd * abfd)
{
  int err, new_type, type = -1;

  do
    {
      vms_debug2 ((7, "reading at %08lx\n", bfd_tell (abfd)));

      new_type = _bfd_vms_get_object_record (abfd);
      if (new_type < 0)
	{
	  vms_debug2 ((2, "next_record failed\n"));
	  return -1;
	}

      if (type == EOBJ_S_C_EGSD && new_type != EOBJ_S_C_EGSD)
	{
	  if (! vms_fixup_sections (abfd))
	    {
	      vms_debug2 ((2, "vms_fixup_sections failed\n"));
	      return -1;
	    }
	}

      type = new_type;

      switch (type)
	{
	  case OBJ_S_C_HDR:
	  case EOBJ_S_C_EMH:
	    err = _bfd_vms_slurp_hdr (abfd, type);
	    break;
	  case OBJ_S_C_EOM:
	  case OBJ_S_C_EOMW:
	  case EOBJ_S_C_EEOM:
	    err = _bfd_vms_slurp_eom (abfd, type);
	    break;
	  case OBJ_S_C_GSD:
	  case EOBJ_S_C_EGSD:
	    err = _bfd_vms_slurp_gsd (abfd, type);
	    break;
	  case OBJ_S_C_TIR:
	  case EOBJ_S_C_ETIR:
	    err = _bfd_vms_slurp_tir (abfd, type);
	    break;
	  case OBJ_S_C_DBG:
	  case EOBJ_S_C_EDBG:
	    err = _bfd_vms_slurp_dbg (abfd, type);
	    PRIV (dst_ptr_end) = PRIV (image_ptr);
	    break;
	  case OBJ_S_C_TBT:
	  case EOBJ_S_C_ETBT:
	    err = _bfd_vms_slurp_tbt (abfd, type);
	    PRIV (dst_ptr_end) = PRIV (image_ptr);
	    break;
	  case OBJ_S_C_LNK:
	    err = _bfd_vms_slurp_lnk (abfd, type);
	    break;
	  default:
	    err = -1;
	}
      if (err != 0)
	{
	  vms_debug2 ((2, "slurp type %d failed with %d\n", type, err));
	  return err;
	}
    }
  while (type != EOBJ_S_C_EEOM && type != OBJ_S_C_EOM && type != OBJ_S_C_EOMW);

  return 0;
}

/* Slurp a VMS module and return an error status.  */

static int
vms_slurp_module (bfd *abfd)
{
  int type, err;

  if (PRIV (is_vax))
    type = PRIV (vms_rec)[0];
  else
    type = bfd_getl16 (PRIV (vms_rec));

  err = _bfd_vms_slurp_hdr (abfd, type);
  if (err != 0)
    {
      bfd_set_error (bfd_error_wrong_format);
      return err;
    }

  return _bfd_vms_slurp_object_records (abfd);
}

/* Slurp a VMS image and return an error status.  */

static int
vms_slurp_image (bfd *abfd)
{
  unsigned int isd_offset, ihs_offset;
  int err;

  err = _bfd_vms_slurp_ihd (abfd, &isd_offset, &ihs_offset);
  if (err != 0)
    {
      bfd_set_error (bfd_error_wrong_format);
      return err;
    }

  err = _bfd_vms_slurp_isd (abfd, isd_offset);
  if (err != 0)
    {
      bfd_set_error (bfd_error_wrong_format);
      return err;
    }

  return _bfd_vms_slurp_ihs (abfd, ihs_offset);
}

/* Check the format for a file being read.
   Return a (bfd_target *) if it's an object file or zero if not.  */

static const struct bfd_target *
vms_object_p (bfd *abfd)
{
  const struct bfd_target *target_vector;
  const bfd_arch_info_type *arch;
  PTR tdata_save = abfd->tdata.any;
  bfd_vma saddr_save = bfd_get_start_address (abfd);
  int err = 0;

  vms_debug2 ((1, "vms_object_p(%p)\n", abfd));

  if (!vms_initialize (abfd))
    goto error_ret;

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET))
    goto err_wrong_format;

  switch (_bfd_vms_get_first_record (abfd))
    {
    case FT_UNKNOWN:
    default:
      err = -1;
      break;

    case FT_MODULE:
      err = vms_slurp_module (abfd);
      break;

    case FT_IMAGE:
      err = vms_slurp_image (abfd);
      break;
    }

  if (err != 0)
    goto err_wrong_format;

  if (PRIV (is_vax))
    {
      if (! vms_fixup_sections (abfd))
	{
	  vms_debug2 ((2, "vms_fixup_sections failed\n"));
	  goto err_wrong_format;
	}

      target_vector = &vms_vax_vec;
      arch = bfd_scan_arch ("vax");

      vms_debug2 ((2, "arch is vax\n"));
    }
  else
    {
      /* Set arch_info to alpha.   */
      target_vector = &vms_alpha_vec;
      arch = bfd_scan_arch ("alpha");
      vms_debug2 ((2, "arch is alpha\n"));
    }

  abfd->arch_info = arch;
  return target_vector;

 err_wrong_format:
  bfd_set_error (bfd_error_wrong_format);

 error_ret:
  if (abfd->tdata.any != tdata_save && abfd->tdata.any != NULL)
    bfd_release (abfd, abfd->tdata.any);
  abfd->tdata.any = tdata_save;
  bfd_set_start_address (abfd, saddr_save);
  return NULL;
}

/* Set the format of a file being written.  */

static bfd_boolean
vms_mkobject (bfd * abfd)
{
  const bfd_arch_info_type *arch;

  vms_debug2 ((1, "vms_mkobject (%p)\n", abfd));

  if (!vms_initialize (abfd))
    return FALSE;

  if (PRIV (is_vax))
    arch = bfd_scan_arch ("vax");
  else
    arch = bfd_scan_arch ("alpha");

  if (arch == 0)
    {
      bfd_set_error(bfd_error_wrong_format);
      return FALSE;
    }

  abfd->arch_info = arch;
  return TRUE;
}

/* Write cached information into a file being written, at bfd_close.  */

static bfd_boolean
vms_write_object_contents (bfd * abfd)
{
  vms_debug2 ((1, "vms_write_object_contents (%p)\n", abfd));

  if (abfd->section_count > 0)			/* we have sections */
    {
      if (PRIV (is_vax))
	{
	  if (_bfd_vms_write_hdr (abfd, OBJ_S_C_HDR) != 0)
	    return FALSE;
	  if (_bfd_vms_write_gsd (abfd, OBJ_S_C_GSD) != 0)
	    return FALSE;
	  if (_bfd_vms_write_tir (abfd, OBJ_S_C_TIR) != 0)
	    return FALSE;
	  if (_bfd_vms_write_tbt (abfd, OBJ_S_C_TBT) != 0)
	    return FALSE;
	  if (_bfd_vms_write_dbg (abfd, OBJ_S_C_DBG) != 0)
	    return FALSE;
	  if (abfd->section_count > 255)
	    {
	      if (_bfd_vms_write_eom (abfd, OBJ_S_C_EOMW) != 0)
		return FALSE;
	    }
	  else
	    {
	      if (_bfd_vms_write_eom (abfd, OBJ_S_C_EOM) != 0)
		return FALSE;
	    }
	}
      else
	{
	  if (_bfd_vms_write_hdr (abfd, EOBJ_S_C_EMH) != 0)
	    return FALSE;
	  if (_bfd_vms_write_gsd (abfd, EOBJ_S_C_EGSD) != 0)
	    return FALSE;
	  if (_bfd_vms_write_tir (abfd, EOBJ_S_C_ETIR) != 0)
	    return FALSE;
	  if (_bfd_vms_write_tbt (abfd, EOBJ_S_C_ETBT) != 0)
	    return FALSE;
	  if (_bfd_vms_write_dbg (abfd, EOBJ_S_C_EDBG) != 0)
	    return FALSE;
	  if (_bfd_vms_write_eom (abfd, EOBJ_S_C_EEOM) != 0)
	    return FALSE;
	}
    }
  return TRUE;
}

/* 4.1, generic.  */

/* Free the reloc buffer for the specified section.  */

static void
free_reloc_stream (bfd *abfd ATTRIBUTE_UNUSED, asection *section,
		   void *data ATTRIBUTE_UNUSED)
{
  if (vms_section_data (section)->reloc_stream)
    free (vms_section_data (section)->reloc_stream);
}

#ifdef VMS
/* Convert the file to variable record length format. This is done
   using undocumented system call sys$modify().
   Pure VMS version.  */

static void
vms_convert_to_var (char *vms_filename)
{
  struct FAB fab = cc$rms_fab;

  fab.fab$l_fna = vms_filename;
  fab.fab$b_fns = strlen (vms_filename);
  fab.fab$b_fac = FAB$M_PUT;
  fab.fab$l_fop = FAB$M_ESC;
  fab.fab$l_ctx = RME$C_SETRFM;

  sys$open (&fab);

  fab.fab$b_rfm = FAB$C_VAR;

  sys$modify (&fab);
  sys$close (&fab);
}

static int
vms_convert_to_var_1 (char *filename, int type)
{
  if (type != DECC$K_FILE)
    return FALSE;
  vms_convert_to_var (filename);
  return TRUE;
}

/* Convert the file to variable record length format. This is done
   using undocumented system call sys$modify().
   Unix filename version.  */

static int
vms_convert_to_var_unix_filename (const char *unix_filename)
{
  if (decc$to_vms (unix_filename, &vms_convert_to_var_1, 0, 1) != 1)
    return FALSE;
  return TRUE;
}
#endif /* VMS */

/* Called when the BFD is being closed to do any necessary cleanup.  */

static bfd_boolean
vms_close_and_cleanup (bfd * abfd)
{
  vms_debug2 ((1, "vms_close_and_cleanup (%p)\n", abfd));

  if (abfd == NULL || abfd->tdata.any == NULL)
    return TRUE;

  if (PRIV (vms_buf) != NULL)
    free (PRIV (vms_buf));

  if (PRIV (sections) != NULL)
    free (PRIV (sections));

  if (PRIV (vms_symbol_table))
    bfd_hash_table_free (PRIV (vms_symbol_table));

  bfd_map_over_sections (abfd, free_reloc_stream, NULL);

  bfd_release (abfd, abfd->tdata.any);
  abfd->tdata.any = NULL;

#ifdef VMS
  if (abfd->direction == write_direction)
    {
      /* Last step on VMS is to convert the file to variable record length
	 format.  */
      if (bfd_cache_close (abfd) != TRUE)
	return FALSE;
      if (vms_convert_to_var_unix_filename (abfd->filename) != TRUE)
	return FALSE;
    }
#endif

  return TRUE;
}

/* Called when a new section is created.  */

static bfd_boolean
vms_new_section_hook (bfd * abfd, asection *section)
{
  bfd_size_type amt;

  /* Count hasn't been incremented yet.  */
  unsigned int section_count = abfd->section_count + 1;

  vms_debug2 ((1, "vms_new_section_hook (%p, [%d]%s), count %d\n",
               abfd, section->index, section->name, section_count));

  bfd_set_section_alignment (abfd, section, 0);

  if (section_count > PRIV (section_count))
    {
      amt = section_count;
      amt *= sizeof (asection *);
      PRIV (sections) = bfd_realloc_or_free (PRIV (sections), amt);
      if (PRIV (sections) == NULL)
	return FALSE;
      PRIV (section_count) = section_count;
    }

  vms_debug2 ((6, "section_count: %d\n", PRIV (section_count)));

  PRIV (sections)[section->index] = section;

  vms_debug2 ((7, "%d: %s\n", section->index, section->name));

  amt = sizeof (struct vms_section_data_struct);
  section->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
  if (section->used_by_bfd == NULL)
    return FALSE;

  return _bfd_generic_new_section_hook (abfd, section);
}

/* Read the contents of a section.
   buf points to a buffer of buf_size bytes to be filled with
   section data (starting at offset into section)  */

static bfd_boolean
vms_get_section_contents (bfd * abfd ATTRIBUTE_UNUSED,
			  asection *section ATTRIBUTE_UNUSED,
			  void * buf ATTRIBUTE_UNUSED,
			  file_ptr offset ATTRIBUTE_UNUSED,
			  bfd_size_type buf_size ATTRIBUTE_UNUSED)
{
  bfd_size_type size = section->size;

  vms_debug2 ((1, "vms_get_section_contents (%p, %s, %p, off %ld, size %d)\n",
               abfd, section->name, buf, offset, (int)buf_size));

  if (section->contents)
    abort ();

  section->contents = (unsigned char *) bfd_malloc (size);

  if (section->contents == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }

  if (bfd_seek (abfd, section->filepos, SEEK_SET))
    {
      bfd_set_error (bfd_error_file_truncated);
      return FALSE;
    }

  if (bfd_bread (section->contents, size, abfd) != size)
    {
      bfd_set_error (bfd_error_file_truncated);
      return FALSE;
    }

  section->flags |= SEC_IN_MEMORY;

  if (buf)
    memcpy (buf, section->contents + offset, (size_t) buf_size);

  return TRUE;
}

/* Part 4.5, symbols.  */

/* Return the number of bytes required to store a vector of pointers
   to asymbols for all the symbols in the BFD abfd, including a
   terminal NULL pointer. If there are no symbols in the BFD,
   then return 0.  If an error occurs, return -1.  */

static long
vms_get_symtab_upper_bound (bfd * abfd)
{
  vms_debug2 ((1, "vms_get_symtab_upper_bound (%p), %d symbols\n",
               abfd, PRIV (gsd_sym_count)));

  return (PRIV (gsd_sym_count) + 1) * sizeof (asymbol *);
}

/* Copy symbols from hash table to symbol vector

   called from bfd_hash_traverse in vms_canonicalize_symtab
   init counter to 0 if entry == 0.  */

static bfd_boolean
copy_symbols (struct bfd_hash_entry *entry, void * arg)
{
  bfd * abfd = (bfd *) arg;

  if (entry == NULL)	/* Init counter.  */
    PRIV (symnum) = 0;
  else			/* Fill vector, inc counter.  */
    PRIV (symcache)[PRIV (symnum)++] = ((vms_symbol_entry *)entry)->symbol;

  return TRUE;
}

/* Read the symbols from the BFD abfd, and fills in the vector
   location with pointers to the symbols and a trailing NULL.

   Return number of symbols read.   */

static long
vms_canonicalize_symtab (bfd * abfd, asymbol **symbols)
{
  vms_debug2 ((1, "vms_canonicalize_symtab (%p, <ret>)\n", abfd));

  /* Init counter.  */
  copy_symbols (NULL, abfd);

  /* Traverse table and fill symbols vector.  */
  PRIV (symcache) = symbols;
  bfd_hash_traverse (PRIV (vms_symbol_table), copy_symbols, abfd);

  symbols[PRIV (gsd_sym_count)] = NULL;

  return PRIV (gsd_sym_count);
}

/* Print symbol to file according to how. how is one of
   bfd_print_symbol_name	just print the name
   bfd_print_symbol_more	print more (???)
   bfd_print_symbol_all	print all we know, which is not much right now :-).  */

static void
vms_print_symbol (bfd * abfd,
		  void * file,
		  asymbol *symbol,
		  bfd_print_symbol_type how)
{
  vms_debug2 ((1, "vms_print_symbol (%p, %p, %p, %d)\n",
               abfd, file, symbol, how));

  switch (how)
    {
      case bfd_print_symbol_name:
      case bfd_print_symbol_more:
	fprintf ((FILE *)file," %s", symbol->name);
      break;

      case bfd_print_symbol_all:
	{
	  const char *section_name = symbol->section->name;

	  bfd_print_symbol_vandf (abfd, file, symbol);

	  fprintf ((FILE *) file," %-8s %s", section_name, symbol->name);
        }
      break;
    }
}

/* Return information about symbol in ret.

   fill type, value and name
   type:
	A	absolute
	B	bss segment symbol
	C	common symbol
	D	data segment symbol
	f	filename
	t	a static function symbol
	T	text segment symbol
	U	undefined
	-	debug.  */

static void
vms_get_symbol_info (bfd * abfd ATTRIBUTE_UNUSED,
		     asymbol *symbol,
		     symbol_info *ret)
{
  asection *sec;

  vms_debug2 ((1, "vms_get_symbol_info (%p, %p, %p)\n", abfd, symbol, ret));

  sec = symbol->section;

  if (ret == NULL)
    return;

  if (sec == 0)
    ret->type = 'U';
  else if (bfd_is_com_section (sec))
    ret->type = 'C';
  else if (bfd_is_abs_section (sec))
    ret->type = 'A';
  else if (bfd_is_und_section (sec))
    ret->type = 'U';
  else if (bfd_is_ind_section (sec))
    ret->type = 'I';
  else if (bfd_get_section_flags (abfd, sec) & SEC_CODE)
    ret->type = 'T';
  else if (bfd_get_section_flags (abfd, sec) & SEC_DATA)
    ret->type = 'D';
  else if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
    ret->type = 'B';
  else
    ret->type = '-';

  if (ret->type != 'U')
    ret->value = symbol->value + symbol->section->vma;
  else
    ret->value = 0;
  ret->name = symbol->name;
}

/* Return TRUE if the given symbol sym in the BFD abfd is
   a compiler generated local label, else return FALSE.  */

static bfd_boolean
vms_bfd_is_local_label_name (bfd * abfd ATTRIBUTE_UNUSED,
			     const char *name)
{
  vms_debug2 ((1, "vms_bfd_is_local_label_name (%p, %s)\n", abfd, name));
  return name[0] == '$';
}

/* Provided a BFD, a section and an offset into the section, calculate and
   return the name of the source file and the line nearest to the wanted
   location.  */

static bfd_boolean
vms_find_nearest_line (bfd * abfd ATTRIBUTE_UNUSED,
		       asection *section ATTRIBUTE_UNUSED,
		       asymbol **symbols ATTRIBUTE_UNUSED,
		       bfd_vma offset ATTRIBUTE_UNUSED,
		       const char **file ATTRIBUTE_UNUSED,
		       const char **func ATTRIBUTE_UNUSED,
		       unsigned int *line ATTRIBUTE_UNUSED)
{
  vms_debug2 ((1, "vms_find_nearest_line (%p, %s, %p, %ld, ...)\n",
               abfd, section->name, symbols, (long int)offset));
  return _bfd_vms_find_nearest_dst_line (abfd, section, symbols, offset, file, func, line);
}

/* Part 4.6, relocations.  */

/* Allocate the reloc buffer for the specified section.  */

static void
alloc_reloc_stream (bfd *abfd ATTRIBUTE_UNUSED, asection *section,
		    void *alloc_error)
{
  unsigned char *ptr;

  /* If there were no relocations, there is nothing to do.  */
  if (section->reloc_count == 0)
    return;

  ptr = bfd_malloc (vms_section_data (section)->reloc_size);
  if (ptr == NULL)
    {
      *(bfd_boolean *)alloc_error = TRUE;
      return;
    }

  vms_section_data (section)->reloc_stream = ptr;
}

/* Read in the relocs for the specified section and internalize them.

   The implementation is loosely based on the SOM code and made up
   of 3 distinct phases:

   1. When the VMS object is opened and parsed, the number and the size
      of the relocations are computed for all sections.  This makes it
      possible to know upfront both which sections have no relocs and
      the size of the reloc buffers for the other sections, at virtually
      no cost for consumers that don't care about relocs at all.

   2. When vms_slurp_reloc_table is invoked for the first time on a section
      with relocs, the object is traversed and all the reloc information
      is saved in per-section reloc buffers.  It would be very inefficient
      to scan the whole file on each invocation, so we slurp for all the
      sections at once.

   3. On subsequent invocations of vms_slurp_reloc_table, the relocs for the
      specified section are fetched from the buffer, decoded and internalized.
      The buffer is then freed since the internalized relocs are attached to
      the section, turning additional invocations of vms_slurp_reloc_table
      on the same section into no-ops.

   Since VMS objects have very few sections, it could be profitable to merge
   phase #2 and phase #3, i.e. to decode and internalize the relocs for all
   the sections at once.  The current implementation is more elegant.  */

static bfd_boolean
vms_slurp_reloc_table (bfd *abfd, asection *section, asymbol **symbols)
{
  arelent *internal_relocs;
  bfd_size_type amt;
  int err;

  /* If there were no relocations, there is nothing to do.  */
  if (section->reloc_count == 0)
    return TRUE;

  /* Return saved information about the relocations if it is available.  */
  if (section->relocation != NULL)
    return TRUE;

  /* If the relocation stream has not been slurped, do it now.  */
  if (vms_section_data (section)->reloc_stream == NULL)
    {
      bfd_boolean alloc_error = FALSE;
      int type;

      /* Size the reloc buffer for each section.  */
      bfd_map_over_sections (abfd, alloc_reloc_stream, &alloc_error);
      if (alloc_error)
	return FALSE;

      if (bfd_seek (abfd, 0, SEEK_SET) != 0)
	return FALSE;

      /* Reset section pointer.  */
      PRIV (image_section) = NULL;

      do
	{
	  type = _bfd_vms_get_object_record (abfd);
	  if (type != EOBJ_S_C_ETIR
	      && type != EOBJ_S_C_EDBG
	      && type != EOBJ_S_C_ETBT)
	    continue;
	  err = _bfd_vms_slurp_relocs (abfd);
	  if (err != 0)
	    {
	      vms_debug2 ((2, "slurp relocs failed with %d\n", err));
	      return FALSE;
	    }
	}
      while (type != EOBJ_S_C_EEOM);
    }

  amt = section->reloc_count * sizeof (arelent);
  internal_relocs = (arelent *) bfd_zalloc (abfd, amt);
  if (internal_relocs == NULL)
    return FALSE;

  /* Decode and internalize the relocations.  */
  err = _bfd_vms_decode_relocs (abfd, internal_relocs, section, symbols);
  if (err != 0)
    {
      vms_debug2 ((2, "decode relocs failed with %d\n", err));
      return FALSE;
    }

  /* We're done with the external relocations.  Free them.  */
  free (vms_section_data (section)->reloc_stream);
  vms_section_data (section)->reloc_stream = NULL;

  /* Save our results and return success.  */
  section->relocation = internal_relocs;
  return TRUE;
}

/* Return the number of bytes required to store the relocation
   information associated with the given section.  */

static long
vms_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED, asection *section)
{
  return (section->reloc_count + 1) * sizeof (arelent *);
}

/* Convert relocations from VMS (external) form into BFD internal
   form.  Return the number of relocations.  */

static long
vms_canonicalize_reloc (bfd *abfd, asection *section, arelent **relptr,
			asymbol **symbols)
{
  arelent *tblptr;
  int count;

  if (! vms_slurp_reloc_table (abfd, section, symbols))
    return -1;

  count = section->reloc_count;
  tblptr = section->relocation;

  while (count--)
    *relptr++ = tblptr++;

  *relptr = (arelent *) NULL;
  return section->reloc_count;
}

/* This is just copied from ecoff-alpha, needs to be fixed probably.  */

/* How to process the various reloc types.  */

static bfd_reloc_status_type
reloc_nil (bfd * abfd ATTRIBUTE_UNUSED,
	   arelent *reloc ATTRIBUTE_UNUSED,
	   asymbol *sym ATTRIBUTE_UNUSED,
	   void * data ATTRIBUTE_UNUSED,
	   asection *sec ATTRIBUTE_UNUSED,
	   bfd *output_bfd ATTRIBUTE_UNUSED,
	   char **error_message ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "reloc_nil (abfd %p, output_bfd %p)\n", abfd, output_bfd);
  vms_debug (2, "In section %s, symbol %s\n",
	sec->name, sym->name);
  vms_debug (2, "reloc sym %s, addr %08lx, addend %08lx, reloc is a %s\n",
		reloc->sym_ptr_ptr[0]->name,
		(unsigned long)reloc->address,
		(unsigned long)reloc->addend, reloc->howto->name);
  vms_debug (2, "data at %p\n", data);
  /*  _bfd_hexdump (2, data, bfd_get_reloc_size (reloc->howto), 0); */
#endif

  return bfd_reloc_ok;
}

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)

static reloc_howto_type alpha_howto_table[] =
{
  HOWTO (ALPHA_R_IGNORE,	/* Type.  */
	 0,			/* Rightshift.  */
	 0,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 8,			/* Bitsize.  */
	 TRUE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_dont,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "IGNORE",		/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 0,			/* Source mask */
	 0,			/* Dest mask.  */
	 TRUE),			/* PC rel offset.  */

  /* A 64 bit reference to a symbol.  */
  HOWTO (ALPHA_R_REFQUAD,	/* Type.  */
	 0,			/* Rightshift.  */
	 4,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 64,			/* Bitsize.  */
	 FALSE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_bitfield, /* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "REFQUAD",		/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 MINUS_ONE,		/* Source mask.  */
	 MINUS_ONE,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* A 21 bit branch.  The native assembler generates these for
     branches within the text segment, and also fills in the PC
     relative offset in the instruction.  */
  HOWTO (ALPHA_R_BRADDR,	/* Type.  */
	 2,			/* Rightshift.  */
	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 21,			/* Bitsize.  */
	 TRUE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_signed, /* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "BRADDR",		/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 0x1fffff,		/* Source mask.  */
	 0x1fffff,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* A hint for a jump to a register.  */
  HOWTO (ALPHA_R_HINT,		/* Type.  */
	 2,			/* Rightshift.  */
	 1,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 14,			/* Bitsize.  */
	 TRUE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_dont,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "HINT",		/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 0x3fff,		/* Source mask.  */
	 0x3fff,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* 16 bit PC relative offset.  */
  HOWTO (ALPHA_R_SREL16,	/* Type.  */
	 0,			/* Rightshift.  */
	 1,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,			/* Bitsize.  */
	 TRUE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_signed, /* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "SREL16",		/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 0xffff,		/* Source mask.  */
	 0xffff,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* 32 bit PC relative offset.  */
  HOWTO (ALPHA_R_SREL32,	/* Type.  */
	 0,			/* Rightshift.  */
	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 32,			/* Bitsize.  */
	 TRUE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_signed, /* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "SREL32",		/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 0xffffffff,		/* Source mask.  */
	 0xffffffff,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* A 64 bit PC relative offset.  */
  HOWTO (ALPHA_R_SREL64,	/* Type.  */
	 0,			/* Rightshift.  */
	 4,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 64,			/* Bitsize.  */
	 TRUE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_signed, /* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "SREL64",		/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 MINUS_ONE,		/* Source mask.  */
	 MINUS_ONE,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* Push a value on the reloc evaluation stack.  */
  HOWTO (ALPHA_R_OP_PUSH,	/* Type.  */
	 0,			/* Rightshift.  */
	 0,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* Bitsize.  */
	 FALSE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_dont,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "OP_PUSH",		/* Name.  */
	 FALSE,			/* Partial_inplace.  */
	 0,			/* Source mask.  */
	 0,			/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* Store the value from the stack at the given address.  Store it in
     a bitfield of size r_size starting at bit position r_offset.  */
  HOWTO (ALPHA_R_OP_STORE,	/* Type.  */
	 0,			/* Rightshift.  */
	 4,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 64,			/* Bitsize.  */
	 FALSE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_dont,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "OP_STORE",		/* Name.  */
	 FALSE,			/* Partial_inplace.  */
	 0,			/* Source mask.  */
	 MINUS_ONE,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* Subtract the reloc address from the value on the top of the
     relocation stack.  */
  HOWTO (ALPHA_R_OP_PSUB,	/* Type.  */
	 0,			/* Rightshift.  */
	 0,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* Bitsize.  */
	 FALSE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_dont,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "OP_PSUB",		/* Name.  */
	 FALSE,			/* Partial_inplace.  */
	 0,			/* Source mask.  */
	 0,			/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* Shift the value on the top of the relocation stack right by the
     given value.  */
  HOWTO (ALPHA_R_OP_PRSHIFT,	/* Type.  */
	 0,			/* Rightshift.  */
	 0,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* Bitsize.  */
	 FALSE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_dont,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "OP_PRSHIFT",		/* Name.  */
	 FALSE,			/* Partial_inplace.  */
	 0,			/* Source mask.  */
	 0,			/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* Hack. Linkage is done by linker.  */
  HOWTO (ALPHA_R_LINKAGE,	/* Type.  */
	 0,			/* Rightshift.  */
	 8,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 256,			/* Bitsize.  */
	 FALSE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_dont,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "LINKAGE",		/* Name.  */
	 FALSE,			/* Partial_inplace.  */
	 0,			/* Source mask.  */
	 0,			/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* A 32 bit reference to a symbol.  */
  HOWTO (ALPHA_R_REFLONG,	/* Type.  */
	 0,			/* Rightshift.  */
	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 32,			/* Bitsize.  */
	 FALSE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_bitfield, /* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "REFLONG",		/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 0xffffffff,		/* Source mask.  */
	 0xffffffff,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  /* A 64 bit reference to a procedure, written as 32 bit value.  */
  HOWTO (ALPHA_R_CODEADDR,	/* Type.  */
	 0,			/* Rightshift.  */
	 4,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 64,			/* Bitsize.  */
	 FALSE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_signed,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "CODEADDR",		/* Name.  */
	 FALSE,			/* Partial_inplace.  */
	 0xffffffff,		/* Source mask.  */
	 0xffffffff,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  HOWTO (ALPHA_R_NOP,		/* Type.  */
	 0,			/* Rightshift.  */
	 3,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* Bitsize.  */
	 /* The following value must match that of ALPHA_R_BSR/ALPHA_R_BOH
	    because the calculations for the 3 relocations are the same.
	    See B.4.5.2 of the OpenVMS Linker Utility Manual.  */
	 TRUE,			/* PC relative.  */
	 0,			/* Bitpos.   */
	 complain_overflow_dont,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "NOP",			/* Name.  */
	 FALSE,			/* Partial_inplace.  */
	 0xffffffff,		/* Source mask.  */
	 0xffffffff,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  HOWTO (ALPHA_R_BSR,		/* Type.  */
	 0,			/* Rightshift.  */
	 3,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* Bitsize.  */
	 TRUE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_dont,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "BSR",			/* Name.  */
	 FALSE,			/* Partial_inplace.  */
	 0xffffffff,		/* Source mask.  */
	 0xffffffff,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  HOWTO (ALPHA_R_LDA,		/* Type.  */
	 0,			/* Rightshift.  */
	 3,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* Bitsize.  */
	 FALSE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_dont,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "LDA",			/* Name.  */
	 FALSE,			/* Partial_inplace.  */
	 0xffffffff,		/* Source mask.  */
	 0xffffffff,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */

  HOWTO (ALPHA_R_BOH,		/* Type.  */
	 0,			/* Rightshift.  */
	 3,			/* Size (0 = byte, 1 = short, 2 = long, 3 = nil).  */
	 0,			/* Bitsize.  */
	 TRUE,			/* PC relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_dont,/* Complain_on_overflow.  */
	 reloc_nil,		/* Special_function.  */
	 "BOH",			/* Name.  */
	 FALSE,			/* Partial_inplace.  */
	 0xffffffff,		/* Source mask.  */
	 0xffffffff,		/* Dest mask.  */
	 FALSE),		/* PC rel offset.  */
};

/* Return a pointer to a howto structure which, when invoked, will perform
   the relocation code on data from the architecture noted.  */

static const struct reloc_howto_struct *
vms_bfd_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
			   bfd_reloc_code_real_type code)
{
  int alpha_type;

  vms_debug2 ((1, "vms_bfd_reloc_type_lookup (%p, %d)\t", abfd, code));

  switch (code)
    {
      case BFD_RELOC_16:		alpha_type = ALPHA_R_SREL16;	break;
      case BFD_RELOC_32:		alpha_type = ALPHA_R_REFLONG;	break;
      case BFD_RELOC_64:		alpha_type = ALPHA_R_REFQUAD;	break;
      case BFD_RELOC_CTOR:		alpha_type = ALPHA_R_REFQUAD;	break;
      case BFD_RELOC_23_PCREL_S2:	alpha_type = ALPHA_R_BRADDR;	break;
      case BFD_RELOC_ALPHA_HINT:	alpha_type = ALPHA_R_HINT;	break;
      case BFD_RELOC_16_PCREL:		alpha_type = ALPHA_R_SREL16;	break;
      case BFD_RELOC_32_PCREL:		alpha_type = ALPHA_R_SREL32;	break;
      case BFD_RELOC_64_PCREL:		alpha_type = ALPHA_R_SREL64;	break;
      case BFD_RELOC_ALPHA_LINKAGE:	alpha_type = ALPHA_R_LINKAGE;	break;
      case BFD_RELOC_ALPHA_CODEADDR:	alpha_type = ALPHA_R_CODEADDR;	break;
      case BFD_RELOC_ALPHA_NOP:		alpha_type = ALPHA_R_NOP;	break;
      case BFD_RELOC_ALPHA_BSR:		alpha_type = ALPHA_R_BSR;	break;
      case BFD_RELOC_ALPHA_LDA:		alpha_type = ALPHA_R_LDA;	break;
      case BFD_RELOC_ALPHA_BOH:		alpha_type = ALPHA_R_BOH;	break;
      default:
	(*_bfd_error_handler) ("reloc (%d) is *UNKNOWN*", code);
	return NULL;
    }
  vms_debug2 ((2, "reloc is %s\n", alpha_howto_table[alpha_type].name));
  return & alpha_howto_table[alpha_type];
}

static reloc_howto_type *
vms_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			   const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (alpha_howto_table) / sizeof (alpha_howto_table[0]);
       i++)
    if (alpha_howto_table[i].name != NULL
	&& strcasecmp (alpha_howto_table[i].name, r_name) == 0)
      return &alpha_howto_table[i];

  return NULL;
}

/* Part 4.7, writing an object file.  */

/* Set the architecture and machine type in BFD abfd to arch and mach.
   Find the correct pointer to a structure and insert it into the arch_info
   pointer.  */

static bfd_boolean
vms_set_arch_mach (bfd * abfd,
		   enum bfd_architecture arch ATTRIBUTE_UNUSED,
		   unsigned long mach ATTRIBUTE_UNUSED)
{
  vms_debug2 ((1, "vms_set_arch_mach (%p, %d, %ld)\n", abfd, arch, mach));

  if (arch != bfd_arch_alpha
      && arch != bfd_arch_vax
      && arch != bfd_arch_unknown)
    return FALSE;

  return bfd_default_set_arch_mach (abfd, arch, mach);
}

/* Sets the contents of the section section in BFD abfd to the data starting
   in memory at LOCATION. The data is written to the output section starting
   at offset offset for count bytes.

   Normally TRUE is returned, else FALSE. Possible error returns are:
   o bfd_error_no_contents - The output section does not have the
	SEC_HAS_CONTENTS attribute, so nothing can be written to it.
   o and some more too  */

static bfd_boolean
vms_set_section_contents (bfd * abfd,
			  asection *section,
			  const void * location,
			  file_ptr offset,
			  bfd_size_type count)
{
#if VMS_DEBUG
  vms_debug (1, "vms_set_section_contents (%p, sec %s, loc %p, off %ld, count %d)\n",
	     abfd, section->name, location, (long int)offset, (int)count);
  vms_debug (2, "size %d\n", (int) section->size);
#endif
  if (count == (bfd_size_type)0)
    return TRUE;

  if (section->contents == NULL)
    section->contents = bfd_alloc (abfd, section->size);
  if (section->contents == NULL)
    return FALSE;

  memcpy (section->contents + offset, location, (size_t) count);
  return TRUE;
}

static bfd_boolean
vms_bfd_print_private_bfd_data (bfd *abfd, void *ptr)
{
  FILE *file = (FILE *)ptr;

  fprintf (file, _("structure level: %d\n"), PRIV(hdr_data.hdr_b_strlvl));
  fprintf (file, _("module name    : %s\n"), PRIV(hdr_data.hdr_t_name));
  fprintf (file, _("module version : %s\n"), PRIV(hdr_data.hdr_t_version));
  fprintf (file, _("module date    : %s\n"), PRIV(hdr_data.hdr_t_date));
  fprintf (file, _("language name  : %s\n"), PRIV(hdr_data.hdr_c_lnm));
  fprintf (file, _("source files   : %s\n"), PRIV(hdr_data.hdr_c_src));
  fprintf (file, _("title          : %s\n"), PRIV(hdr_data.hdr_c_ttl));

  return TRUE;
}

const bfd_target vms_alpha_vec =
{
  "vms-alpha",			/* Name.  */
  bfd_target_evax_flavour,
  BFD_ENDIAN_LITTLE,		/* Data byte order is little.  */
  BFD_ENDIAN_LITTLE,		/* Header byte order is little.  */

  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | HAS_SYMS | HAS_LOCALS
   | WP_TEXT | D_PAGED),	/* Object flags.  */
  (SEC_ALLOC | SEC_LOAD | SEC_RELOC
   | SEC_READONLY | SEC_CODE | SEC_DATA
   | SEC_HAS_CONTENTS | SEC_IN_MEMORY),		/* Sect flags.  */
  0,				/* symbol_leading_char.  */
  ' ',				/* ar_pad_char.  */
  15,				/* ar_max_namelen.  */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16,
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16,

  {_bfd_dummy_target, vms_object_p,		/* bfd_check_format.  */
   _bfd_vms_lib_alpha_archive_p, _bfd_dummy_target},
  {bfd_false, vms_mkobject,			/* bfd_set_format.  */
   _bfd_vms_lib_mkarchive, bfd_false},
  {bfd_false, vms_write_object_contents,	/* bfd_write_contents.  */
   _bfd_vms_lib_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (vms),
  BFD_JUMP_TABLE_COPY (vms),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_vms_lib),
  BFD_JUMP_TABLE_SYMBOLS (vms),
  BFD_JUMP_TABLE_RELOCS (vms),
  BFD_JUMP_TABLE_WRITE (vms),
  BFD_JUMP_TABLE_LINK (_bfd_nolink),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  (PTR) 0
};

const bfd_target vms_vax_vec =
{
  "vms-vax",			/* Name.  */
  bfd_target_ovax_flavour,
  BFD_ENDIAN_LITTLE,		/* Data byte order is little.  */
  BFD_ENDIAN_LITTLE,		/* Header byte order is little.  */

  (HAS_RELOC | HAS_SYMS 	/* Object flags.  */
   | WP_TEXT | D_PAGED
   | HAS_LINENO | HAS_DEBUG | HAS_LOCALS),

  (SEC_ALLOC | SEC_LOAD | SEC_RELOC
   | SEC_READONLY | SEC_CODE | SEC_DATA
   | SEC_HAS_CONTENTS | SEC_IN_MEMORY),		/* Sect flags.  */
  0,				/* symbol_leading_char */
  ' ',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* Data.  */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* Hdrs.  */

  {_bfd_dummy_target, vms_object_p,		/* bfd_check_format.  */
   _bfd_dummy_target, _bfd_dummy_target},
  {bfd_false, vms_mkobject,			/* bfd_set_format.  */
   bfd_false, bfd_false},
  {bfd_false, vms_write_object_contents,	/* bfd_write_contents.  */
   bfd_false, bfd_false},

  BFD_JUMP_TABLE_GENERIC (vms),
  BFD_JUMP_TABLE_COPY (vms),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_noarchive),
  BFD_JUMP_TABLE_SYMBOLS (vms),
  BFD_JUMP_TABLE_RELOCS (vms),
  BFD_JUMP_TABLE_WRITE (vms),
  BFD_JUMP_TABLE_LINK (_bfd_nolink),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  (PTR) 0
};
@


1.55
log
@2010-04-01  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Include time.h. Add prototypes for vms_get_module_name,
	vms_time_to_time_t and vms_rawtime_to_time_t.
	* vms.c (vms_alpha_vec): Add archives support.
	* vms-misc.c: Include safe-ctype.h
	(vms_get_module_name): New function.
	(vms_time_to_time_t, vms_rawtime_to_time_t): Ditto.
	* vms-hdr.c (_bfd_vms_write_hdr): Put module name creation to the
	vms_get_module_name function.  Use this function.
	* targets.c: Declare vms_lib_txt_vec.  Add it to _bfd_target_vector.
	* libbfd-in.h: Add prototype for _bfd_append_relative_path.
	Add prototypes for vms-lib.c
	* libbfd.h: Regenerate.
	* configure.in (TDEFINES): Add an entry for vms_lib_txt_vec.  Add
	vms-lib.lo to vms_alpha_vec.
	* config.bfd (targ_cpu): Add targ_selvecs for alpha*-*-*vms*.
	* configure: Regenerate.
	* bfd.c: Add selective_search field.
	* bfd-in2.h: Regenerate.
	* archive.c (append_relative_path): Rename to
	_bfd_append_relative_path and make it public.
	(_bfd_get_elt_at_filepos): Adjust for above renaming.
	* Makefile.am (BFD32_BACKENDS): Add vms-lib.lo
	(BFD32_BACKENDS_CFILES): Add vms-lib.c
	* Makefile.in: Regenerate.
@
text
@@


1.54
log
@2010-01-27  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Remove trailing spaces.
	(struct hdr_struct): Remove unused hdr_c_cpr field.
	(enum file_format_enum): Add comments.
	* vms.c (vms_bfd_print_private_bfd_data): New function that
	replaces the macro.
	Remove trailing spaces.
	* vms-misc.c: Improve comments.
	(_bfd_vms_get_object_record): Also handle files without pads.
	* vms-hdr.c (_bfd_vms_write_dbg): Fix format string.
	* vms-gsd.c (struct flagdescstruct): Make name field const.
	(gsyflagdesc): Fix typo.
@
text
@d1453 1
a1453 1
   _bfd_dummy_target, _bfd_dummy_target},
d1455 1
a1455 1
   bfd_false, bfd_false},
d1457 1
a1457 1
   bfd_false, bfd_false},
d1462 1
a1462 1
  BFD_JUMP_TABLE_ARCHIVE (_bfd_noarchive),
@


1.53
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@a92 1
#define vms_bfd_print_private_bfd_data	  _bfd_generic_bfd_print_private_bfd_data
d197 1
a197 1
    
d518 1
a518 1
  
d520 1
a520 1
  
d522 1
a522 1
  
d974 1
a974 1
  return (section->reloc_count + 1) * sizeof (arelent *);  
d1413 16
@


1.52
log
@2009-11-24  Tristan Gingold  <gingold@@adacore.com>

	* vms-hdr.c (_bfd_vms_write_hdr): Strip any suffix to create module
	name.
	* vms.h (vms_debug2): Add vms_debug2.
	* vms.c (vms_archive_p): Remove
	(vms_bfd_free_cached_info): Remove the function, use libbfd.h macro
	instead.
	(vms_get_section_contents_in_window): Ditto.
	(vms_bfd_copy_private_bfd_data): Ditto.
	(vms_bfd_copy_private_section_data): Ditto.
	(vms_bfd_copy_private_symbol_data): Ditto.
	(vms_bfd_print_private_bfd_data): Ditto.
	(vms_bfd_set_private_flags): Ditto.
	(vms_bfd_merge_private_bfd_data): Ditto.
	(vms_read_minisymbols): Ditto.
	(vms_minisymbol_to_symbol): Ditto.
	(vms_get_lineno): Ditto.
	(vms_find_nearest_line): Ditto.
	(vms_bfd_make_debug_symbol): Ditto.
	(vms_core_file_failing_command): Remove.
	(vms_core_file_failing_signal): Remove.
	(vms_core_file_matches_executable_p): Remove.
	(vms_slurp_armap): Remove.
	(vms_slurp_extended_name_table): Remove.
	(vms_construct_extended_name_table): Remove.
	(vms_truncate_arname): Remove.
	(vms_write_armap): Remove.
	(vms_read_ar_hdr): Remove.
	(vms_get_elt_at_index): Remove.
	(vms_openr_next_archived_file): Remove.
	(vms_update_armap_timestamp): Remove.
	(vms_generic_stat_arch_elt): Remove.
	(vms_get_symtab_upper_bound): Remove.
	(vms_sizeof_headers): Remove.
	(vms_bfd_get_relocated_section_contents): Remove.
	(vms_bfd_relax_section): Remove.
	(vms_bfd_gc_sections): Remove.
	(vms_bfd_merge_sections): Remove.
	(vms_bfd_link_hash_table_create): Remove.
	(vms_bfd_link_hash_table_free): Remove.
	(vms_bfd_link_add_symbols): Remove.
	(vms_bfd_final_link): Remove.
	(vms_bfd_link_split_section): Remove.
	(vms_get_dynamic_symtab_upper_bound): Remove.
	(vms_canonicalize_dynamic_symtab): Remove.
	(vms_get_dynamic_reloc_upper_bound): Remove.
	(vms_canonicalize_dynamic_reloc): Remove.
	(fill_section_ptr): Use vms_debug2 instead of vms_debug.
	(_bfd_vms_slurp_object_records): Ditto.
	(vms_object_p): Ditto.
	(vms_mkobject): Ditto.
	(vms_write_object_contents): Ditto.
	(vms_close_and_cleanup): Ditto.
	(vms_new_section_hook): Ditto.
	(vms_get_section_contents): Ditto.
	(vms_get_symtab_upper_bound): Ditto.
	(vms_canonicalize_symtab): Ditto.
	(vms_print_symbol): Ditto.
	(vms_get_symbol_info): Ditto.
	(vms_bfd_is_local_label_name): Ditto.
	(vms_find_nearest_line): Ditto.
	(vms_slurp_reloc_table): Ditto.
	(vms_bfd_reloc_type_lookup): Ditto.
	(vms_set_arch_mach): Ditto.
	(vms_alpha_vec, vms_vax_vec): Use _bfd_nocore, _bfd_noarchive,
	_bfd_nolink and _bfd_nodynamic methods instead of vms stubs.
@
text
@d606 1
a606 1
      bfd_size_type amt = section_count;
@


1.51
log
@2009-11-23  Paul Brook  <paul@@codesourcery.com>

	ld/
	* ldexp.c: Copy symbol type for simple assignments.

	bfd/
	* libbfd-in.h (_bfd_generic_copy_link_hash_symbol_type): Add
	prototype.
	* elf-bfd.h (_bfd_elf_copy_link_hash_symbol_type): Add prototype.
	* linker.c (_bfd_generic_copy_link_hash_symbol_type): New function.
	* elflink.c (_bfd_elf_copy_link_hash_symbol_type): New function.
	* targets.c (BFD_JUMP_TABLE_LINK, struct bfd_target): Add
	_copy_link_hash_symbol_type.
	* bfd/coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* bfd/coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* aout-adobe.c (aout_32_bfd_copy_link_hash_symbol_type): Define.
	* aout-target.h (MY_bfd_copy_link_hash_symbol_type): Define.
	* aout-tic30.c (MY_bfd_copy_link_hash_symbol_type): Define.
	* binary.c (binary_bfd_copy_link_hash_symbol_type): Define.
	* bout.c (b_out_bfd_copy_link_hash_symbol_type): Define.
	* coffcode.h (coff_bfd_copy_link_hash_symbol_type): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_link_hash_symbol_type): Define.
	* i386msdos.c (msdos_bfd_copy_link_hash_symbol_type): Define.
	* i386os9k.c (os9k_bfd_copy_link_hash_symbol_type): Define.
	* ieee.c (ieee_bfd_copy_link_hash_symbol_type): Define.
	* ihex.c (ihex_bfd_copy_link_hash_symbol_type): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_link_hash_symbol_type): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_link_hash_symbol_type): Define.
	* mmo.c (mmo_bfd_copy_link_hash_symbol_type): Define.
	* nlm-target.h (nlm_bfd_copy_link_hash_symbol_type): Define.
	* oasys.c (oasys_bfd_copy_link_hash_symbol_type): Define.
	* pef.c (bfd_pef_bfd_copy_link_hash_symbol_type): Define.
	* ppcboot.c (ppcboot_bfd_copy_link_hash_symbol_type): Define.
	* som.c (som_bfd_copy_link_hash_symbol_type): Define.
	* srec.c (srec_bfd_copy_link_hash_symbol_type): Define.
	* tekhex.c (tekhex_bfd_copy_link_hash_symbol_type): Define.
	* versados.c (versados_bfd_copy_link_hash_symbol_type): Define.
	* vms.c (vms_bfd_copy_link_hash_symbol_type): Define.
	* xsym.c (bfd_sym_bfd_copy_link_hash_symbol_type): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	ld/testsuite
	* ld-arm/script-type.sym: New test.
	* ld-arm/script-type.s: New test.
	* ld-arm/script-type.s: New test.
@
text
@a48 1
static const struct bfd_target *vms_archive_p (bfd *abfd);
a52 1
static bfd_boolean vms_bfd_free_cached_info (bfd *abfd);
a55 24
static bfd_boolean vms_get_section_contents_in_window
  (bfd *abfd, asection *section, bfd_window *w, file_ptr offset,
   bfd_size_type count);
static bfd_boolean vms_bfd_copy_private_bfd_data (bfd *src, bfd *dest);
static bfd_boolean vms_bfd_copy_private_section_data
  (bfd *srcbfd, asection *srcsec, bfd *dstbfd, asection *dstsec);
static bfd_boolean vms_bfd_copy_private_symbol_data
  (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
static bfd_boolean vms_bfd_print_private_bfd_data (bfd *abfd, void *file);
static char *vms_core_file_failing_command (bfd *abfd);
static int vms_core_file_failing_signal (bfd *abfd);
static bfd_boolean vms_core_file_matches_executable_p (bfd *abfd, bfd *bbfd);
static bfd_boolean vms_slurp_armap (bfd *abfd);
static bfd_boolean vms_slurp_extended_name_table (bfd *abfd);
static bfd_boolean vms_construct_extended_name_table
  (bfd *abfd, char **tabloc, bfd_size_type *tablen, const char **name);
static void vms_truncate_arname (bfd *abfd, const char *pathname, char *arhdr);
static bfd_boolean vms_write_armap
  (bfd *arch, unsigned int elen, struct orl *map, unsigned int cnt, int idx);
static PTR vms_read_ar_hdr (bfd *abfd);
static bfd *vms_get_elt_at_index (bfd *abfd, symindex index);
static bfd *vms_openr_next_archived_file (bfd *arch, bfd *prev);
static bfd_boolean vms_update_armap_timestamp (bfd *abfd);
static int vms_generic_stat_arch_elt (bfd *, struct stat *);
a61 1
static alent *vms_get_lineno (bfd *abfd, asymbol *symbol);
a64 6
static asymbol *vms_bfd_make_debug_symbol (bfd *abfd, void *ptr,
					   unsigned long size);
static long vms_read_minisymbols (bfd *abfd, bfd_boolean dynamic,
				  PTR *minisymsp, unsigned int *sizep);
static asymbol *vms_minisymbol_to_symbol
  (bfd *abfd, bfd_boolean dynamic, const PTR minisym, asymbol *sym);
a78 27
static int vms_sizeof_headers (bfd *abfd,
			       struct bfd_link_info *info ATTRIBUTE_UNUSED);
static bfd_byte *vms_bfd_get_relocated_section_contents
  (bfd *abfd, struct bfd_link_info *link_info,
   struct bfd_link_order *link_order, bfd_byte *data,
   bfd_boolean relocatable, asymbol **symbols);
static bfd_boolean vms_bfd_relax_section
  (bfd *abfd, asection *section, struct bfd_link_info *link_info,
   bfd_boolean *again);
static bfd_boolean vms_bfd_gc_sections
  (bfd *abfd, struct bfd_link_info *link_info);
static bfd_boolean vms_bfd_merge_sections
  (bfd *abfd, struct bfd_link_info *link_info);
static struct bfd_link_hash_table *vms_bfd_link_hash_table_create (bfd *abfd);
static void vms_bfd_link_hash_table_free (struct bfd_link_hash_table *hash);
static bfd_boolean vms_bfd_link_add_symbols
  (bfd *abfd, struct bfd_link_info *link_info);
static bfd_boolean vms_bfd_final_link (bfd *abfd,
				       struct bfd_link_info *link_info);
static bfd_boolean vms_bfd_link_split_section (bfd *abfd, asection *section);
static long vms_get_dynamic_symtab_upper_bound (bfd *abfd);
static long vms_canonicalize_dynamic_symtab (bfd *abfd, asymbol **symbols);
static long vms_get_dynamic_reloc_upper_bound (bfd *abfd);
static long vms_canonicalize_dynamic_reloc
  (bfd *abfd, arelent **arel, asymbol **symbols);
static bfd_boolean vms_bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
static bfd_boolean vms_bfd_set_private_flags (bfd *abfd, flagword flags);
d92 13
d187 1
a187 3
#if VMS_DEBUG
  vms_debug (6, "fill_section_ptr: sym %p, sec %p\n", sym, sec);
#endif
d227 2
a228 3
#if VMS_DEBUG
      vms_debug (7, "reading at %08lx\n", bfd_tell (abfd));
#endif
d232 1
a232 3
#if VMS_DEBUG
	  vms_debug (2, "next_record failed\n");
#endif
d240 1
a240 3
#if VMS_DEBUG
	      vms_debug (2, "vms_fixup_sections failed\n");
#endif
d284 1
a284 3
#if VMS_DEBUG
	  vms_debug (2, "slurp type %d failed with %d\n", type, err);
#endif
d352 1
a352 3
#if VMS_DEBUG
  vms_debug (1, "vms_object_p(%p)\n", abfd);
#endif
d383 1
a383 3
#if VMS_DEBUG
	  vms_debug (2, "vms_fixup_sections failed\n");
#endif
d390 1
a390 3
#if VMS_DEBUG
      vms_debug (2, "arch is vax\n");
#endif
d397 1
a397 3
#if VMS_DEBUG
      vms_debug (2, "arch is alpha\n");
#endif
a413 13
/* Check the format for a file being read.
   Return a (bfd_target *) if it's an archive file or zero.  */

static const struct bfd_target *
vms_archive_p (bfd * abfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_archive_p (%p)\n", abfd);
#endif

  return NULL;
}

d421 1
a421 3
#if VMS_DEBUG
  vms_debug (1, "vms_mkobject (%p)\n", abfd);
#endif
d446 1
a446 3
#if VMS_DEBUG
  vms_debug (1, "vms_write_object_contents (%p)\n", abfd);
#endif
d555 2
a556 3
#if VMS_DEBUG
  vms_debug (1, "vms_close_and_cleanup (%p)\n", abfd);
#endif
a588 11
/* Ask the BFD to free all cached information.  */

static bfd_boolean
vms_bfd_free_cached_info (bfd * abfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_free_cached_info (%p)\n", abfd);
#endif
  return TRUE;
}

d599 2
a600 4
#if VMS_DEBUG
  vms_debug (1, "vms_new_section_hook (%p, [%d]%s), count %d\n",
	     abfd, section->index, section->name, section_count);
#endif
d614 1
a614 3
#if VMS_DEBUG
  vms_debug (6, "section_count: %d\n", PRIV (section_count));
#endif
d618 1
a618 3
#if VMS_DEBUG
  vms_debug (7, "%d: %s\n", section->index, section->name);
#endif
d641 2
a642 4
#if VMS_DEBUG
  vms_debug (1, "vms_get_section_contents (%p, %s, %p, off %ld, size %d)\n",
		 abfd, section->name, buf, offset, (int)buf_size);
#endif
a674 271
/* Read the contents of a section.
   buf points to a buffer of buf_size bytes to be filled with
   section data (starting at offset into section).  */

static bfd_boolean
vms_get_section_contents_in_window (bfd * abfd ATTRIBUTE_UNUSED,
				    asection *section ATTRIBUTE_UNUSED,
				    bfd_window *w ATTRIBUTE_UNUSED,
				    file_ptr offset ATTRIBUTE_UNUSED,
				    bfd_size_type count ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_get_section_contents_in_window (%p, %s, %p, off %ld, count %d)\n",
		 abfd, section->name, w, offset, (int)count);
#endif

  /* Shouldn't be called, since all sections are IN_MEMORY.  */
  return FALSE;
}

/* Part 4.2, copy private data.  */

/* Called to copy BFD general private data from one object file
   to another.  */

static bfd_boolean
vms_bfd_copy_private_bfd_data (bfd *src ATTRIBUTE_UNUSED,
			       bfd *dest ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_copy_private_bfd_data (%p, %p)\n", src, dest);
#endif
  return TRUE;
}

/* Merge private BFD information from the BFD @@var{ibfd} to the
   the output file BFD @@var{obfd} when linking.  Return <<TRUE>>
   on success, <<FALSE>> on error.  Possible error returns are:

   o <<bfd_error_no_memory>> -
     Not enough memory exists to create private data for @@var{obfd}.  */

static bfd_boolean
vms_bfd_merge_private_bfd_data (bfd * ibfd ATTRIBUTE_UNUSED,
				bfd * obfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1,"vms_bfd_merge_private_bfd_data (%p, %p)\n", ibfd, obfd);
#endif
  return TRUE;
}

/* Set private BFD flag information in the BFD @@var{abfd}.
   Return <<TRUE>> on success, <<FALSE>> on error.  Possible error
   returns are:

   o <<bfd_error_no_memory>> -
     Not enough memory exists to create private data for @@var{obfd}.  */

static bfd_boolean
vms_bfd_set_private_flags (bfd * abfd ATTRIBUTE_UNUSED,
			   flagword flags ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1,"vms_bfd_set_private_flags (%p, %lx)\n", abfd, (long)flags);
#endif
  return TRUE;
}

/* Called to copy BFD private section data from one object file
   to another.  */

static bfd_boolean
vms_bfd_copy_private_section_data (bfd *srcbfd ATTRIBUTE_UNUSED,
				   asection *srcsec ATTRIBUTE_UNUSED,
				   bfd *dstbfd ATTRIBUTE_UNUSED,
				   asection *dstsec ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_copy_private_section_data (%p, %s, %p, %s)\n",
		 srcbfd, srcsec->name, dstbfd, dstsec->name);
#endif
  return TRUE;
}

/* Called to copy BFD private symbol data from one object file
   to another.  */

static bfd_boolean
vms_bfd_copy_private_symbol_data (bfd *ibfd ATTRIBUTE_UNUSED,
				  asymbol *isym ATTRIBUTE_UNUSED,
				  bfd *obfd ATTRIBUTE_UNUSED,
				  asymbol *osym ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_copy_private_symbol_data (%p, %s, %p, %s)\n",
		 ibfd, isym->name, obfd, osym->name);
#endif
  return TRUE;
}

/* Part 4.3, core file.  */

/* Return a read-only string explaining which program was running
   when it failed and produced the core file abfd.  */

static char *
vms_core_file_failing_command (bfd * abfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_core_file_failing_command (%p)\n", abfd);
#endif
  return NULL;
}

/* Returns the signal number which caused the core dump which
   generated the file the BFD abfd is attached to.  */

static int
vms_core_file_failing_signal (bfd * abfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_core_file_failing_signal (%p)\n", abfd);
#endif
  return 0;
}

/* Return TRUE if the core file attached to core_bfd was generated
   by a run of the executable file attached to exec_bfd, FALSE otherwise.  */

static bfd_boolean
vms_core_file_matches_executable_p (bfd * abfd ATTRIBUTE_UNUSED,
				    bfd *bbfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_core_file_matches_executable_p (%p, %p)\n", abfd, bbfd);
#endif
  return FALSE;
}

/* Part 4.4, archive.  */

/* ???	do something with an archive map.
   Return FALSE on error, TRUE otherwise.  */

static bfd_boolean
vms_slurp_armap (bfd * abfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_slurp_armap (%p)\n", abfd);
#endif
  return FALSE;
}

/* ???	do something with an extended name table.
   Return FALSE on error, TRUE otherwise.  */

static bfd_boolean
vms_slurp_extended_name_table (bfd * abfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_slurp_extended_name_table (%p)\n", abfd);
#endif
  return FALSE;
}

/* ???	do something with an extended name table.
   Return FALSE on error, TRUE otherwise.  */

static bfd_boolean
vms_construct_extended_name_table (bfd * abfd ATTRIBUTE_UNUSED,
				   char **tabloc ATTRIBUTE_UNUSED,
				   bfd_size_type *tablen ATTRIBUTE_UNUSED,
				   const char **name ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_construct_extended_name_table (%p)\n", abfd);
#endif
  return FALSE;
}

/* Truncate the name of an archive to match system-dependent restrictions.  */

static void
vms_truncate_arname (bfd * abfd ATTRIBUTE_UNUSED,
		     const char *pathname ATTRIBUTE_UNUSED,
		     char *arhdr ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_truncate_arname (%p, %s, %s)\n", abfd, pathname, arhdr);
#endif
}

/* ???	write archive map.  */

static bfd_boolean
vms_write_armap (bfd *arch ATTRIBUTE_UNUSED,
		 unsigned int elength ATTRIBUTE_UNUSED,
		 struct orl *map ATTRIBUTE_UNUSED,
		 unsigned int orl_count ATTRIBUTE_UNUSED,
		 int stridx ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_write_armap (%p, %d, %p, %d %d)\n",
	arch, elength, map, orl_count, stridx);
#endif
  return TRUE;
}

/* Read archive header ???  */

static void *
vms_read_ar_hdr (bfd * abfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_read_ar_hdr (%p)\n", abfd);
#endif
  return NULL;
}

/* Provided a BFD, @@var{archive}, containing an archive and NULL, open
   an input BFD on the first contained element and returns that.
   Subsequent calls should pass the archive and the previous return value
   to return a created BFD to the next contained element.
   NULL is returned when there are no more.  */

static bfd *
vms_openr_next_archived_file (bfd *arch ATTRIBUTE_UNUSED,
			      bfd *prev ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_openr_next_archived_file (%p, %p)\n", arch, prev);
#endif
  return NULL;
}

/* Return the BFD which is referenced by the symbol in ABFD indexed by
   INDEX.  INDEX should have been returned by bfd_get_next_mapent.  */

static bfd *
vms_get_elt_at_index (bfd * abfd, symindex index)
{
#if VMS_DEBUG
  vms_debug (1, "vms_get_elt_at_index (%p, %p)\n", abfd, index);
#endif
  return _bfd_generic_get_elt_at_index (abfd, index);
}

/* ???
   -> bfd_generic_stat_arch_elt.  */

static int
vms_generic_stat_arch_elt (bfd * abfd, struct stat *st)
{
#if VMS_DEBUG
  vms_debug (1, "vms_generic_stat_arch_elt (%p, %p)\n", abfd, st);
#endif
  return bfd_generic_stat_arch_elt (abfd, st);
}

/* This is a new function in bfd 2.5.  */

static bfd_boolean
vms_update_armap_timestamp (bfd * abfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_update_armap_timestamp (%p)\n", abfd);
#endif
  return TRUE;
}

d685 3
a687 3
#if VMS_DEBUG
  vms_debug (1, "vms_get_symtab_upper_bound (%p), %d symbols\n", abfd, PRIV (gsd_sym_count));
#endif
d717 1
a717 3
#if VMS_DEBUG
  vms_debug (1, "vms_canonicalize_symtab (%p, <ret>)\n", abfd);
#endif
d742 2
a743 3
#if VMS_DEBUG
  vms_debug (1, "vms_print_symbol (%p, %p, %p, %d)\n", abfd, file, symbol, how);
#endif
d785 1
a785 3
#if VMS_DEBUG
  vms_debug (1, "vms_get_symbol_info (%p, %p, %p)\n", abfd, symbol, ret);
#endif
d825 1
a825 3
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_is_local_label_name (%p, %s)\n", abfd, name);
#endif
a828 12
/* Get source line number for symbol.  */

static alent *
vms_get_lineno (bfd * abfd ATTRIBUTE_UNUSED,
		asymbol *symbol ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_get_lineno (%p, %p)\n", abfd, symbol);
#endif
  return NULL;
}

d842 2
a843 4
#if VMS_DEBUG
  vms_debug (1, "vms_find_nearest_line (%p, %s, %p, %ld, <ret>, <ret>, <ret>)\n",
	      abfd, section->name, symbols, (long int)offset);
#endif
a846 60
static bfd_boolean
vms_find_inliner_info (bfd * abfd ATTRIBUTE_UNUSED,
		       const char **file ATTRIBUTE_UNUSED,
		       const char **func ATTRIBUTE_UNUSED,
		       unsigned int *line ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_find_inliner_info (%p, <ret>, <ret>, <ret>)\n",
	     abfd);
#endif
  return FALSE;
}

/* Back-door to allow format-aware applications to create debug symbols
   while using BFD for everything else.  Currently used by the assembler
   when creating COFF files.  */

static asymbol *
vms_bfd_make_debug_symbol (bfd * abfd ATTRIBUTE_UNUSED,
			   void *ptr ATTRIBUTE_UNUSED,
			   unsigned long size ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_make_debug_symbol (%p, %p, %ld)\n", abfd, ptr, size);
#endif
  return NULL;
}

/* Read minisymbols.  For minisymbols, we use the unmodified a.out
   symbols.  The minisymbol_to_symbol function translates these into
   BFD asymbol structures.  */

static long
vms_read_minisymbols (bfd * abfd,
		      bfd_boolean dynamic,
		      void * *minisymsp,
		      unsigned int *sizep)
{
#if VMS_DEBUG
  vms_debug (1, "vms_read_minisymbols (%p, %d, %p, %d)\n", abfd, dynamic, minisymsp, *sizep);
#endif
  return _bfd_generic_read_minisymbols (abfd, dynamic, minisymsp, sizep);
}

/* Convert a minisymbol to a BFD asymbol.  A minisymbol is just an
   unmodified a.out symbol.  The SYM argument is a structure returned
   by bfd_make_empty_symbol, which we fill in here.  */

static asymbol *
vms_minisymbol_to_symbol (bfd * abfd,
			  bfd_boolean dynamic,
			  const void * minisym,
			  asymbol *sym)
{
#if VMS_DEBUG
  vms_debug (1, "vms_minisymbol_to_symbol (%p, %d, %p, %p)\n", abfd, dynamic, minisym, sym);
#endif
  return _bfd_generic_minisymbol_to_symbol (abfd, dynamic, minisym, sym);
}

d940 1
a940 3
#if VMS_DEBUG
	      vms_debug (2, "slurp relocs failed with %d\n", err);
#endif
d956 1
a956 3
#if VMS_DEBUG
      vms_debug (2, "decode relocs failed with %d\n", err);
#endif
d1318 1
a1318 3
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_reloc_type_lookup (%p, %d)\t", abfd, code);
#endif
d1341 1
a1341 3
#if VMS_DEBUG
  vms_debug (2, "reloc is %s\n", alpha_howto_table[alpha_type].name);
#endif
d1372 1
a1372 3
#if VMS_DEBUG
  vms_debug (1, "vms_set_arch_mach (%p, %d, %ld)\n", abfd, arch, mach);
#endif
a1413 189

/* Part 4.8, linker.  */

/* Get the size of the section headers.  */

static int
vms_sizeof_headers (bfd * abfd ATTRIBUTE_UNUSED,
		    struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_sizeof_headers (%p, %s)\n", abfd, (reloc)?"True":"False");
#endif
  return 0;
}

/* Provides default handling of relocation effort for back ends
   which can't be bothered to do it efficiently.  */

static bfd_byte *
vms_bfd_get_relocated_section_contents (bfd * abfd ATTRIBUTE_UNUSED,
					struct bfd_link_info *link_info ATTRIBUTE_UNUSED,
					struct bfd_link_order *link_order ATTRIBUTE_UNUSED,
					bfd_byte *data ATTRIBUTE_UNUSED,
					bfd_boolean relocatable ATTRIBUTE_UNUSED,
					asymbol **symbols ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_get_relocated_section_contents (%p, %p, %p, %p, %s, %p)\n",
	     abfd, link_info, link_order, data, (relocatable)?"True":"False", symbols);
#endif
  return NULL;
}

/* ???  */

static bfd_boolean
vms_bfd_relax_section (bfd * abfd ATTRIBUTE_UNUSED,
		       asection *section ATTRIBUTE_UNUSED,
		       struct bfd_link_info *link_info ATTRIBUTE_UNUSED,
		       bfd_boolean *again ATTRIBUTE_UNUSED)
{
  if (link_info->relocatable)
    (*link_info->callbacks->einfo)
      (_("%P%F: --relax and -r may not be used together\n"));

#if VMS_DEBUG
  vms_debug (1, "vms_bfd_relax_section (%p, %s, %p, <ret>)\n",
	     abfd, section->name, link_info);
#endif
  return TRUE;
}

static bfd_boolean
vms_bfd_gc_sections (bfd * abfd ATTRIBUTE_UNUSED,
		     struct bfd_link_info *link_info ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_gc_sections (%p, %p)\n", abfd, link_info);
#endif
  return TRUE;
}

static bfd_boolean
vms_bfd_merge_sections (bfd * abfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *link_info ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_merge_sections (%p, %p)\n", abfd, link_info);
#endif
  return TRUE;
}

/* Create a hash table for the linker.  Different backends store
   different information in this table.  */

static struct bfd_link_hash_table *
vms_bfd_link_hash_table_create (bfd * abfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_link_hash_table_create (%p)\n", abfd);
#endif
  return NULL;
}

/* Free a linker hash table.  */

static void
vms_bfd_link_hash_table_free (struct bfd_link_hash_table *hash ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_link_hash_table_free (%p)\n", abfd);
#endif
}

/* Add symbols from this object file into the hash table.  */

static bfd_boolean
vms_bfd_link_add_symbols (bfd * abfd ATTRIBUTE_UNUSED,
			  struct bfd_link_info *link_info ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_link_add_symbols (%p, %p)\n", abfd, link_info);
#endif
  return FALSE;
}

/* Do a link based on the link_order structures attached to each
   section of the BFD.  */

static bfd_boolean
vms_bfd_final_link (bfd * abfd ATTRIBUTE_UNUSED,
		    struct bfd_link_info *link_info ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_final_link (%p, %p)\n", abfd, link_info);
#endif
  return TRUE;
}

/* Should this section be split up into smaller pieces during linking.  */

static bfd_boolean
vms_bfd_link_split_section (bfd * abfd ATTRIBUTE_UNUSED,
			    asection *section ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_link_split_section (%p, %s)\n", abfd, section->name);
#endif
  return FALSE;
}

/* Part 4.9, dynamic symbols and relocations.  */

/* Get the amount of memory required to hold the dynamic symbols.  */

static long
vms_get_dynamic_symtab_upper_bound (bfd * abfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_get_dynamic_symtab_upper_bound (%p)\n", abfd);
#endif
  return 0L;
}

static bfd_boolean
vms_bfd_print_private_bfd_data (bfd * abfd ATTRIBUTE_UNUSED,
				void *file ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_bfd_print_private_bfd_data (%p)\n", abfd);
#endif
  return FALSE;
}

/* Read in the dynamic symbols.  */

static long
vms_canonicalize_dynamic_symtab (bfd * abfd ATTRIBUTE_UNUSED,
				 asymbol **symbols ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_canonicalize_dynamic_symtab (%p, <ret>)\n", abfd);
#endif
  return 0L;
}

/* Get the amount of memory required to hold the dynamic relocs.  */

static long
vms_get_dynamic_reloc_upper_bound (bfd * abfd ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_get_dynamic_reloc_upper_bound (%p)\n", abfd);
#endif
  return 0L;
}

/* Read in the dynamic relocs.  */

static long
vms_canonicalize_dynamic_reloc (bfd * abfd ATTRIBUTE_UNUSED,
				arelent **arel ATTRIBUTE_UNUSED,
				asymbol **symbols ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  vms_debug (1, "vms_canonicalize_dynamic_reloc (%p)\n", abfd);
#endif
  return 0L;
}
d1438 1
a1438 1
   vms_archive_p, _bfd_dummy_target},
d1440 1
a1440 1
   _bfd_generic_mkarchive, bfd_false},
d1442 1
a1442 1
   _bfd_write_archive_contents, bfd_false},
d1446 2
a1447 2
  BFD_JUMP_TABLE_CORE (vms),
  BFD_JUMP_TABLE_ARCHIVE (vms),
d1451 2
a1452 2
  BFD_JUMP_TABLE_LINK (vms),
  BFD_JUMP_TABLE_DYNAMIC (vms),
d1484 1
a1484 1
   vms_archive_p, _bfd_dummy_target},
d1486 1
a1486 1
   _bfd_generic_mkarchive, bfd_false},
d1488 1
a1488 1
   _bfd_write_archive_contents, bfd_false},
d1492 2
a1493 2
  BFD_JUMP_TABLE_CORE (vms),
  BFD_JUMP_TABLE_ARCHIVE (vms),
d1497 2
a1498 2
  BFD_JUMP_TABLE_LINK (vms),
  BFD_JUMP_TABLE_DYNAMIC (vms),
@


1.50
log
@2009-09-01  Tristan Gingold  <gingold@@adacore.com>

	* makefile.vms: Ported to Itanium VMS.  Remove useless variable and
	dependencies.  Reindent.
	* configure.com: Ported to Itanium VMS.  Now generates a build.com
	to build without make.  Add messages but make edit silent.
	* hosts/alphavms.h: Add a prototype for stpcpy.
	* vms.c: Add a missing include for Alpha VMS.
	* elfxx-ia64.c (ELF_OSABI): Define for OpenVMS.
@
text
@d143 2
@


1.49
log
@Fix a nit.

2009-06-23  Tristan Gingold  <gingold@@adacore.com>

	* vms.c (vms_get_synthetic_symtab): Remove duplicate definition
	of this macro.  Fix indentation.
@
text
@d27 1
@


1.48
log
@	bfd/
	* elf32-ppc.c (ppc_elf_relax_section): Work with a partial
	link.
	* bout.c (b_out_bfd_relax_section): Reject relocatable links.
	* elf32-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-avr.c (elf32_avr_relax_section): Likewise.
	* elf32-frv.c (elf32_avr_relax_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relax_section): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relax_section): Likewise.
	* reloc.c (bfd_generic_relax_section): Likewise.
	* reloc16.c (bfd_coff_reloc16_relax_section): Likewise.
	* vms.c (vms_bfd_relax_section): Likewise.

	ld/
	* ldmain.c (main): Don't reject --relax -r.
	* ld.texinfo (PowerPC ELF32): Document behaviour of relaxing
	partial links.

	ld/testsuite/
	* ld-powerpc/vxworks-relax-2.s: New.
	* ld-powerpc/vxworks-relax-2.rd: New.
	* ld-powerpc/powerpc.exp: Add it.
@
text
@d132 1
a132 3
static long vms_canonicalize_dynamic_symtab
  (bfd *abfd, asymbol **symbols);
#define vms_get_synthetic_symtab _bfd_nodynamic_get_synthetic_symtab
@


1.47
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d1917 4
@


1.46
log
@2009-02-23  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Update copyright year, fix comments, reorder declarations.
	(_bfd_save_vms_section): Remove the prototype.
	(EGPS_S_V_NO_SHIFT): New constant.
	(bfd_vms_set_section_flags): New prototype.
	(EGPS_S_B_ALIGN, EGPS_S_W_FLAGS, EGPS_S_L_ALLOC, EGPS_S_B_NAMLNG): New
	constants.
	(EGSY_S_W_FLAGS): Ditto.
	(EGSY_S_V_QUAD_VAL): Ditto.
	(ESDF_S_L_VALUE, ESDF_S_L_PSINDX, ESDF_S_B_NAMLNG): Ditto.
	(EGST_S_W_FLAGS, EGST_S_Q_LP_1, EGST_S_Q_LP_2, EGST_S_L_PSINDX,
	EGST_S_B_NAMLNG): Ditto.
	(ESRF_S_B_NAMLNG): Ditto.
	(ETIR_S_C_HEADER_SIZE): Ditto.
	(EGPS_S_V_ALLOC_64BIT): Ditto.
	(DST_S_C_EPILOG): Ditto.
	(DST_S_C_SRC_SETLNUM_L, DST_S_C_SRC_SETLNUM_W) : Ditto.
	(DST_S_C_SRC_INCRLNUM_B): Ditto.
	(DST_S_B_PCLINE_UNSBYTE, DST_S_W_PCLINE_UNSWORD): Ditto.
	(DST_S_L_PCLINE_UNSLONG): Ditto.
	(DST_S_B_MODBEG_NAME, DST_S_L_RTNBEG_ADDRESS) : Ditto
	(DST_S_B_RTNBEG_NAME, DST_S_L_RTNEND_SIZE): Ditto
	(DST_S_C_SOURCE_HEADER_SIZE): Ditto.
	(DST_S_B_SRC_DF_LENGTH, DST_S_W_SRC_DF_FILEID): Ditto.
	(DST_S_B_SRC_DF_FILENAME, DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_W_SRC_UNSWORD, DST_S_L_SRC_UNSLONG): Ditto.
	Add prototypes.
	(vms_section, vms_reloc): Remove types.
	(hdr_struc): Replaced by ...
	(hdr_struct): ... new type.
	(EMH_S_W_HDRTYP, EMH_S_B_STRLVL, EMH_S_L_ARCH1): New constants.
	(EMH_S_L_ARCH2, EMH_S_L_RECSIZ, EMH_S_B_NAMLNG): Ditto.
	(EMH_DATE_LENGTH): Ditto.
	(eom_struc): Replaced by ...
	(eom_struct): ... new type.
	(EEOM_S_L_TOTAL_LPS, EEOM_S_W_COMCOD, EEOM_S_B_TFRFLG): New constants.
	(EEOM_S_L_PSINDX, EEOM_S_L_TFRADR): Ditto.
	(EIHD_S_K_MAJORID, EIHD_S_K_MINORID, EIHD_S_K_EXE): Ditto.
	(EIHD_S_L_SIZE, EIHD_S_L_ISDOFF, EIHD_S_L_SYMDBGOFF): Ditto.
	(EIHD_S_Q_SYMVVA, EIHD_S_L_IMGTYPE): Ditto.
	(EISD_S_L_EISDSIZE, EISD_S_L_SECSIZE, EISD_S_Q_VIR_ADDR): Ditto.
	(EISD_S_L_FLAGS, EISD_S_L_VBN, EISD_S_R_CONTROL): Ditto.
	(EISD_S_L_IDENT, EISD_S_T_GBLNAM): Ditto.
	(EISD_S_M_GBL, EISD_S_M_CRF, EISD_S_M_DZRO, EISD_S_M_WRT): Ditto.
	(EISD_S_M_INITALCODE, EISD_S_M_BASED, EISD_S_M_FIXUPVEC): Ditto.
	(EISD_S_M_RESIDENT, EISD_S_M_VECTOR, EISD_S_M_PROTECT): Ditto.
	(EISD_S_M_LASTCLU, EISD_S_M_EXE, EISD_S_M_NONSHRADR): Ditto.
	(EISD_S_M_QUAD_LENGTH, EISD_S_M_ALLOC_64BIT): Ditto.
	(EIHS_S_L_DSTVBN, EIHS_S_L_DSTSIZE, EIHS_S_L_GSTVBN): Ditto.
	(EIHS_S_L_GSTSIZE, EIHS_S_L_DMTVBN, EIHS_S_L_DMTBYTES): Ditto.
	(DBG_S_L_DMT_MODBEG, DBG_S_L_DST_SIZE): Ditto.
	(DBG_S_W_DMT_PSECT_COUNT, DBG_S_C_DMT_HEADER_SIZE): Ditto.
	(DBG_S_L_DMT_PSECT_START, DBG_S_L_DMT_PSECT_LENGTH)
	(DBG_S_C_DMT_PSECT_SIZE): Ditto.
	(enum file_type_enum): New type.
	(struct location_struct): Removed.
	(struct fileinfo, struct srecinfo, struct lineinfo): New types.
	(struct funcinfo, struct module): Ditto.
	(struct vms_private_data_struct): Update fields.
	(struct vms_section_data_struct): New type.

	* vms.c: Update copyright year, fix comments,
	Fix includes for DECC, add prototypes.
	(vms_initialize): Use bfd_alloc instead of bfd_zalloc and remove
	some initializers.
	Use flavour to set is_vax, location_stack is removed.
	(struct pair): Declare.
	(fill_section_ptr): Initialize variables at declaration.
	Add guard to set SECTION_SYM flag, handlde und section.
	(vms_fixup_sections): Use struct pair for fill_section_ptr argument.
	(_bfd_vms_slurp_object_records): New function, replaces previous
	vms_object_p.
	(vms_slurp_module): New function.
	(vms_slurp_image): Ditto.
	(vms_object_p): Complete rewrite.
	(vms_mkobject): Use is_vax field to slect architecture.
	(free_reloc_stream): New function.
	(vms_convert_to_var): Ditto.
	(vms_convert_to_var_1): Ditto.
	(vms_convert_to_var_unix_filename): Ditto.
	(vms_close_and_cleanup): Call free_reloc_stream, convert file to
	VAR format on VMS.
	(vms_new_section_hook): Set alignment to 0, allocate private data.
	(vms_get_section_contents): Load content.
	(vms_get_symbol_info): Handle undefined section.
	(vms_find_nearest_line): Handle.
	(alloc_reloc_stream): New function.
	(vms_slurp_reloc_table): Ditto.
	(vms_get_reloc_upper_bound): Make it real.
	(vms_canonicalize_reloc): Do the real work.
	(alpha_howto_table): Add ALPHA_R_NOP, ALPHA_R_BSR, ALPHA_R_LDA,
	ALPHA_R_BOH.
	(vms_bfd_reloc_type_lookup): Handle NOP, BSR, LDA and BOH.
	(vms_set_arch_mach): Check arch.
	(vms_set_section_contents): Copy the content after allocation.
	(vms_alpha_vec): Update object flags.

	* vms-tir.c: Update copyright year, fix comments,
	add prototypes for new functions.
	(dst_define_location): New function.
	(dst_restore_location): New function.
	(dst_retrieve_location): New function.
	(dst_check_allocation): New function.
	(image_dump): Call dst_check_allocation.
	(image_write_b): Ditto.
	(image_write_w): Ditto.
	(image_write_l): Ditto.
	(image_write_q): Ditto.
	(cmd_name): Handle STA_LW, STA_QW, STO_OFF, STO_IMM, STO_IMMR, STO_LW,
	STO_QW, OPR_ADD, CTL_SETRB, STC_LP_PSB, CTL_DFLOC, CTL_STLOC,
	CTL_STKDL.
	Call error handler instead of abort if name is not known.
	(etir_sta): Add quarter_relocs argument and set it.
	Fix cast.
	(etir_sto): Ditto.
	(etir_opr): Ditto, return FALSE in case of error.
	(etir_ctl): Add quarter_relocs argument and set it, fix cast.
	Fix CTL_DFLOC, CTL_STLOC, CTL_STKDL.
	(etir_stc): Add quarter_relocs argument and set it, fix cast.
	Fix STC_LP, STC_LP_PSB, STC_GBL and STC_CGA.
	Handle STC_LP_PSB, STC_BSR_GBL, STC_LDA_GBL, STC_BOH_GBL.
	Move STC_NOP_PS, STC_BSR_PS, STC_LDA_PS, STC_BOH_PS, STC_NBH_PS.
	Return FALSE in case of error.
	(tir_sta): Change sign of psect.
	(tir_ctl): Ditto.
	(tir_cmd): Fix cast. Makes tir_table static const.
	(etir_cmd): Add quarter_relocs argument, makes etir_table const,
	add argument to explain.
	(analyze_etir): Initialize maxptr, add quarter_relocs
	declaration, move some declarations into inner scopes.
	Handle quarter_relocs and STO_IMM.
	(_bfd_vms_slurp_tir): Use constant instead of hard-coded values.
	(_bfd_vms_slurp_relocs): New function.
	(_bfd_vms_decode_relocs): New function.
	(sto_imm): Rewritten.
	(start_first_etbt_record): New function.
	(start_another_etbt_record): Ditto.
	(etir_output_check): Ditto.
	(defer_reloc_p): Ditto.
	(_bfd_vms_write_tir): Remove nextoffset, convert a while-loop to
	a for-loop.  Correctly deals with contents, deals with .vmsdebug,
	rewritte relocations handling.
	(_bfd_vms_write_tbt): Removed.
	(_bfd_vms_write_dbg): Ditto.

	* vms-misc.c: Update copyright year, Fix comments.
	(_bfd_vms_get_header_values): Use 'size' instead of 'length'.
	(maybe_adjust_record_pointer_for_object): New function.
	(_bfd_vms_get_first_record): New function, replaces ...
	(_bfd_vms_get_record): ..  removed.
	(_bfd_vms_get_object_record): New function.
	(_bfd_vms_get_object_record): New function.
	(vms_get_remaining_object_record): New function, replaces ...
	(_bfd_vms_get_next_record): ... removed.
	(add_new_contents): Removed.
	(_bfd_save_vms_section): Removed.
	(_bfd_get_vms_section): Removed.
	(_bfd_vms_output_flush): Write in VAR format.
	(new_symbol): Don't make UND section.

	* vms-hdr.c: Update copyright year, update list of record handled.
	(_bfd_vms_slurp_hdr): rec_length renamed to rec_size.
	(_bfd_vms_write_hdr): Strip vms and unix patches,
	add comments, truncate module name at 31 characters,
	use constants instead of hard-coded value,
	write BFD version instead of a fixed string.
	(_bfd_vms_slurp_ihd): New function.
	(_bfd_vms_slurp_isd): Ditto.
	(_bfd_vms_slurp_ihs): Ditto.
	(new_module): Ditto.
	(parse_module): Ditto
	(build_module_list): Ditto.
	(module_find_nearest_line): Ditto.
	(_bfd_vms_find_nearest_dst_line): Ditto.
	(vms_slurp_debug): Ditto.
	(_bfd_vms_slurp_dbg): Ditto.
	(_bfd_vms_slurp_tbt): Ditto.
	(_bfd_vms_write_dbg): Ditto.
	(_bfd_vms_write_tbt): Ditto.

	* vms-gsd.c: Update copyright year, update list of records handled.
	(EVAX_LITERALS_NAME): New macro.
	(evax_section_flags): Add an entry for EVAX_LITERALS_NAME.
	(gpsflagdesc, gsyflagdesc): Moved out of _bfd_vms_slurp_gsd.
	(register_universal_symbol): New function and prototype.
	(_bfd_vms_slurp_gsd): Fix indentations and casts,
	improve debug messages,
	use constants instead of hard-coded value,
	fix missing endianness conversion,
	handle global symbol (SYMG).
	(bfd_vms_set_section_flags): New function.
	(_bfd_vms_write_gsd): Don't write .vmsdebug section,
	handle section literals,
	fix indentation,
	handle section bfd and vms flags,
	don't output LIB$INITIALIZE symbol,
	fix handling of weak symbols,
	fix evax vs vax procedure descriptor,
	handle absolute symbols.

	* reloc.c (BFD_RELOC_ALPHA_NOP, BFD_RELOC_ALPHA_BSR,
	BFD_RELOC_ALPHA_LDA, BFD_RELOC_ALPHA_BOH): New relocations.

	* makefile.vms (DEFS): Fix flags for VMS.

	* bfdio.c (real_fopen): Handle multiple VMS fopen attributes.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Regenerated.
@
text
@d147 1
@


1.45
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@d4 3
a6 1
   2006, 2007, 2008 Free Software Foundation, Inc.
d25 7
d39 102
d150 7
a156 1
static unsigned int priv_section_count;
a158 2

/* Initialize private data.  */
d160 1
a163 1
  int i;
d169 1
a169 1
  abfd->tdata.any = bfd_alloc (abfd, amt);
d173 3
a175 8
#ifdef __ALPHA
  PRIV (is_vax) = FALSE;
#else
  PRIV (is_vax) = TRUE;
#endif
  PRIV (vms_buf) = NULL;
  PRIV (buf_size) = 0;
  PRIV (rec_length) = 0;
a176 2
  PRIV (fixup_done) = FALSE;
  PRIV (sections) = NULL;
a181 1
  PRIV (stackptr) = 0;
a191 8
  amt = sizeof (struct location_struct) * LOCATION_SAVE_SIZE;
  PRIV (location_stack) = bfd_alloc (abfd, amt);
  if (PRIV (location_stack) == NULL)
    goto error_ret2;

  for (i = 0; i < VMS_SECTION_COUNT; i++)
    PRIV (vms_section_table)[i] = NULL;

a196 2
  PRIV (push_level) = 0;
  PRIV (pushed_size) = 0;
a197 2
  PRIV (output_size) = 0;
  PRIV (output_alignment) = 1;
d209 8
a216 1
/* Fill symbol->section with section ptr
d218 1
a218 1
   during reading the GSD/EGSD section. But we need the pointer to the
d221 1
a221 1
   It has the correct value for referenced (undefined section) symbols
d223 1
a223 1
   called from bfd_hash_traverse in vms_fixup_sections.  */
d226 1
a226 1
fill_section_ptr (struct bfd_hash_entry * entry, void * sections)
d228 3
a230 5
  asection *sec;
  asymbol *sym;

  sym = ((vms_symbol_entry *) entry)->symbol;
  sec = sym->section;
d236 3
a238 7
  /* Fill forward references (these contain section number, not section ptr).  */
  if ((unsigned int) (size_t) sec < priv_section_count)
    sec = ((vms_symbol_entry *) entry)->symbol->section =
      ((asection **) sections)[(unsigned int) (size_t) sec];

  if (strcmp (sym->name, sec->name) == 0)
    sym->flags |= BSF_SECTION_SYM;
d240 6
d249 1
a249 9
/* Fixup sections
   set up all pointers and arrays, counters and sizes are fixed now

   we build a private sections vector for easy access since sections
   are always referenced by an index number.

   alloc PRIV(sections) according to abfd->section_count
	copy abfd->sections to PRIV(sections).  */

d253 2
d258 3
a260 5
  /* Traverse symbol table and fill in all section pointers.  */

  /* Can't provide section count as argument to fill_section_ptr().  */
  priv_section_count = PRIV (section_count);
  bfd_hash_traverse (PRIV (vms_symbol_table), fill_section_ptr, (PRIV (sections)));
a262 1

a264 3

/* Check the format for a file being read.
   Return a (bfd_target *) if it's an object file or zero if not.  */
d266 3
a268 2
static const struct bfd_target *
vms_object_p (bfd * abfd)
d270 1
a270 18
  int err = 0;
  int prev_type;
  const struct bfd_target *target_vector = NULL;
  const bfd_arch_info_type *arch = NULL;
  void * tdata_save = abfd->tdata.any;
  bfd_vma saddr_save = bfd_get_start_address (abfd);

#if VMS_DEBUG
  vms_debug (1, "vms_object_p (%p)\n", abfd);
#endif

  if (!vms_initialize (abfd))
    goto error_ret;

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET))
    goto err_wrong_format;

  prev_type = -1;
d277 2
a278 1
      if (_bfd_vms_next_record (abfd) < 0)
d283 1
a283 1
	  goto err_wrong_format;
d286 1
a286 2
      if ((prev_type == EOBJ_S_C_EGSD)
	   && (PRIV (rec_type) != EOBJ_S_C_EGSD))
d293 1
a293 1
	      goto err_wrong_format;
d297 1
a297 9
      prev_type = PRIV (rec_type);

      if (target_vector == NULL)
	{
	  if (prev_type <= OBJ_S_C_MAXRECTYP)
	    target_vector = & vms_vax_vec;
	  else
	    target_vector = & vms_alpha_vec;
	}
d299 1
a299 1
      switch (prev_type)
d303 1
a303 1
	    err = _bfd_vms_slurp_hdr (abfd, prev_type);
d308 1
a308 1
	    err = _bfd_vms_slurp_eom (abfd, prev_type);
d312 1
a312 1
	    err = _bfd_vms_slurp_gsd (abfd, prev_type);
d316 1
a316 1
	    err = _bfd_vms_slurp_tir (abfd, prev_type);
d320 2
a321 1
	    err = _bfd_vms_slurp_dbg (abfd, prev_type);
d325 2
a326 1
	    err = _bfd_vms_slurp_tbt (abfd, prev_type);
d329 1
a329 1
	    err = _bfd_vms_slurp_lnk (abfd, prev_type);
d337 1
a337 1
	  vms_debug (2, "slurp type %d failed with %d\n", prev_type, err);
d339 1
a339 1
	  goto err_wrong_format;
d342 92
a433 1
  while ((prev_type != EOBJ_S_C_EEOM) && (prev_type != OBJ_S_C_EOM) && (prev_type != OBJ_S_C_EOMW));
d435 1
a435 1
  if (target_vector == & vms_vax_vec)
d445 2
a446 1
      /* Set arch_info to vax.  */
a447 2
      arch = bfd_scan_arch ("vax");
      PRIV (is_vax) = TRUE;
d452 1
a452 1
  else if (target_vector == & vms_alpha_vec)
d455 1
a455 1

a456 1
      PRIV (is_vax) = FALSE;
a461 7
  if (arch == NULL)
    {
#if VMS_DEBUG
      vms_debug (2, "arch not found\n");
#endif
      goto err_wrong_format;
    }
a462 1

d467 1
d494 2
d503 10
a512 13
  {
#ifdef __VAX
    const bfd_arch_info_type *arch = bfd_scan_arch ("vax");
#else
    const bfd_arch_info_type *arch = bfd_scan_arch ("alpha");
#endif
    if (arch == NULL)
      {
	bfd_set_error (bfd_error_wrong_format);
	return FALSE;
      }
    abfd->arch_info = arch;
  }
d514 1
d573 56
d637 1
a637 2
  if (abfd == NULL
      || abfd->tdata.any == NULL)
d649 2
d654 12
d685 2
d694 2
a695 1
  bfd_set_section_alignment (abfd, section, 4);
d706 1
d710 1
d712 1
d717 5
d736 2
d743 29
a771 2
  /* Shouldn't be called, since all sections are IN_MEMORY.  */
  return FALSE;
a964 1
  return;
d1167 3
a1169 1
  if (bfd_is_com_section (sec))
d1235 1
a1235 1
  return FALSE;
d1300 26
a1325 3
/* Return the number of bytes required to store the relocation information
   associated with section sect attached to bfd abfd.
   If an error occurs, return -1.  */
d1327 24
a1350 3
static long
vms_get_reloc_upper_bound (bfd * abfd ATTRIBUTE_UNUSED,
			   asection *section ATTRIBUTE_UNUSED)
d1352 39
d1392 1
a1392 1
  vms_debug (1, "vms_get_reloc_upper_bound (%p, %s)\n", abfd, section->name);
d1394 37
a1430 1
  return -1L;
d1433 2
a1434 5
/* Call the back end associated with the open BFD abfd and translate the
   external form of the relocation information attached to sec into the
   internal canonical form.  Place the table into memory at loc, which has
   been preallocated, usually by a call to bfd_get_reloc_upper_bound.
   Returns the number of relocs, or -1 on error.  */
d1437 2
a1438 4
vms_canonicalize_reloc (bfd * abfd ATTRIBUTE_UNUSED,
			asection *section ATTRIBUTE_UNUSED,
			arelent **location ATTRIBUTE_UNUSED,
			asymbol **symbols ATTRIBUTE_UNUSED)
d1440 14
a1453 4
#if VMS_DEBUG
  vms_debug (1, "vms_canonicalize_reloc (%p, %s, <ret>, <ret>)\n", abfd, section->name);
#endif
  return FALSE;
d1704 58
d1790 4
a1833 1
  abfd->arch_info = bfd_scan_arch ("alpha");
d1835 6
a1840 1
  return TRUE;
d1844 2
a1845 2
   in memory at data. The data is written to the output section starting at
   offset offset for count bytes.
d1864 10
a1873 1
  return _bfd_save_vms_section (abfd, section, location, offset, count);
d2012 1
a2012 1
  return 0;
d2068 1
a2068 1
  (HAS_RELOC | HAS_SYMS
d2073 3
a2075 3
  0,				/* Symbol_leading_char.  */
  ' ',				/* AR_pad_char.  */
  15,				/* AR_max_namelen.  */
d2102 1
a2102 1
  NULL
d2119 3
a2121 3
  0,				/* Symbol_leading_char.  */
  ' ',				/* AR_pad_char.  */
  15,				/* AR_max_namelen.  */
d2127 1
a2127 1
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* Headers.  */
d2148 1
a2148 1
  NULL
@


1.44
log
@PR binutils/5535
   * vms.c (vms_close_and_cleanup): Check for the presence of a
   vms_private_data_struct before examining any of its fields.
@
text
@d4 1
a4 1
   2006, 2007 Free Software Foundation, Inc.
d479 1
a479 1
      PRIV (sections) = bfd_realloc (PRIV (sections), amt);
@


1.43
log
@Switch sources over to use the GPL version 3
@
text
@d431 2
a432 1
  if (abfd == NULL)
@


1.42
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.41
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d22 1
a23 1
#include "sysdep.h"
@


1.40
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d4 1
a4 1
   2006 Free Software Foundation, Inc.
d1356 16
@


1.39
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d1405 1
a1405 1
		    bfd_boolean reloc ATTRIBUTE_UNUSED)
@


1.38
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d490 1
a490 1
  return TRUE;
@


1.37
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d80 2
a81 1
  if (!bfd_hash_table_init (PRIV (vms_symbol_table), _bfd_vms_hash_newfunc))
@


1.36
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d975 13
@


1.35
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.34
log
@Update to ISO-C90 and fix formatting
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.33
log
@	* coffcode.h (coff_print_aux): Warning fix.
	* elf-m10300.c (mn10300_elf_relax_section): Use section->id
	instead of section pointer to identify.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.  Allocate
	the correct size buffer for local sym mangling too.
	(h8300_bfd_link_add_symbols): Likewise.
	* elf32-sh-symbian.c (sh_symbian_process_embedded_commands): Fix
	warning.
	* elf32-sh64.c (shmedia_prepare_reloc): Use %B and %p in error message
	* elf32-xtensa.c (literal_value_hash): Warning fix.
	* versados.c (process_otr): Warning fix.
	(versados_canonicalize_reloc): Likewise.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Warning fix.
	* vms.c (fill_section_ptr): Warning fix.
@
text
@d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a28 138
static bfd_boolean vms_initialize
  PARAMS ((bfd *));
static unsigned int priv_section_count;
static bfd_boolean fill_section_ptr
  PARAMS ((struct bfd_hash_entry *, PTR));
static bfd_boolean vms_fixup_sections
  PARAMS ((bfd *));
static bfd_boolean copy_symbols
  PARAMS ((struct bfd_hash_entry *, PTR));
static bfd_reloc_status_type reloc_nil
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static const struct bfd_target *vms_object_p
  PARAMS ((bfd *abfd));
static const struct bfd_target *vms_archive_p
  PARAMS ((bfd *abfd));
static bfd_boolean vms_mkobject
  PARAMS ((bfd *abfd));
static bfd_boolean vms_write_object_contents
  PARAMS ((bfd *abfd));
static bfd_boolean vms_close_and_cleanup
  PARAMS ((bfd *abfd));
static bfd_boolean vms_bfd_free_cached_info
  PARAMS ((bfd *abfd));
static bfd_boolean vms_new_section_hook
  PARAMS ((bfd *abfd, asection *section));
static bfd_boolean vms_get_section_contents
  PARAMS ((bfd *abfd, asection *section, PTR x1, file_ptr x2,
	   bfd_size_type x3));
static bfd_boolean vms_get_section_contents_in_window
  PARAMS ((bfd *abfd, asection *section, bfd_window *w, file_ptr offset,
	   bfd_size_type count));
static bfd_boolean vms_bfd_copy_private_bfd_data
  PARAMS ((bfd *src, bfd *dest));
static bfd_boolean vms_bfd_copy_private_section_data
  PARAMS ((bfd *srcbfd, asection *srcsec, bfd *dstbfd, asection *dstsec));
static bfd_boolean vms_bfd_copy_private_symbol_data
  PARAMS ((bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym));
static bfd_boolean vms_bfd_print_private_bfd_data
  PARAMS ((bfd *abfd, void *file));
static char *vms_core_file_failing_command
  PARAMS ((bfd *abfd));
static int vms_core_file_failing_signal
  PARAMS ((bfd *abfd));
static bfd_boolean vms_core_file_matches_executable_p
  PARAMS ((bfd *abfd, bfd *bbfd));
static bfd_boolean vms_slurp_armap
  PARAMS ((bfd *abfd));
static bfd_boolean vms_slurp_extended_name_table
  PARAMS ((bfd *abfd));
static bfd_boolean vms_construct_extended_name_table
  PARAMS ((bfd *abfd, char **tabloc, bfd_size_type *tablen,
	   const char **name));
static void vms_truncate_arname
  PARAMS ((bfd *abfd, const char *pathname, char *arhdr));
static bfd_boolean vms_write_armap
  PARAMS ((bfd *arch, unsigned int elength, struct orl *map,
	   unsigned int orl_count, int stridx));
static PTR vms_read_ar_hdr
  PARAMS ((bfd *abfd));
static bfd *vms_get_elt_at_index
  PARAMS ((bfd *abfd, symindex index));
static bfd *vms_openr_next_archived_file
  PARAMS ((bfd *arch, bfd *prev));
static bfd_boolean vms_update_armap_timestamp
  PARAMS ((bfd *abfd));
static int vms_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static long vms_get_symtab_upper_bound
  PARAMS ((bfd *abfd));
static long vms_canonicalize_symtab
  PARAMS ((bfd *abfd, asymbol **symbols));
static void vms_print_symbol
  PARAMS ((bfd *abfd, PTR file, asymbol *symbol, bfd_print_symbol_type how));
static void vms_get_symbol_info
  PARAMS ((bfd *abfd, asymbol *symbol, symbol_info *ret));
static bfd_boolean vms_bfd_is_local_label_name
  PARAMS ((bfd *abfd, const char *));
static alent *vms_get_lineno
  PARAMS ((bfd *abfd, asymbol *symbol));
static bfd_boolean vms_find_nearest_line
  PARAMS ((bfd *abfd, asection *section, asymbol **symbols, bfd_vma offset,
	   const char **file, const char **func, unsigned int *line));
static asymbol *vms_bfd_make_debug_symbol
  PARAMS ((bfd *abfd, void *ptr, unsigned long size));
static long vms_read_minisymbols
  PARAMS ((bfd *abfd, bfd_boolean dynamic, PTR *minisymsp,
	   unsigned int *sizep));
static asymbol *vms_minisymbol_to_symbol
  PARAMS ((bfd *abfd, bfd_boolean dynamic, const PTR minisym, asymbol *sym));
static long vms_get_reloc_upper_bound
  PARAMS ((bfd *abfd, asection *sect));
static long vms_canonicalize_reloc
  PARAMS ((bfd *abfd, asection *srcsec, arelent **location,
	   asymbol **symbols));
static const struct reloc_howto_struct *vms_bfd_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
static bfd_boolean vms_set_arch_mach
  PARAMS ((bfd *abfd, enum bfd_architecture arch, unsigned long mach));
static bfd_boolean vms_set_section_contents
  PARAMS ((bfd *abfd, asection *section, const PTR location, file_ptr offset,
	   bfd_size_type count));
static int vms_sizeof_headers
  PARAMS ((bfd *abfd, bfd_boolean reloc));
static bfd_byte *vms_bfd_get_relocated_section_contents
  PARAMS ((bfd *abfd, struct bfd_link_info *link_info,
	   struct bfd_link_order *link_order, bfd_byte *data,
	   bfd_boolean relocatable, asymbol **symbols));
static bfd_boolean vms_bfd_relax_section
  PARAMS ((bfd *abfd, asection *section, struct bfd_link_info *link_info,
	   bfd_boolean *again));
static bfd_boolean vms_bfd_gc_sections
  PARAMS ((bfd *abfd, struct bfd_link_info *link_info));
static bfd_boolean vms_bfd_merge_sections
  PARAMS ((bfd *abfd, struct bfd_link_info *link_info));
static struct bfd_link_hash_table *vms_bfd_link_hash_table_create
  PARAMS ((bfd *abfd));
static void vms_bfd_link_hash_table_free
  PARAMS ((struct bfd_link_hash_table *hash));
static bfd_boolean vms_bfd_link_add_symbols
  PARAMS ((bfd *abfd, struct bfd_link_info *link_info));
static bfd_boolean vms_bfd_final_link
  PARAMS ((bfd *abfd, struct bfd_link_info *link_info));
static bfd_boolean vms_bfd_link_split_section
  PARAMS ((bfd *abfd, asection *section));
static long vms_get_dynamic_symtab_upper_bound
  PARAMS ((bfd *abfd));
static long vms_canonicalize_dynamic_symtab
  PARAMS ((bfd *abfd, asymbol **symbols));
#define vms_get_synthetic_symtab _bfd_nodynamic_get_synthetic_symtab
static long vms_get_dynamic_reloc_upper_bound
  PARAMS ((bfd *abfd));
static long vms_canonicalize_dynamic_reloc
  PARAMS ((bfd *abfd, arelent **arel, asymbol **symbols));
static bfd_boolean vms_bfd_merge_private_bfd_data
  PARAMS ((bfd *ibfd, bfd *obfd));
static bfd_boolean vms_bfd_set_private_flags
  PARAMS ((bfd *abfd, flagword flags));

d30 7
a36 10
#define vms_make_empty_symbol _bfd_generic_make_empty_symbol
#define vms_bfd_link_just_syms _bfd_generic_link_just_syms
#define vms_bfd_is_group_section bfd_generic_is_group_section
#define vms_bfd_discard_group bfd_generic_discard_group
#define vms_section_already_linked \
  _bfd_generic_section_already_linked
#define vms_bfd_copy_private_header_data \
  _bfd_generic_bfd_copy_private_header_data

/*===========================================================================*/
d38 3
a40 89
const bfd_target vms_alpha_vec =
{
  "vms-alpha",			/* name */
  bfd_target_evax_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */

  (HAS_RELOC | HAS_SYMS
   | WP_TEXT | D_PAGED),	/* object flags */
  (SEC_ALLOC | SEC_LOAD | SEC_RELOC
   | SEC_READONLY | SEC_CODE | SEC_DATA
   | SEC_HAS_CONTENTS | SEC_IN_MEMORY),		/* sect flags */
  0,				/* symbol_leading_char */
  ' ',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16,
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16,

  {_bfd_dummy_target, vms_object_p,		/* bfd_check_format */
   vms_archive_p, _bfd_dummy_target},
  {bfd_false, vms_mkobject,			/* bfd_set_format */
   _bfd_generic_mkarchive, bfd_false},
  {bfd_false, vms_write_object_contents,	/* bfd_write_contents */
   _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (vms),
  BFD_JUMP_TABLE_COPY (vms),
  BFD_JUMP_TABLE_CORE (vms),
  BFD_JUMP_TABLE_ARCHIVE (vms),
  BFD_JUMP_TABLE_SYMBOLS (vms),
  BFD_JUMP_TABLE_RELOCS (vms),
  BFD_JUMP_TABLE_WRITE (vms),
  BFD_JUMP_TABLE_LINK (vms),
  BFD_JUMP_TABLE_DYNAMIC (vms),

  NULL,

  (PTR) 0
};

const bfd_target vms_vax_vec =
{
  "vms-vax",			/* name */
  bfd_target_ovax_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */

  (HAS_RELOC | HAS_SYMS 	/* object flags */
   | WP_TEXT | D_PAGED
   | HAS_LINENO | HAS_DEBUG | HAS_LOCALS),

  (SEC_ALLOC | SEC_LOAD | SEC_RELOC
   | SEC_READONLY | SEC_CODE | SEC_DATA
   | SEC_HAS_CONTENTS | SEC_IN_MEMORY),		/* sect flags */
  0,				/* symbol_leading_char */
  ' ',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */

  {_bfd_dummy_target, vms_object_p,		/* bfd_check_format */
   vms_archive_p, _bfd_dummy_target},
  {bfd_false, vms_mkobject,			/* bfd_set_format */
   _bfd_generic_mkarchive, bfd_false},
  {bfd_false, vms_write_object_contents,	/* bfd_write_contents */
   _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (vms),
  BFD_JUMP_TABLE_COPY (vms),
  BFD_JUMP_TABLE_CORE (vms),
  BFD_JUMP_TABLE_ARCHIVE (vms),
  BFD_JUMP_TABLE_SYMBOLS (vms),
  BFD_JUMP_TABLE_RELOCS (vms),
  BFD_JUMP_TABLE_WRITE (vms),
  BFD_JUMP_TABLE_LINK (vms),
  BFD_JUMP_TABLE_DYNAMIC (vms),

  NULL,

  (PTR) 0
};
d42 1
a42 3
/*===========================================================================*/

/* Initialize private data  */
d45 1
a45 2
vms_initialize (abfd)
     bfd *abfd;
d53 2
a54 2
  abfd->tdata.any = (struct vms_private_data_struct*) bfd_alloc (abfd, amt);
  if (abfd->tdata.any == 0)
d58 1
a58 1
  PRIV (is_vax) = 0;
d60 1
a60 1
  PRIV (is_vax) = 1;
d62 1
a62 1
  PRIV (vms_buf) = 0;
d70 2
a71 2
  PRIV (stack) = (struct stack_struct *) bfd_alloc (abfd, amt);
  if (PRIV (stack) == 0)
d76 2
a77 2
  PRIV (vms_symbol_table) = (struct bfd_hash_table *) bfd_alloc (abfd, amt);
  if (PRIV (vms_symbol_table) == 0)
d84 2
a85 2
  PRIV (location_stack) = (struct location_struct *) bfd_alloc (abfd, amt);
  if (PRIV (location_stack) == 0)
d92 2
a93 2
  PRIV (output_buf) = (unsigned char *) bfd_alloc (abfd, amt);
  if (PRIV (output_buf) == 0)
d108 1
a108 1
  abfd->tdata.any = 0;
d119 1
a119 1
   called from bfd_hash_traverse in vms_fixup_sections  */
d122 1
a122 3
fill_section_ptr (entry, sections)
     struct bfd_hash_entry *entry;
     PTR sections;
d127 1
a127 1
  sym =  ((vms_symbol_entry *)entry)->symbol;
d134 1
a134 2
  /* fill forward references (these contain section number, not section ptr).  */

d136 2
a137 4
    {
      sec = ((vms_symbol_entry *) entry)->symbol->section =
	((asection **) sections)[(unsigned int) (size_t) sec];
    }
d152 1
a152 1
	copy abfd->sections to PRIV(sections)  */
d155 1
a155 2
vms_fixup_sections (abfd)
     bfd *abfd;
d160 1
a160 3
  /*
   * traverse symbol table and fill in all section pointers
   */
d162 1
a162 1
  /* can't provide section count as argument to fill_section_ptr().  */
d164 1
a164 2
  bfd_hash_traverse (PRIV (vms_symbol_table), fill_section_ptr,
		    (PTR) (PRIV (sections)));
d170 1
a170 3

/*===========================================================================*/

d175 1
a175 2
vms_object_p (abfd)
     bfd *abfd;
d179 3
a181 3
  const struct bfd_target *target_vector = 0;
  const bfd_arch_info_type *arch = 0;
  PTR tdata_save = abfd->tdata.any;
d185 1
a185 1
  vms_debug (1, "vms_object_p(%p)\n", abfd);
d199 1
a199 1
      vms_debug (7, "reading at %08lx\n", bfd_tell(abfd));
d223 1
a223 1
      if (target_vector == 0)
d226 1
a226 1
	    target_vector = &vms_vax_vec;
d228 1
a228 1
	    target_vector = &vms_alpha_vec;
d274 1
a274 1
  if (target_vector == &vms_vax_vec)
d284 1
a284 1
      /* set arch_info to vax  */
d287 1
a287 1
      PRIV (is_vax) = 1;
d292 1
a292 1
  else if (target_vector == &vms_alpha_vec)
d294 1
a294 1
      /* set arch_info to alpha  */
d297 1
a297 1
      PRIV (is_vax) = 0;
d303 1
a303 1
  if (arch == 0)
d328 1
a328 2
vms_archive_p (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d331 1
a331 1
  vms_debug (1, "vms_archive_p(%p)\n", abfd);
d334 1
a334 1
  return 0;
d340 1
a340 2
vms_mkobject (abfd)
     bfd *abfd;
d343 1
a343 1
  vms_debug (1, "vms_mkobject(%p)\n", abfd);
d347 1
a347 1
    return 0;
d355 1
a355 1
    if (arch == 0)
d357 2
a358 2
	bfd_set_error(bfd_error_wrong_format);
	return 0;
d369 1
a369 2
vms_write_object_contents (abfd)
     bfd *abfd;
d372 1
a372 1
  vms_debug (1, "vms_write_object_contents(%p)\n", abfd);
d419 1
a419 1
/*-- 4.1, generic -----------------------------------------------------------*/
d424 1
a424 2
vms_close_and_cleanup (abfd)
     bfd *abfd;
d427 1
a427 1
  vms_debug (1, "vms_close_and_cleanup(%p)\n", abfd);
d429 1
a429 1
  if (abfd == 0)
d448 1
d450 1
a450 2
vms_bfd_free_cached_info (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d453 1
a453 1
  vms_debug (1, "vms_bfd_free_cached_info(%p)\n", abfd);
d461 1
a461 3
vms_new_section_hook (abfd, section)
     bfd *abfd;
     asection *section;
d476 2
a477 2
      PRIV (sections) = (asection **) bfd_realloc (PRIV (sections), amt);
      if (PRIV (sections) == 0)
d497 5
a501 6
vms_get_section_contents (abfd, section, buf, offset, buf_size)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     PTR buf ATTRIBUTE_UNUSED;
     file_ptr offset ATTRIBUTE_UNUSED;
     bfd_size_type buf_size ATTRIBUTE_UNUSED;
d504 1
a504 1
  vms_debug (1, "vms_get_section_contents(%p, %s, %p, off %ld, size %d)\n",
d508 1
a508 2
  /* shouldn't be called, since all sections are IN_MEMORY  */

d514 1
a514 1
   section data (starting at offset into section)  */
d517 5
a521 6
vms_get_section_contents_in_window (abfd, section, w, offset, count)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     bfd_window *w ATTRIBUTE_UNUSED;
     file_ptr offset ATTRIBUTE_UNUSED;
     bfd_size_type count ATTRIBUTE_UNUSED;
d524 1
a524 1
  vms_debug (1, "vms_get_section_contents_in_window(%p, %s, %p, off %ld, count %d)\n",
d528 1
a528 2
  /* shouldn't be called, since all sections are IN_MEMORY  */

d532 1
a532 1
/*-- Part 4.2, copy private data --------------------------------------------*/
d538 2
a539 3
vms_bfd_copy_private_bfd_data (src, dest)
     bfd *src ATTRIBUTE_UNUSED;
     bfd *dest ATTRIBUTE_UNUSED;
d542 1
a542 1
  vms_debug (1, "vms_bfd_copy_private_bfd_data(%p, %p)\n", src, dest);
d555 2
a556 3
vms_bfd_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd ATTRIBUTE_UNUSED;
     bfd *obfd ATTRIBUTE_UNUSED;
d559 1
a559 1
  vms_debug (1,"vms_bfd_merge_private_bfd_data(%p, %p)\n", ibfd, obfd);
d572 2
a573 3
vms_bfd_set_private_flags (abfd, flags)
     bfd *abfd ATTRIBUTE_UNUSED;
     flagword flags ATTRIBUTE_UNUSED;
d576 1
a576 1
  vms_debug (1,"vms_bfd_set_private_flags(%p, %lx)\n", abfd, (long)flags);
d585 4
a588 5
vms_bfd_copy_private_section_data (srcbfd, srcsec, dstbfd, dstsec)
     bfd *srcbfd ATTRIBUTE_UNUSED;
     asection *srcsec ATTRIBUTE_UNUSED;
     bfd *dstbfd ATTRIBUTE_UNUSED;
     asection *dstsec ATTRIBUTE_UNUSED;
d591 1
a591 1
  vms_debug (1, "vms_bfd_copy_private_section_data(%p, %s, %p, %s)\n",
d601 4
a604 5
vms_bfd_copy_private_symbol_data (ibfd, isym, obfd, osym)
     bfd *ibfd ATTRIBUTE_UNUSED;
     asymbol *isym ATTRIBUTE_UNUSED;
     bfd *obfd ATTRIBUTE_UNUSED;
     asymbol *osym ATTRIBUTE_UNUSED;
d607 1
a607 1
  vms_debug (1, "vms_bfd_copy_private_symbol_data(%p, %s, %p, %s)\n",
d613 1
a613 1
/*-- Part 4.3, core file ----------------------------------------------------*/
d619 1
a619 2
vms_core_file_failing_command (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d622 1
a622 1
  vms_debug (1, "vms_core_file_failing_command(%p)\n", abfd);
d624 1
a624 1
  return 0;
d631 1
a631 2
vms_core_file_failing_signal (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d634 1
a634 1
  vms_debug (1, "vms_core_file_failing_signal(%p)\n", abfd);
d643 2
a644 3
vms_core_file_matches_executable_p (abfd, bbfd)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd *bbfd ATTRIBUTE_UNUSED;
d647 1
a647 1
  vms_debug (1, "vms_core_file_matches_executable_p(%p, %p)\n", abfd, bbfd);
d652 1
a652 1
/*-- Part 4.4, archive ------------------------------------------------------*/
d658 1
a658 2
vms_slurp_armap (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d661 1
a661 1
  vms_debug (1, "vms_slurp_armap(%p)\n", abfd);
d670 1
a670 2
vms_slurp_extended_name_table (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d673 1
a673 1
  vms_debug (1, "vms_slurp_extended_name_table(%p)\n", abfd);
d682 4
a685 5
vms_construct_extended_name_table (abfd, tabloc, tablen, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     char **tabloc ATTRIBUTE_UNUSED;
     bfd_size_type *tablen ATTRIBUTE_UNUSED;
     const char **name ATTRIBUTE_UNUSED;
d688 1
a688 1
  vms_debug (1, "vms_construct_extended_name_table(%p)\n", abfd);
d693 1
a693 1
/* Truncate the name of an archive to match system-dependent restrictions  */
d696 3
a698 4
vms_truncate_arname (abfd, pathname, arhdr)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *pathname ATTRIBUTE_UNUSED;
     char *arhdr ATTRIBUTE_UNUSED;
d701 1
a701 1
  vms_debug (1, "vms_truncate_arname(%p, %s, %s)\n", abfd, pathname, arhdr);
d706 1
a706 1
/* ???	write archive map  */
d709 5
a713 6
vms_write_armap (arch, elength, map, orl_count, stridx)
     bfd *arch ATTRIBUTE_UNUSED;
     unsigned int elength ATTRIBUTE_UNUSED;
     struct orl *map ATTRIBUTE_UNUSED;
     unsigned int orl_count ATTRIBUTE_UNUSED;
     int stridx ATTRIBUTE_UNUSED;
d716 1
a716 1
  vms_debug (1, "vms_write_armap(%p, %d, %p, %d %d)\n",
d724 2
a725 3
static PTR
vms_read_ar_hdr (abfd)
    bfd * abfd ATTRIBUTE_UNUSED;
d728 1
a728 1
  vms_debug (1, "vms_read_ar_hdr(%p)\n", abfd);
d730 1
a730 1
  return (PTR)0;
d740 2
a741 3
vms_openr_next_archived_file (arch, prev)
     bfd *arch ATTRIBUTE_UNUSED;
     bfd *prev ATTRIBUTE_UNUSED;
d744 1
a744 1
  vms_debug (1, "vms_openr_next_archived_file(%p, %p)\n", arch, prev);
d753 1
a753 3
vms_get_elt_at_index (abfd, index)
     bfd *abfd;
     symindex index;
d756 1
a756 1
  vms_debug (1, "vms_get_elt_at_index(%p, %p)\n", abfd, index);
d758 1
a758 1
  return _bfd_generic_get_elt_at_index(abfd, index);
d762 1
a762 1
   -> bfd_generic_stat_arch_elt  */
d765 1
a765 3
vms_generic_stat_arch_elt (abfd, st)
     bfd *abfd;
     struct stat *st;
d768 1
a768 1
  vms_debug (1, "vms_generic_stat_arch_elt(%p, %p)\n", abfd, st);
d773 1
a773 1
/* This is a new function in bfd 2.5  */
d776 1
a776 2
vms_update_armap_timestamp (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d779 1
a779 1
  vms_debug (1, "vms_update_armap_timestamp(%p)\n", abfd);
d784 1
a784 1
/*-- Part 4.5, symbols --------------------------------------------------------*/
d792 1
a792 2
vms_get_symtab_upper_bound (abfd)
     bfd *abfd;
d795 1
a795 1
  vms_debug (1, "vms_get_symtab_upper_bound(%p), %d symbols\n", abfd, PRIV (gsd_sym_count));
d797 1
a797 1
  return (PRIV (gsd_sym_count)+1) * sizeof (asymbol *);
d803 1
a803 1
   init counter to 0 if entry == 0  */
d806 1
a806 3
copy_symbols (entry, arg)
     struct bfd_hash_entry *entry;
     PTR arg;
d808 1
a808 1
  bfd *abfd = (bfd *) arg;
d810 1
a810 1
  if (entry == NULL)	/* init counter */
d812 1
a812 1
  else			/* fill vector, inc counter */
d821 1
a821 1
   return # of symbols read  */
d824 1
a824 3
vms_canonicalize_symtab (abfd, symbols)
     bfd *abfd;
     asymbol **symbols;
d827 1
a827 1
  vms_debug (1, "vms_canonicalize_symtab(%p, <ret>)\n", abfd);
d830 2
a831 4
	/* init counter */
  (void)copy_symbols((struct bfd_hash_entry *)0, abfd);

	/* traverse table and fill symbols vector */
d833 1
d835 1
a835 1
  bfd_hash_traverse(PRIV (vms_symbol_table), copy_symbols, (PTR)abfd);
d845 1
a845 1
   bfd_print_symbol_all	print all we know, which is not much right now :-)  */
d848 4
a851 5
vms_print_symbol (abfd, file, symbol, how)
     bfd *abfd;
     PTR file;
     asymbol *symbol;
     bfd_print_symbol_type how;
d854 1
a854 1
  vms_debug (1, "vms_print_symbol(%p, %p, %p, %d)\n", abfd, file, symbol, how);
d868 1
a868 1
	  bfd_print_symbol_vandf (abfd, (PTR)file, symbol);
d870 1
a870 1
	  fprintf ((FILE *)file," %-8s %s", section_name, symbol->name);
a873 1
  return;
d888 1
a888 1
	-	debug  */
d891 3
a893 4
vms_get_symbol_info (abfd, symbol, ret)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
d898 1
a898 1
  vms_debug (1, "vms_get_symbol_info(%p, %p, %p)\n", abfd, symbol, ret);
d903 1
a903 1
  if (ret == 0)
a927 2

  return;
d934 2
a935 3
vms_bfd_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
d938 1
a938 1
  vms_debug (1, "vms_bfd_is_local_label_name(%p, %s)\n", abfd, name);
d943 1
a943 1
/* Get source line number for symbol  */
d946 2
a947 3
vms_get_lineno (abfd, symbol)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
d950 1
a950 1
  vms_debug (1, "vms_get_lineno(%p, %p)\n", abfd, symbol);
d952 1
a952 1
  return 0;
d960 7
a966 8
vms_find_nearest_line (abfd, section, symbols, offset, file, func, line)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
     bfd_vma offset ATTRIBUTE_UNUSED;
     const char **file ATTRIBUTE_UNUSED;
     const char **func ATTRIBUTE_UNUSED;
     unsigned int *line ATTRIBUTE_UNUSED;
d969 1
a969 1
  vms_debug (1, "vms_find_nearest_line(%p, %s, %p, %ld, <ret>, <ret>, <ret>)\n",
d980 3
a982 4
vms_bfd_make_debug_symbol (abfd, ptr, size)
     bfd *abfd ATTRIBUTE_UNUSED;
     void *ptr ATTRIBUTE_UNUSED;
     unsigned long size ATTRIBUTE_UNUSED;
d985 1
a985 1
  vms_debug (1, "vms_bfd_make_debug_symbol(%p, %p, %ld)\n", abfd, ptr, size);
d987 1
a987 1
  return 0;
d995 4
a998 5
vms_read_minisymbols (abfd, dynamic, minisymsp, sizep)
     bfd *abfd;
     bfd_boolean dynamic;
     PTR *minisymsp;
     unsigned int *sizep;
d1001 1
a1001 1
  vms_debug (1, "vms_read_minisymbols(%p, %d, %p, %d)\n", abfd, dynamic, minisymsp, *sizep);
d1011 4
a1014 5
vms_minisymbol_to_symbol (abfd, dynamic, minisym, sym)
     bfd *abfd;
     bfd_boolean dynamic;
     const PTR minisym;
     asymbol *sym;
d1017 1
a1017 1
  vms_debug (1, "vms_minisymbol_to_symbol(%p, %d, %p, %p)\n", abfd, dynamic, minisym, sym);
d1022 1
a1022 1
/*-- Part 4.6, relocations --------------------------------------------------*/
d1029 2
a1030 3
vms_get_reloc_upper_bound (abfd, section)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
d1033 1
a1033 1
  vms_debug (1, "vms_get_reloc_upper_bound(%p, %s)\n", abfd, section->name);
d1045 4
a1048 5
vms_canonicalize_reloc (abfd, section, location, symbols)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     arelent **location ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
d1051 1
a1051 1
  vms_debug (1, "vms_canonicalize_reloc(%p, %s, <ret>, <ret>)\n", abfd, section->name);
d1055 2
a1056 3

/*---------------------------------------------------------------------------*/
/* this is just copied from ecoff-alpha, needs to be fixed probably */
d1061 7
a1067 8
reloc_nil (abfd, reloc, sym, data, sec, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc ATTRIBUTE_UNUSED;
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     char **error_message ATTRIBUTE_UNUSED;
d1070 1
a1070 1
  vms_debug (1, "reloc_nil(abfd %p, output_bfd %p)\n", abfd, output_bfd);
d1078 1
a1078 1
/*  _bfd_hexdump (2, data, bfd_get_reloc_size(reloc->howto),0); */
d1090 13
a1102 13
  HOWTO (ALPHA_R_IGNORE,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "IGNORE",		/* name */
	 TRUE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */
d1105 13
a1117 13
  HOWTO (ALPHA_R_REFQUAD,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "REFQUAD",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1122 13
a1134 13
  HOWTO (ALPHA_R_BRADDR,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 21,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "BRADDR",		/* name */
	 TRUE,			/* partial_inplace */
	 0x1fffff,		/* src_mask */
	 0x1fffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1137 13
a1149 13
  HOWTO (ALPHA_R_HINT,		/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 14,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "HINT",		/* name */
	 TRUE,			/* partial_inplace */
	 0x3fff,		/* src_mask */
	 0x3fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1152 13
a1164 13
  HOWTO (ALPHA_R_SREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "SREL16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1167 13
a1179 13
  HOWTO (ALPHA_R_SREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "SREL32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1182 13
a1194 13
  HOWTO (ALPHA_R_SREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "SREL64",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1197 13
a1209 13
  HOWTO (ALPHA_R_OP_PUSH,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "OP_PUSH",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1213 13
a1225 13
  HOWTO (ALPHA_R_OP_STORE,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "OP_STORE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1229 13
a1241 13
  HOWTO (ALPHA_R_OP_PSUB,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "OP_PSUB",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1245 13
a1257 13
  HOWTO (ALPHA_R_OP_PRSHIFT,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "OP_PRSHIFT",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1260 13
a1272 13
  HOWTO (ALPHA_R_LINKAGE,	/* type */
	 0,			/* rightshift */
	 8,			/* size (0 = byte, 1 = short, 2 = long) */
	 256,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "LINKAGE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1275 13
a1287 13
  HOWTO (ALPHA_R_REFLONG,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "REFLONG",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1290 13
a1302 13
  HOWTO (ALPHA_R_CODEADDR,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "CODEADDR",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1310 2
a1311 3
vms_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1316 1
a1316 1
  vms_debug (1, "vms_bfd_reloc_type_lookup(%p, %d)\t", abfd, code);
d1334 1
a1334 1
	return (const struct reloc_howto_struct *) NULL;
d1339 1
a1339 1
  return &alpha_howto_table[alpha_type];
d1342 1
a1342 1
/*-- Part 4.7, writing an object file ---------------------------------------*/
d1349 3
a1351 4
vms_set_arch_mach (abfd, arch, mach)
     bfd *abfd;
     enum bfd_architecture arch ATTRIBUTE_UNUSED;
     unsigned long mach ATTRIBUTE_UNUSED;
d1354 1
a1354 1
  vms_debug (1, "vms_set_arch_mach(%p, %d, %ld)\n", abfd, arch, mach);
d1356 1
a1356 1
  abfd->arch_info = bfd_scan_arch("alpha");
d1371 5
a1375 6
vms_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     asection *section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
d1378 2
a1379 2
  vms_debug (1, "vms_set_section_contents(%p, sec %s, loc %p, off %ld, count %d)\n",
					abfd, section->name, location, (long int)offset, (int)count);
d1382 1
a1382 1
  return _bfd_save_vms_section(abfd, section, location, offset, count);
d1385 1
a1385 1
/*-- Part 4.8, linker -------------------------------------------------------*/
d1390 2
a1391 3
vms_sizeof_headers (abfd, reloc)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d1394 1
a1394 1
  vms_debug (1, "vms_sizeof_headers(%p, %s)\n", abfd, (reloc)?"True":"False");
d1403 6
a1408 8
vms_bfd_get_relocated_section_contents (abfd, link_info, link_order, data,
					 relocatable, symbols)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
     struct bfd_link_order *link_order ATTRIBUTE_UNUSED;
     bfd_byte *data ATTRIBUTE_UNUSED;
     bfd_boolean relocatable ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
d1411 2
a1412 2
  vms_debug (1, "vms_bfd_get_relocated_section_contents(%p, %p, %p, %p, %s, %p)\n",
			abfd, link_info, link_order, data, (relocatable)?"True":"False", symbols);
d1414 1
a1414 1
  return 0;
d1420 4
a1423 5
vms_bfd_relax_section (abfd, section, link_info, again)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
     bfd_boolean *again ATTRIBUTE_UNUSED;
d1426 2
a1427 2
  vms_debug (1, "vms_bfd_relax_section(%p, %s, %p, <ret>)\n",
					abfd, section->name, link_info);
d1433 2
a1434 3
vms_bfd_gc_sections (abfd, link_info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
d1437 1
a1437 1
  vms_debug (1, "vms_bfd_gc_sections(%p, %p)\n", abfd, link_info);
d1443 2
a1444 3
vms_bfd_merge_sections (abfd, link_info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
d1447 1
a1447 1
  vms_debug (1, "vms_bfd_merge_sections(%p, %p)\n", abfd, link_info);
d1456 1
a1456 2
vms_bfd_link_hash_table_create (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d1459 1
a1459 1
  vms_debug (1, "vms_bfd_link_hash_table_create(%p)\n", abfd);
d1461 1
a1461 1
  return 0;
d1467 1
a1467 2
vms_bfd_link_hash_table_free (hash)
     struct bfd_link_hash_table *hash ATTRIBUTE_UNUSED;
d1470 1
a1470 1
  vms_debug (1, "vms_bfd_link_hash_table_free(%p)\n", abfd);
d1477 2
a1478 3
vms_bfd_link_add_symbols (abfd, link_info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
d1481 1
a1481 1
  vms_debug (1, "vms_bfd_link_add_symbols(%p, %p)\n", abfd, link_info);
d1490 2
a1491 3
vms_bfd_final_link (abfd, link_info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
d1494 1
a1494 1
  vms_debug (1, "vms_bfd_final_link(%p, %p)\n", abfd, link_info);
d1502 2
a1503 3
vms_bfd_link_split_section (abfd, section)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
d1506 1
a1506 1
  vms_debug (1, "vms_bfd_link_split_section(%p, %s)\n", abfd, section->name);
d1511 1
a1511 1
/*-- Part 4.9, dynamic symbols and relocations ------------------------------*/
d1516 1
a1516 2
vms_get_dynamic_symtab_upper_bound (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d1519 1
a1519 1
  vms_debug (1, "vms_get_dynamic_symtab_upper_bound(%p)\n", abfd);
d1525 2
a1526 3
vms_bfd_print_private_bfd_data (abfd, file)
    bfd *abfd ATTRIBUTE_UNUSED;
    void *file ATTRIBUTE_UNUSED;
d1529 1
a1529 1
  vms_debug (1, "vms_bfd_print_private_bfd_data(%p)\n", abfd);
d1531 1
a1531 1
  return 0;
d1537 2
a1538 3
vms_canonicalize_dynamic_symtab (abfd, symbols)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
d1541 1
a1541 1
  vms_debug (1, "vms_canonicalize_dynamic_symtab(%p, <ret>)\n", abfd);
d1549 1
a1549 2
vms_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d1552 1
a1552 1
  vms_debug (1, "vms_get_dynamic_reloc_upper_bound(%p)\n", abfd);
d1560 3
a1562 4
vms_canonicalize_dynamic_reloc (abfd, arel, symbols)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent **arel ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
d1565 1
a1565 1
  vms_debug (1, "vms_canonicalize_dynamic_reloc(%p)\n", abfd);
d1569 90
@


1.32
log
@Implement a new BFD API function: bfd_is_target_special_symbol.  Use this in nm
and objdump to skip the displaying of ARM Mapping symbols unless specifically
requested.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d368 1
a368 1
  if ((unsigned int) sec < priv_section_count)
d370 2
a371 2
      sec = ((vms_symbol_entry *)entry)->symbol->section =
	((asection **)sections)[(int)sec];
@


1.31
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d167 1
@


1.30
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d171 2
@


1.29
log
@binutils ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* objcopy.c (setup_bfd_headers): New function.
	(copy_object): Call setup_bfd_headers.
bfd ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* aout-target.h (MY_bfd_copy_private_header_data): Define.
	* aout-tic30.c (MY_bfd_copy_private_header_data): Define.
	* bfd.c (bfd_copy_private_header_data): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add entries for new
	interface.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_copy_private_header_data): Define.
	* elf-bfd.h (_bfd_elf_copy_private_header_data): Declare.
	* elf.c (_bfd_elf_copy_private_section_data): Remove code to set up
	segments by calling copy_private_bfd_data.
	(_bfd_elf_copy_private_header_data): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_private_header_data): Define.
	* libbfd-in.h (_bfd_generic_bfd_copy_private_header_data): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_private_header_data): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_private_header_data): Define.
	* mmo.c (mmo_bfd_copy_private_header_data): Define.
	* ppcboot.c (ppcboot_bfd_copy_private_header_data): Define.
	* som.c (som_bfd_copy_private_header_data): Define.
	* targets.c (BFD_JUMP_TABLE_COPY): Add _bfd_copy_private_header_data.
	* vms.c (vms_bfd_copy_private_header_data): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d1673 1
a1673 1
  vms_debug (2, "secraw %d, seccooked %d\n", (int)section->_raw_size, (int)section->_cooked_size);
@


1.28
log
@	* section.c (bfd_make_section_anyway): Add all sections to hash tab.

	* elf-bfd.h (bfd_elf_is_group_section): Declare.
	* elf.c (bfd_elf_is_group_section): New function.
	* elfxx-target.h (bfd_elfNN_bfd_is_group_section
	* section.c (bfd_generic_is_group_section): New function.
	* targets.c (struct bfd_target): Add _bfd_is_group_section field.
	(BFD_JUMP_TABLE_LINK): Adjust.
	* aout-adobe.c (aout_32_bfd_is_group_section): Define.
	* aout-target.h (MY_bfd_is_group_section): Define.
	* aout-tic30.c (MY_bfd_is_group_section): Define.
	* bfd.c (bfd_is_group_section): Define.
	* binary.c (binary_bfd_is_group_section): Define.
	* bout.c (b_out_bfd_is_group_section): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-mips.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Adjust.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Adjust.
	* coffcode.h (coff_bfd_is_group_section): Define.
	* i386msdos.c (msdos_bfd_is_group_section): Define.
	* i386os9k.c (os9k_bfd_is_group_section): Define.
	* ieee.c (ieee_bfd_is_group_section): Define.
	* ihex.c (ihex_bfd_is_group_section): Define.
	* libbfd-in.h (_bfd_nolink_bfd_is_group_section): Define.
	* mach-o.c (bfd_mach_o_bfd_is_group_section): Define.
	* mmo.c (mmo_bfd_is_group_section): Define.
	* nlm-target.h (nlm_bfd_is_group_section): Define.
	* oasys.c (oasys_bfd_is_group_section): Define.
	* pef.c (bfd_pef_bfd_is_group_section): Define.
	* ppcboot.c (ppcboot_bfd_is_group_section): Define.
	* srec.c (srec_bfd_is_group_section): Define.
	* tekhex.c (tekhex_bfd_is_group_section): Define.
	* versados.c (versados_bfd_is_group_section): Define.
	* vms.c (vms_bfd_is_group_section): Define.
	* xsym.c (bfd_sym_bfd_is_group_section): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d171 2
@


1.27
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Define.
	* targets.c (BFD_JUMP_TABLE_DYNAMIC): Add
	NAME##_get_synthetic_symtab.
	(struct bfd_target): Add _bfd_get_synthetic_symtab.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Define.
	* elf-bfd.h (struct elf_backend_data): Add plt_sym_val and
	relplt_name fields.
	(_bfd_elf_get_synthetic_symtab): New prototype.
	* elfcode.h (elf_get_synthetic_symtab): Define.
	* elf.c (_bfd_elf_get_synthetic_symtab): New function.
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Define.
	(elf_backend_plt_sym_val, elf_backend_relplt_name): Define.
	(elfNN_bed): Add elf_backend_plt_sym_val and elf_backend_relplt_name.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-x86-64.c (elf64_x86_64_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-sparc (elf32_sparc_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-ppc.c (ppc_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* aout-target.h (MY_get_synthetic_symtab): Define.
	* aout-tic30.c (MY_get_synthetic_symtab): Define.
	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(aix5coff64_vec): Likewise.
	* sunos.c (MY_get_synthetic_symtab): Define.
	* vms.c (vms_get_synthetic_symtab): Define.
binutils/
	* objdump.c (synthsyms, synthcount): New variables.
	(disassemble_data): Use dynsyms for stripped binaries or libraries.
	Add synthetized symbols.
	(dump_bfd): For disassemble, initialize dynsyms always and
	also synthsyms.  Free synthsyms and clear {sym,dynsym,synth}count
	before returning.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d169 1
@


1.26
log
@	* aout-adobe.c (aout_adobe_set_section_contents): Constify location.
	* aoutx.h (NAME(aout,set_section_contents)): Ditto.
	* bfd-in2.h: Regenerate.
	* binary.c (binary_set_section_contents): Ditto.
	* bout.c (b_out_set_section_contents): Ditto.
	* coff-tic54x.c (tic54x_set_section_contents): Ditto.
	* coffcode.h (coff_set_section_contents): Ditto.
	* ecoff.c (_bfd_ecoff_set_section_contents): Ditto.
	* elf-bfd.h (_bfd_elf_set_section_contents): Ditto.
	* elf.c (_bfd_elf_set_section_contents): Ditto.
	* elfxx-mips.c (_bfd_mips_elf_set_section_contents): Ditto.
	* elfxx-mips.h (_bfd_mips_elf_set_section_contents): Ditto.
	* i386msdos.c (msdos_set_section_contents): Ditto.
	* ieee.c (ieee_set_section_contents): Ditto.
	* ihex.c (ihex_set_section_contents): Ditto.
	* libaout.h (NAME(aout,set_section_contents)): Ditto.
	* libbfd-in.h (_bfd_nowrite_set_section_contents): Ditto.
	(_bfd_generic_set_section_contents): Ditto.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_generic_set_section_contents): Ditto.
	* libecoff.h (_bfd_ecoff_set_section_contents): Ditto.
	* libnlm.h (nlmNAME(set_section_contents)): Ditto.
	(struct nlm_backend_data <nlm_mangle_relocs>): Ditto.
	* mmo.c (mmo_set_section_contents): Ditto.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Ditto.
	* nlm32-i386.c (nlm_i386_mangle_relocs): Ditto.
	* nlm32-ppc.c (nlm_powerpc_mangle_relocs): Ditto.
	* nlm32-sparc.c (nlm_sparc_mangle_relocs): Ditto.
	* nlmcode.h (nlm_set_section_contents): Ditto.
	* oasys.c (oasys_set_section_contents): Ditto.
	* pdp11.c (NAME(aout,set_section_contents)): Ditto.
	* ppcboot.c (ppcboot_set_section_contents): Ditto.
	* srec.c (srec_set_section_contents): Ditto.
	* targets.c (BFD_JUMP_TABLE_WRITE <_bfd_set_section_contents>): Ditto.
	* tekhex.c (tekhex_set_section_contents): Ditto.
	(move_section_contents): Ditto.
	* versados.c (versados_set_section_contents): Ditto.
	* vms-misc.c (_bfd_save_vms_section): Ditto.
	* vms.c (vms_set_section_contents): Ditto.
	* vms.h (_bfd_save_vms_section): Ditto.
@
text
@d157 1
@


1.26.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a156 1
#define vms_get_synthetic_symtab _bfd_nodynamic_get_synthetic_symtab
a167 1
#define vms_bfd_is_group_section bfd_generic_is_group_section
a168 4
#define vms_section_already_linked \
  _bfd_generic_section_already_linked
#define vms_bfd_copy_private_header_data \
  _bfd_generic_bfd_copy_private_header_data
d1669 1
a1669 1
  vms_debug (2, "size %d\n", (int) section->size);
@


1.25
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d128 1
a128 1
  PARAMS ((bfd *abfd, asection *section, PTR location, file_ptr offset,
d1662 1
a1662 1
     PTR location;
@


1.24
log
@Correct spelling of "relocatable".
@
text
@d98 1
a98 1
static long vms_get_symtab
d1068 1
a1068 1
   called from bfd_hash_traverse in vms_get_symtab
d1092 1
a1092 1
vms_get_symtab (abfd, symbols)
d1097 1
a1097 1
  vms_debug (1, "vms_get_symtab(%p, <ret>)\n", abfd);
@


1.23
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d135 1
a135 1
	   bfd_boolean relocateable, asymbol **symbols));
d1694 1
a1694 1
					 relocateable, symbols)
d1699 1
a1699 1
     bfd_boolean relocateable ATTRIBUTE_UNUSED;
d1704 1
a1704 1
			abfd, link_info, link_order, data, (relocateable)?"True":"False", symbols);
@


1.22
log
@	* vms.c (vms_object_p): Restore the start address when returning
	NULL.
@
text
@d29 2
a30 1
static boolean vms_initialize PARAMS ((bfd *));
d32 6
a37 3
static boolean fill_section_ptr PARAMS ((struct bfd_hash_entry *, PTR));
static boolean vms_fixup_sections PARAMS ((bfd *));
static boolean copy_symbols PARAMS ((struct bfd_hash_entry *, PTR));
d40 15
a54 8
static const struct bfd_target *vms_object_p PARAMS ((bfd *abfd));
static const struct bfd_target *vms_archive_p PARAMS ((bfd *abfd));
static boolean vms_mkobject PARAMS ((bfd *abfd));
static boolean vms_write_object_contents PARAMS ((bfd *abfd));
static boolean vms_close_and_cleanup PARAMS ((bfd *abfd));
static boolean vms_bfd_free_cached_info PARAMS ((bfd *abfd));
static boolean vms_new_section_hook PARAMS ((bfd *abfd, asection *section));
static boolean vms_get_section_contents
d57 1
a57 1
static boolean vms_get_section_contents_in_window
d60 3
a62 2
static boolean vms_bfd_copy_private_bfd_data PARAMS ((bfd *src, bfd *dest));
static boolean vms_bfd_copy_private_section_data
d64 1
a64 1
static boolean vms_bfd_copy_private_symbol_data
d66 1
a66 1
static boolean vms_bfd_print_private_bfd_data
d68 5
a72 3
static char *vms_core_file_failing_command PARAMS ((bfd *abfd));
static int vms_core_file_failing_signal PARAMS ((bfd *abfd));
static boolean vms_core_file_matches_executable_p
d74 5
a78 3
static boolean vms_slurp_armap PARAMS ((bfd *abfd));
static boolean vms_slurp_extended_name_table PARAMS ((bfd *abfd));
static boolean vms_construct_extended_name_table
d83 1
a83 1
static boolean vms_write_armap
d86 14
a99 7
static PTR vms_read_ar_hdr PARAMS ((bfd *abfd));
static bfd *vms_get_elt_at_index PARAMS ((bfd *abfd, symindex index));
static bfd *vms_openr_next_archived_file PARAMS ((bfd *arch, bfd *prev));
static boolean vms_update_armap_timestamp PARAMS ((bfd *abfd));
static int vms_generic_stat_arch_elt PARAMS ((bfd *, struct stat *));
static long vms_get_symtab_upper_bound PARAMS ((bfd *abfd));
static long vms_get_symtab PARAMS ((bfd *abfd, asymbol **symbols));
d104 5
a108 3
static boolean vms_bfd_is_local_label_name PARAMS ((bfd *abfd, const char *));
static alent *vms_get_lineno PARAMS ((bfd *abfd, asymbol *symbol));
static boolean vms_find_nearest_line
d114 2
a115 1
  PARAMS ((bfd *abfd, boolean dynamic, PTR *minisymsp, unsigned int *sizep));
d117 3
a119 2
  PARAMS ((bfd *abfd, boolean dynamic, const PTR minisym, asymbol *sym));
static long vms_get_reloc_upper_bound PARAMS ((bfd *abfd, asection *sect));
d125 1
a125 1
static boolean vms_set_arch_mach
d127 1
a127 1
static boolean vms_set_section_contents
d130 2
a131 1
static int vms_sizeof_headers PARAMS ((bfd *abfd, boolean reloc));
d135 2
a136 2
	   boolean relocateable, asymbol **symbols));
static boolean vms_bfd_relax_section
d138 2
a139 2
	   boolean *again));
static boolean vms_bfd_gc_sections
d141 1
a141 1
static boolean vms_bfd_merge_sections
d147 1
a147 1
static boolean vms_bfd_link_add_symbols
d149 1
a149 1
static boolean vms_bfd_final_link
d151 1
a151 1
static boolean vms_bfd_link_split_section
d153 2
a154 1
static long vms_get_dynamic_symtab_upper_bound PARAMS ((bfd *abfd));
d157 2
a158 1
static long vms_get_dynamic_reloc_upper_bound PARAMS ((bfd *abfd));
d161 4
a164 2
static boolean vms_bfd_merge_private_bfd_data PARAMS ((bfd *ibfd, bfd *obfd));
static boolean vms_bfd_set_private_flags PARAMS ((bfd *abfd, flagword flags));
d266 1
a266 1
static boolean
d278 1
a278 1
    return false;
d289 1
a289 1
  PRIV (fixup_done) = false;
d325 1
a325 1
  return true;
d332 1
a332 1
  return false;
d344 1
a344 1
static boolean
d370 1
a370 1
  return true;
d382 1
a382 1
static boolean
d387 1
a387 1
    return true;
d398 1
a398 1
  PRIV (fixup_done) = true;
d400 1
a400 1
  return true;
d575 1
a575 1
static boolean
d600 1
a600 1
  return true;
d605 1
a605 1
static boolean
d618 1
a618 1
	    return false;
d620 1
a620 1
	    return false;
d622 1
a622 1
	    return false;
d624 1
a624 1
	    return false;
d626 1
a626 1
	    return false;
d630 1
a630 1
		return false;
d635 1
a635 1
		return false;
d641 1
a641 1
	    return false;
d643 1
a643 1
	    return false;
d645 1
a645 1
	    return false;
d647 1
a647 1
	    return false;
d649 1
a649 1
	    return false;
d651 1
a651 1
	    return false;
d654 1
a654 1
  return true;
d661 1
a661 1
static boolean
d669 1
a669 1
    return true;
d683 1
a683 1
  return true;
d687 1
a687 1
static boolean
d694 1
a694 1
  return true;
d699 1
a699 1
static boolean
d719 1
a719 1
	return false;
d730 1
a730 1
  return true;
d737 1
a737 1
static boolean
d752 1
a752 1
  return false;
d759 1
a759 1
static boolean
d774 1
a774 1
  return false;
d782 1
a782 1
static boolean
d790 1
a790 1
  return true;
d794 2
a795 2
   the output file BFD @@var{obfd} when linking.  Return <<true>>
   on success, <<false>> on error.  Possible error returns are:
d800 1
a800 1
static boolean
d808 1
a808 1
  return true;
d812 1
a812 1
   Return <<true>> on success, <<false>> on error.  Possible error
d818 1
a818 1
static boolean
d826 1
a826 1
  return true;
d832 1
a832 1
static boolean
d843 1
a843 1
  return true;
d849 1
a849 1
static boolean
d860 1
a860 1
  return true;
d891 2
a892 2
/* Return true if the core file attached to core_bfd was generated
   by a run of the executable file attached to exec_bfd, false otherwise.  */
d894 1
a894 1
static boolean
d902 1
a902 1
  return false;
d908 1
a908 1
   Return false on error, true otherwise.  */
d910 1
a910 1
static boolean
d917 1
a917 1
  return false;
d921 1
a921 1
   Return false on error, true otherwise.  */
d923 1
a923 1
static boolean
d930 1
a930 1
  return false;
d934 1
a934 1
   Return false on error, true otherwise.  */
d936 1
a936 1
static boolean
d946 1
a946 1
  return false;
d965 1
a965 1
static boolean
d977 1
a977 1
  return true;
d1039 1
a1039 1
static boolean
d1046 1
a1046 1
  return true;
d1071 1
a1071 1
static boolean
d1083 1
a1083 1
  return true;
d1206 2
a1207 2
/* Return true if the given symbol sym in the BFD abfd is
   a compiler generated local label, else return false.  */
d1209 1
a1209 1
static boolean
d1237 1
a1237 1
static boolean
d1251 1
a1251 1
  return false;
d1277 1
a1277 1
     boolean dynamic;
d1294 1
a1294 1
     boolean dynamic;
d1337 1
a1337 1
  return false;
d1380 1
a1380 1
	 true,			/* pc_relative */
d1385 1
a1385 1
	 true,			/* partial_inplace */
d1388 1
a1388 1
	 true),			/* pcrel_offset */
d1395 1
a1395 1
	 false,			/* pc_relative */
d1400 1
a1400 1
	 true,			/* partial_inplace */
d1403 1
a1403 1
	 false),		/* pcrel_offset */
d1412 1
a1412 1
	 true,			/* pc_relative */
d1417 1
a1417 1
	 true,			/* partial_inplace */
d1420 1
a1420 1
	 false),		/* pcrel_offset */
d1427 1
a1427 1
	 true,			/* pc_relative */
d1432 1
a1432 1
	 true,			/* partial_inplace */
d1435 1
a1435 1
	 false),		/* pcrel_offset */
d1442 1
a1442 1
	 true,			/* pc_relative */
d1447 1
a1447 1
	 true,			/* partial_inplace */
d1450 1
a1450 1
	 false),		/* pcrel_offset */
d1457 1
a1457 1
	 true,			/* pc_relative */
d1462 1
a1462 1
	 true,			/* partial_inplace */
d1465 1
a1465 1
	 false),		/* pcrel_offset */
d1472 1
a1472 1
	 true,			/* pc_relative */
d1477 1
a1477 1
	 true,			/* partial_inplace */
d1480 1
a1480 1
	 false),		/* pcrel_offset */
d1487 1
a1487 1
	 false,			/* pc_relative */
d1492 1
a1492 1
	 false,			/* partial_inplace */
d1495 1
a1495 1
	 false),		/* pcrel_offset */
d1503 1
a1503 1
	 false,			/* pc_relative */
d1508 1
a1508 1
	 false,			/* partial_inplace */
d1511 1
a1511 1
	 false),		/* pcrel_offset */
d1519 1
a1519 1
	 false,			/* pc_relative */
d1524 1
a1524 1
	 false,			/* partial_inplace */
d1527 1
a1527 1
	 false),		/* pcrel_offset */
d1535 1
a1535 1
	 false,			/* pc_relative */
d1540 1
a1540 1
	 false,			/* partial_inplace */
d1543 1
a1543 1
	 false),		/* pcrel_offset */
d1550 1
a1550 1
	 false,			/* pc_relative */
d1555 1
a1555 1
	 false,			/* partial_inplace */
d1558 1
a1558 1
	 false),		/* pcrel_offset */
d1565 1
a1565 1
	 false,			/* pc_relative */
d1570 1
a1570 1
	 true,			/* partial_inplace */
d1573 1
a1573 1
	 false),		/* pcrel_offset */
d1580 1
a1580 1
	 false,			/* pc_relative */
d1585 1
a1585 1
	 false,			/* partial_inplace */
d1588 1
a1588 1
	 false),		/* pcrel_offset */
d1635 1
a1635 1
static boolean
d1646 1
a1646 1
  return true;
d1653 1
a1653 1
   Normally true is returned, else false. Possible error returns are:
d1658 1
a1658 1
static boolean
d1681 1
a1681 1
     boolean reloc ATTRIBUTE_UNUSED;
d1699 1
a1699 1
     boolean relocateable ATTRIBUTE_UNUSED;
d1711 1
a1711 1
static boolean
d1716 1
a1716 1
     boolean *again ATTRIBUTE_UNUSED;
d1722 1
a1722 1
  return true;
d1725 1
a1725 1
static boolean
d1733 1
a1733 1
  return true;
d1736 1
a1736 1
static boolean
d1744 1
a1744 1
  return true;
d1773 1
a1773 1
static boolean
d1781 1
a1781 1
  return false;
d1787 1
a1787 1
static boolean
d1795 1
a1795 1
  return true;
d1800 1
a1800 1
static boolean
d1808 1
a1808 1
  return false;
d1825 1
a1825 1
static boolean
@


1.21
log
@	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.
@
text
@d385 1
d523 1
@


1.21.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d29 1
a29 2
static bfd_boolean vms_initialize
  PARAMS ((bfd *));
d31 3
a33 6
static bfd_boolean fill_section_ptr
  PARAMS ((struct bfd_hash_entry *, PTR));
static bfd_boolean vms_fixup_sections
  PARAMS ((bfd *));
static bfd_boolean copy_symbols
  PARAMS ((struct bfd_hash_entry *, PTR));
d36 8
a43 15
static const struct bfd_target *vms_object_p
  PARAMS ((bfd *abfd));
static const struct bfd_target *vms_archive_p
  PARAMS ((bfd *abfd));
static bfd_boolean vms_mkobject
  PARAMS ((bfd *abfd));
static bfd_boolean vms_write_object_contents
  PARAMS ((bfd *abfd));
static bfd_boolean vms_close_and_cleanup
  PARAMS ((bfd *abfd));
static bfd_boolean vms_bfd_free_cached_info
  PARAMS ((bfd *abfd));
static bfd_boolean vms_new_section_hook
  PARAMS ((bfd *abfd, asection *section));
static bfd_boolean vms_get_section_contents
d46 1
a46 1
static bfd_boolean vms_get_section_contents_in_window
d49 2
a50 3
static bfd_boolean vms_bfd_copy_private_bfd_data
  PARAMS ((bfd *src, bfd *dest));
static bfd_boolean vms_bfd_copy_private_section_data
d52 1
a52 1
static bfd_boolean vms_bfd_copy_private_symbol_data
d54 1
a54 1
static bfd_boolean vms_bfd_print_private_bfd_data
d56 3
a58 5
static char *vms_core_file_failing_command
  PARAMS ((bfd *abfd));
static int vms_core_file_failing_signal
  PARAMS ((bfd *abfd));
static bfd_boolean vms_core_file_matches_executable_p
d60 3
a62 5
static bfd_boolean vms_slurp_armap
  PARAMS ((bfd *abfd));
static bfd_boolean vms_slurp_extended_name_table
  PARAMS ((bfd *abfd));
static bfd_boolean vms_construct_extended_name_table
d67 1
a67 1
static bfd_boolean vms_write_armap
d70 7
a76 14
static PTR vms_read_ar_hdr
  PARAMS ((bfd *abfd));
static bfd *vms_get_elt_at_index
  PARAMS ((bfd *abfd, symindex index));
static bfd *vms_openr_next_archived_file
  PARAMS ((bfd *arch, bfd *prev));
static bfd_boolean vms_update_armap_timestamp
  PARAMS ((bfd *abfd));
static int vms_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static long vms_get_symtab_upper_bound
  PARAMS ((bfd *abfd));
static long vms_canonicalize_symtab
  PARAMS ((bfd *abfd, asymbol **symbols));
d81 3
a83 5
static bfd_boolean vms_bfd_is_local_label_name
  PARAMS ((bfd *abfd, const char *));
static alent *vms_get_lineno
  PARAMS ((bfd *abfd, asymbol *symbol));
static bfd_boolean vms_find_nearest_line
d89 1
a89 2
  PARAMS ((bfd *abfd, bfd_boolean dynamic, PTR *minisymsp,
	   unsigned int *sizep));
d91 2
a92 3
  PARAMS ((bfd *abfd, bfd_boolean dynamic, const PTR minisym, asymbol *sym));
static long vms_get_reloc_upper_bound
  PARAMS ((bfd *abfd, asection *sect));
d98 1
a98 1
static bfd_boolean vms_set_arch_mach
d100 2
a101 2
static bfd_boolean vms_set_section_contents
  PARAMS ((bfd *abfd, asection *section, const PTR location, file_ptr offset,
d103 1
a103 2
static int vms_sizeof_headers
  PARAMS ((bfd *abfd, bfd_boolean reloc));
d107 2
a108 2
	   bfd_boolean relocatable, asymbol **symbols));
static bfd_boolean vms_bfd_relax_section
d110 2
a111 2
	   bfd_boolean *again));
static bfd_boolean vms_bfd_gc_sections
d113 1
a113 1
static bfd_boolean vms_bfd_merge_sections
d119 1
a119 1
static bfd_boolean vms_bfd_link_add_symbols
d121 1
a121 1
static bfd_boolean vms_bfd_final_link
d123 1
a123 1
static bfd_boolean vms_bfd_link_split_section
d125 1
a125 2
static long vms_get_dynamic_symtab_upper_bound
  PARAMS ((bfd *abfd));
d128 1
a128 2
static long vms_get_dynamic_reloc_upper_bound
  PARAMS ((bfd *abfd));
d131 2
a132 4
static bfd_boolean vms_bfd_merge_private_bfd_data
  PARAMS ((bfd *ibfd, bfd *obfd));
static bfd_boolean vms_bfd_set_private_flags
  PARAMS ((bfd *abfd, flagword flags));
d234 1
a234 1
static bfd_boolean
d246 1
a246 1
    return FALSE;
d257 1
a257 1
  PRIV (fixup_done) = FALSE;
d293 1
a293 1
  return TRUE;
d300 1
a300 1
  return FALSE;
d312 1
a312 1
static bfd_boolean
d338 1
a338 1
  return TRUE;
d350 1
a350 1
static bfd_boolean
d355 1
a355 1
    return TRUE;
d366 1
a366 1
  PRIV (fixup_done) = TRUE;
d368 1
a368 1
  return TRUE;
a384 1
  bfd_vma saddr_save = bfd_get_start_address (abfd);
a521 1
  bfd_set_start_address (abfd, saddr_save);
d541 1
a541 1
static bfd_boolean
d566 1
a566 1
  return TRUE;
d571 1
a571 1
static bfd_boolean
d584 1
a584 1
	    return FALSE;
d586 1
a586 1
	    return FALSE;
d588 1
a588 1
	    return FALSE;
d590 1
a590 1
	    return FALSE;
d592 1
a592 1
	    return FALSE;
d596 1
a596 1
		return FALSE;
d601 1
a601 1
		return FALSE;
d607 1
a607 1
	    return FALSE;
d609 1
a609 1
	    return FALSE;
d611 1
a611 1
	    return FALSE;
d613 1
a613 1
	    return FALSE;
d615 1
a615 1
	    return FALSE;
d617 1
a617 1
	    return FALSE;
d620 1
a620 1
  return TRUE;
d627 1
a627 1
static bfd_boolean
d635 1
a635 1
    return TRUE;
d649 1
a649 1
  return TRUE;
d653 1
a653 1
static bfd_boolean
d660 1
a660 1
  return TRUE;
d665 1
a665 1
static bfd_boolean
d685 1
a685 1
	return FALSE;
d696 1
a696 1
  return TRUE;
d703 1
a703 1
static bfd_boolean
d718 1
a718 1
  return FALSE;
d725 1
a725 1
static bfd_boolean
d740 1
a740 1
  return FALSE;
d748 1
a748 1
static bfd_boolean
d756 1
a756 1
  return TRUE;
d760 2
a761 2
   the output file BFD @@var{obfd} when linking.  Return <<TRUE>>
   on success, <<FALSE>> on error.  Possible error returns are:
d766 1
a766 1
static bfd_boolean
d774 1
a774 1
  return TRUE;
d778 1
a778 1
   Return <<TRUE>> on success, <<FALSE>> on error.  Possible error
d784 1
a784 1
static bfd_boolean
d792 1
a792 1
  return TRUE;
d798 1
a798 1
static bfd_boolean
d809 1
a809 1
  return TRUE;
d815 1
a815 1
static bfd_boolean
d826 1
a826 1
  return TRUE;
d857 2
a858 2
/* Return TRUE if the core file attached to core_bfd was generated
   by a run of the executable file attached to exec_bfd, FALSE otherwise.  */
d860 1
a860 1
static bfd_boolean
d868 1
a868 1
  return FALSE;
d874 1
a874 1
   Return FALSE on error, TRUE otherwise.  */
d876 1
a876 1
static bfd_boolean
d883 1
a883 1
  return FALSE;
d887 1
a887 1
   Return FALSE on error, TRUE otherwise.  */
d889 1
a889 1
static bfd_boolean
d896 1
a896 1
  return FALSE;
d900 1
a900 1
   Return FALSE on error, TRUE otherwise.  */
d902 1
a902 1
static bfd_boolean
d912 1
a912 1
  return FALSE;
d931 1
a931 1
static bfd_boolean
d943 1
a943 1
  return TRUE;
d1005 1
a1005 1
static bfd_boolean
d1012 1
a1012 1
  return TRUE;
d1034 1
a1034 1
   called from bfd_hash_traverse in vms_canonicalize_symtab
d1037 1
a1037 1
static bfd_boolean
d1049 1
a1049 1
  return TRUE;
d1058 1
a1058 1
vms_canonicalize_symtab (abfd, symbols)
d1063 1
a1063 1
  vms_debug (1, "vms_canonicalize_symtab(%p, <ret>)\n", abfd);
d1172 2
a1173 2
/* Return TRUE if the given symbol sym in the BFD abfd is
   a compiler generated local label, else return FALSE.  */
d1175 1
a1175 1
static bfd_boolean
d1203 1
a1203 1
static bfd_boolean
d1217 1
a1217 1
  return FALSE;
d1243 1
a1243 1
     bfd_boolean dynamic;
d1260 1
a1260 1
     bfd_boolean dynamic;
d1303 1
a1303 1
  return FALSE;
d1346 1
a1346 1
	 TRUE,			/* pc_relative */
d1351 1
a1351 1
	 TRUE,			/* partial_inplace */
d1354 1
a1354 1
	 TRUE),			/* pcrel_offset */
d1361 1
a1361 1
	 FALSE,			/* pc_relative */
d1366 1
a1366 1
	 TRUE,			/* partial_inplace */
d1369 1
a1369 1
	 FALSE),		/* pcrel_offset */
d1378 1
a1378 1
	 TRUE,			/* pc_relative */
d1383 1
a1383 1
	 TRUE,			/* partial_inplace */
d1386 1
a1386 1
	 FALSE),		/* pcrel_offset */
d1393 1
a1393 1
	 TRUE,			/* pc_relative */
d1398 1
a1398 1
	 TRUE,			/* partial_inplace */
d1401 1
a1401 1
	 FALSE),		/* pcrel_offset */
d1408 1
a1408 1
	 TRUE,			/* pc_relative */
d1413 1
a1413 1
	 TRUE,			/* partial_inplace */
d1416 1
a1416 1
	 FALSE),		/* pcrel_offset */
d1423 1
a1423 1
	 TRUE,			/* pc_relative */
d1428 1
a1428 1
	 TRUE,			/* partial_inplace */
d1431 1
a1431 1
	 FALSE),		/* pcrel_offset */
d1438 1
a1438 1
	 TRUE,			/* pc_relative */
d1443 1
a1443 1
	 TRUE,			/* partial_inplace */
d1446 1
a1446 1
	 FALSE),		/* pcrel_offset */
d1453 1
a1453 1
	 FALSE,			/* pc_relative */
d1458 1
a1458 1
	 FALSE,			/* partial_inplace */
d1461 1
a1461 1
	 FALSE),		/* pcrel_offset */
d1469 1
a1469 1
	 FALSE,			/* pc_relative */
d1474 1
a1474 1
	 FALSE,			/* partial_inplace */
d1477 1
a1477 1
	 FALSE),		/* pcrel_offset */
d1485 1
a1485 1
	 FALSE,			/* pc_relative */
d1490 1
a1490 1
	 FALSE,			/* partial_inplace */
d1493 1
a1493 1
	 FALSE),		/* pcrel_offset */
d1501 1
a1501 1
	 FALSE,			/* pc_relative */
d1506 1
a1506 1
	 FALSE,			/* partial_inplace */
d1509 1
a1509 1
	 FALSE),		/* pcrel_offset */
d1516 1
a1516 1
	 FALSE,			/* pc_relative */
d1521 1
a1521 1
	 FALSE,			/* partial_inplace */
d1524 1
a1524 1
	 FALSE),		/* pcrel_offset */
d1531 1
a1531 1
	 FALSE,			/* pc_relative */
d1536 1
a1536 1
	 TRUE,			/* partial_inplace */
d1539 1
a1539 1
	 FALSE),		/* pcrel_offset */
d1546 1
a1546 1
	 FALSE,			/* pc_relative */
d1551 1
a1551 1
	 FALSE,			/* partial_inplace */
d1554 1
a1554 1
	 FALSE),		/* pcrel_offset */
d1601 1
a1601 1
static bfd_boolean
d1612 1
a1612 1
  return TRUE;
d1619 1
a1619 1
   Normally TRUE is returned, else FALSE. Possible error returns are:
d1624 1
a1624 1
static bfd_boolean
d1628 1
a1628 1
     const PTR location;
d1647 1
a1647 1
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d1660 1
a1660 1
					 relocatable, symbols)
d1665 1
a1665 1
     bfd_boolean relocatable ATTRIBUTE_UNUSED;
d1670 1
a1670 1
			abfd, link_info, link_order, data, (relocatable)?"True":"False", symbols);
d1677 1
a1677 1
static bfd_boolean
d1682 1
a1682 1
     bfd_boolean *again ATTRIBUTE_UNUSED;
d1688 1
a1688 1
  return TRUE;
d1691 1
a1691 1
static bfd_boolean
d1699 1
a1699 1
  return TRUE;
d1702 1
a1702 1
static bfd_boolean
d1710 1
a1710 1
  return TRUE;
d1739 1
a1739 1
static bfd_boolean
d1747 1
a1747 1
  return FALSE;
d1753 1
a1753 1
static bfd_boolean
d1761 1
a1761 1
  return TRUE;
d1766 1
a1766 1
static bfd_boolean
d1774 1
a1774 1
  return FALSE;
d1791 1
a1791 1
static bfd_boolean
@


1.21.10.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a384 1
  bfd_vma saddr_save = bfd_get_start_address (abfd);
a521 1
  bfd_set_start_address (abfd, saddr_save);
@


1.21.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d29 1
a29 2
static bfd_boolean vms_initialize
  PARAMS ((bfd *));
d31 3
a33 6
static bfd_boolean fill_section_ptr
  PARAMS ((struct bfd_hash_entry *, PTR));
static bfd_boolean vms_fixup_sections
  PARAMS ((bfd *));
static bfd_boolean copy_symbols
  PARAMS ((struct bfd_hash_entry *, PTR));
d36 8
a43 15
static const struct bfd_target *vms_object_p
  PARAMS ((bfd *abfd));
static const struct bfd_target *vms_archive_p
  PARAMS ((bfd *abfd));
static bfd_boolean vms_mkobject
  PARAMS ((bfd *abfd));
static bfd_boolean vms_write_object_contents
  PARAMS ((bfd *abfd));
static bfd_boolean vms_close_and_cleanup
  PARAMS ((bfd *abfd));
static bfd_boolean vms_bfd_free_cached_info
  PARAMS ((bfd *abfd));
static bfd_boolean vms_new_section_hook
  PARAMS ((bfd *abfd, asection *section));
static bfd_boolean vms_get_section_contents
d46 1
a46 1
static bfd_boolean vms_get_section_contents_in_window
d49 2
a50 3
static bfd_boolean vms_bfd_copy_private_bfd_data
  PARAMS ((bfd *src, bfd *dest));
static bfd_boolean vms_bfd_copy_private_section_data
d52 1
a52 1
static bfd_boolean vms_bfd_copy_private_symbol_data
d54 1
a54 1
static bfd_boolean vms_bfd_print_private_bfd_data
d56 3
a58 5
static char *vms_core_file_failing_command
  PARAMS ((bfd *abfd));
static int vms_core_file_failing_signal
  PARAMS ((bfd *abfd));
static bfd_boolean vms_core_file_matches_executable_p
d60 3
a62 5
static bfd_boolean vms_slurp_armap
  PARAMS ((bfd *abfd));
static bfd_boolean vms_slurp_extended_name_table
  PARAMS ((bfd *abfd));
static bfd_boolean vms_construct_extended_name_table
d67 1
a67 1
static bfd_boolean vms_write_armap
d70 7
a76 14
static PTR vms_read_ar_hdr
  PARAMS ((bfd *abfd));
static bfd *vms_get_elt_at_index
  PARAMS ((bfd *abfd, symindex index));
static bfd *vms_openr_next_archived_file
  PARAMS ((bfd *arch, bfd *prev));
static bfd_boolean vms_update_armap_timestamp
  PARAMS ((bfd *abfd));
static int vms_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static long vms_get_symtab_upper_bound
  PARAMS ((bfd *abfd));
static long vms_get_symtab
  PARAMS ((bfd *abfd, asymbol **symbols));
d81 3
a83 5
static bfd_boolean vms_bfd_is_local_label_name
  PARAMS ((bfd *abfd, const char *));
static alent *vms_get_lineno
  PARAMS ((bfd *abfd, asymbol *symbol));
static bfd_boolean vms_find_nearest_line
d89 1
a89 2
  PARAMS ((bfd *abfd, bfd_boolean dynamic, PTR *minisymsp,
	   unsigned int *sizep));
d91 2
a92 3
  PARAMS ((bfd *abfd, bfd_boolean dynamic, const PTR minisym, asymbol *sym));
static long vms_get_reloc_upper_bound
  PARAMS ((bfd *abfd, asection *sect));
d98 1
a98 1
static bfd_boolean vms_set_arch_mach
d100 1
a100 1
static bfd_boolean vms_set_section_contents
d103 1
a103 2
static int vms_sizeof_headers
  PARAMS ((bfd *abfd, bfd_boolean reloc));
d107 2
a108 2
	   bfd_boolean relocateable, asymbol **symbols));
static bfd_boolean vms_bfd_relax_section
d110 2
a111 2
	   bfd_boolean *again));
static bfd_boolean vms_bfd_gc_sections
d113 1
a113 1
static bfd_boolean vms_bfd_merge_sections
d119 1
a119 1
static bfd_boolean vms_bfd_link_add_symbols
d121 1
a121 1
static bfd_boolean vms_bfd_final_link
d123 1
a123 1
static bfd_boolean vms_bfd_link_split_section
d125 1
a125 2
static long vms_get_dynamic_symtab_upper_bound
  PARAMS ((bfd *abfd));
d128 1
a128 2
static long vms_get_dynamic_reloc_upper_bound
  PARAMS ((bfd *abfd));
d131 2
a132 4
static bfd_boolean vms_bfd_merge_private_bfd_data
  PARAMS ((bfd *ibfd, bfd *obfd));
static bfd_boolean vms_bfd_set_private_flags
  PARAMS ((bfd *abfd, flagword flags));
d234 1
a234 1
static bfd_boolean
d246 1
a246 1
    return FALSE;
d257 1
a257 1
  PRIV (fixup_done) = FALSE;
d293 1
a293 1
  return TRUE;
d300 1
a300 1
  return FALSE;
d312 1
a312 1
static bfd_boolean
d338 1
a338 1
  return TRUE;
d350 1
a350 1
static bfd_boolean
d355 1
a355 1
    return TRUE;
d366 1
a366 1
  PRIV (fixup_done) = TRUE;
d368 1
a368 1
  return TRUE;
d543 1
a543 1
static bfd_boolean
d568 1
a568 1
  return TRUE;
d573 1
a573 1
static bfd_boolean
d586 1
a586 1
	    return FALSE;
d588 1
a588 1
	    return FALSE;
d590 1
a590 1
	    return FALSE;
d592 1
a592 1
	    return FALSE;
d594 1
a594 1
	    return FALSE;
d598 1
a598 1
		return FALSE;
d603 1
a603 1
		return FALSE;
d609 1
a609 1
	    return FALSE;
d611 1
a611 1
	    return FALSE;
d613 1
a613 1
	    return FALSE;
d615 1
a615 1
	    return FALSE;
d617 1
a617 1
	    return FALSE;
d619 1
a619 1
	    return FALSE;
d622 1
a622 1
  return TRUE;
d629 1
a629 1
static bfd_boolean
d637 1
a637 1
    return TRUE;
d651 1
a651 1
  return TRUE;
d655 1
a655 1
static bfd_boolean
d662 1
a662 1
  return TRUE;
d667 1
a667 1
static bfd_boolean
d687 1
a687 1
	return FALSE;
d698 1
a698 1
  return TRUE;
d705 1
a705 1
static bfd_boolean
d720 1
a720 1
  return FALSE;
d727 1
a727 1
static bfd_boolean
d742 1
a742 1
  return FALSE;
d750 1
a750 1
static bfd_boolean
d758 1
a758 1
  return TRUE;
d762 2
a763 2
   the output file BFD @@var{obfd} when linking.  Return <<TRUE>>
   on success, <<FALSE>> on error.  Possible error returns are:
d768 1
a768 1
static bfd_boolean
d776 1
a776 1
  return TRUE;
d780 1
a780 1
   Return <<TRUE>> on success, <<FALSE>> on error.  Possible error
d786 1
a786 1
static bfd_boolean
d794 1
a794 1
  return TRUE;
d800 1
a800 1
static bfd_boolean
d811 1
a811 1
  return TRUE;
d817 1
a817 1
static bfd_boolean
d828 1
a828 1
  return TRUE;
d859 2
a860 2
/* Return TRUE if the core file attached to core_bfd was generated
   by a run of the executable file attached to exec_bfd, FALSE otherwise.  */
d862 1
a862 1
static bfd_boolean
d870 1
a870 1
  return FALSE;
d876 1
a876 1
   Return FALSE on error, TRUE otherwise.  */
d878 1
a878 1
static bfd_boolean
d885 1
a885 1
  return FALSE;
d889 1
a889 1
   Return FALSE on error, TRUE otherwise.  */
d891 1
a891 1
static bfd_boolean
d898 1
a898 1
  return FALSE;
d902 1
a902 1
   Return FALSE on error, TRUE otherwise.  */
d904 1
a904 1
static bfd_boolean
d914 1
a914 1
  return FALSE;
d933 1
a933 1
static bfd_boolean
d945 1
a945 1
  return TRUE;
d1007 1
a1007 1
static bfd_boolean
d1014 1
a1014 1
  return TRUE;
d1039 1
a1039 1
static bfd_boolean
d1051 1
a1051 1
  return TRUE;
d1174 2
a1175 2
/* Return TRUE if the given symbol sym in the BFD abfd is
   a compiler generated local label, else return FALSE.  */
d1177 1
a1177 1
static bfd_boolean
d1205 1
a1205 1
static bfd_boolean
d1219 1
a1219 1
  return FALSE;
d1245 1
a1245 1
     bfd_boolean dynamic;
d1262 1
a1262 1
     bfd_boolean dynamic;
d1305 1
a1305 1
  return FALSE;
d1348 1
a1348 1
	 TRUE,			/* pc_relative */
d1353 1
a1353 1
	 TRUE,			/* partial_inplace */
d1356 1
a1356 1
	 TRUE),			/* pcrel_offset */
d1363 1
a1363 1
	 FALSE,			/* pc_relative */
d1368 1
a1368 1
	 TRUE,			/* partial_inplace */
d1371 1
a1371 1
	 FALSE),		/* pcrel_offset */
d1380 1
a1380 1
	 TRUE,			/* pc_relative */
d1385 1
a1385 1
	 TRUE,			/* partial_inplace */
d1388 1
a1388 1
	 FALSE),		/* pcrel_offset */
d1395 1
a1395 1
	 TRUE,			/* pc_relative */
d1400 1
a1400 1
	 TRUE,			/* partial_inplace */
d1403 1
a1403 1
	 FALSE),		/* pcrel_offset */
d1410 1
a1410 1
	 TRUE,			/* pc_relative */
d1415 1
a1415 1
	 TRUE,			/* partial_inplace */
d1418 1
a1418 1
	 FALSE),		/* pcrel_offset */
d1425 1
a1425 1
	 TRUE,			/* pc_relative */
d1430 1
a1430 1
	 TRUE,			/* partial_inplace */
d1433 1
a1433 1
	 FALSE),		/* pcrel_offset */
d1440 1
a1440 1
	 TRUE,			/* pc_relative */
d1445 1
a1445 1
	 TRUE,			/* partial_inplace */
d1448 1
a1448 1
	 FALSE),		/* pcrel_offset */
d1455 1
a1455 1
	 FALSE,			/* pc_relative */
d1460 1
a1460 1
	 FALSE,			/* partial_inplace */
d1463 1
a1463 1
	 FALSE),		/* pcrel_offset */
d1471 1
a1471 1
	 FALSE,			/* pc_relative */
d1476 1
a1476 1
	 FALSE,			/* partial_inplace */
d1479 1
a1479 1
	 FALSE),		/* pcrel_offset */
d1487 1
a1487 1
	 FALSE,			/* pc_relative */
d1492 1
a1492 1
	 FALSE,			/* partial_inplace */
d1495 1
a1495 1
	 FALSE),		/* pcrel_offset */
d1503 1
a1503 1
	 FALSE,			/* pc_relative */
d1508 1
a1508 1
	 FALSE,			/* partial_inplace */
d1511 1
a1511 1
	 FALSE),		/* pcrel_offset */
d1518 1
a1518 1
	 FALSE,			/* pc_relative */
d1523 1
a1523 1
	 FALSE,			/* partial_inplace */
d1526 1
a1526 1
	 FALSE),		/* pcrel_offset */
d1533 1
a1533 1
	 FALSE,			/* pc_relative */
d1538 1
a1538 1
	 TRUE,			/* partial_inplace */
d1541 1
a1541 1
	 FALSE),		/* pcrel_offset */
d1548 1
a1548 1
	 FALSE,			/* pc_relative */
d1553 1
a1553 1
	 FALSE,			/* partial_inplace */
d1556 1
a1556 1
	 FALSE),		/* pcrel_offset */
d1603 1
a1603 1
static bfd_boolean
d1614 1
a1614 1
  return TRUE;
d1621 1
a1621 1
   Normally TRUE is returned, else FALSE. Possible error returns are:
d1626 1
a1626 1
static bfd_boolean
d1649 1
a1649 1
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d1667 1
a1667 1
     bfd_boolean relocateable ATTRIBUTE_UNUSED;
d1679 1
a1679 1
static bfd_boolean
d1684 1
a1684 1
     bfd_boolean *again ATTRIBUTE_UNUSED;
d1690 1
a1690 1
  return TRUE;
d1693 1
a1693 1
static bfd_boolean
d1701 1
a1701 1
  return TRUE;
d1704 1
a1704 1
static bfd_boolean
d1712 1
a1712 1
  return TRUE;
d1741 1
a1741 1
static bfd_boolean
d1749 1
a1749 1
  return FALSE;
d1755 1
a1755 1
static bfd_boolean
d1763 1
a1763 1
  return TRUE;
d1768 1
a1768 1
static bfd_boolean
d1776 1
a1776 1
  return FALSE;
d1793 1
a1793 1
static bfd_boolean
@


1.21.10.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d135 1
a135 1
	   bfd_boolean relocatable, asymbol **symbols));
d1694 1
a1694 1
					 relocatable, symbols)
d1699 1
a1699 1
     bfd_boolean relocatable ATTRIBUTE_UNUSED;
d1704 1
a1704 1
			abfd, link_info, link_order, data, (relocatable)?"True":"False", symbols);
@


1.21.10.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d98 1
a98 1
static long vms_canonicalize_symtab
d128 1
a128 1
  PARAMS ((bfd *abfd, asection *section, const PTR location, file_ptr offset,
d1068 1
a1068 1
   called from bfd_hash_traverse in vms_canonicalize_symtab
d1092 1
a1092 1
vms_canonicalize_symtab (abfd, symbols)
d1097 1
a1097 1
  vms_debug (1, "vms_canonicalize_symtab(%p, <ret>)\n", abfd);
d1662 1
a1662 1
     const PTR location;
@


1.20
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@a240 3
  if (abfd->tdata.any != 0)
    return true;

d244 1
a244 1
  abfd->tdata.any = (struct vms_private_data_struct*) bfd_malloc (amt);
d261 1
a261 1
  PRIV (stack) = (struct stack_struct *) bfd_malloc (amt);
d263 1
a263 6
    {
     vms_init_no_mem1:
      free (abfd->tdata.any);
      abfd->tdata.any = 0;
      return false;
    }
d267 1
a267 1
  PRIV (vms_symbol_table) = (struct bfd_hash_table *) bfd_malloc (amt);
d269 1
a269 6
    {
     vms_init_no_mem2:
      free (PRIV (stack));
      PRIV (stack) = 0;
      goto vms_init_no_mem1;
    }
d272 1
a272 1
    return false;
d275 1
a275 1
  PRIV (location_stack) = (struct location_struct *) bfd_malloc (amt);
d277 1
a277 6
    {
     vms_init_no_mem3:
      free (PRIV (vms_symbol_table));
      PRIV (vms_symbol_table) = 0;
      goto vms_init_no_mem2;
    }
d282 2
a283 1
  PRIV (output_buf) = (unsigned char *) malloc (MAX_OUTREC_SIZE);
d285 2
a286 5
    {
      free (PRIV (location_stack));
      PRIV (location_stack) = 0;
      goto vms_init_no_mem3;
    }
d294 7
d384 1
d391 1
a391 4
    {
      fprintf (stderr, "vms_initialize () failed !!\n");
      return 0;
    }
d394 1
a394 4
    {
      bfd_set_error (bfd_error_file_truncated);
      return 0;
    }
d408 1
a408 2
	  bfd_set_error (bfd_error_wrong_format);
	  return 0;
d419 1
a419 2
	      bfd_set_error (bfd_error_wrong_format);
	      return 0;
d471 1
a471 2
	  bfd_set_error (bfd_error_wrong_format);
	  return 0;
d483 1
a483 2
	  bfd_set_error (bfd_error_wrong_format);
	  return 0;
d510 1
a510 2
      bfd_set_error (bfd_error_wrong_format);
      return 0;
d515 8
d550 1
a550 4
    {
      fprintf (stderr, "vms_initialize () failed !!\n");
      return 0;
    }
a630 4
  asection *sec;
  vms_section *es, *es1;
  int i;

d638 1
a638 19
    {
      free (PRIV (vms_buf));
      PRIV (vms_buf) = NULL;
    }
  PRIV (buf_size) = 0;

  if (PRIV (output_buf) != 0)
    {
      free (PRIV (output_buf));
      PRIV (output_buf) = 0;
    }

  sec = abfd->sections;
  while (sec != NULL)
    {
      if (sec->contents)
	free (sec->contents);
      sec = sec->next;
    }
d641 1
a641 4
    {
      free (PRIV (sections));
      PRIV (sections) = NULL;
    }
d644 1
a644 28
    {
      bfd_hash_table_free (PRIV (vms_symbol_table));
      PRIV (vms_symbol_table) = 0;
    }

  if (PRIV (stack))
    {
      free (PRIV (stack));
      PRIV (stack) = 0;
    }

  if (PRIV (location_stack))
    {
      free (PRIV (location_stack));
      PRIV (location_stack) = 0;
    }

  for (i = 0; i < VMS_SECTION_COUNT; i++)
    {
      es = PRIV (vms_section_table)[i];
      while (es != NULL)
	{
	  es1 = es->next;
	  free (es);
	  es = es1;
	}
      PRIV (vms_section_table)[i] = NULL;
   }
d646 1
a646 1
  free (abfd->tdata.any);
@


1.20.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d241 3
d247 1
a247 1
  abfd->tdata.any = (struct vms_private_data_struct*) bfd_alloc (abfd, amt);
d264 1
a264 1
  PRIV (stack) = (struct stack_struct *) bfd_alloc (abfd, amt);
d266 6
a271 1
    goto error_ret1;
d275 1
a275 1
  PRIV (vms_symbol_table) = (struct bfd_hash_table *) bfd_alloc (abfd, amt);
d277 6
a282 1
    goto error_ret1;
d285 1
a285 1
    goto error_ret1;
d288 1
a288 1
  PRIV (location_stack) = (struct location_struct *) bfd_alloc (abfd, amt);
d290 6
a295 1
    goto error_ret2;
d300 1
a300 2
  amt = MAX_OUTREC_SIZE;
  PRIV (output_buf) = (unsigned char *) bfd_alloc (abfd, amt);
d302 5
a306 2
    goto error_ret2;

a313 7

 error_ret2:
  bfd_hash_table_free (PRIV (vms_symbol_table));
 error_ret1:
  bfd_release (abfd, abfd->tdata.any);
  abfd->tdata.any = 0;
  return false;
a396 1
  PTR tdata_save = abfd->tdata.any;
d403 4
a406 1
    goto error_ret;
d409 4
a412 1
    goto err_wrong_format;
d426 2
a427 1
	  goto err_wrong_format;
d438 2
a439 1
	      goto err_wrong_format;
d491 2
a492 1
	  goto err_wrong_format;
d504 2
a505 1
	  goto err_wrong_format;
d532 2
a533 1
      goto err_wrong_format;
a537 8

 err_wrong_format:
  bfd_set_error (bfd_error_wrong_format);
 error_ret:
  if (abfd->tdata.any != tdata_save && abfd->tdata.any != NULL)
    bfd_release (abfd, abfd->tdata.any);
  abfd->tdata.any = tdata_save;
  return NULL;
d565 4
a568 1
    return 0;
d649 4
d660 19
a678 1
    free (PRIV (vms_buf));
d681 4
a684 1
    free (PRIV (sections));
d687 28
a714 1
    bfd_hash_table_free (PRIV (vms_symbol_table));
d716 1
a716 1
  bfd_release (abfd, abfd->tdata.any);
@


1.20.2.2
log
@        * vms-gsd.c (_bfd_vms_write_gsd): Check that symbol->udata.p is
        non-NULL before dereferencing.

        * vms.c (vms_object_p): Restore the start address when returning
        NULL.
@
text
@a384 1
  bfd_vma saddr_save = bfd_get_start_address (abfd);
a521 1
  bfd_set_start_address (abfd, saddr_save);
@


1.19
log
@	* bfd-in.h: Remove "taken from the source" comment.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	* elf.c (bfd_elf_discard_group): Return true.
	* elf-bfd.h (bfd_elf_discard_group): Declare.
	* bfd-in.h (bfd_elf_discard_group): Don't declare here.
	* section.c (bfd_discard_group): Rename to bfd_generic_discard_group.
	* bfd.c (bfd_discard_group): Define.
	* targets.c (struct bfd_target): Add _bfd_discard_group.
	(BFD_JUMP_TABLE_LINK): Here too.
	* libbfd-in.h (_bfd_nolink_bfd_discard_group): Define.
	* aout-adobe.c (aout_32_bfd_discard_group): Define.
	* aout-target.h (MY_bfd_discard_group): Define.
	* aout-tic30.c (MY_bfd_discard_group): Define.
	* binary.c (binary_bfd_discard_group): Define.
	* bout.c (b_out_bfd_discard_group): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_discard_group): Define.
	* coffcode.h (coff_bfd_discard_group): Define.
	* coff-mips.c (_bfd_ecoff_bfd_discard_group): Define.
	* elfxx-target.h (bfd_elfNN_bfd_discard_group): Define.
	* i386msdos.c (msdos_bfd_discard_group): Define.
	* i386os9k.c (os9k_bfd_discard_group): Define.
	* ieee.c (ieee_bfd_discard_group): Define.
	* ihex.c (ihex_bfd_discard_group): Define.
	* mmo.c (mmo_bfd_discard_group): Define.
	* nlm-target.h (nlm_bfd_discard_group): Define.
	* oasys.c (oasys_bfd_discard_group): Define.
	* ppcboot.c (ppcboot_bfd_discard_group): Define.
	* som.c (som_bfd_discard_group): Define.
	* srec.c (srec_bfd_discard_group): Define.
	* tekhex.c (tekhex_bfd_discard_group): Define.
	* versados.c (versados_bfd_discard_group): Define.
	* vms.c (vms_bfd_discard_group): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_discard_group): Define.
	* coff64-rs6000.c (rs6000coff64_vec): Update initialiser.
	(aix5coff64_vec): Likewise.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
@
text
@d433 1
a433 1
	  if (vms_fixup_sections (abfd) == false)
d499 1
a499 1
      if (vms_fixup_sections (abfd) == false)
@


1.18
log
@Fix ld --just-symbols
	* aix5ppc-core.c: Warning fixes.
	* aout-adobe.c (aout_32_bfd_link_just_syms): Define.
	* aout-target.h (MY_bfd_link_just_syms): Define.
	* aout-tic30.c (MY_bfd_link_just_syms): Define.
	* bfd.c (bfd_link_just_syms): Define.
	* binary.c (binary_bfd_link_just_syms): Define.
	* bout.c (b_out_bfd_link_just_syms): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update initializer.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_just_syms): Define.
	* elf-bfd.h (enum elf_link_info_type): Add ELF_INFO_TYPE_JUST_SYMS.
	(elf_discarded_section): Check for ELF_INFO_TYPE_JUST_SYMS.
	(_bfd_elf_link_just_syms): Declare.
	* elf.c (_bfd_elf_link_just_syms): New function.
	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Check that
	sections haven't already been discarded by the linker.
	* elflink.h (elf_link_add_object_symbols): Likewise for stab
	sections and SEC_MERGE sections.
	(elf_bfd_discard_info): Similarly here.
	* elfxx-target.h (bfd_elfNN_bfd_link_just_syms): Define.
	* i386msdos.c (msdos_bfd_link_just_syms): Define.
	* i386os9k.c (os9k_bfd_link_just_syms): Define.
	* ieee.c (ieee_bfd_link_just_syms): Define.
	* ihex.c (ihex_bfd_link_just_syms): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_just_syms): Define.
	(_bfd_generic_link_just_syms): Declare.
	* libecoff.h (_bfd_ecoff_bfd_link_just_syms): Define.
	* linker.c (_bfd_generic_link_just_syms): New function.
	* mmo.c (mmo_bfd_link_just_syms): Define.
	* nlm-target.h (nlm_bfd_link_just_syms): Define.
	* oasys.c (oasys_bfd_link_just_syms): Define.
	* ppcboot.c (ppcboot_bfd_link_just_syms): Define.
	* som.c (som_bfd_link_just_syms): Define.
	* srec.c (srec_bfd_link_just_syms): Define.
	* targets.c (struct bfd_target): Add _bfd_link_just_syms.
	(BFD_JUMP_TABLE_LINK): And here.
	* tekhex.c (tekhex_bfd_link_just_syms): Define.
	* versados.c (versados_bfd_link_just_syms): Define.
	* vms.c (vms_bfd_link_just_syms): Define.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d136 1
@


1.18.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a135 1
#define vms_bfd_discard_group bfd_generic_discard_group
@


1.18.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d433 1
a433 1
	  if (! vms_fixup_sections (abfd))
d499 1
a499 1
      if (! vms_fixup_sections (abfd))
@


1.18.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d241 3
d247 1
a247 1
  abfd->tdata.any = (struct vms_private_data_struct*) bfd_alloc (abfd, amt);
d264 1
a264 1
  PRIV (stack) = (struct stack_struct *) bfd_alloc (abfd, amt);
d266 6
a271 1
    goto error_ret1;
d275 1
a275 1
  PRIV (vms_symbol_table) = (struct bfd_hash_table *) bfd_alloc (abfd, amt);
d277 6
a282 1
    goto error_ret1;
d285 1
a285 1
    goto error_ret1;
d288 1
a288 1
  PRIV (location_stack) = (struct location_struct *) bfd_alloc (abfd, amt);
d290 6
a295 1
    goto error_ret2;
d300 1
a300 2
  amt = MAX_OUTREC_SIZE;
  PRIV (output_buf) = (unsigned char *) bfd_alloc (abfd, amt);
d302 5
a306 2
    goto error_ret2;

a313 7

 error_ret2:
  bfd_hash_table_free (PRIV (vms_symbol_table));
 error_ret1:
  bfd_release (abfd, abfd->tdata.any);
  abfd->tdata.any = 0;
  return false;
a396 1
  PTR tdata_save = abfd->tdata.any;
d403 4
a406 1
    goto error_ret;
d409 4
a412 1
    goto err_wrong_format;
d426 2
a427 1
	  goto err_wrong_format;
d438 2
a439 1
	      goto err_wrong_format;
d491 2
a492 1
	  goto err_wrong_format;
d504 2
a505 1
	  goto err_wrong_format;
d532 2
a533 1
      goto err_wrong_format;
a537 8

 err_wrong_format:
  bfd_set_error (bfd_error_wrong_format);
 error_ret:
  if (abfd->tdata.any != tdata_save && abfd->tdata.any != NULL)
    bfd_release (abfd, abfd->tdata.any);
  abfd->tdata.any = tdata_save;
  return NULL;
d565 4
a568 1
    return 0;
d649 4
d660 19
a678 1
    free (PRIV (vms_buf));
d681 4
a684 1
    free (PRIV (sections));
d687 28
a714 1
    bfd_hash_table_free (PRIV (vms_symbol_table));
d716 1
a716 1
  bfd_release (abfd, abfd->tdata.any);
@


1.18.2.4
log
@merge from mainline
@
text
@a384 1
  bfd_vma saddr_save = bfd_get_start_address (abfd);
a521 1
  bfd_set_start_address (abfd, saddr_save);
@


1.17
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d135 1
@


1.17.4.1
log
@merge from trunk
@
text
@a134 2
#define vms_bfd_link_just_syms _bfd_generic_link_just_syms
#define vms_bfd_discard_group bfd_generic_discard_group
@


1.16
log
@	* syms.c (_bfd_generic_make_empty_symbol): New function.
	* libbfd-in.h (_bfd_nosymbols_make_empty_symbol): Define as
	_bfd_generic_make_empty_symbol.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* hppabsd-core.c (hppabsd_core_make_empty_symbol): Delete function.
	(hppabsd_core_get_symtab_upper_bound): Don't define.
	(hppabsd_core_get_symtab): Likewise.
	(hppabsd_core_print_symbol): Likewise.
	(hppabsd_core_get_symbol_info): Likewise.
	(hppabsd_core_bfd_is_local_label_name): Likewise.
	(hppabsd_core_get_lineno): Likewise.
	(hppabsd_core_find_nearest_line): Likewise.
	(hppabsd_core_bfd_make_debug_symbol): Likewise.
	(hppabsd_core_read_minisymbols): Likewise.
	(hppabsd_core_minisymbol_to_symbol): Likewise.
	(hppabsd_core_vec): Use BFD_JUMP_TABLE_SYMBOLS (_bfd_nosymbols).
	Formatting fixes.
	* hpux-core.c: Similarly.
	* irix-core.c: Similarly.
	* osf-core.c: Similarly.
	* sco5-core.c: Similarly.
	* binary.c (binary_make_empty_symbol): Remove function, define as
	_bfd_generic_make_empty_symbol.
	* ihex.c (ihex_make_empty_symbol): Likewise.
	* mmo.c (mmo_make_empty_symbol): Likewise.
	* ppcboot.c (ppcboot_make_empty_symbol): Likewise.
	* srec.c (srec_make_empty_symbol): Likewise.
	* versados.c (versados_make_empty_symbol): Likewise.
	* vms.c (_bfd_vms_make_empty_symbol): Remove.
	(vms_make_empty_symbol): Define as _bfd_generic_make_empty_symbol.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Call bfd_make_empty_symbol
	rather than _bfd_vms_make_empty_symbol.
	* vms-misc.c (new_symbol): Likewise.
@
text
@d117 2
d1792 11
@


1.15
log
@	* section.c (bfd_make_section_anyway): Don't increment section_id
	and the BFD's section_count if adding the section failed.
	* vms.c (vms_new_section_hook): Adjust for bfd_make_section_anyway
	change.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d132 1
a132 1
#define vms_make_empty_symbol _bfd_vms_make_empty_symbol
a1142 28
}

/* Create a new asymbol structure for the BFD abfd and return a pointer
   to it.
   This routine is necessary because each back end has private information
   surrounding the asymbol. Building your own asymbol and pointing to it
   will not create the private information, and will cause problems later on.  */

asymbol *
_bfd_vms_make_empty_symbol (abfd)
     bfd *abfd;
{
  asymbol *symbol;

  symbol = (asymbol *) bfd_zalloc(abfd, (bfd_size_type) sizeof (asymbol));

#if VMS_DEBUG
  vms_debug (1, "_bfd_vms_make_empty_symbol(%p)\n", abfd);
#endif

  if (symbol == 0)
    {
      bfd_set_error (bfd_error_no_memory);
      return 0;
    }
  symbol->the_bfd = abfd;

  return symbol;
@


1.14
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d736 3
d740 2
a741 1
  vms_debug (1, "vms_new_section_hook (%p, [%d]%s), count %d\n", abfd, section->index, section->name, abfd->section_count);
d743 1
a743 1
  bfd_set_section_alignment(abfd, section, 4);
d745 1
a745 1
  if (abfd->section_count > PRIV (section_count))
d747 1
a747 1
      bfd_size_type amt = abfd->section_count;
d752 1
a752 1
      PRIV (section_count) = abfd->section_count;
@


1.13
log
@2001-08-23  H.J. Lu  <hjl@@gnu.org>

	* syms.c (bfd_print_symbol_vandf): Add abfd to arg.
	* bfd-in2.h (bfd_print_symbol_vandf): Regenerated.

	* aoutx.h (NAME(aout,print_symbol)): Pass abfd to
	bfd_print_symbol_vandf.
	* coffgen.c (coff_print_symbol): Likewise.
	* elf.c (bfd_elf_print_symbol): Likewise.
	* ieee.c (ieee_print_symbol): Likewise.
	* nlmcode.h (nlm_print_symbol): Likewise.
	* oasys.c (oasys_print_symbol): Likewise.
	* pdp11.c (NAME(aout,print_symbol)): Likewise.
	* som.c (som_print_symbol): Likewise.
	* srec.c (srec_print_symbol): Likewise.
	* tekhex.c (tekhex_print_symbol): Likewise.
	* versados.c (versados_print_symbol): Likewise.
	* vms.c (vms_print_symbol): Likewise.

	* elf.c (_bfd_elf_print_private_bfd_data): Replace fprintf_vma
	with bfd_fprintf_vma.
	(bfd_elf_print_symbol): Likewise.
	* syms.c (bfd_print_symbol_vandf): Likewise.
@
text
@d66 1
a66 1
  PARAMS ((bfd *abfd, CONST char *pathname, char *arhdr));
d74 1
a74 1
static int vms_generic_stat_arch_elt PARAMS ((bfd *abfd, struct stat *stat));
d235 1
d240 1
a240 1
  bfd_set_start_address (abfd, (bfd_vma)-1);
d242 2
a243 2
  abfd->tdata.any = ((struct vms_private_data_struct*)
		     bfd_malloc (sizeof (struct vms_private_data_struct)));
d259 2
a260 2
  PRIV (stack) = ((struct stack_struct *)
		 bfd_malloc (sizeof (struct stack_struct) * STACKSIZE));
d270 2
a271 2
  PRIV (vms_symbol_table) = ((struct bfd_hash_table *)
			     bfd_malloc (sizeof (struct bfd_hash_table)));
d283 2
a284 3
  PRIV (location_stack) = ((struct location_struct *)
			  bfd_malloc (sizeof (struct location_struct)
				      * LOCATION_SAVE_SIZE));
d404 1
a404 1
  if (bfd_seek (abfd, 0L, SEEK_SET))
d743 3
a745 2
      PRIV (sections) = ((asection **)
			    bfd_realloc (PRIV (sections), abfd->section_count * sizeof (asection *)));
d982 1
a982 1
     CONST char *pathname ATTRIBUTE_UNUSED;
d1055 1
a1055 1
vms_generic_stat_arch_elt (abfd, stat)
d1057 1
a1057 1
     struct stat *stat;
d1060 1
a1060 1
  vms_debug (1, "vms_generic_stat_arch_elt(%p, %p)\n", abfd, stat);
d1062 1
a1062 1
  return bfd_generic_stat_arch_elt(abfd, stat);
d1151 3
a1153 1
  asymbol *symbol = (asymbol *)bfd_zalloc(abfd, sizeof (asymbol));
d1194 1
a1194 1
	  CONST char *section_name = symbol->section->name;
d1299 2
a1300 2
     CONST char **file ATTRIBUTE_UNUSED;
     CONST char **func ATTRIBUTE_UNUSED;
@


1.12
log
@	* merge.c (struct sec_merge_hash_entry): Add u.entsize and u.suffix
	fields, change sec into secinfo.
	(struct sec_merge_info): Add chain, remove last fields.
	(struct sec_merge_sec_info): Add next, sec, psecinfo fields.
	(sec_merge_hash_lookup): If lookup could not use a string only
	because it has bad alignment, mark the old string for deletion.
	(sec_merge_add): Add secinfo argument. Don't compute entry's
	position, instead record the section.
	(sec_merge_emit): Update for the sec into secinfo change in
	struct sec_merge_hash_entry.
	(_bfd_merge_section): Only record the section for merging, defer
	putting strings into the hash table.
	(cmplengthentry, last4_eq, last_eq, record_section, merge_strings,
	_bfd_merge_sections): New functions.
	(_bfd_merged_section_offset): Update for the sec_merge_hash_entry
	changes.
	* libbfd-in.h (_bfd_merge_sections): Add prototype.
	(_bfd_nolink_bfd_merge_sections): Define.
	* libbfd.h: Likewise.
	(bfd_generic_merge_sections): Add prototype.
	* targets.c (BFD_JUMP_TABLE_LINK): Add _bfd_merge_sections.
	(struct bfd_target): Likewise.
	* bfd.c (bfd_merge_sections): Define.
	* bfd-in2.h: Rebuilt.
	* elf.c (_bfd_elf_merge_sections): New function.
	* elf-bfd.h (_bfd_elf_merge_sections): Add prototype.
	* elfxx-target.h (bfd_elfNN_bfd_merge_sections): Define.
	* reloc.c (bfd_generic_merge_sections): New function.
	* vms.c (vms_bfd_merge_sections): New function.
	* aout-adobe.c (aout_32_bfd_merge_sections): Define.
	* aout-target.h (MY_bfd_merge_sections): Define.
	* aout-tic30.c (MY_bfd_merge_sections): Define.
	* binary.c (binary_bfd_merge_sections): Define.
	* bout.c (b_out_bfd_merge_sections): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_merge_sections): Define.
	* coffcode.c (coff_bfd_merge_sections): Define.
	* coff-mips.c (_bfd_ecoff_bfd_merge_sections): Define.
	* i386msdos.c (msdos_bfd_merge_sections): Define.
	* i386os9k.c (os9k_bfd_merge_sections): Define.
	* ieee.c (ieee_bfd_merge_sections): Define.
	* ihex.c (ihex_bfd_merge_sections): Define.
	* nlm-target.h (nlm_bfd_merge_sections): Define.
	* oasys.c (oasys_bfd_merge_sections): Define.
	* ppcboot.c (ppcboot_bfd_merge_sections): Define.
	* som.c (som_bfd_merge_sections): Define.
	* srec.c (srec_bfd_merge_sections): Define.
	* tekhex.c (tekhex_bfd_merge_sections): Define.
	* versados.c (versados_bfd_merge_sections): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_merge_sections): Define.

	* ldlang.c (lang_process): Call bfd_merge_sections.
@
text
@d1173 1
a1173 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1193 1
a1193 1
	  bfd_print_symbol_vandf((PTR)file,symbol);
@


1.11
log
@Update copyright notices
@
text
@d113 2
d1785 11
@


1.10
log
@2001-02-16  Kazu Hirata  <kazu@@hxi.com>

	* vms.c: Fix formatting.
@
text
@d3 2
a4 1
   Copyright 1996, 97, 98, 99, 2000 Free Software Foundation, Inc.
@


1.9
log
@2001-02-13  Kazu Hirata  <kazu@@hxi.com>

	* vms.c (vms_print_symbol): Remove unreachable code.
@
text
@d244 1
a244 1
  PRIV(is_vax) = 0;
d246 1
a246 1
  PRIV(is_vax) = 1;
d248 6
a253 6
  PRIV(vms_buf) = 0;
  PRIV(buf_size) = 0;
  PRIV(rec_length) = 0;
  PRIV(file_format) = FF_UNKNOWN;
  PRIV(fixup_done) = false;
  PRIV(sections) = NULL;
d255 1
a255 1
  PRIV(stack) = ((struct stack_struct *)
d257 1
a257 1
  if (PRIV(stack) == 0)
d264 1
a264 1
  PRIV(stackptr) = 0;
d266 1
a266 1
  PRIV(vms_symbol_table) = ((struct bfd_hash_table *)
d268 1
a268 1
  if (PRIV(vms_symbol_table) == 0)
d271 2
a272 2
      free (PRIV(stack));
      PRIV(stack) = 0;
d276 1
a276 1
  if (!bfd_hash_table_init (PRIV(vms_symbol_table), _bfd_vms_hash_newfunc))
d279 1
a279 1
  PRIV(location_stack) = ((struct location_struct *)
d282 1
a282 1
  if (PRIV(location_stack) == 0)
d285 2
a286 2
      free (PRIV(vms_symbol_table));
      PRIV(vms_symbol_table) = 0;
d291 1
a291 1
    PRIV(vms_section_table)[i] = NULL;
d293 2
a294 2
  PRIV(output_buf) = (unsigned char *) malloc (MAX_OUTREC_SIZE);
  if (PRIV(output_buf) == 0)
d296 2
a297 2
      free (PRIV(location_stack));
      PRIV(location_stack) = 0;
d300 5
a304 5
  PRIV(push_level) = 0;
  PRIV(pushed_size) = 0;
  PRIV(length_pos) = 2;
  PRIV(output_size) = 0;
  PRIV(output_alignment) = 1;
d360 1
a360 1
  if (PRIV(fixup_done))
d368 3
a370 3
  priv_section_count = PRIV(section_count);
  bfd_hash_traverse (PRIV(vms_symbol_table), fill_section_ptr,
		    (PTR) (PRIV(sections)));
d372 1
a372 1
  PRIV(fixup_done) = true;
d424 1
a424 1
	   && (PRIV(rec_type) != EOBJ_S_C_EGSD))
d436 1
a436 1
      prev_type = PRIV(rec_type);
d592 1
a592 1
      if (PRIV(is_vax))
d652 1
a652 1
  if (PRIV(vms_buf) != NULL)
d654 2
a655 2
      free (PRIV(vms_buf));
      PRIV(vms_buf) = NULL;
d657 1
a657 1
  PRIV(buf_size) = 0;
d659 1
a659 1
  if (PRIV(output_buf) != 0)
d661 2
a662 2
      free (PRIV(output_buf));
      PRIV(output_buf) = 0;
d673 1
a673 1
  if (PRIV(sections) != NULL)
d675 2
a676 2
      free (PRIV(sections));
      PRIV(sections) = NULL;
d679 1
a679 1
  if (PRIV(vms_symbol_table))
d681 2
a682 2
      bfd_hash_table_free (PRIV(vms_symbol_table));
      PRIV(vms_symbol_table) = 0;
d685 1
a685 1
  if (PRIV(stack))
d687 2
a688 2
      free (PRIV(stack));
      PRIV(stack) = 0;
d691 1
a691 1
  if (PRIV(location_stack))
d693 2
a694 2
      free (PRIV(location_stack));
      PRIV(location_stack) = 0;
d699 1
a699 1
      es = PRIV(vms_section_table)[i];
d706 1
a706 1
      PRIV(vms_section_table)[i] = NULL;
d738 1
a738 1
  if (abfd->section_count > PRIV(section_count))
d740 3
a742 3
      PRIV(sections) = ((asection **)
			    bfd_realloc (PRIV(sections), abfd->section_count * sizeof (asection *)));
      if (PRIV(sections) == 0)
d744 1
a744 1
      PRIV(section_count) = abfd->section_count;
d747 1
a747 1
  vms_debug (6, "section_count: %d\n", PRIV(section_count));
d749 1
a749 1
  PRIV(sections)[section->index] = section;
d1085 1
a1085 1
  vms_debug (1, "vms_get_symtab_upper_bound(%p), %d symbols\n", abfd, PRIV(gsd_sym_count));
d1087 1
a1087 1
  return (PRIV(gsd_sym_count)+1) * sizeof (asymbol *);
d1103 1
a1103 1
    PRIV(symnum) = 0;
d1105 1
a1105 1
    PRIV(symcache)[PRIV(symnum)++] = ((vms_symbol_entry *)entry)->symbol;
d1129 2
a1130 2
  PRIV(symcache) = symbols;
  bfd_hash_traverse(PRIV(vms_symbol_table), copy_symbols, (PTR)abfd);
d1132 1
a1132 1
  symbols[PRIV(gsd_sym_count)] = NULL;
d1134 1
a1134 1
  return PRIV(gsd_sym_count);
@


1.8
log
@2000-12-23  Kazu Hirata  <kazu@@hxi.com>

	* vms.c: Fix formatting.
	* vms.h: Likewise.
@
text
@a1185 2
      break;

@


1.8.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.8.2.2
log
@Merge from mainline.
@
text
@d245 1
a245 1
  PRIV (is_vax) = 0;
d247 1
a247 1
  PRIV (is_vax) = 1;
d249 6
a254 6
  PRIV (vms_buf) = 0;
  PRIV (buf_size) = 0;
  PRIV (rec_length) = 0;
  PRIV (file_format) = FF_UNKNOWN;
  PRIV (fixup_done) = false;
  PRIV (sections) = NULL;
d256 1
a256 1
  PRIV (stack) = ((struct stack_struct *)
d258 1
a258 1
  if (PRIV (stack) == 0)
d265 1
a265 1
  PRIV (stackptr) = 0;
d267 1
a267 1
  PRIV (vms_symbol_table) = ((struct bfd_hash_table *)
d269 1
a269 1
  if (PRIV (vms_symbol_table) == 0)
d272 2
a273 2
      free (PRIV (stack));
      PRIV (stack) = 0;
d277 1
a277 1
  if (!bfd_hash_table_init (PRIV (vms_symbol_table), _bfd_vms_hash_newfunc))
d280 1
a280 1
  PRIV (location_stack) = ((struct location_struct *)
d283 1
a283 1
  if (PRIV (location_stack) == 0)
d286 2
a287 2
      free (PRIV (vms_symbol_table));
      PRIV (vms_symbol_table) = 0;
d292 1
a292 1
    PRIV (vms_section_table)[i] = NULL;
d294 2
a295 2
  PRIV (output_buf) = (unsigned char *) malloc (MAX_OUTREC_SIZE);
  if (PRIV (output_buf) == 0)
d297 2
a298 2
      free (PRIV (location_stack));
      PRIV (location_stack) = 0;
d301 5
a305 5
  PRIV (push_level) = 0;
  PRIV (pushed_size) = 0;
  PRIV (length_pos) = 2;
  PRIV (output_size) = 0;
  PRIV (output_alignment) = 1;
d361 1
a361 1
  if (PRIV (fixup_done))
d369 3
a371 3
  priv_section_count = PRIV (section_count);
  bfd_hash_traverse (PRIV (vms_symbol_table), fill_section_ptr,
		    (PTR) (PRIV (sections)));
d373 1
a373 1
  PRIV (fixup_done) = true;
d425 1
a425 1
	   && (PRIV (rec_type) != EOBJ_S_C_EGSD))
d437 1
a437 1
      prev_type = PRIV (rec_type);
d593 1
a593 1
      if (PRIV (is_vax))
d653 1
a653 1
  if (PRIV (vms_buf) != NULL)
d655 2
a656 2
      free (PRIV (vms_buf));
      PRIV (vms_buf) = NULL;
d658 1
a658 1
  PRIV (buf_size) = 0;
d660 1
a660 1
  if (PRIV (output_buf) != 0)
d662 2
a663 2
      free (PRIV (output_buf));
      PRIV (output_buf) = 0;
d674 1
a674 1
  if (PRIV (sections) != NULL)
d676 2
a677 2
      free (PRIV (sections));
      PRIV (sections) = NULL;
d680 1
a680 1
  if (PRIV (vms_symbol_table))
d682 2
a683 2
      bfd_hash_table_free (PRIV (vms_symbol_table));
      PRIV (vms_symbol_table) = 0;
d686 1
a686 1
  if (PRIV (stack))
d688 2
a689 2
      free (PRIV (stack));
      PRIV (stack) = 0;
d692 1
a692 1
  if (PRIV (location_stack))
d694 2
a695 2
      free (PRIV (location_stack));
      PRIV (location_stack) = 0;
d700 1
a700 1
      es = PRIV (vms_section_table)[i];
d707 1
a707 1
      PRIV (vms_section_table)[i] = NULL;
d739 1
a739 1
  if (abfd->section_count > PRIV (section_count))
d741 3
a743 3
      PRIV (sections) = ((asection **)
			    bfd_realloc (PRIV (sections), abfd->section_count * sizeof (asection *)));
      if (PRIV (sections) == 0)
d745 1
a745 1
      PRIV (section_count) = abfd->section_count;
d748 1
a748 1
  vms_debug (6, "section_count: %d\n", PRIV (section_count));
d750 1
a750 1
  PRIV (sections)[section->index] = section;
d1086 1
a1086 1
  vms_debug (1, "vms_get_symtab_upper_bound(%p), %d symbols\n", abfd, PRIV (gsd_sym_count));
d1088 1
a1088 1
  return (PRIV (gsd_sym_count)+1) * sizeof (asymbol *);
d1104 1
a1104 1
    PRIV (symnum) = 0;
d1106 1
a1106 1
    PRIV (symcache)[PRIV (symnum)++] = ((vms_symbol_entry *)entry)->symbol;
d1130 2
a1131 2
  PRIV (symcache) = symbols;
  bfd_hash_traverse(PRIV (vms_symbol_table), copy_symbols, (PTR)abfd);
d1133 1
a1133 1
  symbols[PRIV (gsd_sym_count)] = NULL;
d1135 1
a1135 1
  return PRIV (gsd_sym_count);
d1185 2
@


1.7
log
@Fix "incompatible types in return" gcc error.
@
text
@d173 1
a173 1
  
d219 1
a219 1
  
a308 1

a346 1

d370 1
a370 1
		    (PTR)(PRIV(sections)));
d417 1
a417 1
	  vms_debug (2, "next_record failed\n");      
d502 1
a502 1
 
d512 1
a512 1
 
a532 1

a546 1

a579 1

a714 1

a725 1

a756 1

a816 1

a834 1

a852 1

d873 1
a873 1
static boolean 
a901 1

a914 1

a943 1

a956 1

a972 1

a986 1

a1015 1

a1032 1

a1046 1

a1060 1

d1087 1
a1087 1
  return (PRIV(gsd_sym_count)+1) * sizeof(asymbol *);
a1089 1

a1109 1

a1136 1

d1147 1
a1147 1
  asymbol *symbol = (asymbol *)bfd_zalloc(abfd, sizeof(asymbol));
a1162 1

d1183 1
a1183 1
	fprintf((FILE *)file," %s", symbol->name);
d1194 1
a1194 1
	  fprintf((FILE *)file," %-8s %s", section_name, symbol->name);
a1200 1

a1257 1

a1271 1

a1284 1

a1305 1

a1321 1

a1372 1

a1680 1

a1700 1

a1725 1

a1740 1

a1760 1

a1787 1

a1800 1

a1813 1

a1865 1

a1878 1

a1889 1

@


1.6
log
@Revert previous patch.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d1048 1
a1048 1
  return false;
@


1.5
log
@Change AR for ELF so that common symbols are not included in archive map.
Change LD for ELF so that archive elements whoes archive map contains a
 reference to a common symbol will get linkled in.
Add new field to bfd_target structure and initialise it for all bfd targets.
@
text
@a129 1
#define vms_allow_commons_in_armap bfd_true
@


1.4
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d130 1
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@a134 1

d137 2
a138 2
  false,			/* data byte order is little */
  false,			/* header byte order is little */
d172 2
a178 1

d181 2
a182 2
  false,			/* data byte order is little */
  false,			/* header byte order is little */
d218 2
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d29 1
a29 1
static int priv_section_count;
d334 1
a334 1
  if ((int)sec < priv_section_count)
d539 1
a539 1
     bfd *abfd;
d722 1
a722 1
     bfd *abfd;
d769 5
a773 5
     bfd *abfd;
     asection *section;
     PTR buf;
     file_ptr offset;
     bfd_size_type buf_size;
d791 5
a795 5
     bfd *abfd;
     asection *section;
     bfd_window *w;
     file_ptr offset;
     bfd_size_type count;
d814 2
a815 2
     bfd *src;
     bfd *dest;
d833 2
a834 2
     bfd *ibfd;
     bfd *obfd;
d852 2
a853 2
     bfd *abfd;
     flagword flags;
d867 4
a870 4
     bfd *srcbfd;
     asection *srcsec;
     bfd *dstbfd;
     asection *dstsec;
d884 4
a887 4
     bfd *ibfd;
     asymbol *isym;
     bfd *obfd;
     asymbol *osym;
d903 1
a903 1
     bfd *abfd;
d917 1
a917 1
     bfd *abfd;
d931 2
a932 2
     bfd *abfd;
     bfd *bbfd;
d947 1
a947 1
     bfd *abfd;
d961 1
a961 1
     bfd *abfd;
d975 4
a978 4
     bfd *abfd;
     char **tabloc;
     bfd_size_type *tablen;
     const char **name;
d991 3
a993 3
     bfd *abfd;
     CONST char *pathname;
     char *arhdr;
d1006 5
a1010 5
     bfd *arch;
     unsigned int elength;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
d1023 1
a1023 1
    bfd * abfd;
d1040 2
a1041 2
     bfd *arch;
     bfd *prev;
d1084 1
a1084 1
     bfd *abfd;
d1193 1
a1193 1
     bfd *abfd;
d1241 1
a1241 1
     bfd *abfd;
d1288 1
a1288 1
     bfd *abfd;
d1302 2
a1303 2
     bfd *abfd;
     asymbol *symbol;
d1318 7
a1324 7
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     CONST char **file;
     CONST char **func;
     unsigned int *line;
d1340 3
a1342 3
     bfd *abfd;
     void *ptr;
     unsigned long size;
d1393 2
a1394 2
     bfd *abfd;
     asection *section;
d1411 4
a1414 4
     bfd *abfd;
     asection *section;
     arelent **location;
     asymbol **symbols;
d1429 7
a1435 7
     bfd *abfd;
     arelent *reloc;
     asymbol *sym;
     PTR data;
     asection *sec;
     bfd *output_bfd;
     char **error_message;
d1679 1
a1679 1
     bfd *abfd;
d1721 2
a1722 2
     enum bfd_architecture arch;
     unsigned long mach;
d1765 2
a1766 2
     bfd *abfd;
     boolean reloc;
d1781 6
a1786 6
     bfd *abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     boolean relocateable;
     asymbol **symbols;
d1800 4
a1803 4
     bfd *abfd;
     asection *section;
     struct bfd_link_info *link_info;
     boolean *again;
d1814 2
a1815 2
     bfd *abfd;
     struct bfd_link_info *link_info;
d1829 1
a1829 1
     bfd *abfd;
d1842 2
a1843 2
     bfd *abfd;
     struct bfd_link_info *link_info;
d1857 2
a1858 2
     bfd *abfd;
     struct bfd_link_info *link_info;
d1870 2
a1871 2
     bfd *abfd;
     asection *section;
d1885 1
a1885 1
     bfd *abfd;
d1895 2
a1896 2
    bfd *abfd;
    void *file;
d1909 2
a1910 2
     bfd *abfd;
     asymbol **symbols;
d1923 1
a1923 1
     bfd *abfd;
d1936 3
a1938 3
     bfd *abfd;
     arelent **arel;
     asymbol **symbols;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998 Free Software Foundation, Inc.
a359 2
  asection *s;

a646 1
  vms_reloc *er, *er1;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

