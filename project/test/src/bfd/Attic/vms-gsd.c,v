head	1.25;
access;
symbols
	binutils-2_20_1:1.22
	sid-snapshot-20100401:1.24
	gdb_7_1-2010-03-18-release:1.24
	sid-snapshot-20100301:1.24
	gdb_7_1-branch:1.24.0.2
	gdb_7_1-2010-02-18-branchpoint:1.24
	sid-snapshot-20100201:1.24
	sid-snapshot-20100101:1.23
	gdb_7_0_1-2009-12-22-release:1.22
	sid-snapshot-20091201:1.22
	sid-snapshot-20091101:1.22
	binutils-2_20:1.22
	gdb_7_0-2009-10-06-release:1.22
	sid-snapshot-20091001:1.22
	gdb_7_0-branch:1.22.0.8
	gdb_7_0-2009-09-16-branchpoint:1.22
	arc-sim-20090309:1.21
	binutils-arc-20081103-branch:1.21.0.26
	binutils-arc-20081103-branchpoint:1.21
	binutils-2_20-branch:1.22.0.6
	binutils-2_20-branchpoint:1.22
	sid-snapshot-20090901:1.22
	sid-snapshot-20090801:1.22
	msnyder-checkpoint-072509-branch:1.22.0.4
	msnyder-checkpoint-072509-branchpoint:1.22
	sid-snapshot-20090701:1.22
	dje-cgen-play1-branch:1.22.0.2
	dje-cgen-play1-branchpoint:1.22
	sid-snapshot-20090601:1.22
	sid-snapshot-20090501:1.22
	sid-snapshot-20090401:1.22
	arc-20081103-branch:1.21.0.24
	arc-20081103-branchpoint:1.21
	arc-insight_6_8-branch:1.21.0.22
	arc-insight_6_8-branchpoint:1.21
	insight_6_8-branch:1.21.0.20
	insight_6_8-branchpoint:1.21
	sid-snapshot-20090301:1.22
	binutils-2_19_1:1.21
	sid-snapshot-20090201:1.21
	sid-snapshot-20090101:1.21
	reverse-20081226-branch:1.21.0.18
	reverse-20081226-branchpoint:1.21
	sid-snapshot-20081201:1.21
	multiprocess-20081120-branch:1.21.0.16
	multiprocess-20081120-branchpoint:1.21
	sid-snapshot-20081101:1.21
	binutils-2_19:1.21
	sid-snapshot-20081001:1.21
	reverse-20080930-branch:1.21.0.14
	reverse-20080930-branchpoint:1.21
	binutils-2_19-branch:1.21.0.12
	binutils-2_19-branchpoint:1.21
	sid-snapshot-20080901:1.21
	sid-snapshot-20080801:1.21
	reverse-20080717-branch:1.21.0.10
	reverse-20080717-branchpoint:1.21
	sid-snapshot-20080701:1.21
	msnyder-reverse-20080609-branch:1.21.0.8
	msnyder-reverse-20080609-branchpoint:1.21
	drow-reverse-20070409-branch:1.19.0.34
	drow-reverse-20070409-branchpoint:1.19
	sid-snapshot-20080601:1.21
	sid-snapshot-20080501:1.21
	sid-snapshot-20080403:1.21
	sid-snapshot-20080401:1.21
	gdb_6_8-2008-03-27-release:1.21
	sid-snapshot-20080301:1.21
	gdb_6_8-branch:1.21.0.6
	gdb_6_8-2008-02-26-branchpoint:1.21
	sid-snapshot-20080201:1.21
	sid-snapshot-20080101:1.21
	sid-snapshot-20071201:1.21
	sid-snapshot-20071101:1.21
	gdb_6_7_1-2007-10-29-release:1.21
	gdb_6_7-2007-10-10-release:1.21
	sid-snapshot-20071001:1.21
	gdb_6_7-branch:1.21.0.4
	gdb_6_7-2007-09-07-branchpoint:1.21
	binutils-2_18:1.21
	binutils-2_18-branch:1.21.0.2
	binutils-2_18-branchpoint:1.21
	insight_6_6-20070208-release:1.19
	binutils-csl-coldfire-4_1-32:1.19
	binutils-csl-sourcerygxx-4_1-32:1.19
	gdb_6_6-2006-12-18-release:1.19
	binutils-csl-innovasic-fido-3_4_4-33:1.19
	binutils-csl-sourcerygxx-3_4_4-32:1.16
	binutils-csl-coldfire-4_1-30:1.19
	binutils-csl-sourcerygxx-4_1-30:1.19
	binutils-csl-coldfire-4_1-28:1.19
	binutils-csl-sourcerygxx-4_1-29:1.19
	binutils-csl-sourcerygxx-4_1-28:1.19
	gdb_6_6-branch:1.19.0.32
	gdb_6_6-2006-11-15-branchpoint:1.19
	binutils-csl-arm-2006q3-27:1.19
	binutils-csl-sourcerygxx-4_1-27:1.19
	binutils-csl-arm-2006q3-26:1.19
	binutils-csl-sourcerygxx-4_1-26:1.19
	binutils-csl-sourcerygxx-4_1-25:1.19
	binutils-csl-sourcerygxx-4_1-24:1.19
	binutils-csl-sourcerygxx-4_1-23:1.19
	insight_6_5-20061003-release:1.19
	gdb-csl-symbian-6_4_50_20060226-12:1.19
	binutils-csl-sourcerygxx-4_1-21:1.19
	binutils-csl-arm-2006q3-21:1.19
	binutils-csl-sourcerygxx-4_1-22:1.19
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.19
	binutils-csl-sourcerygxx-4_1-20:1.19
	binutils-csl-arm-2006q3-19:1.19
	binutils-csl-sourcerygxx-4_1-19:1.19
	binutils-csl-sourcerygxx-4_1-18:1.19
	binutils-csl-renesas-4_1-9:1.19
	gdb-csl-sourcerygxx-3_4_4-25:1.19
	binutils-csl-sourcerygxx-3_4_4-25:1.16
	nickrob-async-20060828-mergepoint:1.19
	gdb-csl-symbian-6_4_50_20060226-11:1.19
	binutils-csl-renesas-4_1-8:1.19
	binutils-csl-renesas-4_1-7:1.19
	binutils-csl-renesas-4_1-6:1.19
	gdb-csl-sourcerygxx-4_1-17:1.19
	binutils-csl-sourcerygxx-4_1-17:1.19
	gdb-csl-20060226-branch-local-2:1.19
	gdb-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-15:1.19
	gdb-csl-sourcerygxx-4_1-13:1.19
	binutils-csl-sourcerygxx-4_1-13:1.19
	binutils-2_17:1.19
	gdb-csl-sourcerygxx-4_1-12:1.19
	binutils-csl-sourcerygxx-4_1-12:1.19
	gdb-csl-sourcerygxx-3_4_4-21:1.19
	binutils-csl-sourcerygxx-3_4_4-21:1.19
	gdb_6_5-20060621-release:1.19
	binutils-csl-wrs-linux-3_4_4-24:1.16
	binutils-csl-wrs-linux-3_4_4-23:1.16
	gdb-csl-sourcerygxx-4_1-9:1.19
	binutils-csl-sourcerygxx-4_1-9:1.19
	gdb-csl-sourcerygxx-4_1-8:1.19
	binutils-csl-sourcerygxx-4_1-8:1.19
	gdb-csl-sourcerygxx-4_1-7:1.19
	binutils-csl-sourcerygxx-4_1-7:1.19
	gdb-csl-arm-2006q1-6:1.19
	binutils-csl-arm-2006q1-6:1.19
	gdb-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-wrs-linux-3_4_4-22:1.16
	gdb-csl-symbian-6_4_50_20060226-10:1.19
	gdb-csl-symbian-6_4_50_20060226-9:1.19
	gdb-csl-symbian-6_4_50_20060226-8:1.19
	gdb-csl-coldfire-4_1-11:1.19
	binutils-csl-coldfire-4_1-11:1.19
	gdb-csl-sourcerygxx-3_4_4-19:1.19
	binutils-csl-sourcerygxx-3_4_4-19:1.19
	gdb-csl-coldfire-4_1-10:1.19
	gdb_6_5-branch:1.19.0.30
	gdb_6_5-2006-05-14-branchpoint:1.19
	binutils-csl-coldfire-4_1-10:1.19
	gdb-csl-sourcerygxx-4_1-5:1.19
	binutils-csl-sourcerygxx-4_1-5:1.19
	nickrob-async-20060513-branch:1.19.0.28
	nickrob-async-20060513-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-4:1.19
	binutils-csl-sourcerygxx-4_1-4:1.19
	msnyder-reverse-20060502-branch:1.19.0.26
	msnyder-reverse-20060502-branchpoint:1.19
	binutils-csl-wrs-linux-3_4_4-21:1.16
	gdb-csl-morpho-4_1-4:1.19
	binutils-csl-morpho-4_1-4:1.19
	gdb-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-wrs-linux-3_4_4-20:1.16
	readline_5_1-import-branch:1.19.0.24
	readline_5_1-import-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19
	binutils-2_17-branch:1.19.0.22
	binutils-2_17-branchpoint:1.19
	gdb-csl-symbian-20060226-branch:1.19.0.20
	gdb-csl-symbian-20060226-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19
	msnyder-reverse-20060331-branch:1.19.0.18
	msnyder-reverse-20060331-branchpoint:1.19
	binutils-csl-2_17-branch:1.19.0.16
	binutils-csl-2_17-branchpoint:1.19
	gdb-csl-available-20060303-branch:1.19.0.14
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.12
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.19
	msnyder-fork-checkpoint-branch:1.19.0.10
	msnyder-fork-checkpoint-branchpoint:1.19
	gdb-csl-gxxpro-6_3-branch:1.19.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.19
	gdb_6_4-branch:1.19.0.6
	gdb_6_4-2005-11-01-branchpoint:1.19
	gdb-csl-arm-20051020-branch:1.19.0.4
	gdb-csl-arm-20051020-branchpoint:1.19
	binutils-csl-gxxpro-3_4-branch:1.16.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.16
	binutils-2_16_1:1.16
	msnyder-tracepoint-checkpoint-branch:1.19.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.19
	gdb-csl-arm-20050325-2005-q1b:1.16
	binutils-csl-arm-2005q1b:1.16
	binutils-2_16:1.16
	gdb-csl-arm-20050325-2005-q1a:1.16
	binutils-csl-arm-2005q1a:1.16
	csl-arm-20050325-branch:1.16.0.6
	csl-arm-20050325-branchpoint:1.16
	binutils-csl-arm-2005q1-branch:1.16.0.4
	binutils-csl-arm-2005q1-branchpoint:1.16
	binutils-2_16-branch:1.16.0.2
	binutils-2_16-branchpoint:1.16
	csl-arm-2004-q3d:1.14
	gdb_6_3-20041109-release:1.14
	gdb_6_3-branch:1.14.0.4
	gdb_6_3-20041019-branchpoint:1.14
	csl-arm-2004-q3:1.14
	drow_intercu-merge-20040921:1.14
	drow_intercu-merge-20040915:1.14
	jimb-gdb_6_2-e500-branch:1.14.0.6
	jimb-gdb_6_2-e500-branchpoint:1.14
	gdb_6_2-20040730-release:1.14
	gdb_6_2-branch:1.14.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.14
	gdb_6_1_1-20040616-release:1.13
	binutils-2_15:1.13
	binutils-2_15-branchpoint:1.13
	csl-arm-2004-q1a:1.13
	csl-arm-2004-q1:1.13
	gdb_6_1-2004-04-05-release:1.13
	drow_intercu-merge-20040402:1.13
	drow_intercu-merge-20040327:1.13
	ezannoni_pie-20040323-branch:1.13.0.14
	ezannoni_pie-20040323-branchpoint:1.13
	cagney_tramp-20040321-mergepoint:1.13
	cagney_tramp-20040309-branch:1.13.0.12
	cagney_tramp-20040309-branchpoint:1.13
	gdb_6_1-branch:1.13.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.13
	drow_intercu-20040221-branch:1.13.0.8
	drow_intercu-20040221-branchpoint:1.13
	binutils-2_15-branch:1.13.0.6
	cagney_bfdfile-20040213-branch:1.13.0.4
	cagney_bfdfile-20040213-branchpoint:1.13
	drow-cplus-merge-20040208:1.13
	carlton_dictionary-20040126-merge:1.13
	cagney_bigcore-20040122-branch:1.13.0.2
	cagney_bigcore-20040122-branchpoint:1.13
	drow-cplus-merge-20040113:1.13
	csl-arm-2003-q4:1.13
	drow-cplus-merge-20031224:1.13
	drow-cplus-merge-20031220:1.13
	carlton_dictionary-20031215-merge:1.13
	drow-cplus-merge-20031214:1.13
	carlton-dictionary-20031111-merge:1.12
	gdb_6_0-2003-10-04-release:1.12
	kettenis_sparc-20030918-branch:1.12.0.42
	kettenis_sparc-20030918-branchpoint:1.12
	carlton_dictionary-20030917-merge:1.12
	ezannoni_pie-20030916-branchpoint:1.12
	ezannoni_pie-20030916-branch:1.12.0.40
	cagney_x86i386-20030821-branch:1.12.0.38
	cagney_x86i386-20030821-branchpoint:1.12
	carlton_dictionary-20030805-merge:1.12
	carlton_dictionary-20030627-merge:1.12
	gdb_6_0-branch:1.12.0.36
	gdb_6_0-2003-06-23-branchpoint:1.12
	jimb-ppc64-linux-20030613-branch:1.12.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.12
	binutils-2_14:1.12
	cagney_convert-20030606-branch:1.12.0.32
	cagney_convert-20030606-branchpoint:1.12
	cagney_writestrings-20030508-branch:1.12.0.30
	cagney_writestrings-20030508-branchpoint:1.12
	jimb-ppc64-linux-20030528-branch:1.12.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.12
	carlton_dictionary-20030523-merge:1.12
	cagney_fileio-20030521-branch:1.12.0.26
	cagney_fileio-20030521-branchpoint:1.12
	kettenis_i386newframe-20030517-mergepoint:1.12
	jimb-ppc64-linux-20030509-branch:1.12.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.12
	kettenis_i386newframe-20030504-mergepoint:1.12
	carlton_dictionary-20030430-merge:1.12
	binutils-2_14-branch:1.12.0.22
	binutils-2_14-branchpoint:1.12
	kettenis_i386newframe-20030419-branch:1.12.0.20
	kettenis_i386newframe-20030419-branchpoint:1.12
	carlton_dictionary-20030416-merge:1.12
	cagney_frameaddr-20030409-mergepoint:1.12
	kettenis_i386newframe-20030406-branch:1.12.0.18
	kettenis_i386newframe-20030406-branchpoint:1.12
	cagney_frameaddr-20030403-branchpoint:1.12
	cagney_frameaddr-20030403-branch:1.12.0.16
	cagney_framebase-20030330-mergepoint:1.12
	cagney_framebase-20030326-branch:1.12.0.14
	cagney_framebase-20030326-branchpoint:1.12
	cagney_lazyid-20030317-branch:1.12.0.12
	cagney_lazyid-20030317-branchpoint:1.12
	kettenis-i386newframe-20030316-mergepoint:1.12
	offbyone-20030313-branch:1.12.0.10
	offbyone-20030313-branchpoint:1.12
	kettenis-i386newframe-20030308-branch:1.12.0.8
	kettenis-i386newframe-20030308-branchpoint:1.12
	carlton_dictionary-20030305-merge:1.12
	cagney_offbyone-20030303-branch:1.12.0.6
	cagney_offbyone-20030303-branchpoint:1.12
	carlton_dictionary-20030207-merge:1.12
	interps-20030202-branch:1.12.0.4
	interps-20030202-branchpoint:1.12
	cagney-unwind-20030108-branch:1.12.0.2
	cagney-unwind-20030108-branchpoint:1.12
	binutils-2_13_2_1:1.10.2.1
	binutils-2_13_2:1.10.2.1
	carlton_dictionary-20021223-merge:1.12
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.11
	binutils-2_13_1:1.10.2.1
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.14
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.12
	carlton_dictionary-20020920-branchpoint:1.10
	sid-20020905-branchpoint:1.10
	sid-20020905-branch:1.10.0.10
	gdb_5_3-branch:1.10.0.8
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.6
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.4
	readline_4_3-import-branchpoint:1.10
	binutils-2_13:1.10
	gdb_5_2_1-2002-07-23-release:1.9
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	kseitz_interps-20020528-branch:1.9.0.10
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.8
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.9
	jimb-macro-020506-branch:1.9.0.6
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	binutils-2_12:1.9
	gdb_5_2-branch:1.9.0.4
	gdb_5_2-2002-03-03-branchpoint:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	binutils-2_11_2:1.4.2.1
	binutils-2_11_1:1.4.2.1
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	insight-precleanup-2001-01-01:1.4
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.4
	gdb_5_0-2000-04-10-branchpoint:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.24
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2010.04.14.09.24.59;	author gingold;	state dead;
branches;
next	1.24;

1.24
date	2010.01.27.16.43.27;	author gingold;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.23.09.28.42;	author gingold;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.04.15.53.40;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.04.07.19.38;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.21.07.45.38;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.03.11.41.01;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.24.13.34.38;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.24.04.46.26;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.05.01.08.18;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.07.15.04.49;	author amodra;	state Exp;
branches
	1.10.2.1
	1.10.12.1
	1.10.14.1;
next	1.9;

1.9
date	2002.01.06.07.30.35;	author amodra;	state Exp;
branches
	1.9.8.1
	1.9.10.1;
next	1.8;

1.8
date	2001.09.19.05.33.13;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.01.10.29.27;	author aj;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.26.19.50.50;	author kazu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.07.12.10.30.11;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.07.35.16;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;

1.4.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.9.8.1
date	2002.06.15.16.42.42;	author cagney;	state Exp;
branches;
next	;

1.9.10.1
date	2002.06.20.01.31.15;	author kseitz;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2002.11.05.20.33.26;	author ezannoni;	state Exp;
branches;
next	;

1.10.2.1
date	2002.11.06.04.34.59;	author drow;	state Exp;
branches;
next	;

1.10.12.1
date	2002.11.15.19.18.29;	author carlton;	state Exp;
branches;
next	1.10.12.2;

1.10.12.2
date	2002.12.23.19.38.01;	author carlton;	state Exp;
branches;
next	1.10.12.3;

1.10.12.3
date	2003.12.15.23.59.54;	author carlton;	state Exp;
branches;
next	;

1.10.14.1
date	2003.12.14.20.26.53;	author drow;	state Exp;
branches;
next	;

1.13.8.1
date	2004.09.16.17.00.38;	author drow;	state Exp;
branches;
next	;


desc
@@


1.25
log
@2010-04-14  Tristan Gingold  <gingold@@adacore.com>

	* Makefile.am (BFD32_BACKENDS): Remove vms-gsd.lo, vms-hdr.lo,
	vms-tir.lo, vms.lo and add vms-alpha.lo
	(BFD32_BACKENDS_CFILES): Remove vms-gsd.c, vms-hdr.c,
	vms-tir.c, vms.c and add vms-alpha.c
	* Makefile.in: Regenerate.
	* configure.in (TDEFINES): Adjust file list for vms_alpha_vec.
	Remove vms_vax_vec.
	* configure: Regenerate.
	* targets.c (vms_vax_vec): Remove the declaration.
	(_bfd_target_vector): Remove vms_vax_vec.
	* vms-alpha.c: New file.
	* vms-gsd.c: Removed, rewritten in vms-alpha.c
	* vms-hdr.c: Ditto.
	* vms-tir.c: Ditto.
	* vms.c: Ditto.
	* vms-misc.c: Fix indentation and comments.  Replace most of
	#if VMS_DEBUG/vms_debug with vms_debug2.
	(_bfd_vms_hash_newfunc): Moved to vms-alpha.c
	(hash_string): Ditto.
	(_bfd_vms_length_hash_symbol): Ditto.
	(maybe_adjust_record_pointer_for_object): Ditto.
	(_bfd_vms_get_object_record): Ditto.
	(vms_get_remaining_object_record): Ditto.
	(_bfd_vms_push): Ditto.
	(_bfd_vms_pop): Ditto.
	(_bfd_vms_get_header_values): Removed.
	(_bfd_vms_get_first_record): Removed.
	(vms_get_remaining_image_record): Removed.
	(new_symbol): Removed.
	(_bfd_vms_enter_symbol): Removed.
	(_bfd_vms_save_sized_string): Use memcpy instead of strncpy.
	(_bfd_vms_output_begin): Remove rechead parameter.  Replace bfd
	parameter with struct vms_rec_wr.
	(_bfd_vms_output_push): Removed and replaced by ...
	(_bfd_vms_output_begin_subrec): ... new function.
	(_bfd_vms_output_alignment): Replace bfd parameter with
	struct vms_rec_wr, and adjust.
	(_bfd_vms_output_check): Ditto
	(_bfd_vms_output_byte): Ditto.
	(_bfd_vms_output_short): Ditto.
	(_bfd_vms_output_long): Ditto.
	(_bfd_vms_output_quad): Ditto.
	(_bfd_vms_output_counted): Ditto.
	(_bfd_vms_output_dump): Ditto.
	(_bfd_vms_output_fill): Ditto.
	(_bfd_vms_output_pop): Removed and replaced by ...
	(_bfd_vms_output_end_subrec): ... new function.
	(_bfd_vms_output_flush): Removed.
	(_bfd_vms_output_align): New function.
	(_bfd_vms_output_end): Add recwr parameter.  Adjust for this new
	parameter.
	(vms_convert_to_var): New function imported from vms.c
	(vms_convert_to_var_1): Ditto.
	(vms_convert_to_var_unix_filename): Ditto.
	(vms_get_module_name): Ditto.
	(get_vms_time_string): Ditto.
	(vms_time_to_time_t): Ditto.
	(vms_rawtime_to_time_t): Ditto.
	* vms.h: All macros for the VMS file format are now in include/vms.
	Prototypes for vms.c, vms-gsd.c, vms-misc.c, vms-hdr.c, vms-tir.c
	have been removed.
	(struct vms_symbol_struct, struct stack_struct): Moved to vms-alpha.c
	(struct fileinfo, struct srecinfo, struct lineinfo): Ditto.
	(struct funcinfo, struct vms_private_data_struct): Ditto.
	(struct vms_section_data_struct): Ditto.
	(struct vms_rec_rd, stryct vms_rec_wr): New declarations.
	(vms_get_module_name, get_vms_time_string): New declarations.
	(vms_time_to_time_t, vms_rawtime_to_time_t): Ditto.
	(_bfd_vms_output_begin_subrec, _bfd_vms_output_end_subrec): Ditto.
	(_bfd_vms_save_sized_string, _bfd_vms_save_counted_string): Adjusted.
	(_bfd_vms_output_begin, _bfd_vms_output_alignment): Ditto.
	(_bfd_vms_output_end,_bfd_vms_output_check): Ditto.
	(_bfd_vms_output_byte, _bfd_vms_output_short): Ditto.
	(_bfd_vms_output_long, _bfd_vms_output_quad): Ditto.
	(_bfd_vms_output_counted, _bfd_vms_output_dump): Ditto.
	(_bfd_vms_output_fill): Ditto.
	(bfd_vms_set_section_flags): Ditto.
@
text
@/* vms-gsd.c -- BFD back-end for VAX (openVMS/VAX) and
   EVAX (openVMS/Alpha) files.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2007, 2009 Free Software Foundation, Inc.

   GSD record handling functions
   EGSD record handling functions

   Go and read the openVMS linker manual (esp. appendix B)
   if you don't know what's going on here :-)

   Written by Klaus K"ampf (kkaempf@@rmi.de)

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"

#include "vms.h"

/* Typical sections for vax object files.  */

#define VAX_CODE_NAME		"$CODE"
#define VAX_DATA_NAME		"$DATA"
#define VAX_ADDRESS_DATA_NAME	"$ADDRESS_DATA"

/* Typical sections for evax object files.  */

#define EVAX_ABS_NAME		"$ABS$"
#define EVAX_CODE_NAME		"$CODE$"
#define EVAX_LINK_NAME		"$LINK$"
#define EVAX_DATA_NAME		"$DATA$"
#define EVAX_BSS_NAME		"$BSS$"
#define EVAX_READONLYADDR_NAME	"$READONLY_ADDR$"
#define EVAX_READONLY_NAME	"$READONLY$"
#define EVAX_LITERAL_NAME	"$LITERAL$"
#define EVAX_LITERALS_NAME	"$LITERALS"
#define EVAX_COMMON_NAME	"$COMMON$"
#define EVAX_LOCAL_NAME		"$LOCAL$"

struct sec_flags_struct
{
  char *name;			/* Name of section.  */
  int vflags_always;
  flagword flags_always;	/* Flags we set always.  */
  int vflags_hassize;
  flagword flags_hassize;	/* Flags we set if the section has a size > 0.  */
};

/* These flags are deccrtl/vaxcrtl (openVMS 6.2 VAX) compatible.  */

static struct sec_flags_struct vax_section_flags[] =
  {
    { VAX_CODE_NAME,
      (GPS_S_M_PIC | GPS_S_M_REL | GPS_S_M_SHR | GPS_S_M_EXE | GPS_S_M_RD),
      (SEC_CODE),
      (GPS_S_M_PIC | GPS_S_M_REL | GPS_S_M_SHR | GPS_S_M_EXE | GPS_S_M_RD),
      (SEC_IN_MEMORY | SEC_CODE | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD) },
    { VAX_DATA_NAME,
      (GPS_S_M_PIC | GPS_S_M_REL | GPS_S_M_RD | GPS_S_M_WRT),
      (SEC_DATA),
      (GPS_S_M_PIC | GPS_S_M_REL | GPS_S_M_RD | GPS_S_M_WRT),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD) },
    { VAX_ADDRESS_DATA_NAME,
      (GPS_S_M_PIC | GPS_S_M_REL | GPS_S_M_RD),
      (SEC_DATA | SEC_READONLY),
      (GPS_S_M_PIC | GPS_S_M_REL | GPS_S_M_RD),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_READONLY | SEC_LOAD) },
    { NULL,
      (GPS_S_M_PIC | GPS_S_M_OVR | GPS_S_M_REL | GPS_S_M_GBL | GPS_S_M_RD | GPS_S_M_WRT),
      (SEC_DATA),
      (GPS_S_M_PIC | GPS_S_M_OVR | GPS_S_M_REL | GPS_S_M_GBL | GPS_S_M_RD | GPS_S_M_WRT),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD) }
  };

/* These flags are deccrtl/vaxcrtl (openVMS 6.2 Alpha) compatible.  */

static struct sec_flags_struct evax_section_flags[] =
  {
    { EVAX_ABS_NAME,
      (EGPS_S_V_SHR),
      (SEC_DATA),
      (EGPS_S_V_SHR),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD) },
    { EVAX_CODE_NAME,
      (EGPS_S_V_PIC | EGPS_S_V_REL | EGPS_S_V_SHR | EGPS_S_V_EXE),
      (SEC_CODE),
      (EGPS_S_V_PIC | EGPS_S_V_REL | EGPS_S_V_SHR | EGPS_S_V_EXE),
      (SEC_IN_MEMORY | SEC_CODE | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD) },
    { EVAX_LITERAL_NAME,
      (EGPS_S_V_PIC | EGPS_S_V_REL | EGPS_S_V_SHR | EGPS_S_V_RD | EGPS_S_V_NOMOD),
      (SEC_DATA | SEC_READONLY),
      (EGPS_S_V_PIC | EGPS_S_V_REL | EGPS_S_V_SHR | EGPS_S_V_RD),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_READONLY | SEC_LOAD) },
    { EVAX_LINK_NAME,
      (EGPS_S_V_REL | EGPS_S_V_RD),
      (SEC_DATA | SEC_READONLY),
      (EGPS_S_V_REL | EGPS_S_V_RD),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_READONLY | SEC_LOAD) },
    { EVAX_DATA_NAME,
      (EGPS_S_V_REL | EGPS_S_V_RD | EGPS_S_V_WRT | EGPS_S_V_NOMOD),
      (SEC_DATA),
      (EGPS_S_V_REL | EGPS_S_V_RD | EGPS_S_V_WRT),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD) },
    { EVAX_BSS_NAME,
      (EGPS_S_V_REL | EGPS_S_V_RD | EGPS_S_V_WRT | EGPS_S_V_NOMOD),
      (SEC_NO_FLAGS),
      (EGPS_S_V_REL | EGPS_S_V_RD | EGPS_S_V_WRT | EGPS_S_V_NOMOD),
      (SEC_IN_MEMORY | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD) },
    { EVAX_READONLYADDR_NAME,
      (EGPS_S_V_PIC | EGPS_S_V_REL | EGPS_S_V_RD),
      (SEC_DATA | SEC_READONLY),
      (EGPS_S_V_PIC | EGPS_S_V_REL | EGPS_S_V_RD),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_READONLY | SEC_LOAD) },
    { EVAX_READONLY_NAME,
      (EGPS_S_V_PIC | EGPS_S_V_REL | EGPS_S_V_SHR | EGPS_S_V_RD | EGPS_S_V_NOMOD),
      (SEC_DATA | SEC_READONLY),
      (EGPS_S_V_PIC | EGPS_S_V_REL | EGPS_S_V_SHR | EGPS_S_V_RD),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_READONLY | SEC_LOAD) },
    { EVAX_LOCAL_NAME,
      (EGPS_S_V_REL | EGPS_S_V_RD | EGPS_S_V_WRT),
      (SEC_DATA),
      (EGPS_S_V_REL | EGPS_S_V_RD | EGPS_S_V_WRT),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD) },
    { EVAX_LITERALS_NAME,
      (EGPS_S_V_PIC | EGPS_S_V_OVR),
      (SEC_DATA | SEC_READONLY),
      (EGPS_S_V_PIC | EGPS_S_V_OVR),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_READONLY | SEC_LOAD) },
    { NULL,
      (EGPS_S_V_REL | EGPS_S_V_RD | EGPS_S_V_WRT),
      (SEC_DATA),
      (EGPS_S_V_REL | EGPS_S_V_RD | EGPS_S_V_WRT),
      (SEC_IN_MEMORY | SEC_DATA | SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD) }
  };

/* Retrieve bfd section flags by name and size.  */

static flagword
vms_secflag_by_name (bfd *abfd,
		     struct sec_flags_struct *section_flags,
		     char *name,
		     int hassize)
{
  int i = 0;

  while (section_flags[i].name != NULL)
    {
      if ((PRIV (is_vax)?
	   strcasecmp (name, section_flags[i].name):
	   strcmp (name, section_flags[i].name)) == 0)
	{
	  if (hassize)
	    return section_flags[i].flags_hassize;
	  else
	    return section_flags[i].flags_always;
	}
      i++;
    }
  if (hassize)
    return section_flags[i].flags_hassize;
  return section_flags[i].flags_always;
}

/* Retrieve vms section flags by name and size.  */

static flagword
vms_esecflag_by_name (struct sec_flags_struct *section_flags,
		      char *name,
		      int hassize)
{
  int i = 0;

  while (section_flags[i].name != NULL)
    {
      if (strcmp (name, section_flags[i].name) == 0)
	{
	  if (hassize)
	    return section_flags[i].vflags_hassize;
	  else
	    return section_flags[i].vflags_always;
	}
      i++;
    }
  if (hassize)
    return section_flags[i].vflags_hassize;
  return section_flags[i].vflags_always;
}

#if VMS_DEBUG

struct flagdescstruct { const char *name; flagword value; };

static const struct flagdescstruct gpsflagdesc[] =
{
  { "PIC", GPS_S_M_PIC },
  { "LIB", GPS_S_M_LIB },
  { "OVR", GPS_S_M_OVR },
  { "REL", GPS_S_M_REL },
  { "GBL", GPS_S_M_GBL },
  { "SHR", GPS_S_M_SHR },
  { "EXE", GPS_S_M_EXE },
  { "RD",  GPS_S_M_RD },
  { "WRT", GPS_S_M_WRT },
  { "VEC", GPS_S_M_VEC },
  { "NOMOD", EGPS_S_V_NOMOD },
  { "COM", EGPS_S_V_COM },
  { NULL, 0 }
};

static const struct flagdescstruct gsyflagdesc[] =
{
  { "WEAK", GSY_S_M_WEAK },
  { "DEF",  GSY_S_M_DEF },
  { "UNI",  GSY_S_M_UNI },
  { "REL",  GSY_S_M_REL },
  { "COMM", EGSY_S_V_COMM },
  { "VECEP", EGSY_S_V_VECEP },
  { "NORM", EGSY_S_V_NORM },
  { NULL, 0 }
};

static char *flag2str (struct flagdescstruct *, flagword);

/* Convert flag to printable string.  */

static char *
flag2str (struct flagdescstruct * flagdesc, flagword flags)
{
  static char res[64];
  int next = 0;

  res[0] = 0;
  while (flagdesc->name != NULL)
    {
      if ((flags & flagdesc->value) != 0)
	{
	  if (next)
	    strcat (res, ",");
	  else
	    next = 1;
	  strcat (res, flagdesc->name);
	}
      flagdesc++;
    }
  return res;
}
#endif

/* Input routines.  */

static int register_universal_symbol (bfd *abfd, asymbol *symbol,
				      int vms_flags);

/* Process GSD/EGSD record
   return 0 on success, -1 on error.  */

int
_bfd_vms_slurp_gsd (bfd * abfd, int objtype)
{
  int gsd_type, gsd_size;
  asection *section;
  unsigned char *vms_rec;
  flagword new_flags, old_flags;
  char *name;
  asymbol *symbol;
  vms_symbol_entry *entry;
  unsigned long base_addr;
  unsigned long align_addr;
  static unsigned int psect_idx = 0;

#if VMS_DEBUG
  vms_debug (2, "GSD/EGSD (%d/%x)\n", objtype, objtype);
#endif

  switch (objtype)
    {
    case EOBJ_S_C_EGSD:
      PRIV (vms_rec) += 8;	/* Skip type, size, l_temp.  */
      PRIV (rec_size) -= 8;
      break;
    case OBJ_S_C_GSD:
      PRIV (vms_rec) += 1;
      PRIV (rec_size) -= 1;
      break;
    default:
      return -1;
    }

  /* Calculate base address for each section.  */
  base_addr = 0L;

  abfd->symcount = 0;

  while (PRIV (rec_size) > 0)
    {
      vms_rec = PRIV (vms_rec);

      if (objtype == OBJ_S_C_GSD)
	gsd_type = vms_rec[0];
      else
	{
	  _bfd_vms_get_header_values (abfd, vms_rec, &gsd_type, &gsd_size);
	  gsd_type += EVAX_OFFSET;
	}

#if VMS_DEBUG
      vms_debug (3, "gsd_type %d\n", gsd_type);
#endif

      switch (gsd_type)
	{
	case GSD_S_C_PSC:
	  {
	    /* Program section definition.  */
	    asection *old_section = 0;

#if VMS_DEBUG
	    vms_debug (4, "GSD_S_C_PSC\n");
#endif
	    /* If this section isn't a bfd section.  */
	    if (PRIV (is_vax) && (psect_idx < (abfd->section_count - 1)))
	      {
		/* Check for temporary section from TIR record.  */
		if (psect_idx < PRIV (section_count))
		  old_section = PRIV (sections)[psect_idx];
		else
		  old_section = 0;
	      }

	    name = _bfd_vms_save_counted_string (vms_rec + 8);
	    section = bfd_make_section (abfd, name);
	    if (!section)
	      {
		(*_bfd_error_handler) (_("bfd_make_section (%s) failed"),
				       name);
		return -1;
	      }
	    old_flags = bfd_getl16 (vms_rec + 2);
	    section->size = bfd_getl32 (vms_rec + 4);  /* allocation */
	    new_flags = vms_secflag_by_name (abfd, vax_section_flags, name,
					     section->size > 0);
	    if (old_flags & EGPS_S_V_REL)
	      new_flags |= SEC_RELOC;
	    if (old_flags & GPS_S_M_OVR)
	      new_flags |= SEC_IS_COMMON;
	    if (!bfd_set_section_flags (abfd, section, new_flags))
	      {
		(*_bfd_error_handler)
		  (_("bfd_set_section_flags (%s, %x) failed"),
		   name, new_flags);
		return -1;
	      }
	    section->alignment_power = vms_rec[1];
	    align_addr = (1 << section->alignment_power);
	    if ((base_addr % align_addr) != 0)
	      base_addr += (align_addr - (base_addr % align_addr));
	    section->vma = (bfd_vma)base_addr;
	    base_addr += section->size;

	    /* Global section is common symbol.  */
	    if (old_flags & GPS_S_M_GBL)
	      {
		entry = _bfd_vms_enter_symbol (abfd, name);
		if (entry == NULL)
		  {
		    bfd_set_error (bfd_error_no_memory);
		    return -1;
		  }
		symbol = entry->symbol;

		symbol->value = 0;
		symbol->section = section;
		symbol->flags = (BSF_GLOBAL | BSF_SECTION_SYM | BSF_OLD_COMMON);
	      }

	    /* Copy saved contents if old_section set.  */
	    if (old_section != 0)
	      {
		section->contents = old_section->contents;
		if (section->size < old_section->size)
		  {
		    (*_bfd_error_handler)
		      (_("Size mismatch section %s=%lx, %s=%lx"),
		       old_section->name,
		       (unsigned long) old_section->size,
		       section->name,
		       (unsigned long) section->size);
		    return -1;
		  }
		else if (section->size > old_section->size)
		  {
		    section->contents = bfd_realloc (old_section->contents,
						     section->size);
		    if (section->contents == NULL)
		      {
			bfd_set_error (bfd_error_no_memory);
			return -1;
		      }
		  }
	      }
	    else
	      {
		section->contents = bfd_zmalloc (section->size);
		if (section->contents == NULL)
		  {
		    bfd_set_error (bfd_error_no_memory);
		    return -1;
		  }
	      }
#if VMS_DEBUG
	    vms_debug (4, "gsd psc %d (%s, flags %04x=%s) ",
		       section->index, name, old_flags, flag2str (gpsflagdesc, old_flags));
	    vms_debug (4, "%d bytes at 0x%08lx (mem %p)\n",
		       section->size, section->vma, section->contents);
#endif

	    gsd_size = vms_rec[8] + 9;

	    psect_idx++;
	  }
	  break;

	case GSD_S_C_EPM:
	case GSD_S_C_EPMW:
#if VMS_DEBUG
	  vms_debug (4, "gsd epm\n");
#endif
	  /* Fall through.  */
	case GSD_S_C_SYM:
	case GSD_S_C_SYMW:
	  {
	    int name_offset = 0, value_offset = 0;

	    /* Symbol specification (definition or reference).  */
#if VMS_DEBUG
	    vms_debug (4, "GSD_S_C_SYM(W)\n");
#endif
	    old_flags = bfd_getl16 (vms_rec + 2);
	    new_flags = BSF_NO_FLAGS;

	    if (old_flags & GSY_S_M_WEAK)
	      new_flags |= BSF_WEAK;

	    switch (gsd_type)
	      {
	      case GSD_S_C_EPM:
		name_offset = 11;
		value_offset = 5;
		new_flags |= BSF_FUNCTION;
		break;
	      case GSD_S_C_EPMW:
		name_offset = 12;
		value_offset = 6;
		new_flags |= BSF_FUNCTION;
		break;
	      case GSD_S_C_SYM:
		if (old_flags & GSY_S_M_DEF)	/* Symbol definition.  */
		  name_offset = 9;
		else
		  name_offset = 4;
		value_offset = 5;
		break;
	      case GSD_S_C_SYMW:
		if (old_flags & GSY_S_M_DEF)	/* Symbol definition.  */
		  name_offset = 10;
		else
		  name_offset = 5;
		value_offset = 6;
		break;
	      }

	    /* Save symbol in vms_symbol_table.  */
	    entry = _bfd_vms_enter_symbol
	      (abfd, _bfd_vms_save_counted_string (vms_rec + name_offset));
	    if (entry == NULL)
	      {
		bfd_set_error (bfd_error_no_memory);
		return -1;
	      }
	    symbol = entry->symbol;

	    if (old_flags & GSY_S_M_DEF)
	      {
		/* Symbol definition.  */
		int psect;

		symbol->value = bfd_getl32 (vms_rec + value_offset);
		if ((gsd_type == GSD_S_C_SYMW)
		    || (gsd_type == GSD_S_C_EPMW))
		  psect = bfd_getl16 (vms_rec + value_offset - 2);
		else
		  psect = vms_rec[value_offset-1];

		symbol->section = (asection *)(unsigned long)psect;
#if VMS_DEBUG
		vms_debug (4, "gsd sym def #%d (%s, %ld, %04x=%s)\n", abfd->symcount,
			  symbol->name, (long)symbol->section, old_flags, flag2str(gsyflagdesc, old_flags));
#endif
	      }
	    else
	      {
		/* Symbol reference.  */
#if VMS_DEBUG
		vms_debug (4, "gsd sym ref #%d (%s, %04x=%s)\n", abfd->symcount,
			   symbol->name, old_flags, flag2str (gsyflagdesc, old_flags));
#endif
		symbol->section = (asection *)(unsigned long)-1;
	      }

	    gsd_size = vms_rec[name_offset] + name_offset + 1;
	    symbol->flags = new_flags;
	  }

	  break;

	case GSD_S_C_PRO:
	case GSD_S_C_PROW:
#if VMS_DEBUG
	  vms_debug (4, "gsd pro\n");
#endif
	  break;
	case GSD_S_C_IDC:
#if VMS_DEBUG
	  vms_debug (4, "gsd idc\n");
#endif
	  break;
	case GSD_S_C_ENV:
#if VMS_DEBUG
	  vms_debug (4, "gsd env\n");
#endif
	  break;
	case GSD_S_C_LSY:
#if VMS_DEBUG
	  vms_debug (4, "gsd lsy\n");
#endif
	  break;
	case GSD_S_C_LEPM:
#if VMS_DEBUG
	  vms_debug (4, "gsd lepm\n");
#endif
	  break;
	case GSD_S_C_LPRO:
#if VMS_DEBUG
	  vms_debug (4, "gsd lpro\n");
#endif
	  break;
	case GSD_S_C_SPSC:
#if VMS_DEBUG
	  vms_debug (4, "gsd spsc\n");
#endif
	  break;
	case GSD_S_C_SYMV:
#if VMS_DEBUG
	  vms_debug (4, "gsd symv\n");
#endif
	  break;
	case GSD_S_C_EPMV:
#if VMS_DEBUG
	  vms_debug (4, "gsd epmv\n");
#endif
	  break;
	case GSD_S_C_PROV:
#if VMS_DEBUG
	  vms_debug (4, "gsd prov\n");
#endif
	  break;

	case EGSD_S_C_PSC + EVAX_OFFSET:
	  {
	    /* Program section definition.  */
	    name = _bfd_vms_save_counted_string (vms_rec + EGPS_S_B_NAMLNG);
	    section = bfd_make_section (abfd, name);
	    if (!section)
	      return -1;
	    old_flags = bfd_getl16 (vms_rec + EGPS_S_W_FLAGS);
	    section->size = bfd_getl32 (vms_rec + EGPS_S_L_ALLOC);
	    new_flags = vms_secflag_by_name (abfd, evax_section_flags, name,
					     section->size > 0);
	    if (old_flags & EGPS_S_V_REL)
	      new_flags |= SEC_RELOC;
	    if (!bfd_set_section_flags (abfd, section, new_flags))
	      return -1;
	    section->alignment_power = vms_rec[EGPS_S_B_ALIGN];
	    align_addr = (1 << section->alignment_power);
	    if ((base_addr % align_addr) != 0)
	      base_addr += (align_addr - (base_addr % align_addr));
	    section->vma = (bfd_vma)base_addr;
	    base_addr += section->size;
	    section->contents = bfd_zmalloc (section->size);
	    if (section->contents == NULL)
	      return -1;
	    section->filepos = (unsigned int)-1;
#if VMS_DEBUG
	    vms_debug (4, "EGSD P-section %d (%s, flags %04x=%s) ",
		       section->index, name, old_flags, flag2str(gpsflagdesc, old_flags));
	    vms_debug (4, "%d bytes at 0x%08lx (mem %p)\n",
		       section->size, section->vma, section->contents);
#endif
	  }
	  break;

	case EGSD_S_C_SYM + EVAX_OFFSET:
	  {
	    /* Global symbol specification (definition or reference).  */
	    symbol = bfd_make_empty_symbol (abfd);
	    if (symbol == 0)
	      return -1;

	    old_flags = bfd_getl16 (vms_rec + EGSY_S_W_FLAGS);
	    new_flags = BSF_NO_FLAGS;

	    if (old_flags & EGSY_S_V_WEAK)
	      new_flags |= BSF_WEAK;

	    if (old_flags & EGSY_S_V_DEF)
	      {
		/* Symbol definition.  */
		if (old_flags & EGSY_S_V_NORM)
		  new_flags |= BSF_FUNCTION;
		symbol->name =
		  _bfd_vms_save_counted_string (vms_rec + ESDF_S_B_NAMLNG);
		symbol->value = bfd_getl64 (vms_rec + ESDF_S_L_VALUE);
		symbol->section =
		  (asection *)(unsigned long) bfd_getl32 (vms_rec + ESDF_S_L_PSINDX);
#if VMS_DEBUG
		vms_debug (4, "EGSD sym def #%d (%s, %ld, %04x=%s)\n",
			   abfd->symcount, symbol->name, (long)symbol->section,
			   old_flags, flag2str (gsyflagdesc, old_flags));
#endif
	      }
	    else
	      {
		/* Symbol reference.  */
		symbol->name =
		  _bfd_vms_save_counted_string (vms_rec + ESRF_S_B_NAMLNG);
#if VMS_DEBUG
		vms_debug (4, "EGSD sym ref #%d (%s, %04x=%s)\n",
			   abfd->symcount, symbol->name, old_flags,
			   flag2str (gsyflagdesc, old_flags));
#endif
		symbol->section = (asection *)(unsigned long)-1;
	      }

	    symbol->flags = new_flags;

	    /* Register symbol in VMS symbol table.  */
	    entry = (vms_symbol_entry *) bfd_hash_lookup
	      (PRIV (vms_symbol_table), symbol->name, TRUE, FALSE);

	    if (entry == NULL)
	      {
		bfd_set_error (bfd_error_no_memory);
		return -1;
	      }

	    if (entry->symbol != NULL)
	      {
		/* FIXME ?, DEC C generates this.  */
#if VMS_DEBUG
		vms_debug (4, "EGSD_S_C_SYM: duplicate \"%s\"\n", symbol->name);
#endif
	      }
	    else
	      {
		entry->symbol = symbol;
		PRIV (gsd_sym_count)++;
		abfd->symcount++;
	      }
	  }
	  break;

	case EGSD_S_C_SYMG + EVAX_OFFSET:
	  {
	    /* Universal symbol specification (definition).  */
	    symbol = bfd_make_empty_symbol (abfd);
	    if (symbol == 0)
	      return -1;

	    old_flags = bfd_getl16 (vms_rec + EGST_S_W_FLAGS);
	    new_flags = BSF_NO_FLAGS;

	    if (old_flags & EGSY_S_V_WEAK)
	      new_flags |= BSF_WEAK;

	    if (old_flags & EGSY_S_V_DEF) /* symbol definition */
	      {
		if (old_flags & EGSY_S_V_NORM)
		  new_flags |= BSF_FUNCTION;

		symbol->name =
		  _bfd_vms_save_counted_string (vms_rec + EGST_S_B_NAMLNG);

		/* For BSF_FUNCTION symbols, the entry point is in LP_1
		   and the descriptor in LP_2.  For other symbols, the
		   unique value is in LP_2.  */
		symbol->value = bfd_getl64 (vms_rec + EGST_S_Q_LP_2);

		/* Adding this offset is necessary in order for GDB to
		   read the DWARF-2 debug info from shared libraries.  */
		if (abfd->flags & DYNAMIC
		    && strstr (symbol->name, "$DWARF2.DEBUG") != 0)
		  symbol->value += PRIV (symvva);
	      }
	    else /* symbol reference */
	      (*_bfd_error_handler) ("Invalid EGST reference");

	    symbol->flags = new_flags;

	    if (register_universal_symbol (abfd, symbol, old_flags) < 0)
	      return -1;

	    /* Make a second symbol for the entry point.  */
	    if (symbol->flags & BSF_FUNCTION)
	      {
		asymbol *en_sym;

		name = bfd_alloc (abfd, strlen (symbol->name) + 5);

		en_sym = bfd_make_empty_symbol (abfd);
		if (en_sym == 0)
		  return -1;

		strcpy (name, symbol->name);
		strcat (name, "..en");

		en_sym->name = name;
		en_sym->value = bfd_getl64 (vms_rec + EGST_S_Q_LP_1);

		if (register_universal_symbol (abfd, en_sym, old_flags) < 0)
		  return -1;
	      }
	  }
	  break;

	case EGSD_S_C_IDC + EVAX_OFFSET:
  	  break;

	default:
	  (*_bfd_error_handler) (_("Unknown GSD/EGSD subtype %d"), gsd_type);
	  bfd_set_error (bfd_error_bad_value);
	  return -1;
	}

      PRIV (rec_size) -= gsd_size;
      PRIV (vms_rec) += gsd_size;
    }

  if (abfd->symcount > 0)
    abfd->flags |= HAS_SYMS;

  return 0;
}

/* Register a universal symbol in the VMS symbol table.  */

static int
register_universal_symbol (bfd *abfd, asymbol *symbol, int vms_flags)
{
  bfd_vma sbase = 0;
  asection *s, *sec = NULL;
  vms_symbol_entry *entry;

  /* A universal symbol is by definition global...  */
  symbol->flags |= BSF_GLOBAL;

  /* ...and dynamic in shared libraries.  */
  if (abfd->flags & DYNAMIC)
    symbol->flags |= BSF_DYNAMIC;

  /* Find containing section.  */
  for (s = abfd->sections; s; s = s->next)
    {
      if (symbol->value >= s->vma
	  && s->vma > sbase
	  && !(s->flags & SEC_COFF_SHARED_LIBRARY)
	  && (s->size > 0 || !(vms_flags & EGSY_S_V_REL)))
	{
	  sbase = s->vma;
	  sec = s;
	}
    }

  symbol->value -= sbase;
  symbol->section = sec;

#if VMS_DEBUG
  vms_debug (4, "EGST sym def #%d (%s, 0x%llx => 0x%llx, %04x=%s)\n",
	     abfd->symcount, symbol->name, symbol->value + sbase,
	     symbol->value, vms_flags,
	     flag2str(gsyflagdesc, vms_flags));
#endif

  entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV (vms_symbol_table),
						symbol->name,
						TRUE, FALSE);

  if (entry == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return -1;
    }

  if (entry->symbol) /* FIXME: DEC C generates this */
    {
#if VMS_DEBUG
      vms_debug (4, "EGSD_S_C_SYMG: duplicate \"%s\"\n", symbol->name);
#endif
    }
  else
    {
      entry->symbol = symbol;
      PRIV (gsd_sym_count)++;
      abfd->symcount++;
    }

  return 0;
}

/* Set section VMS flags.  */

void
bfd_vms_set_section_flags (bfd *abfd ATTRIBUTE_UNUSED,
			   asection *sec, flagword flags)
{
  vms_section_data (sec)->vflags = flags;
}

/* Write section and symbol directory of bfd abfd.  */

int
_bfd_vms_write_gsd (bfd *abfd, int objtype ATTRIBUTE_UNUSED)
{
  asection *section;
  asymbol *symbol;
  unsigned int symnum;
  int last_index = -1;
  char dummy_name[10];
  char *sname;
  flagword new_flags, old_flags;
  int abs_section_index = 0;

#if VMS_DEBUG
  vms_debug (2, "vms_write_gsd (%p, %d)\n", abfd, objtype);
#endif

  /* Output sections.  */
  section = abfd->sections;
#if VMS_DEBUG
  vms_debug (3, "%d sections found\n", abfd->section_count);
#endif

  /* Egsd is quadword aligned.  */
  _bfd_vms_output_alignment (abfd, 8);

  _bfd_vms_output_begin (abfd, EOBJ_S_C_EGSD, -1);
  _bfd_vms_output_long (abfd, 0);
  /* Prepare output for subrecords.  */
  _bfd_vms_output_push (abfd);

  while (section != 0)
    {
#if VMS_DEBUG
      vms_debug (3, "Section #%d %s, %d bytes\n", section->index, section->name, (int)section->size);
#endif

      /* Don't write out the VMS debug info section since it is in the
         ETBT and EDBG sections in etir. */
      if (!strcmp (section->name, ".vmsdebug"))
        goto done;

      /* 13 bytes egsd, max 31 chars name -> should be 44 bytes.  */
      if (_bfd_vms_output_check (abfd, 64) < 0)
	{
	  _bfd_vms_output_pop (abfd);
	  _bfd_vms_output_end (abfd);
	  _bfd_vms_output_begin (abfd, EOBJ_S_C_EGSD, -1);
	  _bfd_vms_output_long (abfd, 0);
	  /* Prepare output for subrecords.  */
	  _bfd_vms_output_push (abfd);
	}

      /* Create dummy sections to keep consecutive indices.  */
      while (section->index - last_index > 1)
	{
#if VMS_DEBUG
	  vms_debug (3, "index %d, last %d\n", section->index, last_index);
#endif
	  _bfd_vms_output_begin (abfd, EGSD_S_C_PSC, -1);
	  _bfd_vms_output_short (abfd, 0);
	  _bfd_vms_output_short (abfd, 0);
	  _bfd_vms_output_long (abfd, 0);
	  sprintf (dummy_name, ".DUMMY%02d", last_index);
	  _bfd_vms_output_counted (abfd, dummy_name);
	  _bfd_vms_output_flush (abfd);
	  last_index++;
	}

      /* Don't know if this is necessary for the linker but for now it keeps
	 vms_slurp_gsd happy  */
      sname = (char *)section->name;
      if (*sname == '.')
	{
	  sname++;
	  if ((*sname == 't') && (strcmp (sname, "text") == 0))
	    sname = PRIV (is_vax)?VAX_CODE_NAME:EVAX_CODE_NAME;
	  else if ((*sname == 'd') && (strcmp (sname, "data") == 0))
	    sname = PRIV (is_vax)?VAX_DATA_NAME:EVAX_DATA_NAME;
	  else if ((*sname == 'b') && (strcmp (sname, "bss") == 0))
	    sname = EVAX_BSS_NAME;
	  else if ((*sname == 'l') && (strcmp (sname, "link") == 0))
	    sname = EVAX_LINK_NAME;
	  else if ((*sname == 'r') && (strcmp (sname, "rdata") == 0))
	    sname = EVAX_READONLY_NAME;
	  else if ((*sname == 'l') && (strcmp (sname, "literal") == 0))
	    sname = EVAX_LITERAL_NAME;
	  else if ((*sname == 'l') && (strcmp (sname, "literals") == 0))
	    {
	      sname = EVAX_LITERALS_NAME;
	      abs_section_index = section->index;
	    }
	  else if ((*sname == 'c') && (strcmp (sname, "comm") == 0))
	    sname = EVAX_COMMON_NAME;
	  else if ((*sname == 'l') && (strcmp (sname, "lcomm") == 0))
	    sname = EVAX_LOCAL_NAME;
	}
      else
	sname = _bfd_vms_length_hash_symbol (abfd, sname, EOBJ_S_C_SECSIZ);

      _bfd_vms_output_begin (abfd, EGSD_S_C_PSC, -1);
      _bfd_vms_output_short (abfd, section->alignment_power & 0xff);

      if (bfd_is_com_section (section))
	new_flags = (EGPS_S_V_OVR | EGPS_S_V_REL | EGPS_S_V_GBL | EGPS_S_V_RD
		     | EGPS_S_V_WRT | EGPS_S_V_NOMOD | EGPS_S_V_COM);
      else
	new_flags = vms_esecflag_by_name (evax_section_flags, sname,
					  section->size > 0);

      /* Modify them as directed.  */
      if (section->flags & SEC_READONLY)
	new_flags &= ~EGPS_S_V_WRT;

      new_flags |= vms_section_data (section)->vflags & 0xffff;
      new_flags &=
	~((vms_section_data (section)->vflags >> EGPS_S_V_NO_SHIFT) & 0xffff);

#if VMS_DEBUG
      vms_debug (3, "sec flags %x\n", section->flags);
      vms_debug (3, "new_flags %x, _raw_size %d\n", new_flags, section->size);
#endif

      _bfd_vms_output_short (abfd, new_flags);
      _bfd_vms_output_long (abfd, (unsigned long) section->size);
      _bfd_vms_output_counted (abfd, sname);
      _bfd_vms_output_flush (abfd);

      last_index = section->index;
done:
      section = section->next;
    }

  /* Output symbols.  */
#if VMS_DEBUG
  vms_debug (3, "%d symbols found\n", abfd->symcount);
#endif

  bfd_set_start_address (abfd, (bfd_vma) -1);

  for (symnum = 0; symnum < abfd->symcount; symnum++)
    {
      char *hash;

      symbol = abfd->outsymbols[symnum];
      if (*(symbol->name) == '_')
	{
	  if (strcmp (symbol->name, "__main") == 0)
	    bfd_set_start_address (abfd, (bfd_vma)symbol->value);
	}
      old_flags = symbol->flags;

      if (old_flags & BSF_FILE)
	continue;

      if ((old_flags & BSF_GLOBAL) == 0		   /* Not xdef...  */
	  && !bfd_is_und_section (symbol->section) /* and not xref... */
	  && !((old_flags & BSF_SECTION_SYM) != 0  /* and not LIB$INITIALIZE.  */
	       && strcmp (symbol->section->name, "LIB$INITIALIZE") == 0))
	continue;

      /* 13 bytes egsd, max 64 chars name -> should be 77 bytes.  */
      if (_bfd_vms_output_check (abfd, 80) < 0)
	{
	  _bfd_vms_output_pop (abfd);
	  _bfd_vms_output_end (abfd);
	  _bfd_vms_output_begin (abfd, EOBJ_S_C_EGSD, -1);
	  _bfd_vms_output_long (abfd, 0);
	  /* Prepare output for subrecords.  */
	  _bfd_vms_output_push (abfd);
	}

      _bfd_vms_output_begin (abfd, EGSD_S_C_SYM, -1);

      /* Data type, alignment.  */
      _bfd_vms_output_short (abfd, 0);

      new_flags = 0;

      if (old_flags & BSF_WEAK)
	new_flags |= EGSY_S_V_WEAK;
      if (bfd_is_com_section (symbol->section))		/* .comm  */
	new_flags |= (EGSY_S_V_WEAK | EGSY_S_V_COMM);

      if (old_flags & BSF_FUNCTION)
	{
	  new_flags |= EGSY_S_V_NORM;
	  new_flags |= EGSY_S_V_REL;
	}
      if (old_flags & BSF_GLOBAL)
	{
	  new_flags |= EGSY_S_V_DEF;
	  if (!bfd_is_abs_section (symbol->section))
	    new_flags |= EGSY_S_V_REL;
	}
      _bfd_vms_output_short (abfd, new_flags);

      if (old_flags & BSF_GLOBAL)
	{
	  /* Symbol definition.  */
	  uquad code_address = 0;
	  unsigned long ca_psindx = 0;
	  unsigned long psindx;

	  if ((old_flags & BSF_FUNCTION) && symbol->udata.p != NULL)
	    {
	      asymbol *sym;

	      if (bfd_get_flavour (abfd) == bfd_target_evax_flavour)
	        sym = ((struct evax_private_udata_struct *)symbol->udata.p)->enbsym;
	      else
	        sym = (asymbol *)symbol->udata.p;
	      code_address = sym->value;
	      ca_psindx = sym->section->index;
	    }
	  if (bfd_is_abs_section (symbol->section))
	    psindx = abs_section_index;
	  else
	    psindx = symbol->section->index;

	  _bfd_vms_output_quad (abfd, symbol->value);
	  _bfd_vms_output_quad (abfd, code_address);
	  _bfd_vms_output_long (abfd, ca_psindx);
	  _bfd_vms_output_long (abfd, psindx);
	}
      hash = _bfd_vms_length_hash_symbol (abfd, symbol->name, EOBJ_S_C_SYMSIZ);
      _bfd_vms_output_counted (abfd, hash);

      _bfd_vms_output_flush (abfd);

    }

  _bfd_vms_output_alignment (abfd, 8);
  _bfd_vms_output_pop (abfd);
  _bfd_vms_output_end (abfd);

  return 0;
}
@


1.24
log
@2010-01-27  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Remove trailing spaces.
	(struct hdr_struct): Remove unused hdr_c_cpr field.
	(enum file_format_enum): Add comments.
	* vms.c (vms_bfd_print_private_bfd_data): New function that
	replaces the macro.
	Remove trailing spaces.
	* vms-misc.c: Improve comments.
	(_bfd_vms_get_object_record): Also handle files without pads.
	* vms-hdr.c (_bfd_vms_write_dbg): Fix format string.
	* vms-gsd.c (struct flagdescstruct): Make name field const.
	(gsyflagdesc): Fix typo.
@
text
@@


1.23
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d207 1
a207 1
struct flagdescstruct { char *name; flagword value; };
d234 1
a234 1
  { "NORM", EGCY_S_V_NORM },
@


1.22
log
@2009-02-23  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Update copyright year, fix comments, reorder declarations.
	(_bfd_save_vms_section): Remove the prototype.
	(EGPS_S_V_NO_SHIFT): New constant.
	(bfd_vms_set_section_flags): New prototype.
	(EGPS_S_B_ALIGN, EGPS_S_W_FLAGS, EGPS_S_L_ALLOC, EGPS_S_B_NAMLNG): New
	constants.
	(EGSY_S_W_FLAGS): Ditto.
	(EGSY_S_V_QUAD_VAL): Ditto.
	(ESDF_S_L_VALUE, ESDF_S_L_PSINDX, ESDF_S_B_NAMLNG): Ditto.
	(EGST_S_W_FLAGS, EGST_S_Q_LP_1, EGST_S_Q_LP_2, EGST_S_L_PSINDX,
	EGST_S_B_NAMLNG): Ditto.
	(ESRF_S_B_NAMLNG): Ditto.
	(ETIR_S_C_HEADER_SIZE): Ditto.
	(EGPS_S_V_ALLOC_64BIT): Ditto.
	(DST_S_C_EPILOG): Ditto.
	(DST_S_C_SRC_SETLNUM_L, DST_S_C_SRC_SETLNUM_W) : Ditto.
	(DST_S_C_SRC_INCRLNUM_B): Ditto.
	(DST_S_B_PCLINE_UNSBYTE, DST_S_W_PCLINE_UNSWORD): Ditto.
	(DST_S_L_PCLINE_UNSLONG): Ditto.
	(DST_S_B_MODBEG_NAME, DST_S_L_RTNBEG_ADDRESS) : Ditto
	(DST_S_B_RTNBEG_NAME, DST_S_L_RTNEND_SIZE): Ditto
	(DST_S_C_SOURCE_HEADER_SIZE): Ditto.
	(DST_S_B_SRC_DF_LENGTH, DST_S_W_SRC_DF_FILEID): Ditto.
	(DST_S_B_SRC_DF_FILENAME, DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_W_SRC_UNSWORD, DST_S_L_SRC_UNSLONG): Ditto.
	Add prototypes.
	(vms_section, vms_reloc): Remove types.
	(hdr_struc): Replaced by ...
	(hdr_struct): ... new type.
	(EMH_S_W_HDRTYP, EMH_S_B_STRLVL, EMH_S_L_ARCH1): New constants.
	(EMH_S_L_ARCH2, EMH_S_L_RECSIZ, EMH_S_B_NAMLNG): Ditto.
	(EMH_DATE_LENGTH): Ditto.
	(eom_struc): Replaced by ...
	(eom_struct): ... new type.
	(EEOM_S_L_TOTAL_LPS, EEOM_S_W_COMCOD, EEOM_S_B_TFRFLG): New constants.
	(EEOM_S_L_PSINDX, EEOM_S_L_TFRADR): Ditto.
	(EIHD_S_K_MAJORID, EIHD_S_K_MINORID, EIHD_S_K_EXE): Ditto.
	(EIHD_S_L_SIZE, EIHD_S_L_ISDOFF, EIHD_S_L_SYMDBGOFF): Ditto.
	(EIHD_S_Q_SYMVVA, EIHD_S_L_IMGTYPE): Ditto.
	(EISD_S_L_EISDSIZE, EISD_S_L_SECSIZE, EISD_S_Q_VIR_ADDR): Ditto.
	(EISD_S_L_FLAGS, EISD_S_L_VBN, EISD_S_R_CONTROL): Ditto.
	(EISD_S_L_IDENT, EISD_S_T_GBLNAM): Ditto.
	(EISD_S_M_GBL, EISD_S_M_CRF, EISD_S_M_DZRO, EISD_S_M_WRT): Ditto.
	(EISD_S_M_INITALCODE, EISD_S_M_BASED, EISD_S_M_FIXUPVEC): Ditto.
	(EISD_S_M_RESIDENT, EISD_S_M_VECTOR, EISD_S_M_PROTECT): Ditto.
	(EISD_S_M_LASTCLU, EISD_S_M_EXE, EISD_S_M_NONSHRADR): Ditto.
	(EISD_S_M_QUAD_LENGTH, EISD_S_M_ALLOC_64BIT): Ditto.
	(EIHS_S_L_DSTVBN, EIHS_S_L_DSTSIZE, EIHS_S_L_GSTVBN): Ditto.
	(EIHS_S_L_GSTSIZE, EIHS_S_L_DMTVBN, EIHS_S_L_DMTBYTES): Ditto.
	(DBG_S_L_DMT_MODBEG, DBG_S_L_DST_SIZE): Ditto.
	(DBG_S_W_DMT_PSECT_COUNT, DBG_S_C_DMT_HEADER_SIZE): Ditto.
	(DBG_S_L_DMT_PSECT_START, DBG_S_L_DMT_PSECT_LENGTH)
	(DBG_S_C_DMT_PSECT_SIZE): Ditto.
	(enum file_type_enum): New type.
	(struct location_struct): Removed.
	(struct fileinfo, struct srecinfo, struct lineinfo): New types.
	(struct funcinfo, struct module): Ditto.
	(struct vms_private_data_struct): Update fields.
	(struct vms_section_data_struct): New type.

	* vms.c: Update copyright year, fix comments,
	Fix includes for DECC, add prototypes.
	(vms_initialize): Use bfd_alloc instead of bfd_zalloc and remove
	some initializers.
	Use flavour to set is_vax, location_stack is removed.
	(struct pair): Declare.
	(fill_section_ptr): Initialize variables at declaration.
	Add guard to set SECTION_SYM flag, handlde und section.
	(vms_fixup_sections): Use struct pair for fill_section_ptr argument.
	(_bfd_vms_slurp_object_records): New function, replaces previous
	vms_object_p.
	(vms_slurp_module): New function.
	(vms_slurp_image): Ditto.
	(vms_object_p): Complete rewrite.
	(vms_mkobject): Use is_vax field to slect architecture.
	(free_reloc_stream): New function.
	(vms_convert_to_var): Ditto.
	(vms_convert_to_var_1): Ditto.
	(vms_convert_to_var_unix_filename): Ditto.
	(vms_close_and_cleanup): Call free_reloc_stream, convert file to
	VAR format on VMS.
	(vms_new_section_hook): Set alignment to 0, allocate private data.
	(vms_get_section_contents): Load content.
	(vms_get_symbol_info): Handle undefined section.
	(vms_find_nearest_line): Handle.
	(alloc_reloc_stream): New function.
	(vms_slurp_reloc_table): Ditto.
	(vms_get_reloc_upper_bound): Make it real.
	(vms_canonicalize_reloc): Do the real work.
	(alpha_howto_table): Add ALPHA_R_NOP, ALPHA_R_BSR, ALPHA_R_LDA,
	ALPHA_R_BOH.
	(vms_bfd_reloc_type_lookup): Handle NOP, BSR, LDA and BOH.
	(vms_set_arch_mach): Check arch.
	(vms_set_section_contents): Copy the content after allocation.
	(vms_alpha_vec): Update object flags.

	* vms-tir.c: Update copyright year, fix comments,
	add prototypes for new functions.
	(dst_define_location): New function.
	(dst_restore_location): New function.
	(dst_retrieve_location): New function.
	(dst_check_allocation): New function.
	(image_dump): Call dst_check_allocation.
	(image_write_b): Ditto.
	(image_write_w): Ditto.
	(image_write_l): Ditto.
	(image_write_q): Ditto.
	(cmd_name): Handle STA_LW, STA_QW, STO_OFF, STO_IMM, STO_IMMR, STO_LW,
	STO_QW, OPR_ADD, CTL_SETRB, STC_LP_PSB, CTL_DFLOC, CTL_STLOC,
	CTL_STKDL.
	Call error handler instead of abort if name is not known.
	(etir_sta): Add quarter_relocs argument and set it.
	Fix cast.
	(etir_sto): Ditto.
	(etir_opr): Ditto, return FALSE in case of error.
	(etir_ctl): Add quarter_relocs argument and set it, fix cast.
	Fix CTL_DFLOC, CTL_STLOC, CTL_STKDL.
	(etir_stc): Add quarter_relocs argument and set it, fix cast.
	Fix STC_LP, STC_LP_PSB, STC_GBL and STC_CGA.
	Handle STC_LP_PSB, STC_BSR_GBL, STC_LDA_GBL, STC_BOH_GBL.
	Move STC_NOP_PS, STC_BSR_PS, STC_LDA_PS, STC_BOH_PS, STC_NBH_PS.
	Return FALSE in case of error.
	(tir_sta): Change sign of psect.
	(tir_ctl): Ditto.
	(tir_cmd): Fix cast. Makes tir_table static const.
	(etir_cmd): Add quarter_relocs argument, makes etir_table const,
	add argument to explain.
	(analyze_etir): Initialize maxptr, add quarter_relocs
	declaration, move some declarations into inner scopes.
	Handle quarter_relocs and STO_IMM.
	(_bfd_vms_slurp_tir): Use constant instead of hard-coded values.
	(_bfd_vms_slurp_relocs): New function.
	(_bfd_vms_decode_relocs): New function.
	(sto_imm): Rewritten.
	(start_first_etbt_record): New function.
	(start_another_etbt_record): Ditto.
	(etir_output_check): Ditto.
	(defer_reloc_p): Ditto.
	(_bfd_vms_write_tir): Remove nextoffset, convert a while-loop to
	a for-loop.  Correctly deals with contents, deals with .vmsdebug,
	rewritte relocations handling.
	(_bfd_vms_write_tbt): Removed.
	(_bfd_vms_write_dbg): Ditto.

	* vms-misc.c: Update copyright year, Fix comments.
	(_bfd_vms_get_header_values): Use 'size' instead of 'length'.
	(maybe_adjust_record_pointer_for_object): New function.
	(_bfd_vms_get_first_record): New function, replaces ...
	(_bfd_vms_get_record): ..  removed.
	(_bfd_vms_get_object_record): New function.
	(_bfd_vms_get_object_record): New function.
	(vms_get_remaining_object_record): New function, replaces ...
	(_bfd_vms_get_next_record): ... removed.
	(add_new_contents): Removed.
	(_bfd_save_vms_section): Removed.
	(_bfd_get_vms_section): Removed.
	(_bfd_vms_output_flush): Write in VAR format.
	(new_symbol): Don't make UND section.

	* vms-hdr.c: Update copyright year, update list of record handled.
	(_bfd_vms_slurp_hdr): rec_length renamed to rec_size.
	(_bfd_vms_write_hdr): Strip vms and unix patches,
	add comments, truncate module name at 31 characters,
	use constants instead of hard-coded value,
	write BFD version instead of a fixed string.
	(_bfd_vms_slurp_ihd): New function.
	(_bfd_vms_slurp_isd): Ditto.
	(_bfd_vms_slurp_ihs): Ditto.
	(new_module): Ditto.
	(parse_module): Ditto
	(build_module_list): Ditto.
	(module_find_nearest_line): Ditto.
	(_bfd_vms_find_nearest_dst_line): Ditto.
	(vms_slurp_debug): Ditto.
	(_bfd_vms_slurp_dbg): Ditto.
	(_bfd_vms_slurp_tbt): Ditto.
	(_bfd_vms_write_dbg): Ditto.
	(_bfd_vms_write_tbt): Ditto.

	* vms-gsd.c: Update copyright year, update list of records handled.
	(EVAX_LITERALS_NAME): New macro.
	(evax_section_flags): Add an entry for EVAX_LITERALS_NAME.
	(gpsflagdesc, gsyflagdesc): Moved out of _bfd_vms_slurp_gsd.
	(register_universal_symbol): New function and prototype.
	(_bfd_vms_slurp_gsd): Fix indentations and casts,
	improve debug messages,
	use constants instead of hard-coded value,
	fix missing endianness conversion,
	handle global symbol (SYMG).
	(bfd_vms_set_section_flags): New function.
	(_bfd_vms_write_gsd): Don't write .vmsdebug section,
	handle section literals,
	fix indentation,
	handle section bfd and vms flags,
	don't output LIB$INITIALIZE symbol,
	fix handling of weak symbols,
	fix evax vs vax procedure descriptor,
	handle absolute symbols.

	* reloc.c (BFD_RELOC_ALPHA_NOP, BFD_RELOC_ALPHA_BSR,
	BFD_RELOC_ALPHA_LDA, BFD_RELOC_ALPHA_BOH): New relocations.

	* makefile.vms (DEFS): Fix flags for VMS.

	* bfdio.c (real_fopen): Handle multiple VMS fopen attributes.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Regenerated.
@
text
@d732 2
a733 1
		char *name = bfd_alloc (abfd, strlen (symbol->name) + 5);
@


1.21
log
@Switch sources over to use the GPL version 3
@
text
@d4 1
a4 1
   2007 Free Software Foundation, Inc.
d6 4
a9 1
   go and read the openVMS linker manual (esp. appendix B)
d52 1
d140 5
d209 31
d267 3
a275 31
#if VMS_DEBUG
  static struct flagdescstruct gpsflagdesc[] =
    {
      { "PIC", 0x0001 },
      { "LIB", 0x0002 },
      { "OVR", 0x0004 },
      { "REL", 0x0008 },
      { "GBL", 0x0010 },
      { "SHR", 0x0020 },
      { "EXE", 0x0040 },
      { "RD",  0x0080 },
      { "WRT", 0x0100 },
      { "VEC", 0x0200 },
      { "NOMOD", 0x0400 },
      { "COM", 0x0800 },
      { NULL, 0 }
    };

  static struct flagdescstruct gsyflagdesc[] =
    {
      { "WEAK", 0x0001 },
      { "DEF",  0x0002 },
      { "UNI",  0x0004 },
      { "REL",  0x0008 },
      { "COMM", 0x0010 },
      { "VECEP", 0x0020 },
      { "NORM", 0x0040 },
      { NULL, 0 }
    };
#endif

d315 1
a315 1
	gsd_type = *vms_rec;
d337 1
a337 1
	    if (PRIV (is_vax) && (psect_idx < (abfd->section_count-1)))
a376 1

d510 1
a510 1
		symbol->section = (asection *) (size_t) psect;
d512 2
a513 2
		vms_debug (4, "gsd sym def #%d (%s, %d [%p], %04x=%s)\n", abfd->symcount,
			   symbol->name, (int)symbol->section, symbol->section, old_flags, flag2str (gsyflagdesc, old_flags));
a518 1
		symbol->section = bfd_make_section (abfd, BFD_UND_SECTION_NAME);
d520 2
a521 3
		vms_debug (4, "gsd sym ref #%d (%s, %s [%p], %04x=%s)\n",
			   abfd->symcount, symbol->name, symbol->section->name,
			   symbol->section, old_flags, flag2str (gsyflagdesc, old_flags));
d523 1
d587 1
a587 1
	    name = _bfd_vms_save_counted_string (vms_rec + 12);
d591 2
a592 2
	    old_flags = bfd_getl16 (vms_rec + 6);
	    section->size = bfd_getl32 (vms_rec + 8);	/* Allocation.  */
d599 1
a599 1
	    section->alignment_power = vms_rec[4];
d608 1
d610 2
a611 2
	    vms_debug (4, "egsd psc %d (%s, flags %04x=%s) ",
		       section->index, name, old_flags, flag2str (gpsflagdesc, old_flags));
d620 1
a620 1
	    /* Symbol specification (definition or reference).  */
d625 1
a625 1
	    old_flags = bfd_getl16 (vms_rec + 6);
d631 1
a631 1
	    if (vms_rec[6] & EGSY_S_V_DEF)
a633 1
		symbol->name = _bfd_vms_save_counted_string (vms_rec + 32);
a634 1
		  /* Proc def.  */
d636 9
a644 7

		symbol->value = bfd_getl64 (vms_rec + 8);
		symbol->section = (asection *) ((unsigned long) bfd_getl32 (vms_rec + 28));
#if VMS_DEBUG
		vms_debug (4, "egsd sym def #%d (%s, %d, %04x=%s)\n", abfd->symcount,
			   symbol->name, (int) symbol->section, old_flags,
			   flag2str (gsyflagdesc, old_flags));
d650 2
a651 1
		symbol->name = _bfd_vms_save_counted_string (vms_rec + 8);
d653 3
a655 2
		vms_debug (4, "egsd sym ref #%d (%s, %04x=%s)\n", abfd->symcount,
			  symbol->name, old_flags, flag2str (gsyflagdesc, old_flags));
d657 1
a657 1
		symbol->section = bfd_make_section (abfd, BFD_UND_SECTION_NAME);
d662 4
a665 4
	    /* Save symbol in vms_symbol_table.  */
	    entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV (vms_symbol_table),
							  symbol->name,
							  TRUE, FALSE);
d688 62
d751 1
a751 1
	  break;
d754 1
a754 1
	  (*_bfd_error_handler) (_("unknown gsd/egsd subtype %d"), gsd_type);
d769 73
a841 1
/* Output routines.  */
d855 1
d881 5
d931 5
d946 1
d948 2
a949 1
	new_flags = (EGPS_S_V_OVR | EGPS_S_V_REL | EGPS_S_V_GBL | EGPS_S_V_RD | EGPS_S_V_WRT | EGPS_S_V_NOMOD | EGPS_S_V_COM);
d954 13
d973 1
d999 5
a1003 3
      if (((old_flags & (BSF_GLOBAL | BSF_WEAK)) == 0)	/* Not xdef...  */
	  && (!bfd_is_und_section (symbol->section)))	/* ...and not xref.  */
	continue;					/* Dont output.  */
d1025 1
a1025 1
      if (bfd_is_com_section (symbol->section))
d1033 1
a1033 1
      if (old_flags & (BSF_GLOBAL | BSF_WEAK))
d1041 1
a1041 1
      if (old_flags & (BSF_GLOBAL | BSF_WEAK))
d1050 8
a1057 2
	      code_address = ((asymbol *) (symbol->udata.p))->value;
	      ca_psindx = ((asymbol *) (symbol->udata.p))->section->index;
d1059 4
a1062 1
	  psindx = symbol->section->index;
@


1.20
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d13 1
a13 1
   the Free Software Foundation; either version 2 of the License, or
d23 2
a24 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.19
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d25 1
a26 1
#include "sysdep.h"
@


1.18
log
@Update the FSF address in the copyright/GPL notice
@
text
@d23 1
a23 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.17
log
@Update to ISO-C90 and fix formatting
@
text
@d23 1
a23 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.16
log
@update copyright dates
@
text
@d11 13
a23 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 1
a32 3
/*-----------------------------------------------------------------------------*/

/* typical sections for vax object files  */
d38 1
a38 1
/* typical sections for evax object files  */
d51 3
a53 2
struct sec_flags_struct {
  char *name;			/* name of section */
d55 1
a55 1
  flagword flags_always;	/* flags we set always */
d57 1
a57 1
  flagword flags_hassize;	/* flags we set if the section has a size > 0 */
d60 1
a60 1
/* These flags are deccrtl/vaxcrtl (openVMS 6.2 VAX) compatible  */
d62 23
a84 22
static struct sec_flags_struct vax_section_flags[] = {
  { VAX_CODE_NAME,
	(GPS_S_M_PIC|GPS_S_M_REL|GPS_S_M_SHR|GPS_S_M_EXE|GPS_S_M_RD),
	(SEC_CODE),
	(GPS_S_M_PIC|GPS_S_M_REL|GPS_S_M_SHR|GPS_S_M_EXE|GPS_S_M_RD),
	(SEC_IN_MEMORY|SEC_CODE|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_LOAD) },
  { VAX_DATA_NAME,
	(GPS_S_M_PIC|GPS_S_M_REL|GPS_S_M_RD|GPS_S_M_WRT),
	(SEC_DATA),
	(GPS_S_M_PIC|GPS_S_M_REL|GPS_S_M_RD|GPS_S_M_WRT),
	(SEC_IN_MEMORY|SEC_DATA|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_LOAD) },
  { VAX_ADDRESS_DATA_NAME,
	(GPS_S_M_PIC|GPS_S_M_REL|GPS_S_M_RD),
	(SEC_DATA|SEC_READONLY),
	(GPS_S_M_PIC|GPS_S_M_REL|GPS_S_M_RD),
	(SEC_IN_MEMORY|SEC_DATA|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_READONLY|SEC_LOAD) },
  { NULL,
	(GPS_S_M_PIC|GPS_S_M_OVR|GPS_S_M_REL|GPS_S_M_GBL|GPS_S_M_RD|GPS_S_M_WRT),
	(SEC_DATA),
	(GPS_S_M_PIC|GPS_S_M_OVR|GPS_S_M_REL|GPS_S_M_GBL|GPS_S_M_RD|GPS_S_M_WRT),
	(SEC_IN_MEMORY|SEC_DATA|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_LOAD) }
};
d86 1
a86 1
/* These flags are deccrtl/vaxcrtl (openVMS 6.2 Alpha) compatible  */
d88 53
a140 52
static struct sec_flags_struct evax_section_flags[] = {
  { EVAX_ABS_NAME,
	(EGPS_S_V_SHR),
	(SEC_DATA),
	(EGPS_S_V_SHR),
	(SEC_IN_MEMORY|SEC_DATA|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_LOAD) },
  { EVAX_CODE_NAME,
	(EGPS_S_V_PIC|EGPS_S_V_REL|EGPS_S_V_SHR|EGPS_S_V_EXE),
	(SEC_CODE),
	(EGPS_S_V_PIC|EGPS_S_V_REL|EGPS_S_V_SHR|EGPS_S_V_EXE),
	(SEC_IN_MEMORY|SEC_CODE|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_LOAD) },
  { EVAX_LITERAL_NAME,
	(EGPS_S_V_PIC|EGPS_S_V_REL|EGPS_S_V_SHR|EGPS_S_V_RD|EGPS_S_V_NOMOD),
	(SEC_DATA|SEC_READONLY),
	(EGPS_S_V_PIC|EGPS_S_V_REL|EGPS_S_V_SHR|EGPS_S_V_RD),
	(SEC_IN_MEMORY|SEC_DATA|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_READONLY|SEC_LOAD) },
  { EVAX_LINK_NAME,
	(EGPS_S_V_REL|EGPS_S_V_RD),
	(SEC_DATA|SEC_READONLY),
	(EGPS_S_V_REL|EGPS_S_V_RD),
	(SEC_IN_MEMORY|SEC_DATA|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_READONLY|SEC_LOAD) },
  { EVAX_DATA_NAME,
	(EGPS_S_V_REL|EGPS_S_V_RD|EGPS_S_V_WRT|EGPS_S_V_NOMOD),
	(SEC_DATA),
	(EGPS_S_V_REL|EGPS_S_V_RD|EGPS_S_V_WRT),
	(SEC_IN_MEMORY|SEC_DATA|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_LOAD) },
  { EVAX_BSS_NAME,
	(EGPS_S_V_REL|EGPS_S_V_RD|EGPS_S_V_WRT|EGPS_S_V_NOMOD),
	(SEC_NO_FLAGS),
	(EGPS_S_V_REL|EGPS_S_V_RD|EGPS_S_V_WRT|EGPS_S_V_NOMOD),
	(SEC_IN_MEMORY|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_LOAD) },
  { EVAX_READONLYADDR_NAME,
	(EGPS_S_V_PIC|EGPS_S_V_REL|EGPS_S_V_RD),
	(SEC_DATA|SEC_READONLY),
	(EGPS_S_V_PIC|EGPS_S_V_REL|EGPS_S_V_RD),
	(SEC_IN_MEMORY|SEC_DATA|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_READONLY|SEC_LOAD) },
  { EVAX_READONLY_NAME,
	(EGPS_S_V_PIC|EGPS_S_V_REL|EGPS_S_V_SHR|EGPS_S_V_RD|EGPS_S_V_NOMOD),
	(SEC_DATA|SEC_READONLY),
	(EGPS_S_V_PIC|EGPS_S_V_REL|EGPS_S_V_SHR|EGPS_S_V_RD),
	(SEC_IN_MEMORY|SEC_DATA|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_READONLY|SEC_LOAD) },
  { EVAX_LOCAL_NAME,
	(EGPS_S_V_REL|EGPS_S_V_RD|EGPS_S_V_WRT),
	(SEC_DATA),
	(EGPS_S_V_REL|EGPS_S_V_RD|EGPS_S_V_WRT),
	(SEC_IN_MEMORY|SEC_DATA|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_LOAD) },
  { NULL,
	(EGPS_S_V_REL|EGPS_S_V_RD|EGPS_S_V_WRT),
	(SEC_DATA),
	(EGPS_S_V_REL|EGPS_S_V_RD|EGPS_S_V_WRT),
	(SEC_IN_MEMORY|SEC_DATA|SEC_HAS_CONTENTS|SEC_ALLOC|SEC_LOAD) }
};
d142 1
a142 4
static flagword vms_secflag_by_name PARAMS ((bfd *, struct sec_flags_struct *, char *, int));
static flagword vms_esecflag_by_name PARAMS ((struct sec_flags_struct *, char *, int));

/* Retrieve bfd section flags by name and size  */
d145 4
a148 5
vms_secflag_by_name (abfd, section_flags, name, hassize)
     bfd *abfd;
     struct sec_flags_struct *section_flags;
     char *name;
     int hassize;
d154 3
a156 3
      if ((PRIV(is_vax)?
	    strcasecmp (name, section_flags[i].name):
	    strcmp (name, section_flags[i].name)) == 0)
d170 1
a170 1
/* Retrieve vms section flags by name and size  */
d173 3
a175 4
vms_esecflag_by_name (section_flags, name, hassize)
     struct sec_flags_struct *section_flags;
     char *name;
     int hassize;
a194 1
/*-----------------------------------------------------------------------------*/
a195 1
/* debug */
d199 1
a199 1
/* Convert flag to printable string  */
d202 1
a202 3
flag2str(flagdesc, flags)
     struct flagdescstruct *flagdesc;
     flagword flags;
a203 1

d213 1
a213 1
	    strcat(res, ",");
d224 1
a224 2
/*-----------------------------------------------------------------------------*/
/* input routines */
d227 1
a227 1
   return 0 on success, -1 on error  */
d230 1
a230 3
_bfd_vms_slurp_gsd (abfd, objtype)
     bfd *abfd;
     int objtype;
d234 15
a248 15
  {
    { "PIC", 0x0001 },
    { "LIB", 0x0002 },
    { "OVR", 0x0004 },
    { "REL", 0x0008 },
    { "GBL", 0x0010 },
    { "SHR", 0x0020 },
    { "EXE", 0x0040 },
    { "RD",  0x0080 },
    { "WRT", 0x0100 },
    { "VEC", 0x0200 },
    { "NOMOD", 0x0400 },
    { "COM", 0x0800 },
    { NULL, 0 }
  };
d251 10
a260 10
  {
    { "WEAK", 0x0001 },
    { "DEF",  0x0002 },
    { "UNI",  0x0004 },
    { "REL",  0x0008 },
    { "COMM", 0x0010 },
    { "VECEP", 0x0020 },
    { "NORM", 0x0040 },
    { NULL, 0 }
  };
d281 2
a282 2
      PRIV(vms_rec) += 8;	/* skip type, size, l_temp */
      PRIV(rec_size) -= 8;
d285 2
a286 2
      PRIV(vms_rec) += 1;
      PRIV(rec_size) -= 1;
d292 1
a292 1
  /* calculate base address for each section  */
d297 1
a297 1
  while (PRIV(rec_size) > 0)
d299 1
a299 1
      vms_rec = PRIV(vms_rec);
d302 1
a302 3
	{
	  gsd_type = *vms_rec;
	}
d310 1
a310 1
  vms_debug (3, "gsd_type %d\n", gsd_type);
d315 104
a418 112
	  case GSD_S_C_PSC:
	    {
	      /*
	       * program section definition
	       */

	      asection *old_section = 0;

#if VMS_DEBUG
  vms_debug (4, "GSD_S_C_PSC\n");
#endif
	      /* If this section isn't a bfd section.  */

	      if (PRIV(is_vax) && (psect_idx < (abfd->section_count-1)))
		{
		  /* check for temporary section from TIR record.  */

		  if (psect_idx < PRIV(section_count))
		    old_section = PRIV(sections)[psect_idx];
		  else
		    old_section = 0;
		}

	      name = _bfd_vms_save_counted_string (vms_rec + 8);
	      section = bfd_make_section (abfd, name);
	      if (!section)
		{
		  (*_bfd_error_handler) (_("bfd_make_section (%s) failed"),
					 name);
		  return -1;
		}
	      old_flags = bfd_getl16 (vms_rec + 2);
	      section->size = bfd_getl32 (vms_rec + 4);  /* allocation */
	      new_flags = vms_secflag_by_name (abfd, vax_section_flags, name,
					       section->size > 0);
	      if (old_flags & EGPS_S_V_REL)
		new_flags |= SEC_RELOC;
	      if (old_flags & GPS_S_M_OVR)
		new_flags |= SEC_IS_COMMON;
	      if (!bfd_set_section_flags (abfd, section, new_flags))
		{
		  (*_bfd_error_handler)
		    (_("bfd_set_section_flags (%s, %x) failed"),
		     name, new_flags);
		  return -1;
		}
	      section->alignment_power = vms_rec[1];
	      align_addr = (1 << section->alignment_power);
	      if ((base_addr % align_addr) != 0)
		base_addr += (align_addr - (base_addr % align_addr));
	      section->vma = (bfd_vma)base_addr;
	      base_addr += section->size;

	      /* global section is common symbol  */

	      if (old_flags & GPS_S_M_GBL)
		{
		  entry = _bfd_vms_enter_symbol (abfd, name);
		  if (entry == (vms_symbol_entry *)NULL)
		    {
		      bfd_set_error (bfd_error_no_memory);
		      return -1;
		    }
		  symbol = entry->symbol;

		  symbol->value = 0;
		  symbol->section = section;
		  symbol->flags = (BSF_GLOBAL|BSF_SECTION_SYM|BSF_OLD_COMMON);
		}

	      /* copy saved contents if old_section set  */

	      if (old_section != 0)
		{
		  section->contents = old_section->contents;
		  if (section->size < old_section->size)
		    {
		      (*_bfd_error_handler)
			(_("Size mismatch section %s=%lx, %s=%lx"),
			 old_section->name,
			 (unsigned long) old_section->size,
			 section->name,
			 (unsigned long) section->size);
		      return -1;
		    }
		  else if (section->size > old_section->size)
		    {
		      section->contents = ((unsigned char *)
					   bfd_realloc (old_section->contents,
							section->size));
		      if (section->contents == NULL)
			{
			  bfd_set_error (bfd_error_no_memory);
			  return -1;
			}
		    }
		}
	      else
		{
		  section->contents = ((unsigned char *)
				       bfd_zmalloc (section->size));
		  if (section->contents == NULL)
		    {
		      bfd_set_error (bfd_error_no_memory);
		      return -1;
		    }
		}
#if VMS_DEBUG
	      vms_debug (4, "gsd psc %d (%s, flags %04x=%s) ",
			 section->index, name, old_flags, flag2str (gpsflagdesc, old_flags));
	      vms_debug (4, "%d bytes at 0x%08lx (mem %p)\n",
			 section->size, section->vma, section->contents);
d421 1
a421 1
	      gsd_size = vms_rec[8] + 9;
d423 2
a424 2
	      psect_idx++;
	    }
d427 2
a428 2
	  case GSD_S_C_EPM:
	  case GSD_S_C_EPMW:
d430 1
a430 1
		vms_debug(4, "gsd epm\n");
d432 5
a436 9
	  /*FALLTHRU*/
	  case GSD_S_C_SYM:
	  case GSD_S_C_SYMW:
	    {
	      int name_offset = 0, value_offset = 0;

	      /*
	       * symbol specification (definition or reference)
	       */
d438 1
d440 1
a440 1
  vms_debug (4, "GSD_S_C_SYM(W)\n");
d442 2
a443 2
	      old_flags = bfd_getl16 (vms_rec + 2);
	      new_flags = BSF_NO_FLAGS;
d445 2
a446 2
	      if (old_flags & GSY_S_M_WEAK)
		new_flags |= BSF_WEAK;
d448 60
a507 59
	      switch (gsd_type)
		{
		case GSD_S_C_EPM:
		  name_offset = 11;
		  value_offset = 5;
		  new_flags |= BSF_FUNCTION;
		  break;
		case GSD_S_C_EPMW:
		  name_offset = 12;
		  value_offset = 6;
		  new_flags |= BSF_FUNCTION;
		  break;
		case GSD_S_C_SYM:
		  if (old_flags & GSY_S_M_DEF)	/* symbol definition */
		    name_offset = 9;
		  else
		    name_offset = 4;
		  value_offset = 5;
		  break;
		case GSD_S_C_SYMW:
		  if (old_flags & GSY_S_M_DEF)	/* symbol definition */
		    name_offset = 10;
		  else
		    name_offset = 5;
		  value_offset = 6;
		  break;
		}

	      /* save symbol in vms_symbol_table */

	      entry = _bfd_vms_enter_symbol (abfd,
			_bfd_vms_save_counted_string (vms_rec + name_offset));
	      if (entry == (vms_symbol_entry *)NULL)
		{
		  bfd_set_error (bfd_error_no_memory);
		  return -1;
		}
	      symbol = entry->symbol;

	      if (old_flags & GSY_S_M_DEF)	/* symbol definition */
		{
		  int psect;

		  symbol->value = bfd_getl32 (vms_rec+value_offset);
		  if ((gsd_type == GSD_S_C_SYMW)
		      || (gsd_type == GSD_S_C_EPMW))
		    psect = bfd_getl16 (vms_rec + value_offset - 2);
		  else
		    psect = vms_rec[value_offset-1];

		  symbol->section = (asection *) (size_t) psect;
#if VMS_DEBUG
		  vms_debug(4, "gsd sym def #%d (%s, %d [%p], %04x=%s)\n", abfd->symcount,
				symbol->name, (int)symbol->section, symbol->section, old_flags, flag2str(gsyflagdesc, old_flags));
#endif
		}
	      else	/* symbol reference */
		{
		  symbol->section = bfd_make_section (abfd, BFD_UND_SECTION_NAME);
d509 3
a511 2
		  vms_debug (4, "gsd sym ref #%d (%s, %s [%p], %04x=%s)\n", abfd->symcount,
				symbol->name, symbol->section->name, symbol->section, old_flags, flag2str (gsyflagdesc, old_flags));
d513 1
a513 1
		}
d515 3
a517 3
	      gsd_size = vms_rec[name_offset] + name_offset + 1;
	      symbol->flags = new_flags;
	    }
d521 2
a522 2
	  case GSD_S_C_PRO:
	  case GSD_S_C_PROW:
d524 1
a524 1
		vms_debug(4, "gsd pro\n");
d527 1
a527 1
	  case GSD_S_C_IDC:
d529 1
a529 1
		vms_debug(4, "gsd idc\n");
d532 1
a532 1
	  case GSD_S_C_ENV:
d534 1
a534 1
		vms_debug(4, "gsd env\n");
d537 1
a537 1
	  case GSD_S_C_LSY:
d539 1
a539 1
		vms_debug(4, "gsd lsy\n");
d542 1
a542 1
	  case GSD_S_C_LEPM:
d544 1
a544 1
		vms_debug(4, "gsd lepm\n");
d547 1
a547 1
	  case GSD_S_C_LPRO:
d549 1
a549 1
		vms_debug(4, "gsd lpro\n");
d552 1
a552 1
	  case GSD_S_C_SPSC:
d554 1
a554 1
		vms_debug(4, "gsd spsc\n");
d557 1
a557 1
	  case GSD_S_C_SYMV:
d559 1
a559 1
		vms_debug(4, "gsd symv\n");
d562 1
a562 1
	  case GSD_S_C_EPMV:
d564 1
a564 1
		vms_debug(4, "gsd epmv\n");
d567 1
a567 1
	  case GSD_S_C_PROV:
d569 1
a569 1
		vms_debug(4, "gsd prov\n");
d575 2
a576 3
	    /* program section definition  */

	    name = _bfd_vms_save_counted_string (vms_rec+12);
d581 1
a581 1
	    section->size = bfd_getl32 (vms_rec + 8);	/* allocation */
d594 1
a594 2
	    section->contents = ((unsigned char *)
				 bfd_zmalloc (section->size));
d598 3
a600 3
	    vms_debug(4, "egsd psc %d (%s, flags %04x=%s) ",
		       section->index, name, old_flags, flag2str(gpsflagdesc, old_flags));
	    vms_debug(4, "%d bytes at 0x%08lx (mem %p)\n",
d608 1
a608 2
	    /* symbol specification (definition or reference)  */

d619 1
a619 1
	    if (vms_rec[6] & EGSY_S_V_DEF)	/* symbol definition */
d621 2
a622 2
		symbol->name =
		  _bfd_vms_save_counted_string (vms_rec+32);
d624 5
a628 5
		  {         /* proc def */
		    new_flags |= BSF_FUNCTION;
		  }
		symbol->value = bfd_getl64 (vms_rec+8);
		symbol->section = (asection *) ((unsigned long) bfd_getl32 (vms_rec+28));
d630 3
a632 2
		vms_debug(4, "egsd sym def #%d (%s, %d, %04x=%s)\n", abfd->symcount,
			   symbol->name, (int)symbol->section, old_flags, flag2str(gsyflagdesc, old_flags));
d635 1
a635 1
	    else	/* symbol reference */
d637 2
a638 2
		symbol->name =
		  _bfd_vms_save_counted_string (vms_rec+8);
d640 2
a641 2
		vms_debug(4, "egsd sym ref #%d (%s, %04x=%s)\n", abfd->symcount,
			   symbol->name, old_flags, flag2str(gsyflagdesc, old_flags));
d648 2
a649 3
	    /* save symbol in vms_symbol_table  */

	    entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV(vms_symbol_table),
d652 1
a652 1
	    if (entry == (vms_symbol_entry *)NULL)
d657 4
a660 2
	    if (entry->symbol != (asymbol *)NULL)
	      {					/* FIXME ?, DEC C generates this */
d662 1
a662 1
		vms_debug(4, "EGSD_S_C_SYM: duplicate \"%s\"\n", symbol->name);
d668 1
a668 1
		PRIV(gsd_sym_count)++;
d681 1
d683 3
a685 6
	} /* switch */

      PRIV(rec_size) -= gsd_size;
      PRIV(vms_rec) += gsd_size;

    } /* while (recsize > 0) */
d693 1
a693 2
/*-----------------------------------------------------------------------------*/
/* output routines */
d695 1
a695 1
/* Write section and symbol directory of bfd abfd  */
d698 1
a698 3
_bfd_vms_write_gsd (abfd, objtype)
     bfd *abfd;
     int objtype ATTRIBUTE_UNUSED;
d712 1
a712 2
  /* output sections  */

d718 1
a718 2
  /* egsd is quadword aligned  */

d723 2
a724 1
  _bfd_vms_output_push (abfd);		/* prepare output for subrecords */
d729 1
a729 1
  vms_debug (3, "Section #%d %s, %d bytes\n", section->index, section->name, (int)section->size);
d732 1
a732 1
	/* 13 bytes egsd, max 31 chars name -> should be 44 bytes */
d739 2
a740 1
	  _bfd_vms_output_push (abfd);		/* prepare output for subrecords */
d743 1
a743 2
	/* Create dummy sections to keep consecutive indices */

a760 1

d766 1
a766 1
	    sname = PRIV(is_vax)?VAX_CODE_NAME:EVAX_CODE_NAME;
d768 1
a768 1
	    sname = PRIV(is_vax)?VAX_DATA_NAME:EVAX_DATA_NAME;
d788 1
a788 3
	{
	  new_flags = (EGPS_S_V_OVR|EGPS_S_V_REL|EGPS_S_V_GBL|EGPS_S_V_RD|EGPS_S_V_WRT|EGPS_S_V_NOMOD|EGPS_S_V_COM);
	}
d790 3
a792 4
	{
	  new_flags = vms_esecflag_by_name (evax_section_flags, sname,
					    section->size > 0);
	}
d802 1
a802 2
  /* output symbols  */

d807 1
a807 1
  bfd_set_start_address (abfd, (bfd_vma)-1);
d824 3
a826 5
      if (((old_flags & (BSF_GLOBAL|BSF_WEAK)) == 0)	/* not xdef */
	  && (!bfd_is_und_section (symbol->section)))	/* and not xref */
	continue;					/* dont output */

      /* 13 bytes egsd, max 64 chars name -> should be 77 bytes  */
d828 1
d835 2
a836 1
	  _bfd_vms_output_push (abfd);		/* prepare output for subrecords */
d841 2
a842 1
      _bfd_vms_output_short (abfd, 0);			/* data type, alignment */
d848 2
a849 2
      if (bfd_is_com_section (symbol->section))		/* .comm  */
	new_flags |= (EGSY_S_V_WEAK|EGSY_S_V_COMM);
d856 1
a856 1
      if (old_flags & (BSF_GLOBAL|BSF_WEAK))
d864 1
a864 1
      if (old_flags & (BSF_GLOBAL | BSF_WEAK))		/* symbol definition */
d866 1
@


1.15
log
@	* coffcode.h (coff_print_aux): Warning fix.
	* elf-m10300.c (mn10300_elf_relax_section): Use section->id
	instead of section pointer to identify.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.  Allocate
	the correct size buffer for local sym mangling too.
	(h8300_bfd_link_add_symbols): Likewise.
	* elf32-sh-symbian.c (sh_symbian_process_embedded_commands): Fix
	warning.
	* elf32-sh64.c (shmedia_prepare_reloc): Use %B and %p in error message
	* elf32-xtensa.c (literal_value_hash): Warning fix.
	* versados.c (process_otr): Warning fix.
	(versados_canonicalize_reloc): Likewise.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Warning fix.
	* vms.c (fill_section_ptr): Warning fix.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005
@


1.14
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004
d523 1
a523 1
		  symbol->section = (asection *)psect;
@


1.13
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d361 1
a361 1
	      section->_raw_size = bfd_getl32 (vms_rec + 4);  /* allocation */
d363 1
a363 1
					       section->_raw_size > 0);
d380 1
a380 1
	      base_addr += section->_raw_size;
d404 1
a404 1
		  if (section->_raw_size < old_section->_raw_size)
d409 1
a409 1
			 (unsigned long) old_section->_raw_size,
d411 1
a411 1
			 (unsigned long) section->_raw_size);
d414 1
a414 1
		  else if (section->_raw_size > old_section->_raw_size)
d418 1
a418 1
							section->_raw_size));
d429 1
a429 1
				       bfd_zmalloc (section->_raw_size));
a435 1
	      section->_cooked_size = section->_raw_size;
d440 1
a440 1
			 section->_raw_size, section->vma, section->contents);
d605 1
a605 1
	    section->_raw_size = bfd_getl32 (vms_rec + 8);	/* allocation */
d607 1
a607 1
					     section->_raw_size > 0);
d617 1
a617 1
	    base_addr += section->_raw_size;
d619 1
a619 1
				 bfd_zmalloc (section->_raw_size));
a621 1
	    section->_cooked_size = section->_raw_size;
d626 1
a626 1
		       section->_raw_size, section->vma, section->contents);
d759 1
a759 1
  vms_debug (3, "Section #%d %s, %d bytes\n", section->index, section->name, (int)section->_raw_size);
d825 1
a825 1
					    section->_raw_size > 0);
d828 1
a828 1
      _bfd_vms_output_long (abfd, (unsigned long) section->_raw_size);
@


1.13.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004
d361 1
a361 1
	      section->size = bfd_getl32 (vms_rec + 4);  /* allocation */
d363 1
a363 1
					       section->size > 0);
d380 1
a380 1
	      base_addr += section->size;
d404 1
a404 1
		  if (section->size < old_section->size)
d409 1
a409 1
			 (unsigned long) old_section->size,
d411 1
a411 1
			 (unsigned long) section->size);
d414 1
a414 1
		  else if (section->size > old_section->size)
d418 1
a418 1
							section->size));
d429 1
a429 1
				       bfd_zmalloc (section->size));
d436 1
d441 1
a441 1
			 section->size, section->vma, section->contents);
d606 1
a606 1
	    section->size = bfd_getl32 (vms_rec + 8);	/* allocation */
d608 1
a608 1
					     section->size > 0);
d618 1
a618 1
	    base_addr += section->size;
d620 1
a620 1
				 bfd_zmalloc (section->size));
d623 1
d628 1
a628 1
		       section->size, section->vma, section->contents);
d761 1
a761 1
  vms_debug (3, "Section #%d %s, %d bytes\n", section->index, section->name, (int)section->size);
d827 1
a827 1
					    section->size > 0);
d830 1
a830 1
      _bfd_vms_output_long (abfd, (unsigned long) section->size);
@


1.12
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d791 1
a791 1
      /* Don't know if this is neccesary for the linker but for now it keeps
@


1.11
log
@	* vms-gsd.c (_bfd_vms_write_gsd): Check that symbol->udata.p is
	non-NULL before dereferencing.
@
text
@d677 3
a679 1
	    entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV(vms_symbol_table), symbol->name, true, false);
@


1.10
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d423 1
a423 1
		        }
d664 1
a664 1
	        symbol->name =
d670 1
a670 1
	        symbol->section = bfd_make_section (abfd, BFD_UND_SECTION_NAME);
d904 1
a904 1
	  if (old_flags & BSF_FUNCTION)
@


1.10.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d423 1
a423 1
			}
d664 1
a664 1
		symbol->name =
d670 1
a670 1
		symbol->section = bfd_make_section (abfd, BFD_UND_SECTION_NAME);
d677 1
a677 3
	    entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV(vms_symbol_table),
							  symbol->name,
							  TRUE, FALSE);
d789 1
a789 1
      /* Don't know if this is necessary for the linker but for now it keeps
d904 1
a904 1
	  if ((old_flags & BSF_FUNCTION) && symbol->udata.p != NULL)
@


1.10.12.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d423 1
a423 1
			}
d664 1
a664 1
		symbol->name =
d670 1
a670 1
		symbol->section = bfd_make_section (abfd, BFD_UND_SECTION_NAME);
d904 1
a904 1
	  if ((old_flags & BSF_FUNCTION) && symbol->udata.p != NULL)
@


1.10.12.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d677 1
a677 3
	    entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV(vms_symbol_table),
							  symbol->name,
							  TRUE, FALSE);
@


1.10.12.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d791 1
a791 1
      /* Don't know if this is necessary for the linker but for now it keeps
@


1.10.2.1
log
@        * vms-gsd.c (_bfd_vms_write_gsd): Check that symbol->udata.p is
        non-NULL before dereferencing.

        * vms.c (vms_object_p): Restore the start address when returning
        NULL.
@
text
@d423 1
a423 1
			}
d664 1
a664 1
		symbol->name =
d670 1
a670 1
		symbol->section = bfd_make_section (abfd, BFD_UND_SECTION_NAME);
d904 1
a904 1
	  if ((old_flags & BSF_FUNCTION) && symbol->udata.p != NULL)
@


1.9
log
@	* syms.c (_bfd_generic_make_empty_symbol): New function.
	* libbfd-in.h (_bfd_nosymbols_make_empty_symbol): Define as
	_bfd_generic_make_empty_symbol.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* hppabsd-core.c (hppabsd_core_make_empty_symbol): Delete function.
	(hppabsd_core_get_symtab_upper_bound): Don't define.
	(hppabsd_core_get_symtab): Likewise.
	(hppabsd_core_print_symbol): Likewise.
	(hppabsd_core_get_symbol_info): Likewise.
	(hppabsd_core_bfd_is_local_label_name): Likewise.
	(hppabsd_core_get_lineno): Likewise.
	(hppabsd_core_find_nearest_line): Likewise.
	(hppabsd_core_bfd_make_debug_symbol): Likewise.
	(hppabsd_core_read_minisymbols): Likewise.
	(hppabsd_core_minisymbol_to_symbol): Likewise.
	(hppabsd_core_vec): Use BFD_JUMP_TABLE_SYMBOLS (_bfd_nosymbols).
	Formatting fixes.
	* hpux-core.c: Similarly.
	* irix-core.c: Similarly.
	* osf-core.c: Similarly.
	* sco5-core.c: Similarly.
	* binary.c (binary_make_empty_symbol): Remove function, define as
	_bfd_generic_make_empty_symbol.
	* ihex.c (ihex_make_empty_symbol): Likewise.
	* mmo.c (mmo_make_empty_symbol): Likewise.
	* ppcboot.c (ppcboot_make_empty_symbol): Likewise.
	* srec.c (srec_make_empty_symbol): Likewise.
	* versados.c (versados_make_empty_symbol): Likewise.
	* vms.c (_bfd_vms_make_empty_symbol): Remove.
	(vms_make_empty_symbol): Define as _bfd_generic_make_empty_symbol.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Call bfd_make_empty_symbol
	rather than _bfd_vms_make_empty_symbol.
	* vms-misc.c (new_symbol): Likewise.
@
text
@d429 1
a429 1
				       bfd_malloc (section->_raw_size));
a434 1
		  memset (section->contents, 0, (size_t) section->_raw_size);
d620 1
a620 1
				 bfd_malloc (section->_raw_size));
a622 1
	    memset (section->contents, 0, (size_t) section->_raw_size);
@


1.9.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d429 1
a429 1
				       bfd_zmalloc (section->_raw_size));
d435 1
d621 1
a621 1
				 bfd_zmalloc (section->_raw_size));
d624 1
@


1.9.10.2
log
@merge from mainline
@
text
@d423 1
a423 1
			}
d664 1
a664 1
		symbol->name =
d670 1
a670 1
		symbol->section = bfd_make_section (abfd, BFD_UND_SECTION_NAME);
d904 1
a904 1
	  if ((old_flags & BSF_FUNCTION) && symbol->udata.p != NULL)
@


1.9.8.1
log
@merge from trunk
@
text
@d429 1
a429 1
				       bfd_zmalloc (section->_raw_size));
d435 1
d621 1
a621 1
				 bfd_zmalloc (section->_raw_size));
d624 1
@


1.8
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d639 1
a639 1
	    symbol = _bfd_vms_make_empty_symbol (abfd);
@


1.7
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@a23 2
#include <ctype.h>

@


1.6
log
@	* vms-tir.c: Add missing prototypes.
	* vms-hdr.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d148 1
a148 1
vms_secflag_by_name (abfd, section_flags, name, size)
d152 1
a152 1
     int size;
d162 1
a162 1
	  if (size > 0)
d169 1
a169 1
  if (size > 0)
d177 1
a177 1
vms_esecflag_by_name (section_flags, name, size)
d180 1
a180 1
     int size;
d188 1
a188 1
	  if (size > 0)
d195 1
a195 1
  if (size > 0)
d293 10
a302 10
      case EOBJ_S_C_EGSD:
 	PRIV(vms_rec) += 8;	/* skip type, size, l_temp */
	PRIV(rec_size) -= 8;
	break;
      case OBJ_S_C_GSD:
	PRIV(vms_rec) += 1;
	PRIV(rec_size) -= 1;
	break;
      default:
	return -1;
d362 3
a364 2
	      section->_raw_size = bfd_getl32(vms_rec + 4);	/* allocation */
	      new_flags = vms_secflag_by_name (abfd, vax_section_flags, name, section->_raw_size);
d418 2
a419 1
				    bfd_realloc (old_section->contents, section->_raw_size));
d430 1
a430 1
					bfd_malloc (section->_raw_size));
d436 1
a436 1
		  memset (section->contents, 0, (size_t)section->_raw_size);
d461 1
a461 1
	      int name_offset, value_offset;
d478 24
a501 24
		  case GSD_S_C_EPM:
		    name_offset = 11;
		    value_offset = 5;
		    new_flags |= BSF_FUNCTION;
		    break;
		  case GSD_S_C_EPMW:
		    name_offset = 12;
		    value_offset = 6;
		    new_flags |= BSF_FUNCTION;
		    break;
		  case GSD_S_C_SYM:
		    if (old_flags & GSY_S_M_DEF)	/* symbol definition */
		      name_offset = 9;
		    else
		      name_offset = 4;
		    value_offset = 5;
		    break;
		  case GSD_S_C_SYMW:
		    if (old_flags & GSY_S_M_DEF)	/* symbol definition */
		      name_offset = 10;
		    else
		      name_offset = 5;
		    value_offset = 6;
		    break;
d609 2
a610 1
	    new_flags = vms_secflag_by_name (abfd, evax_section_flags, name, (int) section->_raw_size);
d827 2
a828 1
	  new_flags = vms_esecflag_by_name (evax_section_flags, sname, section->_raw_size);
d831 1
a831 1
      _bfd_vms_output_long (abfd, section->_raw_size);
d849 1
d901 1
a901 1
      if (old_flags & (BSF_GLOBAL|BSF_WEAK))		/* symbol definition */
d903 4
d909 2
a910 14
	      _bfd_vms_output_quad (abfd, symbol->value);
	      _bfd_vms_output_quad (abfd,
				     ((asymbol *) (symbol->udata.p))->value);
	      _bfd_vms_output_long (abfd,
				     (((asymbol *) (symbol->udata.p))
				      ->section->index));
	      _bfd_vms_output_long (abfd, symbol->section->index);
	    }
	  else
	    {
	      _bfd_vms_output_quad (abfd, symbol->value);	/* L_VALUE */
	      _bfd_vms_output_quad (abfd, 0);			/* L_CODE_ADDRESS */
	      _bfd_vms_output_long (abfd, 0);			/* L_CA_PSINDX */
	      _bfd_vms_output_long (abfd, symbol->section->index);/* L_PSINDX */
d912 6
d919 2
a920 1
      _bfd_vms_output_counted (abfd, _bfd_vms_length_hash_symbol (abfd, symbol->name, EOBJ_S_C_SYMSIZ));
@


1.5
log
@Update copyright notices
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d141 3
@


1.4
log
@2000-12-26  Kazu Hirata  <kazu@@hxi.com>

	* vaxnetbsd.c: Fix formatting.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999 Free Software Foundation Inc.
@


1.4.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@a23 1

a86 1

a170 1

d653 1
a653 1
		symbol->section = (asection *)((unsigned long) bfd_getl32 (vms_rec+28));
d899 1
a899 1
				     ((asymbol *)(symbol->udata.p))->value);
d901 1
a901 1
				     (((asymbol *)(symbol->udata.p))
d921 1
a921 1
  _bfd_vms_output_end (abfd); 
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d285 1
a285 1
  static int psect_idx = 0;
d727 1
a727 1
     int objtype;
d731 1
a731 1
  int symnum;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998 Free Software Foundation Inc.
d357 2
a358 1
		  fprintf (stderr, "bfd_make_section (%s) failed\n", name);
d370 3
a372 1
		  fprintf (stderr, "bfd_set_section_flags (%s, %x) failed\n", name, new_flags);
d406 6
a411 1
		      fprintf (stderr, "Size mismatch section %s=%d, %s=%d\n", old_section->name, old_section->_raw_size, section->name, section->_raw_size);
a735 1
  char *nptr, *uptr;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

