head	1.24;
access;
symbols
	binutils-2_20_1:1.21
	sid-snapshot-20100401:1.23
	gdb_7_1-2010-03-18-release:1.23
	sid-snapshot-20100301:1.23
	gdb_7_1-branch:1.23.0.2
	gdb_7_1-2010-02-18-branchpoint:1.23
	sid-snapshot-20100201:1.23
	sid-snapshot-20100101:1.22
	gdb_7_0_1-2009-12-22-release:1.21
	sid-snapshot-20091201:1.21
	sid-snapshot-20091101:1.21
	binutils-2_20:1.21
	gdb_7_0-2009-10-06-release:1.21
	sid-snapshot-20091001:1.21
	gdb_7_0-branch:1.21.0.8
	gdb_7_0-2009-09-16-branchpoint:1.21
	arc-sim-20090309:1.20
	binutils-arc-20081103-branch:1.20.0.22
	binutils-arc-20081103-branchpoint:1.20
	binutils-2_20-branch:1.21.0.6
	binutils-2_20-branchpoint:1.21
	sid-snapshot-20090901:1.21
	sid-snapshot-20090801:1.21
	msnyder-checkpoint-072509-branch:1.21.0.4
	msnyder-checkpoint-072509-branchpoint:1.21
	sid-snapshot-20090701:1.21
	dje-cgen-play1-branch:1.21.0.2
	dje-cgen-play1-branchpoint:1.21
	sid-snapshot-20090601:1.21
	sid-snapshot-20090501:1.21
	sid-snapshot-20090401:1.21
	arc-20081103-branch:1.20.0.20
	arc-20081103-branchpoint:1.20
	arc-insight_6_8-branch:1.20.0.18
	arc-insight_6_8-branchpoint:1.20
	insight_6_8-branch:1.20.0.16
	insight_6_8-branchpoint:1.20
	sid-snapshot-20090301:1.21
	binutils-2_19_1:1.20
	sid-snapshot-20090201:1.20
	sid-snapshot-20090101:1.20
	reverse-20081226-branch:1.20.0.14
	reverse-20081226-branchpoint:1.20
	sid-snapshot-20081201:1.20
	multiprocess-20081120-branch:1.20.0.12
	multiprocess-20081120-branchpoint:1.20
	sid-snapshot-20081101:1.20
	binutils-2_19:1.20
	sid-snapshot-20081001:1.20
	reverse-20080930-branch:1.20.0.10
	reverse-20080930-branchpoint:1.20
	binutils-2_19-branch:1.20.0.8
	binutils-2_19-branchpoint:1.20
	sid-snapshot-20080901:1.20
	sid-snapshot-20080801:1.20
	reverse-20080717-branch:1.20.0.6
	reverse-20080717-branchpoint:1.20
	sid-snapshot-20080701:1.20
	msnyder-reverse-20080609-branch:1.20.0.4
	msnyder-reverse-20080609-branchpoint:1.20
	drow-reverse-20070409-branch:1.16.0.34
	drow-reverse-20070409-branchpoint:1.16
	sid-snapshot-20080601:1.20
	sid-snapshot-20080501:1.20
	sid-snapshot-20080403:1.20
	sid-snapshot-20080401:1.20
	gdb_6_8-2008-03-27-release:1.20
	sid-snapshot-20080301:1.20
	gdb_6_8-branch:1.20.0.2
	gdb_6_8-2008-02-26-branchpoint:1.20
	sid-snapshot-20080201:1.19
	sid-snapshot-20080101:1.19
	sid-snapshot-20071201:1.19
	sid-snapshot-20071101:1.19
	gdb_6_7_1-2007-10-29-release:1.19
	gdb_6_7-2007-10-10-release:1.19
	sid-snapshot-20071001:1.19
	gdb_6_7-branch:1.19.0.4
	gdb_6_7-2007-09-07-branchpoint:1.19
	binutils-2_18:1.19
	binutils-2_18-branch:1.19.0.2
	binutils-2_18-branchpoint:1.19
	insight_6_6-20070208-release:1.16
	binutils-csl-coldfire-4_1-32:1.16
	binutils-csl-sourcerygxx-4_1-32:1.16
	gdb_6_6-2006-12-18-release:1.16
	binutils-csl-innovasic-fido-3_4_4-33:1.16
	binutils-csl-sourcerygxx-3_4_4-32:1.13
	binutils-csl-coldfire-4_1-30:1.16
	binutils-csl-sourcerygxx-4_1-30:1.16
	binutils-csl-coldfire-4_1-28:1.16
	binutils-csl-sourcerygxx-4_1-29:1.16
	binutils-csl-sourcerygxx-4_1-28:1.16
	gdb_6_6-branch:1.16.0.32
	gdb_6_6-2006-11-15-branchpoint:1.16
	binutils-csl-arm-2006q3-27:1.16
	binutils-csl-sourcerygxx-4_1-27:1.16
	binutils-csl-arm-2006q3-26:1.16
	binutils-csl-sourcerygxx-4_1-26:1.16
	binutils-csl-sourcerygxx-4_1-25:1.16
	binutils-csl-sourcerygxx-4_1-24:1.16
	binutils-csl-sourcerygxx-4_1-23:1.16
	insight_6_5-20061003-release:1.16
	gdb-csl-symbian-6_4_50_20060226-12:1.16
	binutils-csl-sourcerygxx-4_1-21:1.16
	binutils-csl-arm-2006q3-21:1.16
	binutils-csl-sourcerygxx-4_1-22:1.16
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.16
	binutils-csl-sourcerygxx-4_1-20:1.16
	binutils-csl-arm-2006q3-19:1.16
	binutils-csl-sourcerygxx-4_1-19:1.16
	binutils-csl-sourcerygxx-4_1-18:1.16
	binutils-csl-renesas-4_1-9:1.16
	gdb-csl-sourcerygxx-3_4_4-25:1.16
	binutils-csl-sourcerygxx-3_4_4-25:1.13
	nickrob-async-20060828-mergepoint:1.16
	gdb-csl-symbian-6_4_50_20060226-11:1.16
	binutils-csl-renesas-4_1-8:1.16
	binutils-csl-renesas-4_1-7:1.16
	binutils-csl-renesas-4_1-6:1.16
	gdb-csl-sourcerygxx-4_1-17:1.16
	binutils-csl-sourcerygxx-4_1-17:1.16
	gdb-csl-20060226-branch-local-2:1.16
	gdb-csl-sourcerygxx-4_1-14:1.16
	binutils-csl-sourcerygxx-4_1-14:1.16
	binutils-csl-sourcerygxx-4_1-15:1.16
	gdb-csl-sourcerygxx-4_1-13:1.16
	binutils-csl-sourcerygxx-4_1-13:1.16
	binutils-2_17:1.16
	gdb-csl-sourcerygxx-4_1-12:1.16
	binutils-csl-sourcerygxx-4_1-12:1.16
	gdb-csl-sourcerygxx-3_4_4-21:1.16
	binutils-csl-sourcerygxx-3_4_4-21:1.16
	gdb_6_5-20060621-release:1.16
	binutils-csl-wrs-linux-3_4_4-24:1.13
	binutils-csl-wrs-linux-3_4_4-23:1.13
	gdb-csl-sourcerygxx-4_1-9:1.16
	binutils-csl-sourcerygxx-4_1-9:1.16
	gdb-csl-sourcerygxx-4_1-8:1.16
	binutils-csl-sourcerygxx-4_1-8:1.16
	gdb-csl-sourcerygxx-4_1-7:1.16
	binutils-csl-sourcerygxx-4_1-7:1.16
	gdb-csl-arm-2006q1-6:1.16
	binutils-csl-arm-2006q1-6:1.16
	gdb-csl-sourcerygxx-4_1-6:1.16
	binutils-csl-sourcerygxx-4_1-6:1.16
	binutils-csl-wrs-linux-3_4_4-22:1.13
	gdb-csl-symbian-6_4_50_20060226-10:1.16
	gdb-csl-symbian-6_4_50_20060226-9:1.16
	gdb-csl-symbian-6_4_50_20060226-8:1.16
	gdb-csl-coldfire-4_1-11:1.16
	binutils-csl-coldfire-4_1-11:1.16
	gdb-csl-sourcerygxx-3_4_4-19:1.16
	binutils-csl-sourcerygxx-3_4_4-19:1.16
	gdb-csl-coldfire-4_1-10:1.16
	gdb_6_5-branch:1.16.0.30
	gdb_6_5-2006-05-14-branchpoint:1.16
	binutils-csl-coldfire-4_1-10:1.16
	gdb-csl-sourcerygxx-4_1-5:1.16
	binutils-csl-sourcerygxx-4_1-5:1.16
	nickrob-async-20060513-branch:1.16.0.28
	nickrob-async-20060513-branchpoint:1.16
	gdb-csl-sourcerygxx-4_1-4:1.16
	binutils-csl-sourcerygxx-4_1-4:1.16
	msnyder-reverse-20060502-branch:1.16.0.26
	msnyder-reverse-20060502-branchpoint:1.16
	binutils-csl-wrs-linux-3_4_4-21:1.13
	gdb-csl-morpho-4_1-4:1.16
	binutils-csl-morpho-4_1-4:1.16
	gdb-csl-sourcerygxx-3_4_4-17:1.16
	binutils-csl-sourcerygxx-3_4_4-17:1.16
	binutils-csl-wrs-linux-3_4_4-20:1.13
	readline_5_1-import-branch:1.16.0.24
	readline_5_1-import-branchpoint:1.16
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.16
	binutils-2_17-branch:1.16.0.22
	binutils-2_17-branchpoint:1.16
	gdb-csl-symbian-20060226-branch:1.16.0.20
	gdb-csl-symbian-20060226-branchpoint:1.16
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.16
	msnyder-reverse-20060331-branch:1.16.0.18
	msnyder-reverse-20060331-branchpoint:1.16
	binutils-csl-2_17-branch:1.16.0.16
	binutils-csl-2_17-branchpoint:1.16
	gdb-csl-available-20060303-branch:1.16.0.14
	gdb-csl-available-20060303-branchpoint:1.16
	gdb-csl-20060226-branch:1.16.0.12
	gdb-csl-20060226-branchpoint:1.16
	gdb_6_4-20051202-release:1.16
	msnyder-fork-checkpoint-branch:1.16.0.10
	msnyder-fork-checkpoint-branchpoint:1.16
	gdb-csl-gxxpro-6_3-branch:1.16.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.16
	gdb_6_4-branch:1.16.0.6
	gdb_6_4-2005-11-01-branchpoint:1.16
	gdb-csl-arm-20051020-branch:1.16.0.4
	gdb-csl-arm-20051020-branchpoint:1.16
	binutils-csl-gxxpro-3_4-branch:1.13.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.13
	binutils-2_16_1:1.13
	msnyder-tracepoint-checkpoint-branch:1.16.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.16
	gdb-csl-arm-20050325-2005-q1b:1.13
	binutils-csl-arm-2005q1b:1.13
	binutils-2_16:1.13
	gdb-csl-arm-20050325-2005-q1a:1.13
	binutils-csl-arm-2005q1a:1.13
	csl-arm-20050325-branch:1.13.0.6
	csl-arm-20050325-branchpoint:1.13
	binutils-csl-arm-2005q1-branch:1.13.0.4
	binutils-csl-arm-2005q1-branchpoint:1.13
	binutils-2_16-branch:1.13.0.2
	binutils-2_16-branchpoint:1.13
	csl-arm-2004-q3d:1.11
	gdb_6_3-20041109-release:1.11
	gdb_6_3-branch:1.11.0.4
	gdb_6_3-20041019-branchpoint:1.11
	csl-arm-2004-q3:1.11
	drow_intercu-merge-20040921:1.11
	drow_intercu-merge-20040915:1.11
	jimb-gdb_6_2-e500-branch:1.11.0.6
	jimb-gdb_6_2-e500-branchpoint:1.11
	gdb_6_2-20040730-release:1.11
	gdb_6_2-branch:1.11.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.11
	gdb_6_1_1-20040616-release:1.10
	binutils-2_15:1.10
	binutils-2_15-branchpoint:1.10
	csl-arm-2004-q1a:1.10
	csl-arm-2004-q1:1.10
	gdb_6_1-2004-04-05-release:1.10
	drow_intercu-merge-20040402:1.10
	drow_intercu-merge-20040327:1.10
	ezannoni_pie-20040323-branch:1.10.0.56
	ezannoni_pie-20040323-branchpoint:1.10
	cagney_tramp-20040321-mergepoint:1.10
	cagney_tramp-20040309-branch:1.10.0.54
	cagney_tramp-20040309-branchpoint:1.10
	gdb_6_1-branch:1.10.0.52
	gdb_6_1-2004-03-01-gmt-branchpoint:1.10
	drow_intercu-20040221-branch:1.10.0.50
	drow_intercu-20040221-branchpoint:1.10
	binutils-2_15-branch:1.10.0.48
	cagney_bfdfile-20040213-branch:1.10.0.46
	cagney_bfdfile-20040213-branchpoint:1.10
	drow-cplus-merge-20040208:1.10
	carlton_dictionary-20040126-merge:1.10
	cagney_bigcore-20040122-branch:1.10.0.44
	cagney_bigcore-20040122-branchpoint:1.10
	drow-cplus-merge-20040113:1.10
	csl-arm-2003-q4:1.10
	drow-cplus-merge-20031224:1.10
	drow-cplus-merge-20031220:1.10
	carlton_dictionary-20031215-merge:1.10
	drow-cplus-merge-20031214:1.10
	carlton-dictionary-20031111-merge:1.10
	gdb_6_0-2003-10-04-release:1.10
	kettenis_sparc-20030918-branch:1.10.0.42
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.40
	cagney_x86i386-20030821-branch:1.10.0.38
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.10
	carlton_dictionary-20030627-merge:1.10
	gdb_6_0-branch:1.10.0.36
	gdb_6_0-2003-06-23-branchpoint:1.10
	jimb-ppc64-linux-20030613-branch:1.10.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.10
	binutils-2_14:1.10
	cagney_convert-20030606-branch:1.10.0.32
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.10.0.30
	cagney_writestrings-20030508-branchpoint:1.10
	jimb-ppc64-linux-20030528-branch:1.10.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.10
	carlton_dictionary-20030523-merge:1.10
	cagney_fileio-20030521-branch:1.10.0.26
	cagney_fileio-20030521-branchpoint:1.10
	kettenis_i386newframe-20030517-mergepoint:1.10
	jimb-ppc64-linux-20030509-branch:1.10.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.10
	kettenis_i386newframe-20030504-mergepoint:1.10
	carlton_dictionary-20030430-merge:1.10
	binutils-2_14-branch:1.10.0.22
	binutils-2_14-branchpoint:1.10
	kettenis_i386newframe-20030419-branch:1.10.0.20
	kettenis_i386newframe-20030419-branchpoint:1.10
	carlton_dictionary-20030416-merge:1.10
	cagney_frameaddr-20030409-mergepoint:1.10
	kettenis_i386newframe-20030406-branch:1.10.0.18
	kettenis_i386newframe-20030406-branchpoint:1.10
	cagney_frameaddr-20030403-branchpoint:1.10
	cagney_frameaddr-20030403-branch:1.10.0.16
	cagney_framebase-20030330-mergepoint:1.10
	cagney_framebase-20030326-branch:1.10.0.14
	cagney_framebase-20030326-branchpoint:1.10
	cagney_lazyid-20030317-branch:1.10.0.12
	cagney_lazyid-20030317-branchpoint:1.10
	kettenis-i386newframe-20030316-mergepoint:1.10
	offbyone-20030313-branch:1.10.0.10
	offbyone-20030313-branchpoint:1.10
	kettenis-i386newframe-20030308-branch:1.10.0.8
	kettenis-i386newframe-20030308-branchpoint:1.10
	carlton_dictionary-20030305-merge:1.10
	cagney_offbyone-20030303-branch:1.10.0.6
	cagney_offbyone-20030303-branchpoint:1.10
	carlton_dictionary-20030207-merge:1.10
	interps-20030202-branch:1.10.0.4
	interps-20030202-branchpoint:1.10
	cagney-unwind-20030108-branch:1.10.0.2
	cagney-unwind-20030108-branchpoint:1.10
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.9
	binutils-2_13_1:1.9
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.24
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.22
	carlton_dictionary-20020920-branchpoint:1.9
	sid-20020905-branchpoint:1.9
	sid-20020905-branch:1.9.0.20
	gdb_5_3-branch:1.9.0.18
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.16
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.14
	readline_4_3-import-branchpoint:1.9
	binutils-2_13:1.9
	gdb_5_2_1-2002-07-23-release:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.12
	kseitz_interps-20020528-branch:1.9.0.10
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.8
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.9
	jimb-macro-020506-branch:1.9.0.6
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	binutils-2_12:1.9
	gdb_5_2-branch:1.9.0.4
	gdb_5_2-2002-03-03-branchpoint:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.8
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	binutils-2_11_2:1.4.2.1
	binutils-2_11_1:1.4.2.1
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	insight-precleanup-2001-01-01:1.4
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.4
	gdb_5_0-2000-04-10-branchpoint:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.23
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2010.04.14.09.24.59;	author gingold;	state dead;
branches;
next	1.23;

1.23
date	2010.01.15.21.38.16;	author jkratoch;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.23.09.28.43;	author gingold;	state Exp;
branches;
next	1.20;

1.20
date	2008.02.20.17.42.36;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.01.20.06.05;	author msnyder;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.03.14.26.43;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.04.15.53.40;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.04.07.19.39;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.21.07.45.38;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.20.14.59.07;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.31.23.13.30;	author bje;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.24.04.46.26;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches
	1.10.50.1;
next	1.9;

1.9
date	2002.01.30.16.07.28;	author nickc;	state Exp;
branches
	1.9.22.1
	1.9.24.1;
next	1.8;

1.8
date	2001.09.19.05.33.13;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.01.10.29.27;	author aj;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.25.14.42.42;	author kazu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.07.12.10.30.15;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.07.35.19;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;

1.4.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.9.22.1
date	2002.12.23.19.38.01;	author carlton;	state Exp;
branches;
next	;

1.9.24.1
date	2003.12.14.20.26.53;	author drow;	state Exp;
branches;
next	;

1.10.50.1
date	2004.09.16.17.00.38;	author drow;	state Exp;
branches;
next	;


desc
@@


1.24
log
@2010-04-14  Tristan Gingold  <gingold@@adacore.com>

	* Makefile.am (BFD32_BACKENDS): Remove vms-gsd.lo, vms-hdr.lo,
	vms-tir.lo, vms.lo and add vms-alpha.lo
	(BFD32_BACKENDS_CFILES): Remove vms-gsd.c, vms-hdr.c,
	vms-tir.c, vms.c and add vms-alpha.c
	* Makefile.in: Regenerate.
	* configure.in (TDEFINES): Adjust file list for vms_alpha_vec.
	Remove vms_vax_vec.
	* configure: Regenerate.
	* targets.c (vms_vax_vec): Remove the declaration.
	(_bfd_target_vector): Remove vms_vax_vec.
	* vms-alpha.c: New file.
	* vms-gsd.c: Removed, rewritten in vms-alpha.c
	* vms-hdr.c: Ditto.
	* vms-tir.c: Ditto.
	* vms.c: Ditto.
	* vms-misc.c: Fix indentation and comments.  Replace most of
	#if VMS_DEBUG/vms_debug with vms_debug2.
	(_bfd_vms_hash_newfunc): Moved to vms-alpha.c
	(hash_string): Ditto.
	(_bfd_vms_length_hash_symbol): Ditto.
	(maybe_adjust_record_pointer_for_object): Ditto.
	(_bfd_vms_get_object_record): Ditto.
	(vms_get_remaining_object_record): Ditto.
	(_bfd_vms_push): Ditto.
	(_bfd_vms_pop): Ditto.
	(_bfd_vms_get_header_values): Removed.
	(_bfd_vms_get_first_record): Removed.
	(vms_get_remaining_image_record): Removed.
	(new_symbol): Removed.
	(_bfd_vms_enter_symbol): Removed.
	(_bfd_vms_save_sized_string): Use memcpy instead of strncpy.
	(_bfd_vms_output_begin): Remove rechead parameter.  Replace bfd
	parameter with struct vms_rec_wr.
	(_bfd_vms_output_push): Removed and replaced by ...
	(_bfd_vms_output_begin_subrec): ... new function.
	(_bfd_vms_output_alignment): Replace bfd parameter with
	struct vms_rec_wr, and adjust.
	(_bfd_vms_output_check): Ditto
	(_bfd_vms_output_byte): Ditto.
	(_bfd_vms_output_short): Ditto.
	(_bfd_vms_output_long): Ditto.
	(_bfd_vms_output_quad): Ditto.
	(_bfd_vms_output_counted): Ditto.
	(_bfd_vms_output_dump): Ditto.
	(_bfd_vms_output_fill): Ditto.
	(_bfd_vms_output_pop): Removed and replaced by ...
	(_bfd_vms_output_end_subrec): ... new function.
	(_bfd_vms_output_flush): Removed.
	(_bfd_vms_output_align): New function.
	(_bfd_vms_output_end): Add recwr parameter.  Adjust for this new
	parameter.
	(vms_convert_to_var): New function imported from vms.c
	(vms_convert_to_var_1): Ditto.
	(vms_convert_to_var_unix_filename): Ditto.
	(vms_get_module_name): Ditto.
	(get_vms_time_string): Ditto.
	(vms_time_to_time_t): Ditto.
	(vms_rawtime_to_time_t): Ditto.
	* vms.h: All macros for the VMS file format are now in include/vms.
	Prototypes for vms.c, vms-gsd.c, vms-misc.c, vms-hdr.c, vms-tir.c
	have been removed.
	(struct vms_symbol_struct, struct stack_struct): Moved to vms-alpha.c
	(struct fileinfo, struct srecinfo, struct lineinfo): Ditto.
	(struct funcinfo, struct vms_private_data_struct): Ditto.
	(struct vms_section_data_struct): Ditto.
	(struct vms_rec_rd, stryct vms_rec_wr): New declarations.
	(vms_get_module_name, get_vms_time_string): New declarations.
	(vms_time_to_time_t, vms_rawtime_to_time_t): Ditto.
	(_bfd_vms_output_begin_subrec, _bfd_vms_output_end_subrec): Ditto.
	(_bfd_vms_save_sized_string, _bfd_vms_save_counted_string): Adjusted.
	(_bfd_vms_output_begin, _bfd_vms_output_alignment): Ditto.
	(_bfd_vms_output_end,_bfd_vms_output_check): Ditto.
	(_bfd_vms_output_byte, _bfd_vms_output_short): Ditto.
	(_bfd_vms_output_long, _bfd_vms_output_quad): Ditto.
	(_bfd_vms_output_counted, _bfd_vms_output_dump): Ditto.
	(_bfd_vms_output_fill): Ditto.
	(bfd_vms_set_section_flags): Ditto.
@
text
@/* vms-tir.c -- BFD back-end for VAX (openVMS/VAX) and
   EVAX (openVMS/Alpha) files.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2007,
   2008, 2009 Free Software Foundation, Inc.

   TIR record handling functions
   ETIR record handling functions

   Go and read the openVMS linker manual (esp. appendix B)
   if you don't know what's going on here :-)

   Written by Klaus K"ampf (kkaempf@@rmi.de)

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

/* The following type abbreviations are used:

	cs	counted string (ascii string with length byte)
	by	byte (1 byte)
	sh	short (2 byte, 16 bit)
	lw	longword (4 byte, 32 bit)
	qw	quadword (8 byte, 64 bit)
	da	data stream  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "vms.h"

static int check_section (bfd *, int);
static void image_set_ptr (bfd *abfd, int psect, uquad offset);
static void image_inc_ptr (bfd *abfd, uquad offset);
static void dst_define_location (bfd *abfd, uquad loc);
static void dst_restore_location (bfd *abfd, uquad loc);
static unsigned int dst_retrieve_location (bfd *abfd, uquad loc);
static void dst_check_allocation (bfd *abfd, unsigned int size);
static void image_dump (bfd *abfd, unsigned char *ptr, int size, int offset);
static void image_write_b (bfd *abfd, unsigned int value);
static void image_write_w (bfd *abfd, unsigned int value);
static void image_write_l (bfd *abfd, unsigned long value);
static void image_write_q (bfd *abfd, uquad value);
static bfd_boolean etir_sta (bfd *, int, unsigned char *, int *);
static bfd_boolean etir_sto (bfd *, int, unsigned char *, int *);
static bfd_boolean etir_opr (bfd *, int, unsigned char *, int *);
static bfd_boolean etir_ctl (bfd *, int, unsigned char *, int *);
static bfd_boolean etir_stc (bfd *, int, unsigned char *, int *);
static asection *new_section (bfd *, int);
static int alloc_section (bfd *, unsigned int);
static int etir_cmd (bfd *, int, unsigned char *, int *);
static int analyze_tir (bfd *, unsigned char *, unsigned int);
static int analyze_etir (bfd *, unsigned char *, unsigned int);
static unsigned char *tir_opr (bfd *, unsigned char *);
static const char *tir_cmd_name (int);
static const char *cmd_name (int);


static int
check_section (bfd * abfd, int size)
{
  bfd_size_type offset;

  offset = PRIV (image_ptr) - PRIV (image_section)->contents;
  if (offset + size > PRIV (image_section)->size)
    {
      PRIV (image_section)->contents
	= bfd_realloc_or_free (PRIV (image_section)->contents, offset + size);
      if (PRIV (image_section)->contents == NULL)
	{
	  (*_bfd_error_handler) (_("No Mem !"));
	  return -1;
	}
      PRIV (image_section)->size = offset + size;
      PRIV (image_ptr) = PRIV (image_section)->contents + offset;
    }

  return 0;
}

/* Routines to fill sections contents during tir/etir read.  */

/* Initialize image buffer pointer to be filled.  */

static void
image_set_ptr (bfd * abfd, int psect, uquad offset)
{
#if VMS_DEBUG
  _bfd_vms_debug (4, "image_set_ptr (%d=%s, %d)\n",
		  psect, PRIV (sections)[psect]->name, offset);
#endif

  PRIV (image_ptr) = PRIV (sections)[psect]->contents + offset;
  PRIV (image_section) = PRIV (sections)[psect];
}

/* Increment image buffer pointer by offset.  */

static void
image_inc_ptr (bfd * abfd, uquad offset)
{
#if VMS_DEBUG
  _bfd_vms_debug (4, "image_inc_ptr (%d)\n", offset);
#endif

  PRIV (image_ptr) += offset;
}

/* Save current DST location counter under specified index.  */

static void
dst_define_location (bfd *abfd, uquad loc)
{
  asection *dst_section = PRIV (dst_section);

#if VMS_DEBUG
  _bfd_vms_debug (4, "dst_define_location (%d)\n", (int)loc);
#endif

  /* Grow the ptr offset table if necessary.  */
  if (loc + 1 > PRIV (dst_ptr_offsets_count))
    {
      PRIV (dst_ptr_offsets) = bfd_realloc (PRIV (dst_ptr_offsets),
					   (loc + 1) * sizeof (unsigned int));
      PRIV (dst_ptr_offsets_count) = loc + 1;
    }

  PRIV (dst_ptr_offsets)[loc] = PRIV (image_ptr) - dst_section->contents;
}

/* Restore saved DST location counter from specified index.  */

static void
dst_restore_location (bfd *abfd, uquad loc)
{
  asection *dst_section = PRIV (dst_section);

#if VMS_DEBUG
  _bfd_vms_debug (4, "dst_restore_location (%d)\n", (int)loc);
#endif

  PRIV (image_ptr) = dst_section->contents + PRIV (dst_ptr_offsets)[loc];
}

/* Retrieve saved DST location counter from specified index.  */

static unsigned int
dst_retrieve_location (bfd *abfd, uquad loc)
{
#if VMS_DEBUG
  _bfd_vms_debug (4, "dst_retrieve_location (%d)\n", (int)loc);
#endif

  return PRIV (dst_ptr_offsets)[loc];
}

/* Check that the DST section is big enough for the specified
   amount of bytes.  */

static void
dst_check_allocation (bfd *abfd, unsigned int size)
{
  asection *dst_section = PRIV (dst_section);

  bfd_size_type used = PRIV (image_ptr) - dst_section->contents;
  bfd_size_type left = dst_section->size - used;

  /* Grow the DST section as necessary */
  if (size > left)
    {
      dst_section->size *= 2;
      dst_section->contents
	= bfd_realloc (dst_section->contents, dst_section->size);
      PRIV (image_ptr) = dst_section->contents + used;

      dst_check_allocation (abfd, size);
    }
}

/* Dump multiple bytes to section image.  */

static void
image_dump (bfd * abfd,
	    unsigned char *ptr,
	    int size,
	    int offset ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  _bfd_vms_debug (8, "image_dump from (%p, %d) to (%p)\n", ptr, size,
		  PRIV (image_ptr));
  _bfd_hexdump (9, ptr, size, offset);
#endif

  if (PRIV (is_vax) && check_section (abfd, size))
    return;

  if (PRIV (dst_section))
    dst_check_allocation (abfd, size);

  while (size-- > 0)
    *PRIV (image_ptr)++ = *ptr++;
}

/* Write byte to section image.  */

static void
image_write_b (bfd * abfd, unsigned int value)
{
#if VMS_DEBUG
  _bfd_vms_debug (6, "image_write_b (%02x)\n", (int) value);
#endif

  if (PRIV (is_vax) && check_section (abfd, 1))
    return;

  if (PRIV (dst_section))
    dst_check_allocation (abfd, 1);

  *PRIV (image_ptr)++ = (value & 0xff);
}

/* Write 2-byte word to image.  */

static void
image_write_w (bfd * abfd, unsigned int value)
{
#if VMS_DEBUG
  _bfd_vms_debug (6, "image_write_w (%04x)\n", (int) value);
#endif

  if (PRIV (is_vax) && check_section (abfd, 2))
    return;

  if (PRIV (dst_section))
    dst_check_allocation (abfd, 2);

  bfd_putl16 ((bfd_vma) value, PRIV (image_ptr));
  PRIV (image_ptr) += 2;
}

/* Write 4-byte long to image.  */

static void
image_write_l (bfd * abfd, unsigned long value)
{
#if VMS_DEBUG
  _bfd_vms_debug (6, "image_write_l (%08lx)\n", value);
#endif

  if (PRIV (is_vax) && check_section (abfd, 4))
    return;

  if (PRIV (dst_section))
    dst_check_allocation (abfd, 4);

  bfd_putl32 ((bfd_vma) value, PRIV (image_ptr));
  PRIV (image_ptr) += 4;
}

/* Write 8-byte quad to image.  */

static void
image_write_q (bfd * abfd, uquad value)
{
#if VMS_DEBUG
  _bfd_vms_debug (6, "image_write_q (%016lx)\n", value);
#endif

  if (PRIV (is_vax) && check_section (abfd, 8))
    return;

  if (PRIV (dst_section))
    dst_check_allocation (abfd, 8);

  bfd_putl64 (value, PRIV (image_ptr));
  PRIV (image_ptr) += 8;
}

static const char *
cmd_name (int cmd)
{
  switch (cmd)
    {
    case ETIR_S_C_STA_GBL: return "ETIR_S_C_STA_GBL";
    case ETIR_S_C_STA_LW: return "ETIR_S_C_STA_LW";
    case ETIR_S_C_STA_QW: return "ETIR_S_C_STA_QW";
    case ETIR_S_C_STA_PQ: return "ETIR_S_C_STA_PQ";
    case ETIR_S_C_STA_LI: return "ETIR_S_C_STA_LI";
    case ETIR_S_C_STA_MOD: return "ETIR_S_C_STA_MOD";
    case ETIR_S_C_STA_CKARG: return "ETIR_S_C_STA_CKARG";
    case ETIR_S_C_STO_B: return "ETIR_S_C_STO_B";
    case ETIR_S_C_STO_W: return "ETIR_S_C_STO_W";
    case ETIR_S_C_STO_GBL: return "ETIR_S_C_STO_GBL";
    case ETIR_S_C_STO_CA: return "ETIR_S_C_STO_CA";
    case ETIR_S_C_STO_RB: return "ETIR_S_C_STO_RB";
    case ETIR_S_C_STO_AB: return "ETIR_S_C_STO_AB";
    case ETIR_S_C_STO_OFF: return "ETIR_S_C_STO_OFF";
    case ETIR_S_C_STO_IMM: return "ETIR_S_C_STO_IMM";
    case ETIR_S_C_STO_IMMR: return "ETIR_S_C_STO_IMMR";
    case ETIR_S_C_STO_LW: return "ETIR_S_C_STO_LW";
    case ETIR_S_C_STO_QW: return "ETIR_S_C_STO_QW";
    case ETIR_S_C_STO_GBL_LW: return "ETIR_S_C_STO_GBL_LW";
    case ETIR_S_C_STO_LP_PSB: return "ETIR_S_C_STO_LP_PSB";
    case ETIR_S_C_STO_HINT_GBL: return "ETIR_S_C_STO_HINT_GBL";
    case ETIR_S_C_STO_HINT_PS: return "ETIR_S_C_STO_HINT_PS";
    case ETIR_S_C_OPR_ADD: return "ETIR_S_C_OPR_ADD";
    case ETIR_S_C_OPR_INSV: return "ETIR_S_C_OPR_INSV";
    case ETIR_S_C_OPR_USH: return "ETIR_S_C_OPR_USH";
    case ETIR_S_C_OPR_ROT: return "ETIR_S_C_OPR_ROT";
    case ETIR_S_C_OPR_REDEF: return "ETIR_S_C_OPR_REDEF";
    case ETIR_S_C_OPR_DFLIT: return "ETIR_S_C_OPR_DFLIT";
    case ETIR_S_C_STC_LP: return "ETIR_S_C_STC_LP";
    case ETIR_S_C_STC_GBL: return "ETIR_S_C_STC_GBL";
    case ETIR_S_C_STC_GCA: return "ETIR_S_C_STC_GCA";
    case ETIR_S_C_STC_PS: return "ETIR_S_C_STC_PS";
    case ETIR_S_C_STC_NBH_PS: return "ETIR_S_C_STC_NBH_PS";
    case ETIR_S_C_STC_NOP_GBL: return "ETIR_S_C_STC_NOP_GBL";
    case ETIR_S_C_STC_NOP_PS: return "ETIR_S_C_STC_NOP_PS";
    case ETIR_S_C_STC_BSR_GBL: return "ETIR_S_C_STC_BSR_GBL";
    case ETIR_S_C_STC_BSR_PS: return "ETIR_S_C_STC_BSR_PS";
    case ETIR_S_C_STC_LDA_GBL: return "ETIR_S_C_STC_LDA_GBL";
    case ETIR_S_C_STC_LDA_PS: return "ETIR_S_C_STC_LDA_PS";
    case ETIR_S_C_STC_BOH_GBL: return "ETIR_S_C_STC_BOH_GBL";
    case ETIR_S_C_STC_BOH_PS: return "ETIR_S_C_STC_BOH_PS";
    case ETIR_S_C_STC_NBH_GBL: return "ETIR_S_C_STC_NBH_GBL";
    case ETIR_S_C_CTL_SETRB: return "ETIR_S_C_CTL_SETRB";
    case ETIR_S_C_STC_LP_PSB: return "ETIR_S_C_STC_LP_PSB";
    case ETIR_S_C_CTL_DFLOC: return "ETIR_S_C_CTL_DFLOC";
    case ETIR_S_C_CTL_STLOC: return "ETIR_S_C_CTL_STLOC";
    case ETIR_S_C_CTL_STKDL: return "ETIR_S_C_CTL_STKDL";

    default:
      /* These names have not yet been added to this switch statement.  */
      (*_bfd_error_handler) (_("unknown ETIR command %d"), cmd);
    }

  return NULL;
}
#define HIGHBIT(op) ((op & 0x80000000L) == 0x80000000L)

/* etir_sta

   Vms stack commands.

   Handle sta_xxx commands in etir section,
   ptr points to data area in record.

   See table B-8 of the openVMS linker manual.  */

static bfd_boolean
etir_sta (bfd *abfd, int cmd, unsigned char *ptr, int *quarter_relocs)
{
#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_sta %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (long) ptr);
#endif

  switch (cmd)
    {
      /* Stack global
	 arg: cs	symbol name

	 stack 32 bit value of symbol (high bits set to 0).  */
    case ETIR_S_C_STA_GBL:
      {
	char *name;
	vms_symbol_entry *entry;

	name = _bfd_vms_save_counted_string (ptr);
	entry = (vms_symbol_entry *)
	  bfd_hash_lookup (PRIV (vms_symbol_table), name, FALSE, FALSE);
	if (entry == NULL)
	  {
#if VMS_DEBUG
	    _bfd_vms_debug (3, "%s: no symbol \"%s\"\n",
			    cmd_name (cmd), name);
#endif
	    _bfd_vms_push (abfd, (uquad) 0, -1);
	  }
	else
	  _bfd_vms_push (abfd, (uquad) (entry->symbol->value), -1);
      }
      *quarter_relocs = 1;
      break;

      /* Stack longword
	 arg: lw	value

	 stack 32 bit value, sign extend to 64 bit.  */
    case ETIR_S_C_STA_LW:
      _bfd_vms_push (abfd, (uquad) bfd_getl32 (ptr), -1);
      /* This one is special as it is both part of the section header
         and of the ALPHA_R_REFLONG relocation.  */
      if (bfd_getl16 (ptr - 4 + bfd_getl16 (ptr - 2)) == ETIR_S_C_CTL_DFLOC)
	*quarter_relocs = 0;
      else if (*quarter_relocs)
	*quarter_relocs += 1;
      else
	*quarter_relocs = 2;
      break;

      /* Stack quadword
	 arg: qw	value

	 stack 64 bit value of symbol.  */
    case ETIR_S_C_STA_QW:
      _bfd_vms_push (abfd, (uquad) bfd_getl64 (ptr), -1);
      if (*quarter_relocs)
	*quarter_relocs += 1;
      else
	*quarter_relocs = 2;
      break;

      /* Stack psect base plus quadword offset
	 arg: lw	section index
	 qw	signed quadword offset (low 32 bits)

	 Stack qw argument and section index
	 (see ETIR_S_C_STO_OFF, ETIR_S_C_CTL_SETRB).  */
    case ETIR_S_C_STA_PQ:
      {
	uquad dummy;
	int psect;

	psect = bfd_getl32 (ptr);
	if ((unsigned int) psect >= PRIV (section_count))
	  {
	    (*_bfd_error_handler) (_("bad section index in %s"),
				   cmd_name (cmd));
	    bfd_set_error (bfd_error_bad_value);
	    return FALSE;
	  }
	dummy = bfd_getl64 (ptr + 4);
	_bfd_vms_push (abfd, dummy, (int) psect);
      }
      /* This one is special as it is both part of the section header
         and of the ALPHA_R_REFLONG and ALPHA_R_REFQUAD relocations.  */
      if (bfd_getl16 (ptr - 4 + bfd_getl16 (ptr - 2)) == ETIR_S_C_CTL_SETRB)
	*quarter_relocs = 0;
      else
	*quarter_relocs = 2;
      break;

    case ETIR_S_C_STA_LI:
    case ETIR_S_C_STA_MOD:
    case ETIR_S_C_STA_CKARG:
      (*_bfd_error_handler) (_("unsupported STA cmd %s"), cmd_name (cmd));
      *quarter_relocs = 0;
      return FALSE;

    default:
      (*_bfd_error_handler) (_("reserved STA cmd %d"), cmd);
      *quarter_relocs = 0;
      return FALSE;
    }

#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_sta true\n");
#endif

  return TRUE;
}

/* etir_sto

   vms store commands

   handle sto_xxx commands in etir section
   ptr points to data area in record

   see table B-9 of the openVMS linker manual.  */

static bfd_boolean
etir_sto (bfd *abfd, int cmd, unsigned char *ptr, int *quarter_relocs)
{
  uquad dummy;
  int psect;

#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_sto %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (long) ptr);
#endif

  switch (cmd)
    {
      /* Store byte: pop stack, write byte
	 arg: -.  */
    case ETIR_S_C_STO_B:
      dummy = _bfd_vms_pop (abfd, &psect);
      /* FIXME: check top bits.  */
      image_write_b (abfd, (unsigned int) dummy & 0xff);
      *quarter_relocs = 0;
      break;

      /* Store word: pop stack, write word
	 arg: -.  */
    case ETIR_S_C_STO_W:
      dummy = _bfd_vms_pop (abfd, &psect);
      /* FIXME: check top bits */
      image_write_w (abfd, (unsigned int) dummy & 0xffff);
      *quarter_relocs = 0;
      break;

      /* Store longword: pop stack, write longword
	 arg: -.  */
    case ETIR_S_C_STO_LW:
      dummy = _bfd_vms_pop (abfd, &psect);
      dummy += (PRIV (sections)[psect])->vma;
      /* FIXME: check top bits.  */
      image_write_l (abfd, (unsigned int) dummy & 0xffffffff);
      if (*quarter_relocs == 2)
	*quarter_relocs = 4;
      else
	*quarter_relocs += 1;
      break;

      /* Store quadword: pop stack, write quadword
	 arg: -.  */
    case ETIR_S_C_STO_QW:
      dummy = _bfd_vms_pop (abfd, &psect);
      dummy += (PRIV (sections)[psect])->vma;
      /* FIXME: check top bits.  */
      image_write_q (abfd, dummy);
      if (*quarter_relocs == 2)
	*quarter_relocs = 4;
      else
	*quarter_relocs += 1;
      break;

      /* Store immediate repeated: pop stack for repeat count
	 arg: lw	byte count
	 da	data.  */
    case ETIR_S_C_STO_IMMR:
      {
	int size;

	size = bfd_getl32 (ptr);
	dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
	while (dummy-- > 0)
	  image_dump (abfd, ptr+4, size, 0);
      }
      *quarter_relocs = 0;
      break;

      /* Store global: write symbol value
	 arg: cs	global symbol name.  */
    case ETIR_S_C_STO_GBL:
      {
	vms_symbol_entry *entry;
	char *name;

	name = _bfd_vms_save_counted_string (ptr);
	entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV (vms_symbol_table),
						      name, FALSE, FALSE);
	if (entry == NULL)
	  /* FIXME, reloc.  */
	  image_write_q (abfd, (uquad) (0));
	else
	  /* FIXME, reloc.  */
	  image_write_q (abfd, (uquad) (entry->symbol->value));
      }
      *quarter_relocs = 4;
      break;

      /* Store code address: write address of entry point
	 arg: cs	global symbol name (procedure).  */
    case ETIR_S_C_STO_CA:
      {
	vms_symbol_entry *entry;
	char *name;

	name = _bfd_vms_save_counted_string (ptr);
	entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV (vms_symbol_table),
						      name, FALSE, FALSE);
	if (entry == NULL)
	  /* FIXME, reloc.  */
	  image_write_q (abfd, (uquad) (0));
	else
	  /* FIXME, reloc.  */
	  image_write_q (abfd, (uquad) (entry->symbol->value));
      }
      *quarter_relocs = 4;
      break;

      /* Store offset to psect: pop stack, add low 32 bits to base of psect
	 arg: none.  */
    case ETIR_S_C_STO_OFF:
      {
	uquad q;
	int psect1;

	q = _bfd_vms_pop (abfd, & psect1);
	q += (PRIV (sections)[psect1])->vma;
	image_write_q (abfd, q);
      }
      *quarter_relocs += 2;
      break;

      /* Store immediate
	 arg: lw	count of bytes
	      da	data.  */
    case ETIR_S_C_STO_IMM:
      {
	int size;

	size = bfd_getl32 (ptr);
	image_dump (abfd, ptr+4, size, 0);
      }
      *quarter_relocs = 0;
      break;

      /* This code is 'reserved to digital' according to the openVMS
	 linker manual, however it is generated by the DEC C compiler
	 and defined in the include file.
	 FIXME, since the following is just a guess
	 store global longword: store 32bit value of symbol
	 arg: cs	symbol name.  */
    case ETIR_S_C_STO_GBL_LW:
      {
	vms_symbol_entry *entry;
	char *name;

	name = _bfd_vms_save_counted_string (ptr);
	entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV (vms_symbol_table),
						      name, FALSE, FALSE);
	if (entry == NULL)
	  {
#if VMS_DEBUG
	    _bfd_vms_debug (3, "%s: no symbol \"%s\"\n", cmd_name (cmd), name);
#endif
	    image_write_l (abfd, (unsigned long) 0);	/* FIXME, reloc */
	  }
	else
	  /* FIXME, reloc.  */
	  image_write_l (abfd, (unsigned long) (entry->symbol->value));
      }
      *quarter_relocs = 4;
      break;

    case ETIR_S_C_STO_RB:
    case ETIR_S_C_STO_AB:
    case ETIR_S_C_STO_LP_PSB:
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
      *quarter_relocs = 0;
      return FALSE;

    case ETIR_S_C_STO_HINT_GBL:
    case ETIR_S_C_STO_HINT_PS:
      (*_bfd_error_handler) (_("%s: not implemented"), cmd_name (cmd));
      *quarter_relocs = 0;
      return FALSE;

    default:
      (*_bfd_error_handler) (_("reserved STO cmd %d"), cmd);
      *quarter_relocs = 0;
      return FALSE;
    }

  return TRUE;
}

/* Stack operator commands
   all 32 bit signed arithmetic
   all word just like a stack calculator
   arguments are popped from stack, results are pushed on stack

   see table B-10 of the openVMS linker manual.  */

static bfd_boolean
etir_opr (bfd *abfd, int cmd, unsigned char *ptr ATTRIBUTE_UNUSED,
	  int *quarter_relocs)
{
  long op1, op2;

#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_opr %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (long) ptr);
#endif

  /* No relocation uses OPR commands except ETIR_S_C_OPR_ADD.  */
  if (cmd == ETIR_S_C_OPR_ADD)
    *quarter_relocs += 1;
  else
    *quarter_relocs = 0;

  switch (cmd)
    {
    case ETIR_S_C_OPR_NOP:      /* No-op.  */
      break;

    case ETIR_S_C_OPR_ADD:      /* Add.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 + op2), -1);
      break;

    case ETIR_S_C_OPR_SUB:      /* Subtract.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op2 - op1), -1);
      break;

    case ETIR_S_C_OPR_MUL:      /* Multiply.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 * op2), -1);
      break;

    case ETIR_S_C_OPR_DIV:      /* Divide.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      if (op2 == 0)
	_bfd_vms_push (abfd, (uquad) 0, -1);
      else
	_bfd_vms_push (abfd, (uquad) (op2 / op1), -1);
      break;

    case ETIR_S_C_OPR_AND:      /* Logical AND.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 & op2), -1);
      break;

    case ETIR_S_C_OPR_IOR:      /* Logical inclusive OR.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 | op2), -1);
      break;

    case ETIR_S_C_OPR_EOR:      /* Logical exclusive OR.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 ^ op2), -1);
      break;

    case ETIR_S_C_OPR_NEG:      /* Negate.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (-op1), -1);
      break;

    case ETIR_S_C_OPR_COM:      /* Complement.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 ^ -1L), -1);
      break;

    case ETIR_S_C_OPR_ASH:      /* Arithmetic shift.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      if (op2 < 0)		/* Shift right.  */
	op1 >>= -op2;
      else			/* Shift left.  */
	op1 <<= op2;
      _bfd_vms_push (abfd, (uquad) op1, -1);
      break;

    case ETIR_S_C_OPR_INSV:      /* Insert field.   */
      (void) _bfd_vms_pop (abfd, NULL);
    case ETIR_S_C_OPR_USH:       /* Unsigned shift.   */
    case ETIR_S_C_OPR_ROT:       /* Rotate.  */
    case ETIR_S_C_OPR_REDEF:     /* Redefine symbol to current location.  */
    case ETIR_S_C_OPR_DFLIT:     /* Define a literal.  */
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
      return FALSE;

    case ETIR_S_C_OPR_SEL:      /* Select.  */
      if ((long) _bfd_vms_pop (abfd, NULL) & 0x01L)
	(void) _bfd_vms_pop (abfd, NULL);
      else
	{
	  op1 = (long) _bfd_vms_pop (abfd, NULL);
	  (void) _bfd_vms_pop (abfd, NULL);
	  _bfd_vms_push (abfd, (uquad) op1, -1);
	}
      break;

    default:
      (*_bfd_error_handler) (_("reserved OPR cmd %d"), cmd);
      return FALSE;
    }

  return TRUE;
}

/* Control commands.

   See table B-11 of the openVMS linker manual.  */

static bfd_boolean
etir_ctl (bfd *abfd, int cmd, unsigned char *ptr, int *quarter_relocs)
{
  uquad dummy;
  int psect;

#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_ctl %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (long) ptr);
#endif

  /* No relocation uses CTL commands.  */
  *quarter_relocs = 0;

  switch (cmd)
    {
      /* Det relocation base: pop stack, set image location counter
	 arg: none.  */
    case ETIR_S_C_CTL_SETRB:
      dummy = _bfd_vms_pop (abfd, &psect);
      image_set_ptr (abfd, psect, dummy);
      break;

      /* Augment relocation base: increment image location counter by offset
	 arg: lw	offset value.  */
    case ETIR_S_C_CTL_AUGRB:
      dummy = bfd_getl32 (ptr);
      image_inc_ptr (abfd, dummy);
      break;

      /* Define location: pop index, save location counter under index
	 arg: none.  */
    case ETIR_S_C_CTL_DFLOC:
      dummy = _bfd_vms_pop (abfd, NULL);
      dst_define_location (abfd, dummy);
      break;

      /* Set location: pop index, restore location counter from index
	 arg: none.  */
    case ETIR_S_C_CTL_STLOC:
      dummy = _bfd_vms_pop (abfd, NULL);
      dst_restore_location (abfd, dummy);
      break;

      /* Stack defined location: pop index, push location counter from index
	 arg: none.  */
    case ETIR_S_C_CTL_STKDL:
      dummy = _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, dst_retrieve_location (abfd, dummy), -1);
      break;

    default:
      (*_bfd_error_handler) (_("reserved CTL cmd %d"), cmd);
      return FALSE;
    }

  return TRUE;
}

/* Store conditional commands

   See table B-12 and B-13 of the openVMS linker manual.  */

static bfd_boolean
etir_stc (bfd *abfd, int cmd, unsigned char *ptr ATTRIBUTE_UNUSED,
	  int *quarter_relocs)
{
#if VMS_DEBUG
  _bfd_vms_debug (5, "etir_stc %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (long) ptr);
#endif

  switch (cmd)
    {
      /* 200 Store-conditional Linkage Pair
	 arg: none.  */
    case ETIR_S_C_STC_LP:

      /* 202 Store-conditional Address at global address
	 arg:	lw	linkage index
		cs	global name.  */

    case ETIR_S_C_STC_GBL:

      /* 203 Store-conditional Code Address at global address
	 arg:	lw	linkage index
		cs	procedure name.  */
    case ETIR_S_C_STC_GCA:

      /* 204 Store-conditional Address at psect + offset
	 arg:	lw	linkage index
		lw	psect index
		qw	offset.  */
    case ETIR_S_C_STC_PS:
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
      *quarter_relocs = 0;
      return FALSE;

      /* 201 Store-conditional Linkage Pair with Procedure Signature
	 arg:	lw	linkage index
		cs	procedure name
		by	signature length
		da	signature.  */

    case ETIR_S_C_STC_LP_PSB:
      image_inc_ptr (abfd, (uquad) 16);	/* skip entry,procval */
      *quarter_relocs = 4;
      break;

      /* 205 Store-conditional NOP at address of global
	 arg: none.  */
    case ETIR_S_C_STC_NOP_GBL:
      /* ALPHA_R_NOP */

      /* 207 Store-conditional BSR at global address
	 arg: none.  */

    case ETIR_S_C_STC_BSR_GBL:
      /* ALPHA_R_BSR */

      /* 209 Store-conditional LDA at global address
	 arg: none.  */

    case ETIR_S_C_STC_LDA_GBL:
      /* ALPHA_R_LDA */

      /* 211 Store-conditional BSR or Hint at global address
	 arg: none.  */

    case ETIR_S_C_STC_BOH_GBL:
      *quarter_relocs = 4;
      break;

      /* 213 Store-conditional NOP,BSR or HINT at global address
	 arg: none.  */

    case ETIR_S_C_STC_NBH_GBL:

      /* 206 Store-conditional NOP at pect + offset
	 arg: none.  */

    case ETIR_S_C_STC_NOP_PS:

      /* 208 Store-conditional BSR at pect + offset
	 arg: none.  */

    case ETIR_S_C_STC_BSR_PS:

      /* 210 Store-conditional LDA at psect + offset
	 arg: none.  */

    case ETIR_S_C_STC_LDA_PS:

      /* 212 Store-conditional BSR or Hint at pect + offset
	 arg: none.  */

    case ETIR_S_C_STC_BOH_PS:

      /* 214 Store-conditional NOP, BSR or HINT at psect + offset
	 arg: none.  */
    case ETIR_S_C_STC_NBH_PS:
      (*_bfd_error_handler) ("%s: not supported", cmd_name (cmd));
      *quarter_relocs = 0;
      return FALSE;

    default:
      (*_bfd_error_handler) (_("reserved STC cmd %d"), cmd);
      *quarter_relocs = 0;
      return FALSE;
    }

  return TRUE;
}

static asection *
new_section (bfd * abfd ATTRIBUTE_UNUSED, int idx)
{
  asection *section;
  char sname[16];
  char *name;

#if VMS_DEBUG
  _bfd_vms_debug (5, "new_section %d\n", idx);
#endif
  sprintf (sname, SECTION_NAME_TEMPLATE, idx);

  name = bfd_malloc ((bfd_size_type) strlen (sname) + 1);
  if (name == 0)
    return NULL;
  strcpy (name, sname);

  section = bfd_malloc ((bfd_size_type) sizeof (asection));
  if (section == 0)
    {
#if VMS_DEBUG
      _bfd_vms_debug (6,  "new_section (%s) failed", name);
#endif
      return NULL;
    }

  section->size = 0;
  section->vma = 0;
  section->contents = 0;
  section->name = name;
  section->index = idx;

  return section;
}

static int
alloc_section (bfd * abfd, unsigned int idx)
{
  bfd_size_type amt;

#if VMS_DEBUG
  _bfd_vms_debug (4, "alloc_section %d\n", idx);
#endif

  amt = idx + 1;
  amt *= sizeof (asection *);
  PRIV (sections) = bfd_realloc_or_free (PRIV (sections), amt);
  if (PRIV (sections) == NULL)
    return -1;

  while (PRIV (section_count) <= idx)
    {
      PRIV (sections)[PRIV (section_count)]
	= new_section (abfd, (int) PRIV (section_count));
      if (PRIV (sections)[PRIV (section_count)] == 0)
	return -1;
      PRIV (section_count)++;
    }

  return 0;
}

/* tir_sta

   Vax stack commands.

   Handle sta_xxx commands in tir section,
   ptr points to data area in record.

   See table 7-3 of the VAX/VMS linker manual.  */

static unsigned char *
tir_sta (bfd * abfd, unsigned char *ptr)
{
  int cmd = *ptr++;

#if VMS_DEBUG
  _bfd_vms_debug (5, "tir_sta %d\n", cmd);
#endif

  switch (cmd)
    {
      /* stack */
    case TIR_S_C_STA_GBL:
      /* stack global
	 arg: cs	symbol name

	 stack 32 bit value of symbol (high bits set to 0).  */
      {
	char *name;
	vms_symbol_entry *entry;

	name = _bfd_vms_save_counted_string (ptr);

	entry = _bfd_vms_enter_symbol (abfd, name);
	if (entry == NULL)
	  return NULL;

	_bfd_vms_push (abfd, (uquad) (entry->symbol->value), -1);
	ptr += *ptr + 1;
      }
      break;

    case TIR_S_C_STA_SB:
      /* stack signed byte
	 arg: by	value

	 stack byte value, sign extend to 32 bit.  */
      _bfd_vms_push (abfd, (uquad) *ptr++, -1);
      break;

    case TIR_S_C_STA_SW:
      /* stack signed short word
	 arg: sh	value

	 stack 16 bit value, sign extend to 32 bit.  */
      _bfd_vms_push (abfd, (uquad) bfd_getl16 (ptr), -1);
      ptr += 2;
      break;

    case TIR_S_C_STA_LW:
      /* stack signed longword
	 arg: lw	value

	 stack 32 bit value.  */
      _bfd_vms_push (abfd, (uquad) bfd_getl32 (ptr), -1);
      ptr += 4;
      break;

    case TIR_S_C_STA_PB:
    case TIR_S_C_STA_WPB:
      /* stack psect base plus byte offset (word index)
	 arg: by	section index
		(sh	section index)
		by	signed byte offset.  */
      {
	unsigned long dummy;
	int psect;

	if (cmd == TIR_S_C_STA_PB)
	  psect = *ptr++;
	else
	  {
	    psect = bfd_getl16 (ptr);
	    ptr += 2;
	  }

	if ((unsigned int) psect >= PRIV (section_count))
	  alloc_section (abfd, psect);

	dummy = (long) *ptr++;
	dummy += (PRIV (sections)[psect])->vma;
	_bfd_vms_push (abfd, (uquad) dummy, psect);
      }
      break;

    case TIR_S_C_STA_PW:
    case TIR_S_C_STA_WPW:
      /* stack psect base plus word offset (word index)
	 arg: by	section index
		(sh	section index)
		sh	signed short offset.  */
      {
	unsigned long dummy;
	int psect;

	if (cmd == TIR_S_C_STA_PW)
	  psect = *ptr++;
	else
	  {
	    psect = bfd_getl16 (ptr);
	    ptr += 2;
	  }

	if ((unsigned int) psect >= PRIV (section_count))
	  alloc_section (abfd, psect);

	dummy = bfd_getl16 (ptr); ptr+=2;
	dummy += (PRIV (sections)[psect])->vma;
	_bfd_vms_push (abfd, (uquad) dummy, psect);
      }
      break;

    case TIR_S_C_STA_PL:
    case TIR_S_C_STA_WPL:
      /* stack psect base plus long offset (word index)
	 arg: by	section index
		(sh	section index)
		lw	signed longword offset.	 */
      {
	unsigned long dummy;
	int psect;

	if (cmd == TIR_S_C_STA_PL)
	  psect = *ptr++;
	else
	  {
	    psect = bfd_getl16 (ptr);
	    ptr += 2;
	  }

	if ((unsigned int) psect >= PRIV (section_count))
	  alloc_section (abfd, psect);

	dummy = bfd_getl32 (ptr); ptr += 4;
	dummy += (PRIV (sections)[psect])->vma;
	_bfd_vms_push (abfd, (uquad) dummy, psect);
      }
      break;

    case TIR_S_C_STA_UB:
      /* stack unsigned byte
	 arg: by	value

	 stack byte value.  */
      _bfd_vms_push (abfd, (uquad) *ptr++, -1);
      break;

    case TIR_S_C_STA_UW:
      /* stack unsigned short word
	 arg: sh	value

	 stack 16 bit value.  */
      _bfd_vms_push (abfd, (uquad) bfd_getl16 (ptr), -1);
      ptr += 2;
      break;

    case TIR_S_C_STA_BFI:
      /* stack byte from image
	 arg: none.  */
      /* FALLTHRU  */
    case TIR_S_C_STA_WFI:
      /* stack byte from image
	 arg: none.  */
      /* FALLTHRU */
    case TIR_S_C_STA_LFI:
      /* stack byte from image
	 arg: none.  */
      (*_bfd_error_handler) (_("stack-from-image not implemented"));
      return NULL;

    case TIR_S_C_STA_EPM:
      /* stack entry point mask
	 arg: cs	symbol name

	 stack (unsigned) entry point mask of symbol
	 err if symbol is no entry point.  */
      {
	char *name;
	vms_symbol_entry *entry;

	name = _bfd_vms_save_counted_string (ptr);
	entry = _bfd_vms_enter_symbol (abfd, name);
	if (entry == NULL)
	  return NULL;

	(*_bfd_error_handler) (_("stack-entry-mask not fully implemented"));
	_bfd_vms_push (abfd, (uquad) 0, -1);
	ptr += *ptr + 1;
      }
      break;

    case TIR_S_C_STA_CKARG:
      /* compare procedure argument
	 arg: cs	symbol name
		by	argument index
		da	argument descriptor

	 compare argument descriptor with symbol argument (ARG$V_PASSMECH)
	 and stack TRUE (args match) or FALSE (args dont match) value.  */
      (*_bfd_error_handler) (_("PASSMECH not fully implemented"));
      _bfd_vms_push (abfd, (uquad) 1, -1);
      break;

    case TIR_S_C_STA_LSY:
      /* stack local symbol value
	 arg:	sh	environment index
		cs	symbol name.  */
      {
	int envidx;
	char *name;
	vms_symbol_entry *entry;

	envidx = bfd_getl16 (ptr);
	ptr += 2;
	name = _bfd_vms_save_counted_string (ptr);
	entry = _bfd_vms_enter_symbol (abfd, name);
	if (entry == NULL)
	  return NULL;
	(*_bfd_error_handler) (_("stack-local-symbol not fully implemented"));
	_bfd_vms_push (abfd, (uquad) 0, -1);
	ptr += *ptr + 1;
      }
      break;

    case TIR_S_C_STA_LIT:
      /* stack literal
	 arg:	by	literal index

	 stack literal.  */
      ptr++;
      _bfd_vms_push (abfd, (uquad) 0, -1);
      (*_bfd_error_handler) (_("stack-literal not fully implemented"));
      break;

    case TIR_S_C_STA_LEPM:
      /* stack local symbol entry point mask
	 arg:	sh	environment index
		cs	symbol name

	 stack (unsigned) entry point mask of symbol
	 err if symbol is no entry point.  */
      {
	int envidx;
	char *name;
	vms_symbol_entry *entry;

	envidx = bfd_getl16 (ptr);
	ptr += 2;
	name = _bfd_vms_save_counted_string (ptr);
	entry = _bfd_vms_enter_symbol (abfd, name);
	if (entry == NULL)
	  return NULL;
	(*_bfd_error_handler) (_("stack-local-symbol-entry-point-mask not fully implemented"));
	_bfd_vms_push (abfd, (uquad) 0, -1);
	ptr += *ptr + 1;
      }
      break;

    default:
      (*_bfd_error_handler) (_("reserved STA cmd %d"), ptr[-1]);
      return NULL;
      break;
    }

  return ptr;
}

static const char *
tir_cmd_name (int cmd)
{
  switch (cmd)
    {
    case TIR_S_C_STO_RSB: return "TIR_S_C_STO_RSB";
    case TIR_S_C_STO_RSW: return "TIR_S_C_STO_RSW";
    case TIR_S_C_STO_RL: return "TIR_S_C_STO_RL";
    case TIR_S_C_STO_VPS: return "TIR_S_C_STO_VPS";
    case TIR_S_C_STO_USB: return "TIR_S_C_STO_USB";
    case TIR_S_C_STO_USW: return "TIR_S_C_STO_USW";
    case TIR_S_C_STO_RUB: return "TIR_S_C_STO_RUB";
    case TIR_S_C_STO_RUW: return "TIR_S_C_STO_RUW";
    case TIR_S_C_STO_PIRR: return "TIR_S_C_STO_PIRR";
    case TIR_S_C_OPR_INSV: return "TIR_S_C_OPR_INSV";
    case TIR_S_C_OPR_DFLIT: return "TIR_S_C_OPR_DFLIT";
    case TIR_S_C_OPR_REDEF: return "TIR_S_C_OPR_REDEF";
    case TIR_S_C_OPR_ROT: return "TIR_S_C_OPR_ROT";
    case TIR_S_C_OPR_USH: return "TIR_S_C_OPR_USH";
    case TIR_S_C_OPR_ASH: return "TIR_S_C_OPR_ASH";
    case TIR_S_C_CTL_DFLOC: return "TIR_S_C_CTL_DFLOC";
    case TIR_S_C_CTL_STLOC: return "TIR_S_C_CTL_STLOC";
    case TIR_S_C_CTL_STKDL: return "TIR_S_C_CTL_STKDL";

    default:
      /* These strings have not been added yet.  */
      abort ();
    }
}

/* tir_sto

   vax store commands

   handle sto_xxx commands in tir section
   ptr points to data area in record

   See table 7-4 of the VAX/VMS linker manual.  */

static unsigned char *
tir_sto (bfd * abfd, unsigned char *ptr)
{
  unsigned long dummy;
  int size;
  int psect;

#if VMS_DEBUG
  _bfd_vms_debug (5, "tir_sto %d\n", *ptr);
#endif

  switch (*ptr++)
    {
    case TIR_S_C_STO_SB:
      /* Store signed byte: pop stack, write byte
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_b (abfd, dummy & 0xff);	/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_SW:
      /* Store signed word: pop stack, write word
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_w (abfd, dummy & 0xffff);	/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_LW:
      /* Store longword: pop stack, write longword
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_l (abfd, dummy & 0xffffffff);	/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_BD:
      /* Store byte displaced: pop stack, sub lc+1, write byte
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      dummy -= ((PRIV (sections)[psect])->vma + 1);
      image_write_b (abfd, dummy & 0xff);/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_WD:
      /* Store word displaced: pop stack, sub lc+2, write word
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      dummy -= ((PRIV (sections)[psect])->vma + 2);
      image_write_w (abfd, dummy & 0xffff);/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_LD:
      /* Store long displaced: pop stack, sub lc+4, write long
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      dummy -= ((PRIV (sections)[psect])->vma + 4);
      image_write_l (abfd, dummy & 0xffffffff);/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_LI:
      /* Store short literal: pop stack, write byte
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_b (abfd, dummy & 0xff);/* FIXME: check top bits */
      break;

    case TIR_S_C_STO_PIDR:
      /* Store position independent data reference: pop stack, write longword
	 arg: none.
	 FIXME: incomplete !  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_l (abfd, dummy & 0xffffffff);
      break;

    case TIR_S_C_STO_PICR:
      /* Store position independent code reference: pop stack, write longword
	 arg: none.
	 FIXME: incomplete !  */
      dummy = _bfd_vms_pop (abfd, &psect);
      image_write_b (abfd, 0x9f);
      image_write_l (abfd, dummy & 0xffffffff);
      break;

    case TIR_S_C_STO_RIVB:
      /* Store repeated immediate variable bytes
	 1-byte count n field followed by n bytes of data
	 pop stack, write n bytes <stack> times.  */
      size = *ptr++;
      dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
      while (dummy-- > 0L)
	image_dump (abfd, ptr, size, 0);
      ptr += size;
      break;

    case TIR_S_C_STO_B:
      /* Store byte from top longword.  */
      dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
      image_write_b (abfd, dummy & 0xff);
      break;

    case TIR_S_C_STO_W:
      /* Store word from top longword.  */
      dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
      image_write_w (abfd, dummy & 0xffff);
      break;

    case TIR_S_C_STO_RB:
      /* Store repeated byte from top longword.  */
      size = (unsigned long) _bfd_vms_pop (abfd, NULL);
      dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
      while (size-- > 0)
	image_write_b (abfd, dummy & 0xff);
      break;

    case TIR_S_C_STO_RW:
      /* Store repeated word from top longword.  */
      size = (unsigned long) _bfd_vms_pop (abfd, NULL);
      dummy = (unsigned long) _bfd_vms_pop (abfd, NULL);
      while (size-- > 0)
	image_write_w (abfd, dummy & 0xffff);
      break;

    case TIR_S_C_STO_RSB:
    case TIR_S_C_STO_RSW:
    case TIR_S_C_STO_RL:
    case TIR_S_C_STO_VPS:
    case TIR_S_C_STO_USB:
    case TIR_S_C_STO_USW:
    case TIR_S_C_STO_RUB:
    case TIR_S_C_STO_RUW:
    case TIR_S_C_STO_PIRR:
      (*_bfd_error_handler) (_("%s: not implemented"), tir_cmd_name (ptr[-1]));
      break;

    default:
      (*_bfd_error_handler) (_("reserved STO cmd %d"), ptr[-1]);
      break;
    }

  return ptr;
}

/* Stack operator commands
   All 32 bit signed arithmetic
   All word just like a stack calculator
   Arguments are popped from stack, results are pushed on stack

   See table 7-5 of the VAX/VMS linker manual.  */

static unsigned char *
tir_opr (bfd * abfd, unsigned char *ptr)
{
  long op1, op2;

#if VMS_DEBUG
  _bfd_vms_debug (5, "tir_opr %d\n", *ptr);
#endif

  /* Operation.  */
  switch (*ptr++)
    {
    case TIR_S_C_OPR_NOP: /* No-op.  */
      break;

    case TIR_S_C_OPR_ADD: /* Add.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 + op2), -1);
      break;

    case TIR_S_C_OPR_SUB: /* Subtract.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op2 - op1), -1);
      break;

    case TIR_S_C_OPR_MUL: /* Multiply.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 * op2), -1);
      break;

    case TIR_S_C_OPR_DIV: /* Divide.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      if (op2 == 0)
	_bfd_vms_push (abfd, (uquad) 0, -1);
      else
	_bfd_vms_push (abfd, (uquad) (op2 / op1), -1);
      break;

    case TIR_S_C_OPR_AND: /* Logical AND.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 & op2), -1);
      break;

    case TIR_S_C_OPR_IOR: /* Logical inclusive OR.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 | op2), -1);
      break;

    case TIR_S_C_OPR_EOR: /* Logical exclusive OR.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 ^ op2), -1);
      break;

    case TIR_S_C_OPR_NEG: /* Negate.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (-op1), -1);
      break;

    case TIR_S_C_OPR_COM: /* Complement.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      _bfd_vms_push (abfd, (uquad) (op1 ^ -1L), -1);
      break;

    case TIR_S_C_OPR_INSV: /* Insert field.  */
      (void) _bfd_vms_pop (abfd, NULL);
      (*_bfd_error_handler)  (_("%s: not fully implemented"),
			      tir_cmd_name (ptr[-1]));
      break;

    case TIR_S_C_OPR_ASH: /* Arithmetic shift.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      if (HIGHBIT (op1))	/* Shift right.  */
	op2 >>= op1;
      else			/* Shift left.  */
	op2 <<= op1;
      _bfd_vms_push (abfd, (uquad) op2, -1);
      (*_bfd_error_handler)  (_("%s: not fully implemented"),
			      tir_cmd_name (ptr[-1]));
      break;

    case TIR_S_C_OPR_USH: /* Unsigned shift.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      if (HIGHBIT (op1))	/* Shift right.  */
	op2 >>= op1;
      else			/* Shift left.  */
	op2 <<= op1;
      _bfd_vms_push (abfd, (uquad) op2, -1);
      (*_bfd_error_handler)  (_("%s: not fully implemented"),
			      tir_cmd_name (ptr[-1]));
      break;

    case TIR_S_C_OPR_ROT: /* Rotate.  */
      op1 = (long) _bfd_vms_pop (abfd, NULL);
      op2 = (long) _bfd_vms_pop (abfd, NULL);
      if (HIGHBIT (0))	/* Shift right.  */
	op2 >>= op1;
      else		/* Shift left.  */
	op2 <<= op1;
      _bfd_vms_push (abfd, (uquad) op2, -1);
      (*_bfd_error_handler)  (_("%s: not fully implemented"),
			      tir_cmd_name (ptr[-1]));
      break;

    case TIR_S_C_OPR_SEL: /* Select.  */
      if ((long) _bfd_vms_pop (abfd, NULL) & 0x01L)
	(void) _bfd_vms_pop (abfd, NULL);
      else
	{
	  op1 = (long) _bfd_vms_pop (abfd, NULL);
	  (void) _bfd_vms_pop (abfd, NULL);
	  _bfd_vms_push (abfd, (uquad) op1, -1);
	}
      break;

    case TIR_S_C_OPR_REDEF: /* Redefine symbol to current location.  */
    case TIR_S_C_OPR_DFLIT: /* Define a literal.  */
      (*_bfd_error_handler) (_("%s: not supported"),
			     tir_cmd_name (ptr[-1]));
      break;

    default:
      (*_bfd_error_handler) (_("reserved OPR cmd %d"), ptr[-1]);
      break;
    }

  return ptr;
}

/* Control commands

   See table 7-6 of the VAX/VMS linker manual.  */

static unsigned char *
tir_ctl (bfd * abfd, unsigned char *ptr)
{
  unsigned long dummy;
  int psect;

#if VMS_DEBUG
  _bfd_vms_debug (5, "tir_ctl %d\n", *ptr);
#endif

  switch (*ptr++)
    {
    case TIR_S_C_CTL_SETRB:
      /* Set relocation base: pop stack, set image location counter
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      if ((unsigned int) psect >= PRIV (section_count))
	alloc_section (abfd, psect);
      image_set_ptr (abfd, psect, (uquad) dummy);
      break;

    case TIR_S_C_CTL_AUGRB:
      /* Augment relocation base: increment image location counter by offset
	 arg: lw	offset value.  */
      dummy = bfd_getl32 (ptr);
      image_inc_ptr (abfd, (uquad) dummy);
      break;

    case TIR_S_C_CTL_DFLOC:
      /* Define location: pop index, save location counter under index
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, NULL);
      (*_bfd_error_handler) (_("%s: not fully implemented"),
			     tir_cmd_name (ptr[-1]));
      break;

    case TIR_S_C_CTL_STLOC:
      /* Set location: pop index, restore location counter from index
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      (*_bfd_error_handler) (_("%s: not fully implemented"),
			     tir_cmd_name (ptr[-1]));
      break;

    case TIR_S_C_CTL_STKDL:
      /* Stack defined location: pop index, push location counter from index
	 arg: none.  */
      dummy = _bfd_vms_pop (abfd, &psect);
      (*_bfd_error_handler) (_("%s: not fully implemented"),
			     tir_cmd_name (ptr[-1]));
      break;

    default:
      (*_bfd_error_handler) (_("reserved CTL cmd %d"), ptr[-1]);
      break;
    }
  return ptr;
}

/* Handle command from TIR section.  */

static unsigned char *
tir_cmd (bfd * abfd, unsigned char *ptr)
{
  static const struct
  {
    int mincod;
    int maxcod;
    unsigned char * (*explain) (bfd *, unsigned char *);
  }
  tir_table[] =
  {
    { 0,		 TIR_S_C_MAXSTACOD, tir_sta },
    { TIR_S_C_MINSTOCOD, TIR_S_C_MAXSTOCOD, tir_sto },
    { TIR_S_C_MINOPRCOD, TIR_S_C_MAXOPRCOD, tir_opr },
    { TIR_S_C_MINCTLCOD, TIR_S_C_MAXCTLCOD, tir_ctl },
    { -1, -1, NULL }
  };
  int i = 0;

#if VMS_DEBUG
  _bfd_vms_debug (4, "tir_cmd %d/%x\n", *ptr, *ptr);
  _bfd_hexdump (8, ptr, 16, (long) ptr);
#endif

  if (*ptr & 0x80)
    {
      /* Store immediate.  */
      i = 128 - (*ptr++ & 0x7f);
      image_dump (abfd, ptr, i, 0);
      ptr += i;
    }
  else
    {
      while (tir_table[i].mincod >= 0)
	{
	  if ( (tir_table[i].mincod <= *ptr)
	       && (*ptr <= tir_table[i].maxcod))
	    {
	      ptr = tir_table[i].explain (abfd, ptr);
	      break;
	    }
	  i++;
	}
      if (tir_table[i].mincod < 0)
	{
	  (*_bfd_error_handler) (_("obj code %d not found"), *ptr);
	  ptr = 0;
	}
    }

  return ptr;
}

/* Handle command from ETIR section.  */

static int
etir_cmd (bfd *abfd, int cmd, unsigned char *ptr, int *quarter_relocs)
{
  static const struct
  {
    int mincod;
    int maxcod;
    bfd_boolean (*explain) (bfd *, int, unsigned char *, int *);
  }
  etir_table[] =
  {
    { ETIR_S_C_MINSTACOD, ETIR_S_C_MAXSTACOD, etir_sta },
    { ETIR_S_C_MINSTOCOD, ETIR_S_C_MAXSTOCOD, etir_sto },
    { ETIR_S_C_MINOPRCOD, ETIR_S_C_MAXOPRCOD, etir_opr },
    { ETIR_S_C_MINCTLCOD, ETIR_S_C_MAXCTLCOD, etir_ctl },
    { ETIR_S_C_MINSTCCOD, ETIR_S_C_MAXSTCCOD, etir_stc },
    { -1, -1, NULL }
  };

  int i = 0;

#if VMS_DEBUG
  _bfd_vms_debug (4, "etir_cmd: %s(%d)\n", cmd_name (cmd), cmd);
  _bfd_hexdump (8, ptr, 16, (long) ptr);
#endif

  while (etir_table[i].mincod >= 0)
    {
      if ( (etir_table[i].mincod <= cmd)
	   && (cmd <= etir_table[i].maxcod))
	{
	  if (!etir_table[i].explain (abfd, cmd, ptr, quarter_relocs))
	    return -1;
	  break;
	}
      i++;
    }

#if VMS_DEBUG
  _bfd_vms_debug (4, "etir_cmd: result = 0\n");
#endif
  return 0;
}

/* Text Information and Relocation Records (OBJ$C_TIR)
   handle tir record.  */

static int
analyze_tir (bfd * abfd, unsigned char *ptr, unsigned int length)
{
  unsigned char *maxptr;

#if VMS_DEBUG
  _bfd_vms_debug (3, "analyze_tir: %d bytes\n", length);
#endif

  maxptr = ptr + length;

  while (ptr < maxptr)
    {
      ptr = tir_cmd (abfd, ptr);
      if (ptr == 0)
	return -1;
    }

  return 0;
}

/* Text Information and Relocation Records (EOBJ$C_ETIR)
   handle etir record.  */

static int
analyze_etir (bfd * abfd, unsigned char *ptr, unsigned int length)
{
  unsigned char *maxptr = ptr + length;
  /* Relocations are made of 1, 2 or 4 ETIR commands.
     We therefore count them using quarters.  */
  int quarter_relocs = 0;
  int result = 0;

#if VMS_DEBUG
  _bfd_vms_debug (3, "analyze_etir: %d bytes\n", length);
#endif

  while (ptr < maxptr)
    {
      int cmd = bfd_getl16 (ptr);
      int cmd_length = bfd_getl16 (ptr + 2);
      result = etir_cmd (abfd, cmd, ptr + 4, &quarter_relocs);
      if (result != 0)
	break;

      /* If we have a relocation, we record its length to size
	 future buffers and bump the reloc count of the section.  */
      if (quarter_relocs)
	{
	  vms_section_data (PRIV (image_section))->reloc_size += cmd_length;
	  abfd->flags |= HAS_RELOC;

	  if (quarter_relocs == 4)
	    {
	      PRIV (image_section)->reloc_count++;

#if VMS_DEBUG
	      _bfd_vms_debug (4, "-> reloc %d at 0x%x\n",
			      PRIV (image_section)->reloc_count-1,
			      ptr - (maxptr - length));
#endif

	      quarter_relocs = 0;
	    }
	  else if (quarter_relocs > 4)
	    {

#if VMS_DEBUG
	      _bfd_vms_debug (4, "Reloc count error (%d) in section %s\n",
			      PRIV (image_section)->reloc_count,
			      PRIV (image_section)->name);
#endif

	      quarter_relocs = 0;
	    }
	}

      /* If we have a Store Immediate, we reserve space for the
	 count argument.  */
      else if (cmd == ETIR_S_C_STO_IMM)
        vms_section_data (PRIV (image_section))->reloc_size
	  += ETIR_S_C_HEADER_SIZE + 4;

      ptr += cmd_length;
    }

#if VMS_DEBUG
  _bfd_vms_debug (3, "analyze_etir: result = %d\n", result);
#endif

  return result;
}

/* Process ETIR record
   Return 0 on success, -1 on error.  */

int
_bfd_vms_slurp_tir (bfd * abfd, int objtype)
{
  int result;

#if VMS_DEBUG
  _bfd_vms_debug (2, "TIR/ETIR\n");
#endif

  switch (objtype)
    {
    case EOBJ_S_C_ETIR:
      PRIV (vms_rec) += ETIR_S_C_HEADER_SIZE;
      PRIV (rec_size) -= ETIR_S_C_HEADER_SIZE;
      result = analyze_etir (abfd, PRIV (vms_rec), (unsigned) PRIV (rec_size));
      break;
    case OBJ_S_C_TIR:
      PRIV (vms_rec) += 1;	/* Skip type.  */
      PRIV (rec_size) -= 1;
      result = analyze_tir (abfd, PRIV (vms_rec), (unsigned) PRIV (rec_size));
      break;
    default:
      result = -1;
      break;
    }

  return result;
}

 /* Slurp relocs from ETIR sections and (temporarily) save them
    in the per-section reloc buffer.  */

int
_bfd_vms_slurp_relocs (bfd *abfd)
{
  struct vms_section_data_struct *vsd;
  unsigned char *begin = PRIV (vms_rec) + 4;
  unsigned char *end = PRIV (vms_rec) + PRIV (rec_size);
  unsigned char *ptr;
  int cmd, length, slurped_length;

#if VMS_DEBUG
  _bfd_vms_debug (3, "_bfd_vms_slurp_relocs: %d bytes\n", PRIV (rec_size));
#endif

  for (ptr = begin; ptr < end; ptr += length)
    {
      cmd = bfd_getl16 (ptr);
      length = bfd_getl16 (ptr + 2);
      slurped_length = length;

      switch (cmd)
	{
	case ETIR_S_C_STA_PQ: /* ALPHA_R_REF{LONG|QUAD}, others part 1 */
	  /* This one is special as it is both part of the section header
	     and of the ALPHA_R_REFLONG and ALPHA_R_REFQUAD relocations.  */
	  if (bfd_getl16 (ptr + length) == ETIR_S_C_CTL_SETRB)
	    {
	      int psect = bfd_getl32 (ptr + ETIR_S_C_HEADER_SIZE);
	      PRIV (image_section) = PRIV (sections)[psect];
	      continue;
	    }

	case ETIR_S_C_STA_GBL: /* ALPHA_R_REFLONG und_section, step 1 */
			       /* ALPHA_R_REFQUAD und_section, step 1 */
	  break;

	case ETIR_S_C_STA_LW: /* ALPHA_R_REFLONG und_section, step 2 */
			      /* ALPHA_R_REFLONG abs_section, step 1 */
	  /* This one is special as it is both part of the section header
	     and of the ALPHA_R_REFLONG relocation.  */
	  if (bfd_getl16 (ptr + length) == ETIR_S_C_CTL_DFLOC)
	    {
	      PRIV (image_section) = PRIV (dst_section);
	      continue;
	    }

	case ETIR_S_C_STA_QW: /* ALPHA_R_REFQUAD und_section, step 2 */
			      /* ALPHA_R_REFQUAD abs_section, step 1 */

	case ETIR_S_C_STO_LW: /* ALPHA_R_REFLONG und_section, step 4 */
			      /* ALPHA_R_REFLONG abs_section, step 2 */
			      /* ALPHA_R_REFLONG others, step 2 */

	case ETIR_S_C_STO_QW: /* ALPHA_R_REFQUAD und_section, step 4 */
			      /* ALPHA_R_REFQUAD abs_section, step 2 */

	case ETIR_S_C_STO_OFF: /* ALPHA_R_REFQUAD others, step 2 */

	case ETIR_S_C_OPR_ADD: /* ALPHA_R_REFLONG und_section, step 3 */
			       /* ALPHA_R_REFQUAD und_section, step 3 */

	case ETIR_S_C_STO_CA:      /* ALPHA_R_CODEADDR */
	case ETIR_S_C_STO_GBL:     /* ALPHA_R_REFQUAD und_section */
	case ETIR_S_C_STO_GBL_LW:  /* ALPHA_R_REFLONG und_section */
	case ETIR_S_C_STC_LP_PSB:  /* ALPHA_R_LINKAGE */
	case ETIR_S_C_STC_NOP_GBL: /* ALPHA_R_NOP */
	case ETIR_S_C_STC_BSR_GBL: /* ALPHA_R_BSR */
	case ETIR_S_C_STC_LDA_GBL: /* ALPHA_R_LDA */
	case ETIR_S_C_STC_BOH_GBL: /* ALPHA_R_BOH */
	  break;

	case ETIR_S_C_STO_IMM:
	  if (PRIV (image_section)->reloc_count == 0)
	    continue;
	  /* This is not a relocation, but we nevertheless slurp the
	     count argument.  We'll use it to compute the addresses
	     of the relocations.  */
	  slurped_length = ETIR_S_C_HEADER_SIZE + 4;
	  break;

	default:
	  continue;
	}

      vsd = vms_section_data (PRIV (image_section));
      memcpy (vsd->reloc_stream + vsd->reloc_offset, ptr, slurped_length);
      vsd->reloc_offset += slurped_length;
      if (vsd->reloc_offset > vsd->reloc_size)
        {
	  (*_bfd_error_handler) (_("Reloc size error in section %s"),
			         PRIV (image_section)->name);
	  return -1;
	}
    }

#if VMS_DEBUG
  _bfd_vms_debug (3, "_bfd_vms_slurp_relocs: result = 0\n");
#endif

  return 0;
}

/* Decode relocs from the reloc buffer of the specified section
   and internalize them in the specified buffer.  */

int
_bfd_vms_decode_relocs (bfd *abfd, arelent *relocs, asection *section,
			asymbol **symbols ATTRIBUTE_UNUSED)
{
  int saved_cmd, saved_sym_offset, saved_sec_offset, saved_addend_offset;
  int cmd, sym_offset, sec_offset, address_offset, addend_offset;
  struct vms_section_data_struct *vsd = vms_section_data (section);
  bfd_reloc_code_real_type reloc_code;
  vms_symbol_entry *entry;
  bfd_vma vaddr = 0;
  unsigned char *begin = vsd->reloc_stream;
  unsigned char *end = vsd->reloc_stream + vsd->reloc_size;
  unsigned char *ptr, *arg_ptr;
  const char *name;
  int length;

#if VMS_DEBUG
  _bfd_vms_debug (3, "_bfd_vms_decode_relocs: %d bytes\n", vsd->reloc_size);
#endif

  #define PUSH_CMD()					\
    {							\
      saved_cmd = cmd;					\
      saved_sym_offset = sym_offset - length;		\
      saved_sec_offset = sec_offset - length;		\
      saved_addend_offset = addend_offset - length;	\
      continue;						\
    }

  #define POP_CMD()					\
    {							\
      cmd = saved_cmd;					\
      saved_cmd = ETIR_S_C_MAXSTCCOD + 1;		\
      sym_offset = saved_sym_offset;			\
      sec_offset = saved_sec_offset;			\
      addend_offset= saved_addend_offset;		\
    }

  #define CMD_PUSHED (saved_cmd != ETIR_S_C_MAXSTCCOD + 1)

  #define NO_OFFSET -128

  saved_cmd = ETIR_S_C_MAXSTCCOD + 1;
  saved_sym_offset = NO_OFFSET;
  saved_sec_offset = NO_OFFSET;
  saved_addend_offset = NO_OFFSET;

  for (ptr = begin; ptr < end; ptr += length)
    {
      cmd = bfd_getl16 (ptr);
      length = bfd_getl16 (ptr + 2);

      arg_ptr = ptr + ETIR_S_C_HEADER_SIZE;
      sym_offset = NO_OFFSET;
      sec_offset = NO_OFFSET;
      address_offset = NO_OFFSET;
      addend_offset = NO_OFFSET;

      switch (cmd)
	{
	case ETIR_S_C_STA_GBL: /* ALPHA_R_REFLONG und_section, step 1 */
			       /* ALPHA_R_REFQUAD und_section, step 1 */
	  sym_offset = 0;
	  PUSH_CMD ()

	case ETIR_S_C_STA_PQ: /* ALPHA_R_REF{LONG|QUAD}, others part 1 */
	  sec_offset = 0;
	  addend_offset = 4;
	  PUSH_CMD ()

	case ETIR_S_C_STA_LW: /* ALPHA_R_REFLONG abs_section, step 1 */
			      /* ALPHA_R_REFLONG und_section, step 2 */
	  if (CMD_PUSHED)
	    {
	      POP_CMD ()
	      if (cmd != ETIR_S_C_STA_GBL)
		{
		  (*_bfd_error_handler) (_("Unknown reloc %s + %s"),
					 cmd_name (cmd),
					 cmd_name (ETIR_S_C_STA_LW));
		  return 0;
		}
	      cmd = ETIR_S_C_STA_LW;
	    }
	  addend_offset = 0;
	  PUSH_CMD ()

	case ETIR_S_C_STA_QW: /* ALPHA_R_REFQUAD abs_section, step 1 */
			      /* ALPHA_R_REFQUAD und_section, step 2 */
	  if (CMD_PUSHED)
	    {
	      POP_CMD ()
	      if (cmd != ETIR_S_C_STA_GBL)
		{
		  (*_bfd_error_handler) (_("Unknown reloc %s + %s"),
					 cmd_name (cmd),
					 cmd_name (ETIR_S_C_STA_QW));
		  return 0;
		}
	      cmd = ETIR_S_C_STA_QW;
	    }
	  addend_offset = 0;
	  PUSH_CMD ()

	case ETIR_S_C_STO_LW: /* ALPHA_R_REFLONG und_section, step 4 */
			      /* ALPHA_R_REFLONG abs_section, step 2 */
			      /* ALPHA_R_REFLONG others, step 2 */
	  POP_CMD ()
	  if (cmd != ETIR_S_C_OPR_ADD
	      && cmd != ETIR_S_C_STA_LW
	      && cmd != ETIR_S_C_STA_PQ)
	    {
	      (*_bfd_error_handler) (_("Unknown reloc %s + %s"),
	        cmd_name (cmd), cmd_name (ETIR_S_C_STO_LW));
	      return 0;
	    }
	  reloc_code = BFD_RELOC_32;
	  break;

	case ETIR_S_C_STO_QW: /* ALPHA_R_REFQUAD und_section, step 4 */
			      /* ALPHA_R_REFQUAD abs_section, step 2 */
	  POP_CMD ()
	  if (cmd != ETIR_S_C_OPR_ADD && cmd != ETIR_S_C_STA_QW)
	    {
	      (*_bfd_error_handler) (_("Unknown reloc %s + %s"),
	        cmd_name (cmd), cmd_name (ETIR_S_C_STO_QW));
	      return 0;
	    }
	  reloc_code = BFD_RELOC_64;
	  break;

	case ETIR_S_C_STO_OFF: /* ALPHA_R_REFQUAD others, step 2 */
	  POP_CMD ()
	  if (cmd != ETIR_S_C_STA_PQ)
	    {
	      (*_bfd_error_handler) (_("Unknown reloc %s + %s"),
	        cmd_name (cmd), cmd_name (ETIR_S_C_STO_OFF));
	      return 0;
	    }
	  reloc_code = BFD_RELOC_64;
	  break;

	case ETIR_S_C_OPR_ADD: /* ALPHA_R_REFLONG und_section, step 3 */
			       /* ALPHA_R_REFQUAD und_section, step 3 */
	  POP_CMD ()
	  if (cmd != ETIR_S_C_STA_LW && cmd != ETIR_S_C_STA_QW)
	    {
	      (*_bfd_error_handler) (_("Unknown reloc %s + %s"),
	        cmd_name (cmd), cmd_name (ETIR_S_C_OPR_ADD));
	      return 0;
	    }
	  cmd = ETIR_S_C_OPR_ADD;
	  PUSH_CMD ()

	case ETIR_S_C_STO_CA: /* ALPHA_R_CODEADDR */
	  reloc_code = BFD_RELOC_ALPHA_CODEADDR;
	  sym_offset = 0;
	  break;

	case ETIR_S_C_STO_GBL: /* ALPHA_R_REFQUAD und_section */
	  reloc_code = BFD_RELOC_64;
	  sym_offset = 0;
	  break;

	case ETIR_S_C_STO_GBL_LW: /* ALPHA_R_REFLONG und_section */
	  reloc_code = BFD_RELOC_32;
	  sym_offset = 0;
	  break;

	case ETIR_S_C_STC_LP_PSB: /* ALPHA_R_LINKAGE */
	  reloc_code = BFD_RELOC_ALPHA_LINKAGE;
	  sym_offset = 4;
	  break;

	case ETIR_S_C_STC_NOP_GBL: /* ALPHA_R_NOP */
	  reloc_code = BFD_RELOC_ALPHA_NOP;
	  goto call_reloc;

	case ETIR_S_C_STC_BSR_GBL: /* ALPHA_R_BSR */
	  reloc_code = BFD_RELOC_ALPHA_BSR;
	  goto call_reloc;

	case ETIR_S_C_STC_LDA_GBL: /* ALPHA_R_LDA */
	  reloc_code = BFD_RELOC_ALPHA_LDA;
	  goto call_reloc;

	case ETIR_S_C_STC_BOH_GBL: /* ALPHA_R_BOH */
	  reloc_code = BFD_RELOC_ALPHA_BOH;
	  goto call_reloc;

	call_reloc:
	  sym_offset = 32;
	  address_offset = 8;
	  addend_offset = 24;
	  break;

	case ETIR_S_C_STO_IMM:
	  vaddr += bfd_getl32 (arg_ptr);
	  length = ETIR_S_C_HEADER_SIZE + 4;
	  continue;

	default:
	  continue;
	}

      relocs->howto = bfd_reloc_type_lookup (abfd, reloc_code);

      if (sym_offset > NO_OFFSET)
	{
	  name = _bfd_vms_save_counted_string (arg_ptr + sym_offset);
	  entry = (vms_symbol_entry *)
	    bfd_hash_lookup (PRIV (vms_symbol_table), name, FALSE, FALSE);
	  if (entry == NULL)
	    {
	      (*_bfd_error_handler) (_("Unknown symbol %s in command %s"),
				     name, cmd_name (cmd));
	      relocs->sym_ptr_ptr = NULL;
	    }
	  else
	    /* ??? This is a hack.  We should point in 'symbols'.  */
	    relocs->sym_ptr_ptr = &entry->symbol;
	}
      else if (sec_offset > NO_OFFSET)
	relocs->sym_ptr_ptr
	  = PRIV (sections)[bfd_getl32 (arg_ptr + sec_offset)]->symbol_ptr_ptr;
      else
	relocs->sym_ptr_ptr = NULL;

      if (address_offset > NO_OFFSET)
	relocs->address = bfd_getl64 (arg_ptr + address_offset);
      else
	relocs->address = vaddr;

      if (addend_offset > NO_OFFSET)
	relocs->addend = bfd_getl64 (arg_ptr + addend_offset);
      else
	relocs->addend = 0;

      vaddr += bfd_get_reloc_size (relocs->howto);
      relocs++;     
    }

  #undef PUSH_CMD
  #undef POP_CMD
  #undef NO_OFFSET

#if VMS_DEBUG
  _bfd_vms_debug (3, "_bfd_vms_decode_relocs: result = 0\n");
#endif

  return 0;
}

/* Process LNK record
   Return 0 on success, -1 on error

   Not implemented yet.  */

int
_bfd_vms_slurp_lnk (bfd * abfd ATTRIBUTE_UNUSED,
		    int objtype ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "LNK\n");
#endif

  return 0;
}

/* WRITE ETIR SECTION

   This is still under construction and therefore not documented.  */

static void start_etir_record (bfd *abfd, int sec_index, uquad offset,
			       bfd_boolean justoffset);
static void start_first_etbt_record (bfd *abfd);
static void start_another_etbt_record (bfd *abfd);
static void sto_imm (bfd *abfd, bfd_size_type, unsigned char *, bfd_vma vaddr,
		     int sec_index, const char *name);
static void end_etir_record (bfd *abfd);
static void etir_output_check (bfd *abfd, asection *section, bfd_vma vaddr,
			       int checklen);

/* Start ETIR record for section #index at virtual addr offset.  */

static void
start_etir_record (bfd * abfd, int sec_index, uquad offset, bfd_boolean justoffset)
{
  if (!justoffset)
    {
      /* One ETIR per section.  */
      _bfd_vms_output_begin (abfd, EOBJ_S_C_ETIR, -1);
      _bfd_vms_output_push (abfd);
    }

  /* Push start offset.  */
  _bfd_vms_output_begin (abfd, ETIR_S_C_STA_PQ, -1);
  _bfd_vms_output_long (abfd, (unsigned long) sec_index);
  _bfd_vms_output_quad (abfd, (uquad) offset);
  _bfd_vms_output_flush (abfd);

  /* Start = pop ().  */
  _bfd_vms_output_begin (abfd, ETIR_S_C_CTL_SETRB, -1);
  _bfd_vms_output_flush (abfd);
}

static void
end_etir_record (bfd * abfd)
{
  _bfd_vms_output_pop (abfd);
  _bfd_vms_output_end (abfd);
}

/* Output a STO_IMM command for SSIZE bytes of data from CPR at virtual
   address VADDR in section specified by SEC_INDEX and NAME.  */

static void
sto_imm (bfd *abfd, bfd_size_type ssize, unsigned char *cptr, bfd_vma vaddr,
	 int sec_index, const char *name)
{
  bfd_size_type size;

#if VMS_DEBUG
  _bfd_vms_debug (8, "sto_imm %d bytes\n", ssize);
  _bfd_hexdump (9, cptr, (int) ssize, (int) vaddr);
#endif

  while (ssize > 0)
    {
      /* Try all the rest.  */
      size = ssize;

      if (_bfd_vms_output_check (abfd, size) < 0)
	{
	  /* Doesn't fit, split !  */
	  end_etir_record (abfd);

	  if (name [0] && name[1] == 'v' && !strcmp (name, ".vmsdebug"))
	    start_another_etbt_record (abfd);
	  else
	    start_etir_record (abfd, sec_index, vaddr, FALSE);

	  size = _bfd_vms_output_check (abfd, 0);	/* get max size */
	  if (size > ssize)			/* more than what's left ? */
	    size = ssize;
	}

      _bfd_vms_output_begin (abfd, ETIR_S_C_STO_IMM, -1);
      _bfd_vms_output_long (abfd, (unsigned long) (size));
      _bfd_vms_output_dump (abfd, cptr, size);
      _bfd_vms_output_flush (abfd);

#if VMS_DEBUG
      _bfd_vms_debug (10, "dumped %d bytes\n", size);
      _bfd_hexdump (10, cptr, (int) size, (int) vaddr);
#endif

      vaddr += size;
      cptr += size;
      ssize -= size;
    }
}

/* Start ETBT record for section #index at virtual addr offset.  */

static void
start_first_etbt_record (bfd *abfd)
{
  _bfd_vms_output_begin (abfd, EOBJ_S_C_ETBT, -1);
  _bfd_vms_output_push (abfd);

  _bfd_vms_output_begin (abfd, ETIR_S_C_STA_LW, -1);	/* push start offset */
  _bfd_vms_output_long (abfd, (unsigned long) 0);
  _bfd_vms_output_flush (abfd);

  _bfd_vms_output_begin (abfd, ETIR_S_C_CTL_DFLOC, -1);	/* start = pop() */
  _bfd_vms_output_flush (abfd);
}

static void
start_another_etbt_record (bfd *abfd)
{
  _bfd_vms_output_begin (abfd, EOBJ_S_C_ETBT, -1);
  _bfd_vms_output_push (abfd);
}

static void
etir_output_check (bfd *abfd, asection *section, bfd_vma vaddr, int checklen)
{
  if (_bfd_vms_output_check (abfd, checklen) < 0)
    {
      end_etir_record (abfd);
      if (section->name[0] && section->name[1] == 'v'
	  && !strcmp (section->name, ".vmsdebug"))
	start_another_etbt_record (abfd);
      else
	start_etir_record (abfd, section->index, vaddr, FALSE);
    }
}

/* Return whether RELOC must be deferred till the end.  */

static int
defer_reloc_p (arelent *reloc)
{
  switch (reloc->howto->type)
    {
    case ALPHA_R_NOP:
    case ALPHA_R_LDA:
    case ALPHA_R_BSR:
    case ALPHA_R_BOH:
      return 1;

    default:
      return 0;
    }
}

/* Write section contents for bfd abfd.  */

int
_bfd_vms_write_tir (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
{
  asection *section;

#if VMS_DEBUG
  _bfd_vms_debug (2, "vms_write_tir (%p, %d)\n", abfd, objtype);
#endif

  _bfd_vms_output_alignment (abfd, 4);

  PRIV (vms_linkage_index) = 1;

  for (section = abfd->sections; section; section = section->next)
    {
#if VMS_DEBUG
      _bfd_vms_debug (4, "writing %d. section '%s' (%d bytes)\n",
		      section->index, section->name,
		      (int) (section->size));
#endif

      if (!(section->flags & SEC_HAS_CONTENTS)
	  || bfd_is_com_section (section))
	continue;

      if (!section->contents)
	{
	  bfd_set_error (bfd_error_no_contents);
	  return -1;
	}

      if (section->name[0]
	  && section->name[1] == 'v'
	  && !strcmp (section->name, ".vmsdebug"))
	start_first_etbt_record (abfd);
      else
	start_etir_record (abfd, section->index, 0, FALSE);

      if (section->flags & SEC_RELOC)
	{
	  bfd_vma curr_addr = 0;
	  unsigned char *curr_data = section->contents;
	  bfd_size_type size;
	  int pass2_needed = 0;
	  int pass2_in_progress = 0;
	  unsigned int irel;

	  if (section->reloc_count <= 0)
	    (*_bfd_error_handler)
	      (_("SEC_RELOC with no relocs in section %s"), section->name);

#if VMS_DEBUG
	  else
	    {
	      int i = section->reloc_count;
	      arelent **rptr = section->orelocation;
	      _bfd_vms_debug (4, "%d relocations:\n", i);
	      while (i-- > 0)
		{
		  _bfd_vms_debug (4, "sym %s in sec %s, value %08lx, "
				     "addr %08lx, off %08lx, len %d: %s\n",
				  (*(*rptr)->sym_ptr_ptr)->name,
				  (*(*rptr)->sym_ptr_ptr)->section->name,
				  (long) (*(*rptr)->sym_ptr_ptr)->value,
				  (*rptr)->address, (*rptr)->addend,
				  bfd_get_reloc_size ((*rptr)->howto),
				   ( *rptr)->howto->name);
		  rptr++;
		}
	    }
#endif

	new_pass:
	  for (irel = 0; irel < section->reloc_count; irel++)
	    {
	      struct evax_private_udata_struct *udata;
	      arelent *rptr = section->orelocation [irel];
	      bfd_vma addr = rptr->address;
	      asymbol *sym = *rptr->sym_ptr_ptr;
	      asection *sec = sym->section;
	      int defer = defer_reloc_p (rptr);
	      unsigned int slen;
	      char *hash;

	      if (pass2_in_progress)
		{
		  /* Non-deferred relocs have already been output.  */
		  if (!defer)
		    continue;
		}
	      else
		{
		  /* Deferred relocs must be output at the very end.  */
		  if (defer)
		    {
		      pass2_needed = 1;
		      continue;
		    }

		  /* Regular relocs are intertwined with binary data.  */
	          if (curr_addr > addr)
		    (*_bfd_error_handler) (_("Size error in section %s"),
					   section->name);
		  size = addr - curr_addr;
		  sto_imm (abfd, size, curr_data, curr_addr,
		          section->index, section->name);
		  curr_data += size;
		  curr_addr += size;
		}

	      size = bfd_get_reloc_size (rptr->howto);

	      switch (rptr->howto->type)
	        {
		case ALPHA_R_IGNORE:
		  break;

		case ALPHA_R_REFLONG:
		  if (bfd_is_und_section (sym->section))
		    {
		      bfd_vma addend = rptr->addend;
		      slen = strlen ((char *) sym->name);
		      hash = _bfd_vms_length_hash_symbol
			       (abfd, sym->name, EOBJ_S_C_SYMSIZ);
		      etir_output_check (abfd, section, curr_addr, slen);
		      if (addend)
			{
			  _bfd_vms_output_begin (abfd, ETIR_S_C_STA_GBL, -1);
			  _bfd_vms_output_counted (abfd, hash);
			  _bfd_vms_output_flush (abfd);
			  _bfd_vms_output_begin (abfd, ETIR_S_C_STA_LW, -1);
			  _bfd_vms_output_long (abfd, (unsigned long) addend);
			  _bfd_vms_output_flush (abfd);
			  _bfd_vms_output_begin (abfd, ETIR_S_C_OPR_ADD, -1);
			  _bfd_vms_output_flush (abfd);
			  _bfd_vms_output_begin (abfd, ETIR_S_C_STO_LW, -1);
			  _bfd_vms_output_flush (abfd);
			}
		      else
			{
			  _bfd_vms_output_begin (abfd, ETIR_S_C_STO_GBL_LW, -1);
			  _bfd_vms_output_counted (abfd, hash);
			  _bfd_vms_output_flush (abfd);
			}
		    }
		  else if (bfd_is_abs_section (sym->section))
		    {
		      etir_output_check (abfd, section, curr_addr, 16);
		      _bfd_vms_output_begin (abfd, ETIR_S_C_STA_LW, -1);
		      _bfd_vms_output_long (abfd, (unsigned long) sym->value);
		      _bfd_vms_output_flush (abfd);
		      _bfd_vms_output_begin (abfd, ETIR_S_C_STO_LW, -1);
		      _bfd_vms_output_flush (abfd);
		    }
		  else
		    {
		      etir_output_check (abfd, section, curr_addr, 32);
		      _bfd_vms_output_begin (abfd, ETIR_S_C_STA_PQ, -1);
		      _bfd_vms_output_long (abfd, (unsigned long) sec->index);
		      _bfd_vms_output_quad (abfd, (uquad) rptr->addend
						    + (uquad) sym->value);
		      _bfd_vms_output_flush (abfd);
		      /* ??? Table B-8 of the OpenVMS Linker Utilily Manual
			 says that we should have a ETIR_S_C_STO_OFF here.
			 But the relocation would not be BFD_RELOC_32 then.
			 This case is very likely unreachable.  */
		      _bfd_vms_output_begin (abfd, ETIR_S_C_STO_LW, -1);
		      _bfd_vms_output_flush (abfd);
		    }
		  break;

		case ALPHA_R_REFQUAD:
		  if (bfd_is_und_section (sym->section))
		    {
		      bfd_vma addend = rptr->addend;
		      slen = strlen ((char *) sym->name);
		      hash = _bfd_vms_length_hash_symbol
			       (abfd, sym->name, EOBJ_S_C_SYMSIZ);
		      etir_output_check (abfd, section, curr_addr, slen);
		      if (addend)
			{
			  _bfd_vms_output_begin (abfd, ETIR_S_C_STA_GBL, -1);
			  _bfd_vms_output_counted (abfd, hash);
			  _bfd_vms_output_flush (abfd);
			  _bfd_vms_output_begin (abfd, ETIR_S_C_STA_QW, -1);
			  _bfd_vms_output_quad (abfd, (uquad) addend);
			  _bfd_vms_output_flush (abfd);
			  _bfd_vms_output_begin (abfd, ETIR_S_C_OPR_ADD, -1);
			  _bfd_vms_output_flush (abfd);
			  _bfd_vms_output_begin (abfd, ETIR_S_C_STO_QW, -1);
			  _bfd_vms_output_flush (abfd);
			}
		      else
			{
			  _bfd_vms_output_begin (abfd, ETIR_S_C_STO_GBL, -1);
			  _bfd_vms_output_counted (abfd, hash);
			  _bfd_vms_output_flush (abfd);
			}
		    }
		  else if (bfd_is_abs_section (sym->section))
		    {
		      etir_output_check (abfd, section, curr_addr, 16);
		      _bfd_vms_output_begin (abfd, ETIR_S_C_STA_QW, -1);
		      _bfd_vms_output_quad (abfd, (uquad) sym->value);
		      _bfd_vms_output_flush (abfd);
		      _bfd_vms_output_begin (abfd, ETIR_S_C_STO_QW, -1);
		      _bfd_vms_output_flush (abfd);
		    }
		  else
		    {
		      etir_output_check (abfd, section, curr_addr, 32);
		      _bfd_vms_output_begin (abfd, ETIR_S_C_STA_PQ, -1);
		      _bfd_vms_output_long (abfd, (unsigned long) sec->index);
		      _bfd_vms_output_quad (abfd, (uquad) rptr->addend
						    + (uquad) sym->value);
		      _bfd_vms_output_flush (abfd);
		      _bfd_vms_output_begin (abfd, ETIR_S_C_STO_OFF, -1);
		      _bfd_vms_output_flush (abfd);
		    }
		  break;

		case ALPHA_R_HINT:
		  sto_imm (abfd, size, curr_data, curr_addr,
			   section->index, section->name);
		  break;
		
		case ALPHA_R_LINKAGE:
		  etir_output_check (abfd, section, curr_addr, 64);
		  _bfd_vms_output_begin (abfd, ETIR_S_C_STC_LP_PSB, -1);
		  _bfd_vms_output_long
		    (abfd, (unsigned long) PRIV (vms_linkage_index));
		  PRIV (vms_linkage_index) += 2;
		  hash = _bfd_vms_length_hash_symbol
			   (abfd, sym->name, EOBJ_S_C_SYMSIZ);
		  _bfd_vms_output_counted (abfd, hash);
		  _bfd_vms_output_byte (abfd, 0);
		  _bfd_vms_output_flush (abfd);
		  break;

		case ALPHA_R_CODEADDR:
		  slen = strlen ((char *) sym->name);
		  hash = _bfd_vms_length_hash_symbol
			   (abfd, sym->name, EOBJ_S_C_SYMSIZ);
		  etir_output_check (abfd, section, curr_addr, slen);
		  _bfd_vms_output_begin (abfd, ETIR_S_C_STO_CA, -1);
		  _bfd_vms_output_counted (abfd, hash);
		  _bfd_vms_output_flush (abfd);
		  break;

		case ALPHA_R_NOP:
		  udata
		    = (struct evax_private_udata_struct *) rptr->sym_ptr_ptr;
		  etir_output_check (abfd, section, curr_addr,
				     32 + 1 + strlen (udata->origname));
		  _bfd_vms_output_begin (abfd, ETIR_S_C_STC_NOP_GBL, -1);
		  _bfd_vms_output_long (abfd, (unsigned long) udata->lkindex);
		  _bfd_vms_output_long
		    (abfd, (unsigned long) udata->enbsym->section->index);
		  _bfd_vms_output_quad (abfd, (uquad) rptr->address);
		  _bfd_vms_output_long (abfd, (unsigned long) 0x47ff041f);
		  _bfd_vms_output_long
		    (abfd, (unsigned long) udata->enbsym->section->index);
		  _bfd_vms_output_quad (abfd, (uquad) rptr->addend);
		  _bfd_vms_output_counted
		    (abfd, _bfd_vms_length_hash_symbol
			     (abfd, udata->origname, EOBJ_S_C_SYMSIZ));
		  _bfd_vms_output_flush (abfd);
		  break;

		case ALPHA_R_BSR:
		  (*_bfd_error_handler) (_("Spurious ALPHA_R_BSR reloc"));
		  break;

		case ALPHA_R_LDA:
		  udata
		    = (struct evax_private_udata_struct *) rptr->sym_ptr_ptr;
		  etir_output_check (abfd, section, curr_addr,
				     32 + 1 + strlen (udata->origname));
		  _bfd_vms_output_begin (abfd, ETIR_S_C_STC_LDA_GBL, -1);
		  _bfd_vms_output_long
		    (abfd, (unsigned long) udata->lkindex + 1);
		  _bfd_vms_output_long
		    (abfd, (unsigned long) udata->enbsym->section->index);
		  _bfd_vms_output_quad (abfd, (uquad) rptr->address);
		  _bfd_vms_output_long (abfd, (unsigned long) 0x237B0000);
		  _bfd_vms_output_long
		    (abfd, (unsigned long) udata->bsym->section->index);
		  _bfd_vms_output_quad (abfd, (uquad) rptr->addend);
		  _bfd_vms_output_counted
		    (abfd, _bfd_vms_length_hash_symbol
			    (abfd, udata->origname, EOBJ_S_C_SYMSIZ));
		  _bfd_vms_output_flush (abfd);
		  break;

		case ALPHA_R_BOH:
		  udata
		    = (struct evax_private_udata_struct *) rptr->sym_ptr_ptr;
		  etir_output_check (abfd, section, curr_addr,
				       32 + 1 + strlen (udata->origname));
		  _bfd_vms_output_begin (abfd, ETIR_S_C_STC_BOH_GBL, -1);
		  _bfd_vms_output_long (abfd, (unsigned long) udata->lkindex);
		  _bfd_vms_output_long
		    (abfd, (unsigned long) udata->enbsym->section->index);
		  _bfd_vms_output_quad (abfd, (uquad) rptr->address);
		  _bfd_vms_output_long (abfd, (unsigned long) 0xD3400000);
		  _bfd_vms_output_long
		    (abfd, (unsigned long) udata->enbsym->section->index);
		  _bfd_vms_output_quad (abfd, (uquad) rptr->addend);
		  _bfd_vms_output_counted
		    (abfd, _bfd_vms_length_hash_symbol
			     (abfd, udata->origname, EOBJ_S_C_SYMSIZ));
		  _bfd_vms_output_flush (abfd);
		  break;

		default:
		  (*_bfd_error_handler) (_("Unhandled relocation %s"),
		  			 rptr->howto->name);
		  break;
		}

	      curr_data += size;
	      curr_addr += size;
	    } /* End of relocs loop.  */

	  if (!pass2_in_progress)
	    {
	      /* Output rest of section.  */
	      if (curr_addr > section->size)
		(*_bfd_error_handler) (_("Size error in section %s"),
				       section->name);
	      size = section->size - curr_addr;
	      sto_imm (abfd, size, curr_data, curr_addr,
		       section->index, section->name);
	      curr_data += size;
	      curr_addr += size;

	      if (pass2_needed)
		{
		  pass2_in_progress = 1;
		  goto new_pass;
		}
	    }
	}
  
      else /* (section->flags & SEC_RELOC) */
	sto_imm (abfd, section->size, section->contents, 0,
		 section->index, section->name);

      end_etir_record (abfd);
    }

  _bfd_vms_output_alignment (abfd, 2);
  return 0;
}
@


1.23
log
@bfd/
	Fix compilation warning on gcc-3.4.
	* vms-tir.c (start_etir_record, sto_imm): Rename the prototype
	parameter index to sec_index according to the function definition.
@
text
@@


1.22
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2308 1
a2308 1
static void start_etir_record (bfd *abfd, int index, uquad offset,
d2313 1
a2313 1
		     int index, const char *name);
@


1.21
log
@2009-02-23  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Update copyright year, fix comments, reorder declarations.
	(_bfd_save_vms_section): Remove the prototype.
	(EGPS_S_V_NO_SHIFT): New constant.
	(bfd_vms_set_section_flags): New prototype.
	(EGPS_S_B_ALIGN, EGPS_S_W_FLAGS, EGPS_S_L_ALLOC, EGPS_S_B_NAMLNG): New
	constants.
	(EGSY_S_W_FLAGS): Ditto.
	(EGSY_S_V_QUAD_VAL): Ditto.
	(ESDF_S_L_VALUE, ESDF_S_L_PSINDX, ESDF_S_B_NAMLNG): Ditto.
	(EGST_S_W_FLAGS, EGST_S_Q_LP_1, EGST_S_Q_LP_2, EGST_S_L_PSINDX,
	EGST_S_B_NAMLNG): Ditto.
	(ESRF_S_B_NAMLNG): Ditto.
	(ETIR_S_C_HEADER_SIZE): Ditto.
	(EGPS_S_V_ALLOC_64BIT): Ditto.
	(DST_S_C_EPILOG): Ditto.
	(DST_S_C_SRC_SETLNUM_L, DST_S_C_SRC_SETLNUM_W) : Ditto.
	(DST_S_C_SRC_INCRLNUM_B): Ditto.
	(DST_S_B_PCLINE_UNSBYTE, DST_S_W_PCLINE_UNSWORD): Ditto.
	(DST_S_L_PCLINE_UNSLONG): Ditto.
	(DST_S_B_MODBEG_NAME, DST_S_L_RTNBEG_ADDRESS) : Ditto
	(DST_S_B_RTNBEG_NAME, DST_S_L_RTNEND_SIZE): Ditto
	(DST_S_C_SOURCE_HEADER_SIZE): Ditto.
	(DST_S_B_SRC_DF_LENGTH, DST_S_W_SRC_DF_FILEID): Ditto.
	(DST_S_B_SRC_DF_FILENAME, DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_W_SRC_UNSWORD, DST_S_L_SRC_UNSLONG): Ditto.
	Add prototypes.
	(vms_section, vms_reloc): Remove types.
	(hdr_struc): Replaced by ...
	(hdr_struct): ... new type.
	(EMH_S_W_HDRTYP, EMH_S_B_STRLVL, EMH_S_L_ARCH1): New constants.
	(EMH_S_L_ARCH2, EMH_S_L_RECSIZ, EMH_S_B_NAMLNG): Ditto.
	(EMH_DATE_LENGTH): Ditto.
	(eom_struc): Replaced by ...
	(eom_struct): ... new type.
	(EEOM_S_L_TOTAL_LPS, EEOM_S_W_COMCOD, EEOM_S_B_TFRFLG): New constants.
	(EEOM_S_L_PSINDX, EEOM_S_L_TFRADR): Ditto.
	(EIHD_S_K_MAJORID, EIHD_S_K_MINORID, EIHD_S_K_EXE): Ditto.
	(EIHD_S_L_SIZE, EIHD_S_L_ISDOFF, EIHD_S_L_SYMDBGOFF): Ditto.
	(EIHD_S_Q_SYMVVA, EIHD_S_L_IMGTYPE): Ditto.
	(EISD_S_L_EISDSIZE, EISD_S_L_SECSIZE, EISD_S_Q_VIR_ADDR): Ditto.
	(EISD_S_L_FLAGS, EISD_S_L_VBN, EISD_S_R_CONTROL): Ditto.
	(EISD_S_L_IDENT, EISD_S_T_GBLNAM): Ditto.
	(EISD_S_M_GBL, EISD_S_M_CRF, EISD_S_M_DZRO, EISD_S_M_WRT): Ditto.
	(EISD_S_M_INITALCODE, EISD_S_M_BASED, EISD_S_M_FIXUPVEC): Ditto.
	(EISD_S_M_RESIDENT, EISD_S_M_VECTOR, EISD_S_M_PROTECT): Ditto.
	(EISD_S_M_LASTCLU, EISD_S_M_EXE, EISD_S_M_NONSHRADR): Ditto.
	(EISD_S_M_QUAD_LENGTH, EISD_S_M_ALLOC_64BIT): Ditto.
	(EIHS_S_L_DSTVBN, EIHS_S_L_DSTSIZE, EIHS_S_L_GSTVBN): Ditto.
	(EIHS_S_L_GSTSIZE, EIHS_S_L_DMTVBN, EIHS_S_L_DMTBYTES): Ditto.
	(DBG_S_L_DMT_MODBEG, DBG_S_L_DST_SIZE): Ditto.
	(DBG_S_W_DMT_PSECT_COUNT, DBG_S_C_DMT_HEADER_SIZE): Ditto.
	(DBG_S_L_DMT_PSECT_START, DBG_S_L_DMT_PSECT_LENGTH)
	(DBG_S_C_DMT_PSECT_SIZE): Ditto.
	(enum file_type_enum): New type.
	(struct location_struct): Removed.
	(struct fileinfo, struct srecinfo, struct lineinfo): New types.
	(struct funcinfo, struct module): Ditto.
	(struct vms_private_data_struct): Update fields.
	(struct vms_section_data_struct): New type.

	* vms.c: Update copyright year, fix comments,
	Fix includes for DECC, add prototypes.
	(vms_initialize): Use bfd_alloc instead of bfd_zalloc and remove
	some initializers.
	Use flavour to set is_vax, location_stack is removed.
	(struct pair): Declare.
	(fill_section_ptr): Initialize variables at declaration.
	Add guard to set SECTION_SYM flag, handlde und section.
	(vms_fixup_sections): Use struct pair for fill_section_ptr argument.
	(_bfd_vms_slurp_object_records): New function, replaces previous
	vms_object_p.
	(vms_slurp_module): New function.
	(vms_slurp_image): Ditto.
	(vms_object_p): Complete rewrite.
	(vms_mkobject): Use is_vax field to slect architecture.
	(free_reloc_stream): New function.
	(vms_convert_to_var): Ditto.
	(vms_convert_to_var_1): Ditto.
	(vms_convert_to_var_unix_filename): Ditto.
	(vms_close_and_cleanup): Call free_reloc_stream, convert file to
	VAR format on VMS.
	(vms_new_section_hook): Set alignment to 0, allocate private data.
	(vms_get_section_contents): Load content.
	(vms_get_symbol_info): Handle undefined section.
	(vms_find_nearest_line): Handle.
	(alloc_reloc_stream): New function.
	(vms_slurp_reloc_table): Ditto.
	(vms_get_reloc_upper_bound): Make it real.
	(vms_canonicalize_reloc): Do the real work.
	(alpha_howto_table): Add ALPHA_R_NOP, ALPHA_R_BSR, ALPHA_R_LDA,
	ALPHA_R_BOH.
	(vms_bfd_reloc_type_lookup): Handle NOP, BSR, LDA and BOH.
	(vms_set_arch_mach): Check arch.
	(vms_set_section_contents): Copy the content after allocation.
	(vms_alpha_vec): Update object flags.

	* vms-tir.c: Update copyright year, fix comments,
	add prototypes for new functions.
	(dst_define_location): New function.
	(dst_restore_location): New function.
	(dst_retrieve_location): New function.
	(dst_check_allocation): New function.
	(image_dump): Call dst_check_allocation.
	(image_write_b): Ditto.
	(image_write_w): Ditto.
	(image_write_l): Ditto.
	(image_write_q): Ditto.
	(cmd_name): Handle STA_LW, STA_QW, STO_OFF, STO_IMM, STO_IMMR, STO_LW,
	STO_QW, OPR_ADD, CTL_SETRB, STC_LP_PSB, CTL_DFLOC, CTL_STLOC,
	CTL_STKDL.
	Call error handler instead of abort if name is not known.
	(etir_sta): Add quarter_relocs argument and set it.
	Fix cast.
	(etir_sto): Ditto.
	(etir_opr): Ditto, return FALSE in case of error.
	(etir_ctl): Add quarter_relocs argument and set it, fix cast.
	Fix CTL_DFLOC, CTL_STLOC, CTL_STKDL.
	(etir_stc): Add quarter_relocs argument and set it, fix cast.
	Fix STC_LP, STC_LP_PSB, STC_GBL and STC_CGA.
	Handle STC_LP_PSB, STC_BSR_GBL, STC_LDA_GBL, STC_BOH_GBL.
	Move STC_NOP_PS, STC_BSR_PS, STC_LDA_PS, STC_BOH_PS, STC_NBH_PS.
	Return FALSE in case of error.
	(tir_sta): Change sign of psect.
	(tir_ctl): Ditto.
	(tir_cmd): Fix cast. Makes tir_table static const.
	(etir_cmd): Add quarter_relocs argument, makes etir_table const,
	add argument to explain.
	(analyze_etir): Initialize maxptr, add quarter_relocs
	declaration, move some declarations into inner scopes.
	Handle quarter_relocs and STO_IMM.
	(_bfd_vms_slurp_tir): Use constant instead of hard-coded values.
	(_bfd_vms_slurp_relocs): New function.
	(_bfd_vms_decode_relocs): New function.
	(sto_imm): Rewritten.
	(start_first_etbt_record): New function.
	(start_another_etbt_record): Ditto.
	(etir_output_check): Ditto.
	(defer_reloc_p): Ditto.
	(_bfd_vms_write_tir): Remove nextoffset, convert a while-loop to
	a for-loop.  Correctly deals with contents, deals with .vmsdebug,
	rewritte relocations handling.
	(_bfd_vms_write_tbt): Removed.
	(_bfd_vms_write_dbg): Ditto.

	* vms-misc.c: Update copyright year, Fix comments.
	(_bfd_vms_get_header_values): Use 'size' instead of 'length'.
	(maybe_adjust_record_pointer_for_object): New function.
	(_bfd_vms_get_first_record): New function, replaces ...
	(_bfd_vms_get_record): ..  removed.
	(_bfd_vms_get_object_record): New function.
	(_bfd_vms_get_object_record): New function.
	(vms_get_remaining_object_record): New function, replaces ...
	(_bfd_vms_get_next_record): ... removed.
	(add_new_contents): Removed.
	(_bfd_save_vms_section): Removed.
	(_bfd_get_vms_section): Removed.
	(_bfd_vms_output_flush): Write in VAR format.
	(new_symbol): Don't make UND section.

	* vms-hdr.c: Update copyright year, update list of record handled.
	(_bfd_vms_slurp_hdr): rec_length renamed to rec_size.
	(_bfd_vms_write_hdr): Strip vms and unix patches,
	add comments, truncate module name at 31 characters,
	use constants instead of hard-coded value,
	write BFD version instead of a fixed string.
	(_bfd_vms_slurp_ihd): New function.
	(_bfd_vms_slurp_isd): Ditto.
	(_bfd_vms_slurp_ihs): Ditto.
	(new_module): Ditto.
	(parse_module): Ditto
	(build_module_list): Ditto.
	(module_find_nearest_line): Ditto.
	(_bfd_vms_find_nearest_dst_line): Ditto.
	(vms_slurp_debug): Ditto.
	(_bfd_vms_slurp_dbg): Ditto.
	(_bfd_vms_slurp_tbt): Ditto.
	(_bfd_vms_write_dbg): Ditto.
	(_bfd_vms_write_tbt): Ditto.

	* vms-gsd.c: Update copyright year, update list of records handled.
	(EVAX_LITERALS_NAME): New macro.
	(evax_section_flags): Add an entry for EVAX_LITERALS_NAME.
	(gpsflagdesc, gsyflagdesc): Moved out of _bfd_vms_slurp_gsd.
	(register_universal_symbol): New function and prototype.
	(_bfd_vms_slurp_gsd): Fix indentations and casts,
	improve debug messages,
	use constants instead of hard-coded value,
	fix missing endianness conversion,
	handle global symbol (SYMG).
	(bfd_vms_set_section_flags): New function.
	(_bfd_vms_write_gsd): Don't write .vmsdebug section,
	handle section literals,
	fix indentation,
	handle section bfd and vms flags,
	don't output LIB$INITIALIZE symbol,
	fix handling of weak symbols,
	fix evax vs vax procedure descriptor,
	handle absolute symbols.

	* reloc.c (BFD_RELOC_ALPHA_NOP, BFD_RELOC_ALPHA_BSR,
	BFD_RELOC_ALPHA_LDA, BFD_RELOC_ALPHA_BOH): New relocations.

	* makefile.vms (DEFS): Fix flags for VMS.

	* bfdio.c (real_fopen): Handle multiple VMS fopen attributes.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Regenerated.
@
text
@d2321 1
a2321 1
start_etir_record (bfd * abfd, int index, uquad offset, bfd_boolean justoffset)
d2332 1
a2332 1
  _bfd_vms_output_long (abfd, (unsigned long) index);
d2349 1
a2349 1
   address VADDR in section specified by INDEX and NAME.  */
d2353 1
a2353 1
	 int index, const char *name)
d2375 1
a2375 1
	    start_etir_record (abfd, index, vaddr, FALSE);
@


1.20
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008
   Free Software Foundation, Inc.
d9 1
a9 1
   go and read the openVMS linker manual (esp. appendix B)
a28 1

d43 27
d121 71
d209 3
d228 3
d246 3
d265 3
d284 3
d297 2
d309 5
d318 1
d338 5
d346 1
a346 1
      abort ();
d348 2
d355 1
a355 1
   vms stack commands
d357 2
a358 2
   handle sta_xxx commands in etir section
   ptr points to data area in record
d360 1
a360 1
   see table B-8 of the openVMS linker manual.  */
d363 1
a363 1
etir_sta (bfd * abfd, int cmd, unsigned char *ptr)
d367 1
a367 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d372 1
a372 1
      /* stack global
d395 1
d398 1
a398 1
      /* stack longword
d404 8
d414 1
a414 1
      /* stack global
d420 4
d426 1
a426 1
      /* stack psect base plus quadword offset
d430 1
a430 1
	 stack qw argument and section index
d435 1
a435 1
	unsigned int psect;
d438 1
a438 1
	if (psect >= PRIV (section_count))
d448 6
d460 1
a461 1
      break;
d465 1
a466 1
      break;
d468 1
d472 1
d486 1
a486 1
etir_sto (bfd * abfd, int cmd, unsigned char *ptr)
d493 1
a493 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d504 1
d513 1
d523 4
d536 4
d554 1
d568 2
a569 5
	  {
	    (*_bfd_error_handler) (_("%s: no symbol \"%s\""),
				   cmd_name (cmd), name);
	    return FALSE;
	  }
d574 1
d588 2
a589 5
	  {
	    (*_bfd_error_handler) (_("%s: no symbol \"%s\""),
				   cmd_name (cmd), name);
	    return FALSE;
	  }
d594 1
d608 1
d621 1
d649 1
d656 2
a657 1
      break;
d662 2
a663 1
      break;
d667 2
a668 1
      break;
d682 2
a683 1
etir_opr (bfd * abfd, int cmd, unsigned char *ptr ATTRIBUTE_UNUSED)
d689 1
a689 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d692 6
d775 1
a775 1
      break;
d790 1
a790 1
      break;
d801 1
a801 1
etir_ctl (bfd * abfd, int cmd, unsigned char *ptr)
d803 1
a803 1
  uquad	 dummy;
d808 1
a808 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d811 3
d834 1
a834 1
      /* FIXME */
d840 2
a841 2
      dummy = _bfd_vms_pop (abfd, &psect);
      /* FIXME */
d847 2
a848 2
      dummy = _bfd_vms_pop (abfd, &psect);
      /* FIXME.  */
d853 1
a853 1
      break;
d855 1
d864 2
a865 1
etir_stc (bfd * abfd, int cmd, unsigned char *ptr ATTRIBUTE_UNUSED)
d869 1
a869 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
a876 11
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
      break;

      /* 201 Store-conditional Linkage Pair with Procedure Signature
	 arg:	lw	linkage index
		cs	procedure name
		by	signature length
		da	signature.  */
    case ETIR_S_C_STC_LP_PSB:
      image_inc_ptr (abfd, (uquad) 16);	/* skip entry,procval */
      break;
a882 2
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
      break;
a887 2
      (*_bfd_error_handler) (_("%s: not supported"), cmd_name (cmd));
      break;
d895 12
d912 25
d940 1
d943 1
a943 1
      /* 207 Store-conditional BSR at global address
a944 1
    case ETIR_S_C_STC_BSR_GBL:
a945 2
      /* 208 Store-conditional BSR at pect + offset
	 arg: none.  */
d948 1
a948 1
      /* 209 Store-conditional LDA at global address
a949 1
    case ETIR_S_C_STC_LDA_GBL:
a950 2
      /* 210 Store-conditional LDA at psect + offset
	 arg: none.  */
d953 1
a953 1
      /* 211 Store-conditional BSR or Hint at global address
a954 1
    case ETIR_S_C_STC_BOH_GBL:
a955 2
      /* 212 Store-conditional BSR or Hint at pect + offset
	 arg: none.  */
d958 1
a958 5
      /* 213 Store-conditional NOP,BSR or HINT at global address
	 arg: none.  */
    case ETIR_S_C_STC_NBH_GBL:

      /* 214 Store-conditional NOP,BSR or HINT at psect + offset
d961 3
a963 2
      /* FIXME */
      break;
d966 3
a968 4
#if VMS_DEBUG
      _bfd_vms_debug (3,  "reserved STC cmd %d", cmd);
#endif
      break;
d970 1
d1038 1
a1038 1
   vax stack commands
d1040 2
a1041 2
   Handle sta_xxx commands in tir section
   ptr points to data area in record
d1111 1
a1111 1
	unsigned int psect;
d1121 1
a1121 1
	if (psect >= PRIV (section_count))
d1126 1
a1126 1
	_bfd_vms_push (abfd, (uquad) dummy, (int) psect);
d1138 1
a1138 1
	unsigned int psect;
d1148 1
a1148 1
	if (psect >= PRIV (section_count))
d1153 1
a1153 1
	_bfd_vms_push (abfd, (uquad) dummy, (int) psect);
d1165 1
a1165 1
	unsigned int psect;
d1175 1
a1175 1
	if (psect >= PRIV (section_count))
d1180 1
a1180 1
	_bfd_vms_push (abfd, (uquad) dummy, (int) psect);
d1644 1
a1644 1
  unsigned int psect;
d1655 2
a1656 2
      dummy = _bfd_vms_pop (abfd, (int *) &psect);
      if (psect >= PRIV (section_count))
d1658 1
a1658 1
      image_set_ptr (abfd, (int) psect, (uquad) dummy);
d1679 1
a1679 1
      dummy = _bfd_vms_pop (abfd, (int *) &psect);
d1687 1
a1687 1
      dummy = _bfd_vms_pop (abfd, (int *) &psect);
d1704 1
a1704 1
  struct
d1722 1
a1722 1
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d1757 1
a1757 1
etir_cmd (bfd * abfd, int cmd, unsigned char *ptr)
d1759 1
a1759 1
  static struct
d1763 1
a1763 1
    bfd_boolean (*explain) (bfd *, int, unsigned char *);
d1778 2
a1779 2
  _bfd_vms_debug (4, "etir_cmd %d/%x\n", cmd, cmd);
  _bfd_hexdump (8, ptr, 16, (int) ptr);
d1787 1
a1787 1
	  if (!etir_table[i].explain (abfd, cmd, ptr))
d1795 1
a1795 1
  _bfd_vms_debug (4, "etir_cmd: = 0\n");
d1830 4
a1833 2
  int cmd;
  unsigned char *maxptr;
a1839 2
  maxptr = ptr + length;

d1842 3
a1844 3
      cmd = bfd_getl16 (ptr);
      length = bfd_getl16 (ptr + 2);
      result = etir_cmd (abfd, cmd, ptr+4);
d1847 40
a1886 1
      ptr += length;
d1890 1
a1890 1
  _bfd_vms_debug (3, "analyze_etir: = %d\n", result);
d1911 2
a1912 2
      PRIV (vms_rec) += 4;	/* Skip type, size.  */
      PRIV (rec_size) -= 4;
d1928 2
a1929 4
/* Process EDBG record
   Return 0 on success, -1 on error

   Not implemented yet.  */
d1932 1
a1932 1
_bfd_vms_slurp_dbg (bfd * abfd, int objtype ATTRIBUTE_UNUSED)
d1934 91
d2026 1
a2026 1
  _bfd_vms_debug (2, "DBG/EDBG\n");
a2028 1
  abfd->flags |= (HAS_DEBUG | HAS_LINENO);
d2032 2
a2033 4
/* Process ETBT record
   Return 0 on success, -1 on error

   Not implemented yet.  */
d2036 2
a2037 2
_bfd_vms_slurp_tbt (bfd * abfd ATTRIBUTE_UNUSED,
		    int objtype ATTRIBUTE_UNUSED)
d2039 242
d2282 1
a2282 1
  _bfd_vms_debug (2, "TBT/ETBT\n");
d2304 14
d2348 2
a2349 3
/* WRITE ETIR SECTION

   This is still under construction and therefore not documented.  */
d2352 2
a2353 1
sto_imm (bfd * abfd, vms_section *sptr, bfd_vma vaddr, int index)
d2355 1
a2355 3
  int size;
  int ssize;
  unsigned char *cptr;
d2358 2
a2359 2
  _bfd_vms_debug (8, "sto_imm %d bytes\n", sptr->size);
  _bfd_hexdump (9, sptr->contents, (int) sptr->size, (int) vaddr);
a2361 3
  ssize = sptr->size;
  cptr = sptr->contents;

d2371 8
a2378 5
	  start_etir_record (abfd, index, vaddr, FALSE);
	  /* Get max size.  */
	  size = _bfd_vms_output_check (abfd, 0);
	  /* More than what's left ?  */
	  if (size > ssize)
d2393 1
d2395 55
a2449 1
      cptr += size;
a2458 2
  vms_section *sptr;
  int nextoffset;
a2465 1
  nextoffset = 0;
d2468 1
a2468 4
  /* Dump all other sections.  */
  section = abfd->sections;

  while (section != NULL)
a2469 1

d2476 17
d2495 10
a2504 1
	  int i;
a2505 3
	  if ((i = section->reloc_count) <= 0)
	    (*_bfd_error_handler) (_("SEC_RELOC with no relocs in section %s"),
				   section->name);
d2509 2
a2510 1
	      arelent **rptr;
a2511 1
	      rptr = section->orelocation;
d2514 2
a2515 1
		  _bfd_vms_debug (4, "sym %s in sec %s, value %08lx, addr %08lx, off %08lx, len %d: %s\n",
d2521 1
a2521 1
				  (*rptr)->howto->name);
a2525 1
	}
d2527 11
a2537 5
      if ((section->flags & SEC_HAS_CONTENTS)
	  && (! bfd_is_com_section (section)))
	{
	  /* Virtual addr in section.  */
	  bfd_vma vaddr;
d2539 14
a2552 6
	  sptr = _bfd_get_vms_section (abfd, section->index);
	  if (sptr == NULL)
	    {
	      bfd_set_error (bfd_error_no_contents);
	      return -1;
	    }
d2554 10
a2563 1
	  vaddr = (bfd_vma) (sptr->offset);
d2565 1
a2565 2
	  start_etir_record (abfd, section->index, (uquad) sptr->offset,
			     FALSE);
d2567 4
a2570 8
	  while (sptr != NULL)
	    {
	      /* One STA_PQ, CTL_SETRB per vms_section.  */
	      if (section->flags & SEC_RELOC)
		{
		  /* Check for relocs.  */
		  arelent **rptr = section->orelocation;
		  int i = section->reloc_count;
d2572 2
a2573 1
		  for (;;)
d2575 6
a2580 3
		      bfd_size_type addr = (*rptr)->address;
		      bfd_size_type len = bfd_get_reloc_size ((*rptr)->howto);
		      if (sptr->offset < addr)
d2582 10
a2591 21
			  /* Sptr starts before reloc.  */
			  bfd_size_type before = addr - sptr->offset;
			  if (sptr->size <= before)
			    {
			      /* Complete before.  */
			      sto_imm (abfd, sptr, vaddr, section->index);
			      vaddr += sptr->size;
			      break;
			    }
			  else
			    {
			      /* Partly before.  */
			      int after = sptr->size - before;

			      sptr->size = before;
			      sto_imm (abfd, sptr, vaddr, section->index);
			      vaddr += sptr->size;
			      sptr->contents += before;
			      sptr->offset += before;
			      sptr->size = after;
			    }
d2593 1
a2593 1
		      else if (sptr->offset == addr)
d2595 3
a2597 221
			  /* Sptr starts at reloc.  */
			  asymbol *sym = *(*rptr)->sym_ptr_ptr;
			  asection *sec = sym->section;

			  switch ((*rptr)->howto->type)
			    {
			    case ALPHA_R_IGNORE:
			      break;

			    case ALPHA_R_REFLONG:
			      {
				if (bfd_is_und_section (sym->section))
				  {
				    int slen = strlen ((char *) sym->name);
				    char *hash;

				    if (_bfd_vms_output_check (abfd, slen) < 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, FALSE);
				      }
				    _bfd_vms_output_begin (abfd,
							   ETIR_S_C_STO_GBL_LW,
							   -1);
				    hash = (_bfd_vms_length_hash_symbol
					    (abfd, sym->name, EOBJ_S_C_SYMSIZ));
				    _bfd_vms_output_counted (abfd, hash);
				    _bfd_vms_output_flush (abfd);
				  }
				else if (bfd_is_abs_section (sym->section))
				  {
				    if (_bfd_vms_output_check (abfd, 16) < 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, FALSE);
				      }
				    _bfd_vms_output_begin (abfd,
							   ETIR_S_C_STA_LW,
							   -1);
				    _bfd_vms_output_quad (abfd,
							  (uquad) sym->value);
				    _bfd_vms_output_flush (abfd);
				    _bfd_vms_output_begin (abfd,
							   ETIR_S_C_STO_LW,
							   -1);
				    _bfd_vms_output_flush (abfd);
				  }
				else
				  {
				    if (_bfd_vms_output_check (abfd, 32) < 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, FALSE);
				      }
				    _bfd_vms_output_begin (abfd,
							   ETIR_S_C_STA_PQ,
							   -1);
				    _bfd_vms_output_long (abfd,
							  (unsigned long) (sec->index));
				    _bfd_vms_output_quad (abfd,
							  ((uquad) (*rptr)->addend
							   + (uquad) sym->value));
				    _bfd_vms_output_flush (abfd);
				    _bfd_vms_output_begin (abfd,
							   ETIR_S_C_STO_LW,
							   -1);
				    _bfd_vms_output_flush (abfd);
				  }
			      }
			      break;

			    case ALPHA_R_REFQUAD:
			      {
				if (bfd_is_und_section (sym->section))
				  {
				    int slen = strlen ((char *) sym->name);
				    char *hash;

				    if (_bfd_vms_output_check (abfd, slen) < 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, FALSE);
				      }
				    _bfd_vms_output_begin (abfd,
							   ETIR_S_C_STO_GBL,
							   -1);
				    hash = (_bfd_vms_length_hash_symbol
					    (abfd, sym->name, EOBJ_S_C_SYMSIZ));
				    _bfd_vms_output_counted (abfd, hash);
				    _bfd_vms_output_flush (abfd);
				  }
				else if (bfd_is_abs_section (sym->section))
				  {
				    if (_bfd_vms_output_check (abfd, 16) < 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, FALSE);
				      }
				    _bfd_vms_output_begin (abfd,
							   ETIR_S_C_STA_QW,
							   -1);
				    _bfd_vms_output_quad (abfd,
							  (uquad) sym->value);
				    _bfd_vms_output_flush (abfd);
				    _bfd_vms_output_begin (abfd,
							   ETIR_S_C_STO_QW,
							   -1);
				    _bfd_vms_output_flush (abfd);
				  }
				else
				  {
				    if (_bfd_vms_output_check (abfd, 32) < 0)
				      {
					end_etir_record (abfd);
					start_etir_record (abfd,
							   section->index,
							   vaddr, FALSE);
				      }
				    _bfd_vms_output_begin (abfd,
							   ETIR_S_C_STA_PQ,
							   -1);
				    _bfd_vms_output_long (abfd,
							  (unsigned long) (sec->index));
				    _bfd_vms_output_quad (abfd,
							  ((uquad) (*rptr)->addend
							   + (uquad) sym->value));
				    _bfd_vms_output_flush (abfd);
				    _bfd_vms_output_begin (abfd,
							   ETIR_S_C_STO_OFF,
							   -1);
				    _bfd_vms_output_flush (abfd);
				  }
			      }
			      break;

			    case ALPHA_R_HINT:
			      {
				int hint_size;
				char *hash ATTRIBUTE_UNUSED;

				hint_size = sptr->size;
				sptr->size = len;
				sto_imm (abfd, sptr, vaddr, section->index);
				sptr->size = hint_size;
			      }
			      break;
			    case ALPHA_R_LINKAGE:
			      {
				char *hash;

				if (_bfd_vms_output_check (abfd, 64) < 0)
				  {
				    end_etir_record (abfd);
				    start_etir_record (abfd, section->index,
						       vaddr, FALSE);
				  }
				_bfd_vms_output_begin (abfd,
						       ETIR_S_C_STC_LP_PSB,
						       -1);
				_bfd_vms_output_long (abfd,
						      (unsigned long) PRIV (vms_linkage_index));
				PRIV (vms_linkage_index) += 2;
				hash = (_bfd_vms_length_hash_symbol
					(abfd, sym->name, EOBJ_S_C_SYMSIZ));
				_bfd_vms_output_counted (abfd, hash);
				_bfd_vms_output_byte (abfd, 0);
				_bfd_vms_output_flush (abfd);
			      }
			      break;

			    case ALPHA_R_CODEADDR:
			      {
				int slen = strlen ((char *) sym->name);
				char *hash;
				if (_bfd_vms_output_check (abfd, slen) < 0)
				  {
				    end_etir_record (abfd);
				    start_etir_record (abfd,
						       section->index,
						       vaddr, FALSE);
				  }
				_bfd_vms_output_begin (abfd,
						       ETIR_S_C_STO_CA,
						       -1);
				hash = (_bfd_vms_length_hash_symbol
					(abfd, sym->name, EOBJ_S_C_SYMSIZ));
				_bfd_vms_output_counted (abfd, hash);
				_bfd_vms_output_flush (abfd);
			      }
			      break;

			    default:
			      (*_bfd_error_handler) (_("Unhandled relocation %s"),
						     (*rptr)->howto->name);
			      break;
			    }

			  vaddr += len;

			  if (len == sptr->size)
			    {
			      break;
			    }
			  else
			    {
			      sptr->contents += len;
			      sptr->offset += len;
			      sptr->size -= len;
			      i--;
			      rptr++;
			    }
d2599 36
a2634 1
		      else
d2636 10
a2645 4
			  /* Sptr starts after reloc.  */
			  i--;
			  /* Check next reloc.  */
			  rptr++;
d2647 1
a2647 2

		      if (i == 0)
d2649 3
a2651 8
			  /* All reloc checked.  */
			  if (sptr->size > 0)
			    {
			      /* Dump rest.  */
			      sto_imm (abfd, sptr, vaddr, section->index);
			      vaddr += sptr->size;
			    }
			  break;
d2654 119
d2774 18
a2791 1
	      else
d2793 2
a2794 3
		  /* No relocs, just dump.  */
		  sto_imm (abfd, sptr, vaddr, section->index);
		  vaddr += sptr->size;
a2795 2

	      sptr = sptr->next;
a2796 2

	  end_etir_record (abfd);
d2798 4
d2803 1
a2803 1
      section = section->next;
a2808 26

/* Write traceback data for bfd abfd.  */

int
_bfd_vms_write_tbt (bfd * abfd ATTRIBUTE_UNUSED,
		    int objtype ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "vms_write_tbt (%p, %d)\n", abfd, objtype);
#endif

  return 0;
}

/* Write debug info for bfd abfd.  */

int
_bfd_vms_write_dbg (bfd * abfd ATTRIBUTE_UNUSED,
		    int objtype ATTRIBUTE_UNUSED)
{
#if VMS_DEBUG
  _bfd_vms_debug (2, "vms_write_dbg (%p, objtype)\n", abfd, objtype);
#endif

  return 0;
}
@


1.19
log
@2007-08-01  Michael Snyder  <msnyder@@access-company.com>

	* vms-tir.c (new_section): Fix cut and paste error.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2007
d54 2
a55 2
	= bfd_realloc (PRIV (image_section)->contents, offset + size);
      if (PRIV (image_section)->contents == 0)
d836 2
a837 2
  PRIV (sections) = bfd_realloc (PRIV (sections), amt);
  if (PRIV (sections) == 0)
@


1.18
log
@Switch sources over to use the GPL version 3
@
text
@d811 1
a811 1
      _bfd_vms_debug (6,  "bfd_make_section (%s) failed", name);
@


1.17
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d16 1
a16 1
   the Free Software Foundation; either version 2 of the License, or
d26 3
a28 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.16
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005
d37 1
a38 1
#include "sysdep.h"
@


1.15
log
@Update the FSF address in the copyright/GPL notice
@
text
@d26 1
a26 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.14
log
@Update to ISO-C90 and fix formatting
@
text
@d26 1
a26 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.13
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@a40 1

a41 44

static void image_set_ptr
  PARAMS ((bfd *abfd, int psect, uquad offset));
static void image_inc_ptr
  PARAMS ((bfd *abfd, uquad offset));
static void image_dump
  PARAMS ((bfd *abfd, unsigned char *ptr, int size, int offset));
static void image_write_b
  PARAMS ((bfd *abfd, unsigned int value));
static void image_write_w
  PARAMS ((bfd *abfd, unsigned int value));
static void image_write_l
  PARAMS ((bfd *abfd, unsigned long value));
static void image_write_q
  PARAMS ((bfd *abfd, uquad value));
static int check_section
  PARAMS ((bfd *, int));
static bfd_boolean etir_sta
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_sto
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_opr
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_ctl
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_stc
  PARAMS ((bfd *, int, unsigned char *));
static asection *new_section
  PARAMS ((bfd *, int));
static int alloc_section
  PARAMS ((bfd *, unsigned int));
static int etir_cmd
  PARAMS ((bfd *, int, unsigned char *));
static int analyze_tir
  PARAMS ((bfd *, unsigned char *, unsigned int));
static int analyze_etir
  PARAMS ((bfd *, unsigned char *, unsigned int));
static unsigned char * tir_opr
  PARAMS ((bfd *, unsigned char *));
static const char * tir_cmd_name
  PARAMS ((int));
static const char * cmd_name
  PARAMS ((int));

d44 1
a44 3
check_section (abfd, size)
     bfd *abfd;
     int size;
d70 1
a70 4
image_set_ptr (abfd, psect, offset)
     bfd *abfd;
     int psect;
     uquad offset;
a78 1
  return;
d84 1
a84 3
image_inc_ptr (abfd, offset)
     bfd *abfd;
     uquad offset;
a90 2

  return;
d96 4
a99 5
image_dump (abfd, ptr, size, offset)
    bfd *abfd;
    unsigned char *ptr;
    int size;
    int offset ATTRIBUTE_UNUSED;
a111 1
  return;
d117 1
a117 3
image_write_b (abfd, value)
     bfd *abfd;
     unsigned int value;
d120 1
a120 1
  _bfd_vms_debug (6, "image_write_b(%02x)\n", (int) value);
a126 1
  return;
d132 1
a132 3
image_write_w (abfd, value)
     bfd *abfd;
     unsigned int value;
d135 1
a135 1
  _bfd_vms_debug (6, "image_write_w(%04x)\n", (int) value);
a142 2

  return;
d148 1
a148 3
image_write_l (abfd, value)
     bfd *abfd;
     unsigned long value;
a158 2

  return;
d164 1
a164 3
image_write_q (abfd, value)
     bfd *abfd;
     uquad value;
a174 2

  return;
d178 1
a178 2
cmd_name (cmd)
     int cmd;
d234 1
a234 4
etir_sta (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr;
a235 1

a242 2
      /* stack */

d246 1
a246 2
	 stack 32 bit value of symbol (high bits set to 0)  */

d255 1
a255 1
	if (entry == (vms_symbol_entry *) NULL)
d264 1
a264 3
	  {
	    _bfd_vms_push (abfd, (uquad) (entry->symbol->value), -1);
	  }
d271 1
a271 2
	 stack 32 bit value, sign extend to 64 bit  */

d279 1
a279 2
	 stack 64 bit value of symbol	 */

d289 1
a289 2
	 (see ETIR_S_C_STO_OFF, ETIR_S_C_CTL_SETRB)  */

d303 1
a303 1
	dummy = bfd_getl64 (ptr+4);
d326 1
a326 2
/*
   etir_sto
d336 1
a336 4
etir_sto (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr;
d348 2
a349 3
      /* store byte: pop stack, write byte
	 arg: -  */

d352 1
a352 1
      /* FIXME: check top bits */
d356 2
a357 3
      /* store word: pop stack, write word
	 arg: -  */

d364 2
a365 3
      /* store longword: pop stack, write longword
	 arg: -  */

d373 2
a374 3
      /* store quadword: pop stack, write quadword
	 arg: -  */

d378 2
a379 1
      image_write_q (abfd, dummy);		/* FIXME: check top bits */
d382 1
a382 1
      /* store immediate repeated: pop stack for repeat count
d384 1
a384 2
	 da	data  */

d396 1
a396 1
      /* store global: write symbol value
a397 1

d406 1
a406 1
	if (entry == (vms_symbol_entry *) NULL)
d418 1
a418 1
      /* store code address: write address of entry point
a419 1

d428 1
a428 1
	if (entry == (vms_symbol_entry *) NULL)
d435 2
a436 1
	  image_write_q (abfd, (uquad) (entry->symbol->value));	/* FIXME, reloc */
a441 1

d447 1
a447 1
	q = _bfd_vms_pop (abfd, &psect1);
a455 1

a470 1

d479 1
a479 1
	if (entry == (vms_symbol_entry *) NULL)
d519 1
a519 4
etir_opr (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr ATTRIBUTE_UNUSED;
d530 1
a530 1
    case ETIR_S_C_OPR_NOP:      /* no-op  */
d533 1
a533 1
    case ETIR_S_C_OPR_ADD:      /* add  */
d539 1
a539 1
    case ETIR_S_C_OPR_SUB:      /* subtract  */
d545 1
a545 1
    case ETIR_S_C_OPR_MUL:      /* multiply  */
d551 1
a551 1
    case ETIR_S_C_OPR_DIV:      /* divide  */
d560 1
a560 1
    case ETIR_S_C_OPR_AND:      /* logical and  */
d566 1
a566 1
    case ETIR_S_C_OPR_IOR:      /* logical inclusive or	 */
d572 1
a572 1
    case ETIR_S_C_OPR_EOR:      /* logical exclusive or  */
d578 1
a578 1
    case ETIR_S_C_OPR_NEG:      /* negate  */
d583 1
a583 1
    case ETIR_S_C_OPR_COM:      /* complement  */
d588 1
a588 1
    case ETIR_S_C_OPR_ASH:      /* arithmetic shift  */
d591 1
a591 1
      if (op2 < 0)		/* shift right */
d593 1
a593 1
      else			/* shift left */
d598 1
a598 1
    case ETIR_S_C_OPR_INSV:      /* insert field  */
d600 2
a601 2
    case ETIR_S_C_OPR_USH:       /* unsigned shift  */
    case ETIR_S_C_OPR_ROT:       /* rotate  */
d607 1
a607 1
    case ETIR_S_C_OPR_SEL:      /* select  */
d631 1
a631 4
etir_ctl (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr;
d643 1
a643 1
      /* set relocation base: pop stack, set image location counter
a644 1

d650 2
a651 3
      /* augment relocation base: increment image location counter by offset
	 arg: lw	offset value  */

d657 1
a657 1
      /* define location: pop index, save location counter under index
a658 1

d664 1
a664 1
      /* set location: pop index, restore location counter from index
a665 1

d671 1
a671 1
      /* stack defined location: pop index, push location counter from index
a672 1

d675 1
a675 1
      /* FIXME */
d685 1
a685 1
/* store conditional commands
d690 1
a690 4
etir_stc (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr ATTRIBUTE_UNUSED;
a700 1

a709 1

a724 1

a732 1

a738 1

a742 1

a746 1

a750 1

a754 1

a758 1

a762 1

a766 1

a770 1

a774 1

d789 1
a789 3
new_section (abfd, idx)
     bfd *abfd ATTRIBUTE_UNUSED;
     int idx;
d802 1
a802 1
    return 0;
d811 1
a811 1
      return 0;
d824 1
a824 3
alloc_section (abfd, idx)
     bfd *abfd;
     unsigned int idx;
d834 1
a834 1
  PRIV (sections) = (asection **) bfd_realloc (PRIV (sections), amt);
d860 1
a860 1
tir_sta (bfd *abfd, unsigned char *ptr)
d883 2
a884 2
	if (entry == (vms_symbol_entry *) NULL)
	  return 0;
d1041 2
a1042 2
	if (entry == (vms_symbol_entry *) NULL)
	  return 0;
d1075 2
a1076 2
	if (entry == (vms_symbol_entry *) NULL)
	  return 0;
d1109 2
a1110 2
	if (entry == (vms_symbol_entry *) NULL)
	  return 0;
d1127 1
a1127 2
tir_cmd_name (cmd)
     int cmd;
d1166 1
a1166 1
tir_sto (bfd *abfd, unsigned char *ptr)
d1179 1
a1179 1
      /* store signed byte: pop stack, write byte
d1186 1
a1186 1
      /* store signed word: pop stack, write word
d1193 1
a1193 1
      /* store longword: pop stack, write longword
d1200 1
a1200 1
      /* store byte displaced: pop stack, sub lc+1, write byte
d1208 1
a1208 1
      /* store word displaced: pop stack, sub lc+2, write word
d1216 1
a1216 1
      /* store long displaced: pop stack, sub lc+4, write long
d1224 1
a1224 1
      /* store short literal: pop stack, write byte
d1231 1
a1231 1
      /* store position independent data reference: pop stack, write longword
d1239 1
a1239 1
      /* store position independent code reference: pop stack, write longword
d1248 1
a1248 1
      /* store repeated immediate variable bytes
d1259 1
a1259 1
      /* store byte from top longword.  */
d1265 1
a1265 1
      /* store word from top longword.  */
d1271 1
a1271 1
      /* store repeated byte from top longword.  */
d1279 1
a1279 1
      /* store repeated word from top longword.  */
d1306 4
a1309 4
/* stack operator commands
   all 32 bit signed arithmetic
   all word just like a stack calculator
   arguments are popped from stack, results are pushed on stack
d1314 1
a1314 3
tir_opr (abfd, ptr)
     bfd *abfd;
     unsigned char *ptr;
d1322 1
d1325 1
a1325 2
      /* operation */
    case TIR_S_C_OPR_NOP: /* no-op */
d1328 1
a1328 1
    case TIR_S_C_OPR_ADD: /* add */
d1334 1
a1334 1
    case TIR_S_C_OPR_SUB: /* subtract */
d1340 1
a1340 1
    case TIR_S_C_OPR_MUL: /* multiply */
d1346 1
a1346 1
    case TIR_S_C_OPR_DIV: /* divide */
d1355 1
a1355 1
    case TIR_S_C_OPR_AND: /* logical and */
d1361 1
a1361 1
    case TIR_S_C_OPR_IOR: /* logical inclusive or */
d1367 1
a1367 1
    case TIR_S_C_OPR_EOR: /* logical exclusive or */
d1373 1
a1373 1
    case TIR_S_C_OPR_NEG: /* negate */
d1378 1
a1378 1
    case TIR_S_C_OPR_COM: /* complement */
d1383 1
a1383 1
    case TIR_S_C_OPR_INSV: /* insert field */
d1389 1
a1389 1
    case TIR_S_C_OPR_ASH: /* arithmetic shift */
d1392 1
a1392 1
      if (HIGHBIT (op1))	/* shift right */
d1394 1
a1394 1
      else			/* shift left */
d1401 1
a1401 1
    case TIR_S_C_OPR_USH: /* unsigned shift */
d1404 1
a1404 1
      if (HIGHBIT (op1))	/* shift right */
d1406 1
a1406 1
      else			/* shift left */
d1413 1
a1413 1
    case TIR_S_C_OPR_ROT: /* rotate */
d1416 1
a1416 1
      if (HIGHBIT (0))	/* shift right */
d1418 1
a1418 1
      else		/* shift left */
d1425 1
a1425 1
    case TIR_S_C_OPR_SEL: /* select */
d1450 1
a1450 1
/* control commands
d1455 1
a1455 1
tir_ctl (bfd *abfd, unsigned char *ptr)
d1516 1
a1516 1
tir_cmd (bfd *abfd, unsigned char *ptr)
d1539 1
a1539 1
  if (*ptr & 0x80)				/* store immediate */
d1541 1
d1571 1
a1571 4
etir_cmd (abfd, cmd, ptr)
     bfd *abfd;
     int cmd;
     unsigned char *ptr;
d1577 1
a1577 1
    bfd_boolean (*explain) PARAMS ((bfd *, int, unsigned char *));
d1618 1
a1618 4
analyze_tir (abfd, ptr, length)
     bfd *abfd;
     unsigned char *ptr;
     unsigned int length;
d1642 1
a1642 4
analyze_etir (abfd, ptr, length)
     bfd *abfd;
     unsigned char *ptr;
     unsigned int length;
d1675 1
a1675 3
_bfd_vms_slurp_tir (abfd, objtype)
     bfd *abfd;
     int objtype;
d1686 1
a1686 1
      PRIV (vms_rec) += 4;	/* skip type, size */
d1691 1
a1691 1
      PRIV (vms_rec) += 1;	/* skip type */
d1709 1
a1709 3
_bfd_vms_slurp_dbg (abfd, objtype)
     bfd *abfd;
     int objtype ATTRIBUTE_UNUSED;
d1725 2
a1726 3
_bfd_vms_slurp_tbt (abfd, objtype)
     bfd *abfd ATTRIBUTE_UNUSED;
     int objtype ATTRIBUTE_UNUSED;
d1741 2
a1742 3
_bfd_vms_slurp_lnk (abfd, objtype)
     bfd *abfd ATTRIBUTE_UNUSED;
     int objtype ATTRIBUTE_UNUSED;
d1751 30
a1784 7
static void start_etir_record
  PARAMS ((bfd *abfd, int index, uquad offset, bfd_boolean justoffset));
static void sto_imm
  PARAMS ((bfd *abfd, vms_section *sptr, bfd_vma vaddr, int index));
static void end_etir_record
  PARAMS ((bfd *abfd));

d1786 1
a1786 5
sto_imm (abfd, sptr, vaddr, index)
     bfd *abfd;
     vms_section *sptr;
     bfd_vma vaddr;
     int index;
d1802 2
a1803 1
      size = ssize;				/* try all the rest */
d1806 2
a1807 1
	{					/* doesn't fit, split ! */
d1810 4
a1813 2
	  size = _bfd_vms_output_check (abfd, 0);	/* get max size */
	  if (size > ssize)			/* more than what's left ? */
a1832 34
/* Start ETIR record for section #index at virtual addr offset.  */

static void
start_etir_record (abfd, index, offset, justoffset)
    bfd *abfd;
    int index;
    uquad offset;
    bfd_boolean justoffset;
{
  if (!justoffset)
    {
      _bfd_vms_output_begin (abfd, EOBJ_S_C_ETIR, -1);	/* one ETIR per section */
      _bfd_vms_output_push (abfd);
    }

  _bfd_vms_output_begin (abfd, ETIR_S_C_STA_PQ, -1);	/* push start offset */
  _bfd_vms_output_long (abfd, (unsigned long) index);
  _bfd_vms_output_quad (abfd, (uquad) offset);
  _bfd_vms_output_flush (abfd);

  _bfd_vms_output_begin (abfd, ETIR_S_C_CTL_SETRB, -1);	/* start = pop () */
  _bfd_vms_output_flush (abfd);
}

/* End etir record.  */

static void
end_etir_record (abfd)
    bfd *abfd;
{
  _bfd_vms_output_pop (abfd);
  _bfd_vms_output_end (abfd);
}

d1836 1
a1836 3
_bfd_vms_write_tir (abfd, objtype)
     bfd *abfd;
     int objtype ATTRIBUTE_UNUSED;
a1851 1

d1868 2
a1869 4
	    {
	      (*_bfd_error_handler) (_("SEC_RELOC with no relocs in section %s"),
				     section->name);
	    }
d1894 2
a1895 1
	  bfd_vma vaddr;		/* Virtual addr in section.  */
d1909 1
a1909 1
	  while (sptr != NULL)	/* one STA_PQ, CTL_SETRB per vms_section */
d1911 2
a1912 2

	      if (section->flags & SEC_RELOC)	/* check for relocs */
d1914 1
d1922 1
a1922 1
		      if (sptr->offset < addr)	/* sptr starts before reloc */
d1924 1
d1926 1
a1926 1
			  if (sptr->size <= before)	/* complete before */
d1928 1
d1933 1
a1933 1
			  else				/* partly before */
d1935 1
d1937 1
d1946 1
a1946 1
		      else if (sptr->offset == addr) /* sptr starts at reloc */
d1948 1
d2031 1
d2170 1
a2170 1
		      else			/* sptr starts after reloc */
d2172 3
a2174 1
			  i--;			/* check next reloc */
d2178 1
a2178 1
		      if (i==0)			/* all reloc checked */
d2180 1
d2183 1
a2183 1
			      /* dump rest */
d2189 3
a2191 3
		    } /* for (;;) */
		} /* if SEC_RELOC */
	      else				/* no relocs, just dump */
d2193 1
d2199 1
a2199 2

	    } /* while (sptr != 0) */
d2202 1
a2202 2

	} /* has_contents */
d2214 2
a2215 3
_bfd_vms_write_tbt (abfd, objtype)
     bfd *abfd ATTRIBUTE_UNUSED;
     int objtype ATTRIBUTE_UNUSED;
d2227 2
a2228 3
_bfd_vms_write_dbg (abfd, objtype)
     bfd *abfd ATTRIBUTE_UNUSED;
     int objtype ATTRIBUTE_UNUSED;
@


1.12
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004
d1601 1
a1601 1
      dummy = _bfd_vms_pop (abfd, &psect);
d1625 1
a1625 1
      dummy = _bfd_vms_pop (abfd, &psect);
d1633 1
a1633 1
      dummy = _bfd_vms_pop (abfd, &psect);
@


1.11
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a441 5
#if 0
      if (is_share)		/* FIXME */
	(*_bfd_error_handler) ("%s: byte fixups not supported",
			       cmd_name (cmd));
#endif
a450 5
#if 0
      if (is_share)		/* FIXME */
	(*_bfd_error_handler) ("%s: word fixups not supported",
			       cmd_name (cmd));
#endif
a901 3
#if 0
      (*_bfd_error_handler) ("%s: not supported", cmd_name (cmd));
#endif
a2255 13
#if 0
				vms_output_begin (abfd,
						  ETIR_S_C_STO_HINT_GBL, -1);
				vms_output_long (abfd,
						 (unsigned long) (sec->index));
				vms_output_quad (abfd, (uquad) addr);

				hash = (_bfd_vms_length_hash_symbol
					(abfd, sym->name, EOBJ_S_C_SYMSIZ));
				vms_output_counted (abfd, hash);

				vms_output_flush (abfd);
#endif
@


1.10
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d96 1
a96 1
  if (offset + size > PRIV (image_section)->_raw_size)
d105 1
a105 1
      PRIV (image_section)->_raw_size = offset + size;
d954 1
a954 1
  section->_raw_size = 0;
a956 1
  section->_cooked_size = 0;
d2033 1
a2033 1
		      (int) (section->_raw_size));
@


1.10.50.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004
d96 1
a96 1
  if (offset + size > PRIV (image_section)->size)
d105 1
a105 1
      PRIV (image_section)->size = offset + size;
d954 1
a954 1
  section->size = 0;
d957 1
d2034 1
a2034 1
		      (int) (section->size));
@


1.9
log
@Fixes for better translation into other languages
@
text
@d44 42
a85 21
static void image_set_ptr PARAMS ((bfd *abfd, int psect, uquad offset));
static void image_inc_ptr PARAMS ((bfd *abfd, uquad offset));
static void image_dump PARAMS ((bfd *abfd, unsigned char *ptr, int size, int offset));
static void image_write_b PARAMS ((bfd *abfd, unsigned int value));
static void image_write_w PARAMS ((bfd *abfd, unsigned int value));
static void image_write_l PARAMS ((bfd *abfd, unsigned long value));
static void image_write_q PARAMS ((bfd *abfd, uquad value));
static int check_section PARAMS ((bfd *, int));
static boolean etir_sta PARAMS ((bfd *, int, unsigned char *));
static boolean etir_sto PARAMS ((bfd *, int, unsigned char *));
static boolean etir_opr PARAMS ((bfd *, int, unsigned char *));
static boolean etir_ctl PARAMS ((bfd *, int, unsigned char *));
static boolean etir_stc PARAMS ((bfd *, int, unsigned char *));
static asection *new_section PARAMS ((bfd *, int));
static int alloc_section PARAMS ((bfd *, unsigned int));
static int etir_cmd PARAMS ((bfd *, int, unsigned char *));
static int analyze_tir PARAMS ((bfd *, unsigned char *, unsigned int));
static int analyze_etir PARAMS ((bfd *, unsigned char *, unsigned int));
static unsigned char * tir_opr PARAMS ((bfd *, unsigned char *));
static const char * tir_cmd_name PARAMS ((int));
static const char * cmd_name PARAMS ((int));
d306 1
a306 1
static boolean
d334 1
a334 1
	  bfd_hash_lookup (PRIV (vms_symbol_table), name, false, false);
d386 1
a386 1
	    return false;
d397 1
a397 1
      return false;
d402 1
a402 1
      return false;
d408 1
a408 1
  return true;
d421 1
a421 1
static boolean
d509 1
a509 1
						      name, false, false);
d514 1
a514 1
	    return false;
d532 1
a532 1
						      name, false, false);
d537 1
a537 1
	    return false;
d585 1
a585 1
						      name, false, false);
d615 1
a615 1
  return true;
d625 1
a625 1
static boolean
d733 1
a733 1
  return true;
d740 1
a740 1
static boolean
d800 1
a800 1
  return true;
d807 1
a807 1
static boolean
d829 3
a831 3
	        cs	procedure name
	        by	signature length
	        da	signature.  */
d839 1
a839 1
	        cs	global name  */
d847 1
a847 1
	        cs	procedure name  */
d855 2
a856 2
	        lw	psect index
	        qw	offset  */
d923 1
a923 1
  return true;
d994 1
a994 1
 
d996 1
a996 1
  
d999 1
a999 1
  
d1016 3
a1018 3
         arg: cs	symbol name
        
         stack 32 bit value of symbol (high bits set to 0).  */
d1036 3
a1038 3
         arg: by	value
        
         stack byte value, sign extend to 32 bit.  */
d1044 3
a1046 3
         arg: sh	value
        
         stack 16 bit value, sign extend to 32 bit.  */
d1053 3
a1055 3
         arg: lw	value
        
         stack 32 bit value.  */
d1063 3
a1065 3
         arg: by	section index
        	(sh	section index)
        	by	signed byte offset.  */
d1090 3
a1092 3
         arg: by	section index
        	(sh	section index)
        	sh	signed short offset.  */
d1117 3
a1119 3
         arg: by	section index
        	(sh	section index)
        	lw	signed longword offset.  */
d1143 3
a1145 3
         arg: by	value
        
         stack byte value.  */
d1151 3
a1153 3
         arg: sh	value
        
         stack 16 bit value.  */
d1160 1
a1160 1
         arg: none.  */
d1164 1
a1164 1
         arg: none.  */
d1168 1
a1168 1
         arg: none.  */
d1174 4
a1177 4
         arg: cs	symbol name
        
         stack (unsigned) entry point mask of symbol
         err if symbol is no entry point.  */
d1195 6
a1200 6
         arg: cs	symbol name
        	by	argument index
        	da	argument descriptor
        
         compare argument descriptor with symbol argument (ARG$V_PASSMECH)
         and stack TRUE (args match) or FALSE (args dont match) value.  */
d1207 2
a1208 2
         arg:	sh	environment index
        	cs	symbol name.  */
d1228 3
a1230 3
         arg:	by	literal index
        
         stack literal.  */
d1238 5
a1242 5
         arg:	sh	environment index
        	cs	symbol name
        
         stack (unsigned) entry point mask of symbol
         err if symbol is no entry point.  */
d1301 1
a1301 1
  
d1303 1
a1303 1
  
d1306 1
a1306 1
  
d1324 1
a1324 1
         arg: none.  */
d1331 1
a1331 1
         arg: none.  */
d1338 1
a1338 1
         arg: none.  */
d1345 1
a1345 1
         arg: none.  */
d1353 1
a1353 1
         arg: none.  */
d1361 1
a1361 1
         arg: none.  */
d1369 1
a1369 1
         arg: none.  */
d1376 1
a1376 1
         arg: none.
d1384 2
a1385 2
         arg: none.
         FIXME: incomplete !  */
d1393 2
a1394 2
         1-byte count n field followed by n bytes of data
         pop stack, write n bytes <stack> times.  */
d1454 1
a1454 1
  
d1597 1
a1597 1
  
d1614 1
a1614 1
         arg: none.  */
d1623 1
a1623 1
         arg: lw	offset value.  */
d1630 1
a1630 1
         arg: none.  */
d1638 1
a1638 1
         arg: none.  */
d1646 1
a1646 1
         arg: none.  */
d1672 1
a1672 1
    { 0,                 TIR_S_C_MAXSTACOD, tir_sta },
d1725 1
a1725 1
    boolean (*explain) PARAMS ((bfd *, int, unsigned char *));
d1915 6
a1920 3
static void start_etir_record PARAMS ((bfd *abfd, int index, uquad offset, boolean justoffset));
static void sto_imm PARAMS ((bfd *abfd, vms_section *sptr, bfd_vma vaddr, int index));
static void end_etir_record PARAMS ((bfd *abfd));
d1948 1
a1948 1
	  start_etir_record (abfd, index, vaddr, false);
d1977 1
a1977 1
    boolean justoffset;
d2082 1
a2082 1
			     false);
d2138 1
a2138 1
							   vaddr, false);
d2155 1
a2155 1
							   vaddr, false);
d2175 1
a2175 1
							   vaddr, false);
d2205 1
a2205 1
							   vaddr, false);
d2222 1
a2222 1
							   vaddr, false);
d2242 1
a2242 1
							   vaddr, false);
d2293 1
a2293 1
						       vaddr, false);
d2318 1
a2318 1
						       vaddr, false);
@


1.9.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d44 21
a64 42
static void image_set_ptr
  PARAMS ((bfd *abfd, int psect, uquad offset));
static void image_inc_ptr
  PARAMS ((bfd *abfd, uquad offset));
static void image_dump
  PARAMS ((bfd *abfd, unsigned char *ptr, int size, int offset));
static void image_write_b
  PARAMS ((bfd *abfd, unsigned int value));
static void image_write_w
  PARAMS ((bfd *abfd, unsigned int value));
static void image_write_l
  PARAMS ((bfd *abfd, unsigned long value));
static void image_write_q
  PARAMS ((bfd *abfd, uquad value));
static int check_section
  PARAMS ((bfd *, int));
static bfd_boolean etir_sta
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_sto
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_opr
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_ctl
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_stc
  PARAMS ((bfd *, int, unsigned char *));
static asection *new_section
  PARAMS ((bfd *, int));
static int alloc_section
  PARAMS ((bfd *, unsigned int));
static int etir_cmd
  PARAMS ((bfd *, int, unsigned char *));
static int analyze_tir
  PARAMS ((bfd *, unsigned char *, unsigned int));
static int analyze_etir
  PARAMS ((bfd *, unsigned char *, unsigned int));
static unsigned char * tir_opr
  PARAMS ((bfd *, unsigned char *));
static const char * tir_cmd_name
  PARAMS ((int));
static const char * cmd_name
  PARAMS ((int));
d285 1
a285 1
static bfd_boolean
d313 1
a313 1
	  bfd_hash_lookup (PRIV (vms_symbol_table), name, FALSE, FALSE);
d365 1
a365 1
	    return FALSE;
d376 1
a376 1
      return FALSE;
d381 1
a381 1
      return FALSE;
d387 1
a387 1
  return TRUE;
d400 1
a400 1
static bfd_boolean
d488 1
a488 1
						      name, FALSE, FALSE);
d493 1
a493 1
	    return FALSE;
d511 1
a511 1
						      name, FALSE, FALSE);
d516 1
a516 1
	    return FALSE;
d564 1
a564 1
						      name, FALSE, FALSE);
d594 1
a594 1
  return TRUE;
d604 1
a604 1
static bfd_boolean
d712 1
a712 1
  return TRUE;
d719 1
a719 1
static bfd_boolean
d779 1
a779 1
  return TRUE;
d786 1
a786 1
static bfd_boolean
d808 3
a810 3
		cs	procedure name
		by	signature length
		da	signature.  */
d818 1
a818 1
		cs	global name.  */
d826 1
a826 1
		cs	procedure name.  */
d834 2
a835 2
		lw	psect index
		qw	offset.  */
d902 1
a902 1
  return TRUE;
d973 1
a973 1

d975 1
a975 1

d978 1
a978 1

d995 3
a997 3
	 arg: cs	symbol name

	 stack 32 bit value of symbol (high bits set to 0).  */
d1015 3
a1017 3
	 arg: by	value

	 stack byte value, sign extend to 32 bit.  */
d1023 3
a1025 3
	 arg: sh	value

	 stack 16 bit value, sign extend to 32 bit.  */
d1032 3
a1034 3
	 arg: lw	value

	 stack 32 bit value.  */
d1042 3
a1044 3
	 arg: by	section index
		(sh	section index)
		by	signed byte offset.  */
d1069 3
a1071 3
	 arg: by	section index
		(sh	section index)
		sh	signed short offset.  */
d1096 3
a1098 3
	 arg: by	section index
		(sh	section index)
		lw	signed longword offset.	 */
d1122 3
a1124 3
	 arg: by	value

	 stack byte value.  */
d1130 3
a1132 3
	 arg: sh	value

	 stack 16 bit value.  */
d1139 1
a1139 1
	 arg: none.  */
d1143 1
a1143 1
	 arg: none.  */
d1147 1
a1147 1
	 arg: none.  */
d1153 4
a1156 4
	 arg: cs	symbol name

	 stack (unsigned) entry point mask of symbol
	 err if symbol is no entry point.  */
d1174 6
a1179 6
	 arg: cs	symbol name
		by	argument index
		da	argument descriptor

	 compare argument descriptor with symbol argument (ARG$V_PASSMECH)
	 and stack TRUE (args match) or FALSE (args dont match) value.  */
d1186 2
a1187 2
	 arg:	sh	environment index
		cs	symbol name.  */
d1207 3
a1209 3
	 arg:	by	literal index

	 stack literal.  */
d1217 5
a1221 5
	 arg:	sh	environment index
		cs	symbol name

	 stack (unsigned) entry point mask of symbol
	 err if symbol is no entry point.  */
d1280 1
a1280 1

d1282 1
a1282 1

d1285 1
a1285 1

d1303 1
a1303 1
	 arg: none.  */
d1310 1
a1310 1
	 arg: none.  */
d1317 1
a1317 1
	 arg: none.  */
d1324 1
a1324 1
	 arg: none.  */
d1332 1
a1332 1
	 arg: none.  */
d1340 1
a1340 1
	 arg: none.  */
d1348 1
a1348 1
	 arg: none.  */
d1355 1
a1355 1
	 arg: none.
d1363 2
a1364 2
	 arg: none.
	 FIXME: incomplete !  */
d1372 2
a1373 2
	 1-byte count n field followed by n bytes of data
	 pop stack, write n bytes <stack> times.  */
d1433 1
a1433 1

d1576 1
a1576 1

d1593 1
a1593 1
	 arg: none.  */
d1602 1
a1602 1
	 arg: lw	offset value.  */
d1609 1
a1609 1
	 arg: none.  */
d1617 1
a1617 1
	 arg: none.  */
d1625 1
a1625 1
	 arg: none.  */
d1651 1
a1651 1
    { 0,		 TIR_S_C_MAXSTACOD, tir_sta },
d1704 1
a1704 1
    bfd_boolean (*explain) PARAMS ((bfd *, int, unsigned char *));
d1894 3
a1896 6
static void start_etir_record
  PARAMS ((bfd *abfd, int index, uquad offset, bfd_boolean justoffset));
static void sto_imm
  PARAMS ((bfd *abfd, vms_section *sptr, bfd_vma vaddr, int index));
static void end_etir_record
  PARAMS ((bfd *abfd));
d1924 1
a1924 1
	  start_etir_record (abfd, index, vaddr, FALSE);
d1953 1
a1953 1
    bfd_boolean justoffset;
d2058 1
a2058 1
			     FALSE);
d2114 1
a2114 1
							   vaddr, FALSE);
d2131 1
a2131 1
							   vaddr, FALSE);
d2151 1
a2151 1
							   vaddr, FALSE);
d2181 1
a2181 1
							   vaddr, FALSE);
d2198 1
a2198 1
							   vaddr, FALSE);
d2218 1
a2218 1
							   vaddr, FALSE);
d2269 1
a2269 1
						       vaddr, FALSE);
d2294 1
a2294 1
						       vaddr, FALSE);
@


1.9.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d44 21
a64 42
static void image_set_ptr
  PARAMS ((bfd *abfd, int psect, uquad offset));
static void image_inc_ptr
  PARAMS ((bfd *abfd, uquad offset));
static void image_dump
  PARAMS ((bfd *abfd, unsigned char *ptr, int size, int offset));
static void image_write_b
  PARAMS ((bfd *abfd, unsigned int value));
static void image_write_w
  PARAMS ((bfd *abfd, unsigned int value));
static void image_write_l
  PARAMS ((bfd *abfd, unsigned long value));
static void image_write_q
  PARAMS ((bfd *abfd, uquad value));
static int check_section
  PARAMS ((bfd *, int));
static bfd_boolean etir_sta
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_sto
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_opr
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_ctl
  PARAMS ((bfd *, int, unsigned char *));
static bfd_boolean etir_stc
  PARAMS ((bfd *, int, unsigned char *));
static asection *new_section
  PARAMS ((bfd *, int));
static int alloc_section
  PARAMS ((bfd *, unsigned int));
static int etir_cmd
  PARAMS ((bfd *, int, unsigned char *));
static int analyze_tir
  PARAMS ((bfd *, unsigned char *, unsigned int));
static int analyze_etir
  PARAMS ((bfd *, unsigned char *, unsigned int));
static unsigned char * tir_opr
  PARAMS ((bfd *, unsigned char *));
static const char * tir_cmd_name
  PARAMS ((int));
static const char * cmd_name
  PARAMS ((int));
d285 1
a285 1
static bfd_boolean
d313 1
a313 1
	  bfd_hash_lookup (PRIV (vms_symbol_table), name, FALSE, FALSE);
d365 1
a365 1
	    return FALSE;
d376 1
a376 1
      return FALSE;
d381 1
a381 1
      return FALSE;
d387 1
a387 1
  return TRUE;
d400 1
a400 1
static bfd_boolean
d488 1
a488 1
						      name, FALSE, FALSE);
d493 1
a493 1
	    return FALSE;
d511 1
a511 1
						      name, FALSE, FALSE);
d516 1
a516 1
	    return FALSE;
d564 1
a564 1
						      name, FALSE, FALSE);
d594 1
a594 1
  return TRUE;
d604 1
a604 1
static bfd_boolean
d712 1
a712 1
  return TRUE;
d719 1
a719 1
static bfd_boolean
d779 1
a779 1
  return TRUE;
d786 1
a786 1
static bfd_boolean
d808 3
a810 3
		cs	procedure name
		by	signature length
		da	signature.  */
d818 1
a818 1
		cs	global name.  */
d826 1
a826 1
		cs	procedure name.  */
d834 2
a835 2
		lw	psect index
		qw	offset.  */
d902 1
a902 1
  return TRUE;
d973 1
a973 1

d975 1
a975 1

d978 1
a978 1

d995 3
a997 3
	 arg: cs	symbol name

	 stack 32 bit value of symbol (high bits set to 0).  */
d1015 3
a1017 3
	 arg: by	value

	 stack byte value, sign extend to 32 bit.  */
d1023 3
a1025 3
	 arg: sh	value

	 stack 16 bit value, sign extend to 32 bit.  */
d1032 3
a1034 3
	 arg: lw	value

	 stack 32 bit value.  */
d1042 3
a1044 3
	 arg: by	section index
		(sh	section index)
		by	signed byte offset.  */
d1069 3
a1071 3
	 arg: by	section index
		(sh	section index)
		sh	signed short offset.  */
d1096 3
a1098 3
	 arg: by	section index
		(sh	section index)
		lw	signed longword offset.	 */
d1122 3
a1124 3
	 arg: by	value

	 stack byte value.  */
d1130 3
a1132 3
	 arg: sh	value

	 stack 16 bit value.  */
d1139 1
a1139 1
	 arg: none.  */
d1143 1
a1143 1
	 arg: none.  */
d1147 1
a1147 1
	 arg: none.  */
d1153 4
a1156 4
	 arg: cs	symbol name

	 stack (unsigned) entry point mask of symbol
	 err if symbol is no entry point.  */
d1174 6
a1179 6
	 arg: cs	symbol name
		by	argument index
		da	argument descriptor

	 compare argument descriptor with symbol argument (ARG$V_PASSMECH)
	 and stack TRUE (args match) or FALSE (args dont match) value.  */
d1186 2
a1187 2
	 arg:	sh	environment index
		cs	symbol name.  */
d1207 3
a1209 3
	 arg:	by	literal index

	 stack literal.  */
d1217 5
a1221 5
	 arg:	sh	environment index
		cs	symbol name

	 stack (unsigned) entry point mask of symbol
	 err if symbol is no entry point.  */
d1280 1
a1280 1

d1282 1
a1282 1

d1285 1
a1285 1

d1303 1
a1303 1
	 arg: none.  */
d1310 1
a1310 1
	 arg: none.  */
d1317 1
a1317 1
	 arg: none.  */
d1324 1
a1324 1
	 arg: none.  */
d1332 1
a1332 1
	 arg: none.  */
d1340 1
a1340 1
	 arg: none.  */
d1348 1
a1348 1
	 arg: none.  */
d1355 1
a1355 1
	 arg: none.
d1363 2
a1364 2
	 arg: none.
	 FIXME: incomplete !  */
d1372 2
a1373 2
	 1-byte count n field followed by n bytes of data
	 pop stack, write n bytes <stack> times.  */
d1433 1
a1433 1

d1576 1
a1576 1

d1593 1
a1593 1
	 arg: none.  */
d1602 1
a1602 1
	 arg: lw	offset value.  */
d1609 1
a1609 1
	 arg: none.  */
d1617 1
a1617 1
	 arg: none.  */
d1625 1
a1625 1
	 arg: none.  */
d1651 1
a1651 1
    { 0,		 TIR_S_C_MAXSTACOD, tir_sta },
d1704 1
a1704 1
    bfd_boolean (*explain) PARAMS ((bfd *, int, unsigned char *));
d1894 3
a1896 6
static void start_etir_record
  PARAMS ((bfd *abfd, int index, uquad offset, bfd_boolean justoffset));
static void sto_imm
  PARAMS ((bfd *abfd, vms_section *sptr, bfd_vma vaddr, int index));
static void end_etir_record
  PARAMS ((bfd *abfd));
d1924 1
a1924 1
	  start_etir_record (abfd, index, vaddr, FALSE);
d1953 1
a1953 1
    bfd_boolean justoffset;
d2058 1
a2058 1
			     FALSE);
d2114 1
a2114 1
							   vaddr, FALSE);
d2131 1
a2131 1
							   vaddr, FALSE);
d2151 1
a2151 1
							   vaddr, FALSE);
d2181 1
a2181 1
							   vaddr, FALSE);
d2198 1
a2198 1
							   vaddr, FALSE);
d2218 1
a2218 1
							   vaddr, FALSE);
d2269 1
a2269 1
						       vaddr, FALSE);
d2294 1
a2294 1
						       vaddr, FALSE);
@


1.8
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d14 13
a26 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d62 3
d66 1
a66 2
/*-----------------------------------------------------------------------------*/

d91 1
a91 1
/* routines to fill sections contents during tir/etir read */
d93 1
a93 1
/* Initialize image buffer pointer to be filled  */
d111 1
a111 1
/* Increment image buffer pointer by offset  */
d127 1
a127 1
/* Dump multiple bytes to section image  */
d150 1
a150 1
/* Write byte to section image  */
d168 1
a168 1
/* Write 2-byte word to image  */
d188 1
a188 1
/* Write 4-byte long to image  */
d208 1
a208 1
/* Write 8-byte quad to image  */
d228 40
d269 5
d283 1
a283 1
   see table B-8 of the openVMS linker manual  */
d317 2
a318 1
	    _bfd_vms_debug (3, "ETIR_S_C_STA_GBL: no symbol \"%s\"\n", name);
d362 2
a363 1
	    (*_bfd_error_handler) (_("Bad section index in ETIR_S_C_STA_PQ"));
a371 2
      /* all not supported  */

d375 1
a375 2

      (*_bfd_error_handler) (_("Unsupported STA cmd %d"), cmd);
d380 1
a380 1
      (*_bfd_error_handler) (_("Reserved STA cmd %d"), cmd);
d398 1
a398 1
   see table B-9 of the openVMS linker manual  */
a415 1

d423 2
a424 1
	(*_bfd_error_handler) ("ETIR_S_C_STO_B: byte fixups not supported");
d437 2
a438 1
	(*_bfd_error_handler) ("ETIR_S_C_STO_B: word fixups not supported");
d450 1
a450 1
      /* FIXME: check top bits */
d479 1
a479 1
	 arg: cs	global symbol name  */
d491 2
a492 2
	    (*_bfd_error_handler) (_("ETIR_S_C_STO_GBL: no symbol \"%s\""),
				   name);
d496 2
a497 1
	  image_write_q (abfd, (uquad) (entry->symbol->value));	/* FIXME, reloc */
d502 1
a502 1
	 arg: cs	global symbol name (procedure)  */
d514 2
a515 2
	    (*_bfd_error_handler) (_("ETIR_S_C_STO_CA: no symbol \"%s\""),
				   name);
d523 2
a524 9
      /* not supported  */

    case ETIR_S_C_STO_RB:
    case ETIR_S_C_STO_AB:
      (*_bfd_error_handler) (_("ETIR_S_C_STO_RB/AB: Not supported"));
      break;

      /* store offset to psect: pop stack, add low 32 bits to base of psect
	 arg: -  */
d537 1
a537 1
      /* store immediate
d539 1
a539 1
	 da	data  */
d550 1
a550 1
      /* this code is 'reserved to digital' according to the openVMS
d555 1
a555 1
	 arg: cs	symbol name  */
d568 1
a568 1
	    _bfd_vms_debug (3, "ETIR_S_C_STO_GBL_LW: no symbol \"%s\"\n", name);
d573 2
a574 1
	  image_write_l (abfd, (unsigned long) (entry->symbol->value));	/* FIXME, reloc */
d578 2
a579 2
      /* not supported  */

d581 1
a581 1
      (*_bfd_error_handler) (_("ETIR_S_C_STO_LP_PSB: Not supported"));
a583 2
      /* */

a584 5
      (*_bfd_error_handler) (_("ETIR_S_C_STO_HINT_GBL: not implemented"));
      break;

      /* */

d586 1
a586 1
      (*_bfd_error_handler) (_("ETIR_S_C_STO_HINT_PS: not implemented"));
d590 1
a590 1
      (*_bfd_error_handler) (_("Reserved STO cmd %d"), cmd);
d597 1
a597 1
/* stack operator commands
d602 1
a602 1
   see table B-10 of the openVMS linker manual  */
d619 1
a619 5
      /* operation */

      /* no-op  */

    case ETIR_S_C_OPR_NOP:
d622 1
a622 3
      /* add  */

    case ETIR_S_C_OPR_ADD:
d628 1
a628 3
      /* subtract  */

    case ETIR_S_C_OPR_SUB:
d634 1
a634 3
      /* multiply  */

    case ETIR_S_C_OPR_MUL:
d640 1
a640 3
      /* divide  */

    case ETIR_S_C_OPR_DIV:
d649 1
a649 3
      /* logical and  */

    case ETIR_S_C_OPR_AND:
d655 1
a655 3
      /* logical inclusive or	 */

    case ETIR_S_C_OPR_IOR:
d661 1
a661 3
      /* logical exclusive or  */

    case ETIR_S_C_OPR_EOR:
d667 1
a667 3
      /* negate  */

    case ETIR_S_C_OPR_NEG:
d672 1
a672 3
      /* complement  */

    case ETIR_S_C_OPR_COM:
d677 1
a677 10
      /* insert field  */

    case ETIR_S_C_OPR_INSV:
      (void) _bfd_vms_pop (abfd, NULL);
      (*_bfd_error_handler) (_("ETIR_S_C_OPR_INSV: Not supported"));
      break;

      /* arithmetic shift  */

    case ETIR_S_C_OPR_ASH:
d687 7
a693 4
      /* unsigned shift  */

    case ETIR_S_C_OPR_USH:
      (*_bfd_error_handler) (_("ETIR_S_C_OPR_USH: Not supported"));
d696 1
a696 9
      /* rotate  */

    case ETIR_S_C_OPR_ROT:
      (*_bfd_error_handler) (_("ETIR_S_C_OPR_ROT: Not supported"));
      break;

      /* select  */

    case ETIR_S_C_OPR_SEL:
a706 12
      /* redefine symbol to current location  */

    case ETIR_S_C_OPR_REDEF:
      (*_bfd_error_handler) (_("ETIR_S_C_OPR_REDEF: Not supported"));
      break;

      /* define a literal  */

    case ETIR_S_C_OPR_DFLIT:
      (*_bfd_error_handler) (_("ETIR_S_C_OPR_DFLIT: Not supported"));
      break;

d708 1
a708 1
      (*_bfd_error_handler) (_("Reserved OPR cmd %d"), cmd);
d715 1
a715 1
/* control commands
d717 1
a717 1
   see table B-11 of the openVMS linker manual  */
d736 1
a736 1
	 arg: -  */
d752 1
a752 1
	 arg: -  */
d760 1
a760 1
	 arg: -  */
d768 1
a768 1
	 arg: -  */
d776 1
a776 1
      (*_bfd_error_handler) (_("Reserved CTL cmd %d"), cmd);
d784 1
a784 1
   see table B-12 and B-13 of the openVMS linker manual  */
a791 1

d800 1
a800 1
	 arg:  */
d803 1
a803 1
      (*_bfd_error_handler) (_("ETIR_S_C_STC_LP: not supported"));
d808 3
a810 3
	 cs	procedure name
	 by	signature length
	 da	signature  */
d818 1
a818 1
	 cs	global name  */
d821 1
a821 1
      (*_bfd_error_handler) (_("ETIR_S_C_STC_GBL: not supported"));
d826 1
a826 1
	 cs	procedure name  */
d829 1
a829 1
      (*_bfd_error_handler) (_("ETIR_S_C_STC_GCA: not supported"));
d834 2
a835 2
	 lw	psect index
	 qw	offset  */
d838 1
a838 1
      (*_bfd_error_handler) (_("ETIR_S_C_STC_PS: not supported"));
d842 1
a842 1
	 arg:  */
d847 1
a847 1
	 arg:  */
d852 1
a852 1
	 arg:  */
d857 1
a857 1
	 arg:  */
d862 1
a862 1
	 arg:  */
d867 1
a867 1
	 arg:  */
d872 1
a872 1
	 arg:  */
d877 1
a877 1
	 arg:  */
d882 1
a882 1
	 arg:  */
d887 1
a887 1
	 arg:  */
d892 1
a892 1
      (*_bfd_error_handler) ("ETIR_S_C_STC_xx: (%d) not supported", cmd);
d898 1
a898 1
      _bfd_vms_debug (3,  "Reserved STC cmd %d", cmd);
d915 1
a915 1
  _bfd_vms_debug (5,  "new_section %d\n", idx);
d951 1
a951 1
  _bfd_vms_debug (4,  "alloc_section %d\n", idx);
d972 8
a979 10
/*
 * tir_sta
 *
 * vax stack commands
 *
 * handle sta_xxx commands in tir section
 * ptr points to data area in record
 *
 * see table 7-3 of the VAX/VMS linker manual
 */
d994 4
a997 6
      /*
       * stack global
       * arg: cs	symbol name
       *
       * stack 32 bit value of symbol (high bits set to 0)
       */
d1014 4
a1017 6
      /*
       * stack signed byte
       * arg: by	value
       *
       * stack byte value, sign extend to 32 bit
       */
d1022 4
a1025 6
      /*
       * stack signed short word
       * arg: sh	value
       *
       * stack 16 bit value, sign extend to 32 bit
       */
d1031 4
a1034 6
      /*
       * stack signed longword
       * arg: lw	value
       *
       * stack 32 bit value
       */
d1041 4
a1044 7
      /*
       * stack psect base plus byte offset (word index)
       * arg: by	section index
       *	(sh	section index)
       *	by	signed byte offset
       *
       */
d1058 1
a1058 3
	  {
	    alloc_section (abfd, psect);
	  }
d1068 4
a1071 7
      /*
       * stack psect base plus word offset (word index)
       * arg: by	section index
       *	(sh	section index)
       *	sh	signed short offset
       *
       */
d1085 1
a1085 3
	  {
	    alloc_section (abfd, psect);
	  }
d1095 4
a1098 7
      /*
       * stack psect base plus long offset (word index)
       * arg: by	section index
       *	(sh	section index)
       *	lw	signed longword offset
       *
       */
d1112 1
a1112 3
	  {
	    alloc_section (abfd, psect);
	  }
d1121 4
a1124 6
      /*
       * stack unsigned byte
       * arg: by	value
       *
       * stack byte value
       */
d1129 4
a1132 6
      /*
       * stack unsigned short word
       * arg: sh	value
       *
       * stack 16 bit value
       */
d1138 3
a1140 6
      /*
       * stack byte from image
       * arg: -
       *
       */
      /*FALLTHRU*/
d1142 3
a1144 6
      /*
       * stack byte from image
       * arg: -
       *
       */
      /*FALLTHRU*/
d1146 3
a1148 6
      /*
       * stack byte from image
       * arg: -
       *
       */
      (*_bfd_error_handler) (_("Stack-from-image not implemented"));
d1152 5
a1156 7
      /*
       * stack entry point mask
       * arg: cs	symbol name
       *
       * stack (unsigned) entry point mask of symbol
       * err if symbol is no entry point
       */
d1166 1
a1166 1
	(*_bfd_error_handler) (_("Stack-entry-mask not fully implemented"));
d1173 7
a1179 9
      /*
       * compare procedure argument
       * arg: cs	symbol name
       *	by	argument index
       *	da	argument descriptor
       *
       * compare argument descriptor with symbol argument (ARG$V_PASSMECH)
       * and stack TRUE (args match) or FALSE (args dont match) value
       */
d1185 3
a1187 5
      /*
       * stack local symbol value
       * arg:	sh	environment index
       *	cs	symbol name
       */
d1199 1
a1199 1
	(*_bfd_error_handler) (_("Stack-local-symbol not fully implemented"));
d1206 4
a1209 6
      /*
       * stack literal
       * arg:	by	literal index
       *
       * stack literal
       */
d1212 1
a1212 1
      (*_bfd_error_handler) (_("Stack-literal not fully implemented"));
d1216 6
a1221 8
      /*
       * stack local symbol entry point mask
       * arg:	sh	environment index
       *	cs	symbol name
       *
       * stack (unsigned) entry point mask of symbol
       * err if symbol is no entry point
       */
d1233 1
a1233 1
	(*_bfd_error_handler) (_("Stack-local-symbol-entry-point-mask not fully implemented"));
d1240 1
a1240 1
      (*_bfd_error_handler) (_("Reserved STA cmd %d"), ptr[-1]);
d1248 39
a1286 10
/*
 * tir_sto
 *
 * vax store commands
 *
 * handle sto_xxx commands in tir section
 * ptr points to data area in record
 *
 * see table 7-4 of the VAX/VMS linker manual
 */
d1302 2
a1303 4
      /*
       * store signed byte: pop stack, write byte
       * arg: -
       */
d1309 2
a1310 4
      /*
       * store signed word: pop stack, write word
       * arg: -
       */
d1316 2
a1317 4
      /*
       * store longword: pop stack, write longword
       * arg: -
       */
d1323 2
a1324 4
      /*
       * store byte displaced: pop stack, sub lc+1, write byte
       * arg: -
       */
d1331 2
a1332 4
      /*
       * store word displaced: pop stack, sub lc+2, write word
       * arg: -
       */
d1337 1
d1339 2
a1340 4
      /*
       * store long displaced: pop stack, sub lc+4, write long
       * arg: -
       */
d1345 1
d1347 2
a1348 4
      /*
       * store short literal: pop stack, write byte
       * arg: -
       */
d1352 1
d1354 3
a1356 5
      /*
       * store position independent data reference: pop stack, write longword
       * arg: -
       * FIXME: incomplete !
       */
d1360 1
d1362 3
a1364 5
      /*
       * store position independent code reference: pop stack, write longword
       * arg: -
       * FIXME: incomplete !
       */
d1369 1
d1371 3
a1373 5
      /*
       * store repeated immediate variable bytes
       * 1-byte count n field followed by n bytes of data
       * pop stack, write n bytes <stack> times
       */
d1380 1
d1382 1
a1382 3
      /*
       * store byte from top longword
       */
d1386 1
d1388 1
a1388 3
      /*
       * store word from top longword
       */
d1392 1
d1394 1
a1394 3
      /*
       * store repeated byte from top longword
       */
d1400 1
d1402 1
a1402 3
      /*
       * store repeated word from top longword
       */
d1418 1
a1418 1
      (*_bfd_error_handler) (_("Unimplemented STO cmd %d"), ptr[-1]);
d1422 1
a1422 1
      (*_bfd_error_handler) (_("Reserved STO cmd %d"), ptr[-1]);
d1429 6
a1434 8
/*
 * stack operator commands
 * all 32 bit signed arithmetic
 * all word just like a stack calculator
 * arguments are popped from stack, results are pushed on stack
 *
 * see table 7-5 of the VAX/VMS linker manual
 */
d1437 3
a1439 1
tir_opr (bfd *abfd, unsigned char *ptr)
d1450 1
a1450 4
    case TIR_S_C_OPR_NOP:
      /*
       * no-op
       */
d1453 1
a1453 4
    case TIR_S_C_OPR_ADD:
      /*
       * add
       */
d1459 1
a1459 4
    case TIR_S_C_OPR_SUB:
      /*
       * subtract
       */
d1465 1
a1465 4
    case TIR_S_C_OPR_MUL:
      /*
       * multiply
       */
d1471 1
a1471 4
    case TIR_S_C_OPR_DIV:
      /*
       * divide
       */
d1480 1
a1480 4
    case TIR_S_C_OPR_AND:
      /*
       * logical and
       */
d1486 1
a1486 1
    case TIR_S_C_OPR_IOR:
a1487 3
      /*
       * logical inclusive or
       */
d1492 1
a1492 4
    case TIR_S_C_OPR_EOR:
      /*
       * logical exclusive or
       */
d1498 1
a1498 4
    case TIR_S_C_OPR_NEG:
      /*
       * negate
       */
d1503 1
a1503 4
    case TIR_S_C_OPR_COM:
      /*
       * complement
       */
d1508 1
a1508 4
    case TIR_S_C_OPR_INSV:
      /*
       * insert field
       */
d1510 2
a1511 1
      (*_bfd_error_handler)  ("TIR_S_C_OPR_INSV incomplete");
d1514 1
a1514 4
    case TIR_S_C_OPR_ASH:
      /*
       * arithmetic shift
       */
d1517 1
a1517 1
      if (HIGHBIT (op1))		/* shift right */
d1522 2
a1523 1
      (*_bfd_error_handler) (_("TIR_S_C_OPR_ASH incomplete"));
d1526 1
a1526 4
    case TIR_S_C_OPR_USH:
      /*
       * unsigned shift
       */
d1529 1
a1529 1
      if (HIGHBIT (op1))		/* shift right */
d1534 2
a1535 1
      (*_bfd_error_handler) (_("TIR_S_C_OPR_USH incomplete"));
d1538 1
a1538 4
    case TIR_S_C_OPR_ROT:
      /*
       * rotate
       */
d1546 2
a1547 1
      (*_bfd_error_handler) (_("TIR_S_C_OPR_ROT incomplete"));
d1550 1
a1550 4
    case TIR_S_C_OPR_SEL:
      /*
       * select
       */
d1561 4
a1564 12
    case TIR_S_C_OPR_REDEF:
      /*
       * redefine symbol to current location
       */
      (*_bfd_error_handler) (_("TIR_S_C_OPR_REDEF not supported"));
      break;

    case TIR_S_C_OPR_DFLIT:
      /*
       * define a literal
       */
      (*_bfd_error_handler) (_("TIR_S_C_OPR_DFLIT not supported"));
d1568 1
a1568 1
      (*_bfd_error_handler) (_("Reserved OPR cmd %d"), ptr[-1]);
d1575 4
a1580 5
/*
 * control commands
 *
 * see table 7-6 of the VAX/VMS linker manual
 */
d1592 2
a1593 4
      /*
       * set relocation base: pop stack, set image location counter
       * arg: -
       */
d1596 1
a1596 3
	{
	  alloc_section (abfd, psect);
	}
d1599 1
d1601 2
a1602 4
      /*
       * augment relocation base: increment image location counter by offset
       * arg: lw	offset value
       */
d1606 1
d1608 2
a1609 4
      /*
       * define location: pop index, save location counter under index
       * arg: -
       */
d1611 2
a1612 1
      (*_bfd_error_handler) (_("TIR_S_C_CTL_DFLOC not fully implemented"));
d1614 1
d1616 2
a1617 4
      /*
       * set location: pop index, restore location counter from index
       * arg: -
       */
d1619 2
a1620 1
      (*_bfd_error_handler) (_("TIR_S_C_CTL_STLOC not fully implemented"));
d1622 1
d1624 2
a1625 4
      /*
       * stack defined location: pop index, push location counter from index
       * arg: -
       */
d1627 2
a1628 1
      (*_bfd_error_handler) (_("TIR_S_C_CTL_STKDL not fully implemented"));
d1630 1
d1632 1
a1632 1
      (*_bfd_error_handler) (_("Reserved CTL cmd %d"), ptr[-1]);
d1638 1
a1638 3
/*
 * handle command from TIR section
 */
d1684 1
a1684 1
	  (*_bfd_error_handler) (_("Obj code %d not found"), *ptr);
d1692 1
a1692 1
/* handle command from ETIR section  */
d1742 1
a1742 1
   handle tir record  */
d1769 1
a1769 1
   handle etir record  */
d1804 2
a1805 3
/* process ETIR record

   return 0 on success, -1 on error  */
d1838 2
a1839 2
/* process EDBG record
   return 0 on success, -1 on error
d1841 1
a1841 1
   not implemented yet  */
d1856 2
a1857 2
/* process ETBT record
   return 0 on success, -1 on error
d1859 1
a1859 1
   not implemented yet  */
d1873 2
a1874 2
/* process LNK record
   return 0 on success, -1 on error
d1876 1
a1876 1
   not implemented yet  */
d1890 3
a1892 7
/*----------------------------------------------------------------------*/
/*									*/
/*	WRITE ETIR SECTION						*/
/*									*/
/*	this is still under construction and therefore not documented	*/
/*									*/
/*----------------------------------------------------------------------*/
a1918 1

a1943 2

  return;
d1946 1
a1946 3
/*-------------------------------------------------------------------*/

/* start ETIR record for section #index at virtual addr offset.  */
d1968 1
d1970 1
a1970 2
  return;
}
a1971 1
/* end etir record  */
d1980 1
a1980 1
/* write section contents for bfd abfd  */
d2000 1
a2000 1
  /* dump all other sections  */
d2046 1
a2046 1
	  bfd_vma vaddr;		/* virtual addr in section */
d2067 1
d2366 1
a2366 1
/* write traceback data for bfd abfd  */
d2380 1
a2380 1
/* write debug info for bfd abfd  */
@


1.7
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@a35 2
#include <ctype.h>

@


1.6
log
@	* vms-tir.c: Add missing prototypes.
	* vms-hdr.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d71 1
a71 1
  int offset;
d73 2
a74 2
  offset = PRIV(image_ptr) - PRIV(image_section)->contents;
  if ((bfd_size_type) (offset + size) > PRIV(image_section)->_raw_size)
d76 3
a78 2
      PRIV(image_section)->contents = bfd_realloc (PRIV(image_section)->contents, offset + size);
      if (PRIV(image_section)->contents == 0)
d83 2
a84 2
      PRIV(image_section)->_raw_size = offset + size;
      PRIV(image_ptr) = PRIV(image_section)->contents + offset;
d102 1
a102 1
		psect, PRIV(sections)[psect]->name, offset);
d105 2
a106 2
  PRIV(image_ptr) = PRIV(sections)[psect]->contents + offset;
  PRIV(image_section) = PRIV(sections)[psect];
d121 1
a121 1
  PRIV(image_ptr) += offset;
d136 2
a137 1
  _bfd_vms_debug (8, "image_dump from (%p, %d) to (%p)\n", ptr, size, PRIV(image_ptr));
d141 1
a141 1
  if (PRIV(is_vax) && check_section (abfd, size))
d145 1
a145 1
    *PRIV(image_ptr)++ = *ptr++;
d157 1
a157 1
  _bfd_vms_debug (6, "image_write_b(%02x)\n", (int)value);
d160 1
a160 1
  if (PRIV(is_vax) && check_section (abfd, 1))
d163 1
a163 1
  *PRIV(image_ptr)++ = (value & 0xff);
d175 1
a175 1
  _bfd_vms_debug (6, "image_write_w(%04x)\n", (int)value);
d178 1
a178 1
  if (PRIV(is_vax) && check_section (abfd, 2))
d181 2
a182 2
  bfd_putl16 (value, PRIV(image_ptr));
  PRIV(image_ptr) += 2;
d198 1
a198 1
  if (PRIV(is_vax) && check_section (abfd, 4))
d201 2
a202 2
  bfd_putl32 (value, PRIV(image_ptr));
  PRIV(image_ptr) += 4;
d218 1
a218 1
  if (PRIV(is_vax) && check_section (abfd, 8))
d221 2
a222 2
  bfd_putl64 (value, PRIV(image_ptr));
  PRIV(image_ptr) += 8;
d248 1
a248 1
  _bfd_hexdump (8, ptr, 16, (int)ptr);
d256 1
a256 1
	   arg: cs	symbol name
d258 1
a258 1
	   stack 32 bit value of symbol (high bits set to 0)  */
d260 4
a263 4
      case ETIR_S_C_STA_GBL:
	{
	  char *name;
	  vms_symbol_entry *entry;
d265 5
a269 5
	  name = _bfd_vms_save_counted_string (ptr);
	  entry = (vms_symbol_entry *)
		  bfd_hash_lookup (PRIV(vms_symbol_table), name, false, false);
	  if (entry == (vms_symbol_entry *)NULL)
	    {
d271 1
a271 1
	      _bfd_vms_debug (3, "ETIR_S_C_STA_GBL: no symbol \"%s\"\n", name);
d273 7
a279 7
	      _bfd_vms_push (abfd, (uquad)0, -1);
	    }
	  else
	    {
	      _bfd_vms_push (abfd, (uquad) (entry->symbol->value), -1);
	    }
	}
d282 2
a283 2
	/* stack longword
	   arg: lw	value
d285 1
a285 1
	   stack 32 bit value, sign extend to 64 bit  */
d287 2
a288 2
      case ETIR_S_C_STA_LW:
	_bfd_vms_push (abfd, (uquad)bfd_getl32 (ptr), -1);
d291 2
a292 2
	/* stack global
	   arg: qw	value
d294 1
a294 1
	   stack 64 bit value of symbol	 */
d296 2
a297 2
      case ETIR_S_C_STA_QW:
	_bfd_vms_push (abfd, (uquad)bfd_getl64(ptr), -1);
d300 3
a302 3
	/* stack psect base plus quadword offset
	   arg: lw	section index
	  	qw	signed quadword offset (low 32 bits)
d304 2
a305 2
	   stack qw argument and section index
	   (see ETIR_S_C_STO_OFF, ETIR_S_C_CTL_SETRB)  */
d307 4
a310 4
      case ETIR_S_C_STA_PQ:
  	{
	  uquad dummy;
	  unsigned int psect;
d312 10
a321 10
	  psect = bfd_getl32 (ptr);
	  if (psect >= PRIV(section_count))
	    {
	      (*_bfd_error_handler) (_("Bad section index in ETIR_S_C_STA_PQ"));
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  dummy = bfd_getl64 (ptr+4);
	  _bfd_vms_push (abfd, dummy, psect);
        }
d324 1
a324 1
	/* all not supported  */
d326 3
a328 3
      case ETIR_S_C_STA_LI:
      case ETIR_S_C_STA_MOD:
      case ETIR_S_C_STA_CKARG:
d330 2
a331 2
	(*_bfd_error_handler) (_("Unsupported STA cmd %d"), cmd);
	return false;
d334 3
a336 3
      default:
	(*_bfd_error_handler) (_("Reserved STA cmd %d"), cmd);
	return false;
d366 1
a366 1
  _bfd_hexdump (8, ptr, 16, (int)ptr);
d381 2
a382 1
      image_write_b (abfd, dummy & 0xff);	/* FIXME: check top bits */
d394 2
a395 1
      image_write_w (abfd, dummy & 0xffff);	/* FIXME: check top bits */
d403 3
a405 2
      dummy += (PRIV(sections)[psect])->vma;
      image_write_l (abfd, dummy & 0xffffffff);/* FIXME: check top bits */
d413 1
a413 1
      dummy += (PRIV(sections)[psect])->vma;
d423 1
a423 1
	unsigned long size;
d426 2
a427 2
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
	while (dummy-- > 0L)
d441 3
a443 2
	entry = (vms_symbol_entry *)bfd_hash_lookup (PRIV(vms_symbol_table), name, false, false);
	if (entry == (vms_symbol_entry *)NULL)
d463 3
a465 2
	entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV(vms_symbol_table), name, false, false);
	if (entry == (vms_symbol_entry *)NULL)
d483 2
a484 2
    /* store offset to psect: pop stack, add low 32 bits to base of psect
       arg: -  */
d489 1
a489 1
	int psect;
d491 2
a492 2
	q = _bfd_vms_pop (abfd, &psect);
	q += (PRIV(sections)[psect])->vma;
d510 3
a512 2
      /* this code is 'reserved to digital' according to the openVMS linker manual,
	 however it is generated by the DEC C compiler and defined in the include file.
d523 3
a525 2
	entry = (vms_symbol_entry *)bfd_hash_lookup (PRIV(vms_symbol_table), name, false, false);
	if (entry == (vms_symbol_entry *)NULL)
d530 1
a530 1
	    image_write_l (abfd, (unsigned long)0);	/* FIXME, reloc */
d543 1
a543 1
    /* */
d549 1
a549 1
    /* */
d580 1
a580 1
  _bfd_hexdump (8, ptr, 16, (int)ptr);
d595 2
a596 2
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
d603 2
a604 2
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
d611 2
a612 2
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
d619 2
a620 2
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
d622 1
a622 1
	_bfd_vms_push (abfd, (uquad)0L, -1);
d630 2
a631 2
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
d638 2
a639 2
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
d646 2
a647 2
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
d654 1
a654 1
      op1 = (long)_bfd_vms_pop (abfd, NULL);
d661 1
a661 1
      op1 = (long)_bfd_vms_pop (abfd, NULL);
d668 1
a668 1
      (void)_bfd_vms_pop (abfd, NULL);
d672 1
a672 1
    /* arithmetic shift  */
d675 2
a676 2
      op1 = (long)_bfd_vms_pop (abfd, NULL);
      op2 = (long)_bfd_vms_pop (abfd, NULL);
d681 1
a681 1
      _bfd_vms_push (abfd, (uquad)op1, -1);
d699 2
a700 2
      if ((long)_bfd_vms_pop (abfd, NULL) & 0x01L)
	(void)_bfd_vms_pop (abfd, NULL);
d703 3
a705 3
	  op1 = (long)_bfd_vms_pop (abfd, NULL);
	  (void)_bfd_vms_pop (abfd, NULL);
	  _bfd_vms_push (abfd, (uquad)op1, -1);
d744 1
a744 1
  _bfd_hexdump (8, ptr, 16, (int)ptr);
d809 1
a809 1
  _bfd_hexdump (8, ptr, 16, (int)ptr);
d828 1
a828 1
      image_inc_ptr (abfd, 16);	/* skip entry,procval */
d905 4
a908 1
/* FIXME     (*_bfd_error_handler) ("ETIR_S_C_STC_xx: (%d) not supported", cmd); */
d934 1
a934 1
  name = bfd_malloc (strlen (sname) + 1);
d939 1
a939 1
  section = bfd_malloc (sizeof (asection));
d963 2
d969 4
a972 3
  PRIV(sections) = ((asection **)
		    bfd_realloc (PRIV(sections), (idx+1) * sizeof (asection *)));
  if (PRIV(sections) == 0)
d975 1
a975 1
  while (PRIV(section_count) <= idx)
d977 3
a979 2
      PRIV(sections)[PRIV(section_count)] = new_section (abfd, PRIV(section_count));
      if (PRIV(sections)[PRIV(section_count)] == 0)
d981 1
a981 1
      PRIV(section_count)++;
d1009 11
a1019 11
  /* stack */
      case TIR_S_C_STA_GBL:
	/*
	 * stack global
	 * arg: cs	symbol name
	 *
	 * stack 32 bit value of symbol (high bits set to 0)
	 */
	{
	  char *name;
	  vms_symbol_entry *entry;
d1021 1
a1021 1
	  name = _bfd_vms_save_counted_string (ptr);
d1023 3
a1025 3
          entry = _bfd_vms_enter_symbol (abfd, name);
	  if (entry == (vms_symbol_entry *)NULL)
	    return 0;
d1027 3
a1029 3
	  _bfd_vms_push (abfd, (unsigned long) (entry->symbol->value), -1);
	  ptr += *ptr + 1;
	}
d1032 52
a1083 20
      case TIR_S_C_STA_SB:
	/*
	 * stack signed byte
	 * arg: by	value
	 *
	 * stack byte value, sign extend to 32 bit
	 */
	_bfd_vms_push (abfd, (long)*ptr++, -1);
      break;

      case TIR_S_C_STA_SW:
	/*
	 * stack signed short word
	 * arg: sh	value
	 *
	 * stack 16 bit value, sign extend to 32 bit
	 */
	_bfd_vms_push (abfd, (long)bfd_getl16(ptr), -1);
	ptr += 2;
      break;
d1085 4
a1088 23
      case TIR_S_C_STA_LW:
	/*
	 * stack signed longword
	 * arg: lw	value
	 *
	 * stack 32 bit value
	 */
	_bfd_vms_push (abfd, (long)bfd_getl32 (ptr), -1);
	ptr += 4;
      break;

      case TIR_S_C_STA_PB:
      case TIR_S_C_STA_WPB:
	/*
	 * stack psect base plus byte offset (word index)
	 * arg: by	section index
	 *	(sh	section index)
	 *	by	signed byte offset
	 *
	 */
  	{
	  unsigned long dummy;
	  unsigned int psect;
d1090 5
a1094 7
	  if (cmd == TIR_S_C_STA_PB)
	    psect = *ptr++;
	  else
	    {
	      psect = bfd_getl16(ptr);
	      ptr += 2;
	    }
d1096 12
a1107 4
	  if (psect >= PRIV(section_count))
	    {
	      alloc_section (abfd, psect);
	    }
d1109 7
a1115 18
	  dummy = (long)*ptr++;
	  dummy += (PRIV(sections)[psect])->vma;
	  _bfd_vms_push (abfd, dummy, psect);
        }
      break;

      case TIR_S_C_STA_PW:
      case TIR_S_C_STA_WPW:
	/*
	 * stack psect base plus word offset (word index)
	 * arg: by	section index
	 *	(sh	section index)
	 *	sh	signed short offset
	 *
	 */
  	{
	  unsigned long dummy;
	  unsigned int psect;
d1117 4
a1120 7
	  if (cmd == TIR_S_C_STA_PW)
	    psect = *ptr++;
	  else
	    {
	      psect = bfd_getl16(ptr);
	      ptr += 2;
	    }
d1122 5
a1126 4
	  if (psect >= PRIV(section_count))
	    {
	      alloc_section (abfd, psect);
	    }
d1128 12
a1139 18
	  dummy = bfd_getl16(ptr); ptr+=2;
	  dummy += (PRIV(sections)[psect])->vma;
	  _bfd_vms_push (abfd, dummy, psect);
        }
      break;

      case TIR_S_C_STA_PL:
      case TIR_S_C_STA_WPL:
	/*
	 * stack psect base plus long offset (word index)
	 * arg: by	section index
	 *	(sh	section index)
	 *	lw	signed longword offset
	 *
	 */
  	{
	  unsigned long dummy;
	  unsigned int psect;
d1141 7
a1147 7
	  if (cmd == TIR_S_C_STA_PL)
	    psect = *ptr++;
	  else
	    {
	      psect = bfd_getl16(ptr);
	      ptr += 2;
	    }
d1149 4
a1152 4
	  if (psect >= PRIV(section_count))
	    {
	      alloc_section (abfd, psect);
	    }
d1154 4
a1157 25
	  dummy = bfd_getl32 (ptr); ptr += 4;
	  dummy += (PRIV(sections)[psect])->vma;
	  _bfd_vms_push (abfd, dummy, psect);
        }
      break;

      case TIR_S_C_STA_UB:
	/*
	 * stack unsigned byte
	 * arg: by	value
	 *
	 * stack byte value
	 */
	_bfd_vms_push (abfd, (unsigned long)*ptr++, -1);
      break;

      case TIR_S_C_STA_UW:
	/*
	 * stack unsigned short word
	 * arg: sh	value
	 *
	 * stack 16 bit value
	 */
	_bfd_vms_push (abfd, (unsigned long)bfd_getl16(ptr), -1);
	ptr += 2;
d1160 55
a1214 34
      case TIR_S_C_STA_BFI:
	/*
	 * stack byte from image
	 * arg: -
	 *
	 */
	/*FALLTHRU*/
      case TIR_S_C_STA_WFI:
	/*
	 * stack byte from image
	 * arg: -
	 *
	 */
	/*FALLTHRU*/
      case TIR_S_C_STA_LFI:
	/*
	 * stack byte from image
	 * arg: -
	 *
	 */
        (*_bfd_error_handler) (_("Stack-from-image not implemented"));
	return NULL;

      case TIR_S_C_STA_EPM:
	/*
	 * stack entry point mask
	 * arg: cs	symbol name
	 *
	 * stack (unsigned) entry point mask of symbol
	 * err if symbol is no entry point
	 */
	{
	  char *name;
	  vms_symbol_entry *entry;
d1216 9
a1224 9
	  name = _bfd_vms_save_counted_string (ptr);
	  entry = _bfd_vms_enter_symbol (abfd, name);
	  if (entry == (vms_symbol_entry *)NULL)
	    return 0;

          (*_bfd_error_handler) (_("Stack-entry-mask not fully implemented"));
	  _bfd_vms_push (abfd, 0L, -1);
	  ptr += *ptr + 1;
	}
d1227 24
a1250 13
      case TIR_S_C_STA_CKARG:
	/*
	 * compare procedure argument
	 * arg: cs	symbol name
	 *	by	argument index
	 *	da	argument descriptor
	 *
	 * compare argument descriptor with symbol argument (ARG$V_PASSMECH)
	 * and stack TRUE (args match) or FALSE (args dont match) value
	 */
        (*_bfd_error_handler) (_("PASSMECH not fully implemented"));
	_bfd_vms_push (abfd, 1L, -1);
	break;
d1252 10
a1261 20
      case TIR_S_C_STA_LSY:
	/*
	 * stack local symbol value
	 * arg:	sh	environment index
	 *	cs	symbol name
	 */
	{
	  int envidx;
	  char *name;
	  vms_symbol_entry *entry;

	  envidx = bfd_getl16(ptr); ptr += 2;
	  name = _bfd_vms_save_counted_string (ptr);
	  entry = _bfd_vms_enter_symbol (abfd, name);
	  if (entry == (vms_symbol_entry *)NULL)
	    return 0;
          (*_bfd_error_handler) (_("Stack-local-symbol not fully implemented"));
	  _bfd_vms_push (abfd, 0L, -1);
	  ptr += *ptr + 1;
	}
d1264 25
a1288 11
      case TIR_S_C_STA_LIT:
	/*
	 * stack literal
 	 * arg:	by	literal index
	 *
	 * stack literal
	 */
	ptr++;
	_bfd_vms_push (abfd, 0L, -1);
	(*_bfd_error_handler) (_("Stack-literal not fully implemented"));
	break;
d1290 10
a1299 23
      case TIR_S_C_STA_LEPM:
	/*
	 * stack local symbol entry point mask
	 * arg:	sh	environment index
	 *	cs	symbol name
	 *
	 * stack (unsigned) entry point mask of symbol
	 * err if symbol is no entry point
	 */
	{
	  int envidx;
	  char *name;
	  vms_symbol_entry *entry;

	  envidx = bfd_getl16(ptr); ptr += 2;
	  name = _bfd_vms_save_counted_string (ptr);
	  entry = _bfd_vms_enter_symbol (abfd, name);
	  if (entry == (vms_symbol_entry *)NULL)
	    return 0;
	  (*_bfd_error_handler) (_("Stack-local-symbol-entry-point-mask not fully implemented"));
	  _bfd_vms_push (abfd, 0L, -1);
	  ptr += *ptr + 1;
	}
d1302 3
a1304 3
      default:
	(*_bfd_error_handler) (_("Reserved STA cmd %d"), ptr[-1]);
	return NULL;
d1306 1
a1306 1
  }
d1335 115
a1449 99
      case TIR_S_C_STO_SB:
	/*
	 * store signed byte: pop stack, write byte
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_b (abfd, dummy & 0xff);	/* FIXME: check top bits */
      break;

      case TIR_S_C_STO_SW:
	/*
	 * store signed word: pop stack, write word
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_w (abfd, dummy & 0xffff);	/* FIXME: check top bits */
      break;

      case TIR_S_C_STO_LW:
	/*
	 * store longword: pop stack, write longword
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_l (abfd, dummy & 0xffffffff);/* FIXME: check top bits */
      break;

      case TIR_S_C_STO_BD:
	/*
	 * store byte displaced: pop stack, sub lc+1, write byte
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	dummy -= ((PRIV(sections)[psect])->vma + 1);
	image_write_b (abfd, dummy & 0xff);/* FIXME: check top bits */
      break;

      case TIR_S_C_STO_WD:
	/*
	 * store word displaced: pop stack, sub lc+2, write word
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	dummy -= ((PRIV(sections)[psect])->vma + 2);
	image_write_w (abfd, dummy & 0xffff);/* FIXME: check top bits */
      break;
      case TIR_S_C_STO_LD:
	/*
	 * store long displaced: pop stack, sub lc+4, write long
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	dummy -= ((PRIV(sections)[psect])->vma + 4);
	image_write_l (abfd, dummy & 0xffffffff);/* FIXME: check top bits */
      break;
      case TIR_S_C_STO_LI:
	/*
	 * store short literal: pop stack, write byte
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_b (abfd, dummy & 0xff);/* FIXME: check top bits */
      break;
      case TIR_S_C_STO_PIDR:
	/*
	 * store position independent data reference: pop stack, write longword
	 * arg: -
	 * FIXME: incomplete !
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_l (abfd, dummy & 0xffffffff);
      break;
      case TIR_S_C_STO_PICR:
	/*
	 * store position independent code reference: pop stack, write longword
	 * arg: -
	 * FIXME: incomplete !
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	image_write_b (abfd, 0x9f);
	image_write_l (abfd, dummy & 0xffffffff);
      break;
      case TIR_S_C_STO_RIVB:
	/*
	 * store repeated immediate variable bytes
	 * 1-byte count n field followed by n bytes of data
	 * pop stack, write n bytes <stack> times
	 */
	size = *ptr++;
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
	while (dummy-- > 0L)
	  image_dump (abfd, ptr, size, 0);
	ptr += size;
	break;
      case TIR_S_C_STO_B:
	/*
	 * store byte from top longword
	 */
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
d1451 8
a1458 6
	break;
      case TIR_S_C_STO_W:
	/*
	 * store word from top longword
	 */
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
d1460 1
a1460 19
	break;
      case TIR_S_C_STO_RB:
	/*
	 * store repeated byte from top longword
	 */
	size = (unsigned long)_bfd_vms_pop (abfd, NULL);
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
	while (size-- > 0)
	  image_write_b (abfd, dummy & 0xff);
	break;
      case TIR_S_C_STO_RW:
	/*
	 * store repeated word from top longword
	 */
	size = (unsigned long)_bfd_vms_pop (abfd, NULL);
	dummy = (unsigned long)_bfd_vms_pop (abfd, NULL);
	while (size-- > 0)
	  image_write_w (abfd, dummy & 0xffff);
	break;
d1462 10
a1471 10
      case TIR_S_C_STO_RSB:
      case TIR_S_C_STO_RSW:
      case TIR_S_C_STO_RL:
      case TIR_S_C_STO_VPS:
      case TIR_S_C_STO_USB:
      case TIR_S_C_STO_USW:
      case TIR_S_C_STO_RUB:
      case TIR_S_C_STO_RUW:
      case TIR_S_C_STO_PIRR:
	(*_bfd_error_handler) (_("Unimplemented STO cmd %d"), ptr[-1]);
d1474 2
a1475 2
      default:
	(*_bfd_error_handler) (_("Reserved STO cmd %d"), ptr[-1]);
d1477 1
a1477 1
  }
d1502 151
a1652 44
  /* operation */
      case TIR_S_C_OPR_NOP:
	/*
	 * no-op
	 */
      break;

      case TIR_S_C_OPR_ADD:
	/*
	 * add
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long) (op1 + op2), -1);
      break;

      case TIR_S_C_OPR_SUB:
	/*
	 * subtract
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long) (op2 - op1), -1);
      break;

      case TIR_S_C_OPR_MUL:
	/*
	 * multiply
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long) (op1 * op2), -1);
      break;

      case TIR_S_C_OPR_DIV:
	/*
	 * divide
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	if (op2 == 0)
	  _bfd_vms_push (abfd, (unsigned long)0L, -1);
	else
	  _bfd_vms_push (abfd, (unsigned long) (op2 / op1), -1);
d1655 5
a1659 105
      case TIR_S_C_OPR_AND:
	/*
	 * logical and
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long) (op1 & op2), -1);
      break;

      case TIR_S_C_OPR_IOR:
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	/*
	 * logical inclusive or
	 */
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long) (op1 | op2), -1);
      break;

      case TIR_S_C_OPR_EOR:
	/*
	 * logical exclusive or
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long) (op1 ^ op2), -1);
      break;

      case TIR_S_C_OPR_NEG:
	/*
	 * negate
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long) (-op1), -1);
      break;

      case TIR_S_C_OPR_COM:
	/*
	 * complement
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	_bfd_vms_push (abfd, (unsigned long) (op1 ^ -1L), -1);
      break;

      case TIR_S_C_OPR_INSV:
	/*
	 * insert field
	 */
	(void)_bfd_vms_pop (abfd, NULL);
	(*_bfd_error_handler)  ("TIR_S_C_OPR_INSV incomplete");
      break;

      case TIR_S_C_OPR_ASH:
	/*
	 * arithmetic shift
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	if (HIGHBIT(op1))		/* shift right */
	  op2 >>= op1;
	else			/* shift left */
	  op2 <<= op1;
	_bfd_vms_push (abfd, (unsigned long)op2, -1);
	(*_bfd_error_handler) (_("TIR_S_C_OPR_ASH incomplete"));
      break;

      case TIR_S_C_OPR_USH:
	/*
	 * unsigned shift
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	if (HIGHBIT(op1))		/* shift right */
	  op2 >>= op1;
	else			/* shift left */
	  op2 <<= op1;
	_bfd_vms_push (abfd, (unsigned long)op2, -1);
	(*_bfd_error_handler) (_("TIR_S_C_OPR_USH incomplete"));
      break;

      case TIR_S_C_OPR_ROT:
	/*
	 * rotate
	 */
	op1 = (long)_bfd_vms_pop (abfd, NULL);
	op2 = (long)_bfd_vms_pop (abfd, NULL);
	if (HIGHBIT(0))		/* shift right */
	  op2 >>= op1;
	else			/* shift left */
	  op2 <<= op1;
	_bfd_vms_push (abfd, (unsigned long)op2, -1);
	(*_bfd_error_handler) (_("TIR_S_C_OPR_ROT incomplete"));
      break;

      case TIR_S_C_OPR_SEL:
	/*
	 * select
	 */
	if ((long)_bfd_vms_pop (abfd, NULL) & 0x01L)
	  (void)_bfd_vms_pop (abfd, NULL);
	else
	  {
	    op1 = (long)_bfd_vms_pop (abfd, NULL);
	    (void)_bfd_vms_pop (abfd, NULL);
	    _bfd_vms_push (abfd, (unsigned long)op1, -1);
	  }
d1662 5
a1666 12
      case TIR_S_C_OPR_REDEF:
	/*
	 * redefine symbol to current location
	 */
	(*_bfd_error_handler) (_("TIR_S_C_OPR_REDEF not supported"));
      break;

      case TIR_S_C_OPR_DFLIT:
	/*
	 * define a literal
	 */
	(*_bfd_error_handler) (_("TIR_S_C_OPR_DFLIT not supported"));
d1669 2
a1670 2
      default:
	(*_bfd_error_handler) (_("Reserved OPR cmd %d"), ptr[-1]);
d1694 27
a1720 11
      case TIR_S_C_CTL_SETRB:
	/*
	 * set relocation base: pop stack, set image location counter
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	if (psect >= PRIV(section_count))
	  {
	    alloc_section (abfd, psect);
	  }
	image_set_ptr (abfd, psect, dummy);
d1722 7
a1728 23
      case TIR_S_C_CTL_AUGRB:
	/*
	 * augment relocation base: increment image location counter by offset
	 * arg: lw	offset value
	 */
	dummy = bfd_getl32 (ptr);
	image_inc_ptr (abfd, dummy);
      break;
      case TIR_S_C_CTL_DFLOC:
	/*
	 * define location: pop index, save location counter under index
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, NULL);
	(*_bfd_error_handler) (_("TIR_S_C_CTL_DFLOC not fully implemented"));
      break;
      case TIR_S_C_CTL_STLOC:
	/*
	 * set location: pop index, restore location counter from index
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	(*_bfd_error_handler) (_("TIR_S_C_CTL_STLOC not fully implemented"));
d1731 6
a1736 6
	/*
	 * stack defined location: pop index, push location counter from index
	 * arg: -
	 */
	dummy = _bfd_vms_pop (abfd, &psect);
	(*_bfd_error_handler) (_("TIR_S_C_CTL_STKDL not fully implemented"));
d1739 3
a1741 3
        (*_bfd_error_handler) (_("Reserved CTL cmd %d"), ptr[-1]);
	break;
  }
d1752 2
a1753 1
  struct {
d1757 8
a1764 6
  } tir_table[] = {
    { 0,		 TIR_S_C_MAXSTACOD, tir_sta }
   ,{ TIR_S_C_MINSTOCOD, TIR_S_C_MAXSTOCOD, tir_sto }
   ,{ TIR_S_C_MINOPRCOD, TIR_S_C_MAXOPRCOD, tir_opr }
   ,{ TIR_S_C_MINCTLCOD, TIR_S_C_MAXCTLCOD, tir_ctl }
   ,{ -1, -1, NULL }
d1770 1
a1770 1
  _bfd_hexdump (8, ptr, 16, (int)ptr);
d1784 1
a1784 1
	    && (*ptr <= tir_table[i].maxcod))
d1809 2
a1810 1
  static struct {
d1813 4
a1816 2
    boolean (*explain) PARAMS((bfd *, int, unsigned char *));
  } etir_table[] = {
d1829 1
a1829 1
  _bfd_hexdump (8, ptr, 16, (int)ptr);
d1835 1
a1835 1
	&& (cmd <= etir_table[i].maxcod))
d1930 13
a1942 13
      case EOBJ_S_C_ETIR:
	PRIV(vms_rec) += 4;	/* skip type, size */
	PRIV(rec_size) -= 4;
	result = analyze_etir (abfd, PRIV(vms_rec), PRIV(rec_size));
	break;
      case OBJ_S_C_TIR:
	PRIV(vms_rec) += 1;	/* skip type */
	PRIV(rec_size) -= 1;
	result = analyze_tir (abfd, PRIV(vms_rec), PRIV(rec_size));
	break;
      default:
	result = -1;
	break;
d2025 1
a2025 1
  _bfd_hexdump (9, sptr->contents, (int)sptr->size, (int)vaddr);
d2052 1
a2052 1
      _bfd_hexdump (10, cptr, (int)size, (int)vaddr);
d2081 2
a2082 2
  _bfd_vms_output_long (abfd, (unsigned long)index);
  _bfd_vms_output_quad (abfd, (uquad)offset);
d2118 1
a2118 1
  PRIV(vms_linkage_index) = 1;
d2128 3
a2130 1
      _bfd_vms_debug (4, "writing %d. section '%s' (%d bytes)\n", section->index, section->name, (int) (section->_raw_size));
d2151 6
a2156 6
			      (*(*rptr)->sym_ptr_ptr)->name,
			      (*(*rptr)->sym_ptr_ptr)->section->name,
			      (long) (*(*rptr)->sym_ptr_ptr)->value,
			      (*rptr)->address, (*rptr)->addend,
			      bfd_get_reloc_size((*rptr)->howto),
			      (*rptr)->howto->name);
d2164 1
a2164 1
	&& (! bfd_is_com_section (section)))
d2180 1
a2180 1
	  while (sptr != NULL)				/* one STA_PQ, CTL_SETRB per vms_section */
d2183 1
a2183 1
	      if (section->flags & SEC_RELOC)			/* check for relocs */
d2191 1
a2191 1
		      if (sptr->offset < addr)		/* sptr starts before reloc */
d2194 1
a2194 1
			  if (sptr->size <= before)		/* complete before */
d2211 1
a2211 1
		      else if (sptr->offset == addr)	/* sptr starts at reloc */
d2225 4
a2228 3
				    if (_bfd_vms_output_check (abfd,
								strlen((char *)sym->name))
					< 0)
d2236 5
a2240 4
							    ETIR_S_C_STO_GBL_LW,
							    -1);
				    _bfd_vms_output_counted (abfd,
							      _bfd_vms_length_hash_symbol (abfd, sym->name, EOBJ_S_C_SYMSIZ));
d2253 2
a2254 2
							    ETIR_S_C_STA_LW,
							    -1);
d2256 1
a2256 1
							   (uquad)sym->value);
d2259 2
a2260 2
							    ETIR_S_C_STO_LW,
							    -1);
d2273 2
a2274 2
							    ETIR_S_C_STA_PQ,
							    -1);
d2276 1
a2276 1
							   (unsigned long) (sec->index));
d2278 2
a2279 2
							   ((uquad) (*rptr)->addend
							    + (uquad)sym->value));
d2282 2
a2283 2
							    ETIR_S_C_STO_LW,
							    -1);
d2293 3
a2295 3
				    if (_bfd_vms_output_check (abfd,
								strlen((char *)sym->name))
					< 0)
d2303 5
a2307 4
							    ETIR_S_C_STO_GBL,
							    -1);
				    _bfd_vms_output_counted (abfd,
							      _bfd_vms_length_hash_symbol (abfd, sym->name, EOBJ_S_C_SYMSIZ));
d2320 2
a2321 2
							    ETIR_S_C_STA_QW,
							    -1);
d2323 1
a2323 1
							   (uquad)sym->value);
d2326 2
a2327 2
							    ETIR_S_C_STO_QW,
							    -1);
d2340 2
a2341 2
							    ETIR_S_C_STA_PQ,
							    -1);
d2343 1
a2343 1
							   (unsigned long) (sec->index));
d2345 2
a2346 2
							   ((uquad) (*rptr)->addend
							    + (uquad)sym->value));
d2349 2
a2350 2
							    ETIR_S_C_STO_OFF,
							    -1);
d2359 1
d2366 9
a2374 3
				vms_output_begin(abfd, ETIR_S_C_STO_HINT_GBL, -1);
				vms_output_long(abfd, (unsigned long) (sec->index));
				vms_output_quad(abfd, (uquad)addr);
d2376 1
a2376 2
				vms_output_counted(abfd, _bfd_vms_length_hash_symbol (abfd, sym->name, EOBJ_S_C_SYMSIZ));
				vms_output_flush(abfd);
d2382 2
d2391 2
a2392 2
							ETIR_S_C_STC_LP_PSB,
							-1);
d2394 5
a2398 4
						       (unsigned long)PRIV(vms_linkage_index));
				PRIV(vms_linkage_index) += 2;
				_bfd_vms_output_counted (abfd,
							  _bfd_vms_length_hash_symbol (abfd, sym->name, EOBJ_S_C_SYMSIZ));
d2406 3
a2408 3
				if (_bfd_vms_output_check (abfd,
							    strlen((char *)sym->name))
				    < 0)
d2416 5
a2420 4
							ETIR_S_C_STO_CA,
							-1);
				_bfd_vms_output_counted (abfd,
							  _bfd_vms_length_hash_symbol (abfd, sym->name, EOBJ_S_C_SYMSIZ));
d2446 1
a2446 1
		      else					/* sptr starts after reloc */
d2448 1
a2448 1
			  i--;				/* check next reloc */
d2452 1
a2452 1
		      if (i==0)				/* all reloc checked */
d2456 2
a2457 1
			      sto_imm (abfd, sptr, vaddr, section->index);	/* dump rest */
d2464 1
a2464 1
	      else						/* no relocs, just dump */
d2481 1
a2481 1
  _bfd_vms_output_alignment(abfd, 2);
@


1.5
log
@Update copyright notices
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d52 11
@


1.4
log
@2000-12-25  Kazu Hirata  <kazu@@hxi.com>

	* vms-tir.c: Fix formatting.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.4.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@a26 1

a97 1

a113 1

a135 1

a153 1

a173 1

a193 1

d218 1
a218 1
  
d220 1
a220 1
  
d223 1
a223 1
  
d264 1
a264 1
	      _bfd_vms_push (abfd, (uquad)(entry->symbol->value), -1);
a331 1

d334 1
a334 1
  
d336 1
a336 1
  
d339 1
a339 1
  
d433 1
a433 1
	  image_write_q (abfd, (uquad)(entry->symbol->value));	/* FIXME, reloc */
d454 1
a454 1
	  image_write_q (abfd, (uquad)(entry->symbol->value));	/* FIXME, reloc */
d513 1
a513 1
	  image_write_l (abfd, (unsigned long)(entry->symbol->value));	/* FIXME, reloc */
d547 1
a547 1
  
d577 1
a577 1
      _bfd_vms_push (abfd, (uquad)(op1 + op2), -1);
d585 1
a585 1
      _bfd_vms_push (abfd, (uquad)(op2 - op1), -1);
d593 1
a593 1
      _bfd_vms_push (abfd, (uquad)(op1 * op2), -1);
d604 1
a604 1
	_bfd_vms_push (abfd, (uquad)(op2 / op1), -1);
d612 1
a612 1
      _bfd_vms_push (abfd, (uquad)(op1 & op2), -1);
d620 1
a620 1
      _bfd_vms_push (abfd, (uquad)(op1 | op2), -1);
d628 1
a628 1
      _bfd_vms_push (abfd, (uquad)(op1 ^ op2), -1);
d635 1
a635 1
      _bfd_vms_push (abfd, (uquad)(-op1), -1);
d642 1
a642 1
      _bfd_vms_push (abfd, (uquad)(op1 ^ -1L), -1);
d709 1
a710 2
/* control commands
  
d776 1
a777 2
/* store conditional commands
  
a896 1

a934 1

a959 1

d1000 1
a1000 1
	  _bfd_vms_push (abfd, (unsigned long)(entry->symbol->value), -1);
a1281 1

a1452 1

d1486 1
a1486 1
	_bfd_vms_push (abfd, (unsigned long)(op1 + op2), -1);
d1495 1
a1495 1
	_bfd_vms_push (abfd, (unsigned long)(op2 - op1), -1);
d1504 1
a1504 1
	_bfd_vms_push (abfd, (unsigned long)(op1 * op2), -1);
d1516 1
a1516 1
	  _bfd_vms_push (abfd, (unsigned long)(op2 / op1), -1);
d1525 1
a1525 1
	_bfd_vms_push (abfd, (unsigned long)(op1 & op2), -1);
d1534 1
a1534 1
	_bfd_vms_push (abfd, (unsigned long)(op1 | op2), -1);
d1543 1
a1543 1
	_bfd_vms_push (abfd, (unsigned long)(op1 ^ op2), -1);
d1551 1
a1551 1
	_bfd_vms_push (abfd, (unsigned long)(-op1), -1);
d1559 1
a1559 1
	_bfd_vms_push (abfd, (unsigned long)(op1 ^ -1L), -1);
a1647 1

a1715 1

d1726 1
a1726 1
    unsigned char * (*explain)(bfd *, unsigned char *);
d1751 1
a1751 1
	  if ( (tir_table[i].mincod <= *ptr) 
a1768 1

d1799 1
a1799 1
      if ( (etir_table[i].mincod <= cmd) 
a1814 1

a1841 1

d1878 1
a1879 2
/* process ETIR record
  
a1912 1

d1915 1
a1915 1
  
a1930 1

d1933 1
a1933 1
  
a1947 1

d1950 1
a1950 1
  
d2011 1
a2011 1
      _bfd_vms_output_long (abfd, (unsigned long)(size));
a2055 1

d2062 1
a2062 1
  _bfd_vms_output_end (abfd); 
d2093 1
a2093 1
      _bfd_vms_debug (4, "writing %d. section '%s' (%d bytes)\n", section->index, section->name, (int)(section->_raw_size));
d2116 1
a2116 1
			      (long)(*(*rptr)->sym_ptr_ptr)->value,
d2138 1
a2138 1
	  vaddr = (bfd_vma)(sptr->offset);
d2237 1
a2237 1
							   (unsigned long)(sec->index));
d2239 1
a2239 1
							   ((uquad)(*rptr)->addend
d2303 1
a2303 1
							   (unsigned long)(sec->index));
d2305 1
a2305 1
							   ((uquad)(*rptr)->addend
d2326 1
a2326 1
				vms_output_long(abfd, (unsigned long)(sec->index));
a2433 1

a2446 1

@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d64 1
a64 1
  if ((offset + size) > PRIV(image_section)->_raw_size)
d124 1
a124 1
    int offset;
d304 1
a304 1
	  int psect;
d562 1
a562 1
     unsigned char *ptr;
d794 1
a794 1
     unsigned char *ptr;
d910 1
a910 1
     bfd *abfd;
d950 1
a950 1
     int idx;
d1061 1
a1061 1
	  int psect;
d1093 1
a1093 1
	  int psect;
d1125 1
a1125 1
	  int psect;
d1673 1
a1673 1
  int psect;
d1943 1
a1943 1
     int objtype;
d1961 2
a1962 2
     bfd *abfd;
     int objtype;
d1979 2
a1980 2
     bfd *abfd;
     int objtype;
d2095 1
a2095 1
     int objtype;
d2178 1
a2178 1
		      int len = bfd_get_reloc_size ((*rptr)->howto);
d2181 1
a2181 1
			  int before = addr - sptr->offset;
d2464 2
a2465 2
     bfd *abfd;
     int objtype;
d2479 2
a2480 2
     bfd *abfd;
     int objtype;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998 Free Software Foundation, Inc.
a951 2
  asection *section;

@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

