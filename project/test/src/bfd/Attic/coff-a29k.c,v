head	1.20;
access;
symbols
	binutils-csl-sourcerygxx-3_4_4-32:1.17
	binutils-csl-sourcerygxx-3_4_4-25:1.17
	binutils-csl-wrs-linux-3_4_4-24:1.17
	binutils-csl-wrs-linux-3_4_4-23:1.17
	binutils-csl-wrs-linux-3_4_4-22:1.17
	binutils-csl-wrs-linux-3_4_4-21:1.17
	binutils-csl-wrs-linux-3_4_4-20:1.17
	binutils-csl-gxxpro-3_4-branch:1.17.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.17
	binutils-2_16_1:1.17
	msnyder-tracepoint-checkpoint-branch:1.19.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.19
	gdb-csl-arm-20050325-2005-q1b:1.17
	binutils-csl-arm-2005q1b:1.17
	binutils-2_16:1.17
	gdb-csl-arm-20050325-2005-q1a:1.17
	binutils-csl-arm-2005q1a:1.17
	csl-arm-20050325-branch:1.17.0.6
	csl-arm-20050325-branchpoint:1.17
	binutils-csl-arm-2005q1-branch:1.17.0.4
	binutils-csl-arm-2005q1-branchpoint:1.17
	binutils-2_16-branch:1.17.0.2
	binutils-2_16-branchpoint:1.17
	csl-arm-2004-q3d:1.16
	gdb_6_3-20041109-release:1.15
	gdb_6_3-branch:1.15.0.24
	gdb_6_3-20041019-branchpoint:1.15
	csl-arm-2004-q3:1.15
	drow_intercu-merge-20040921:1.15
	drow_intercu-merge-20040915:1.15
	jimb-gdb_6_2-e500-branch:1.15.0.26
	jimb-gdb_6_2-e500-branchpoint:1.15
	gdb_6_2-20040730-release:1.15
	gdb_6_2-branch:1.15.0.22
	gdb_6_2-2004-07-10-gmt-branchpoint:1.15
	gdb_6_1_1-20040616-release:1.15
	binutils-2_15:1.15
	binutils-2_15-branchpoint:1.15
	csl-arm-2004-q1a:1.15
	csl-arm-2004-q1:1.15
	gdb_6_1-2004-04-05-release:1.15
	drow_intercu-merge-20040402:1.15
	drow_intercu-merge-20040327:1.15
	ezannoni_pie-20040323-branch:1.15.0.20
	ezannoni_pie-20040323-branchpoint:1.15
	cagney_tramp-20040321-mergepoint:1.15
	cagney_tramp-20040309-branch:1.15.0.18
	cagney_tramp-20040309-branchpoint:1.15
	gdb_6_1-branch:1.15.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.15
	drow_intercu-20040221-branch:1.15.0.14
	drow_intercu-20040221-branchpoint:1.15
	binutils-2_15-branch:1.15.0.12
	cagney_bfdfile-20040213-branch:1.15.0.10
	cagney_bfdfile-20040213-branchpoint:1.15
	drow-cplus-merge-20040208:1.15
	carlton_dictionary-20040126-merge:1.15
	cagney_bigcore-20040122-branch:1.15.0.8
	cagney_bigcore-20040122-branchpoint:1.15
	drow-cplus-merge-20040113:1.15
	csl-arm-2003-q4:1.15
	drow-cplus-merge-20031224:1.15
	drow-cplus-merge-20031220:1.15
	carlton_dictionary-20031215-merge:1.15
	drow-cplus-merge-20031214:1.15
	carlton-dictionary-20031111-merge:1.15
	gdb_6_0-2003-10-04-release:1.14
	kettenis_sparc-20030918-branch:1.15.0.6
	kettenis_sparc-20030918-branchpoint:1.15
	carlton_dictionary-20030917-merge:1.15
	ezannoni_pie-20030916-branchpoint:1.15
	ezannoni_pie-20030916-branch:1.15.0.4
	cagney_x86i386-20030821-branch:1.15.0.2
	cagney_x86i386-20030821-branchpoint:1.15
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.14.0.6
	gdb_6_0-2003-06-23-branchpoint:1.14
	jimb-ppc64-linux-20030613-branch:1.14.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.14
	binutils-2_14:1.13
	cagney_convert-20030606-branch:1.14.0.2
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.13.0.30
	cagney_writestrings-20030508-branchpoint:1.13
	jimb-ppc64-linux-20030528-branch:1.13.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.13
	carlton_dictionary-20030523-merge:1.13
	cagney_fileio-20030521-branch:1.13.0.26
	cagney_fileio-20030521-branchpoint:1.13
	kettenis_i386newframe-20030517-mergepoint:1.13
	jimb-ppc64-linux-20030509-branch:1.13.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.13
	kettenis_i386newframe-20030504-mergepoint:1.13
	carlton_dictionary-20030430-merge:1.13
	binutils-2_14-branch:1.13.0.22
	binutils-2_14-branchpoint:1.13
	kettenis_i386newframe-20030419-branch:1.13.0.20
	kettenis_i386newframe-20030419-branchpoint:1.13
	carlton_dictionary-20030416-merge:1.13
	cagney_frameaddr-20030409-mergepoint:1.13
	kettenis_i386newframe-20030406-branch:1.13.0.18
	kettenis_i386newframe-20030406-branchpoint:1.13
	cagney_frameaddr-20030403-branchpoint:1.13
	cagney_frameaddr-20030403-branch:1.13.0.16
	cagney_framebase-20030330-mergepoint:1.13
	cagney_framebase-20030326-branch:1.13.0.14
	cagney_framebase-20030326-branchpoint:1.13
	cagney_lazyid-20030317-branch:1.13.0.12
	cagney_lazyid-20030317-branchpoint:1.13
	kettenis-i386newframe-20030316-mergepoint:1.13
	offbyone-20030313-branch:1.13.0.10
	offbyone-20030313-branchpoint:1.13
	kettenis-i386newframe-20030308-branch:1.13.0.8
	kettenis-i386newframe-20030308-branchpoint:1.13
	carlton_dictionary-20030305-merge:1.13
	cagney_offbyone-20030303-branch:1.13.0.6
	cagney_offbyone-20030303-branchpoint:1.13
	carlton_dictionary-20030207-merge:1.13
	interps-20030202-branch:1.13.0.4
	interps-20030202-branchpoint:1.13
	cagney-unwind-20030108-branch:1.13.0.2
	cagney-unwind-20030108-branchpoint:1.13
	binutils-2_13_2_1:1.12
	binutils-2_13_2:1.12
	carlton_dictionary-20021223-merge:1.13
	gdb_5_3-2002-12-12-release:1.12
	carlton_dictionary-20021115-merge:1.12
	binutils-2_13_1:1.12
	kseitz_interps-20021105-merge:1.12
	kseitz_interps-20021103-merge:1.12
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.12
	drow-cplus-branch:1.12.0.14
	drow-cplus-branchpoint:1.12
	kseitz_interps-20020930-merge:1.12
	carlton_dictionary-20020927-merge:1.12
	carlton_dictionary-branch:1.12.0.12
	carlton_dictionary-20020920-branchpoint:1.12
	sid-20020905-branchpoint:1.12
	sid-20020905-branch:1.12.0.10
	gdb_5_3-branch:1.12.0.8
	gdb_5_3-2002-09-04-branchpoint:1.12
	kseitz_interps-20020829-merge:1.12
	cagney_sysregs-20020825-branch:1.12.0.6
	cagney_sysregs-20020825-branchpoint:1.12
	readline_4_3-import-branch:1.12.0.4
	readline_4_3-import-branchpoint:1.12
	binutils-2_13:1.12
	gdb_5_2_1-2002-07-23-release:1.11
	binutils-2_13-branchpoint:1.12
	binutils-2_13-branch:1.12.0.2
	kseitz_interps-20020528-branch:1.11.0.10
	kseitz_interps-20020528-branchpoint:1.11
	cagney_regbuf-20020515-branch:1.11.0.8
	cagney_regbuf-20020515-branchpoint:1.11
	binutils-2_12_1:1.11
	jimb-macro-020506-branch:1.11.0.6
	jimb-macro-020506-branchpoint:1.11
	gdb_5_2-2002-04-29-release:1.11
	binutils-2_12:1.11
	gdb_5_2-branch:1.11.0.4
	gdb_5_2-2002-03-03-branchpoint:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.11
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.4
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.2
	gdb_5_1-2001-07-29-branchpoint:1.9
	binutils-2_11_2:1.8.2.1
	binutils-2_11_1:1.8.2.1
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	insight-precleanup-2001-01-01:1.7
	binutils-2_10_1:1.4
	binutils-2_10:1.4
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.4
	gdb_5_0-2000-04-10-branchpoint:1.4
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.19
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2005.08.18.03.59.22;	author amodra;	state dead;
branches;
next	1.19;

1.19
date	2005.05.04.15.53.01;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.03.11.40.56;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.21.15.28.15;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.25.06.40.18;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.04.10.47.30;	author sveinse;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.30.08.39.35;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.25.06.21.47;	author amodra;	state Exp;
branches
	1.12.12.1
	1.12.14.1;
next	1.11;

1.11
date	2001.09.18.09.57.21;	author amodra;	state Exp;
branches
	1.11.10.1;
next	1.10;

1.10
date	2001.08.25.09.47.34;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.21.19.19.59;	author kazu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.11.22.01.08.53;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.09.01.37.44;	author kazu;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.13.01.08.04;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches;
next	1.3;

1.3
date	99.07.19.14.55.15;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.10.28.28;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	;

1.11.10.1
date	2002.07.22.21.46.38;	author kseitz;	state Exp;
branches;
next	;

1.12.12.1
date	2002.12.23.19.37.24;	author carlton;	state Exp;
branches;
next	1.12.12.2;

1.12.12.2
date	2003.06.27.21.49.06;	author carlton;	state Exp;
branches;
next	;

1.12.14.1
date	2003.12.14.20.26.34;	author drow;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove a29k files.
@
text
@/* BFD back-end for AMD 29000 COFF binaries.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001,
   2002, 2003, 2004
   Free Software Foundation, Inc.
   Contributed by David Wood at New York University 7/8/91.

This file is part of BFD, the Binary File Descriptor library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

#define A29K 1

#include "bfd.h"
#include "sysdep.h"
#include "libbfd.h"
#include "coff/a29k.h"
#include "coff/internal.h"
#include "libcoff.h"

static long get_symbol_value PARAMS ((asymbol *));
static bfd_reloc_status_type a29k_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean coff_a29k_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static bfd_boolean coff_a29k_adjust_symndx
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   struct internal_reloc *, bfd_boolean *));
static void reloc_processing
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)

#define INSERT_HWORD(WORD,HWORD)	\
    (((WORD) & 0xff00ff00) | (((HWORD) & 0xff00) << 8) | ((HWORD)& 0xff))
#define EXTRACT_HWORD(WORD) \
    ((((WORD) & 0x00ff0000) >> 8) | ((WORD) & 0xff))
#define SIGN_EXTEND_HWORD(HWORD) \
    (((HWORD) ^ 0x8000) - 0x8000)

/* Provided the symbol, returns the value reffed.  */

static long
get_symbol_value (symbol)
     asymbol *symbol;
{
  long relocation = 0;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value +
      symbol->section->output_section->vma +
      symbol->section->output_offset;

  return relocation;
}

/* This function is in charge of performing all the 29k relocations.  */

static bfd_reloc_status_type
a29k_reloc (abfd, reloc_entry, symbol_in, data, input_section, output_bfd,
	    error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol_in;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* The consth relocation comes in two parts, we have to remember
     the state between calls, in these variables.  */
  static bfd_boolean part1_consth_active = FALSE;
  static unsigned long part1_consth_value;
  unsigned long insn;
  unsigned long sym_value;
  unsigned long unsigned_value;
  unsigned short r_type;
  long signed_value;
  unsigned long addr = reloc_entry->address ; /*+ input_section->vma*/
  bfd_byte  *hit_data =addr + (bfd_byte *) (data);

  r_type = reloc_entry->howto->type;

  if (output_bfd)
    {
      /* Partial linking - do nothing.  */
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (symbol_in != NULL
      && bfd_is_und_section (symbol_in->section))
    {
      /* Keep the state machine happy in case we're called again.  */
      if (r_type == R_IHIHALF)
	{
	  part1_consth_active = TRUE;
	  part1_consth_value  = 0;
	}
      return bfd_reloc_undefined;
    }

  if ((part1_consth_active) && (r_type != R_IHCONST))
    {
      part1_consth_active = FALSE;
      *error_message = (char *) _("Missing IHCONST");

      return bfd_reloc_dangerous;
    }

  sym_value = get_symbol_value(symbol_in);

  switch (r_type)
    {
    case R_IREL:
      insn = bfd_get_32 (abfd, hit_data);
      /* Take the value in the field and sign extend it.  */
      signed_value = EXTRACT_HWORD(insn);
      signed_value = SIGN_EXTEND_HWORD(signed_value);
      signed_value <<= 2;

      /* See the note on the R_IREL reloc in coff_a29k_relocate_section.  */
      if (signed_value == - (long) reloc_entry->address)
	signed_value = 0;

      signed_value += sym_value + reloc_entry->addend;
      if ((signed_value & ~0x3ffff) == 0)
	{				/* Absolute jmp/call */
	  insn |= (1 << 24);		/* Make it absolute */
	  /* FIXME: Should we change r_type to R_IABS.  */
	}
      else
	{
	  /* Relative jmp/call, so subtract from the value the
	     address of the place we're coming from.  */
	  signed_value -= (reloc_entry->address
			   + input_section->output_section->vma
			   + input_section->output_offset);
	  if (signed_value > 0x1ffff || signed_value < -0x20000)
	    return bfd_reloc_overflow;
	}
      signed_value >>= 2;
      insn = INSERT_HWORD (insn, signed_value);
      bfd_put_32 (abfd, (bfd_vma) insn ,hit_data);
      break;
    case R_ILOHALF:
      insn = bfd_get_32 (abfd, hit_data);
      unsigned_value = EXTRACT_HWORD(insn);
      unsigned_value +=  sym_value + reloc_entry->addend;
      insn = INSERT_HWORD(insn, unsigned_value);
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
      break;
    case R_IHIHALF:
      insn = bfd_get_32 (abfd, hit_data);
      /* consth, part 1
	 Just get the symbol value that is referenced.  */
      part1_consth_active = TRUE;
      part1_consth_value = sym_value + reloc_entry->addend;
      /* Don't modify insn until R_IHCONST.  */
      break;
    case R_IHCONST:
      insn = bfd_get_32 (abfd, hit_data);
      /* consth, part 2
	 Now relocate the reference.  */
      if (! part1_consth_active)
	{
	  *error_message = (char *) _("Missing IHIHALF");
	  return bfd_reloc_dangerous;
	}
      /* sym_ptr_ptr = r_symndx, in coff_slurp_reloc_table() */
      unsigned_value = 0;		/*EXTRACT_HWORD(insn) << 16;*/
      unsigned_value += reloc_entry->addend; /* r_symndx */
      unsigned_value += part1_consth_value;
      unsigned_value = unsigned_value >> 16;
      insn = INSERT_HWORD(insn, unsigned_value);
      part1_consth_active = FALSE;
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
      break;
    case R_BYTE:
      insn = bfd_get_8 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
      if (unsigned_value & 0xffffff00)
	return bfd_reloc_overflow;
      bfd_put_8 (abfd, unsigned_value, hit_data);
      break;
    case R_HWORD:
      insn = bfd_get_16 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
      if (unsigned_value & 0xffff0000)
	return bfd_reloc_overflow;
      bfd_put_16 (abfd, (bfd_vma) insn, hit_data);
      break;
    case R_WORD:
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
      break;
    default:
      *error_message = _("Unrecognized reloc");
      return bfd_reloc_dangerous;
    }

  return(bfd_reloc_ok);
}

/*FIXME: I'm not real sure about this table.  */
static reloc_howto_type howto_table[] =
  {
    {R_ABS,     0, 3, 32, FALSE, 0, complain_overflow_bitfield,a29k_reloc,"ABS",     TRUE, 0xffffffff,0xffffffff, FALSE},
    EMPTY_HOWTO (1),
    EMPTY_HOWTO (2),
    EMPTY_HOWTO (3),
    EMPTY_HOWTO (4),
    EMPTY_HOWTO (5),
    EMPTY_HOWTO (6),
    EMPTY_HOWTO (7),
    EMPTY_HOWTO (8),
    EMPTY_HOWTO (9),
    EMPTY_HOWTO (10),
    EMPTY_HOWTO (11),
    EMPTY_HOWTO (12),
    EMPTY_HOWTO (13),
    EMPTY_HOWTO (14),
    EMPTY_HOWTO (15),
    EMPTY_HOWTO (16),
    EMPTY_HOWTO (17),
    EMPTY_HOWTO (18),
    EMPTY_HOWTO (19),
    EMPTY_HOWTO (20),
    EMPTY_HOWTO (21),
    EMPTY_HOWTO (22),
    EMPTY_HOWTO (23),
    {R_IREL,    0, 3, 32, TRUE,  0, complain_overflow_signed,a29k_reloc,"IREL",    TRUE, 0xffffffff,0xffffffff, FALSE},
    {R_IABS,    0, 3, 32, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"IABS",    TRUE, 0xffffffff,0xffffffff, FALSE},
    {R_ILOHALF, 0, 3, 16, TRUE,  0, complain_overflow_signed, a29k_reloc,"ILOHALF", TRUE, 0x0000ffff,0x0000ffff, FALSE},
    {R_IHIHALF, 0, 3, 16, TRUE,  16, complain_overflow_signed, a29k_reloc,"IHIHALF", TRUE, 0xffff0000,0xffff0000, FALSE},
    {R_IHCONST, 0, 3, 16, TRUE,  0, complain_overflow_signed, a29k_reloc,"IHCONST", TRUE, 0xffff0000,0xffff0000, FALSE},
    {R_BYTE,    0, 0, 8, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"BYTE",    TRUE, 0x000000ff,0x000000ff, FALSE},
    {R_HWORD,   0, 1, 16, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"HWORD",   TRUE, 0x0000ffff,0x0000ffff, FALSE},
    {R_WORD,    0, 2, 32, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"WORD",    TRUE, 0xffffffff,0xffffffff, FALSE},
  };

#define BADMAG(x) A29KBADMAG(x)

#define RELOC_PROCESSING(relent, reloc, symbols, abfd, section) \
 reloc_processing(relent, reloc, symbols, abfd, section)

static void
reloc_processing (relent,reloc, symbols, abfd, section)
     arelent *relent;
     struct internal_reloc *reloc;
     asymbol **symbols;
     bfd *abfd;
     asection *section;
{
  static bfd_vma ihihalf_vaddr = (bfd_vma) -1;

  relent->address = reloc->r_vaddr;
  relent->howto = howto_table + reloc->r_type;
  if (reloc->r_type == R_IHCONST)
    {
      /* The address of an R_IHCONST should always be the address of
	 the immediately preceding R_IHIHALF.  relocs generated by gas
	 are correct, but relocs generated by High C are different (I
	 can't figure out what the address means for High C).  We can
	 handle both gas and High C by ignoring the address here, and
	 simply reusing the address saved for R_IHIHALF.  */
      if (ihihalf_vaddr == (bfd_vma) -1)
	abort ();
      relent->address = ihihalf_vaddr;
      ihihalf_vaddr = (bfd_vma) -1;
      relent->addend = reloc->r_symndx;
      relent->sym_ptr_ptr= bfd_abs_section_ptr->symbol_ptr_ptr;
    }
  else
    {
      asymbol *ptr;

      relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];

      ptr = *(relent->sym_ptr_ptr);

      if (ptr
	  && bfd_asymbol_bfd(ptr) == abfd
	  && ((ptr->flags & BSF_OLD_COMMON) == 0))
	relent->addend = 0;
      else
	relent->addend = 0;

      relent->address-= section->vma;
      if (reloc->r_type == R_IHIHALF)
	ihihalf_vaddr = relent->address;
      else if (ihihalf_vaddr != (bfd_vma) -1)
	abort ();
    }
}

/* The reloc processing routine for the optimized COFF linker.  */

static bfd_boolean
coff_a29k_relocate_section (output_bfd, info, input_bfd, input_section,
			    contents, relocs, syms, sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;
  bfd_boolean hihalf;
  bfd_vma hihalf_val;

  /* If we are performing a relocatable link, we don't need to do a
     thing.  The caller will take care of adjusting the reloc
     addresses and symbol indices.  */
  if (info->relocatable)
    return TRUE;

  hihalf = FALSE;
  hihalf_val = 0;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      bfd_byte *loc;
      struct coff_link_hash_entry *h;
      struct internal_syment *sym;
      asection *sec;
      bfd_vma val;
      bfd_boolean overflow;
      unsigned long insn;
      long signed_value;
      unsigned long unsigned_value;
      bfd_reloc_status_type rstat;

      symndx = rel->r_symndx;
      loc = contents + rel->r_vaddr - input_section->vma;

      if (symndx == -1 || rel->r_type == R_IHCONST)
	h = NULL;
      else
	h = obj_coff_sym_hashes (input_bfd)[symndx];

      sym = NULL;
      sec = NULL;
      val = 0;

      /* An R_IHCONST reloc does not have a symbol.  Instead, the
         symbol index is an addend.  R_IHCONST is always used in
         conjunction with R_IHHALF.  */
      if (rel->r_type != R_IHCONST)
	{
	  if (h == NULL)
	    {
	      if (symndx == -1)
		sec = bfd_abs_section_ptr;
	      else
		{
		  sym = syms + symndx;
		  sec = sections[symndx];
		  val = (sec->output_section->vma
			 + sec->output_offset
			 + sym->n_value
			 - sec->vma);
		}
	    }
	  else
	    {
	      if (   h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		{
		  sec = h->root.u.def.section;
		  val = (h->root.u.def.value
			 + sec->output_section->vma
			 + sec->output_offset);
		}
	      else
		{
		  if (! ((*info->callbacks->undefined_symbol)
			 (info, h->root.root.string, input_bfd, input_section,
			  rel->r_vaddr - input_section->vma, TRUE)))
		    return FALSE;
		}
	    }

	  if (hihalf)
	    {
	      if (! ((*info->callbacks->reloc_dangerous)
		     (info, _("missing IHCONST reloc"), input_bfd,
		      input_section, rel->r_vaddr - input_section->vma)))
		return FALSE;
	      hihalf = FALSE;
	    }
	}

      overflow = FALSE;

      switch (rel->r_type)
	{
	default:
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;

	case R_IREL:
	  insn = bfd_get_32 (input_bfd, loc);

	  /* Extract the addend.  */
	  signed_value = EXTRACT_HWORD (insn);
	  signed_value = SIGN_EXTEND_HWORD (signed_value);
	  signed_value <<= 2;

	  /* Unfortunately, there are two different versions of COFF
	     a29k.  In the original AMD version, the value stored in
	     the field for the R_IREL reloc is a simple addend.  In
	     the GNU version, the value is the negative of the address
	     of the reloc within section.  We try to cope here by
	     assuming the AMD version, unless the addend is exactly
	     the negative of the address; in the latter case we assume
	     the GNU version.  This means that something like
	         .text
		 nop
		 jmp i-4
	     will fail, because the addend of -4 will happen to equal
	     the negative of the address within the section.  The
	     compiler will never generate code like this.

	     At some point in the future we may want to take out this
	     check.  */

	  if (signed_value == - (long) (rel->r_vaddr - input_section->vma))
	    signed_value = 0;

	  /* Determine the destination of the jump.  */
	  signed_value += val;

	  if ((signed_value & ~0x3ffff) == 0)
	    {
	      /* We can use an absolute jump.  */
	      insn |= (1 << 24);
	    }
	  else
	    {
	      /* Make the destination PC relative.  */
	      signed_value -= (input_section->output_section->vma
			       + input_section->output_offset
			       + (rel->r_vaddr - input_section->vma));
	      if (signed_value > 0x1ffff || signed_value < - 0x20000)
		{
		  overflow = TRUE;
		  signed_value = 0;
		}
	    }

	  /* Put the adjusted value back into the instruction.  */
	  signed_value >>= 2;
	  insn = INSERT_HWORD (insn, signed_value);

	  bfd_put_32 (input_bfd, (bfd_vma) insn, loc);
	  break;

	case R_ILOHALF:
	  insn = bfd_get_32 (input_bfd, loc);
	  unsigned_value = EXTRACT_HWORD (insn);
	  unsigned_value += val;
	  insn = INSERT_HWORD (insn, unsigned_value);
	  bfd_put_32 (input_bfd, (bfd_vma) insn, loc);
	  break;

	case R_IHIHALF:
	  /* Save the value for the R_IHCONST reloc.  */
	  hihalf = TRUE;
	  hihalf_val = val;
	  break;

	case R_IHCONST:
	  if (! hihalf)
	    {
	      if (! ((*info->callbacks->reloc_dangerous)
		     (info, _("missing IHIHALF reloc"), input_bfd,
		      input_section, rel->r_vaddr - input_section->vma)))
		return FALSE;
	      hihalf_val = 0;
	    }

	  insn = bfd_get_32 (input_bfd, loc);
	  unsigned_value = rel->r_symndx + hihalf_val;
	  unsigned_value >>= 16;
	  insn = INSERT_HWORD (insn, unsigned_value);
	  bfd_put_32 (input_bfd, (bfd_vma) insn, loc);

	  hihalf = FALSE;

	  break;

	case R_BYTE:
	case R_HWORD:
	case R_WORD:
	  rstat = _bfd_relocate_contents (howto_table + rel->r_type,
					  input_bfd, val, loc);
	  if (rstat == bfd_reloc_overflow)
	    overflow = TRUE;
	  else if (rstat != bfd_reloc_ok)
	    abort ();
	  break;
	}

      if (overflow)
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];

	  if (symndx == -1)
	    name = "*ABS*";
	  else if (h != NULL)
	    name = NULL;
	  else if (sym == NULL)
	    name = "*unknown*";
	  else if (sym->_n._n_n._n_zeroes == 0
		   && sym->_n._n_n._n_offset != 0)
	    name = obj_coff_strings (input_bfd) + sym->_n._n_n._n_offset;
	  else
	    {
	      strncpy (buf, sym->_n._n_name, SYMNMLEN);
	      buf[SYMNMLEN] = '\0';
	      name = buf;
	    }

	  if (! ((*info->callbacks->reloc_overflow)
		 (info, (h ? &h->root : NULL), name,
		  howto_table[rel->r_type].name, (bfd_vma) 0, input_bfd,
		  input_section, rel->r_vaddr - input_section->vma)))
	    return FALSE;
	}
    }

  return TRUE;
}

#define coff_relocate_section coff_a29k_relocate_section

/* We don't want to change the symndx of a R_IHCONST reloc, since it
   is actually an addend, not a symbol index at all.  */

static bfd_boolean
coff_a29k_adjust_symndx (obfd, info, ibfd, sec, irel, adjustedp)
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *ibfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     struct internal_reloc *irel;
     bfd_boolean *adjustedp;
{
  if (irel->r_type == R_IHCONST)
    *adjustedp = TRUE;
  else
    *adjustedp = FALSE;
  return TRUE;
}

#define coff_adjust_symndx coff_a29k_adjust_symndx

#include "coffcode.h"

CREATE_BIG_COFF_TARGET_VEC (a29kcoff_big_vec, "coff-a29k-big", 0, SEC_READONLY, '_', NULL, COFF_SWAP_TABLE)
@


1.19
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@@


1.18
log
@Update the FSF address in the copyright/GPL notice
@
text
@d21 1
a21 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.17
log
@update copyright dates
@
text
@d21 1
a21 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.16
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d3 1
a3 1
   2002, 2003
@


1.15
log
@Correct spelling of "relocatable".
@
text
@d535 1
a535 1
	    name = h->root.root.string;
d549 3
a551 3
		 (info, name, howto_table[rel->r_type].name, (bfd_vma) 0,
		  input_bfd, input_section,
		  rel->r_vaddr - input_section->vma)))
@


1.14
log
@Altered the CREATE_xxx_COFF_TARGET_VEC macro arguments
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001, 2002
d331 1
a331 1
  /* If we are performing a relocateable link, we don't need to do a
d334 1
a334 1
  if (info->relocateable)
@


1.13
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d583 1
a583 1
CREATE_BIG_COFF_TARGET_VEC (a29kcoff_big_vec, "coff-a29k-big", 0, SEC_READONLY, '_', NULL)
@


1.12
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d34 1
a34 1
static boolean coff_a29k_relocate_section
d37 1
a37 1
static boolean coff_a29k_adjust_symndx
d39 1
a39 1
	   struct internal_reloc *, boolean *));
d85 1
a85 1
  static boolean part1_consth_active = false;
d110 1
a110 1
	  part1_consth_active = true;
d118 1
a118 1
      part1_consth_active = false;
d170 1
a170 1
      part1_consth_active = true;
d189 1
a189 1
      part1_consth_active = false;
d222 1
a222 1
    {R_ABS,     0, 3, 32, false, 0, complain_overflow_bitfield,a29k_reloc,"ABS",     true, 0xffffffff,0xffffffff, false},
d246 8
a253 8
    {R_IREL,    0, 3, 32, true,  0, complain_overflow_signed,a29k_reloc,"IREL",    true, 0xffffffff,0xffffffff, false},
    {R_IABS,    0, 3, 32, false, 0, complain_overflow_bitfield, a29k_reloc,"IABS",    true, 0xffffffff,0xffffffff, false},
    {R_ILOHALF, 0, 3, 16, true,  0, complain_overflow_signed, a29k_reloc,"ILOHALF", true, 0x0000ffff,0x0000ffff, false},
    {R_IHIHALF, 0, 3, 16, true,  16, complain_overflow_signed, a29k_reloc,"IHIHALF", true, 0xffff0000,0xffff0000, false},
    {R_IHCONST, 0, 3, 16, true,  0, complain_overflow_signed, a29k_reloc,"IHCONST", true, 0xffff0000,0xffff0000, false},
    {R_BYTE,    0, 0, 8, false, 0, complain_overflow_bitfield, a29k_reloc,"BYTE",    true, 0x000000ff,0x000000ff, false},
    {R_HWORD,   0, 1, 16, false, 0, complain_overflow_bitfield, a29k_reloc,"HWORD",   true, 0x0000ffff,0x0000ffff, false},
    {R_WORD,    0, 2, 32, false, 0, complain_overflow_bitfield, a29k_reloc,"WORD",    true, 0xffffffff,0xffffffff, false},
d313 1
a313 1
static boolean
d327 1
a327 1
  boolean hihalf;
d334 1
a334 1
    return true;
d336 1
a336 1
  hihalf = false;
d349 1
a349 1
      boolean overflow;
d400 2
a401 2
			  rel->r_vaddr - input_section->vma, true)))
		    return false;
d410 2
a411 2
		return false;
	      hihalf = false;
d415 1
a415 1
      overflow = false;
d421 1
a421 1
	  return false;
d468 1
a468 1
		  overflow = true;
d490 1
a490 1
	  hihalf = true;
d500 1
a500 1
		return false;
d510 1
a510 1
	  hihalf = false;
d520 1
a520 1
	    overflow = true;
d551 1
a551 1
	    return false;
d555 1
a555 1
  return true;
d563 1
a563 1
static boolean
d570 1
a570 1
     boolean *adjustedp;
d573 1
a573 1
    *adjustedp = true;
d575 2
a576 2
    *adjustedp = false;
  return true;
@


1.12.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001,
   2002, 2003
d34 1
a34 1
static bfd_boolean coff_a29k_relocate_section
d37 1
a37 1
static bfd_boolean coff_a29k_adjust_symndx
d39 1
a39 1
	   struct internal_reloc *, bfd_boolean *));
d85 1
a85 1
  static bfd_boolean part1_consth_active = FALSE;
d110 1
a110 1
	  part1_consth_active = TRUE;
d118 1
a118 1
      part1_consth_active = FALSE;
d170 1
a170 1
      part1_consth_active = TRUE;
d189 1
a189 1
      part1_consth_active = FALSE;
d222 1
a222 1
    {R_ABS,     0, 3, 32, FALSE, 0, complain_overflow_bitfield,a29k_reloc,"ABS",     TRUE, 0xffffffff,0xffffffff, FALSE},
d246 8
a253 8
    {R_IREL,    0, 3, 32, TRUE,  0, complain_overflow_signed,a29k_reloc,"IREL",    TRUE, 0xffffffff,0xffffffff, FALSE},
    {R_IABS,    0, 3, 32, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"IABS",    TRUE, 0xffffffff,0xffffffff, FALSE},
    {R_ILOHALF, 0, 3, 16, TRUE,  0, complain_overflow_signed, a29k_reloc,"ILOHALF", TRUE, 0x0000ffff,0x0000ffff, FALSE},
    {R_IHIHALF, 0, 3, 16, TRUE,  16, complain_overflow_signed, a29k_reloc,"IHIHALF", TRUE, 0xffff0000,0xffff0000, FALSE},
    {R_IHCONST, 0, 3, 16, TRUE,  0, complain_overflow_signed, a29k_reloc,"IHCONST", TRUE, 0xffff0000,0xffff0000, FALSE},
    {R_BYTE,    0, 0, 8, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"BYTE",    TRUE, 0x000000ff,0x000000ff, FALSE},
    {R_HWORD,   0, 1, 16, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"HWORD",   TRUE, 0x0000ffff,0x0000ffff, FALSE},
    {R_WORD,    0, 2, 32, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"WORD",    TRUE, 0xffffffff,0xffffffff, FALSE},
d313 1
a313 1
static bfd_boolean
d327 1
a327 1
  bfd_boolean hihalf;
d330 1
a330 1
  /* If we are performing a relocatable link, we don't need to do a
d333 2
a334 2
  if (info->relocatable)
    return TRUE;
d336 1
a336 1
  hihalf = FALSE;
d349 1
a349 1
      bfd_boolean overflow;
d400 2
a401 2
			  rel->r_vaddr - input_section->vma, TRUE)))
		    return FALSE;
d410 2
a411 2
		return FALSE;
	      hihalf = FALSE;
d415 1
a415 1
      overflow = FALSE;
d421 1
a421 1
	  return FALSE;
d468 1
a468 1
		  overflow = TRUE;
d490 1
a490 1
	  hihalf = TRUE;
d500 1
a500 1
		return FALSE;
d510 1
a510 1
	  hihalf = FALSE;
d520 1
a520 1
	    overflow = TRUE;
d551 1
a551 1
	    return FALSE;
d555 1
a555 1
  return TRUE;
d563 1
a563 1
static bfd_boolean
d570 1
a570 1
     bfd_boolean *adjustedp;
d573 1
a573 1
    *adjustedp = TRUE;
d575 2
a576 2
    *adjustedp = FALSE;
  return TRUE;
d583 1
a583 1
CREATE_BIG_COFF_TARGET_VEC (a29kcoff_big_vec, "coff-a29k-big", 0, SEC_READONLY, '_', NULL, COFF_SWAP_TABLE)
@


1.12.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d34 1
a34 1
static bfd_boolean coff_a29k_relocate_section
d37 1
a37 1
static bfd_boolean coff_a29k_adjust_symndx
d39 1
a39 1
	   struct internal_reloc *, bfd_boolean *));
d85 1
a85 1
  static bfd_boolean part1_consth_active = FALSE;
d110 1
a110 1
	  part1_consth_active = TRUE;
d118 1
a118 1
      part1_consth_active = FALSE;
d170 1
a170 1
      part1_consth_active = TRUE;
d189 1
a189 1
      part1_consth_active = FALSE;
d222 1
a222 1
    {R_ABS,     0, 3, 32, FALSE, 0, complain_overflow_bitfield,a29k_reloc,"ABS",     TRUE, 0xffffffff,0xffffffff, FALSE},
d246 8
a253 8
    {R_IREL,    0, 3, 32, TRUE,  0, complain_overflow_signed,a29k_reloc,"IREL",    TRUE, 0xffffffff,0xffffffff, FALSE},
    {R_IABS,    0, 3, 32, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"IABS",    TRUE, 0xffffffff,0xffffffff, FALSE},
    {R_ILOHALF, 0, 3, 16, TRUE,  0, complain_overflow_signed, a29k_reloc,"ILOHALF", TRUE, 0x0000ffff,0x0000ffff, FALSE},
    {R_IHIHALF, 0, 3, 16, TRUE,  16, complain_overflow_signed, a29k_reloc,"IHIHALF", TRUE, 0xffff0000,0xffff0000, FALSE},
    {R_IHCONST, 0, 3, 16, TRUE,  0, complain_overflow_signed, a29k_reloc,"IHCONST", TRUE, 0xffff0000,0xffff0000, FALSE},
    {R_BYTE,    0, 0, 8, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"BYTE",    TRUE, 0x000000ff,0x000000ff, FALSE},
    {R_HWORD,   0, 1, 16, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"HWORD",   TRUE, 0x0000ffff,0x0000ffff, FALSE},
    {R_WORD,    0, 2, 32, FALSE, 0, complain_overflow_bitfield, a29k_reloc,"WORD",    TRUE, 0xffffffff,0xffffffff, FALSE},
d313 1
a313 1
static bfd_boolean
d327 1
a327 1
  bfd_boolean hihalf;
d334 1
a334 1
    return TRUE;
d336 1
a336 1
  hihalf = FALSE;
d349 1
a349 1
      bfd_boolean overflow;
d400 2
a401 2
			  rel->r_vaddr - input_section->vma, TRUE)))
		    return FALSE;
d410 2
a411 2
		return FALSE;
	      hihalf = FALSE;
d415 1
a415 1
      overflow = FALSE;
d421 1
a421 1
	  return FALSE;
d468 1
a468 1
		  overflow = TRUE;
d490 1
a490 1
	  hihalf = TRUE;
d500 1
a500 1
		return FALSE;
d510 1
a510 1
	  hihalf = FALSE;
d520 1
a520 1
	    overflow = TRUE;
d551 1
a551 1
	    return FALSE;
d555 1
a555 1
  return TRUE;
d563 1
a563 1
static bfd_boolean
d570 1
a570 1
     bfd_boolean *adjustedp;
d573 1
a573 1
    *adjustedp = TRUE;
d575 2
a576 2
    *adjustedp = FALSE;
  return TRUE;
@


1.12.12.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001,
   2002, 2003
d330 1
a330 1
  /* If we are performing a relocatable link, we don't need to do a
d333 1
a333 1
  if (info->relocatable)
d583 1
a583 1
CREATE_BIG_COFF_TARGET_VEC (a29kcoff_big_vec, "coff-a29k-big", 0, SEC_READONLY, '_', NULL, COFF_SWAP_TABLE)
@


1.11
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001
d178 1
a178 1
      if (part1_consth_active == false)
@


1.11.10.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001, 2002
d178 1
a178 1
      if (! part1_consth_active)
@


1.10
log
@Add missing prototypes
@
text
@d157 1
a157 1
      bfd_put_32 (abfd, insn ,hit_data);
d164 1
a164 1
      bfd_put_32 (abfd, insn, hit_data);
d190 1
a190 1
      bfd_put_32 (abfd, insn, hit_data);
d204 1
a204 1
      bfd_put_16 (abfd, insn, hit_data);
d209 1
a209 1
      bfd_put_32 (abfd, insn, hit_data);
d485 1
a485 1
	  bfd_put_32 (input_bfd, insn, loc);
@


1.9
log
@Update copyright notices
@
text
@d40 2
d52 2
a53 1
/* Provided the symbol, returns the value reffed */
d61 1
a61 3
    {
      relocation = 0;
    }
d63 3
a65 5
    {
      relocation = symbol->value +
	symbol->section->output_section->vma +
	symbol->section->output_offset;
    }
d67 1
a67 1
  return(relocation);
d70 1
a70 1
/* this function is in charge of performing all the 29k relocations */
d83 2
a84 2
  /* the consth relocation comes in two parts, we have to remember
     the state between calls, in these variables */
a86 1

a91 1

d99 1
a99 1
      /* Partial linking - do nothing */
a101 1

d107 1
a107 1
      /* Keep the state machine happy in case we're called again */
d113 1
a113 1
      return(bfd_reloc_undefined);
d120 2
a121 1
      return(bfd_reloc_dangerous);
d130 1
a130 1
      /* Take the value in the field and sign extend it */
d142 2
a143 2
	  insn |= (1<<24);		/* Make it absolute */
	  /* FIXME: Should we change r_type to R_IABS */
d148 1
a148 1
	     address of the place we're coming from */
d152 2
a153 2
	  if (signed_value>0x1ffff || signed_value<-0x20000)
	    return(bfd_reloc_overflow);
d156 1
a156 1
      insn = INSERT_HWORD(insn, signed_value);
d169 1
a169 1
	 Just get the symbol value that is referenced */
d172 1
a172 1
      /* Don't modify insn until R_IHCONST */
d177 1
a177 1
	 Now relocate the reference */
d181 1
a181 1
	  return(bfd_reloc_dangerous);
d196 1
a196 1
	return(bfd_reloc_overflow);
d203 1
a203 1
	return(bfd_reloc_overflow);
d213 1
a213 1
      return (bfd_reloc_dangerous);
d219 1
a219 14
/*      type	   rightshift
		       size
			  bitsize
			       pc-relative
				     bitpos
					 absolute
					     complain_on_overflow
						  special_function
						    relocation name
							       partial_inplace
								      src_mask
*/

/*FIXME: I'm not real sure about this table */
d221 34
a254 34
{
  {R_ABS,     0, 3, 32, false, 0, complain_overflow_bitfield,a29k_reloc,"ABS",     true, 0xffffffff,0xffffffff, false},
  EMPTY_HOWTO (1),
  EMPTY_HOWTO (2),
  EMPTY_HOWTO (3),
  EMPTY_HOWTO (4),
  EMPTY_HOWTO (5),
  EMPTY_HOWTO (6),
  EMPTY_HOWTO (7),
  EMPTY_HOWTO (8),
  EMPTY_HOWTO (9),
  EMPTY_HOWTO (10),
  EMPTY_HOWTO (11),
  EMPTY_HOWTO (12),
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  EMPTY_HOWTO (20),
  EMPTY_HOWTO (21),
  EMPTY_HOWTO (22),
  EMPTY_HOWTO (23),
  {R_IREL,    0, 3, 32, true,  0, complain_overflow_signed,a29k_reloc,"IREL",    true, 0xffffffff,0xffffffff, false},
  {R_IABS,    0, 3, 32, false, 0, complain_overflow_bitfield, a29k_reloc,"IABS",    true, 0xffffffff,0xffffffff, false},
  {R_ILOHALF, 0, 3, 16, true,  0, complain_overflow_signed, a29k_reloc,"ILOHALF", true, 0x0000ffff,0x0000ffff, false},
  {R_IHIHALF, 0, 3, 16, true,  16, complain_overflow_signed, a29k_reloc,"IHIHALF", true, 0xffff0000,0xffff0000, false},
  {R_IHCONST, 0, 3, 16, true,  0, complain_overflow_signed, a29k_reloc,"IHCONST", true, 0xffff0000,0xffff0000, false},
  {R_BYTE,    0, 0, 8, false, 0, complain_overflow_bitfield, a29k_reloc,"BYTE",    true, 0x000000ff,0x000000ff, false},
  {R_HWORD,   0, 1, 16, false, 0, complain_overflow_bitfield, a29k_reloc,"HWORD",   true, 0x0000ffff,0x0000ffff, false},
  {R_WORD,    0, 2, 32, false, 0, complain_overflow_bitfield, a29k_reloc,"WORD",    true, 0xffffffff,0xffffffff, false},
};
d291 2
a292 1
      relent->sym_ptr_ptr = symbols + obj_convert(abfd)[reloc->r_symndx];
d298 4
a302 8
	  && ((ptr->flags & BSF_OLD_COMMON)== 0))
	{
	  relent->addend = 0;
	}
      else
	{
	  relent->addend = 0;
	}
d388 1
a388 1
	      if (h->root.type == bfd_link_hash_defined
a477 1

@


1.8
log
@2001-01-21  Kazu Hirata  <kazu@@hxi.com>

	* coff-a29k.c: Fix formatting.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 97, 98, 99, 2000
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1999, 2000, 2001
@


1.7
log
@2000-11-21  Kazu Hirata  <kazu@@hxi.com>

	* coff-a29k.c: Fix formatting.
	* coff-h8500.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-w65.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-hppa.c: Likewise.
	* cpu-ns32k.c: Likewise.
@
text
@d58 3
a60 3
  {
    relocation = 0;
  }
d62 5
a66 5
  {
    relocation = symbol->value +
     symbol->section->output_section->vma +
      symbol->section->output_offset;
  }
d100 5
a104 4
  if (output_bfd) {
    /* Partial linking - do nothing */
    reloc_entry->address += input_section->output_offset;
    return bfd_reloc_ok;
d106 1
a106 1
  }
a109 3
  {
    /* Keep the state machine happy in case we're called again */
    if (r_type == R_IHIHALF)
d111 7
a117 2
      part1_consth_active = true;
      part1_consth_value  = 0;
a118 2
    return(bfd_reloc_undefined);
  }
d121 5
a125 5
  {
    part1_consth_active = false;
    *error_message = (char *) _("Missing IHCONST");
    return(bfd_reloc_dangerous);
  }
a129 19
  {
   case R_IREL:
    insn = bfd_get_32 (abfd, hit_data);
    /* Take the value in the field and sign extend it */
    signed_value = EXTRACT_HWORD(insn);
    signed_value = SIGN_EXTEND_HWORD(signed_value);
    signed_value <<= 2;

    /* See the note on the R_IREL reloc in coff_a29k_relocate_section.  */
    if (signed_value == - (long) reloc_entry->address)
      signed_value = 0;

    signed_value += sym_value + reloc_entry->addend;
    if ((signed_value & ~0x3ffff) == 0)
    {				/* Absolute jmp/call */
      insn |= (1<<24);		/* Make it absolute */
      /* FIXME: Should we change r_type to R_IABS */
    }
    else
d131 86
a216 7
      /* Relative jmp/call, so subtract from the value the
	 address of the place we're coming from */
      signed_value -= (reloc_entry->address
		       + input_section->output_section->vma
		       + input_section->output_offset);
      if (signed_value>0x1ffff || signed_value<-0x20000)
       return(bfd_reloc_overflow);
a217 59
    signed_value >>= 2;
    insn = INSERT_HWORD(insn, signed_value);
    bfd_put_32 (abfd, insn ,hit_data);
    break;
   case R_ILOHALF:
    insn = bfd_get_32 (abfd, hit_data);
    unsigned_value = EXTRACT_HWORD(insn);
    unsigned_value +=  sym_value + reloc_entry->addend;
    insn = INSERT_HWORD(insn, unsigned_value);
    bfd_put_32 (abfd, insn, hit_data);
    break;
   case R_IHIHALF:
    insn = bfd_get_32 (abfd, hit_data);
    /* consth, part 1
       Just get the symbol value that is referenced */
    part1_consth_active = true;
    part1_consth_value = sym_value + reloc_entry->addend;
    /* Don't modify insn until R_IHCONST */
    break;
   case R_IHCONST:
    insn = bfd_get_32 (abfd, hit_data);
    /* consth, part 2
       Now relocate the reference */
    if (part1_consth_active == false) {
      *error_message = (char *) _("Missing IHIHALF");
      return(bfd_reloc_dangerous);
    }
    /* sym_ptr_ptr = r_symndx, in coff_slurp_reloc_table() */
    unsigned_value = 0;		/*EXTRACT_HWORD(insn) << 16;*/
    unsigned_value += reloc_entry->addend; /* r_symndx */
    unsigned_value += part1_consth_value;
    unsigned_value = unsigned_value >> 16;
    insn = INSERT_HWORD(insn, unsigned_value);
    part1_consth_active = false;
    bfd_put_32 (abfd, insn, hit_data);
    break;
   case R_BYTE:
    insn = bfd_get_8 (abfd, hit_data);
    unsigned_value = insn + sym_value + reloc_entry->addend;
    if (unsigned_value & 0xffffff00)
      return(bfd_reloc_overflow);
    bfd_put_8 (abfd, unsigned_value, hit_data);
    break;
   case R_HWORD:
    insn = bfd_get_16 (abfd, hit_data);
    unsigned_value = insn + sym_value + reloc_entry->addend;
    if (unsigned_value & 0xffff0000)
      return(bfd_reloc_overflow);
    bfd_put_16 (abfd, insn, hit_data);
    break;
   case R_WORD:
    insn = bfd_get_32 (abfd, hit_data);
    insn += sym_value + reloc_entry->addend;
    bfd_put_32 (abfd, insn, hit_data);
    break;
   default:
    *error_message = _("Unrecognized reloc");
    return (bfd_reloc_dangerous);
  }
d285 1
a285 1
    static bfd_vma ihihalf_vaddr = (bfd_vma) -1;
d287 3
a289 3
    relent->address = reloc->r_vaddr;
    relent->howto = howto_table + reloc->r_type;
    if (reloc->r_type == R_IHCONST)
d297 6
a302 6
        if (ihihalf_vaddr == (bfd_vma) -1)
	  abort ();
	relent->address = ihihalf_vaddr;
	ihihalf_vaddr = (bfd_vma) -1;
	relent->addend = reloc->r_symndx;
	relent->sym_ptr_ptr= bfd_abs_section_ptr->symbol_ptr_ptr;
d304 1
a304 1
    else
d315 1
a315 1
      {
d317 1
a317 1
      }
d319 1
a319 1
      {
d321 1
a321 1
      }
d327 1
a327 1
  }
@


1.6
log
@2000-11-08  Kazu Hirata  <kazu@@hxi.com>

	* coff-a29k.c: Fix formatting.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
@
text
@d96 1
a96 1
  bfd_byte  *hit_data =addr + (bfd_byte *)(data);
d131 1
a131 1
    insn = bfd_get_32(abfd, hit_data);
d159 1
a159 1
    bfd_put_32(abfd, insn ,hit_data);
d162 1
a162 1
    insn = bfd_get_32(abfd, hit_data);
d166 1
a166 1
    bfd_put_32(abfd, insn, hit_data);
d169 1
a169 1
    insn = bfd_get_32(abfd, hit_data);
d177 1
a177 1
    insn = bfd_get_32(abfd, hit_data);
d191 1
a191 1
    bfd_put_32(abfd, insn, hit_data);
d194 1
a194 1
    insn = bfd_get_8(abfd, hit_data);
d198 1
a198 1
    bfd_put_8(abfd, unsigned_value, hit_data);
d201 1
a201 1
    insn = bfd_get_16(abfd, hit_data);
d205 1
a205 1
    bfd_put_16(abfd, insn, hit_data);
d208 1
a208 1
    insn = bfd_get_32(abfd, hit_data);
d210 1
a210 1
    bfd_put_32(abfd, insn, hit_data);
@


1.5
log
@Remove U suffix from constants for K&R compilers.
Fix a couple of 64 bit nits.
@
text
@d52 1
a52 1
get_symbol_value (symbol)       
d54 1
a54 1
{                                             
d59 1
a59 1
    relocation = 0;                           
d61 2
a62 2
  else 
  {                                      
d66 1
a66 1
  }                                           
d97 1
a97 1
	
d111 1
a111 1
    if (r_type == R_IHIHALF) 
d119 1
a119 1
  if ((part1_consth_active) && (r_type != R_IHCONST)) 
a125 1

d128 1
a128 1
  switch (r_type) 
d130 2
a131 2
   case R_IREL: 	
    insn = bfd_get_32(abfd, hit_data); 
d146 2
a147 2
    } 
    else 
d154 1
a154 1
      if (signed_value>0x1ffff || signed_value<-0x20000) 
d159 1
a159 1
    bfd_put_32(abfd, insn ,hit_data); 
d161 2
a162 2
   case R_ILOHALF: 
    insn = bfd_get_32(abfd, hit_data); 
d166 1
a166 1
    bfd_put_32(abfd, insn, hit_data); 
d169 2
a170 2
    insn = bfd_get_32(abfd, hit_data); 
    /* consth, part 1 
d176 3
a178 3
   case R_IHCONST:	
    insn = bfd_get_32(abfd, hit_data); 
    /* consth, part 2 
d191 1
a191 1
    bfd_put_32(abfd, insn, hit_data); 
d194 2
a195 2
    insn = bfd_get_8(abfd, hit_data); 
    unsigned_value = insn + sym_value + reloc_entry->addend;	
d198 1
a198 1
    bfd_put_8(abfd, unsigned_value, hit_data); 
d201 2
a202 2
    insn = bfd_get_16(abfd, hit_data); 
    unsigned_value = insn + sym_value + reloc_entry->addend;	
d205 1
a205 1
    bfd_put_16(abfd, insn, hit_data); 
d208 2
a209 2
    insn = bfd_get_32(abfd, hit_data); 
    insn += sym_value + reloc_entry->addend;  
d217 1
a217 2

  return(bfd_reloc_ok);	
d229 1
a229 1
							       partial_inplace 
d234 1
a234 1
static reloc_howto_type howto_table[] = 
d285 1
a285 1
    relent->address = reloc->r_vaddr;		
d287 2
a288 2
    if (reloc->r_type == R_IHCONST) 
    {		
d299 1
a299 1
	relent->addend = reloc->r_symndx;		
d302 1
a302 1
    else 
d309 2
a310 2
      if (ptr 
	  && bfd_asymbol_bfd(ptr) == abfd		
d312 2
a313 2
	  && ((ptr->flags & BSF_OLD_COMMON)== 0))	
      {						
d315 1
a315 1
      }						
d317 3
a319 3
      {					
	  relent->addend = 0;			
      }			
d571 1
a571 1
    }     
a580 1
/*ARGSUSED*/
@


1.4
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 97, 98, 1999
d46 1
a46 1
    ((((WORD) & 0x00ff0000) >> 8) | ((WORD)& 0xff))
d48 1
a48 1
    ((HWORD) & 0x8000 ? (HWORD)|(~0xffffL) : (HWORD))
@


1.3
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d419 1
a419 1
			  rel->r_vaddr - input_section->vma)))
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d604 1
a604 58
const bfd_target a29kcoff_big_vec =
{
  "coff-a29k-big",		/* name */
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT),

  (SEC_HAS_CONTENTS | SEC_ALLOC /* section flags */
   | SEC_LOAD | SEC_RELOC  
   | SEC_READONLY ),
  '_',				/* leading underscore */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32,   bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16,
  /* hdrs */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32,   bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16,

 {
	    
   _bfd_dummy_target,
   coff_object_p,
   bfd_generic_archive_p,
   _bfd_dummy_target
  },
 {
   bfd_false,
   coff_mkobject,
   _bfd_generic_mkarchive,
   bfd_false
  },
 {
   bfd_false,
   coff_write_object_contents,
   _bfd_write_archive_contents,
   bfd_false
  },

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (coff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  COFF_SWAP_TABLE
 };
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1997 Free Software Foundation, Inc.
d239 23
a261 3
  {1},  {2},  {3},   {4},  {5},  {6},  {7},  {8},  {9}, {10},
  {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20},
  {21}, {22}, {23},
d335 1
a335 1
     bfd *output_bfd;
d586 4
a589 4
     bfd *obfd;
     struct bfd_link_info *info;
     bfd *ibfd;
     asection *sec;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

