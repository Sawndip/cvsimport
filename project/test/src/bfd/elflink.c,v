head	1.499;
access;
symbols
	sid-snapshot-20180601:1.499
	sid-snapshot-20180501:1.499
	sid-snapshot-20180401:1.499
	sid-snapshot-20180301:1.499
	sid-snapshot-20180201:1.499
	sid-snapshot-20180101:1.499
	sid-snapshot-20171201:1.499
	sid-snapshot-20171101:1.499
	sid-snapshot-20171001:1.499
	sid-snapshot-20170901:1.499
	sid-snapshot-20170801:1.499
	sid-snapshot-20170701:1.499
	sid-snapshot-20170601:1.499
	sid-snapshot-20170501:1.499
	sid-snapshot-20170401:1.499
	sid-snapshot-20170301:1.499
	sid-snapshot-20170201:1.499
	sid-snapshot-20170101:1.499
	sid-snapshot-20161201:1.499
	sid-snapshot-20161101:1.499
	sid-snapshot-20160901:1.499
	sid-snapshot-20160801:1.499
	sid-snapshot-20160701:1.499
	sid-snapshot-20160601:1.499
	sid-snapshot-20160501:1.499
	sid-snapshot-20160401:1.499
	sid-snapshot-20160301:1.499
	sid-snapshot-20160201:1.499
	sid-snapshot-20160101:1.499
	sid-snapshot-20151201:1.499
	sid-snapshot-20151101:1.499
	sid-snapshot-20151001:1.499
	sid-snapshot-20150901:1.499
	sid-snapshot-20150801:1.499
	sid-snapshot-20150701:1.499
	sid-snapshot-20150601:1.499
	sid-snapshot-20150501:1.499
	sid-snapshot-20150401:1.499
	sid-snapshot-20150301:1.499
	sid-snapshot-20150201:1.499
	sid-snapshot-20150101:1.499
	sid-snapshot-20141201:1.499
	sid-snapshot-20141101:1.499
	sid-snapshot-20141001:1.499
	sid-snapshot-20140901:1.499
	sid-snapshot-20140801:1.499
	sid-snapshot-20140701:1.499
	sid-snapshot-20140601:1.499
	sid-snapshot-20140501:1.499
	sid-snapshot-20140401:1.499
	sid-snapshot-20140301:1.499
	sid-snapshot-20140201:1.499
	sid-snapshot-20140101:1.499
	sid-snapshot-20131201:1.499
	sid-snapshot-20131101:1.499
	sid-snapshot-20131001:1.499
	binutils-2_24-branch:1.499.0.2
	binutils-2_24-branchpoint:1.499
	binutils-2_21_1:1.388.2.4
	sid-snapshot-20130901:1.499
	gdb_7_6_1-2013-08-30-release:1.472
	sid-snapshot-20130801:1.496
	sid-snapshot-20130701:1.494
	sid-snapshot-20130601:1.494
	sid-snapshot-20130501:1.492
	gdb_7_6-2013-04-26-release:1.472
	sid-snapshot-20130401:1.485
	binutils-2_23_2:1.450.4.4
	gdb_7_6-branch:1.472.0.2
	gdb_7_6-2013-03-12-branchpoint:1.472
	sid-snapshot-20130301:1.472
	sid-snapshot-20130201:1.464
	sid-snapshot-20130101:1.458
	sid-snapshot-20121201:1.457
	gdb_7_5_1-2012-11-29-release:1.450
	binutils-2_23_1:1.450.4.2
	sid-snapshot-20121101:1.456
	binutils-2_23:1.450.4.2
	sid-snapshot-20121001:1.454
	sid-snapshot-20120901:1.452
	gdb_7_5-2012-08-17-release:1.450
	sid-snapshot-20120801:1.450
	binutils-2_23-branch:1.450.0.4
	binutils-2_23-branchpoint:1.450
	gdb_7_5-branch:1.450.0.2
	gdb_7_5-2012-07-18-branchpoint:1.450
	sid-snapshot-20120701:1.448
	sid-snapshot-20120601:1.446
	sid-snapshot-20120501:1.438
	binutils-2_22_branch:1.420.2.10.0.2
	gdb_7_4_1-2012-04-26-release:1.432
	sid-snapshot-20120401:1.435
	sid-snapshot-20120301:1.433
	sid-snapshot-20120201:1.432
	gdb_7_4-2012-01-24-release:1.432
	sid-snapshot-20120101:1.432
	gdb_7_4-branch:1.432.0.2
	gdb_7_4-2011-12-13-branchpoint:1.432
	sid-snapshot-20111201:1.430
	binutils-2_22:1.420.2.10
	sid-snapshot-20111101:1.428
	sid-snapshot-20111001:1.422
	binutils-2_22-branch:1.420.0.2
	binutils-2_22-branchpoint:1.420
	gdb_7_3_1-2011-09-04-release:1.396
	sid-snapshot-20110901:1.418
	sid-snapshot-20110801:1.416
	gdb_7_3-2011-07-26-release:1.396
	sid-snapshot-20110701:1.412
	sid-snapshot-20110601:1.406
	sid-snapshot-20110501:1.402
	gdb_7_3-branch:1.396.0.2
	gdb_7_3-2011-04-01-branchpoint:1.396
	sid-snapshot-20110401:1.396
	sid-snapshot-20110301:1.394
	sid-snapshot-20110201:1.393
	sid-snapshot-20110101:1.393
	binutils-2_21:1.388
	sid-snapshot-20101201:1.388
	binutils-2_21-branch:1.388.0.2
	binutils-2_21-branchpoint:1.388
	sid-snapshot-20101101:1.388
	sid-snapshot-20101001:1.382
	binutils-2_20_1:1.352.2.1
	gdb_7_2-2010-09-02-release:1.372
	sid-snapshot-20100901:1.377
	sid-snapshot-20100801:1.373
	gdb_7_2-branch:1.372.0.2
	gdb_7_2-2010-07-07-branchpoint:1.372
	sid-snapshot-20100701:1.372
	sid-snapshot-20100601:1.372
	sid-snapshot-20100501:1.372
	sid-snapshot-20100401:1.371
	gdb_7_1-2010-03-18-release:1.368
	sid-snapshot-20100301:1.369
	gdb_7_1-branch:1.368.0.2
	gdb_7_1-2010-02-18-branchpoint:1.368
	sid-snapshot-20100201:1.367
	sid-snapshot-20100101:1.362
	gdb_7_0_1-2009-12-22-release:1.353
	sid-snapshot-20091201:1.361
	sid-snapshot-20091101:1.357
	binutils-2_20:1.352.2.1
	gdb_7_0-2009-10-06-release:1.353
	sid-snapshot-20091001:1.355
	gdb_7_0-branch:1.353.0.2
	gdb_7_0-2009-09-16-branchpoint:1.353
	arc-sim-20090309:1.298
	binutils-arc-20081103-branch:1.315.0.6
	binutils-arc-20081103-branchpoint:1.315
	binutils-2_20-branch:1.352.0.2
	binutils-2_20-branchpoint:1.352
	sid-snapshot-20090901:1.352
	sid-snapshot-20090801:1.350
	msnyder-checkpoint-072509-branch:1.350.0.2
	msnyder-checkpoint-072509-branchpoint:1.350
	sid-snapshot-20090701:1.345
	dje-cgen-play1-branch:1.345.0.2
	dje-cgen-play1-branchpoint:1.345
	sid-snapshot-20090601:1.340
	sid-snapshot-20090501:1.335
	sid-snapshot-20090401:1.332
	arc-20081103-branch:1.315.0.4
	arc-20081103-branchpoint:1.315
	arc-insight_6_8-branch:1.298.0.6
	arc-insight_6_8-branchpoint:1.298
	insight_6_8-branch:1.298.0.4
	insight_6_8-branchpoint:1.298
	sid-snapshot-20090301:1.330
	binutils-2_19_1:1.309
	sid-snapshot-20090201:1.329
	sid-snapshot-20090101:1.320
	reverse-20081226-branch:1.320.0.2
	reverse-20081226-branchpoint:1.320
	sid-snapshot-20081201:1.318
	multiprocess-20081120-branch:1.315.0.2
	multiprocess-20081120-branchpoint:1.315
	sid-snapshot-20081101:1.315
	binutils-2_19:1.309
	sid-snapshot-20081001:1.312
	reverse-20080930-branch:1.312.0.2
	reverse-20080930-branchpoint:1.312
	binutils-2_19-branch:1.309.0.2
	binutils-2_19-branchpoint:1.309
	sid-snapshot-20080901:1.309
	sid-snapshot-20080801:1.306
	reverse-20080717-branch:1.304.0.4
	reverse-20080717-branchpoint:1.304
	sid-snapshot-20080701:1.304
	msnyder-reverse-20080609-branch:1.304.0.2
	msnyder-reverse-20080609-branchpoint:1.304
	drow-reverse-20070409-branch:1.255.0.2
	drow-reverse-20070409-branchpoint:1.255
	sid-snapshot-20080601:1.304
	sid-snapshot-20080501:1.304
	sid-snapshot-20080403:1.302
	sid-snapshot-20080401:1.302
	gdb_6_8-2008-03-27-release:1.298
	sid-snapshot-20080301:1.298
	gdb_6_8-branch:1.298.0.2
	gdb_6_8-2008-02-26-branchpoint:1.298
	sid-snapshot-20080201:1.294
	sid-snapshot-20080101:1.290
	sid-snapshot-20071201:1.287
	sid-snapshot-20071101:1.285
	gdb_6_7_1-2007-10-29-release:1.276
	gdb_6_7-2007-10-10-release:1.276
	sid-snapshot-20071001:1.281
	gdb_6_7-branch:1.276.0.2
	gdb_6_7-2007-09-07-branchpoint:1.276
	binutils-2_18:1.274.2.1
	binutils-2_18-branch:1.274.0.2
	binutils-2_18-branchpoint:1.274
	insight_6_6-20070208-release:1.237
	binutils-csl-coldfire-4_1-32:1.207.2.3
	binutils-csl-sourcerygxx-4_1-32:1.207.2.3
	gdb_6_6-2006-12-18-release:1.237
	binutils-csl-innovasic-fido-3_4_4-33:1.207.2.3
	binutils-csl-sourcerygxx-3_4_4-32:1.136.2.3
	binutils-csl-coldfire-4_1-30:1.207.2.2
	binutils-csl-sourcerygxx-4_1-30:1.207.2.2
	binutils-csl-coldfire-4_1-28:1.207.2.2
	binutils-csl-sourcerygxx-4_1-29:1.207.2.3
	binutils-csl-sourcerygxx-4_1-28:1.207.2.2
	gdb_6_6-branch:1.237.0.2
	gdb_6_6-2006-11-15-branchpoint:1.237
	binutils-csl-arm-2006q3-27:1.207.2.2
	binutils-csl-sourcerygxx-4_1-27:1.207.2.2
	binutils-csl-arm-2006q3-26:1.207.2.2
	binutils-csl-sourcerygxx-4_1-26:1.207.2.2
	binutils-csl-sourcerygxx-4_1-25:1.207.2.2
	binutils-csl-sourcerygxx-4_1-24:1.207.2.2
	binutils-csl-sourcerygxx-4_1-23:1.207.2.2
	insight_6_5-20061003-release:1.213
	gdb-csl-symbian-6_4_50_20060226-12:1.204
	binutils-csl-sourcerygxx-4_1-21:1.207.2.2
	binutils-csl-arm-2006q3-21:1.207.2.2
	binutils-csl-sourcerygxx-4_1-22:1.207.2.2
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.207.2.2
	binutils-csl-sourcerygxx-4_1-20:1.207.2.2
	binutils-csl-arm-2006q3-19:1.207.2.2
	binutils-csl-sourcerygxx-4_1-19:1.207.2.2
	binutils-csl-sourcerygxx-4_1-18:1.207.2.2
	binutils-csl-renesas-4_1-9:1.207.2.2
	gdb-csl-sourcerygxx-3_4_4-25:1.197
	binutils-csl-sourcerygxx-3_4_4-25:1.136.2.3
	nickrob-async-20060828-mergepoint:1.227
	gdb-csl-symbian-6_4_50_20060226-11:1.204
	binutils-csl-renesas-4_1-8:1.207.2.1
	binutils-csl-renesas-4_1-7:1.207.2.1
	binutils-csl-renesas-4_1-6:1.207.2.1
	gdb-csl-sourcerygxx-4_1-17:1.204
	binutils-csl-sourcerygxx-4_1-17:1.207.2.1
	gdb-csl-20060226-branch-local-2:1.204
	gdb-csl-sourcerygxx-4_1-14:1.204
	binutils-csl-sourcerygxx-4_1-14:1.207.2.1
	binutils-csl-sourcerygxx-4_1-15:1.207.2.1
	gdb-csl-sourcerygxx-4_1-13:1.204
	binutils-csl-sourcerygxx-4_1-13:1.207.2.1
	binutils-2_17:1.210.2.4
	gdb-csl-sourcerygxx-4_1-12:1.204
	binutils-csl-sourcerygxx-4_1-12:1.207.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.204
	binutils-csl-sourcerygxx-3_4_4-21:1.207.2.1
	gdb_6_5-20060621-release:1.213
	binutils-csl-wrs-linux-3_4_4-24:1.136.2.1.2.1
	binutils-csl-wrs-linux-3_4_4-23:1.136.2.1.2.1
	gdb-csl-sourcerygxx-4_1-9:1.204
	binutils-csl-sourcerygxx-4_1-9:1.207.2.1
	gdb-csl-sourcerygxx-4_1-8:1.204
	binutils-csl-sourcerygxx-4_1-8:1.207.2.1
	gdb-csl-sourcerygxx-4_1-7:1.204
	binutils-csl-sourcerygxx-4_1-7:1.207.2.1
	gdb-csl-arm-2006q1-6:1.204
	binutils-csl-arm-2006q1-6:1.207.2.1
	gdb-csl-sourcerygxx-4_1-6:1.204
	binutils-csl-sourcerygxx-4_1-6:1.207.2.1
	binutils-csl-wrs-linux-3_4_4-22:1.136.2.1.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.204
	gdb-csl-symbian-6_4_50_20060226-9:1.204
	gdb-csl-symbian-6_4_50_20060226-8:1.204
	gdb-csl-coldfire-4_1-11:1.204
	binutils-csl-coldfire-4_1-11:1.207
	gdb-csl-sourcerygxx-3_4_4-19:1.204
	binutils-csl-sourcerygxx-3_4_4-19:1.207
	gdb-csl-coldfire-4_1-10:1.204
	gdb_6_5-branch:1.213.0.4
	gdb_6_5-2006-05-14-branchpoint:1.213
	binutils-csl-coldfire-4_1-10:1.207
	gdb-csl-sourcerygxx-4_1-5:1.204
	binutils-csl-sourcerygxx-4_1-5:1.207
	nickrob-async-20060513-branch:1.213.0.2
	nickrob-async-20060513-branchpoint:1.213
	gdb-csl-sourcerygxx-4_1-4:1.204
	binutils-csl-sourcerygxx-4_1-4:1.207
	msnyder-reverse-20060502-branch:1.210.0.6
	msnyder-reverse-20060502-branchpoint:1.210
	binutils-csl-wrs-linux-3_4_4-21:1.136.2.1.2.1
	gdb-csl-morpho-4_1-4:1.204
	binutils-csl-morpho-4_1-4:1.207
	gdb-csl-sourcerygxx-3_4_4-17:1.204
	binutils-csl-sourcerygxx-3_4_4-17:1.207
	binutils-csl-wrs-linux-3_4_4-20:1.136.2.1.2.1
	readline_5_1-import-branch:1.210.0.4
	readline_5_1-import-branchpoint:1.210
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.204
	binutils-2_17-branch:1.210.0.2
	binutils-2_17-branchpoint:1.210
	gdb-csl-symbian-20060226-branch:1.204.0.6
	gdb-csl-symbian-20060226-branchpoint:1.204
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.204
	msnyder-reverse-20060331-branch:1.208.0.2
	msnyder-reverse-20060331-branchpoint:1.208
	binutils-csl-2_17-branch:1.207.0.2
	binutils-csl-2_17-branchpoint:1.207
	gdb-csl-available-20060303-branch:1.204.0.4
	gdb-csl-available-20060303-branchpoint:1.204
	gdb-csl-20060226-branch:1.204.0.2
	gdb-csl-20060226-branchpoint:1.204
	gdb_6_4-20051202-release:1.196
	msnyder-fork-checkpoint-branch:1.197.0.4
	msnyder-fork-checkpoint-branchpoint:1.197
	gdb-csl-gxxpro-6_3-branch:1.197.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.197
	gdb_6_4-branch:1.196.0.2
	gdb_6_4-2005-11-01-branchpoint:1.196
	gdb-csl-arm-20051020-branch:1.194.0.2
	gdb-csl-arm-20051020-branchpoint:1.194
	binutils-csl-gxxpro-3_4-branch:1.136.2.3.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.136.2.3
	binutils-2_16_1:1.136.2.3
	msnyder-tracepoint-checkpoint-branch:1.165.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.165
	gdb-csl-arm-20050325-2005-q1b:1.142
	binutils-csl-arm-2005q1b:1.136.2.1.2.1
	binutils-2_16:1.136.2.3
	gdb-csl-arm-20050325-2005-q1a:1.142
	binutils-csl-arm-2005q1a:1.136.2.1
	csl-arm-20050325-branch:1.142.0.2
	csl-arm-20050325-branchpoint:1.142
	binutils-csl-arm-2005q1-branch:1.136.2.1.0.2
	binutils-csl-arm-2005q1-branchpoint:1.136.2.1
	binutils-2_16-branch:1.136.0.2
	binutils-2_16-branchpoint:1.136
	csl-arm-2004-q3d:1.116
	gdb_6_3-20041109-release:1.112
	gdb_6_3-branch:1.112.0.2
	gdb_6_3-20041019-branchpoint:1.112
	csl-arm-2004-q3:1.104
	drow_intercu-merge-20040921:1.103
	drow_intercu-merge-20040915:1.101
	jimb-gdb_6_2-e500-branch:1.80.0.6
	jimb-gdb_6_2-e500-branchpoint:1.80
	gdb_6_2-20040730-release:1.80
	gdb_6_2-branch:1.80.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.80
	gdb_6_1_1-20040616-release:1.53
	binutils-2_15:1.51.6.4
	binutils-2_15-branchpoint:1.51
	csl-arm-2004-q1a:1.68
	csl-arm-2004-q1:1.64
	gdb_6_1-2004-04-05-release:1.53
	drow_intercu-merge-20040402:1.63
	drow_intercu-merge-20040327:1.62
	ezannoni_pie-20040323-branch:1.59.0.2
	ezannoni_pie-20040323-branchpoint:1.59
	cagney_tramp-20040321-mergepoint:1.59
	cagney_tramp-20040309-branch:1.54.0.2
	cagney_tramp-20040309-branchpoint:1.54
	gdb_6_1-branch:1.53.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.53
	drow_intercu-20040221-branch:1.51.0.8
	drow_intercu-20040221-branchpoint:1.51
	binutils-2_15-branch:1.51.0.6
	cagney_bfdfile-20040213-branch:1.51.0.4
	cagney_bfdfile-20040213-branchpoint:1.51
	drow-cplus-merge-20040208:1.51
	carlton_dictionary-20040126-merge:1.51
	cagney_bigcore-20040122-branch:1.51.0.2
	cagney_bigcore-20040122-branchpoint:1.51
	drow-cplus-merge-20040113:1.51
	csl-arm-2003-q4:1.51
	drow-cplus-merge-20031224:1.51
	drow-cplus-merge-20031220:1.51
	carlton_dictionary-20031215-merge:1.51
	drow-cplus-merge-20031214:1.51
	carlton-dictionary-20031111-merge:1.49
	gdb_6_0-2003-10-04-release:1.35
	kettenis_sparc-20030918-branch:1.44.0.6
	kettenis_sparc-20030918-branchpoint:1.44
	carlton_dictionary-20030917-merge:1.44
	ezannoni_pie-20030916-branchpoint:1.44
	ezannoni_pie-20030916-branch:1.44.0.4
	cagney_x86i386-20030821-branch:1.44.0.2
	cagney_x86i386-20030821-branchpoint:1.44
	carlton_dictionary-20030805-merge:1.42
	carlton_dictionary-20030627-merge:1.35
	gdb_6_0-branch:1.35.0.6
	gdb_6_0-2003-06-23-branchpoint:1.35
	jimb-ppc64-linux-20030613-branch:1.35.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.35
	binutils-2_14:1.30
	cagney_convert-20030606-branch:1.35.0.2
	cagney_convert-20030606-branchpoint:1.35
	cagney_writestrings-20030508-branch:1.31.0.4
	cagney_writestrings-20030508-branchpoint:1.31
	jimb-ppc64-linux-20030528-branch:1.34.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.34
	carlton_dictionary-20030523-merge:1.34
	cagney_fileio-20030521-branch:1.34.0.2
	cagney_fileio-20030521-branchpoint:1.34
	kettenis_i386newframe-20030517-mergepoint:1.33
	jimb-ppc64-linux-20030509-branch:1.31.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.31
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.30
	binutils-2_14-branch:1.30.0.18
	binutils-2_14-branchpoint:1.30
	kettenis_i386newframe-20030419-branch:1.30.0.16
	kettenis_i386newframe-20030419-branchpoint:1.30
	carlton_dictionary-20030416-merge:1.30
	cagney_frameaddr-20030409-mergepoint:1.30
	kettenis_i386newframe-20030406-branch:1.30.0.14
	kettenis_i386newframe-20030406-branchpoint:1.30
	cagney_frameaddr-20030403-branchpoint:1.30
	cagney_frameaddr-20030403-branch:1.30.0.12
	cagney_framebase-20030330-mergepoint:1.30
	cagney_framebase-20030326-branch:1.30.0.10
	cagney_framebase-20030326-branchpoint:1.30
	cagney_lazyid-20030317-branch:1.30.0.8
	cagney_lazyid-20030317-branchpoint:1.30
	kettenis-i386newframe-20030316-mergepoint:1.30
	offbyone-20030313-branch:1.30.0.6
	offbyone-20030313-branchpoint:1.30
	kettenis-i386newframe-20030308-branch:1.30.0.4
	kettenis-i386newframe-20030308-branchpoint:1.30
	carlton_dictionary-20030305-merge:1.30
	cagney_offbyone-20030303-branch:1.30.0.2
	cagney_offbyone-20030303-branchpoint:1.30
	carlton_dictionary-20030207-merge:1.29
	interps-20030202-branch:1.29.0.4
	interps-20030202-branchpoint:1.29
	cagney-unwind-20030108-branch:1.29.0.2
	cagney-unwind-20030108-branchpoint:1.29
	binutils-2_13_2_1:1.26.2.2
	binutils-2_13_2:1.26.2.2
	carlton_dictionary-20021223-merge:1.29
	gdb_5_3-2002-12-12-release:1.27
	carlton_dictionary-20021115-merge:1.28
	binutils-2_13_1:1.26.2.2
	kseitz_interps-20021105-merge:1.28
	kseitz_interps-20021103-merge:1.28
	drow-cplus-merge-20021020:1.28
	drow-cplus-merge-20021025:1.28
	carlton_dictionary-20021025-merge:1.28
	carlton_dictionary-20021011-merge:1.28
	drow-cplus-branch:1.27.0.12
	drow-cplus-branchpoint:1.27
	kseitz_interps-20020930-merge:1.27
	carlton_dictionary-20020927-merge:1.27
	carlton_dictionary-branch:1.27.0.10
	carlton_dictionary-20020920-branchpoint:1.27
	sid-20020905-branchpoint:1.27
	sid-20020905-branch:1.27.0.8
	gdb_5_3-branch:1.27.0.6
	gdb_5_3-2002-09-04-branchpoint:1.27
	kseitz_interps-20020829-merge:1.27
	cagney_sysregs-20020825-branch:1.27.0.4
	cagney_sysregs-20020825-branchpoint:1.27
	readline_4_3-import-branch:1.27.0.2
	readline_4_3-import-branchpoint:1.27
	binutils-2_13:1.26.2.1
	gdb_5_2_1-2002-07-23-release:1.23
	binutils-2_13-branchpoint:1.26
	binutils-2_13-branch:1.26.0.2
	kseitz_interps-20020528-branch:1.24.0.6
	kseitz_interps-20020528-branchpoint:1.24
	cagney_regbuf-20020515-branch:1.24.0.4
	cagney_regbuf-20020515-branchpoint:1.24
	binutils-2_12_1:1.23.2.1
	jimb-macro-020506-branch:1.24.0.2
	jimb-macro-020506-branchpoint:1.24
	gdb_5_2-2002-04-29-release:1.23
	binutils-2_12:1.23
	gdb_5_2-branch:1.23.0.4
	gdb_5_2-2002-03-03-branchpoint:1.23
	binutils-2_12-branch:1.23.0.2
	binutils-2_12-branchpoint:1.23
	gdb_5_1_1-2002-01-24-release:1.18
	gdb_5_1_0_1-2002-01-03-release:1.18
	cygnus_cvs_20020108_pre:1.22
	gdb_5_1_0_1-2002-01-03-branch:1.18.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.18
	gdb_5_1-2001-11-21-release:1.18
	gdb_s390-2001-09-26-branch:1.18.0.4
	gdb_s390-2001-09-26-branchpoint:1.18
	gdb_5_1-2001-07-29-branch:1.18.0.2
	gdb_5_1-2001-07-29-branchpoint:1.18
	binutils-2_11_2:1.16.2.2
	binutils-2_11_1:1.16.2.2
	binutils-2_11:1.16
	x86_64versiong3:1.16
	binutils-2_11-branch:1.16.0.2
	insight-precleanup-2001-01-01:1.14
	binutils-2_10_1:1.10.2.2
	binutils-2_10:1.10
	gdb-premipsmulti-2000-06-06-branch:1.13.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.13
	gdb_5_0-2000-05-19-release:1.10
	gdb_4_18_2-2000-05-18-release:1.10
	gdb_4_95_1-2000-05-11-snapshot:1.10
	gdb_4_95_0-2000-04-27-snapshot:1.10
	gdb_5_0-2000-04-10-branch:1.10.0.4
	gdb_5_0-2000-04-10-branchpoint:1.10
	binutils-2_10-branch:1.10.0.2
	binutils-2_10-branchpoint:1.10
	binutils_latest_snapshot:1.499
	repo-unification-2000-02-06:1.9
	binu_ss_19990721:1.7
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.499
date	2013.08.27.01.06.43;	author amodra;	state Exp;
branches;
next	1.498;

1.498
date	2013.08.21.04.09.30;	author amodra;	state Exp;
branches;
next	1.497;

1.497
date	2013.08.21.03.45.44;	author amodra;	state Exp;
branches;
next	1.496;

1.496
date	2013.07.25.00.14.11;	author amodra;	state Exp;
branches;
next	1.495;

1.495
date	2013.07.20.09.50.16;	author amodra;	state Exp;
branches;
next	1.494;

1.494
date	2013.05.08.23.31.38;	author amodra;	state Exp;
branches;
next	1.493;

1.493
date	2013.05.06.08.45.40;	author amodra;	state Exp;
branches;
next	1.492;

1.492
date	2013.04.30.12.13.09;	author nickc;	state Exp;
branches;
next	1.491;

1.491
date	2013.04.30.01.05.18;	author amodra;	state Exp;
branches;
next	1.490;

1.490
date	2013.04.29.13.38.58;	author nickc;	state Exp;
branches;
next	1.489;

1.489
date	2013.04.24.13.24.30;	author nickc;	state Exp;
branches;
next	1.488;

1.488
date	2013.04.24.13.19.27;	author nickc;	state Exp;
branches;
next	1.487;

1.487
date	2013.04.05.09.08.28;	author nickc;	state Exp;
branches;
next	1.486;

1.486
date	2013.04.04.14.38.01;	author amodra;	state Exp;
branches;
next	1.485;

1.485
date	2013.03.27.13.37.50;	author amodra;	state Exp;
branches;
next	1.484;

1.484
date	2013.03.26.07.02.52;	author amodra;	state Exp;
branches;
next	1.483;

1.483
date	2013.03.26.06.08.14;	author amodra;	state Exp;
branches;
next	1.482;

1.482
date	2013.03.25.06.12.06;	author amodra;	state Exp;
branches;
next	1.481;

1.481
date	2013.03.25.06.06.35;	author amodra;	state Exp;
branches;
next	1.480;

1.480
date	2013.03.25.06.03.48;	author amodra;	state Exp;
branches;
next	1.479;

1.479
date	2013.03.25.06.02.28;	author amodra;	state Exp;
branches;
next	1.478;

1.478
date	2013.03.25.06.00.06;	author amodra;	state Exp;
branches;
next	1.477;

1.477
date	2013.03.23.10.25.02;	author amodra;	state Exp;
branches;
next	1.476;

1.476
date	2013.03.22.23.35.55;	author amodra;	state Exp;
branches;
next	1.475;

1.475
date	2013.03.21.16.08.06;	author nickc;	state Exp;
branches;
next	1.474;

1.474
date	2013.03.20.03.44.56;	author amodra;	state Exp;
branches;
next	1.473;

1.473
date	2013.03.18.02.47.02;	author amodra;	state Exp;
branches;
next	1.472;

1.472
date	2013.02.22.01.20.48;	author hjl;	state Exp;
branches;
next	1.471;

1.471
date	2013.02.21.02.29.09;	author amodra;	state Exp;
branches;
next	1.470;

1.470
date	2013.02.18.10.40.19;	author amodra;	state Exp;
branches;
next	1.469;

1.469
date	2013.02.16.17.54.37;	author hjl;	state Exp;
branches;
next	1.468;

1.468
date	2013.02.16.17.48.57;	author hjl;	state Exp;
branches;
next	1.467;

1.467
date	2013.02.11.05.30.53;	author amodra;	state Exp;
branches;
next	1.466;

1.466
date	2013.02.10.04.36.33;	author amodra;	state Exp;
branches;
next	1.465;

1.465
date	2013.02.08.01.33.01;	author hjl;	state Exp;
branches;
next	1.464;

1.464
date	2013.01.18.17.43.57;	author vapier;	state Exp;
branches;
next	1.463;

1.463
date	2013.01.13.12.32.10;	author amodra;	state Exp;
branches;
next	1.462;

1.462
date	2013.01.11.14.09.59;	author amodra;	state Exp;
branches;
next	1.461;

1.461
date	2013.01.11.13.55.02;	author amodra;	state Exp;
branches;
next	1.460;

1.460
date	2013.01.10.20.03.54;	author hjl;	state Exp;
branches;
next	1.459;

1.459
date	2013.01.03.15.47.46;	author nickc;	state Exp;
branches;
next	1.458;

1.458
date	2012.12.19.19.45.43;	author hjl;	state Exp;
branches;
next	1.457;

1.457
date	2012.11.20.22.17.26;	author hjl;	state Exp;
branches;
next	1.456;

1.456
date	2012.10.30.12.44.53;	author nickc;	state Exp;
branches;
next	1.455;

1.455
date	2012.10.23.09.33.54;	author nathan;	state Exp;
branches;
next	1.454;

1.454
date	2012.09.19.00.53.28;	author hjl;	state Exp;
branches;
next	1.453;

1.453
date	2012.09.02.12.17.27;	author hjl;	state Exp;
branches;
next	1.452;

1.452
date	2012.08.28.20.13.27;	author macro;	state Exp;
branches;
next	1.451;

1.451
date	2012.08.06.22.27.50;	author macro;	state Exp;
branches;
next	1.450;

1.450
date	2012.07.09.08.17.34;	author amodra;	state Exp;
branches
	1.450.4.1;
next	1.449;

1.449
date	2012.07.03.14.44.34;	author hjl;	state Exp;
branches;
next	1.448;

1.448
date	2012.06.29.14.46.02;	author amodra;	state Exp;
branches;
next	1.447;

1.447
date	2012.06.06.10.50.13;	author amodra;	state Exp;
branches;
next	1.446;

1.446
date	2012.05.27.13.55.45;	author amodra;	state Exp;
branches;
next	1.445;

1.445
date	2012.05.25.01.12.19;	author amodra;	state Exp;
branches;
next	1.444;

1.444
date	2012.05.23.04.35.31;	author amodra;	state Exp;
branches;
next	1.443;

1.443
date	2012.05.22.14.58.15;	author amodra;	state Exp;
branches;
next	1.442;

1.442
date	2012.05.22.12.09.26;	author amodra;	state Exp;
branches;
next	1.441;

1.441
date	2012.05.16.14.13.26;	author amodra;	state Exp;
branches;
next	1.440;

1.440
date	2012.05.14.19.45.18;	author jwlemke;	state Exp;
branches;
next	1.439;

1.439
date	2012.05.01.16.07.34;	author nickc;	state Exp;
branches;
next	1.438;

1.438
date	2012.04.24.05.12.36;	author amodra;	state Exp;
branches;
next	1.437;

1.437
date	2012.04.13.23.19.59;	author hjl;	state Exp;
branches;
next	1.436;

1.436
date	2012.04.12.07.35.04;	author nickc;	state Exp;
branches;
next	1.435;

1.435
date	2012.03.29.23.17.37;	author amodra;	state Exp;
branches;
next	1.434;

1.434
date	2012.03.23.09.27.43;	author amodra;	state Exp;
branches;
next	1.433;

1.433
date	2012.02.08.10.12.20;	author amodra;	state Exp;
branches;
next	1.432;

1.432
date	2011.12.07.12.15.54;	author amodra;	state Exp;
branches;
next	1.431;

1.431
date	2011.12.03.10.29.01;	author amodra;	state Exp;
branches;
next	1.430;

1.430
date	2011.11.15.11.33.57;	author amodra;	state Exp;
branches;
next	1.429;

1.429
date	2011.11.08.13.49.11;	author amodra;	state Exp;
branches;
next	1.428;

1.428
date	2011.10.19.07.17.19;	author amodra;	state Exp;
branches;
next	1.427;

1.427
date	2011.10.19.05.24.38;	author amodra;	state Exp;
branches;
next	1.426;

1.426
date	2011.10.19.04.13.28;	author amodra;	state Exp;
branches;
next	1.425;

1.425
date	2011.10.08.16.51.09;	author hjl;	state Exp;
branches;
next	1.424;

1.424
date	2011.10.08.07.50.19;	author amodra;	state Exp;
branches;
next	1.423;

1.423
date	2011.10.07.23.06.09;	author amodra;	state Exp;
branches;
next	1.422;

1.422
date	2011.09.29.05.40.21;	author amodra;	state Exp;
branches;
next	1.421;

1.421
date	2011.09.29.00.13.13;	author hjl;	state Exp;
branches;
next	1.420;

1.420
date	2011.09.16.01.17.16;	author hjl;	state Exp;
branches
	1.420.2.1;
next	1.419;

1.419
date	2011.09.16.01.15.18;	author hjl;	state Exp;
branches;
next	1.418;

1.418
date	2011.08.17.00.39.38;	author amodra;	state Exp;
branches;
next	1.417;

1.417
date	2011.08.05.03.17.11;	author amodra;	state Exp;
branches;
next	1.416;

1.416
date	2011.07.14.03.57.18;	author amodra;	state Exp;
branches;
next	1.415;

1.415
date	2011.07.11.18.39.13;	author hjl;	state Exp;
branches;
next	1.414;

1.414
date	2011.07.11.15.03.05;	author clm;	state Exp;
branches;
next	1.413;

1.413
date	2011.07.09.06.20.50;	author amodra;	state Exp;
branches;
next	1.412;

1.412
date	2011.06.21.14.55.26;	author amodra;	state Exp;
branches;
next	1.411;

1.411
date	2011.06.14.02.45.12;	author amodra;	state Exp;
branches;
next	1.410;

1.410
date	2011.06.13.00.59.14;	author amodra;	state Exp;
branches;
next	1.409;

1.409
date	2011.06.10.14.04.23;	author nickc;	state Exp;
branches;
next	1.408;

1.408
date	2011.06.09.04.52.14;	author hjl;	state Exp;
branches;
next	1.407;

1.407
date	2011.06.07.23.57.50;	author amodra;	state Exp;
branches;
next	1.406;

1.406
date	2011.05.26.04.28.20;	author amodra;	state Exp;
branches;
next	1.405;

1.405
date	2011.05.18.14.04.31;	author nickc;	state Exp;
branches;
next	1.404;

1.404
date	2011.05.17.13.02.17;	author amodra;	state Exp;
branches;
next	1.403;

1.403
date	2011.05.07.14.12.59;	author hjl;	state Exp;
branches;
next	1.402;

1.402
date	2011.04.24.10.02.13;	author amodra;	state Exp;
branches;
next	1.401;

1.401
date	2011.04.20.07.17.01;	author amodra;	state Exp;
branches;
next	1.400;

1.400
date	2011.04.20.07.00.46;	author amodra;	state Exp;
branches;
next	1.399;

1.399
date	2011.04.20.00.22.08;	author amodra;	state Exp;
branches;
next	1.398;

1.398
date	2011.04.20.00.11.31;	author amodra;	state Exp;
branches;
next	1.397;

1.397
date	2011.04.17.23.15.12;	author amodra;	state Exp;
branches;
next	1.396;

1.396
date	2011.03.14.15.54.58;	author rsandifo;	state Exp;
branches;
next	1.395;

1.395
date	2011.03.02.17.07.03;	author bernds;	state Exp;
branches;
next	1.394;

1.394
date	2011.02.14.17.03.45;	author vapier;	state Exp;
branches;
next	1.393;

1.393
date	2010.12.31.02.43.21;	author hjl;	state Exp;
branches;
next	1.392;

1.392
date	2010.12.31.00.33.32;	author hjl;	state Exp;
branches;
next	1.391;

1.391
date	2010.12.13.01.06.15;	author amodra;	state Exp;
branches;
next	1.390;

1.390
date	2010.12.12.14.52.26;	author hjl;	state Exp;
branches;
next	1.389;

1.389
date	2010.12.04.04.42.06;	author amodra;	state Exp;
branches;
next	1.388;

1.388
date	2010.10.29.12.10.24;	author hjl;	state Exp;
branches
	1.388.2.1;
next	1.387;

1.387
date	2010.10.21.12.29.02;	author ro;	state Exp;
branches;
next	1.386;

1.386
date	2010.10.14.01.31.27;	author davek;	state Exp;
branches;
next	1.385;

1.385
date	2010.10.11.00.21.44;	author davek;	state Exp;
branches;
next	1.384;

1.384
date	2010.10.08.14.00.47;	author amodra;	state Exp;
branches;
next	1.383;

1.383
date	2010.10.04.14.13.09;	author bernds;	state Exp;
branches;
next	1.382;

1.382
date	2010.10.01.04.28.04;	author hjl;	state Exp;
branches;
next	1.381;

1.381
date	2010.09.24.12.14.25;	author tschwinge;	state Exp;
branches;
next	1.380;

1.380
date	2010.09.24.11.59.19;	author tschwinge;	state Exp;
branches;
next	1.379;

1.379
date	2010.09.16.00.06.11;	author amodra;	state Exp;
branches;
next	1.378;

1.378
date	2010.09.09.09.55.03;	author bernds;	state Exp;
branches;
next	1.377;

1.377
date	2010.08.28.04.04.16;	author amodra;	state Exp;
branches;
next	1.376;

1.376
date	2010.08.25.20.35.58;	author hjl;	state Exp;
branches;
next	1.375;

1.375
date	2010.08.22.19.14.24;	author hjl;	state Exp;
branches;
next	1.374;

1.374
date	2010.08.12.16.23.32;	author nickc;	state Exp;
branches;
next	1.373;

1.373
date	2010.07.30.16.29.58;	author hjl;	state Exp;
branches;
next	1.372;

1.372
date	2010.04.14.08.29.33;	author mgretton;	state Exp;
branches;
next	1.371;

1.371
date	2010.03.21.23.26.33;	author hjl;	state Exp;
branches;
next	1.370;

1.370
date	2010.03.05.19.48.55;	author ro;	state Exp;
branches;
next	1.369;

1.369
date	2010.02.19.01.47.13;	author amodra;	state Exp;
branches;
next	1.368;

1.368
date	2010.02.04.09.16.41;	author nickc;	state Exp;
branches;
next	1.367;

1.367
date	2010.01.26.13.21.36;	author hjl;	state Exp;
branches;
next	1.366;

1.366
date	2010.01.21.14.54.40;	author nickc;	state Exp;
branches;
next	1.365;

1.365
date	2010.01.08.03.03.16;	author hjl;	state Exp;
branches;
next	1.364;

1.364
date	2010.01.08.01.43.22;	author hjl;	state Exp;
branches;
next	1.363;

1.363
date	2010.01.07.13.44.36;	author hjl;	state Exp;
branches;
next	1.362;

1.362
date	2009.12.11.13.42.03;	author nickc;	state Exp;
branches;
next	1.361;

1.361
date	2009.11.23.14.41.29;	author pbrook;	state Exp;
branches;
next	1.360;

1.360
date	2009.11.09.14.37.14;	author hjl;	state Exp;
branches;
next	1.359;

1.359
date	2009.11.05.15.34.18;	author nickc;	state Exp;
branches;
next	1.358;

1.358
date	2009.11.02.06.27.08;	author amodra;	state Exp;
branches;
next	1.357;

1.357
date	2009.10.13.04.06.20;	author amodra;	state Exp;
branches;
next	1.356;

1.356
date	2009.10.13.02.35.08;	author roland;	state Exp;
branches;
next	1.355;

1.355
date	2009.09.24.15.56.50;	author hjl;	state Exp;
branches;
next	1.354;

1.354
date	2009.09.23.13.54.28;	author amodra;	state Exp;
branches;
next	1.353;

1.353
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.352;

1.352
date	2009.08.11.02.21.34;	author amodra;	state Exp;
branches
	1.352.2.1;
next	1.351;

1.351
date	2009.08.10.06.14.04;	author amodra;	state Exp;
branches;
next	1.350;

1.350
date	2009.07.23.13.00.20;	author nickc;	state Exp;
branches;
next	1.349;

1.349
date	2009.07.22.23.55.54;	author hjl;	state Exp;
branches;
next	1.348;

1.348
date	2009.07.22.21.30.30;	author hjl;	state Exp;
branches;
next	1.347;

1.347
date	2009.07.21.21.37.25;	author hjl;	state Exp;
branches;
next	1.346;

1.346
date	2009.07.10.10.04.20;	author amodra;	state Exp;
branches;
next	1.345;

1.345
date	2009.06.20.13.13.11;	author hjl;	state Exp;
branches;
next	1.344;

1.344
date	2009.06.18.10.48.58;	author nickc;	state Exp;
branches;
next	1.343;

1.343
date	2009.06.17.18.08.35;	author hjl;	state Exp;
branches;
next	1.342;

1.342
date	2009.06.16.13.41.10;	author hjl;	state Exp;
branches;
next	1.341;

1.341
date	2009.06.06.22.39.24;	author hjl;	state Exp;
branches;
next	1.340;

1.340
date	2009.06.01.12.53.00;	author hjl;	state Exp;
branches;
next	1.339;

1.339
date	2009.05.26.22.18.22;	author hjl;	state Exp;
branches;
next	1.338;

1.338
date	2009.05.21.14.32.29;	author amodra;	state Exp;
branches;
next	1.337;

1.337
date	2009.05.21.14.15.48;	author amodra;	state Exp;
branches;
next	1.336;

1.336
date	2009.05.04.12.09.29;	author davek;	state Exp;
branches;
next	1.335;

1.335
date	2009.04.30.15.47.10;	author nickc;	state Exp;
branches;
next	1.334;

1.334
date	2009.04.08.16.04.48;	author hjl;	state Exp;
branches;
next	1.333;

1.333
date	2009.04.07.20.04.08;	author hjl;	state Exp;
branches;
next	1.332;

1.332
date	2009.03.31.01.42.29;	author dj;	state Exp;
branches;
next	1.331;

1.331
date	2009.03.13.11.34.42;	author nickc;	state Exp;
branches;
next	1.330;

1.330
date	2009.02.12.15.06.55;	author nickc;	state Exp;
branches;
next	1.329;

1.329
date	2009.01.31.11.44.37;	author amodra;	state Exp;
branches;
next	1.328;

1.328
date	2009.01.29.16.35.03;	author jsm28;	state Exp;
branches;
next	1.327;

1.327
date	2009.01.24.03.10.43;	author amodra;	state Exp;
branches;
next	1.326;

1.326
date	2009.01.23.12.15.27;	author amodra;	state Exp;
branches;
next	1.325;

1.325
date	2009.01.14.21.52.48;	author hjl;	state Exp;
branches;
next	1.324;

1.324
date	2009.01.11.21.09.46;	author jkratoch;	state Exp;
branches;
next	1.323;

1.323
date	2009.01.03.16.19.52;	author hjl;	state Exp;
branches;
next	1.322;

1.322
date	2009.01.02.19.29.37;	author hjl;	state Exp;
branches;
next	1.321;

1.321
date	2009.01.02.16.48.10;	author hjl;	state Exp;
branches;
next	1.320;

1.320
date	2008.12.23.09.01.45;	author nickc;	state Exp;
branches;
next	1.319;

1.319
date	2008.12.03.14.50.57;	author nickc;	state Exp;
branches;
next	1.318;

1.318
date	2008.11.26.01.04.15;	author amodra;	state Exp;
branches;
next	1.317;

1.317
date	2008.11.25.13.03.56;	author nickc;	state Exp;
branches;
next	1.316;

1.316
date	2008.11.21.00.02.37;	author hp;	state Exp;
branches;
next	1.315;

1.315
date	2008.10.20.10.57.33;	author amodra;	state Exp;
branches;
next	1.314;

1.314
date	2008.10.20.10.50.37;	author amodra;	state Exp;
branches;
next	1.313;

1.313
date	2008.10.03.09.40.48;	author amodra;	state Exp;
branches;
next	1.312;

1.312
date	2008.09.30.04.47.50;	author amodra;	state Exp;
branches;
next	1.311;

1.311
date	2008.09.28.13.30.35;	author amodra;	state Exp;
branches;
next	1.310;

1.310
date	2008.09.16.14.09.34;	author hjl;	state Exp;
branches;
next	1.309;

1.309
date	2008.08.22.08.32.39;	author jkratoch;	state Exp;
branches
	1.309.2.1;
next	1.308;

1.308
date	2008.08.08.08.00.14;	author amodra;	state Exp;
branches;
next	1.307;

1.307
date	2008.08.07.20.04.32;	author rsandifo;	state Exp;
branches;
next	1.306;

1.306
date	2008.07.22.04.58.33;	author cgd;	state Exp;
branches;
next	1.305;

1.305
date	2008.07.21.16.13.27;	author hjl;	state Exp;
branches;
next	1.304;

1.304
date	2008.04.29.11.53.45;	author drow;	state Exp;
branches;
next	1.303;

1.303
date	2008.04.08.05.41.19;	author amodra;	state Exp;
branches;
next	1.302;

1.302
date	2008.03.13.05.27.42;	author amodra;	state Exp;
branches;
next	1.301;

1.301
date	2008.03.12.08.36.58;	author amodra;	state Exp;
branches;
next	1.300;

1.300
date	2008.03.11.23.23.23;	author amodra;	state Exp;
branches;
next	1.299;

1.299
date	2008.03.02.22.26.09;	author hjl;	state Exp;
branches;
next	1.298;

1.298
date	2008.02.23.00.02.05;	author hjl;	state Exp;
branches;
next	1.297;

1.297
date	2008.02.20.17.42.35;	author nickc;	state Exp;
branches;
next	1.296;

1.296
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.295;

1.295
date	2008.02.14.08.31.47;	author amodra;	state Exp;
branches;
next	1.294;

1.294
date	2008.01.21.03.53.07;	author amodra;	state Exp;
branches;
next	1.293;

1.293
date	2008.01.15.07.25.48;	author amodra;	state Exp;
branches;
next	1.292;

1.292
date	2008.01.11.09.07.04;	author gingold;	state Exp;
branches;
next	1.291;

1.291
date	2008.01.07.16.45.35;	author hjl;	state Exp;
branches;
next	1.290;

1.290
date	2007.12.15.09.34.48;	author rsandifo;	state Exp;
branches;
next	1.289;

1.289
date	2007.12.15.09.33.51;	author rsandifo;	state Exp;
branches;
next	1.288;

1.288
date	2007.12.15.09.31.41;	author rsandifo;	state Exp;
branches;
next	1.287;

1.287
date	2007.11.20.15.08.25;	author nickc;	state Exp;
branches;
next	1.286;

1.286
date	2007.11.19.02.19.39;	author amodra;	state Exp;
branches;
next	1.285;

1.285
date	2007.10.31.07.36.46;	author amodra;	state Exp;
branches;
next	1.284;

1.284
date	2007.10.18.09.13.50;	author amodra;	state Exp;
branches;
next	1.283;

1.283
date	2007.10.16.15.51.38;	author bwilson;	state Exp;
branches;
next	1.282;

1.282
date	2007.10.12.16.25.21;	author nickc;	state Exp;
branches;
next	1.281;

1.281
date	2007.09.30.13.43.23;	author amodra;	state Exp;
branches;
next	1.280;

1.280
date	2007.09.30.13.33.02;	author amodra;	state Exp;
branches;
next	1.279;

1.279
date	2007.09.26.12.29.41;	author amodra;	state Exp;
branches;
next	1.278;

1.278
date	2007.09.18.08.17.06;	author amodra;	state Exp;
branches;
next	1.277;

1.277
date	2007.09.18.00.25.07;	author hjl;	state Exp;
branches;
next	1.276;

1.276
date	2007.08.20.13.23.41;	author nickc;	state Exp;
branches;
next	1.275;

1.275
date	2007.08.20.08.26.35;	author nickc;	state Exp;
branches;
next	1.274;

1.274
date	2007.07.27.01.04.29;	author msnyder;	state Exp;
branches
	1.274.2.1;
next	1.273;

1.273
date	2007.07.26.13.45.59;	author amodra;	state Exp;
branches;
next	1.272;

1.272
date	2007.07.24.19.54.01;	author msnyder;	state Exp;
branches;
next	1.271;

1.271
date	2007.07.24.08.09.20;	author amodra;	state Exp;
branches;
next	1.270;

1.270
date	2007.07.23.09.56.19;	author rsandifo;	state Exp;
branches;
next	1.269;

1.269
date	2007.07.10.02.40.31;	author hjl;	state Exp;
branches;
next	1.268;

1.268
date	2007.07.06.02.29.10;	author amodra;	state Exp;
branches;
next	1.267;

1.267
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.266;

1.266
date	2007.06.29.16.29.15;	author jsm28;	state Exp;
branches;
next	1.265;

1.265
date	2007.06.29.02.09.42;	author amodra;	state Exp;
branches;
next	1.264;

1.264
date	2007.05.16.12.52.03;	author hjl;	state Exp;
branches;
next	1.263;

1.263
date	2007.05.15.13.55.54;	author hjl;	state Exp;
branches;
next	1.262;

1.262
date	2007.05.11.03.10.11;	author amodra;	state Exp;
branches;
next	1.261;

1.261
date	2007.05.07.14.47.28;	author amodra;	state Exp;
branches;
next	1.260;

1.260
date	2007.05.04.21.53.02;	author hjl;	state Exp;
branches;
next	1.259;

1.259
date	2007.05.04.14.17.07;	author nickc;	state Exp;
branches;
next	1.258;

1.258
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.257;

1.257
date	2007.04.17.20.09.51;	author pbrook;	state Exp;
branches;
next	1.256;

1.256
date	2007.04.14.13.01.24;	author jakub;	state Exp;
branches;
next	1.255;

1.255
date	2007.04.05.16.16.27;	author hjl;	state Exp;
branches;
next	1.254;

1.254
date	2007.03.29.02.38.00;	author amodra;	state Exp;
branches;
next	1.253;

1.253
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.252;

1.252
date	2007.02.22.17.03.59;	author pbrook;	state Exp;
branches;
next	1.251;

1.251
date	2007.02.19.12.44.18;	author amodra;	state Exp;
branches;
next	1.250;

1.250
date	2007.02.14.14.15.52;	author hjl;	state Exp;
branches;
next	1.249;

1.249
date	2007.02.12.11.18.11;	author amodra;	state Exp;
branches;
next	1.248;

1.248
date	2007.02.12.11.14.01;	author amodra;	state Exp;
branches;
next	1.247;

1.247
date	2007.02.05.23.15.38;	author brolley;	state Exp;
branches;
next	1.246;

1.246
date	2007.02.05.19.50.12;	author brolley;	state Exp;
branches;
next	1.245;

1.245
date	2007.01.29.16.29.21;	author jules;	state Exp;
branches;
next	1.244;

1.244
date	2007.01.16.14.56.31;	author hjl;	state Exp;
branches;
next	1.243;

1.243
date	2006.12.29.17.56.32;	author hjl;	state Exp;
branches;
next	1.242;

1.242
date	2006.12.23.09.57.38;	author jakub;	state Exp;
branches;
next	1.241;

1.241
date	2006.12.11.14.52.13;	author ebotcazou;	state Exp;
branches;
next	1.240;

1.240
date	2006.12.07.13.32.00;	author hjl;	state Exp;
branches;
next	1.239;

1.239
date	2006.12.04.08.57.07;	author jbeulich;	state Exp;
branches;
next	1.238;

1.238
date	2006.11.17.13.55.41;	author amodra;	state Exp;
branches;
next	1.237;

1.237
date	2006.10.30.23.25.49;	author hjl;	state Exp;
branches;
next	1.236;

1.236
date	2006.10.27.03.22.08;	author amodra;	state Exp;
branches;
next	1.235;

1.235
date	2006.10.19.02.40.13;	author hjl;	state Exp;
branches;
next	1.234;

1.234
date	2006.10.17.13.41.46;	author amodra;	state Exp;
branches;
next	1.233;

1.233
date	2006.10.02.22.52.19;	author kazu;	state Exp;
branches;
next	1.232;

1.232
date	2006.09.28.13.27.31;	author amodra;	state Exp;
branches;
next	1.231;

1.231
date	2006.09.28.12.59.24;	author nickc;	state Exp;
branches;
next	1.230;

1.230
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.229;

1.229
date	2006.09.12.22.10.31;	author hjl;	state Exp;
branches;
next	1.228;

1.228
date	2006.09.07.17.16.31;	author hjl;	state Exp;
branches;
next	1.227;

1.227
date	2006.08.15.18.28.47;	author ths;	state Exp;
branches;
next	1.226;

1.226
date	2006.08.04.14.53.25;	author nickc;	state Exp;
branches;
next	1.225;

1.225
date	2006.07.19.01.50.23;	author amodra;	state Exp;
branches;
next	1.224;

1.224
date	2006.07.14.13.48.06;	author jakub;	state Exp;
branches;
next	1.223;

1.223
date	2006.07.14.11.00.59;	author kettenis;	state Exp;
branches;
next	1.222;

1.222
date	2006.07.12.15.45.32;	author hjl;	state Exp;
branches;
next	1.221;

1.221
date	2006.07.10.21.40.23;	author jakub;	state Exp;
branches;
next	1.220;

1.220
date	2006.06.20.16.36.18;	author jakub;	state Exp;
branches;
next	1.219;

1.219
date	2006.06.13.14.49.54;	author amodra;	state Exp;
branches;
next	1.218;

1.218
date	2006.06.12.11.12.51;	author nickc;	state Exp;
branches;
next	1.217;

1.217
date	2006.06.02.00.31.59;	author amodra;	state Exp;
branches;
next	1.216;

1.216
date	2006.05.24.17.10.01;	author pbrook;	state Exp;
branches;
next	1.215;

1.215
date	2006.05.22.15.06.22;	author drow;	state Exp;
branches;
next	1.214;

1.214
date	2006.05.17.00.36.30;	author amodra;	state Exp;
branches;
next	1.213;

1.213
date	2006.05.11.15.55.40;	author hjl;	state Exp;
branches;
next	1.212;

1.212
date	2006.05.10.04.55.43;	author amodra;	state Exp;
branches;
next	1.211;

1.211
date	2006.05.02.01.41.20;	author amodra;	state Exp;
branches;
next	1.210;

1.210
date	2006.04.05.13.37.32;	author hjl;	state Exp;
branches
	1.210.2.1;
next	1.209;

1.209
date	2006.04.05.13.36.32;	author hjl;	state Exp;
branches;
next	1.208;

1.208
date	2006.03.30.00.22.20;	author bje;	state Exp;
branches;
next	1.207;

1.207
date	2006.03.17.18.37.21;	author hjl;	state Exp;
branches
	1.207.2.1;
next	1.206;

1.206
date	2006.03.17.03.19.56;	author amodra;	state Exp;
branches;
next	1.205;

1.205
date	2006.03.16.12.20.14;	author amodra;	state Exp;
branches;
next	1.204;

1.204
date	2006.02.25.09.23.30;	author rsandifo;	state Exp;
branches;
next	1.203;

1.203
date	2006.02.24.15.47.24;	author hjl;	state Exp;
branches;
next	1.202;

1.202
date	2006.02.15.14.12.54;	author amodra;	state Exp;
branches;
next	1.201;

1.201
date	2006.01.17.15.32.40;	author amodra;	state Exp;
branches;
next	1.200;

1.200
date	2005.12.23.12.29.35;	author nickc;	state Exp;
branches;
next	1.199;

1.199
date	2005.12.10.03.31.03;	author amodra;	state Exp;
branches;
next	1.198;

1.198
date	2005.12.07.14.43.53;	author hjl;	state Exp;
branches;
next	1.197;

1.197
date	2005.11.03.02.53.38;	author amodra;	state Exp;
branches;
next	1.196;

1.196
date	2005.10.25.16.19.07;	author amodra;	state Exp;
branches;
next	1.195;

1.195
date	2005.10.24.11.24.31;	author amodra;	state Exp;
branches;
next	1.194;

1.194
date	2005.09.28.14.52.02;	author hjl;	state Exp;
branches;
next	1.193;

1.193
date	2005.09.19.23.30.05;	author amodra;	state Exp;
branches;
next	1.192;

1.192
date	2005.09.09.05.11.50;	author hjl;	state Exp;
branches;
next	1.191;

1.191
date	2005.09.08.14.24.22;	author hjl;	state Exp;
branches;
next	1.190;

1.190
date	2005.09.07.05.01.16;	author hjl;	state Exp;
branches;
next	1.189;

1.189
date	2005.08.17.03.07.12;	author amodra;	state Exp;
branches;
next	1.188;

1.188
date	2005.08.15.15.39.07;	author amodra;	state Exp;
branches;
next	1.187;

1.187
date	2005.08.04.06.22.06;	author amodra;	state Exp;
branches;
next	1.186;

1.186
date	2005.08.04.01.19.03;	author amodra;	state Exp;
branches;
next	1.185;

1.185
date	2005.07.31.06.14.15;	author daney;	state Exp;
branches;
next	1.184;

1.184
date	2005.07.29.02.46.03;	author amodra;	state Exp;
branches;
next	1.183;

1.183
date	2005.07.27.08.32.53;	author amodra;	state Exp;
branches;
next	1.182;

1.182
date	2005.07.26.15.19.37;	author amodra;	state Exp;
branches;
next	1.181;

1.181
date	2005.07.26.12.06.35;	author amodra;	state Exp;
branches;
next	1.180;

1.180
date	2005.07.26.11.47.05;	author amodra;	state Exp;
branches;
next	1.179;

1.179
date	2005.07.25.15.35.37;	author hjl;	state Exp;
branches;
next	1.178;

1.178
date	2005.07.23.15.42.51;	author hjl;	state Exp;
branches;
next	1.177;

1.177
date	2005.07.16.15.08.14;	author ebotcazou;	state Exp;
branches;
next	1.176;

1.176
date	2005.07.15.12.18.01;	author amodra;	state Exp;
branches;
next	1.175;

1.175
date	2005.07.14.13.54.16;	author amodra;	state Exp;
branches;
next	1.174;

1.174
date	2005.07.11.17.40.25;	author hjl;	state Exp;
branches;
next	1.173;

1.173
date	2005.07.07.17.44.58;	author hjl;	state Exp;
branches;
next	1.172;

1.172
date	2005.06.30.08.11.15;	author amodra;	state Exp;
branches;
next	1.171;

1.171
date	2005.06.29.14.05.19;	author amodra;	state Exp;
branches;
next	1.170;

1.170
date	2005.06.29.13.56.06;	author amodra;	state Exp;
branches;
next	1.169;

1.169
date	2005.06.29.13.16.44;	author pbrook;	state Exp;
branches;
next	1.168;

1.168
date	2005.06.14.19.25.45;	author hjl;	state Exp;
branches;
next	1.167;

1.167
date	2005.06.09.02.02.17;	author amodra;	state Exp;
branches;
next	1.166;

1.166
date	2005.06.03.09.52.49;	author amodra;	state Exp;
branches;
next	1.165;

1.165
date	2005.05.19.08.26.55;	author amodra;	state Exp;
branches;
next	1.164;

1.164
date	2005.05.14.13.49.42;	author kettenis;	state Exp;
branches;
next	1.163;

1.163
date	2005.05.08.13.43.48;	author hjl;	state Exp;
branches;
next	1.162;

1.162
date	2005.05.07.02.55.53;	author amodra;	state Exp;
branches;
next	1.161;

1.161
date	2005.05.05.16.40.07;	author hjl;	state Exp;
branches;
next	1.160;

1.160
date	2005.05.05.14.37.13;	author pbrook;	state Exp;
branches;
next	1.159;

1.159
date	2005.05.05.14.34.00;	author hjl;	state Exp;
branches;
next	1.158;

1.158
date	2005.05.05.14.30.04;	author hjl;	state Exp;
branches;
next	1.157;

1.157
date	2005.05.04.15.53.28;	author nickc;	state Exp;
branches;
next	1.156;

1.156
date	2005.05.04.13.18.58;	author hjl;	state Exp;
branches;
next	1.155;

1.155
date	2005.05.04.13.13.22;	author hjl;	state Exp;
branches;
next	1.154;

1.154
date	2005.05.04.11.00.19;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2005.05.04.07.19.25;	author nickc;	state Exp;
branches;
next	1.152;

1.152
date	2005.05.02.03.12.21;	author pbrook;	state Exp;
branches;
next	1.151;

1.151
date	2005.04.28.10.31.24;	author nickc;	state Exp;
branches;
next	1.150;

1.150
date	2005.04.27.20.16.08;	author hjl;	state Exp;
branches;
next	1.149;

1.149
date	2005.04.27.16.46.23;	author nickc;	state Exp;
branches;
next	1.148;

1.148
date	2005.04.27.10.09.43;	author nickc;	state Exp;
branches;
next	1.147;

1.147
date	2005.04.25.14.59.09;	author hjl;	state Exp;
branches;
next	1.146;

1.146
date	2005.04.15.03.42.46;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2005.04.13.16.44.08;	author hjl;	state Exp;
branches;
next	1.144;

1.144
date	2005.04.01.03.49.46;	author hjl;	state Exp;
branches;
next	1.143;

1.143
date	2005.03.31.23.45.30;	author hjl;	state Exp;
branches;
next	1.142;

1.142
date	2005.03.23.04.14.43;	author hjl;	state Exp;
branches;
next	1.141;

1.141
date	2005.03.22.14.49.13;	author amodra;	state Exp;
branches;
next	1.140;

1.140
date	2005.03.18.23.51.21;	author hjl;	state Exp;
branches;
next	1.139;

1.139
date	2005.03.18.15.46.25;	author hjl;	state Exp;
branches;
next	1.138;

1.138
date	2005.03.18.13.21.11;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2005.03.16.21.52.40;	author hjl;	state Exp;
branches;
next	1.136;

1.136
date	2005.02.28.15.57.13;	author hjl;	state Exp;
branches
	1.136.2.1;
next	1.135;

1.135
date	2005.02.24.15.28.56;	author jules;	state Exp;
branches;
next	1.134;

1.134
date	2005.02.11.16.41.09;	author pbrook;	state Exp;
branches;
next	1.133;

1.133
date	2005.02.10.14.09.40;	author pbrook;	state Exp;
branches;
next	1.132;

1.132
date	2005.02.10.09.15.07;	author jakub;	state Exp;
branches;
next	1.131;

1.131
date	2005.02.08.13.33.56;	author pbrook;	state Exp;
branches;
next	1.130;

1.130
date	2005.02.08.03.50.08;	author hp;	state Exp;
branches;
next	1.129;

1.129
date	2005.02.03.14.12.49;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2005.02.03.03.30.49;	author amodra;	state Exp;
branches;
next	1.127;

1.127
date	2005.02.02.02.36.35;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2005.02.01.01.11.14;	author amodra;	state Exp;
branches;
next	1.125;

1.125
date	2005.01.31.23.13.26;	author bje;	state Exp;
branches;
next	1.124;

1.124
date	2005.01.25.01.40.01;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2005.01.19.16.15.11;	author hjl;	state Exp;
branches;
next	1.122;

1.122
date	2004.12.22.03.59.26;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2004.12.10.14.04.58;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2004.12.10.13.18.40;	author amodra;	state Exp;
branches;
next	1.119;

1.119
date	2004.12.01.23.23.11;	author pbrook;	state Exp;
branches;
next	1.118;

1.118
date	2004.11.15.23.21.24;	author pbrook;	state Exp;
branches;
next	1.117;

1.117
date	2004.11.15.12.39.01;	author pbrook;	state Exp;
branches;
next	1.116;

1.116
date	2004.11.02.05.44.34;	author hp;	state Exp;
branches;
next	1.115;

1.115
date	2004.10.26.13.46.00;	author pbrook;	state Exp;
branches;
next	1.114;

1.114
date	2004.10.21.15.28.29;	author hjl;	state Exp;
branches;
next	1.113;

1.113
date	2004.10.19.06.02.46;	author mmitchel;	state Exp;
branches;
next	1.112;

1.112
date	2004.10.16.18.13.52;	author drow;	state Exp;
branches;
next	1.111;

1.111
date	2004.10.15.05.19.19;	author jakub;	state Exp;
branches;
next	1.110;

1.110
date	2004.10.12.02.27.53;	author amodra;	state Exp;
branches;
next	1.109;

1.109
date	2004.10.11.13.29.01;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2004.10.11.09.17.13;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2004.10.11.04.54.27;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2004.10.11.01.13.10;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2004.10.07.14.45.24;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	2004.09.30.16.43.41;	author hjl;	state Exp;
branches;
next	1.103;

1.103
date	2004.09.17.07.14.30;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2004.09.16.14.52.07;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2004.09.07.13.40.37;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2004.09.06.17.24.32;	author nickc;	state Exp;
branches;
next	1.99;

1.99
date	2004.09.03.17.15.34;	author mmitchel;	state Exp;
branches;
next	1.98;

1.98
date	2004.08.21.01.13.22;	author drow;	state Exp;
branches;
next	1.97;

1.97
date	2004.08.18.02.45.42;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2004.08.17.08.51.07;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2004.08.16.01.17.58;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2004.08.13.03.15.55;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2004.08.09.06.02.03;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2004.08.09.03.14.11;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2004.07.30.15.37.04;	author hjl;	state Exp;
branches;
next	1.90;

1.90
date	2004.07.27.14.20.47;	author hjl;	state Exp;
branches;
next	1.89;

1.89
date	2004.07.22.15.06.32;	author hjl;	state Exp;
branches;
next	1.88;

1.88
date	2004.07.22.14.19.02;	author hjl;	state Exp;
branches;
next	1.87;

1.87
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.86;

1.86
date	2004.07.21.13.32.26;	author pbrook;	state Exp;
branches;
next	1.85;

1.85
date	2004.07.21.06.46.20;	author aoliva;	state Exp;
branches;
next	1.84;

1.84
date	2004.07.19.16.40.48;	author hjl;	state Exp;
branches;
next	1.83;

1.83
date	2004.07.14.20.07.41;	author danglin;	state Exp;
branches;
next	1.82;

1.82
date	2004.07.14.08.53.59;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2004.07.13.12.55.42;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2004.07.06.16.58.42;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2004.07.02.01.39.31;	author hjl;	state Exp;
branches;
next	1.78;

1.78
date	2004.07.01.13.48.51;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2004.06.30.16.19.20;	author hjl;	state Exp;
branches;
next	1.76;

1.76
date	2004.06.30.13.42.45;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2004.06.28.13.57.59;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2004.06.24.04.46.22;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2004.06.21.14.45.41;	author aoliva;	state Exp;
branches;
next	1.72;

1.72
date	2004.06.09.13.49.04;	author aoliva;	state Exp;
branches;
next	1.71;

1.71
date	2004.05.25.06.33.46;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2004.05.22.01.56.30;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2004.05.11.17.08.37;	author jakub;	state Exp;
branches;
next	1.68;

1.68
date	2004.05.03.14.52.02;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2004.04.30.08.48.55;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.21.07.14.15;	author ebotcazou;	state Exp;
branches;
next	1.65;

1.65
date	2004.04.15.02.55.20;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2004.04.08.15.17.35;	author rsandifo;	state Exp;
branches;
next	1.63;

1.63
date	2004.03.27.10.58.08;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2004.03.26.06.13.40;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.26.05.55.15;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.25.12.48.41;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.19.01.36.45;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.18.23.02.06;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2004.03.18.04.32.17;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2004.03.16.10.31.18;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.16.10.29.11;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.03.21.31.10;	author aoliva;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2004.02.29.06.11.52;	author hjl;	state Exp;
branches;
next	1.52;

1.52
date	2004.02.21.23.05.13;	author hjl;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.01.06.28.23;	author amodra;	state Exp;
branches
	1.51.6.1
	1.51.8.1;
next	1.50;

1.50
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches;
next	1.49;

1.49
date	2003.11.04.06.16.34;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2003.10.30.14.13.50;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2003.10.22.06.58.16;	author jakub;	state Exp;
branches;
next	1.46;

1.46
date	2003.09.25.07.10.42;	author hjl;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.18.19.01.46;	author hjl;	state Exp;
branches;
next	1.44;

1.44
date	2003.08.07.08.38.10;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.06.01.27.11;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2003.08.04.09.39.46;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.22.15.52.44;	author hjl;	state Exp;
branches;
next	1.40;

1.40
date	2003.07.21.00.24.10;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.19.06.41.42;	author hjl;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.19.04.12.22;	author hjl;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.18.21.09.28;	author rth;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.04.01.50.11;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.30.15.50.11;	author jakub;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.20.14.35.00;	author hjl;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.17.06.16.03;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.15.14.54.47;	author hjl;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.09.02.26.52;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.24.04.50.04;	author amodra;	state Exp;
branches
	1.30.16.1;
next	1.29;

1.29
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.25.06.54.51;	author amodra;	state Exp;
branches
	1.27.10.1
	1.27.12.1;
next	1.26;

1.26
date	2002.07.04.14.40.25;	author amodra;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2002.06.25.09.40.43;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.28.03.27.45;	author amodra;	state Exp;
branches
	1.24.6.1;
next	1.23;

1.23
date	2002.01.16.05.50.02;	author amodra;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.11.07.16.50.36;	author jakub;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.20.23.30.36;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.08.13.09.33;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.07.09.15.26;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.23.11.45.53;	author kazu;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.01.03.22.53.38;	author kazu;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.16.18.02.16;	author aoliva;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.05.20.46.21;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.30.20.51.36;	author hjl;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.04.06.38.33;	author hjl;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.01.19.40.54;	author hjl;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.01.26.23.11.47;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.03.18.32.21;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.07.13.18.31.16;	author rth;	state Exp;
branches;
next	1.6;

1.6
date	99.07.13.18.21.28;	author rth;	state Exp;
branches;
next	1.5;

1.5
date	99.07.11.19.49.34;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.13.14.49.50;	author mmitchel;	state Exp;
branches;
next	1.3;

1.3
date	99.06.02.16.31.16;	author mmitchel;	state Exp;
branches;
next	1.2;

1.2
date	99.06.02.13.01.01;	author mmitchel;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.450.4.1
date	2012.09.04.14.37.52;	author gingold;	state Exp;
branches;
next	1.450.4.2;

1.450.4.2
date	2012.09.24.12.22.45;	author gingold;	state Exp;
branches;
next	1.450.4.3;

1.450.4.3
date	2013.01.21.13.48.37;	author amodra;	state Exp;
branches;
next	1.450.4.4;

1.450.4.4
date	2013.02.18.11.31.15;	author amodra;	state Exp;
branches;
next	1.450.4.5;

1.450.4.5
date	2013.07.20.09.57.17;	author amodra;	state Exp;
branches;
next	1.450.4.6;

1.450.4.6
date	2013.07.25.00.54.07;	author amodra;	state Exp;
branches;
next	;

1.420.2.1
date	2011.09.29.05.40.44;	author amodra;	state Exp;
branches;
next	1.420.2.2;

1.420.2.2
date	2011.10.05.16.39.55;	author hjl;	state Exp;
branches;
next	1.420.2.3;

1.420.2.3
date	2011.10.18.19.06.50;	author hjl;	state Exp;
branches;
next	1.420.2.4;

1.420.2.4
date	2011.10.25.02.52.23;	author amodra;	state Exp;
branches;
next	1.420.2.5;

1.420.2.5
date	2011.10.25.02.54.25;	author amodra;	state Exp;
branches;
next	1.420.2.6;

1.420.2.6
date	2011.10.25.02.57.23;	author amodra;	state Exp;
branches;
next	1.420.2.7;

1.420.2.7
date	2011.10.25.03.12.17;	author amodra;	state Exp;
branches;
next	1.420.2.8;

1.420.2.8
date	2011.10.25.03.13.32;	author amodra;	state Exp;
branches;
next	1.420.2.9;

1.420.2.9
date	2011.11.08.13.50.26;	author amodra;	state Exp;
branches;
next	1.420.2.10;

1.420.2.10
date	2011.11.15.11.36.52;	author amodra;	state Exp;
branches;
next	1.420.2.11;

1.420.2.11
date	2011.12.03.10.29.18;	author amodra;	state Exp;
branches;
next	1.420.2.12;

1.420.2.12
date	2012.05.11.12.24.30;	author nickc;	state Exp;
branches;
next	;

1.388.2.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	1.388.2.2;

1.388.2.2
date	2011.04.27.07.17.38;	author amodra;	state Exp;
branches;
next	1.388.2.3;

1.388.2.3
date	2011.05.29.04.51.13;	author amodra;	state Exp;
branches;
next	1.388.2.4;

1.388.2.4
date	2011.06.21.14.55.46;	author amodra;	state Exp;
branches;
next	;

1.352.2.1
date	2009.09.09.21.40.19;	author nickc;	state Exp;
branches;
next	1.352.2.2;

1.352.2.2
date	2010.08.27.12.08.56;	author nickc;	state Exp;
branches;
next	;

1.309.2.1
date	2009.03.02.13.31.14;	author amodra;	state Exp;
branches;
next	1.309.2.2;

1.309.2.2
date	2009.03.02.13.32.54;	author amodra;	state Exp;
branches;
next	1.309.2.3;

1.309.2.3
date	2009.03.02.13.48.42;	author amodra;	state Exp;
branches;
next	;

1.274.2.1
date	2007.08.20.08.27.51;	author nickc;	state Exp;
branches;
next	;

1.210.2.1
date	2006.05.10.05.01.13;	author amodra;	state Exp;
branches;
next	1.210.2.2;

1.210.2.2
date	2006.05.11.16.01.20;	author hjl;	state Exp;
branches;
next	1.210.2.3;

1.210.2.3
date	2006.05.17.05.14.21;	author amodra;	state Exp;
branches;
next	1.210.2.4;

1.210.2.4
date	2006.05.22.15.07.06;	author drow;	state Exp;
branches;
next	1.210.2.5;

1.210.2.5
date	2006.07.19.02.37.04;	author amodra;	state Exp;
branches;
next	1.210.2.6;

1.210.2.6
date	2006.12.11.14.52.39;	author ebotcazou;	state Exp;
branches;
next	;

1.207.2.1
date	2006.05.24.17.14.52;	author pbrook;	state Exp;
branches;
next	1.207.2.2;

1.207.2.2
date	2006.08.22.15.08.29;	author jsm28;	state Exp;
branches;
next	1.207.2.3;

1.207.2.3
date	2006.11.29.16.31.07;	author shinwell;	state Exp;
branches;
next	;

1.136.2.1
date	2005.03.22.14.49.54;	author amodra;	state Exp;
branches
	1.136.2.1.2.1;
next	1.136.2.2;

1.136.2.2
date	2005.04.15.03.52.53;	author amodra;	state Exp;
branches;
next	1.136.2.3;

1.136.2.3
date	2005.04.27.16.47.24;	author nickc;	state Exp;
branches;
next	1.136.2.4;

1.136.2.4
date	2005.07.16.15.20.31;	author ebotcazou;	state Exp;
branches;
next	;

1.136.2.1.2.1
date	2005.05.02.03.12.46;	author pbrook;	state Exp;
branches;
next	;

1.54.2.1
date	2004.03.21.23.57.28;	author cagney;	state Exp;
branches;
next	;

1.51.6.1
date	2004.03.16.10.35.20;	author amodra;	state Exp;
branches;
next	1.51.6.2;

1.51.6.2
date	2004.04.08.12.41.46;	author amodra;	state Exp;
branches;
next	1.51.6.3;

1.51.6.3
date	2004.04.08.15.19.23;	author rsandifo;	state Exp;
branches;
next	1.51.6.4;

1.51.6.4
date	2004.04.16.03.44.35;	author amodra;	state Exp;
branches;
next	1.51.6.5;

1.51.6.5
date	2004.09.07.07.11.06;	author ebotcazou;	state Exp;
branches;
next	1.51.6.6;

1.51.6.6
date	2004.10.16.18.59.34;	author hjl;	state Exp;
branches;
next	;

1.51.8.1
date	2004.03.27.17.37.36;	author drow;	state Exp;
branches;
next	1.51.8.2;

1.51.8.2
date	2004.04.02.16.47.36;	author drow;	state Exp;
branches;
next	1.51.8.3;

1.51.8.3
date	2004.09.16.17.00.32;	author drow;	state Exp;
branches;
next	1.51.8.4;

1.51.8.4
date	2004.09.21.20.44.03;	author drow;	state Exp;
branches;
next	;

1.30.16.1
date	2003.05.18.09.43.48;	author kettenis;	state Exp;
branches;
next	;

1.27.10.1
date	2002.10.11.22.22.49;	author carlton;	state Exp;
branches;
next	1.27.10.2;

1.27.10.2
date	2002.12.23.19.37.50;	author carlton;	state Exp;
branches;
next	1.27.10.3;

1.27.10.3
date	2003.03.06.00.56.17;	author carlton;	state Exp;
branches;
next	1.27.10.4;

1.27.10.4
date	2003.05.23.18.40.28;	author carlton;	state Exp;
branches;
next	1.27.10.5;

1.27.10.5
date	2003.06.27.21.49.24;	author carlton;	state Exp;
branches;
next	1.27.10.6;

1.27.10.6
date	2003.08.05.17.12.53;	author carlton;	state Exp;
branches;
next	1.27.10.7;

1.27.10.7
date	2003.09.17.21.27.56;	author carlton;	state Exp;
branches;
next	1.27.10.8;

1.27.10.8
date	2003.11.11.23.50.24;	author carlton;	state Exp;
branches;
next	1.27.10.9;

1.27.10.9
date	2003.12.15.23.59.41;	author carlton;	state Exp;
branches;
next	;

1.27.12.1
date	2002.10.26.17.11.59;	author drow;	state Exp;
branches;
next	1.27.12.2;

1.27.12.2
date	2003.12.14.20.26.44;	author drow;	state Exp;
branches;
next	;

1.26.2.1
date	2002.07.30.18.19.42;	author drow;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2002.10.11.08.56.13;	author amodra;	state Exp;
branches;
next	;

1.24.6.1
date	2002.07.22.21.46.46;	author kseitz;	state Exp;
branches;
next	1.24.6.2;

1.24.6.2
date	2002.08.09.18.34.16;	author kseitz;	state Exp;
branches;
next	1.24.6.3;

1.24.6.3
date	2002.11.03.22.01.36;	author ezannoni;	state Exp;
branches;
next	;

1.23.2.1
date	2002.04.04.14.53.00;	author amodra;	state Exp;
branches;
next	;

1.16.2.1
date	2001.06.07.03.08.25;	author amodra;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.06.11.10.04.15;	author amodra;	state Exp;
branches;
next	;

1.10.2.1
date	2000.10.16.17.57.07;	author pb;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2000.10.22.15.19.57;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches;
next	;


desc
@@


1.499
log
@	* elf-bfd.h (struct elf_backend_data): Remove as_needed_cleanup.
	Add notice_as_needed.
	* elf64-ppc.c (elf_backend_as_needed_cleanup): Don't define.
	(elf_backend_notice_as_needed): Define.
	(ppc64_elf_as_needed_cleanup): Rename and adjust..
	(ppc64_elf_notice_as_needed): ..to this.
	* elflink.c (_bfd_elf_notice_as_needed): New function, extracted..
	(elf_link_add_object_symbols): ..from here.
	* elfxx-target.h (elf_backend_as_needed_cleanup): Don't define.
	(elf_backend_notice_as_needed): Define..
	(elfNN_bed): ..and use here.
@
text
@/* ELF linking support for BFD.
   Copyright 1995-2013 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#define ARCH_SIZE 0
#include "elf-bfd.h"
#include "safe-ctype.h"
#include "libiberty.h"
#include "objalloc.h"

/* This struct is used to pass information to routines called via
   elf_link_hash_traverse which must return failure.  */

struct elf_info_failed
{
  struct bfd_link_info *info;
  bfd_boolean failed;
};

/* This structure is used to pass information to
   _bfd_elf_link_find_version_dependencies.  */

struct elf_find_verdep_info
{
  /* General link information.  */
  struct bfd_link_info *info;
  /* The number of dependencies.  */
  unsigned int vers;
  /* Whether we had a failure.  */
  bfd_boolean failed;
};

static bfd_boolean _bfd_elf_fix_symbol_flags
  (struct elf_link_hash_entry *, struct elf_info_failed *);

/* Define a symbol in a dynamic linkage section.  */

struct elf_link_hash_entry *
_bfd_elf_define_linkage_sym (bfd *abfd,
			     struct bfd_link_info *info,
			     asection *sec,
			     const char *name)
{
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  const struct elf_backend_data *bed;

  h = elf_link_hash_lookup (elf_hash_table (info), name, FALSE, FALSE, FALSE);
  if (h != NULL)
    {
      /* Zap symbol defined in an as-needed lib that wasn't linked.
	 This is a symptom of a larger problem:  Absolute symbols
	 defined in shared libraries can't be overridden, because we
	 lose the link to the bfd which is via the symbol section.  */
      h->root.type = bfd_link_hash_new;
    }

  bh = &h->root;
  if (!_bfd_generic_link_add_one_symbol (info, abfd, name, BSF_GLOBAL,
					 sec, 0, NULL, FALSE,
					 get_elf_backend_data (abfd)->collect,
					 &bh))
    return NULL;
  h = (struct elf_link_hash_entry *) bh;
  h->def_regular = 1;
  h->non_elf = 0;
  h->type = STT_OBJECT;
  if (ELF_ST_VISIBILITY (h->other) != STV_INTERNAL)
    h->other = (h->other & ~ELF_ST_VISIBILITY (-1)) | STV_HIDDEN;

  bed = get_elf_backend_data (abfd);
  (*bed->elf_backend_hide_symbol) (info, h, TRUE);
  return h;
}

bfd_boolean
_bfd_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags;
  asection *s;
  struct elf_link_hash_entry *h;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct elf_link_hash_table *htab = elf_hash_table (info);

  /* This function may be called more than once.  */
  s = bfd_get_linker_section (abfd, ".got");
  if (s != NULL)
    return TRUE;

  flags = bed->dynamic_sec_flags;

  s = bfd_make_section_anyway_with_flags (abfd,
					  (bed->rela_plts_and_copies_p
					   ? ".rela.got" : ".rel.got"),
					  (bed->dynamic_sec_flags
					   | SEC_READONLY));
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  htab->srelgot = s;

  s = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  htab->sgot = s;

  if (bed->want_got_plt)
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".got.plt", flags);
      if (s == NULL
	  || !bfd_set_section_alignment (abfd, s,
					 bed->s->log_file_align))
	return FALSE;
      htab->sgotplt = s;
    }

  /* The first bit of the global offset table is the header.  */
  s->size += bed->got_header_size;

  if (bed->want_got_sym)
    {
      /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
	 (or .got.plt) section.  We don't do this in the linker script
	 because we don't want to define the symbol if we are not creating
	 a global offset table.  */
      h = _bfd_elf_define_linkage_sym (abfd, info, s,
				       "_GLOBAL_OFFSET_TABLE_");
      elf_hash_table (info)->hgot = h;
      if (h == NULL)
	return FALSE;
    }

  return TRUE;
}

/* Create a strtab to hold the dynamic symbol names.  */
static bfd_boolean
_bfd_elf_link_create_dynstrtab (bfd *abfd, struct bfd_link_info *info)
{
  struct elf_link_hash_table *hash_table;

  hash_table = elf_hash_table (info);
  if (hash_table->dynobj == NULL)
    hash_table->dynobj = abfd;

  if (hash_table->dynstr == NULL)
    {
      hash_table->dynstr = _bfd_elf_strtab_init ();
      if (hash_table->dynstr == NULL)
	return FALSE;
    }
  return TRUE;
}

/* Create some sections which will be filled in with dynamic linking
   information.  ABFD is an input file which requires dynamic sections
   to be created.  The dynamic sections take up virtual memory space
   when the final executable is run, so we need to create them before
   addresses are assigned to the output sections.  We work out the
   actual contents and size of these sections later.  */

bfd_boolean
_bfd_elf_link_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags;
  asection *s;
  const struct elf_backend_data *bed;
  struct elf_link_hash_entry *h;

  if (! is_elf_hash_table (info->hash))
    return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    return TRUE;

  if (!_bfd_elf_link_create_dynstrtab (abfd, info))
    return FALSE;

  abfd = elf_hash_table (info)->dynobj;
  bed = get_elf_backend_data (abfd);

  flags = bed->dynamic_sec_flags;

  /* A dynamically linked executable has a .interp section, but a
     shared library does not.  */
  if (info->executable)
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".interp",
					      flags | SEC_READONLY);
      if (s == NULL)
	return FALSE;
    }

  /* Create sections to hold version informations.  These are removed
     if they are not needed.  */
  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version_d",
					  flags | SEC_READONLY);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version",
					  flags | SEC_READONLY);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, 1))
    return FALSE;

  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version_r",
					  flags | SEC_READONLY);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section_anyway_with_flags (abfd, ".dynsym",
					  flags | SEC_READONLY);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section_anyway_with_flags (abfd, ".dynstr",
					  flags | SEC_READONLY);
  if (s == NULL)
    return FALSE;

  s = bfd_make_section_anyway_with_flags (abfd, ".dynamic", flags);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  /* The special symbol _DYNAMIC is always set to the start of the
     .dynamic section.  We could set _DYNAMIC in a linker script, but we
     only want to define it if we are, in fact, creating a .dynamic
     section.  We don't want to define it if there is no .dynamic
     section, since on some ELF platforms the start up code examines it
     to decide how to initialize the process.  */
  h = _bfd_elf_define_linkage_sym (abfd, info, s, "_DYNAMIC");
  elf_hash_table (info)->hdynamic = h;
  if (h == NULL)
    return FALSE;

  if (info->emit_hash)
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".hash",
					      flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
	return FALSE;
      elf_section_data (s)->this_hdr.sh_entsize = bed->s->sizeof_hash_entry;
    }

  if (info->emit_gnu_hash)
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".gnu.hash",
					      flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
	return FALSE;
      /* For 64-bit ELF, .gnu.hash is a non-uniform entity size section:
	 4 32-bit words followed by variable count of 64-bit words, then
	 variable count of 32-bit words.  */
      if (bed->s->arch_size == 64)
	elf_section_data (s)->this_hdr.sh_entsize = 0;
      else
	elf_section_data (s)->this_hdr.sh_entsize = 4;
    }

  /* Let the backend create the rest of the sections.  This lets the
     backend set the right flags.  The backend will normally create
     the .got and .plt sections.  */
  if (bed->elf_backend_create_dynamic_sections == NULL
      || ! (*bed->elf_backend_create_dynamic_sections) (abfd, info))
    return FALSE;

  elf_hash_table (info)->dynamic_sections_created = TRUE;

  return TRUE;
}

/* Create dynamic sections when linking against a dynamic object.  */

bfd_boolean
_bfd_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags, pltflags;
  struct elf_link_hash_entry *h;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct elf_link_hash_table *htab = elf_hash_table (info);

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */
  flags = bed->dynamic_sec_flags;

  pltflags = flags;
  if (bed->plt_not_loaded)
    /* We do not clear SEC_ALLOC here because we still want the OS to
       allocate space for the section; it's just that there's nothing
       to read in from the object file.  */
    pltflags &= ~ (SEC_CODE | SEC_LOAD | SEC_HAS_CONTENTS);
  else
    pltflags |= SEC_ALLOC | SEC_CODE | SEC_LOAD;
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  s = bfd_make_section_anyway_with_flags (abfd, ".plt", pltflags);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;
  htab->splt = s;

  /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
     .plt section.  */
  if (bed->want_plt_sym)
    {
      h = _bfd_elf_define_linkage_sym (abfd, info, s,
				       "_PROCEDURE_LINKAGE_TABLE_");
      elf_hash_table (info)->hplt = h;
      if (h == NULL)
	return FALSE;
    }

  s = bfd_make_section_anyway_with_flags (abfd,
					  (bed->rela_plts_and_copies_p
					   ? ".rela.plt" : ".rel.plt"),
					  flags | SEC_READONLY);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  htab->srelplt = s;

  if (! _bfd_elf_create_got_section (abfd, info))
    return FALSE;

  if (bed->want_dynbss)
    {
      /* The .dynbss section is a place to put symbols which are defined
	 by dynamic objects, are referenced by regular objects, and are
	 not functions.  We must allocate space for them in the process
	 image and use a R_*_COPY reloc to tell the dynamic linker to
	 initialize them at run time.  The linker script puts the .dynbss
	 section into the .bss section of the final image.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".dynbss",
					      (SEC_ALLOC | SEC_LINKER_CREATED));
      if (s == NULL)
	return FALSE;

      /* The .rel[a].bss section holds copy relocs.  This section is not
	 normally needed.  We need to create it here, though, so that the
	 linker will map it to an output section.  We can't just create it
	 only if we need it, because we will not know whether we need it
	 until we have seen all the input files, and the first time the
	 main linker code calls BFD after examining all the input files
	 (size_dynamic_sections) the input sections have already been
	 mapped to the output sections.  If the section turns out not to
	 be needed, we can discard it later.  We will never need this
	 section when generating a shared object, since they do not use
	 copy relocs.  */
      if (! info->shared)
	{
	  s = bfd_make_section_anyway_with_flags (abfd,
						  (bed->rela_plts_and_copies_p
						   ? ".rela.bss" : ".rel.bss"),
						  flags | SEC_READONLY);
	  if (s == NULL
	      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
	    return FALSE;
	}
    }

  return TRUE;
}

/* Record a new dynamic symbol.  We record the dynamic symbols as we
   read the input files, since we need to have a list of all of them
   before we can determine the final sizes of the output sections.
   Note that we may actually call this function even though we are not
   going to output any dynamic symbols; in some cases we know that a
   symbol should be in the dynamic symbol table, but only if there is
   one.  */

bfd_boolean
bfd_elf_link_record_dynamic_symbol (struct bfd_link_info *info,
				    struct elf_link_hash_entry *h)
{
  if (h->dynindx == -1)
    {
      struct elf_strtab_hash *dynstr;
      char *p;
      const char *name;
      bfd_size_type indx;

      /* XXX: The ABI draft says the linker must turn hidden and
	 internal symbols into STB_LOCAL symbols when producing the
	 DSO. However, if ld.so honors st_other in the dynamic table,
	 this would not be necessary.  */
      switch (ELF_ST_VISIBILITY (h->other))
	{
	case STV_INTERNAL:
	case STV_HIDDEN:
	  if (h->root.type != bfd_link_hash_undefined
	      && h->root.type != bfd_link_hash_undefweak)
	    {
	      h->forced_local = 1;
	      if (!elf_hash_table (info)->is_relocatable_executable)
		return TRUE;
	    }

	default:
	  break;
	}

      h->dynindx = elf_hash_table (info)->dynsymcount;
      ++elf_hash_table (info)->dynsymcount;

      dynstr = elf_hash_table (info)->dynstr;
      if (dynstr == NULL)
	{
	  /* Create a strtab to hold the dynamic symbol names.  */
	  elf_hash_table (info)->dynstr = dynstr = _bfd_elf_strtab_init ();
	  if (dynstr == NULL)
	    return FALSE;
	}

      /* We don't put any version information in the dynamic string
	 table.  */
      name = h->root.root.string;
      p = strchr (name, ELF_VER_CHR);
      if (p != NULL)
	/* We know that the p points into writable memory.  In fact,
	   there are only a few symbols that have read-only names, being
	   those like _GLOBAL_OFFSET_TABLE_ that are created specially
	   by the backends.  Most symbols will have names pointing into
	   an ELF string table read from a file, or to objalloc memory.  */
	*p = 0;

      indx = _bfd_elf_strtab_add (dynstr, name, p != NULL);

      if (p != NULL)
	*p = ELF_VER_CHR;

      if (indx == (bfd_size_type) -1)
	return FALSE;
      h->dynstr_index = indx;
    }

  return TRUE;
}

/* Mark a symbol dynamic.  */

static void
bfd_elf_link_mark_dynamic_symbol (struct bfd_link_info *info,
				  struct elf_link_hash_entry *h,
				  Elf_Internal_Sym *sym)
{
  struct bfd_elf_dynamic_list *d = info->dynamic_list;

  /* It may be called more than once on the same H.  */
  if(h->dynamic || info->relocatable)
    return;

  if ((info->dynamic_data
       && (h->type == STT_OBJECT
	   || (sym != NULL
	       && ELF_ST_TYPE (sym->st_info) == STT_OBJECT)))
      || (d != NULL
	  && h->root.type == bfd_link_hash_new
	  && (*d->match) (&d->head, NULL, h->root.root.string)))
    h->dynamic = 1;
}

/* Record an assignment to a symbol made by a linker script.  We need
   this in case some dynamic object refers to this symbol.  */

bfd_boolean
bfd_elf_record_link_assignment (bfd *output_bfd,
				struct bfd_link_info *info,
				const char *name,
				bfd_boolean provide,
				bfd_boolean hidden)
{
  struct elf_link_hash_entry *h, *hv;
  struct elf_link_hash_table *htab;
  const struct elf_backend_data *bed;

  if (!is_elf_hash_table (info->hash))
    return TRUE;

  htab = elf_hash_table (info);
  h = elf_link_hash_lookup (htab, name, !provide, TRUE, FALSE);
  if (h == NULL)
    return provide;

  switch (h->root.type)
    {
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
    case bfd_link_hash_common:
      break;
    case bfd_link_hash_undefweak:
    case bfd_link_hash_undefined:
      /* Since we're defining the symbol, don't let it seem to have not
	 been defined.  record_dynamic_symbol and size_dynamic_sections
	 may depend on this.  */
      h->root.type = bfd_link_hash_new;
      if (h->root.u.undef.next != NULL || htab->root.undefs_tail == &h->root)
	bfd_link_repair_undef_list (&htab->root);
      break;
    case bfd_link_hash_new:
      bfd_elf_link_mark_dynamic_symbol (info, h, NULL);
      h->non_elf = 0;
      break;
    case bfd_link_hash_indirect:
      /* We had a versioned symbol in a dynamic library.  We make the
	 the versioned symbol point to this one.  */
      bed = get_elf_backend_data (output_bfd);
      hv = h;
      while (hv->root.type == bfd_link_hash_indirect
	     || hv->root.type == bfd_link_hash_warning)
	hv = (struct elf_link_hash_entry *) hv->root.u.i.link;
      /* We don't need to update h->root.u since linker will set them
	 later.  */
      h->root.type = bfd_link_hash_undefined;
      hv->root.type = bfd_link_hash_indirect;
      hv->root.u.i.link = (struct bfd_link_hash_entry *) h;
      (*bed->elf_backend_copy_indirect_symbol) (info, h, hv);
      break;
    case bfd_link_hash_warning:
      abort ();
      break;
    }

  /* If this symbol is being provided by the linker script, and it is
     currently defined by a dynamic object, but not by a regular
     object, then mark it as undefined so that the generic linker will
     force the correct value.  */
  if (provide
      && h->def_dynamic
      && !h->def_regular)
    h->root.type = bfd_link_hash_undefined;

  /* If this symbol is not being provided by the linker script, and it is
     currently defined by a dynamic object, but not by a regular object,
     then clear out any version information because the symbol will not be
     associated with the dynamic object any more.  */
  if (!provide
      && h->def_dynamic
      && !h->def_regular)
    h->verinfo.verdef = NULL;

  h->def_regular = 1;

  if (hidden)
    {
      bed = get_elf_backend_data (output_bfd);
      if (ELF_ST_VISIBILITY (h->other) != STV_INTERNAL)
	h->other = (h->other & ~ELF_ST_VISIBILITY (-1)) | STV_HIDDEN;
      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
    }

  /* STV_HIDDEN and STV_INTERNAL symbols must be STB_LOCAL in shared objects
     and executables.  */
  if (!info->relocatable
      && h->dynindx != -1
      && (ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	  || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL))
    h->forced_local = 1;

  if ((h->def_dynamic
       || h->ref_dynamic
       || info->shared
       || (info->executable && elf_hash_table (info)->is_relocatable_executable))
      && h->dynindx == -1)
    {
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;

      /* If this is a weak defined symbol, and we know a corresponding
	 real symbol from the same dynamic object, make sure the real
	 symbol is also made into a dynamic symbol.  */
      if (h->u.weakdef != NULL
	  && h->u.weakdef->dynindx == -1)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h->u.weakdef))
	    return FALSE;
	}
    }

  return TRUE;
}

/* Record a new local dynamic symbol.  Returns 0 on failure, 1 on
   success, and 2 on a failure caused by attempting to record a symbol
   in a discarded section, eg. a discarded link-once section symbol.  */

int
bfd_elf_link_record_local_dynamic_symbol (struct bfd_link_info *info,
					  bfd *input_bfd,
					  long input_indx)
{
  bfd_size_type amt;
  struct elf_link_local_dynamic_entry *entry;
  struct elf_link_hash_table *eht;
  struct elf_strtab_hash *dynstr;
  unsigned long dynstr_index;
  char *name;
  Elf_External_Sym_Shndx eshndx;
  char esym[sizeof (Elf64_External_Sym)];

  if (! is_elf_hash_table (info->hash))
    return 0;

  /* See if the entry exists already.  */
  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)
    if (entry->input_bfd == input_bfd && entry->input_indx == input_indx)
      return 1;

  amt = sizeof (*entry);
  entry = (struct elf_link_local_dynamic_entry *) bfd_alloc (input_bfd, amt);
  if (entry == NULL)
    return 0;

  /* Go find the symbol, so that we can find it's name.  */
  if (!bfd_elf_get_elf_syms (input_bfd, &elf_tdata (input_bfd)->symtab_hdr,
			     1, input_indx, &entry->isym, esym, &eshndx))
    {
      bfd_release (input_bfd, entry);
      return 0;
    }

  if (entry->isym.st_shndx != SHN_UNDEF
      && entry->isym.st_shndx < SHN_LORESERVE)
    {
      asection *s;

      s = bfd_section_from_elf_index (input_bfd, entry->isym.st_shndx);
      if (s == NULL || bfd_is_abs_section (s->output_section))
	{
	  /* We can still bfd_release here as nothing has done another
	     bfd_alloc.  We can't do this later in this function.  */
	  bfd_release (input_bfd, entry);
	  return 2;
	}
    }

  name = (bfd_elf_string_from_elf_section
	  (input_bfd, elf_tdata (input_bfd)->symtab_hdr.sh_link,
	   entry->isym.st_name));

  dynstr = elf_hash_table (info)->dynstr;
  if (dynstr == NULL)
    {
      /* Create a strtab to hold the dynamic symbol names.  */
      elf_hash_table (info)->dynstr = dynstr = _bfd_elf_strtab_init ();
      if (dynstr == NULL)
	return 0;
    }

  dynstr_index = _bfd_elf_strtab_add (dynstr, name, FALSE);
  if (dynstr_index == (unsigned long) -1)
    return 0;
  entry->isym.st_name = dynstr_index;

  eht = elf_hash_table (info);

  entry->next = eht->dynlocal;
  eht->dynlocal = entry;
  entry->input_bfd = input_bfd;
  entry->input_indx = input_indx;
  eht->dynsymcount++;

  /* Whatever binding the symbol had before, it's now local.  */
  entry->isym.st_info
    = ELF_ST_INFO (STB_LOCAL, ELF_ST_TYPE (entry->isym.st_info));

  /* The dynindx will be set at the end of size_dynamic_sections.  */

  return 1;
}

/* Return the dynindex of a local dynamic symbol.  */

long
_bfd_elf_link_lookup_local_dynindx (struct bfd_link_info *info,
				    bfd *input_bfd,
				    long input_indx)
{
  struct elf_link_local_dynamic_entry *e;

  for (e = elf_hash_table (info)->dynlocal; e ; e = e->next)
    if (e->input_bfd == input_bfd && e->input_indx == input_indx)
      return e->dynindx;
  return -1;
}

/* This function is used to renumber the dynamic symbols, if some of
   them are removed because they are marked as local.  This is called
   via elf_link_hash_traverse.  */

static bfd_boolean
elf_link_renumber_hash_table_dynsyms (struct elf_link_hash_entry *h,
				      void *data)
{
  size_t *count = (size_t *) data;

  if (h->forced_local)
    return TRUE;

  if (h->dynindx != -1)
    h->dynindx = ++(*count);

  return TRUE;
}


/* Like elf_link_renumber_hash_table_dynsyms, but just number symbols with
   STB_LOCAL binding.  */

static bfd_boolean
elf_link_renumber_local_hash_table_dynsyms (struct elf_link_hash_entry *h,
					    void *data)
{
  size_t *count = (size_t *) data;

  if (!h->forced_local)
    return TRUE;

  if (h->dynindx != -1)
    h->dynindx = ++(*count);

  return TRUE;
}

/* Return true if the dynamic symbol for a given section should be
   omitted when creating a shared library.  */
bfd_boolean
_bfd_elf_link_omit_section_dynsym (bfd *output_bfd ATTRIBUTE_UNUSED,
				   struct bfd_link_info *info,
				   asection *p)
{
  struct elf_link_hash_table *htab;

  switch (elf_section_data (p)->this_hdr.sh_type)
    {
    case SHT_PROGBITS:
    case SHT_NOBITS:
      /* If sh_type is yet undecided, assume it could be
	 SHT_PROGBITS/SHT_NOBITS.  */
    case SHT_NULL:
      htab = elf_hash_table (info);
      if (p == htab->tls_sec)
	return FALSE;

      if (htab->text_index_section != NULL)
	return p != htab->text_index_section && p != htab->data_index_section;

      if (strcmp (p->name, ".got") == 0
	  || strcmp (p->name, ".got.plt") == 0
	  || strcmp (p->name, ".plt") == 0)
	{
	  asection *ip;

	  if (htab->dynobj != NULL
	      && (ip = bfd_get_linker_section (htab->dynobj, p->name)) != NULL
	      && ip->output_section == p)
	    return TRUE;
	}
      return FALSE;

      /* There shouldn't be section relative relocations
	 against any other section.  */
    default:
      return TRUE;
    }
}

/* Assign dynsym indices.  In a shared library we generate a section
   symbol for each output section, which come first.  Next come symbols
   which have been forced to local binding.  Then all of the back-end
   allocated local dynamic syms, followed by the rest of the global
   symbols.  */

static unsigned long
_bfd_elf_link_renumber_dynsyms (bfd *output_bfd,
				struct bfd_link_info *info,
				unsigned long *section_sym_count)
{
  unsigned long dynsymcount = 0;

  if (info->shared || elf_hash_table (info)->is_relocatable_executable)
    {
      const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
      asection *p;
      for (p = output_bfd->sections; p ; p = p->next)
	if ((p->flags & SEC_EXCLUDE) == 0
	    && (p->flags & SEC_ALLOC) != 0
	    && !(*bed->elf_backend_omit_section_dynsym) (output_bfd, info, p))
	  elf_section_data (p)->dynindx = ++dynsymcount;
	else
	  elf_section_data (p)->dynindx = 0;
    }
  *section_sym_count = dynsymcount;

  elf_link_hash_traverse (elf_hash_table (info),
			  elf_link_renumber_local_hash_table_dynsyms,
			  &dynsymcount);

  if (elf_hash_table (info)->dynlocal)
    {
      struct elf_link_local_dynamic_entry *p;
      for (p = elf_hash_table (info)->dynlocal; p ; p = p->next)
	p->dynindx = ++dynsymcount;
    }

  elf_link_hash_traverse (elf_hash_table (info),
			  elf_link_renumber_hash_table_dynsyms,
			  &dynsymcount);

  /* There is an unused NULL entry at the head of the table which
     we must account for in our count.  Unless there weren't any
     symbols, which means we'll have no table at all.  */
  if (dynsymcount != 0)
    ++dynsymcount;

  elf_hash_table (info)->dynsymcount = dynsymcount;
  return dynsymcount;
}

/* Merge st_other field.  */

static void
elf_merge_st_other (bfd *abfd, struct elf_link_hash_entry *h,
		    Elf_Internal_Sym *isym, bfd_boolean definition,
		    bfd_boolean dynamic)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* If st_other has a processor-specific meaning, specific
     code might be needed here. We never merge the visibility
     attribute with the one from a dynamic object.  */
  if (bed->elf_backend_merge_symbol_attribute)
    (*bed->elf_backend_merge_symbol_attribute) (h, isym, definition,
						dynamic);

  /* If this symbol has default visibility and the user has requested
     we not re-export it, then mark it as hidden.  */
  if (definition
      && !dynamic
      && (abfd->no_export
	  || (abfd->my_archive && abfd->my_archive->no_export))
      && ELF_ST_VISIBILITY (isym->st_other) != STV_INTERNAL)
    isym->st_other = (STV_HIDDEN
		      | (isym->st_other & ~ELF_ST_VISIBILITY (-1)));

  if (!dynamic && ELF_ST_VISIBILITY (isym->st_other) != 0)
    {
      unsigned char hvis, symvis, other, nvis;

      /* Only merge the visibility. Leave the remainder of the
	 st_other field to elf_backend_merge_symbol_attribute.  */
      other = h->other & ~ELF_ST_VISIBILITY (-1);

      /* Combine visibilities, using the most constraining one.  */
      hvis = ELF_ST_VISIBILITY (h->other);
      symvis = ELF_ST_VISIBILITY (isym->st_other);
      if (! hvis)
	nvis = symvis;
      else if (! symvis)
	nvis = hvis;
      else
	nvis = hvis < symvis ? hvis : symvis;

      h->other = other | nvis;
    }
}

/* This function is called when we want to merge a new symbol with an
   existing symbol.  It handles the various cases which arise when we
   find a definition in a dynamic object, or when there is already a
   definition in a dynamic object.  The new symbol is described by
   NAME, SYM, PSEC, and PVALUE.  We set SYM_HASH to the hash table
   entry.  We set POLDBFD to the old symbol's BFD.  We set POLD_WEAK
   if the old symbol was weak.  We set POLD_ALIGNMENT to the alignment
   of an old common symbol.  We set OVERRIDE if the old symbol is
   overriding a new definition.  We set TYPE_CHANGE_OK if it is OK for
   the type to change.  We set SIZE_CHANGE_OK if it is OK for the size
   to change.  By OK to change, we mean that we shouldn't warn if the
   type or size does change.  */

static bfd_boolean
_bfd_elf_merge_symbol (bfd *abfd,
		       struct bfd_link_info *info,
		       const char *name,
		       Elf_Internal_Sym *sym,
		       asection **psec,
		       bfd_vma *pvalue,
		       struct elf_link_hash_entry **sym_hash,
		       bfd **poldbfd,
		       bfd_boolean *pold_weak,
		       unsigned int *pold_alignment,
		       bfd_boolean *skip,
		       bfd_boolean *override,
		       bfd_boolean *type_change_ok,
		       bfd_boolean *size_change_ok)
{
  asection *sec, *oldsec;
  struct elf_link_hash_entry *h;
  struct elf_link_hash_entry *hi;
  struct elf_link_hash_entry *flip;
  int bind;
  bfd *oldbfd;
  bfd_boolean newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
  bfd_boolean newweak, oldweak, newfunc, oldfunc;
  const struct elf_backend_data *bed;

  *skip = FALSE;
  *override = FALSE;

  sec = *psec;
  bind = ELF_ST_BIND (sym->st_info);

  if (! bfd_is_und_section (sec))
    h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, FALSE, FALSE);
  else
    h = ((struct elf_link_hash_entry *)
	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, FALSE, FALSE));
  if (h == NULL)
    return FALSE;
  *sym_hash = h;

  bed = get_elf_backend_data (abfd);

  /* For merging, we only care about real symbols.  But we need to make
     sure that indirect symbol dynamic flags are updated.  */
  hi = h;
  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* OLDBFD and OLDSEC are a BFD and an ASECTION associated with the
     existing symbol.  */

  oldbfd = NULL;
  oldsec = NULL;
  switch (h->root.type)
    {
    default:
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      oldbfd = h->root.u.undef.abfd;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      oldbfd = h->root.u.def.section->owner;
      oldsec = h->root.u.def.section;
      break;

    case bfd_link_hash_common:
      oldbfd = h->root.u.c.p->section->owner;
      oldsec = h->root.u.c.p->section;
      if (pold_alignment)
	*pold_alignment = h->root.u.c.p->alignment_power;
      break;
    }
  if (poldbfd && *poldbfd == NULL)
    *poldbfd = oldbfd;

  /* Differentiate strong and weak symbols.  */
  newweak = bind == STB_WEAK;
  oldweak = (h->root.type == bfd_link_hash_defweak
	     || h->root.type == bfd_link_hash_undefweak);
  if (pold_weak)
    *pold_weak = oldweak;

  /* This code is for coping with dynamic objects, and is only useful
     if we are doing an ELF link.  */
  if (!(*bed->relocs_compatible) (abfd->xvec, info->output_bfd->xvec))
    return TRUE;

  /* We have to check it for every instance since the first few may be
     references and not all compilers emit symbol type for undefined
     symbols.  */
  bfd_elf_link_mark_dynamic_symbol (info, h, sym);

  /* NEWDYN and OLDDYN indicate whether the new or old symbol,
     respectively, is from a dynamic object.  */

  newdyn = (abfd->flags & DYNAMIC) != 0;

  /* ref_dynamic_nonweak and dynamic_def flags track actual undefined
     syms and defined syms in dynamic libraries respectively.
     ref_dynamic on the other hand can be set for a symbol defined in
     a dynamic library, and def_dynamic may not be set;  When the
     definition in a dynamic lib is overridden by a definition in the
     executable use of the symbol in the dynamic lib becomes a
     reference to the executable symbol.  */
  if (newdyn)
    {
      if (bfd_is_und_section (sec))
	{
	  if (bind != STB_WEAK)
	    {
	      h->ref_dynamic_nonweak = 1;
	      hi->ref_dynamic_nonweak = 1;
	    }
	}
      else
	{
	  h->dynamic_def = 1;
	  hi->dynamic_def = 1;
	}
    }

  /* If we just created the symbol, mark it as being an ELF symbol.
     Other than that, there is nothing to do--there is no merge issue
     with a newly defined symbol--so we just return.  */

  if (h->root.type == bfd_link_hash_new)
    {
      h->non_elf = 0;
      return TRUE;
    }

  /* In cases involving weak versioned symbols, we may wind up trying
     to merge a symbol with itself.  Catch that here, to avoid the
     confusion that results if we try to override a symbol with
     itself.  The additional tests catch cases like
     _GLOBAL_OFFSET_TABLE_, which are regular symbols defined in a
     dynamic object, which we do want to handle here.  */
  if (abfd == oldbfd
      && (newweak || oldweak)
      && ((abfd->flags & DYNAMIC) == 0
	  || !h->def_regular))
    return TRUE;

  olddyn = FALSE;
  if (oldbfd != NULL)
    olddyn = (oldbfd->flags & DYNAMIC) != 0;
  else if (oldsec != NULL)
    {
      /* This handles the special SHN_MIPS_{TEXT,DATA} section
	 indices used by MIPS ELF.  */
      olddyn = (oldsec->symbol->flags & BSF_DYNAMIC) != 0;
    }

  /* NEWDEF and OLDDEF indicate whether the new or old symbol,
     respectively, appear to be a definition rather than reference.  */

  newdef = !bfd_is_und_section (sec) && !bfd_is_com_section (sec);

  olddef = (h->root.type != bfd_link_hash_undefined
	    && h->root.type != bfd_link_hash_undefweak
	    && h->root.type != bfd_link_hash_common);

  /* NEWFUNC and OLDFUNC indicate whether the new or old symbol,
     respectively, appear to be a function.  */

  newfunc = (ELF_ST_TYPE (sym->st_info) != STT_NOTYPE
	     && bed->is_function_type (ELF_ST_TYPE (sym->st_info)));

  oldfunc = (h->type != STT_NOTYPE
	     && bed->is_function_type (h->type));

  /* When we try to create a default indirect symbol from the dynamic
     definition with the default version, we skip it if its type and
     the type of existing regular definition mismatch.  We only do it
     if the existing regular definition won't be dynamic.  */
  if (pold_alignment == NULL
      && !info->shared
      && !info->export_dynamic
      && !h->ref_dynamic
      && newdyn
      && newdef
      && !olddyn
      && (olddef || h->root.type == bfd_link_hash_common)
      && ELF_ST_TYPE (sym->st_info) != h->type
      && ELF_ST_TYPE (sym->st_info) != STT_NOTYPE
      && h->type != STT_NOTYPE
      && !(newfunc && oldfunc))
    {
      *skip = TRUE;
      return TRUE;
    }

  /* Plugin symbol type isn't currently set.  Stop bogus errors.  */
  if (oldbfd != NULL && (oldbfd->flags & BFD_PLUGIN) != 0)
    *type_change_ok = TRUE;

  /* Check TLS symbol.  We don't check undefined symbol introduced by
     "ld -u".  */
  else if (oldbfd != NULL
	   && ELF_ST_TYPE (sym->st_info) != h->type
	   && (ELF_ST_TYPE (sym->st_info) == STT_TLS || h->type == STT_TLS))
    {
      bfd *ntbfd, *tbfd;
      bfd_boolean ntdef, tdef;
      asection *ntsec, *tsec;

      if (h->type == STT_TLS)
	{
	  ntbfd = abfd;
	  ntsec = sec;
	  ntdef = newdef;
	  tbfd = oldbfd;
	  tsec = oldsec;
	  tdef = olddef;
	}
      else
	{
	  ntbfd = oldbfd;
	  ntsec = oldsec;
	  ntdef = olddef;
	  tbfd = abfd;
	  tsec = sec;
	  tdef = newdef;
	}

      if (tdef && ntdef)
	(*_bfd_error_handler)
	  (_("%s: TLS definition in %B section %A "
	     "mismatches non-TLS definition in %B section %A"),
	   tbfd, tsec, ntbfd, ntsec, h->root.root.string);
      else if (!tdef && !ntdef)
	(*_bfd_error_handler)
	  (_("%s: TLS reference in %B "
	     "mismatches non-TLS reference in %B"),
	   tbfd, ntbfd, h->root.root.string);
      else if (tdef)
	(*_bfd_error_handler)
	  (_("%s: TLS definition in %B section %A "
	     "mismatches non-TLS reference in %B"),
	   tbfd, tsec, ntbfd, h->root.root.string);
      else
	(*_bfd_error_handler)
	  (_("%s: TLS reference in %B "
	     "mismatches non-TLS definition in %B section %A"),
	   tbfd, ntbfd, ntsec, h->root.root.string);

      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  /* If the old symbol has non-default visibility, we ignore the new
     definition from a dynamic object.  */
  if (newdyn
      && ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
      && !bfd_is_und_section (sec))
    {
      *skip = TRUE;
      /* Make sure this symbol is dynamic.  */
      h->ref_dynamic = 1;
      hi->ref_dynamic = 1;
      /* A protected symbol has external availability. Make sure it is
	 recorded as dynamic.

	 FIXME: Should we check type and size for protected symbol?  */
      if (ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)
	return bfd_elf_link_record_dynamic_symbol (info, h);
      else
	return TRUE;
    }
  else if (!newdyn
	   && ELF_ST_VISIBILITY (sym->st_other) != STV_DEFAULT
	   && h->def_dynamic)
    {
      /* If the new symbol with non-default visibility comes from a
	 relocatable file and the old definition comes from a dynamic
	 object, we remove the old definition.  */
      if (hi->root.type == bfd_link_hash_indirect)
	{
	  /* Handle the case where the old dynamic definition is
	     default versioned.  We need to copy the symbol info from
	     the symbol with default version to the normal one if it
	     was referenced before.  */
	  if (h->ref_regular)
	    {
	      hi->root.type = h->root.type;
	      h->root.type = bfd_link_hash_indirect;
	      (*bed->elf_backend_copy_indirect_symbol) (info, hi, h);

	      h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
	      if (ELF_ST_VISIBILITY (sym->st_other) != STV_PROTECTED)
		{
		  /* If the new symbol is hidden or internal, completely undo
		     any dynamic link state.  */
		  (*bed->elf_backend_hide_symbol) (info, h, TRUE);
		  h->forced_local = 0;
		  h->ref_dynamic = 0;
		}
	      else
		h->ref_dynamic = 1;

	      h->def_dynamic = 0;
	      /* FIXME: Should we check type and size for protected symbol?  */
	      h->size = 0;
	      h->type = 0;

	      h = hi;
	    }
	  else
	    h = hi;
	}

      /* If the old symbol was undefined before, then it will still be
	 on the undefs list.  If the new symbol is undefined or
	 common, we can't make it bfd_link_hash_new here, because new
	 undefined or common symbols will be added to the undefs list
	 by _bfd_generic_link_add_one_symbol.  Symbols may not be
	 added twice to the undefs list.  Also, if the new symbol is
	 undefweak then we don't want to lose the strong undef.  */
      if (h->root.u.undef.next || info->hash->undefs_tail == &h->root)
	{
	  h->root.type = bfd_link_hash_undefined;
	  h->root.u.undef.abfd = abfd;
	}
      else
	{
	  h->root.type = bfd_link_hash_new;
	  h->root.u.undef.abfd = NULL;
	}

      if (ELF_ST_VISIBILITY (sym->st_other) != STV_PROTECTED)
	{
	  /* If the new symbol is hidden or internal, completely undo
	     any dynamic link state.  */
	  (*bed->elf_backend_hide_symbol) (info, h, TRUE);
	  h->forced_local = 0;
	  h->ref_dynamic = 0;
	}
      else
	h->ref_dynamic = 1;
      h->def_dynamic = 0;
      /* FIXME: Should we check type and size for protected symbol?  */
      h->size = 0;
      h->type = 0;
      return TRUE;
    }

  /* If a new weak symbol definition comes from a regular file and the
     old symbol comes from a dynamic library, we treat the new one as
     strong.  Similarly, an old weak symbol definition from a regular
     file is treated as strong when the new symbol comes from a dynamic
     library.  Further, an old weak symbol from a dynamic library is
     treated as strong if the new symbol is from a dynamic library.
     This reflects the way glibc's ld.so works.

     Do this before setting *type_change_ok or *size_change_ok so that
     we warn properly when dynamic library symbols are overridden.  */

  if (newdef && !newdyn && olddyn)
    newweak = FALSE;
  if (olddef && newdyn)
    oldweak = FALSE;

  /* Allow changes between different types of function symbol.  */
  if (newfunc && oldfunc)
    *type_change_ok = TRUE;

  /* It's OK to change the type if either the existing symbol or the
     new symbol is weak.  A type change is also OK if the old symbol
     is undefined and the new symbol is defined.  */

  if (oldweak
      || newweak
      || (newdef
	  && h->root.type == bfd_link_hash_undefined))
    *type_change_ok = TRUE;

  /* It's OK to change the size if either the existing symbol or the
     new symbol is weak, or if the old symbol is undefined.  */

  if (*type_change_ok
      || h->root.type == bfd_link_hash_undefined)
    *size_change_ok = TRUE;

  /* NEWDYNCOMMON and OLDDYNCOMMON indicate whether the new or old
     symbol, respectively, appears to be a common symbol in a dynamic
     object.  If a symbol appears in an uninitialized section, and is
     not weak, and is not a function, then it may be a common symbol
     which was resolved when the dynamic object was created.  We want
     to treat such symbols specially, because they raise special
     considerations when setting the symbol size: if the symbol
     appears as a common symbol in a regular object, and the size in
     the regular object is larger, we must make sure that we use the
     larger size.  This problematic case can always be avoided in C,
     but it must be handled correctly when using Fortran shared
     libraries.

     Note that if NEWDYNCOMMON is set, NEWDEF will be set, and
     likewise for OLDDYNCOMMON and OLDDEF.

     Note that this test is just a heuristic, and that it is quite
     possible to have an uninitialized symbol in a shared object which
     is really a definition, rather than a common symbol.  This could
     lead to some minor confusion when the symbol really is a common
     symbol in some regular object.  However, I think it will be
     harmless.  */

  if (newdyn
      && newdef
      && !newweak
      && (sec->flags & SEC_ALLOC) != 0
      && (sec->flags & SEC_LOAD) == 0
      && sym->st_size > 0
      && !newfunc)
    newdyncommon = TRUE;
  else
    newdyncommon = FALSE;

  if (olddyn
      && olddef
      && h->root.type == bfd_link_hash_defined
      && h->def_dynamic
      && (h->root.u.def.section->flags & SEC_ALLOC) != 0
      && (h->root.u.def.section->flags & SEC_LOAD) == 0
      && h->size > 0
      && !oldfunc)
    olddyncommon = TRUE;
  else
    olddyncommon = FALSE;

  /* We now know everything about the old and new symbols.  We ask the
     backend to check if we can merge them.  */
  if (bed->merge_symbol != NULL)
    {
      if (!bed->merge_symbol (h, sym, psec, newdef, olddef, oldbfd, oldsec))
	return FALSE;
      sec = *psec;
    }

  /* If both the old and the new symbols look like common symbols in a
     dynamic object, set the size of the symbol to the larger of the
     two.  */

  if (olddyncommon
      && newdyncommon
      && sym->st_size != h->size)
    {
      /* Since we think we have two common symbols, issue a multiple
	 common warning if desired.  Note that we only warn if the
	 size is different.  If the size is the same, we simply let
	 the old symbol override the new one as normally happens with
	 symbols defined in dynamic objects.  */

      if (! ((*info->callbacks->multiple_common)
	     (info, &h->root, abfd, bfd_link_hash_common, sym->st_size)))
	return FALSE;

      if (sym->st_size > h->size)
	h->size = sym->st_size;

      *size_change_ok = TRUE;
    }

  /* If we are looking at a dynamic object, and we have found a
     definition, we need to see if the symbol was already defined by
     some other object.  If so, we want to use the existing
     definition, and we do not want to report a multiple symbol
     definition error; we do this by clobbering *PSEC to be
     bfd_und_section_ptr.

     We treat a common symbol as a definition if the symbol in the
     shared library is a function, since common symbols always
     represent variables; this can cause confusion in principle, but
     any such confusion would seem to indicate an erroneous program or
     shared library.  We also permit a common symbol in a regular
     object to override a weak symbol in a shared object.  */

  if (newdyn
      && newdef
      && (olddef
	  || (h->root.type == bfd_link_hash_common
	      && (newweak || newfunc))))
    {
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;

      *psec = sec = bfd_und_section_ptr;
      *size_change_ok = TRUE;

      /* If we get here when the old symbol is a common symbol, then
	 we are explicitly letting it override a weak symbol or
	 function in a dynamic object, and we don't want to warn about
	 a type change.  If the old symbol is a defined symbol, a type
	 change warning may still be appropriate.  */

      if (h->root.type == bfd_link_hash_common)
	*type_change_ok = TRUE;
    }

  /* Handle the special case of an old common symbol merging with a
     new symbol which looks like a common symbol in a shared object.
     We change *PSEC and *PVALUE to make the new symbol look like a
     common symbol, and let _bfd_generic_link_add_one_symbol do the
     right thing.  */

  if (newdyncommon
      && h->root.type == bfd_link_hash_common)
    {
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;
      *pvalue = sym->st_size;
      *psec = sec = bed->common_section (oldsec);
      *size_change_ok = TRUE;
    }

  /* Skip weak definitions of symbols that are already defined.  */
  if (newdef && olddef && newweak)
    {
      /* Don't skip new non-IR weak syms.  */
      if (!(oldbfd != NULL
	    && (oldbfd->flags & BFD_PLUGIN) != 0
	    && (abfd->flags & BFD_PLUGIN) == 0))
	*skip = TRUE;

      /* Merge st_other.  If the symbol already has a dynamic index,
	 but visibility says it should not be visible, turn it into a
	 local symbol.  */
      elf_merge_st_other (abfd, h, sym, newdef, newdyn);
      if (h->dynindx != -1)
	switch (ELF_ST_VISIBILITY (h->other))
	  {
	  case STV_INTERNAL:
	  case STV_HIDDEN:
	    (*bed->elf_backend_hide_symbol) (info, h, TRUE);
	    break;
	  }
    }

  /* If the old symbol is from a dynamic object, and the new symbol is
     a definition which is not from a dynamic object, then the new
     symbol overrides the old symbol.  Symbols from regular files
     always take precedence over symbols from dynamic objects, even if
     they are defined after the dynamic object in the link.

     As above, we again permit a common symbol in a regular object to
     override a definition in a shared object if the shared object
     symbol is a function or is weak.  */

  flip = NULL;
  if (!newdyn
      && (newdef
	  || (bfd_is_com_section (sec)
	      && (oldweak || oldfunc)))
      && olddyn
      && olddef
      && h->def_dynamic)
    {
      /* Change the hash table entry to undefined, and let
	 _bfd_generic_link_add_one_symbol do the right thing with the
	 new definition.  */

      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;
      *size_change_ok = TRUE;

      olddef = FALSE;
      olddyncommon = FALSE;

      /* We again permit a type change when a common symbol may be
	 overriding a function.  */

      if (bfd_is_com_section (sec))
	{
	  if (oldfunc)
	    {
	      /* If a common symbol overrides a function, make sure
		 that it isn't defined dynamically nor has type
		 function.  */
	      h->def_dynamic = 0;
	      h->type = STT_NOTYPE;
	    }
	  *type_change_ok = TRUE;
	}

      if (hi->root.type == bfd_link_hash_indirect)
	flip = hi;
      else
	/* This union may have been set to be non-NULL when this symbol
	   was seen in a dynamic object.  We must force the union to be
	   NULL, so that it is correct for a regular symbol.  */
	h->verinfo.vertree = NULL;
    }

  /* Handle the special case of a new common symbol merging with an
     old symbol that looks like it might be a common symbol defined in
     a shared object.  Note that we have already handled the case in
     which a new common symbol should simply override the definition
     in the shared library.  */

  if (! newdyn
      && bfd_is_com_section (sec)
      && olddyncommon)
    {
      /* It would be best if we could set the hash table entry to a
	 common symbol, but we don't know what to use for the section
	 or the alignment.  */
      if (! ((*info->callbacks->multiple_common)
	     (info, &h->root, abfd, bfd_link_hash_common, sym->st_size)))
	return FALSE;

      /* If the presumed common symbol in the dynamic object is
	 larger, pretend that the new symbol has its size.  */

      if (h->size > *pvalue)
	*pvalue = h->size;

      /* We need to remember the alignment required by the symbol
	 in the dynamic object.  */
      BFD_ASSERT (pold_alignment);
      *pold_alignment = h->root.u.def.section->alignment_power;

      olddef = FALSE;
      olddyncommon = FALSE;

      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;

      *size_change_ok = TRUE;
      *type_change_ok = TRUE;

      if (hi->root.type == bfd_link_hash_indirect)
	flip = hi;
      else
	h->verinfo.vertree = NULL;
    }

  if (flip != NULL)
    {
      /* Handle the case where we had a versioned symbol in a dynamic
	 library and now find a definition in a normal object.  In this
	 case, we make the versioned symbol point to the normal one.  */
      flip->root.type = h->root.type;
      flip->root.u.undef.abfd = h->root.u.undef.abfd;
      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) flip;
      (*bed->elf_backend_copy_indirect_symbol) (info, flip, h);
      if (h->def_dynamic)
	{
	  h->def_dynamic = 0;
	  flip->ref_dynamic = 1;
	}
    }

  return TRUE;
}

/* This function is called to create an indirect symbol from the
   default for the symbol with the default version if needed. The
   symbol is described by H, NAME, SYM, SEC, and VALUE.  We
   set DYNSYM if the new indirect symbol is dynamic.  */

static bfd_boolean
_bfd_elf_add_default_symbol (bfd *abfd,
			     struct bfd_link_info *info,
			     struct elf_link_hash_entry *h,
			     const char *name,
			     Elf_Internal_Sym *sym,
			     asection *sec,
			     bfd_vma value,
			     bfd **poldbfd,
			     bfd_boolean *dynsym)
{
  bfd_boolean type_change_ok;
  bfd_boolean size_change_ok;
  bfd_boolean skip;
  char *shortname;
  struct elf_link_hash_entry *hi;
  struct bfd_link_hash_entry *bh;
  const struct elf_backend_data *bed;
  bfd_boolean collect;
  bfd_boolean dynamic;
  bfd_boolean override;
  char *p;
  size_t len, shortlen;
  asection *tmp_sec;

  /* If this symbol has a version, and it is the default version, we
     create an indirect symbol from the default name to the fully
     decorated name.  This will cause external references which do not
     specify a version to be bound to this version of the symbol.  */
  p = strchr (name, ELF_VER_CHR);
  if (p == NULL || p[1] != ELF_VER_CHR)
    return TRUE;

  bed = get_elf_backend_data (abfd);
  collect = bed->collect;
  dynamic = (abfd->flags & DYNAMIC) != 0;

  shortlen = p - name;
  shortname = (char *) bfd_hash_allocate (&info->hash->table, shortlen + 1);
  if (shortname == NULL)
    return FALSE;
  memcpy (shortname, name, shortlen);
  shortname[shortlen] = '\0';

  /* We are going to create a new symbol.  Merge it with any existing
     symbol with this name.  For the purposes of the merge, act as
     though we were defining the symbol we just defined, although we
     actually going to define an indirect symbol.  */
  type_change_ok = FALSE;
  size_change_ok = FALSE;
  tmp_sec = sec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &tmp_sec, &value,
			      &hi, poldbfd, NULL, NULL, &skip, &override,
			      &type_change_ok, &size_change_ok))
    return FALSE;

  if (skip)
    goto nondefault;

  if (! override)
    {
      bh = &hi->root;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, shortname, BSF_INDIRECT, bfd_ind_section_ptr,
	      0, name, FALSE, collect, &bh)))
	return FALSE;
      hi = (struct elf_link_hash_entry *) bh;
    }
  else
    {
      /* In this case the symbol named SHORTNAME is overriding the
	 indirect symbol we want to add.  We were planning on making
	 SHORTNAME an indirect symbol referring to NAME.  SHORTNAME
	 is the name without a version.  NAME is the fully versioned
	 name, and it is the default version.

	 Overriding means that we already saw a definition for the
	 symbol SHORTNAME in a regular object, and it is overriding
	 the symbol defined in the dynamic object.

	 When this happens, we actually want to change NAME, the
	 symbol we just added, to refer to SHORTNAME.  This will cause
	 references to NAME in the shared object to become references
	 to SHORTNAME in the regular object.  This is what we expect
	 when we override a function in a shared object: that the
	 references in the shared object will be mapped to the
	 definition in the regular object.  */

      while (hi->root.type == bfd_link_hash_indirect
	     || hi->root.type == bfd_link_hash_warning)
	hi = (struct elf_link_hash_entry *) hi->root.u.i.link;

      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
      if (h->def_dynamic)
	{
	  h->def_dynamic = 0;
	  hi->ref_dynamic = 1;
	  if (hi->ref_regular
	      || hi->def_regular)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, hi))
		return FALSE;
	    }
	}

      /* Now set HI to H, so that the following code will set the
	 other fields correctly.  */
      hi = h;
    }

  /* Check if HI is a warning symbol.  */
  if (hi->root.type == bfd_link_hash_warning)
    hi = (struct elf_link_hash_entry *) hi->root.u.i.link;

  /* If there is a duplicate definition somewhere, then HI may not
     point to an indirect symbol.  We will have reported an error to
     the user in that case.  */

  if (hi->root.type == bfd_link_hash_indirect)
    {
      struct elf_link_hash_entry *ht;

      ht = (struct elf_link_hash_entry *) hi->root.u.i.link;
      (*bed->elf_backend_copy_indirect_symbol) (info, ht, hi);

      /* See if the new flags lead us to realize that the symbol must
	 be dynamic.  */
      if (! *dynsym)
	{
	  if (! dynamic)
	    {
	      if (! info->executable
		  || hi->def_dynamic
		  || hi->ref_dynamic)
		*dynsym = TRUE;
	    }
	  else
	    {
	      if (hi->ref_regular)
		*dynsym = TRUE;
	    }
	}
    }

  /* We also need to define an indirection from the nondefault version
     of the symbol.  */

nondefault:
  len = strlen (name);
  shortname = (char *) bfd_hash_allocate (&info->hash->table, len);
  if (shortname == NULL)
    return FALSE;
  memcpy (shortname, name, shortlen);
  memcpy (shortname + shortlen, p + 1, len - shortlen);

  /* Once again, merge with any existing symbol.  */
  type_change_ok = FALSE;
  size_change_ok = FALSE;
  tmp_sec = sec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &tmp_sec, &value,
			      &hi, NULL, NULL, NULL, &skip, &override,
			      &type_change_ok, &size_change_ok))
    return FALSE;

  if (skip)
    return TRUE;

  if (override)
    {
      /* Here SHORTNAME is a versioned name, so we don't expect to see
	 the type of override we do in the case above unless it is
	 overridden by a versioned definition.  */
      if (hi->root.type != bfd_link_hash_defined
	  && hi->root.type != bfd_link_hash_defweak)
	(*_bfd_error_handler)
	  (_("%B: unexpected redefinition of indirect versioned symbol `%s'"),
	   abfd, shortname);
    }
  else
    {
      bh = &hi->root;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, shortname, BSF_INDIRECT,
	      bfd_ind_section_ptr, 0, name, FALSE, collect, &bh)))
	return FALSE;
      hi = (struct elf_link_hash_entry *) bh;

      /* If there is a duplicate definition somewhere, then HI may not
	 point to an indirect symbol.  We will have reported an error
	 to the user in that case.  */

      if (hi->root.type == bfd_link_hash_indirect)
	{
	  (*bed->elf_backend_copy_indirect_symbol) (info, h, hi);

	  /* See if the new flags lead us to realize that the symbol
	     must be dynamic.  */
	  if (! *dynsym)
	    {
	      if (! dynamic)
		{
		  if (! info->executable
		      || hi->ref_dynamic)
		    *dynsym = TRUE;
		}
	      else
		{
		  if (hi->ref_regular)
		    *dynsym = TRUE;
		}
	    }
	}
    }

  return TRUE;
}

/* This routine is used to export all defined symbols into the dynamic
   symbol table.  It is called via elf_link_hash_traverse.  */

static bfd_boolean
_bfd_elf_export_symbol (struct elf_link_hash_entry *h, void *data)
{
  struct elf_info_failed *eif = (struct elf_info_failed *) data;

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  /* Ignore this if we won't export it.  */
  if (!eif->info->export_dynamic && !h->dynamic)
    return TRUE;

  if (h->dynindx == -1
      && (h->def_regular || h->ref_regular)
      && ! bfd_hide_sym_by_version (eif->info->version_info,
				    h->root.root.string))
    {
      if (! bfd_elf_link_record_dynamic_symbol (eif->info, h))
	{
	  eif->failed = TRUE;
	  return FALSE;
	}
    }

  return TRUE;
}

/* Look through the symbols which are defined in other shared
   libraries and referenced here.  Update the list of version
   dependencies.  This will be put into the .gnu.version_r section.
   This function is called via elf_link_hash_traverse.  */

static bfd_boolean
_bfd_elf_link_find_version_dependencies (struct elf_link_hash_entry *h,
					 void *data)
{
  struct elf_find_verdep_info *rinfo = (struct elf_find_verdep_info *) data;
  Elf_Internal_Verneed *t;
  Elf_Internal_Vernaux *a;
  bfd_size_type amt;

  /* We only care about symbols defined in shared objects with version
     information.  */
  if (!h->def_dynamic
      || h->def_regular
      || h->dynindx == -1
      || h->verinfo.verdef == NULL)
    return TRUE;

  /* See if we already know about this version.  */
  for (t = elf_tdata (rinfo->info->output_bfd)->verref;
       t != NULL;
       t = t->vn_nextref)
    {
      if (t->vn_bfd != h->verinfo.verdef->vd_bfd)
	continue;

      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
	if (a->vna_nodename == h->verinfo.verdef->vd_nodename)
	  return TRUE;

      break;
    }

  /* This is a new version.  Add it to tree we are building.  */

  if (t == NULL)
    {
      amt = sizeof *t;
      t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->info->output_bfd, amt);
      if (t == NULL)
	{
	  rinfo->failed = TRUE;
	  return FALSE;
	}

      t->vn_bfd = h->verinfo.verdef->vd_bfd;
      t->vn_nextref = elf_tdata (rinfo->info->output_bfd)->verref;
      elf_tdata (rinfo->info->output_bfd)->verref = t;
    }

  amt = sizeof *a;
  a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->info->output_bfd, amt);
  if (a == NULL)
    {
      rinfo->failed = TRUE;
      return FALSE;
    }

  /* Note that we are copying a string pointer here, and testing it
     above.  If bfd_elf_string_from_elf_section is ever changed to
     discard the string data when low in memory, this will have to be
     fixed.  */
  a->vna_nodename = h->verinfo.verdef->vd_nodename;

  a->vna_flags = h->verinfo.verdef->vd_flags;
  a->vna_nextptr = t->vn_auxptr;

  h->verinfo.verdef->vd_exp_refno = rinfo->vers;
  ++rinfo->vers;

  a->vna_other = h->verinfo.verdef->vd_exp_refno + 1;

  t->vn_auxptr = a;

  return TRUE;
}

/* Figure out appropriate versions for all the symbols.  We may not
   have the version number script until we have read all of the input
   files, so until that point we don't know which symbols should be
   local.  This function is called via elf_link_hash_traverse.  */

static bfd_boolean
_bfd_elf_link_assign_sym_version (struct elf_link_hash_entry *h, void *data)
{
  struct elf_info_failed *sinfo;
  struct bfd_link_info *info;
  const struct elf_backend_data *bed;
  struct elf_info_failed eif;
  char *p;
  bfd_size_type amt;

  sinfo = (struct elf_info_failed *) data;
  info = sinfo->info;

  /* Fix the symbol flags.  */
  eif.failed = FALSE;
  eif.info = info;
  if (! _bfd_elf_fix_symbol_flags (h, &eif))
    {
      if (eif.failed)
	sinfo->failed = TRUE;
      return FALSE;
    }

  /* We only need version numbers for symbols defined in regular
     objects.  */
  if (!h->def_regular)
    return TRUE;

  bed = get_elf_backend_data (info->output_bfd);
  p = strchr (h->root.root.string, ELF_VER_CHR);
  if (p != NULL && h->verinfo.vertree == NULL)
    {
      struct bfd_elf_version_tree *t;
      bfd_boolean hidden;

      hidden = TRUE;

      /* There are two consecutive ELF_VER_CHR characters if this is
	 not a hidden symbol.  */
      ++p;
      if (*p == ELF_VER_CHR)
	{
	  hidden = FALSE;
	  ++p;
	}

      /* If there is no version string, we can just return out.  */
      if (*p == '\0')
	{
	  if (hidden)
	    h->hidden = 1;
	  return TRUE;
	}

      /* Look for the version.  If we find it, it is no longer weak.  */
      for (t = sinfo->info->version_info; t != NULL; t = t->next)
	{
	  if (strcmp (t->name, p) == 0)
	    {
	      size_t len;
	      char *alc;
	      struct bfd_elf_version_expr *d;

	      len = p - h->root.root.string;
	      alc = (char *) bfd_malloc (len);
	      if (alc == NULL)
		{
		  sinfo->failed = TRUE;
		  return FALSE;
		}
	      memcpy (alc, h->root.root.string, len - 1);
	      alc[len - 1] = '\0';
	      if (alc[len - 2] == ELF_VER_CHR)
		alc[len - 2] = '\0';

	      h->verinfo.vertree = t;
	      t->used = TRUE;
	      d = NULL;

	      if (t->globals.list != NULL)
		d = (*t->match) (&t->globals, NULL, alc);

	      /* See if there is anything to force this symbol to
		 local scope.  */
	      if (d == NULL && t->locals.list != NULL)
		{
		  d = (*t->match) (&t->locals, NULL, alc);
		  if (d != NULL
		      && h->dynindx != -1
		      && ! info->export_dynamic)
		    (*bed->elf_backend_hide_symbol) (info, h, TRUE);
		}

	      free (alc);
	      break;
	    }
	}

      /* If we are building an application, we need to create a
	 version node for this version.  */
      if (t == NULL && info->executable)
	{
	  struct bfd_elf_version_tree **pp;
	  int version_index;

	  /* If we aren't going to export this symbol, we don't need
	     to worry about it.  */
	  if (h->dynindx == -1)
	    return TRUE;

	  amt = sizeof *t;
	  t = (struct bfd_elf_version_tree *) bfd_zalloc (info->output_bfd, amt);
	  if (t == NULL)
	    {
	      sinfo->failed = TRUE;
	      return FALSE;
	    }

	  t->name = p;
	  t->name_indx = (unsigned int) -1;
	  t->used = TRUE;

	  version_index = 1;
	  /* Don't count anonymous version tag.  */
	  if (sinfo->info->version_info != NULL
	      && sinfo->info->version_info->vernum == 0)
	    version_index = 0;
	  for (pp = &sinfo->info->version_info;
	       *pp != NULL;
	       pp = &(*pp)->next)
	    ++version_index;
	  t->vernum = version_index;

	  *pp = t;

	  h->verinfo.vertree = t;
	}
      else if (t == NULL)
	{
	  /* We could not find the version for a symbol when
	     generating a shared archive.  Return an error.  */
	  (*_bfd_error_handler)
	    (_("%B: version node not found for symbol %s"),
	     info->output_bfd, h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  sinfo->failed = TRUE;
	  return FALSE;
	}

      if (hidden)
	h->hidden = 1;
    }

  /* If we don't have a version for this symbol, see if we can find
     something.  */
  if (h->verinfo.vertree == NULL && sinfo->info->version_info != NULL)
    {
      bfd_boolean hide;

      h->verinfo.vertree
	= bfd_find_version_for_sym (sinfo->info->version_info,
				    h->root.root.string, &hide);
      if (h->verinfo.vertree != NULL && hide)
	(*bed->elf_backend_hide_symbol) (info, h, TRUE);
    }

  return TRUE;
}

/* Read and swap the relocs from the section indicated by SHDR.  This
   may be either a REL or a RELA section.  The relocations are
   translated into RELA relocations and stored in INTERNAL_RELOCS,
   which should have already been allocated to contain enough space.
   The EXTERNAL_RELOCS are a buffer where the external form of the
   relocations should be stored.

   Returns FALSE if something goes wrong.  */

static bfd_boolean
elf_link_read_relocs_from_section (bfd *abfd,
				   asection *sec,
				   Elf_Internal_Shdr *shdr,
				   void *external_relocs,
				   Elf_Internal_Rela *internal_relocs)
{
  const struct elf_backend_data *bed;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  const bfd_byte *erela;
  const bfd_byte *erelaend;
  Elf_Internal_Rela *irela;
  Elf_Internal_Shdr *symtab_hdr;
  size_t nsyms;

  /* Position ourselves at the start of the section.  */
  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0)
    return FALSE;

  /* Read the relocations.  */
  if (bfd_bread (external_relocs, shdr->sh_size, abfd) != shdr->sh_size)
    return FALSE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  nsyms = NUM_SHDR_ENTRIES (symtab_hdr);

  bed = get_elf_backend_data (abfd);

  /* Convert the external relocations to the internal format.  */
  if (shdr->sh_entsize == bed->s->sizeof_rel)
    swap_in = bed->s->swap_reloc_in;
  else if (shdr->sh_entsize == bed->s->sizeof_rela)
    swap_in = bed->s->swap_reloca_in;
  else
    {
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  erela = (const bfd_byte *) external_relocs;
  erelaend = erela + shdr->sh_size;
  irela = internal_relocs;
  while (erela < erelaend)
    {
      bfd_vma r_symndx;

      (*swap_in) (abfd, erela, irela);
      r_symndx = ELF32_R_SYM (irela->r_info);
      if (bed->s->arch_size == 64)
	r_symndx >>= 24;
      if (nsyms > 0)
	{
	  if ((size_t) r_symndx >= nsyms)
	    {
	      (*_bfd_error_handler)
		(_("%B: bad reloc symbol index (0x%lx >= 0x%lx)"
		   " for offset 0x%lx in section `%A'"),
		 abfd, sec,
		 (unsigned long) r_symndx, (unsigned long) nsyms, irela->r_offset);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}
      else if (r_symndx != STN_UNDEF)
	{
	  (*_bfd_error_handler)
	    (_("%B: non-zero symbol index (0x%lx) for offset 0x%lx in section `%A'"
	       " when the object file has no symbol table"),
	     abfd, sec,
	     (unsigned long) r_symndx, (unsigned long) nsyms, irela->r_offset);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      irela += bed->s->int_rels_per_ext_rel;
      erela += shdr->sh_entsize;
    }

  return TRUE;
}

/* Read and swap the relocs for a section O.  They may have been
   cached.  If the EXTERNAL_RELOCS and INTERNAL_RELOCS arguments are
   not NULL, they are used as buffers to read into.  They are known to
   be large enough.  If the INTERNAL_RELOCS relocs argument is NULL,
   the return value is allocated using either malloc or bfd_alloc,
   according to the KEEP_MEMORY argument.  If O has two relocation
   sections (both REL and RELA relocations), then the REL_HDR
   relocations will appear first in INTERNAL_RELOCS, followed by the
   RELA_HDR relocations.  */

Elf_Internal_Rela *
_bfd_elf_link_read_relocs (bfd *abfd,
			   asection *o,
			   void *external_relocs,
			   Elf_Internal_Rela *internal_relocs,
			   bfd_boolean keep_memory)
{
  void *alloc1 = NULL;
  Elf_Internal_Rela *alloc2 = NULL;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct bfd_elf_section_data *esdo = elf_section_data (o);
  Elf_Internal_Rela *internal_rela_relocs;

  if (esdo->relocs != NULL)
    return esdo->relocs;

  if (o->reloc_count == 0)
    return NULL;

  if (internal_relocs == NULL)
    {
      bfd_size_type size;

      size = o->reloc_count;
      size *= bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rela);
      if (keep_memory)
	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_alloc (abfd, size);
      else
	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_malloc (size);
      if (internal_relocs == NULL)
	goto error_return;
    }

  if (external_relocs == NULL)
    {
      bfd_size_type size = 0;

      if (esdo->rel.hdr)
	size += esdo->rel.hdr->sh_size;
      if (esdo->rela.hdr)
	size += esdo->rela.hdr->sh_size;

      alloc1 = bfd_malloc (size);
      if (alloc1 == NULL)
	goto error_return;
      external_relocs = alloc1;
    }

  internal_rela_relocs = internal_relocs;
  if (esdo->rel.hdr)
    {
      if (!elf_link_read_relocs_from_section (abfd, o, esdo->rel.hdr,
					      external_relocs,
					      internal_relocs))
	goto error_return;
      external_relocs = (((bfd_byte *) external_relocs)
			 + esdo->rel.hdr->sh_size);
      internal_rela_relocs += (NUM_SHDR_ENTRIES (esdo->rel.hdr)
			       * bed->s->int_rels_per_ext_rel);
    }

  if (esdo->rela.hdr
      && (!elf_link_read_relocs_from_section (abfd, o, esdo->rela.hdr,
					      external_relocs,
					      internal_rela_relocs)))
    goto error_return;

  /* Cache the results for next time, if we can.  */
  if (keep_memory)
    esdo->relocs = internal_relocs;

  if (alloc1 != NULL)
    free (alloc1);

  /* Don't free alloc2, since if it was allocated we are passing it
     back (under the name of internal_relocs).  */

  return internal_relocs;

 error_return:
  if (alloc1 != NULL)
    free (alloc1);
  if (alloc2 != NULL)
    {
      if (keep_memory)
	bfd_release (abfd, alloc2);
      else
	free (alloc2);
    }
  return NULL;
}

/* Compute the size of, and allocate space for, REL_HDR which is the
   section header for a section containing relocations for O.  */

static bfd_boolean
_bfd_elf_link_size_reloc_section (bfd *abfd,
				  struct bfd_elf_section_reloc_data *reldata)
{
  Elf_Internal_Shdr *rel_hdr = reldata->hdr;

  /* That allows us to calculate the size of the section.  */
  rel_hdr->sh_size = rel_hdr->sh_entsize * reldata->count;

  /* The contents field must last into write_object_contents, so we
     allocate it with bfd_alloc rather than malloc.  Also since we
     cannot be sure that the contents will actually be filled in,
     we zero the allocated space.  */
  rel_hdr->contents = (unsigned char *) bfd_zalloc (abfd, rel_hdr->sh_size);
  if (rel_hdr->contents == NULL && rel_hdr->sh_size != 0)
    return FALSE;

  if (reldata->hashes == NULL && reldata->count)
    {
      struct elf_link_hash_entry **p;

      p = (struct elf_link_hash_entry **)
          bfd_zmalloc (reldata->count * sizeof (struct elf_link_hash_entry *));
      if (p == NULL)
	return FALSE;

      reldata->hashes = p;
    }

  return TRUE;
}

/* Copy the relocations indicated by the INTERNAL_RELOCS (which
   originated from the section given by INPUT_REL_HDR) to the
   OUTPUT_BFD.  */

bfd_boolean
_bfd_elf_link_output_relocs (bfd *output_bfd,
			     asection *input_section,
			     Elf_Internal_Shdr *input_rel_hdr,
			     Elf_Internal_Rela *internal_relocs,
			     struct elf_link_hash_entry **rel_hash
			       ATTRIBUTE_UNUSED)
{
  Elf_Internal_Rela *irela;
  Elf_Internal_Rela *irelaend;
  bfd_byte *erel;
  struct bfd_elf_section_reloc_data *output_reldata;
  asection *output_section;
  const struct elf_backend_data *bed;
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  struct bfd_elf_section_data *esdo;

  output_section = input_section->output_section;

  bed = get_elf_backend_data (output_bfd);
  esdo = elf_section_data (output_section);
  if (esdo->rel.hdr && esdo->rel.hdr->sh_entsize == input_rel_hdr->sh_entsize)
    {
      output_reldata = &esdo->rel;
      swap_out = bed->s->swap_reloc_out;
    }
  else if (esdo->rela.hdr
	   && esdo->rela.hdr->sh_entsize == input_rel_hdr->sh_entsize)
    {
      output_reldata = &esdo->rela;
      swap_out = bed->s->swap_reloca_out;
    }
  else
    {
      (*_bfd_error_handler)
	(_("%B: relocation size mismatch in %B section %A"),
	 output_bfd, input_section->owner, input_section);
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  erel = output_reldata->hdr->contents;
  erel += output_reldata->count * input_rel_hdr->sh_entsize;
  irela = internal_relocs;
  irelaend = irela + (NUM_SHDR_ENTRIES (input_rel_hdr)
		      * bed->s->int_rels_per_ext_rel);
  while (irela < irelaend)
    {
      (*swap_out) (output_bfd, irela, erel);
      irela += bed->s->int_rels_per_ext_rel;
      erel += input_rel_hdr->sh_entsize;
    }

  /* Bump the counter, so that we know where to add the next set of
     relocations.  */
  output_reldata->count += NUM_SHDR_ENTRIES (input_rel_hdr);

  return TRUE;
}

/* Make weak undefined symbols in PIE dynamic.  */

bfd_boolean
_bfd_elf_link_hash_fixup_symbol (struct bfd_link_info *info,
				 struct elf_link_hash_entry *h)
{
  if (info->pie
      && h->dynindx == -1
      && h->root.type == bfd_link_hash_undefweak)
    return bfd_elf_link_record_dynamic_symbol (info, h);

  return TRUE;
}

/* Fix up the flags for a symbol.  This handles various cases which
   can only be fixed after all the input files are seen.  This is
   currently called by both adjust_dynamic_symbol and
   assign_sym_version, which is unnecessary but perhaps more robust in
   the face of future changes.  */

static bfd_boolean
_bfd_elf_fix_symbol_flags (struct elf_link_hash_entry *h,
			   struct elf_info_failed *eif)
{
  const struct elf_backend_data *bed;

  /* If this symbol was mentioned in a non-ELF file, try to set
     DEF_REGULAR and REF_REGULAR correctly.  This is the only way to
     permit a non-ELF file to correctly refer to a symbol defined in
     an ELF dynamic object.  */
  if (h->non_elf)
    {
      while (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      if (h->root.type != bfd_link_hash_defined
	  && h->root.type != bfd_link_hash_defweak)
	{
	  h->ref_regular = 1;
	  h->ref_regular_nonweak = 1;
	}
      else
	{
	  if (h->root.u.def.section->owner != NULL
	      && (bfd_get_flavour (h->root.u.def.section->owner)
		  == bfd_target_elf_flavour))
	    {
	      h->ref_regular = 1;
	      h->ref_regular_nonweak = 1;
	    }
	  else
	    h->def_regular = 1;
	}

      if (h->dynindx == -1
	  && (h->def_dynamic
	      || h->ref_dynamic))
	{
	  if (! bfd_elf_link_record_dynamic_symbol (eif->info, h))
	    {
	      eif->failed = TRUE;
	      return FALSE;
	    }
	}
    }
  else
    {
      /* Unfortunately, NON_ELF is only correct if the symbol
	 was first seen in a non-ELF file.  Fortunately, if the symbol
	 was first seen in an ELF file, we're probably OK unless the
	 symbol was defined in a non-ELF file.  Catch that case here.
	 FIXME: We're still in trouble if the symbol was first seen in
	 a dynamic object, and then later in a non-ELF regular object.  */
      if ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && !h->def_regular
	  && (h->root.u.def.section->owner != NULL
	      ? (bfd_get_flavour (h->root.u.def.section->owner)
		 != bfd_target_elf_flavour)
	      : (bfd_is_abs_section (h->root.u.def.section)
		 && !h->def_dynamic)))
	h->def_regular = 1;
    }

  /* Backend specific symbol fixup.  */
  bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
  if (bed->elf_backend_fixup_symbol
      && !(*bed->elf_backend_fixup_symbol) (eif->info, h))
    return FALSE;

  /* If this is a final link, and the symbol was defined as a common
     symbol in a regular object file, and there was no definition in
     any dynamic object, then the linker will have allocated space for
     the symbol in a common section but the DEF_REGULAR
     flag will not have been set.  */
  if (h->root.type == bfd_link_hash_defined
      && !h->def_regular
      && h->ref_regular
      && !h->def_dynamic
      && (h->root.u.def.section->owner->flags & (DYNAMIC | BFD_PLUGIN)) == 0)
    h->def_regular = 1;

  /* If -Bsymbolic was used (which means to bind references to global
     symbols to the definition within the shared object), and this
     symbol was defined in a regular object, then it actually doesn't
     need a PLT entry.  Likewise, if the symbol has non-default
     visibility.  If the symbol has hidden or internal visibility, we
     will force it local.  */
  if (h->needs_plt
      && eif->info->shared
      && is_elf_hash_table (eif->info->hash)
      && (SYMBOLIC_BIND (eif->info, h)
	  || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
      && h->def_regular)
    {
      bfd_boolean force_local;

      force_local = (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
		     || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN);
      (*bed->elf_backend_hide_symbol) (eif->info, h, force_local);
    }

  /* If a weak undefined symbol has non-default visibility, we also
     hide it from the dynamic linker.  */
  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
      && h->root.type == bfd_link_hash_undefweak)
    (*bed->elf_backend_hide_symbol) (eif->info, h, TRUE);

  /* If this is a weak defined symbol in a dynamic object, and we know
     the real definition in the dynamic object, copy interesting flags
     over to the real definition.  */
  if (h->u.weakdef != NULL)
    {
      /* If the real definition is defined by a regular object file,
	 don't do anything special.  See the longer description in
	 _bfd_elf_adjust_dynamic_symbol, below.  */
      if (h->u.weakdef->def_regular)
	h->u.weakdef = NULL;
      else
	{
	  struct elf_link_hash_entry *weakdef = h->u.weakdef;

	  while (h->root.type == bfd_link_hash_indirect)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  BFD_ASSERT (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak);
	  BFD_ASSERT (weakdef->def_dynamic);
	  BFD_ASSERT (weakdef->root.type == bfd_link_hash_defined
		      || weakdef->root.type == bfd_link_hash_defweak);
	  (*bed->elf_backend_copy_indirect_symbol) (eif->info, weakdef, h);
	}
    }

  return TRUE;
}

/* Make the backend pick a good value for a dynamic symbol.  This is
   called via elf_link_hash_traverse, and also calls itself
   recursively.  */

static bfd_boolean
_bfd_elf_adjust_dynamic_symbol (struct elf_link_hash_entry *h, void *data)
{
  struct elf_info_failed *eif = (struct elf_info_failed *) data;
  bfd *dynobj;
  const struct elf_backend_data *bed;

  if (! is_elf_hash_table (eif->info->hash))
    return FALSE;

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  /* Fix the symbol flags.  */
  if (! _bfd_elf_fix_symbol_flags (h, eif))
    return FALSE;

  /* If this symbol does not require a PLT entry, and it is not
     defined by a dynamic object, or is not referenced by a regular
     object, ignore it.  We do have to handle a weak defined symbol,
     even if no regular object refers to it, if we decided to add it
     to the dynamic symbol table.  FIXME: Do we normally need to worry
     about symbols which are defined by one dynamic object and
     referenced by another one?  */
  if (!h->needs_plt
      && h->type != STT_GNU_IFUNC
      && (h->def_regular
	  || !h->def_dynamic
	  || (!h->ref_regular
	      && (h->u.weakdef == NULL || h->u.weakdef->dynindx == -1))))
    {
      h->plt = elf_hash_table (eif->info)->init_plt_offset;
      return TRUE;
    }

  /* If we've already adjusted this symbol, don't do it again.  This
     can happen via a recursive call.  */
  if (h->dynamic_adjusted)
    return TRUE;

  /* Don't look at this symbol again.  Note that we must set this
     after checking the above conditions, because we may look at a
     symbol once, decide not to do anything, and then get called
     recursively later after REF_REGULAR is set below.  */
  h->dynamic_adjusted = 1;

  /* If this is a weak definition, and we know a real definition, and
     the real symbol is not itself defined by a regular object file,
     then get a good value for the real definition.  We handle the
     real symbol first, for the convenience of the backend routine.

     Note that there is a confusing case here.  If the real definition
     is defined by a regular object file, we don't get the real symbol
     from the dynamic object, but we do get the weak symbol.  If the
     processor backend uses a COPY reloc, then if some routine in the
     dynamic object changes the real symbol, we will not see that
     change in the corresponding weak symbol.  This is the way other
     ELF linkers work as well, and seems to be a result of the shared
     library model.

     I will clarify this issue.  Most SVR4 shared libraries define the
     variable _timezone and define timezone as a weak synonym.  The
     tzset call changes _timezone.  If you write
       extern int timezone;
       int _timezone = 5;
       int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }
     you might expect that, since timezone is a synonym for _timezone,
     the same number will print both times.  However, if the processor
     backend uses a COPY reloc, then actually timezone will be copied
     into your process image, and, since you define _timezone
     yourself, _timezone will not.  Thus timezone and _timezone will
     wind up at different memory locations.  The tzset call will set
     _timezone, leaving timezone unchanged.  */

  if (h->u.weakdef != NULL)
    {
      /* If we get to this point, there is an implicit reference to
	 H->U.WEAKDEF by a regular object file via the weak symbol H.  */
      h->u.weakdef->ref_regular = 1;

      /* Ensure that the backend adjust_dynamic_symbol function sees
	 H->U.WEAKDEF before H by recursively calling ourselves.  */
      if (! _bfd_elf_adjust_dynamic_symbol (h->u.weakdef, eif))
	return FALSE;
    }

  /* If a symbol has no type and no size and does not require a PLT
     entry, then we are probably about to do the wrong thing here: we
     are probably going to create a COPY reloc for an empty object.
     This case can arise when a shared object is built with assembly
     code, and the assembly code fails to set the symbol type.  */
  if (h->size == 0
      && h->type == STT_NOTYPE
      && !h->needs_plt)
    (*_bfd_error_handler)
      (_("warning: type and size of dynamic symbol `%s' are not defined"),
       h->root.root.string);

  dynobj = elf_hash_table (eif->info)->dynobj;
  bed = get_elf_backend_data (dynobj);

  if (! (*bed->elf_backend_adjust_dynamic_symbol) (eif->info, h))
    {
      eif->failed = TRUE;
      return FALSE;
    }

  return TRUE;
}

/* Adjust the dynamic symbol, H, for copy in the dynamic bss section,
   DYNBSS.  */

bfd_boolean
_bfd_elf_adjust_dynamic_copy (struct elf_link_hash_entry *h,
			      asection *dynbss)
{
  unsigned int power_of_two;
  bfd_vma mask;
  asection *sec = h->root.u.def.section;

  /* The section aligment of definition is the maximum alignment
     requirement of symbols defined in the section.  Since we don't
     know the symbol alignment requirement, we start with the
     maximum alignment and check low bits of the symbol address
     for the minimum alignment.  */
  power_of_two = bfd_get_section_alignment (sec->owner, sec);
  mask = ((bfd_vma) 1 << power_of_two) - 1;
  while ((h->root.u.def.value & mask) != 0)
    {
       mask >>= 1;
       --power_of_two;
    }

  if (power_of_two > bfd_get_section_alignment (dynbss->owner,
						dynbss))
    {
      /* Adjust the section alignment if needed.  */
      if (! bfd_set_section_alignment (dynbss->owner, dynbss,
				       power_of_two))
	return FALSE;
    }

  /* We make sure that the symbol will be aligned properly.  */
  dynbss->size = BFD_ALIGN (dynbss->size, mask + 1);

  /* Define the symbol as being at this point in DYNBSS.  */
  h->root.u.def.section = dynbss;
  h->root.u.def.value = dynbss->size;

  /* Increment the size of DYNBSS to make room for the symbol.  */
  dynbss->size += h->size;

  return TRUE;
}

/* Adjust all external symbols pointing into SEC_MERGE sections
   to reflect the object merging within the sections.  */

static bfd_boolean
_bfd_elf_link_sec_merge_syms (struct elf_link_hash_entry *h, void *data)
{
  asection *sec;

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && ((sec = h->root.u.def.section)->flags & SEC_MERGE)
      && sec->sec_info_type == SEC_INFO_TYPE_MERGE)
    {
      bfd *output_bfd = (bfd *) data;

      h->root.u.def.value =
	_bfd_merged_section_offset (output_bfd,
				    &h->root.u.def.section,
				    elf_section_data (sec)->sec_info,
				    h->root.u.def.value);
    }

  return TRUE;
}

/* Returns false if the symbol referred to by H should be considered
   to resolve local to the current module, and true if it should be
   considered to bind dynamically.  */

bfd_boolean
_bfd_elf_dynamic_symbol_p (struct elf_link_hash_entry *h,
			   struct bfd_link_info *info,
			   bfd_boolean not_local_protected)
{
  bfd_boolean binding_stays_local_p;
  const struct elf_backend_data *bed;
  struct elf_link_hash_table *hash_table;

  if (h == NULL)
    return FALSE;

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* If it was forced local, then clearly it's not dynamic.  */
  if (h->dynindx == -1)
    return FALSE;
  if (h->forced_local)
    return FALSE;

  /* Identify the cases where name binding rules say that a
     visible symbol resolves locally.  */
  binding_stays_local_p = info->executable || SYMBOLIC_BIND (info, h);

  switch (ELF_ST_VISIBILITY (h->other))
    {
    case STV_INTERNAL:
    case STV_HIDDEN:
      return FALSE;

    case STV_PROTECTED:
      hash_table = elf_hash_table (info);
      if (!is_elf_hash_table (hash_table))
	return FALSE;

      bed = get_elf_backend_data (hash_table->dynobj);

      /* Proper resolution for function pointer equality may require
	 that these symbols perhaps be resolved dynamically, even though
	 we should be resolving them to the current module.  */
      if (!not_local_protected || !bed->is_function_type (h->type))
	binding_stays_local_p = TRUE;
      break;

    default:
      break;
    }

  /* If it isn't defined locally, then clearly it's dynamic.  */
  if (!h->def_regular && !ELF_COMMON_DEF_P (h))
    return TRUE;

  /* Otherwise, the symbol is dynamic if binding rules don't tell
     us that it remains local.  */
  return !binding_stays_local_p;
}

/* Return true if the symbol referred to by H should be considered
   to resolve local to the current module, and false otherwise.  Differs
   from (the inverse of) _bfd_elf_dynamic_symbol_p in the treatment of
   undefined symbols.  The two functions are virtually identical except
   for the place where forced_local and dynindx == -1 are tested.  If
   either of those tests are true, _bfd_elf_dynamic_symbol_p will say
   the symbol is local, while _bfd_elf_symbol_refs_local_p will say
   the symbol is local only for defined symbols.
   It might seem that _bfd_elf_dynamic_symbol_p could be rewritten as
   !_bfd_elf_symbol_refs_local_p, except that targets differ in their
   treatment of undefined weak symbols.  For those that do not make
   undefined weak symbols dynamic, both functions may return false.  */

bfd_boolean
_bfd_elf_symbol_refs_local_p (struct elf_link_hash_entry *h,
			      struct bfd_link_info *info,
			      bfd_boolean local_protected)
{
  const struct elf_backend_data *bed;
  struct elf_link_hash_table *hash_table;

  /* If it's a local sym, of course we resolve locally.  */
  if (h == NULL)
    return TRUE;

  /* STV_HIDDEN or STV_INTERNAL ones must be local.  */
  if (ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
      || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL)
    return TRUE;

  /* Common symbols that become definitions don't get the DEF_REGULAR
     flag set, so test it first, and don't bail out.  */
  if (ELF_COMMON_DEF_P (h))
    /* Do nothing.  */;
  /* If we don't have a definition in a regular file, then we can't
     resolve locally.  The sym is either undefined or dynamic.  */
  else if (!h->def_regular)
    return FALSE;

  /* Forced local symbols resolve locally.  */
  if (h->forced_local)
    return TRUE;

  /* As do non-dynamic symbols.  */
  if (h->dynindx == -1)
    return TRUE;

  /* At this point, we know the symbol is defined and dynamic.  In an
     executable it must resolve locally, likewise when building symbolic
     shared libraries.  */
  if (info->executable || SYMBOLIC_BIND (info, h))
    return TRUE;

  /* Now deal with defined dynamic symbols in shared libraries.  Ones
     with default visibility might not resolve locally.  */
  if (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
    return FALSE;

  hash_table = elf_hash_table (info);
  if (!is_elf_hash_table (hash_table))
    return TRUE;

  bed = get_elf_backend_data (hash_table->dynobj);

  /* STV_PROTECTED non-function symbols are local.  */
  if (!bed->is_function_type (h->type))
    return TRUE;

  /* Function pointer equality tests may require that STV_PROTECTED
     symbols be treated as dynamic symbols.  If the address of a
     function not defined in an executable is set to that function's
     plt entry in the executable, then the address of the function in
     a shared library must also be the plt entry in the executable.  */
  return local_protected;
}

/* Caches some TLS segment info, and ensures that the TLS segment vma is
   aligned.  Returns the first TLS output section.  */

struct bfd_section *
_bfd_elf_tls_setup (bfd *obfd, struct bfd_link_info *info)
{
  struct bfd_section *sec, *tls;
  unsigned int align = 0;

  for (sec = obfd->sections; sec != NULL; sec = sec->next)
    if ((sec->flags & SEC_THREAD_LOCAL) != 0)
      break;
  tls = sec;

  for (; sec != NULL && (sec->flags & SEC_THREAD_LOCAL) != 0; sec = sec->next)
    if (sec->alignment_power > align)
      align = sec->alignment_power;

  elf_hash_table (info)->tls_sec = tls;

  /* Ensure the alignment of the first section is the largest alignment,
     so that the tls segment starts aligned.  */
  if (tls != NULL)
    tls->alignment_power = align;

  return tls;
}

/* Return TRUE iff this is a non-common, definition of a non-function symbol.  */
static bfd_boolean
is_global_data_symbol_definition (bfd *abfd ATTRIBUTE_UNUSED,
				  Elf_Internal_Sym *sym)
{
  const struct elf_backend_data *bed;

  /* Local symbols do not count, but target specific ones might.  */
  if (ELF_ST_BIND (sym->st_info) != STB_GLOBAL
      && ELF_ST_BIND (sym->st_info) < STB_LOOS)
    return FALSE;

  bed = get_elf_backend_data (abfd);
  /* Function symbols do not count.  */
  if (bed->is_function_type (ELF_ST_TYPE (sym->st_info)))
    return FALSE;

  /* If the section is undefined, then so is the symbol.  */
  if (sym->st_shndx == SHN_UNDEF)
    return FALSE;

  /* If the symbol is defined in the common section, then
     it is a common definition and so does not count.  */
  if (bed->common_definition (sym))
    return FALSE;

  /* If the symbol is in a target specific section then we
     must rely upon the backend to tell us what it is.  */
  if (sym->st_shndx >= SHN_LORESERVE && sym->st_shndx < SHN_ABS)
    /* FIXME - this function is not coded yet:

       return _bfd_is_global_symbol_definition (abfd, sym);

       Instead for now assume that the definition is not global,
       Even if this is wrong, at least the linker will behave
       in the same way that it used to do.  */
    return FALSE;

  return TRUE;
}

/* Search the symbol table of the archive element of the archive ABFD
   whose archive map contains a mention of SYMDEF, and determine if
   the symbol is defined in this element.  */
static bfd_boolean
elf_link_is_defined_archive_symbol (bfd * abfd, carsym * symdef)
{
  Elf_Internal_Shdr * hdr;
  bfd_size_type symcount;
  bfd_size_type extsymcount;
  bfd_size_type extsymoff;
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  bfd_boolean result;

  abfd = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
  if (abfd == NULL)
    return FALSE;

  if (! bfd_check_format (abfd, bfd_object))
    return FALSE;

  /* If we have already included the element containing this symbol in the
     link then we do not need to include it again.  Just claim that any symbol
     it contains is not a definition, so that our caller will not decide to
     (re)include this element.  */
  if (abfd->archive_pass)
    return FALSE;

  /* Select the appropriate symbol table.  */
  if ((abfd->flags & DYNAMIC) == 0 || elf_dynsymtab (abfd) == 0)
    hdr = &elf_tdata (abfd)->symtab_hdr;
  else
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;

  symcount = hdr->sh_size / get_elf_backend_data (abfd)->s->sizeof_sym;

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols.  */
  if (elf_bad_symtab (abfd))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }

  if (extsymcount == 0)
    return FALSE;

  /* Read in the symbol table.  */
  isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
				  NULL, NULL, NULL);
  if (isymbuf == NULL)
    return FALSE;

  /* Scan the symbol table looking for SYMDEF.  */
  result = FALSE;
  for (isym = isymbuf, isymend = isymbuf + extsymcount; isym < isymend; isym++)
    {
      const char *name;

      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	break;

      if (strcmp (name, symdef->name) == 0)
	{
	  result = is_global_data_symbol_definition (abfd, isym);
	  break;
	}
    }

  free (isymbuf);

  return result;
}

/* Add an entry to the .dynamic table.  */

bfd_boolean
_bfd_elf_add_dynamic_entry (struct bfd_link_info *info,
			    bfd_vma tag,
			    bfd_vma val)
{
  struct elf_link_hash_table *hash_table;
  const struct elf_backend_data *bed;
  asection *s;
  bfd_size_type newsize;
  bfd_byte *newcontents;
  Elf_Internal_Dyn dyn;

  hash_table = elf_hash_table (info);
  if (! is_elf_hash_table (hash_table))
    return FALSE;

  bed = get_elf_backend_data (hash_table->dynobj);
  s = bfd_get_linker_section (hash_table->dynobj, ".dynamic");
  BFD_ASSERT (s != NULL);

  newsize = s->size + bed->s->sizeof_dyn;
  newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
  if (newcontents == NULL)
    return FALSE;

  dyn.d_tag = tag;
  dyn.d_un.d_val = val;
  bed->s->swap_dyn_out (hash_table->dynobj, &dyn, newcontents + s->size);

  s->size = newsize;
  s->contents = newcontents;

  return TRUE;
}

/* Add a DT_NEEDED entry for this dynamic object if DO_IT is true,
   otherwise just check whether one already exists.  Returns -1 on error,
   1 if a DT_NEEDED tag already exists, and 0 on success.  */

static int
elf_add_dt_needed_tag (bfd *abfd,
		       struct bfd_link_info *info,
		       const char *soname,
		       bfd_boolean do_it)
{
  struct elf_link_hash_table *hash_table;
  bfd_size_type strindex;

  if (!_bfd_elf_link_create_dynstrtab (abfd, info))
    return -1;

  hash_table = elf_hash_table (info);
  strindex = _bfd_elf_strtab_add (hash_table->dynstr, soname, FALSE);
  if (strindex == (bfd_size_type) -1)
    return -1;

  if (_bfd_elf_strtab_refcount (hash_table->dynstr, strindex) != 1)
    {
      asection *sdyn;
      const struct elf_backend_data *bed;
      bfd_byte *extdyn;

      bed = get_elf_backend_data (hash_table->dynobj);
      sdyn = bfd_get_linker_section (hash_table->dynobj, ".dynamic");
      if (sdyn != NULL)
	for (extdyn = sdyn->contents;
	     extdyn < sdyn->contents + sdyn->size;
	     extdyn += bed->s->sizeof_dyn)
	  {
	    Elf_Internal_Dyn dyn;

	    bed->s->swap_dyn_in (hash_table->dynobj, extdyn, &dyn);
	    if (dyn.d_tag == DT_NEEDED
		&& dyn.d_un.d_val == strindex)
	      {
		_bfd_elf_strtab_delref (hash_table->dynstr, strindex);
		return 1;
	      }
	  }
    }

  if (do_it)
    {
      if (!_bfd_elf_link_create_dynamic_sections (hash_table->dynobj, info))
	return -1;

      if (!_bfd_elf_add_dynamic_entry (info, DT_NEEDED, strindex))
	return -1;
    }
  else
    /* We were just checking for existence of the tag.  */
    _bfd_elf_strtab_delref (hash_table->dynstr, strindex);

  return 0;
}

static bfd_boolean
on_needed_list (const char *soname, struct bfd_link_needed_list *needed)
{
  for (; needed != NULL; needed = needed->next)
    if (strcmp (soname, needed->name) == 0)
      return TRUE;

  return FALSE;
}

/* Sort symbol by value, section, and size.  */
static int
elf_sort_symbol (const void *arg1, const void *arg2)
{
  const struct elf_link_hash_entry *h1;
  const struct elf_link_hash_entry *h2;
  bfd_signed_vma vdiff;

  h1 = *(const struct elf_link_hash_entry **) arg1;
  h2 = *(const struct elf_link_hash_entry **) arg2;
  vdiff = h1->root.u.def.value - h2->root.u.def.value;
  if (vdiff != 0)
    return vdiff > 0 ? 1 : -1;
  else
    {
      long sdiff = h1->root.u.def.section->id - h2->root.u.def.section->id;
      if (sdiff != 0)
	return sdiff > 0 ? 1 : -1;
    }
  vdiff = h1->size - h2->size;
  return vdiff == 0 ? 0 : vdiff > 0 ? 1 : -1;
}

/* This function is used to adjust offsets into .dynstr for
   dynamic symbols.  This is called via elf_link_hash_traverse.  */

static bfd_boolean
elf_adjust_dynstr_offsets (struct elf_link_hash_entry *h, void *data)
{
  struct elf_strtab_hash *dynstr = (struct elf_strtab_hash *) data;

  if (h->dynindx != -1)
    h->dynstr_index = _bfd_elf_strtab_offset (dynstr, h->dynstr_index);
  return TRUE;
}

/* Assign string offsets in .dynstr, update all structures referencing
   them.  */

static bfd_boolean
elf_finalize_dynstr (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_link_hash_table *hash_table = elf_hash_table (info);
  struct elf_link_local_dynamic_entry *entry;
  struct elf_strtab_hash *dynstr = hash_table->dynstr;
  bfd *dynobj = hash_table->dynobj;
  asection *sdyn;
  bfd_size_type size;
  const struct elf_backend_data *bed;
  bfd_byte *extdyn;

  _bfd_elf_strtab_finalize (dynstr);
  size = _bfd_elf_strtab_size (dynstr);

  bed = get_elf_backend_data (dynobj);
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");
  BFD_ASSERT (sdyn != NULL);

  /* Update all .dynamic entries referencing .dynstr strings.  */
  for (extdyn = sdyn->contents;
       extdyn < sdyn->contents + sdyn->size;
       extdyn += bed->s->sizeof_dyn)
    {
      Elf_Internal_Dyn dyn;

      bed->s->swap_dyn_in (dynobj, extdyn, &dyn);
      switch (dyn.d_tag)
	{
	case DT_STRSZ:
	  dyn.d_un.d_val = size;
	  break;
	case DT_NEEDED:
	case DT_SONAME:
	case DT_RPATH:
	case DT_RUNPATH:
	case DT_FILTER:
	case DT_AUXILIARY:
	case DT_AUDIT:
	case DT_DEPAUDIT:
	  dyn.d_un.d_val = _bfd_elf_strtab_offset (dynstr, dyn.d_un.d_val);
	  break;
	default:
	  continue;
	}
      bed->s->swap_dyn_out (dynobj, &dyn, extdyn);
    }

  /* Now update local dynamic symbols.  */
  for (entry = hash_table->dynlocal; entry ; entry = entry->next)
    entry->isym.st_name = _bfd_elf_strtab_offset (dynstr,
						  entry->isym.st_name);

  /* And the rest of dynamic symbols.  */
  elf_link_hash_traverse (hash_table, elf_adjust_dynstr_offsets, dynstr);

  /* Adjust version definitions.  */
  if (elf_tdata (output_bfd)->cverdefs)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verdef def;
      Elf_Internal_Verdaux defaux;

      s = bfd_get_linker_section (dynobj, ".gnu.version_d");
      p = s->contents;
      do
	{
	  _bfd_elf_swap_verdef_in (output_bfd, (Elf_External_Verdef *) p,
				   &def);
	  p += sizeof (Elf_External_Verdef);
	  if (def.vd_aux != sizeof (Elf_External_Verdef))
	    continue;
	  for (i = 0; i < def.vd_cnt; ++i)
	    {
	      _bfd_elf_swap_verdaux_in (output_bfd,
					(Elf_External_Verdaux *) p, &defaux);
	      defaux.vda_name = _bfd_elf_strtab_offset (dynstr,
							defaux.vda_name);
	      _bfd_elf_swap_verdaux_out (output_bfd,
					 &defaux, (Elf_External_Verdaux *) p);
	      p += sizeof (Elf_External_Verdaux);
	    }
	}
      while (def.vd_next);
    }

  /* Adjust version references.  */
  if (elf_tdata (output_bfd)->verref)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verneed need;
      Elf_Internal_Vernaux needaux;

      s = bfd_get_linker_section (dynobj, ".gnu.version_r");
      p = s->contents;
      do
	{
	  _bfd_elf_swap_verneed_in (output_bfd, (Elf_External_Verneed *) p,
				    &need);
	  need.vn_file = _bfd_elf_strtab_offset (dynstr, need.vn_file);
	  _bfd_elf_swap_verneed_out (output_bfd, &need,
				     (Elf_External_Verneed *) p);
	  p += sizeof (Elf_External_Verneed);
	  for (i = 0; i < need.vn_cnt; ++i)
	    {
	      _bfd_elf_swap_vernaux_in (output_bfd,
					(Elf_External_Vernaux *) p, &needaux);
	      needaux.vna_name = _bfd_elf_strtab_offset (dynstr,
							 needaux.vna_name);
	      _bfd_elf_swap_vernaux_out (output_bfd,
					 &needaux,
					 (Elf_External_Vernaux *) p);
	      p += sizeof (Elf_External_Vernaux);
	    }
	}
      while (need.vn_next);
    }

  return TRUE;
}

/* Return TRUE iff relocations for INPUT are compatible with OUTPUT.
   The default is to only match when the INPUT and OUTPUT are exactly
   the same target.  */

bfd_boolean
_bfd_elf_default_relocs_compatible (const bfd_target *input,
				    const bfd_target *output)
{
  return input == output;
}

/* Return TRUE iff relocations for INPUT are compatible with OUTPUT.
   This version is used when different targets for the same architecture
   are virtually identical.  */

bfd_boolean
_bfd_elf_relocs_compatible (const bfd_target *input,
			    const bfd_target *output)
{
  const struct elf_backend_data *obed, *ibed;

  if (input == output)
    return TRUE;

  ibed = xvec_get_elf_backend_data (input);
  obed = xvec_get_elf_backend_data (output);

  if (ibed->arch != obed->arch)
    return FALSE;

  /* If both backends are using this function, deem them compatible.  */
  return ibed->relocs_compatible == obed->relocs_compatible;
}

/* Make a special call to the linker "notice" function to tell it that
   we are about to handle an as-needed lib, or have finished
   processing the lib.  */ 

bfd_boolean
_bfd_elf_notice_as_needed (bfd *ibfd,
			   struct bfd_link_info *info,
			   enum notice_asneeded_action act)
{
  return (*info->callbacks->notice) (info, NULL, ibfd, NULL, act, 0, NULL);
}

/* Add symbols from an ELF object file to the linker hash table.  */

static bfd_boolean
elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
{
  Elf_Internal_Ehdr *ehdr;
  Elf_Internal_Shdr *hdr;
  bfd_size_type symcount;
  bfd_size_type extsymcount;
  bfd_size_type extsymoff;
  struct elf_link_hash_entry **sym_hash;
  bfd_boolean dynamic;
  Elf_External_Versym *extversym = NULL;
  Elf_External_Versym *ever;
  struct elf_link_hash_entry *weaks;
  struct elf_link_hash_entry **nondeflt_vers = NULL;
  bfd_size_type nondeflt_vers_cnt = 0;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  const struct elf_backend_data *bed;
  bfd_boolean add_needed;
  struct elf_link_hash_table *htab;
  bfd_size_type amt;
  void *alloc_mark = NULL;
  struct bfd_hash_entry **old_table = NULL;
  unsigned int old_size = 0;
  unsigned int old_count = 0;
  void *old_tab = NULL;
  void *old_ent;
  struct bfd_link_hash_entry *old_undefs = NULL;
  struct bfd_link_hash_entry *old_undefs_tail = NULL;
  long old_dynsymcount = 0;
  bfd_size_type old_dynstr_size = 0;
  size_t tabsize = 0;
  asection *s;

  htab = elf_hash_table (info);
  bed = get_elf_backend_data (abfd);

  if ((abfd->flags & DYNAMIC) == 0)
    dynamic = FALSE;
  else
    {
      dynamic = TRUE;

      /* You can't use -r against a dynamic object.  Also, there's no
	 hope of using a dynamic object which does not exactly match
	 the format of the output file.  */
      if (info->relocatable
	  || !is_elf_hash_table (htab)
	  || info->output_bfd->xvec != abfd->xvec)
	{
	  if (info->relocatable)
	    bfd_set_error (bfd_error_invalid_operation);
	  else
	    bfd_set_error (bfd_error_wrong_format);
	  goto error_return;
	}
    }

  ehdr = elf_elfheader (abfd);
  if (info->warn_alternate_em
      && bed->elf_machine_code != ehdr->e_machine
      && ((bed->elf_machine_alt1 != 0
	   && ehdr->e_machine == bed->elf_machine_alt1)
	  || (bed->elf_machine_alt2 != 0
	      && ehdr->e_machine == bed->elf_machine_alt2)))
    info->callbacks->einfo
      (_("%P: alternate ELF machine code found (%d) in %B, expecting %d\n"),
       ehdr->e_machine, abfd, bed->elf_machine_code);

  /* As a GNU extension, any input sections which are named
     .gnu.warning.SYMBOL are treated as warning symbols for the given
     symbol.  This differs from .gnu.warning sections, which generate
     warnings when they are included in an output file.  */
  /* PR 12761: Also generate this warning when building shared libraries.  */
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      const char *name;

      name = bfd_get_section_name (abfd, s);
      if (CONST_STRNEQ (name, ".gnu.warning."))
	{
	  char *msg;
	  bfd_size_type sz;

	  name += sizeof ".gnu.warning." - 1;

	  /* If this is a shared object, then look up the symbol
	     in the hash table.  If it is there, and it is already
	     been defined, then we will not be using the entry
	     from this shared object, so we don't need to warn.
	     FIXME: If we see the definition in a regular object
	     later on, we will warn, but we shouldn't.  The only
	     fix is to keep track of what warnings we are supposed
	     to emit, and then handle them all at the end of the
	     link.  */
	  if (dynamic)
	    {
	      struct elf_link_hash_entry *h;

	      h = elf_link_hash_lookup (htab, name, FALSE, FALSE, TRUE);

	      /* FIXME: What about bfd_link_hash_common?  */
	      if (h != NULL
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak))
		continue;
	    }

	  sz = s->size;
	  msg = (char *) bfd_alloc (abfd, sz + 1);
	  if (msg == NULL)
	    goto error_return;

	  if (! bfd_get_section_contents (abfd, s, msg, 0, sz))
	    goto error_return;

	  msg[sz] = '\0';

	  if (! (_bfd_generic_link_add_one_symbol
		 (info, abfd, name, BSF_WARNING, s, 0, msg,
		  FALSE, bed->collect, NULL)))
	    goto error_return;

	  if (!info->relocatable && info->executable)
	    {
	      /* Clobber the section size so that the warning does
		 not get copied into the output file.  */
	      s->size = 0;

	      /* Also set SEC_EXCLUDE, so that symbols defined in
		 the warning section don't get copied to the output.  */
	      s->flags |= SEC_EXCLUDE;
	    }
	}
    }

  add_needed = TRUE;
  if (! dynamic)
    {
      /* If we are creating a shared library, create all the dynamic
	 sections immediately.  We need to attach them to something,
	 so we attach them to this BFD, provided it is the right
	 format.  FIXME: If there are no input BFD's of the same
	 format as the output, we can't make a shared library.  */
      if (info->shared
	  && is_elf_hash_table (htab)
	  && info->output_bfd->xvec == abfd->xvec
	  && !htab->dynamic_sections_created)
	{
	  if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	    goto error_return;
	}
    }
  else if (!is_elf_hash_table (htab))
    goto error_return;
  else
    {
      const char *soname = NULL;
      char *audit = NULL;
      struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;
      int ret;

      /* ld --just-symbols and dynamic objects don't mix very well.
	 ld shouldn't allow it.  */
      if ((s = abfd->sections) != NULL
	  && s->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
	abort ();

      /* If this dynamic lib was specified on the command line with
	 --as-needed in effect, then we don't want to add a DT_NEEDED
	 tag unless the lib is actually used.  Similary for libs brought
	 in by another lib's DT_NEEDED.  When --no-add-needed is used
	 on a dynamic lib, we don't want to add a DT_NEEDED entry for
	 any dynamic library in DT_NEEDED tags in the dynamic lib at
	 all.  */
      add_needed = (elf_dyn_lib_class (abfd)
		    & (DYN_AS_NEEDED | DYN_DT_NEEDED
		       | DYN_NO_NEEDED)) == 0;

      s = bfd_get_section_by_name (abfd, ".dynamic");
      if (s != NULL)
	{
	  bfd_byte *dynbuf;
	  bfd_byte *extdyn;
	  unsigned int elfsec;
	  unsigned long shlink;

	  if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
	    {
error_free_dyn:
	      free (dynbuf);
	      goto error_return;
	    }

	  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
	  if (elfsec == SHN_BAD)
	    goto error_free_dyn;
	  shlink = elf_elfsections (abfd)[elfsec]->sh_link;

	  for (extdyn = dynbuf;
	       extdyn < dynbuf + s->size;
	       extdyn += bed->s->sizeof_dyn)
	    {
	      Elf_Internal_Dyn dyn;

	      bed->s->swap_dyn_in (abfd, extdyn, &dyn);
	      if (dyn.d_tag == DT_SONAME)
		{
		  unsigned int tagv = dyn.d_un.d_val;
		  soname = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (soname == NULL)
		    goto error_free_dyn;
		}
	      if (dyn.d_tag == DT_NEEDED)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = (char *) bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    goto error_free_dyn;
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = &htab->needed; *pn != NULL; pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	      if (dyn.d_tag == DT_RUNPATH)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = (char *) bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    goto error_free_dyn;
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = & runpath;
		       *pn != NULL;
		       pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	      /* Ignore DT_RPATH if we have seen DT_RUNPATH.  */
	      if (!runpath && dyn.d_tag == DT_RPATH)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = (char *) bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    goto error_free_dyn;
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = & rpath;
		       *pn != NULL;
		       pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	      if (dyn.d_tag == DT_AUDIT)
		{
		  unsigned int tagv = dyn.d_un.d_val;
		  audit = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		}
	    }

	  free (dynbuf);
	}

      /* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that
	 frees all more recently bfd_alloc'd blocks as well.  */
      if (runpath)
	rpath = runpath;

      if (rpath)
	{
	  struct bfd_link_needed_list **pn;
	  for (pn = &htab->runpath; *pn != NULL; pn = &(*pn)->next)
	    ;
	  *pn = rpath;
	}

      /* We do not want to include any of the sections in a dynamic
	 object in the output file.  We hack by simply clobbering the
	 list of sections in the BFD.  This could be handled more
	 cleanly by, say, a new section flag; the existing
	 SEC_NEVER_LOAD flag is not the one we want, because that one
	 still implies that the section takes up space in the output
	 file.  */
      bfd_section_list_clear (abfd);

      /* Find the name to use in a DT_NEEDED entry that refers to this
	 object.  If the object has a DT_SONAME entry, we use it.
	 Otherwise, if the generic linker stuck something in
	 elf_dt_name, we use that.  Otherwise, we just use the file
	 name.  */
      if (soname == NULL || *soname == '\0')
	{
	  soname = elf_dt_name (abfd);
	  if (soname == NULL || *soname == '\0')
	    soname = bfd_get_filename (abfd);
	}

      /* Save the SONAME because sometimes the linker emulation code
	 will need to know it.  */
      elf_dt_name (abfd) = soname;

      ret = elf_add_dt_needed_tag (abfd, info, soname, add_needed);
      if (ret < 0)
	goto error_return;

      /* If we have already included this dynamic object in the
	 link, just ignore it.  There is no reason to include a
	 particular dynamic object more than once.  */
      if (ret > 0)
	return TRUE;

      /* Save the DT_AUDIT entry for the linker emulation code. */
      elf_dt_audit (abfd) = audit;
    }

  /* If this is a dynamic object, we always link against the .dynsym
     symbol table, not the .symtab symbol table.  The dynamic linker
     will only see the .dynsym symbol table, so there is no reason to
     look at .symtab for a dynamic object.  */

  if (! dynamic || elf_dynsymtab (abfd) == 0)
    hdr = &elf_tdata (abfd)->symtab_hdr;
  else
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;

  symcount = hdr->sh_size / bed->s->sizeof_sym;

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols at
     this point.  */
  if (elf_bad_symtab (abfd))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }

  sym_hash = elf_sym_hashes (abfd);
  if (extsymcount != 0)
    {
      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	goto error_return;

      if (sym_hash == NULL)
	{
	  /* We store a pointer to the hash table entry for each
	     external symbol.  */
	  amt = extsymcount * sizeof (struct elf_link_hash_entry *);
	  sym_hash = (struct elf_link_hash_entry **) bfd_zalloc (abfd, amt);
	  if (sym_hash == NULL)
	    goto error_free_sym;
	  elf_sym_hashes (abfd) = sym_hash;
	}
    }

  if (dynamic)
    {
      /* Read in any version definitions.  */
      if (!_bfd_elf_slurp_version_tables (abfd,
					  info->default_imported_symver))
	goto error_free_sym;

      /* Read in the symbol versions, but don't bother to convert them
	 to internal format.  */
      if (elf_dynversym (abfd) != 0)
	{
	  Elf_Internal_Shdr *versymhdr;

	  versymhdr = &elf_tdata (abfd)->dynversym_hdr;
	  extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
	  if (extversym == NULL)
	    goto error_free_sym;
	  amt = versymhdr->sh_size;
	  if (bfd_seek (abfd, versymhdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread (extversym, amt, abfd) != amt)
	    goto error_free_vers;
	}
    }

  /* If we are loading an as-needed shared lib, save the symbol table
     state before we start adding symbols.  If the lib turns out
     to be unneeded, restore the state.  */
  if ((elf_dyn_lib_class (abfd) & DYN_AS_NEEDED) != 0)
    {
      unsigned int i;
      size_t entsize;

      for (entsize = 0, i = 0; i < htab->root.table.size; i++)
	{
	  struct bfd_hash_entry *p;
	  struct elf_link_hash_entry *h;

	  for (p = htab->root.table.table[i]; p != NULL; p = p->next)
	    {
	      h = (struct elf_link_hash_entry *) p;
	      entsize += htab->root.table.entsize;
	      if (h->root.type == bfd_link_hash_warning)
		entsize += htab->root.table.entsize;
	    }
	}

      tabsize = htab->root.table.size * sizeof (struct bfd_hash_entry *);
      old_tab = bfd_malloc (tabsize + entsize);
      if (old_tab == NULL)
	goto error_free_vers;

      /* Remember the current objalloc pointer, so that all mem for
	 symbols added can later be reclaimed.  */
      alloc_mark = bfd_hash_allocate (&htab->root.table, 1);
      if (alloc_mark == NULL)
	goto error_free_vers;

      /* Make a special call to the linker "notice" function to
	 tell it that we are about to handle an as-needed lib.  */
      if (!(*bed->notice_as_needed) (abfd, info, notice_as_needed))
	goto error_free_vers;

      /* Clone the symbol table.  Remember some pointers into the
	 symbol table, and dynamic symbol count.  */
      old_ent = (char *) old_tab + tabsize;
      memcpy (old_tab, htab->root.table.table, tabsize);
      old_undefs = htab->root.undefs;
      old_undefs_tail = htab->root.undefs_tail;
      old_table = htab->root.table.table;
      old_size = htab->root.table.size;
      old_count = htab->root.table.count;
      old_dynsymcount = htab->dynsymcount;
      old_dynstr_size = _bfd_elf_strtab_size (htab->dynstr);

      for (i = 0; i < htab->root.table.size; i++)
	{
	  struct bfd_hash_entry *p;
	  struct elf_link_hash_entry *h;

	  for (p = htab->root.table.table[i]; p != NULL; p = p->next)
	    {
	      memcpy (old_ent, p, htab->root.table.entsize);
	      old_ent = (char *) old_ent + htab->root.table.entsize;
	      h = (struct elf_link_hash_entry *) p;
	      if (h->root.type == bfd_link_hash_warning)
		{
		  memcpy (old_ent, h->root.u.i.link, htab->root.table.entsize);
		  old_ent = (char *) old_ent + htab->root.table.entsize;
		}
	    }
	}
    }

  weaks = NULL;
  ever = extversym != NULL ? extversym + extsymoff : NULL;
  for (isym = isymbuf, isymend = isymbuf + extsymcount;
       isym < isymend;
       isym++, sym_hash++, ever = (ever != NULL ? ever + 1 : NULL))
    {
      int bind;
      bfd_vma value;
      asection *sec, *new_sec;
      flagword flags;
      const char *name;
      struct elf_link_hash_entry *h;
      struct elf_link_hash_entry *hi;
      bfd_boolean definition;
      bfd_boolean size_change_ok;
      bfd_boolean type_change_ok;
      bfd_boolean new_weakdef;
      bfd_boolean new_weak;
      bfd_boolean old_weak;
      bfd_boolean override;
      bfd_boolean common;
      unsigned int old_alignment;
      bfd *old_bfd;

      override = FALSE;

      flags = BSF_NO_FLAGS;
      sec = NULL;
      value = isym->st_value;
      common = bed->common_definition (isym);

      bind = ELF_ST_BIND (isym->st_info);
      switch (bind)
	{
	case STB_LOCAL:
	  /* This should be impossible, since ELF requires that all
	     global symbols follow all local symbols, and that sh_info
	     point to the first global symbol.  Unfortunately, Irix 5
	     screws this up.  */
	  continue;

	case STB_GLOBAL:
	  if (isym->st_shndx != SHN_UNDEF && !common)
	    flags = BSF_GLOBAL;
	  break;

	case STB_WEAK:
	  flags = BSF_WEAK;
	  break;

	case STB_GNU_UNIQUE:
	  flags = BSF_GNU_UNIQUE;
	  break;

	default:
	  /* Leave it up to the processor backend.  */
	  break;
	}

      if (isym->st_shndx == SHN_UNDEF)
	sec = bfd_und_section_ptr;
      else if (isym->st_shndx == SHN_ABS)
	sec = bfd_abs_section_ptr;
      else if (isym->st_shndx == SHN_COMMON)
	{
	  sec = bfd_com_section_ptr;
	  /* What ELF calls the size we call the value.  What ELF
	     calls the value we call the alignment.  */
	  value = isym->st_size;
	}
      else
	{
	  sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  if (sec == NULL)
	    sec = bfd_abs_section_ptr;
	  else if (discarded_section (sec))
	    {
	      /* Symbols from discarded section are undefined.  We keep
		 its visibility.  */
	      sec = bfd_und_section_ptr;
	      isym->st_shndx = SHN_UNDEF;
	    }
	  else if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
	    value -= sec->vma;
	}

      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	goto error_free_vers;

      if (isym->st_shndx == SHN_COMMON
	  && (abfd->flags & BFD_PLUGIN) != 0)
	{
	  asection *xc = bfd_get_section_by_name (abfd, "COMMON");

	  if (xc == NULL)
	    {
	      flagword sflags = (SEC_ALLOC | SEC_IS_COMMON | SEC_KEEP
				 | SEC_EXCLUDE);
	      xc = bfd_make_section_with_flags (abfd, "COMMON", sflags);
	      if (xc == NULL)
		goto error_free_vers;
	    }
	  sec = xc;
	}
      else if (isym->st_shndx == SHN_COMMON
	       && ELF_ST_TYPE (isym->st_info) == STT_TLS
	       && !info->relocatable)
	{
	  asection *tcomm = bfd_get_section_by_name (abfd, ".tcommon");

	  if (tcomm == NULL)
	    {
	      flagword sflags = (SEC_ALLOC | SEC_THREAD_LOCAL | SEC_IS_COMMON
				 | SEC_LINKER_CREATED);
	      tcomm = bfd_make_section_with_flags (abfd, ".tcommon", sflags);
	      if (tcomm == NULL)
		goto error_free_vers;
	    }
	  sec = tcomm;
	}
      else if (bed->elf_add_symbol_hook)
	{
	  if (! (*bed->elf_add_symbol_hook) (abfd, info, isym, &name, &flags,
					     &sec, &value))
	    goto error_free_vers;

	  /* The hook function sets the name to NULL if this symbol
	     should be skipped for some reason.  */
	  if (name == NULL)
	    continue;
	}

      /* Sanity check that all possibilities were handled.  */
      if (sec == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  goto error_free_vers;
	}

      /* Silently discard TLS symbols from --just-syms.  There's
	 no way to combine a static TLS block with a new TLS block
	 for this executable.  */
      if (ELF_ST_TYPE (isym->st_info) == STT_TLS
	  && sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
	continue;

      if (bfd_is_und_section (sec)
	  || bfd_is_com_section (sec))
	definition = FALSE;
      else
	definition = TRUE;

      size_change_ok = FALSE;
      type_change_ok = bed->type_change_ok;
      old_weak = FALSE;
      old_alignment = 0;
      old_bfd = NULL;
      new_sec = sec;

      if (is_elf_hash_table (htab))
	{
	  Elf_Internal_Versym iver;
	  unsigned int vernum = 0;
	  bfd_boolean skip;

	  if (ever == NULL)
	    {
	      if (info->default_imported_symver)
		/* Use the default symbol version created earlier.  */
		iver.vs_vers = elf_tdata (abfd)->cverdefs;
	      else
		iver.vs_vers = 0;
	    }
	  else
	    _bfd_elf_swap_versym_in (abfd, ever, &iver);

	  vernum = iver.vs_vers & VERSYM_VERSION;

	  /* If this is a hidden symbol, or if it is not version
	     1, we append the version name to the symbol name.
	     However, we do not modify a non-hidden absolute symbol
	     if it is not a function, because it might be the version
	     symbol itself.  FIXME: What if it isn't?  */
	  if ((iver.vs_vers & VERSYM_HIDDEN) != 0
	      || (vernum > 1
		  && (!bfd_is_abs_section (sec)
		      || bed->is_function_type (ELF_ST_TYPE (isym->st_info)))))
	    {
	      const char *verstr;
	      size_t namelen, verlen, newlen;
	      char *newname, *p;

	      if (isym->st_shndx != SHN_UNDEF)
		{
		  if (vernum > elf_tdata (abfd)->cverdefs)
		    verstr = NULL;
		  else if (vernum > 1)
		    verstr =
		      elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;
		  else
		    verstr = "";

		  if (verstr == NULL)
		    {
		      (*_bfd_error_handler)
			(_("%B: %s: invalid version %u (max %d)"),
			 abfd, name, vernum,
			 elf_tdata (abfd)->cverdefs);
		      bfd_set_error (bfd_error_bad_value);
		      goto error_free_vers;
		    }
		}
	      else
		{
		  /* We cannot simply test for the number of
		     entries in the VERNEED section since the
		     numbers for the needed versions do not start
		     at 0.  */
		  Elf_Internal_Verneed *t;

		  verstr = NULL;
		  for (t = elf_tdata (abfd)->verref;
		       t != NULL;
		       t = t->vn_nextref)
		    {
		      Elf_Internal_Vernaux *a;

		      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
			{
			  if (a->vna_other == vernum)
			    {
			      verstr = a->vna_nodename;
			      break;
			    }
			}
		      if (a != NULL)
			break;
		    }
		  if (verstr == NULL)
		    {
		      (*_bfd_error_handler)
			(_("%B: %s: invalid needed version %d"),
			 abfd, name, vernum);
		      bfd_set_error (bfd_error_bad_value);
		      goto error_free_vers;
		    }
		}

	      namelen = strlen (name);
	      verlen = strlen (verstr);
	      newlen = namelen + verlen + 2;
	      if ((iver.vs_vers & VERSYM_HIDDEN) == 0
		  && isym->st_shndx != SHN_UNDEF)
		++newlen;

	      newname = (char *) bfd_hash_allocate (&htab->root.table, newlen);
	      if (newname == NULL)
		goto error_free_vers;
	      memcpy (newname, name, namelen);
	      p = newname + namelen;
	      *p++ = ELF_VER_CHR;
	      /* If this is a defined non-hidden version symbol,
		 we add another @@ to the name.  This indicates the
		 default version of the symbol.  */
	      if ((iver.vs_vers & VERSYM_HIDDEN) == 0
		  && isym->st_shndx != SHN_UNDEF)
		*p++ = ELF_VER_CHR;
	      memcpy (p, verstr, verlen + 1);

	      name = newname;
	    }

	  if (!_bfd_elf_merge_symbol (abfd, info, name, isym, &sec, &value,
				      sym_hash, &old_bfd, &old_weak,
				      &old_alignment, &skip, &override,
				      &type_change_ok, &size_change_ok))
	    goto error_free_vers;

	  if (skip)
	    continue;

	  if (override)
	    definition = FALSE;

	  h = *sym_hash;
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if (elf_tdata (abfd)->verdef != NULL
	      && vernum > 1
	      && definition)
	    h->verinfo.verdef = &elf_tdata (abfd)->verdef[vernum - 1];
	}

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, name, flags, sec, value, NULL, FALSE, bed->collect,
	      (struct bfd_link_hash_entry **) sym_hash)))
	goto error_free_vers;

      h = *sym_hash;
      /* We need to make sure that indirect symbol dynamic flags are
	 updated.  */
      hi = h;
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      *sym_hash = h;

      new_weak = (flags & BSF_WEAK) != 0;
      new_weakdef = FALSE;
      if (dynamic
	  && definition
	  && new_weak
	  && !bed->is_function_type (ELF_ST_TYPE (isym->st_info))
	  && is_elf_hash_table (htab)
	  && h->u.weakdef == NULL)
	{
	  /* Keep a list of all weak defined non function symbols from
	     a dynamic object, using the weakdef field.  Later in this
	     function we will set the weakdef field to the correct
	     value.  We only put non-function symbols from dynamic
	     objects on this list, because that happens to be the only
	     time we need to know the normal symbol corresponding to a
	     weak symbol, and the information is time consuming to
	     figure out.  If the weakdef field is not already NULL,
	     then this symbol was already defined by some previous
	     dynamic object, and we will be using that previous
	     definition anyhow.  */

	  h->u.weakdef = weaks;
	  weaks = h;
	  new_weakdef = TRUE;
	}

      /* Set the alignment of a common symbol.  */
      if ((common || bfd_is_com_section (sec))
	  && h->root.type == bfd_link_hash_common)
	{
	  unsigned int align;

	  if (common)
	    align = bfd_log2 (isym->st_value);
	  else
	    {
	      /* The new symbol is a common symbol in a shared object.
		 We need to get the alignment from the section.  */
	      align = new_sec->alignment_power;
	    }
	  if (align > old_alignment)
	    h->root.u.c.p->alignment_power = align;
	  else
	    h->root.u.c.p->alignment_power = old_alignment;
	}

      if (is_elf_hash_table (htab))
	{
	  /* Set a flag in the hash table entry indicating the type of
	     reference or definition we just found.  A dynamic symbol
	     is one which is referenced or defined by both a regular
	     object and a shared object.  */
	  bfd_boolean dynsym = FALSE;

	  /* Plugin symbols aren't normal.  Don't set def_regular or
	     ref_regular for them, or make them dynamic.  */
	  if ((abfd->flags & BFD_PLUGIN) != 0)
	    ;
	  else if (! dynamic)
	    {
	      if (! definition)
		{
		  h->ref_regular = 1;
		  if (bind != STB_WEAK)
		    h->ref_regular_nonweak = 1;
		}
	      else
		{
		  h->def_regular = 1;
		  if (h->def_dynamic)
		    {
		      h->def_dynamic = 0;
		      h->ref_dynamic = 1;
		    }
		}

	      /* If the indirect symbol has been forced local, don't
		 make the real symbol dynamic.  */
	      if ((h == hi || !hi->forced_local)
		  && (! info->executable
		      || h->def_dynamic
		      || h->ref_dynamic))
		dynsym = TRUE;
	    }
	  else
	    {
	      if (! definition)
		{
		  h->ref_dynamic = 1;
		  hi->ref_dynamic = 1;
		}
	      else
		{
		  h->def_dynamic = 1;
		  hi->def_dynamic = 1;
		}

	      /* If the indirect symbol has been forced local, don't
		 make the real symbol dynamic.  */
	      if ((h == hi || !hi->forced_local)
		  && (h->def_regular
		      || h->ref_regular
		      || (h->u.weakdef != NULL
			  && ! new_weakdef
			  && h->u.weakdef->dynindx != -1)))
		dynsym = TRUE;
	    }

	  /* Check to see if we need to add an indirect symbol for
	     the default name.  */
	  if (definition
	      || (!override && h->root.type == bfd_link_hash_common))
	    if (!_bfd_elf_add_default_symbol (abfd, info, h, name, isym,
					      sec, value, &old_bfd, &dynsym))
	      goto error_free_vers;

	  /* Check the alignment when a common symbol is involved. This
	     can change when a common symbol is overridden by a normal
	     definition or a common symbol is ignored due to the old
	     normal definition. We need to make sure the maximum
	     alignment is maintained.  */
	  if ((old_alignment || common)
	      && h->root.type != bfd_link_hash_common)
	    {
	      unsigned int common_align;
	      unsigned int normal_align;
	      unsigned int symbol_align;
	      bfd *normal_bfd;
	      bfd *common_bfd;

	      BFD_ASSERT (h->root.type == bfd_link_hash_defined
			  || h->root.type == bfd_link_hash_defweak);

	      symbol_align = ffs (h->root.u.def.value) - 1;
	      if (h->root.u.def.section->owner != NULL
		  && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
		{
		  normal_align = h->root.u.def.section->alignment_power;
		  if (normal_align > symbol_align)
		    normal_align = symbol_align;
		}
	      else
		normal_align = symbol_align;

	      if (old_alignment)
		{
		  common_align = old_alignment;
		  common_bfd = old_bfd;
		  normal_bfd = abfd;
		}
	      else
		{
		  common_align = bfd_log2 (isym->st_value);
		  common_bfd = abfd;
		  normal_bfd = old_bfd;
		}

	      if (normal_align < common_align)
		{
		  /* PR binutils/2735 */
		  if (normal_bfd == NULL)
		    (*_bfd_error_handler)
		      (_("Warning: alignment %u of common symbol `%s' in %B is"
			 " greater than the alignment (%u) of its section %A"),
		       common_bfd, h->root.u.def.section,
		       1 << common_align, name, 1 << normal_align);
		  else
		    (*_bfd_error_handler)
		      (_("Warning: alignment %u of symbol `%s' in %B"
			 " is smaller than %u in %B"),
		       normal_bfd, common_bfd,
		       1 << normal_align, name, 1 << common_align);
		}
	    }

	  /* Remember the symbol size if it isn't undefined.  */
	  if (isym->st_size != 0
	      && isym->st_shndx != SHN_UNDEF
	      && (definition || h->size == 0))
	    {
	      if (h->size != 0
		  && h->size != isym->st_size
		  && ! size_change_ok)
		(*_bfd_error_handler)
		  (_("Warning: size of symbol `%s' changed"
		     " from %lu in %B to %lu in %B"),
		   old_bfd, abfd,
		   name, (unsigned long) h->size,
		   (unsigned long) isym->st_size);

	      h->size = isym->st_size;
	    }

	  /* If this is a common symbol, then we always want H->SIZE
	     to be the size of the common symbol.  The code just above
	     won't fix the size if a common symbol becomes larger.  We
	     don't warn about a size change here, because that is
	     covered by --warn-common.  Allow changes between different
	     function types.  */
	  if (h->root.type == bfd_link_hash_common)
	    h->size = h->root.u.c.size;

	  if (ELF_ST_TYPE (isym->st_info) != STT_NOTYPE
	      && ((definition && !new_weak)
		  || (old_weak && h->root.type == bfd_link_hash_common)
		  || h->type == STT_NOTYPE))
	    {
	      unsigned int type = ELF_ST_TYPE (isym->st_info);

	      /* Turn an IFUNC symbol from a DSO into a normal FUNC
		 symbol.  */
	      if (type == STT_GNU_IFUNC
		  && (abfd->flags & DYNAMIC) != 0)
		type = STT_FUNC;

	      if (h->type != type)
		{
		  if (h->type != STT_NOTYPE && ! type_change_ok)
		    (*_bfd_error_handler)
		      (_("Warning: type of symbol `%s' changed"
			 " from %d to %d in %B"),
		       abfd, name, h->type, type);

		  h->type = type;
		}
	    }

	  /* Merge st_other field.  */
	  elf_merge_st_other (abfd, h, isym, definition, dynamic);

	  /* We don't want to make debug symbol dynamic.  */
	  if (definition && (sec->flags & SEC_DEBUGGING) && !info->relocatable)
	    dynsym = FALSE;

	  /* Nor should we make plugin symbols dynamic.  */
	  if ((abfd->flags & BFD_PLUGIN) != 0)
	    dynsym = FALSE;

	  if (definition)
	    {
	      h->target_internal = isym->st_target_internal;
	      h->unique_global = (flags & BSF_GNU_UNIQUE) != 0;
	    }

	  if (definition && !dynamic)
	    {
	      char *p = strchr (name, ELF_VER_CHR);
	      if (p != NULL && p[1] != ELF_VER_CHR)
		{
		  /* Queue non-default versions so that .symver x, x@@FOO
		     aliases can be checked.  */
		  if (!nondeflt_vers)
		    {
		      amt = ((isymend - isym + 1)
			     * sizeof (struct elf_link_hash_entry *));
		      nondeflt_vers =
                          (struct elf_link_hash_entry **) bfd_malloc (amt);
		      if (!nondeflt_vers)
			goto error_free_vers;
		    }
		  nondeflt_vers[nondeflt_vers_cnt++] = h;
		}
	    }

	  if (dynsym && h->dynindx == -1)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		goto error_free_vers;
	      if (h->u.weakdef != NULL
		  && ! new_weakdef
		  && h->u.weakdef->dynindx == -1)
		{
		  if (!bfd_elf_link_record_dynamic_symbol (info, h->u.weakdef))
		    goto error_free_vers;
		}
	    }
	  else if (dynsym && h->dynindx != -1)
	    /* If the symbol already has a dynamic index, but
	       visibility says it should not be visible, turn it into
	       a local symbol.  */
	    switch (ELF_ST_VISIBILITY (h->other))
	      {
	      case STV_INTERNAL:
	      case STV_HIDDEN:
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
		dynsym = FALSE;
		break;
	      }

	  /* Don't add DT_NEEDED for references from the dummy bfd.  */
	  if (!add_needed
	      && definition
	      && ((dynsym
		   && h->ref_regular_nonweak
		   && (old_bfd == NULL
		       || (old_bfd->flags & BFD_PLUGIN) == 0))
		  || (h->ref_dynamic_nonweak
		      && (elf_dyn_lib_class (abfd) & DYN_AS_NEEDED) != 0
		      && !on_needed_list (elf_dt_name (abfd), htab->needed))))
	    {
	      int ret;
	      const char *soname = elf_dt_name (abfd);

	      /* A symbol from a library loaded via DT_NEEDED of some
		 other library is referenced by a regular object.
		 Add a DT_NEEDED entry for it.  Issue an error if
		 --no-add-needed is used and the reference was not
		 a weak one.  */
	      if (old_bfd != NULL
		  && (elf_dyn_lib_class (abfd) & DYN_NO_NEEDED) != 0)
		{
		  (*_bfd_error_handler)
		    (_("%B: undefined reference to symbol '%s'"),
		     old_bfd, name);
		  bfd_set_error (bfd_error_missing_dso);
		  goto error_free_vers;
		}

	      elf_dyn_lib_class (abfd) = (enum dynamic_lib_link_class)
                  (elf_dyn_lib_class (abfd) & ~DYN_AS_NEEDED);

	      add_needed = TRUE;
	      ret = elf_add_dt_needed_tag (abfd, info, soname, add_needed);
	      if (ret < 0)
		goto error_free_vers;

	      BFD_ASSERT (ret == 0);
	    }
	}
    }

  if (extversym != NULL)
    {
      free (extversym);
      extversym = NULL;
    }

  if (isymbuf != NULL)
    {
      free (isymbuf);
      isymbuf = NULL;
    }

  if ((elf_dyn_lib_class (abfd) & DYN_AS_NEEDED) != 0)
    {
      unsigned int i;

      /* Restore the symbol table.  */
      old_ent = (char *) old_tab + tabsize;
      memset (elf_sym_hashes (abfd), 0,
	      extsymcount * sizeof (struct elf_link_hash_entry *));
      htab->root.table.table = old_table;
      htab->root.table.size = old_size;
      htab->root.table.count = old_count;
      memcpy (htab->root.table.table, old_tab, tabsize);
      htab->root.undefs = old_undefs;
      htab->root.undefs_tail = old_undefs_tail;
      _bfd_elf_strtab_restore_size (htab->dynstr, old_dynstr_size);
      for (i = 0; i < htab->root.table.size; i++)
	{
	  struct bfd_hash_entry *p;
	  struct elf_link_hash_entry *h;
	  bfd_size_type size;
	  unsigned int alignment_power;

	  for (p = htab->root.table.table[i]; p != NULL; p = p->next)
	    {
	      h = (struct elf_link_hash_entry *) p;
	      if (h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	      if (h->dynindx >= old_dynsymcount
		  && h->dynstr_index < old_dynstr_size)
		_bfd_elf_strtab_delref (htab->dynstr, h->dynstr_index);

	      /* Preserve the maximum alignment and size for common
		 symbols even if this dynamic lib isn't on DT_NEEDED
		 since it can still be loaded at run time by another
		 dynamic lib.  */
	      if (h->root.type == bfd_link_hash_common)
		{
		  size = h->root.u.c.size;
		  alignment_power = h->root.u.c.p->alignment_power;
		}
	      else
		{
		  size = 0;
		  alignment_power = 0;
		}
	      memcpy (p, old_ent, htab->root.table.entsize);
	      old_ent = (char *) old_ent + htab->root.table.entsize;
	      h = (struct elf_link_hash_entry *) p;
	      if (h->root.type == bfd_link_hash_warning)
		{
		  memcpy (h->root.u.i.link, old_ent, htab->root.table.entsize);
		  old_ent = (char *) old_ent + htab->root.table.entsize;
		  h = (struct elf_link_hash_entry *) h->root.u.i.link;
		}
	      if (h->root.type == bfd_link_hash_common)
		{
		  if (size > h->root.u.c.size)
		    h->root.u.c.size = size;
		  if (alignment_power > h->root.u.c.p->alignment_power)
		    h->root.u.c.p->alignment_power = alignment_power;
		}
	    }
	}

      /* Make a special call to the linker "notice" function to
	 tell it that symbols added for crefs may need to be removed.  */
      if (!(*bed->notice_as_needed) (abfd, info, notice_not_needed))
	goto error_free_vers;

      free (old_tab);
      objalloc_free_block ((struct objalloc *) htab->root.table.memory,
			   alloc_mark);
      if (nondeflt_vers != NULL)
	free (nondeflt_vers);
      return TRUE;
    }

  if (old_tab != NULL)
    {
      if (!(*bed->notice_as_needed) (abfd, info, notice_needed))
	goto error_free_vers;
      free (old_tab);
      old_tab = NULL;
    }

  /* Now that all the symbols from this input file are created, handle
     .symver foo, foo@@BAR such that any relocs against foo become foo@@BAR.  */
  if (nondeflt_vers != NULL)
    {
      bfd_size_type cnt, symidx;

      for (cnt = 0; cnt < nondeflt_vers_cnt; ++cnt)
	{
	  struct elf_link_hash_entry *h = nondeflt_vers[cnt], *hi;
	  char *shortname, *p;

	  p = strchr (h->root.root.string, ELF_VER_CHR);
	  if (p == NULL
	      || (h->root.type != bfd_link_hash_defined
		  && h->root.type != bfd_link_hash_defweak))
	    continue;

	  amt = p - h->root.root.string;
	  shortname = (char *) bfd_malloc (amt + 1);
	  if (!shortname)
	    goto error_free_vers;
	  memcpy (shortname, h->root.root.string, amt);
	  shortname[amt] = '\0';

	  hi = (struct elf_link_hash_entry *)
	       bfd_link_hash_lookup (&htab->root, shortname,
				     FALSE, FALSE, FALSE);
	  if (hi != NULL
	      && hi->root.type == h->root.type
	      && hi->root.u.def.value == h->root.u.def.value
	      && hi->root.u.def.section == h->root.u.def.section)
	    {
	      (*bed->elf_backend_hide_symbol) (info, hi, TRUE);
	      hi->root.type = bfd_link_hash_indirect;
	      hi->root.u.i.link = (struct bfd_link_hash_entry *) h;
	      (*bed->elf_backend_copy_indirect_symbol) (info, h, hi);
	      sym_hash = elf_sym_hashes (abfd);
	      if (sym_hash)
		for (symidx = 0; symidx < extsymcount; ++symidx)
		  if (sym_hash[symidx] == hi)
		    {
		      sym_hash[symidx] = h;
		      break;
		    }
	    }
	  free (shortname);
	}
      free (nondeflt_vers);
      nondeflt_vers = NULL;
    }

  /* Now set the weakdefs field correctly for all the weak defined
     symbols we found.  The only way to do this is to search all the
     symbols.  Since we only need the information for non functions in
     dynamic objects, that's the only time we actually put anything on
     the list WEAKS.  We need this information so that if a regular
     object refers to a symbol defined weakly in a dynamic object, the
     real symbol in the dynamic object is also put in the dynamic
     symbols; we also must arrange for both symbols to point to the
     same memory location.  We could handle the general case of symbol
     aliasing, but a general symbol alias can only be generated in
     assembler code, handling it correctly would be very time
     consuming, and other ELF linkers don't handle general aliasing
     either.  */
  if (weaks != NULL)
    {
      struct elf_link_hash_entry **hpp;
      struct elf_link_hash_entry **hppend;
      struct elf_link_hash_entry **sorted_sym_hash;
      struct elf_link_hash_entry *h;
      size_t sym_count;

      /* Since we have to search the whole symbol list for each weak
	 defined symbol, search time for N weak defined symbols will be
	 O(N^2). Binary search will cut it down to O(NlogN).  */
      amt = extsymcount * sizeof (struct elf_link_hash_entry *);
      sorted_sym_hash = (struct elf_link_hash_entry **) bfd_malloc (amt);
      if (sorted_sym_hash == NULL)
	goto error_return;
      sym_hash = sorted_sym_hash;
      hpp = elf_sym_hashes (abfd);
      hppend = hpp + extsymcount;
      sym_count = 0;
      for (; hpp < hppend; hpp++)
	{
	  h = *hpp;
	  if (h != NULL
	      && h->root.type == bfd_link_hash_defined
	      && !bed->is_function_type (h->type))
	    {
	      *sym_hash = h;
	      sym_hash++;
	      sym_count++;
	    }
	}

      qsort (sorted_sym_hash, sym_count,
	     sizeof (struct elf_link_hash_entry *),
	     elf_sort_symbol);

      while (weaks != NULL)
	{
	  struct elf_link_hash_entry *hlook;
	  asection *slook;
	  bfd_vma vlook;
	  size_t i, j, idx = 0;

	  hlook = weaks;
	  weaks = hlook->u.weakdef;
	  hlook->u.weakdef = NULL;

	  BFD_ASSERT (hlook->root.type == bfd_link_hash_defined
		      || hlook->root.type == bfd_link_hash_defweak
		      || hlook->root.type == bfd_link_hash_common
		      || hlook->root.type == bfd_link_hash_indirect);
	  slook = hlook->root.u.def.section;
	  vlook = hlook->root.u.def.value;

	  i = 0;
	  j = sym_count;
	  while (i != j)
	    {
	      bfd_signed_vma vdiff;
	      idx = (i + j) / 2;
	      h = sorted_sym_hash[idx];
	      vdiff = vlook - h->root.u.def.value;
	      if (vdiff < 0)
		j = idx;
	      else if (vdiff > 0)
		i = idx + 1;
	      else
		{
		  long sdiff = slook->id - h->root.u.def.section->id;
		  if (sdiff < 0)
		    j = idx;
		  else if (sdiff > 0)
		    i = idx + 1;
		  else
		    break;
		}
	    }

	  /* We didn't find a value/section match.  */
	  if (i == j)
	    continue;

	  /* With multiple aliases, or when the weak symbol is already
	     strongly defined, we have multiple matching symbols and
	     the binary search above may land on any of them.  Step
	     one past the matching symbol(s).  */
	  while (++idx != j)
	    {
	      h = sorted_sym_hash[idx];
	      if (h->root.u.def.section != slook
		  || h->root.u.def.value != vlook)
		break;
	    }

	  /* Now look back over the aliases.  Since we sorted by size
	     as well as value and section, we'll choose the one with
	     the largest size.  */
	  while (idx-- != i)
	    {
	      h = sorted_sym_hash[idx];

	      /* Stop if value or section doesn't match.  */
	      if (h->root.u.def.section != slook
		  || h->root.u.def.value != vlook)
		break;
	      else if (h != hlook)
		{
		  hlook->u.weakdef = h;

		  /* If the weak definition is in the list of dynamic
		     symbols, make sure the real definition is put
		     there as well.  */
		  if (hlook->dynindx != -1 && h->dynindx == -1)
		    {
		      if (! bfd_elf_link_record_dynamic_symbol (info, h))
			{
			err_free_sym_hash:
			  free (sorted_sym_hash);
			  goto error_return;
			}
		    }

		  /* If the real definition is in the list of dynamic
		     symbols, make sure the weak definition is put
		     there as well.  If we don't do this, then the
		     dynamic loader might not merge the entries for the
		     real definition and the weak definition.  */
		  if (h->dynindx != -1 && hlook->dynindx == -1)
		    {
		      if (! bfd_elf_link_record_dynamic_symbol (info, hlook))
			goto err_free_sym_hash;
		    }
		  break;
		}
	    }
	}

      free (sorted_sym_hash);
    }

  if (bed->check_directives
      && !(*bed->check_directives) (abfd, info))
    return FALSE;

  /* If this object is the same format as the output object, and it is
     not a shared library, then let the backend look through the
     relocs.

     This is required to build global offset table entries and to
     arrange for dynamic relocs.  It is not required for the
     particular common case of linking non PIC code, even when linking
     against shared libraries, but unfortunately there is no way of
     knowing whether an object file has been compiled PIC or not.
     Looking through the relocs is not particularly time consuming.
     The problem is that we must either (1) keep the relocs in memory,
     which causes the linker to require additional runtime memory or
     (2) read the relocs twice from the input file, which wastes time.
     This would be a good case for using mmap.

     I have no idea how to handle linking PIC code into a file of a
     different format.  It probably can't be done.  */
  if (! dynamic
      && is_elf_hash_table (htab)
      && bed->check_relocs != NULL
      && elf_object_id (abfd) == elf_hash_table_id (htab)
      && (*bed->relocs_compatible) (abfd->xvec, info->output_bfd->xvec))
    {
      asection *o;

      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  Elf_Internal_Rela *internal_relocs;
	  bfd_boolean ok;

	  if ((o->flags & SEC_RELOC) == 0
	      || o->reloc_count == 0
	      || ((info->strip == strip_all || info->strip == strip_debugger)
		  && (o->flags & SEC_DEBUGGING) != 0)
	      || bfd_is_abs_section (o->output_section))
	    continue;

	  internal_relocs = _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
						       info->keep_memory);
	  if (internal_relocs == NULL)
	    goto error_return;

	  ok = (*bed->check_relocs) (abfd, info, o, internal_relocs);

	  if (elf_section_data (o)->relocs != internal_relocs)
	    free (internal_relocs);

	  if (! ok)
	    goto error_return;
	}
    }

  /* If this is a non-traditional link, try to optimize the handling
     of the .stab/.stabstr sections.  */
  if (! dynamic
      && ! info->traditional_format
      && is_elf_hash_table (htab)
      && (info->strip != strip_all && info->strip != strip_debugger))
    {
      asection *stabstr;

      stabstr = bfd_get_section_by_name (abfd, ".stabstr");
      if (stabstr != NULL)
	{
	  bfd_size_type string_offset = 0;
	  asection *stab;

	  for (stab = abfd->sections; stab; stab = stab->next)
	    if (CONST_STRNEQ (stab->name, ".stab")
		&& (!stab->name[5] ||
		    (stab->name[5] == '.' && ISDIGIT (stab->name[6])))
		&& (stab->flags & SEC_MERGE) == 0
		&& !bfd_is_abs_section (stab->output_section))
	      {
		struct bfd_elf_section_data *secdata;

		secdata = elf_section_data (stab);
		if (! _bfd_link_section_stabs (abfd, &htab->stab_info, stab,
					       stabstr, &secdata->sec_info,
					       &string_offset))
		  goto error_return;
		if (secdata->sec_info)
		  stab->sec_info_type = SEC_INFO_TYPE_STABS;
	    }
	}
    }

  if (is_elf_hash_table (htab) && add_needed)
    {
      /* Add this bfd to the loaded list.  */
      struct elf_link_loaded_list *n;

      n = (struct elf_link_loaded_list *)
          bfd_alloc (abfd, sizeof (struct elf_link_loaded_list));
      if (n == NULL)
	goto error_return;
      n->abfd = abfd;
      n->next = htab->loaded;
      htab->loaded = n;
    }

  return TRUE;

 error_free_vers:
  if (old_tab != NULL)
    free (old_tab);
  if (nondeflt_vers != NULL)
    free (nondeflt_vers);
  if (extversym != NULL)
    free (extversym);
 error_free_sym:
  if (isymbuf != NULL)
    free (isymbuf);
 error_return:
  return FALSE;
}

/* Return the linker hash table entry of a symbol that might be
   satisfied by an archive symbol.  Return -1 on error.  */

struct elf_link_hash_entry *
_bfd_elf_archive_symbol_lookup (bfd *abfd,
				struct bfd_link_info *info,
				const char *name)
{
  struct elf_link_hash_entry *h;
  char *p, *copy;
  size_t len, first;

  h = elf_link_hash_lookup (elf_hash_table (info), name, FALSE, FALSE, TRUE);
  if (h != NULL)
    return h;

  /* If this is a default version (the name contains @@@@), look up the
     symbol again with only one `@@' as well as without the version.
     The effect is that references to the symbol with and without the
     version will be matched by the default symbol in the archive.  */

  p = strchr (name, ELF_VER_CHR);
  if (p == NULL || p[1] != ELF_VER_CHR)
    return h;

  /* First check with only one `@@'.  */
  len = strlen (name);
  copy = (char *) bfd_alloc (abfd, len);
  if (copy == NULL)
    return (struct elf_link_hash_entry *) 0 - 1;

  first = p - name + 1;
  memcpy (copy, name, first);
  memcpy (copy + first, name + first + 1, len - first);

  h = elf_link_hash_lookup (elf_hash_table (info), copy, FALSE, FALSE, TRUE);
  if (h == NULL)
    {
      /* We also need to check references to the symbol without the
	 version.  */
      copy[first - 1] = '\0';
      h = elf_link_hash_lookup (elf_hash_table (info), copy,
				FALSE, FALSE, TRUE);
    }

  bfd_release (abfd, copy);
  return h;
}

/* Add symbols from an ELF archive file to the linker hash table.  We
   don't use _bfd_generic_link_add_archive_symbols because of a
   problem which arises on UnixWare.  The UnixWare libc.so is an
   archive which includes an entry libc.so.1 which defines a bunch of
   symbols.  The libc.so archive also includes a number of other
   object files, which also define symbols, some of which are the same
   as those defined in libc.so.1.  Correct linking requires that we
   consider each object file in turn, and include it if it defines any
   symbols we need.  _bfd_generic_link_add_archive_symbols does not do
   this; it looks through the list of undefined symbols, and includes
   any object file which defines them.  When this algorithm is used on
   UnixWare, it winds up pulling in libc.so.1 early and defining a
   bunch of symbols.  This means that some of the other objects in the
   archive are not included in the link, which is incorrect since they
   precede libc.so.1 in the archive.

   Fortunately, ELF archive handling is simpler than that done by
   _bfd_generic_link_add_archive_symbols, which has to allow for a.out
   oddities.  In ELF, if we find a symbol in the archive map, and the
   symbol is currently undefined, we know that we must pull in that
   object file.

   Unfortunately, we do have to make multiple passes over the symbol
   table until nothing further is resolved.  */

static bfd_boolean
elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
{
  symindex c;
  bfd_boolean *defined = NULL;
  bfd_boolean *included = NULL;
  carsym *symdefs;
  bfd_boolean loop;
  bfd_size_type amt;
  const struct elf_backend_data *bed;
  struct elf_link_hash_entry * (*archive_symbol_lookup)
    (bfd *, struct bfd_link_info *, const char *);

  if (! bfd_has_map (abfd))
    {
      /* An empty archive is a special case.  */
      if (bfd_openr_next_archived_file (abfd, NULL) == NULL)
	return TRUE;
      bfd_set_error (bfd_error_no_armap);
      return FALSE;
    }

  /* Keep track of all symbols we know to be already defined, and all
     files we know to be already included.  This is to speed up the
     second and subsequent passes.  */
  c = bfd_ardata (abfd)->symdef_count;
  if (c == 0)
    return TRUE;
  amt = c;
  amt *= sizeof (bfd_boolean);
  defined = (bfd_boolean *) bfd_zmalloc (amt);
  included = (bfd_boolean *) bfd_zmalloc (amt);
  if (defined == NULL || included == NULL)
    goto error_return;

  symdefs = bfd_ardata (abfd)->symdefs;
  bed = get_elf_backend_data (abfd);
  archive_symbol_lookup = bed->elf_backend_archive_symbol_lookup;

  do
    {
      file_ptr last;
      symindex i;
      carsym *symdef;
      carsym *symdefend;

      loop = FALSE;
      last = -1;

      symdef = symdefs;
      symdefend = symdef + c;
      for (i = 0; symdef < symdefend; symdef++, i++)
	{
	  struct elf_link_hash_entry *h;
	  bfd *element;
	  struct bfd_link_hash_entry *undefs_tail;
	  symindex mark;

	  if (defined[i] || included[i])
	    continue;
	  if (symdef->file_offset == last)
	    {
	      included[i] = TRUE;
	      continue;
	    }

	  h = archive_symbol_lookup (abfd, info, symdef->name);
	  if (h == (struct elf_link_hash_entry *) 0 - 1)
	    goto error_return;

	  if (h == NULL)
	    continue;

	  if (h->root.type == bfd_link_hash_common)
	    {
	      /* We currently have a common symbol.  The archive map contains
		 a reference to this symbol, so we may want to include it.  We
		 only want to include it however, if this archive element
		 contains a definition of the symbol, not just another common
		 declaration of it.

		 Unfortunately some archivers (including GNU ar) will put
		 declarations of common symbols into their archive maps, as
		 well as real definitions, so we cannot just go by the archive
		 map alone.  Instead we must read in the element's symbol
		 table and check that to see what kind of symbol definition
		 this is.  */
	      if (! elf_link_is_defined_archive_symbol (abfd, symdef))
		continue;
	    }
	  else if (h->root.type != bfd_link_hash_undefined)
	    {
	      if (h->root.type != bfd_link_hash_undefweak)
		defined[i] = TRUE;
	      continue;
	    }

	  /* We need to include this archive member.  */
	  element = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
	  if (element == NULL)
	    goto error_return;

	  if (! bfd_check_format (element, bfd_object))
	    goto error_return;

	  /* Doublecheck that we have not included this object
	     already--it should be impossible, but there may be
	     something wrong with the archive.  */
	  if (element->archive_pass != 0)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }
	  element->archive_pass = 1;

	  undefs_tail = info->hash->undefs_tail;

	  if (!(*info->callbacks
		->add_archive_element) (info, element, symdef->name, &element))
	    goto error_return;
	  if (!bfd_link_add_symbols (element, info))
	    goto error_return;

	  /* If there are any new undefined symbols, we need to make
	     another pass through the archive in order to see whether
	     they can be defined.  FIXME: This isn't perfect, because
	     common symbols wind up on undefs_tail and because an
	     undefined symbol which is defined later on in this pass
	     does not require another pass.  This isn't a bug, but it
	     does make the code less efficient than it could be.  */
	  if (undefs_tail != info->hash->undefs_tail)
	    loop = TRUE;

	  /* Look backward to mark all symbols from this object file
	     which we have already seen in this pass.  */
	  mark = i;
	  do
	    {
	      included[mark] = TRUE;
	      if (mark == 0)
		break;
	      --mark;
	    }
	  while (symdefs[mark].file_offset == symdef->file_offset);

	  /* We mark subsequent symbols from this object file as we go
	     on through the loop.  */
	  last = symdef->file_offset;
	}
    }
  while (loop);

  free (defined);
  free (included);

  return TRUE;

 error_return:
  if (defined != NULL)
    free (defined);
  if (included != NULL)
    free (included);
  return FALSE;
}

/* Given an ELF BFD, add symbols to the global hash table as
   appropriate.  */

bfd_boolean
bfd_elf_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return elf_link_add_object_symbols (abfd, info);
    case bfd_archive:
      return elf_link_add_archive_symbols (abfd, info);
    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}

struct hash_codes_info
{
  unsigned long *hashcodes;
  bfd_boolean error;
};

/* This function will be called though elf_link_hash_traverse to store
   all hash value of the exported symbols in an array.  */

static bfd_boolean
elf_collect_hash_codes (struct elf_link_hash_entry *h, void *data)
{
  struct hash_codes_info *inf = (struct hash_codes_info *) data;
  const char *name;
  char *p;
  unsigned long ha;
  char *alc = NULL;

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->dynindx == -1)
    return TRUE;

  name = h->root.root.string;
  p = strchr (name, ELF_VER_CHR);
  if (p != NULL)
    {
      alc = (char *) bfd_malloc (p - name + 1);
      if (alc == NULL)
	{
	  inf->error = TRUE;
	  return FALSE;
	}
      memcpy (alc, name, p - name);
      alc[p - name] = '\0';
      name = alc;
    }

  /* Compute the hash value.  */
  ha = bfd_elf_hash (name);

  /* Store the found hash value in the array given as the argument.  */
  *(inf->hashcodes)++ = ha;

  /* And store it in the struct so that we can put it in the hash table
     later.  */
  h->u.elf_hash_value = ha;

  if (alc != NULL)
    free (alc);

  return TRUE;
}

struct collect_gnu_hash_codes
{
  bfd *output_bfd;
  const struct elf_backend_data *bed;
  unsigned long int nsyms;
  unsigned long int maskbits;
  unsigned long int *hashcodes;
  unsigned long int *hashval;
  unsigned long int *indx;
  unsigned long int *counts;
  bfd_vma *bitmask;
  bfd_byte *contents;
  long int min_dynindx;
  unsigned long int bucketcount;
  unsigned long int symindx;
  long int local_indx;
  long int shift1, shift2;
  unsigned long int mask;
  bfd_boolean error;
};

/* This function will be called though elf_link_hash_traverse to store
   all hash value of the exported symbols in an array.  */

static bfd_boolean
elf_collect_gnu_hash_codes (struct elf_link_hash_entry *h, void *data)
{
  struct collect_gnu_hash_codes *s = (struct collect_gnu_hash_codes *) data;
  const char *name;
  char *p;
  unsigned long ha;
  char *alc = NULL;

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->dynindx == -1)
    return TRUE;

  /* Ignore also local symbols and undefined symbols.  */
  if (! (*s->bed->elf_hash_symbol) (h))
    return TRUE;

  name = h->root.root.string;
  p = strchr (name, ELF_VER_CHR);
  if (p != NULL)
    {
      alc = (char *) bfd_malloc (p - name + 1);
      if (alc == NULL)
	{
	  s->error = TRUE;
	  return FALSE;
	}
      memcpy (alc, name, p - name);
      alc[p - name] = '\0';
      name = alc;
    }

  /* Compute the hash value.  */
  ha = bfd_elf_gnu_hash (name);

  /* Store the found hash value in the array for compute_bucket_count,
     and also for .dynsym reordering purposes.  */
  s->hashcodes[s->nsyms] = ha;
  s->hashval[h->dynindx] = ha;
  ++s->nsyms;
  if (s->min_dynindx < 0 || s->min_dynindx > h->dynindx)
    s->min_dynindx = h->dynindx;

  if (alc != NULL)
    free (alc);

  return TRUE;
}

/* This function will be called though elf_link_hash_traverse to do
   final dynaminc symbol renumbering.  */

static bfd_boolean
elf_renumber_gnu_hash_syms (struct elf_link_hash_entry *h, void *data)
{
  struct collect_gnu_hash_codes *s = (struct collect_gnu_hash_codes *) data;
  unsigned long int bucket;
  unsigned long int val;

  /* Ignore indirect symbols.  */
  if (h->dynindx == -1)
    return TRUE;

  /* Ignore also local symbols and undefined symbols.  */
  if (! (*s->bed->elf_hash_symbol) (h))
    {
      if (h->dynindx >= s->min_dynindx)
	h->dynindx = s->local_indx++;
      return TRUE;
    }

  bucket = s->hashval[h->dynindx] % s->bucketcount;
  val = (s->hashval[h->dynindx] >> s->shift1)
	& ((s->maskbits >> s->shift1) - 1);
  s->bitmask[val] |= ((bfd_vma) 1) << (s->hashval[h->dynindx] & s->mask);
  s->bitmask[val]
    |= ((bfd_vma) 1) << ((s->hashval[h->dynindx] >> s->shift2) & s->mask);
  val = s->hashval[h->dynindx] & ~(unsigned long int) 1;
  if (s->counts[bucket] == 1)
    /* Last element terminates the chain.  */
    val |= 1;
  bfd_put_32 (s->output_bfd, val,
	      s->contents + (s->indx[bucket] - s->symindx) * 4);
  --s->counts[bucket];
  h->dynindx = s->indx[bucket]++;
  return TRUE;
}

/* Return TRUE if symbol should be hashed in the `.gnu.hash' section.  */

bfd_boolean
_bfd_elf_hash_symbol (struct elf_link_hash_entry *h)
{
  return !(h->forced_local
	   || h->root.type == bfd_link_hash_undefined
	   || h->root.type == bfd_link_hash_undefweak
	   || ((h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak)
	       && h->root.u.def.section->output_section == NULL));
}

/* Array used to determine the number of hash table buckets to use
   based on the number of symbols there are.  If there are fewer than
   3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,
   fewer than 37 we use 17 buckets, and so forth.  We never use more
   than 32771 buckets.  */

static const size_t elf_buckets[] =
{
  1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209,
  16411, 32771, 0
};

/* Compute bucket count for hashing table.  We do not use a static set
   of possible tables sizes anymore.  Instead we determine for all
   possible reasonable sizes of the table the outcome (i.e., the
   number of collisions etc) and choose the best solution.  The
   weighting functions are not too simple to allow the table to grow
   without bounds.  Instead one of the weighting factors is the size.
   Therefore the result is always a good payoff between few collisions
   (= short chain lengths) and table size.  */
static size_t
compute_bucket_count (struct bfd_link_info *info ATTRIBUTE_UNUSED,
		      unsigned long int *hashcodes ATTRIBUTE_UNUSED,
		      unsigned long int nsyms,
		      int gnu_hash)
{
  size_t best_size = 0;
  unsigned long int i;

  /* We have a problem here.  The following code to optimize the table
     size requires an integer type with more the 32 bits.  If
     BFD_HOST_U_64_BIT is set we know about such a type.  */
#ifdef BFD_HOST_U_64_BIT
  if (info->optimize)
    {
      size_t minsize;
      size_t maxsize;
      BFD_HOST_U_64_BIT best_chlen = ~((BFD_HOST_U_64_BIT) 0);
      bfd *dynobj = elf_hash_table (info)->dynobj;
      size_t dynsymcount = elf_hash_table (info)->dynsymcount;
      const struct elf_backend_data *bed = get_elf_backend_data (dynobj);
      unsigned long int *counts;
      bfd_size_type amt;
      unsigned int no_improvement_count = 0;

      /* Possible optimization parameters: if we have NSYMS symbols we say
	 that the hashing table must at least have NSYMS/4 and at most
	 2*NSYMS buckets.  */
      minsize = nsyms / 4;
      if (minsize == 0)
	minsize = 1;
      best_size = maxsize = nsyms * 2;
      if (gnu_hash)
	{
	  if (minsize < 2)
	    minsize = 2;
	  if ((best_size & 31) == 0)
	    ++best_size;
	}

      /* Create array where we count the collisions in.  We must use bfd_malloc
	 since the size could be large.  */
      amt = maxsize;
      amt *= sizeof (unsigned long int);
      counts = (unsigned long int *) bfd_malloc (amt);
      if (counts == NULL)
	return 0;

      /* Compute the "optimal" size for the hash table.  The criteria is a
	 minimal chain length.  The minor criteria is (of course) the size
	 of the table.  */
      for (i = minsize; i < maxsize; ++i)
	{
	  /* Walk through the array of hashcodes and count the collisions.  */
	  BFD_HOST_U_64_BIT max;
	  unsigned long int j;
	  unsigned long int fact;

	  if (gnu_hash && (i & 31) == 0)
	    continue;

	  memset (counts, '\0', i * sizeof (unsigned long int));

	  /* Determine how often each hash bucket is used.  */
	  for (j = 0; j < nsyms; ++j)
	    ++counts[hashcodes[j] % i];

	  /* For the weight function we need some information about the
	     pagesize on the target.  This is information need not be 100%
	     accurate.  Since this information is not available (so far) we
	     define it here to a reasonable default value.  If it is crucial
	     to have a better value some day simply define this value.  */
# ifndef BFD_TARGET_PAGESIZE
#  define BFD_TARGET_PAGESIZE	(4096)
# endif

	  /* We in any case need 2 + DYNSYMCOUNT entries for the size values
	     and the chains.  */
	  max = (2 + dynsymcount) * bed->s->sizeof_hash_entry;

# if 1
	  /* Variant 1: optimize for short chains.  We add the squares
	     of all the chain lengths (which favors many small chain
	     over a few long chains).  */
	  for (j = 0; j < i; ++j)
	    max += counts[j] * counts[j];

	  /* This adds penalties for the overall size of the table.  */
	  fact = i / (BFD_TARGET_PAGESIZE / bed->s->sizeof_hash_entry) + 1;
	  max *= fact * fact;
# else
	  /* Variant 2: Optimize a lot more for small table.  Here we
	     also add squares of the size but we also add penalties for
	     empty slots (the +1 term).  */
	  for (j = 0; j < i; ++j)
	    max += (1 + counts[j]) * (1 + counts[j]);

	  /* The overall size of the table is considered, but not as
	     strong as in variant 1, where it is squared.  */
	  fact = i / (BFD_TARGET_PAGESIZE / bed->s->sizeof_hash_entry) + 1;
	  max *= fact;
# endif

	  /* Compare with current best results.  */
	  if (max < best_chlen)
	    {
	      best_chlen = max;
	      best_size = i;
              no_improvement_count = 0;
	    }
	  /* PR 11843: Avoid futile long searches for the best bucket size
	     when there are a large number of symbols.  */
	  else if (++no_improvement_count == 100)
	    break;
	}

      free (counts);
    }
  else
#endif /* defined (BFD_HOST_U_64_BIT) */
    {
      /* This is the fallback solution if no 64bit type is available or if we
	 are not supposed to spend much time on optimizations.  We select the
	 bucket count using a fixed set of numbers.  */
      for (i = 0; elf_buckets[i] != 0; i++)
	{
	  best_size = elf_buckets[i];
	  if (nsyms < elf_buckets[i + 1])
	    break;
	}
      if (gnu_hash && best_size < 2)
	best_size = 2;
    }

  return best_size;
}

/* Size any SHT_GROUP section for ld -r.  */

bfd_boolean
_bfd_elf_size_group_sections (struct bfd_link_info *info)
{
  bfd *ibfd;

  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour
	&& !_bfd_elf_fixup_group_sections (ibfd, bfd_abs_section_ptr))
      return FALSE;
  return TRUE;
}

/* Set a default stack segment size.  The value in INFO wins.  If it
   is unset, LEGACY_SYMBOL's value is used, and if that symbol is
   undefined it is initialized.  */

bfd_boolean
bfd_elf_stack_segment_size (bfd *output_bfd,
			    struct bfd_link_info *info,
			    const char *legacy_symbol,
			    bfd_vma default_size)
{
  struct elf_link_hash_entry *h = NULL;

  /* Look for legacy symbol.  */
  if (legacy_symbol)
    h = elf_link_hash_lookup (elf_hash_table (info), legacy_symbol,
			      FALSE, FALSE, FALSE);
  if (h && (h->root.type == bfd_link_hash_defined
	    || h->root.type == bfd_link_hash_defweak)
      && h->def_regular
      && (h->type == STT_NOTYPE || h->type == STT_OBJECT))
    {
      /* The symbol has no type if specified on the command line.  */
      h->type = STT_OBJECT;
      if (info->stacksize)
	(*_bfd_error_handler) (_("%B: stack size specified and %s set"),
			       output_bfd, legacy_symbol);
      else if (h->root.u.def.section != bfd_abs_section_ptr)
	(*_bfd_error_handler) (_("%B: %s not absolute"),
			       output_bfd, legacy_symbol);
      else
	info->stacksize = h->root.u.def.value;
    }

  if (!info->stacksize)
    /* If the user didn't set a size, or explicitly inhibit the
       size, set it now.  */
    info->stacksize = default_size;

  /* Provide the legacy symbol, if it is referenced.  */
  if (h && (h->root.type == bfd_link_hash_undefined
	    || h->root.type == bfd_link_hash_undefweak))
    {
      struct bfd_link_hash_entry *bh = NULL;

      if (!(_bfd_generic_link_add_one_symbol
	    (info, output_bfd, legacy_symbol,
	     BSF_GLOBAL, bfd_abs_section_ptr,
	     info->stacksize >= 0 ? info->stacksize : 0,
	     NULL, FALSE, get_elf_backend_data (output_bfd)->collect, &bh)))
	return FALSE;

      h = (struct elf_link_hash_entry *) bh;
      h->def_regular = 1;
      h->type = STT_OBJECT;
    }

  return TRUE;
}

/* Set up the sizes and contents of the ELF dynamic sections.  This is
   called by the ELF linker emulation before_allocation routine.  We
   must set the sizes of the sections before the linker sets the
   addresses of the various sections.  */

bfd_boolean
bfd_elf_size_dynamic_sections (bfd *output_bfd,
			       const char *soname,
			       const char *rpath,
			       const char *filter_shlib,
			       const char *audit,
			       const char *depaudit,
			       const char * const *auxiliary_filters,
			       struct bfd_link_info *info,
			       asection **sinterpptr)
{
  bfd_size_type soname_indx;
  bfd *dynobj;
  const struct elf_backend_data *bed;
  struct elf_info_failed asvinfo;

  *sinterpptr = NULL;

  soname_indx = (bfd_size_type) -1;

  if (!is_elf_hash_table (info->hash))
    return TRUE;

  bed = get_elf_backend_data (output_bfd);

  /* Any syms created from now on start with -1 in
     got.refcount/offset and plt.refcount/offset.  */
  elf_hash_table (info)->init_got_refcount
    = elf_hash_table (info)->init_got_offset;
  elf_hash_table (info)->init_plt_refcount
    = elf_hash_table (info)->init_plt_offset;

  if (info->relocatable
      && !_bfd_elf_size_group_sections (info))
    return FALSE;

  /* The backend may have to create some sections regardless of whether
     we're dynamic or not.  */
  if (bed->elf_backend_always_size_sections
      && ! (*bed->elf_backend_always_size_sections) (output_bfd, info))
    return FALSE;

  /* Determine any GNU_STACK segment requirements, after the backend
     has had a chance to set a default segment size.  */
  if (info->execstack)
    elf_stack_flags (output_bfd) = PF_R | PF_W | PF_X;
  else if (info->noexecstack)
    elf_stack_flags (output_bfd) = PF_R | PF_W;
  else
    {
      bfd *inputobj;
      asection *notesec = NULL;
      int exec = 0;

      for (inputobj = info->input_bfds;
	   inputobj;
	   inputobj = inputobj->link_next)
	{
	  asection *s;

	  if (inputobj->flags
	      & (DYNAMIC | EXEC_P | BFD_PLUGIN | BFD_LINKER_CREATED))
	    continue;
	  s = bfd_get_section_by_name (inputobj, ".note.GNU-stack");
	  if (s)
	    {
	      if (s->flags & SEC_CODE)
		exec = PF_X;
	      notesec = s;
	    }
	  else if (bed->default_execstack)
	    exec = PF_X;
	}
      if (notesec || info->stacksize > 0)
	elf_stack_flags (output_bfd) = PF_R | PF_W | exec;
      if (notesec && exec && info->relocatable
	  && notesec->output_section != bfd_abs_section_ptr)
	notesec->output_section->flags |= SEC_CODE;
    }

  dynobj = elf_hash_table (info)->dynobj;

  if (dynobj != NULL && elf_hash_table (info)->dynamic_sections_created)
    {
      struct elf_info_failed eif;
      struct elf_link_hash_entry *h;
      asection *dynstr;
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;
      asection *s;
      bfd_boolean all_defined;

      *sinterpptr = bfd_get_linker_section (dynobj, ".interp");
      BFD_ASSERT (*sinterpptr != NULL || !info->executable);

      if (soname != NULL)
	{
	  soname_indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					     soname, TRUE);
	  if (soname_indx == (bfd_size_type) -1
	      || !_bfd_elf_add_dynamic_entry (info, DT_SONAME, soname_indx))
	    return FALSE;
	}

      if (info->symbolic)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_SYMBOLIC, 0))
	    return FALSE;
	  info->flags |= DF_SYMBOLIC;
	}

      if (rpath != NULL)
	{
	  bfd_size_type indx;
	  bfd_vma tag;

	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, rpath,
				      TRUE);
	  if (indx == (bfd_size_type) -1)
	    return FALSE;

	  tag = info->new_dtags ? DT_RUNPATH : DT_RPATH;
	  if (!_bfd_elf_add_dynamic_entry (info, tag, indx))
	    return FALSE;
	}

      if (filter_shlib != NULL)
	{
	  bfd_size_type indx;

	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
				      filter_shlib, TRUE);
	  if (indx == (bfd_size_type) -1
	      || !_bfd_elf_add_dynamic_entry (info, DT_FILTER, indx))
	    return FALSE;
	}

      if (auxiliary_filters != NULL)
	{
	  const char * const *p;

	  for (p = auxiliary_filters; *p != NULL; p++)
	    {
	      bfd_size_type indx;

	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					  *p, TRUE);
	      if (indx == (bfd_size_type) -1
		  || !_bfd_elf_add_dynamic_entry (info, DT_AUXILIARY, indx))
		return FALSE;
	    }
	}

      if (audit != NULL)
	{
	  bfd_size_type indx;

	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, audit,
				      TRUE);
	  if (indx == (bfd_size_type) -1
	      || !_bfd_elf_add_dynamic_entry (info, DT_AUDIT, indx))
	    return FALSE;
	}

      if (depaudit != NULL)
	{
	  bfd_size_type indx;

	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, depaudit,
				      TRUE);
	  if (indx == (bfd_size_type) -1
	      || !_bfd_elf_add_dynamic_entry (info, DT_DEPAUDIT, indx))
	    return FALSE;
	}

      eif.info = info;
      eif.failed = FALSE;

      /* If we are supposed to export all symbols into the dynamic symbol
	 table (this is not the normal case), then do so.  */
      if (info->export_dynamic
	  || (info->executable && info->dynamic))
	{
	  elf_link_hash_traverse (elf_hash_table (info),
				  _bfd_elf_export_symbol,
				  &eif);
	  if (eif.failed)
	    return FALSE;
	}

      /* Make all global versions with definition.  */
      for (t = info->version_info; t != NULL; t = t->next)
	for (d = t->globals.list; d != NULL; d = d->next)
	  if (!d->symver && d->literal)
	    {
	      const char *verstr, *name;
	      size_t namelen, verlen, newlen;
	      char *newname, *p, leading_char;
	      struct elf_link_hash_entry *newh;

	      leading_char = bfd_get_symbol_leading_char (output_bfd);
	      name = d->pattern;
	      namelen = strlen (name) + (leading_char != '\0');
	      verstr = t->name;
	      verlen = strlen (verstr);
	      newlen = namelen + verlen + 3;

	      newname = (char *) bfd_malloc (newlen);
	      if (newname == NULL)
		return FALSE;
	      newname[0] = leading_char;
	      memcpy (newname + (leading_char != '\0'), name, namelen);

	      /* Check the hidden versioned definition.  */
	      p = newname + namelen;
	      *p++ = ELF_VER_CHR;
	      memcpy (p, verstr, verlen + 1);
	      newh = elf_link_hash_lookup (elf_hash_table (info),
					   newname, FALSE, FALSE,
					   FALSE);
	      if (newh == NULL
		  || (newh->root.type != bfd_link_hash_defined
		      && newh->root.type != bfd_link_hash_defweak))
		{
		  /* Check the default versioned definition.  */
		  *p++ = ELF_VER_CHR;
		  memcpy (p, verstr, verlen + 1);
		  newh = elf_link_hash_lookup (elf_hash_table (info),
					       newname, FALSE, FALSE,
					       FALSE);
		}
	      free (newname);

	      /* Mark this version if there is a definition and it is
		 not defined in a shared object.  */
	      if (newh != NULL
		  && !newh->def_dynamic
		  && (newh->root.type == bfd_link_hash_defined
		      || newh->root.type == bfd_link_hash_defweak))
		d->symver = 1;
	    }

      /* Attach all the symbols to their version information.  */
      asvinfo.info = info;
      asvinfo.failed = FALSE;

      elf_link_hash_traverse (elf_hash_table (info),
			      _bfd_elf_link_assign_sym_version,
			      &asvinfo);
      if (asvinfo.failed)
	return FALSE;

      if (!info->allow_undefined_version)
	{
	  /* Check if all global versions have a definition.  */
	  all_defined = TRUE;
	  for (t = info->version_info; t != NULL; t = t->next)
	    for (d = t->globals.list; d != NULL; d = d->next)
	      if (d->literal && !d->symver && !d->script)
		{
		  (*_bfd_error_handler)
		    (_("%s: undefined version: %s"),
		     d->pattern, t->name);
		  all_defined = FALSE;
		}

	  if (!all_defined)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}

      /* Find all symbols which were defined in a dynamic object and make
	 the backend pick a reasonable value for them.  */
      elf_link_hash_traverse (elf_hash_table (info),
			      _bfd_elf_adjust_dynamic_symbol,
			      &eif);
      if (eif.failed)
	return FALSE;

      /* Add some entries to the .dynamic section.  We fill in some of the
	 values later, in bfd_elf_final_link, but we must add the entries
	 now so that we know the final size of the .dynamic section.  */

      /* If there are initialization and/or finalization functions to
	 call then add the corresponding DT_INIT/DT_FINI entries.  */
      h = (info->init_function
	   ? elf_link_hash_lookup (elf_hash_table (info),
				   info->init_function, FALSE,
				   FALSE, FALSE)
	   : NULL);
      if (h != NULL
	  && (h->ref_regular
	      || h->def_regular))
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_INIT, 0))
	    return FALSE;
	}
      h = (info->fini_function
	   ? elf_link_hash_lookup (elf_hash_table (info),
				   info->fini_function, FALSE,
				   FALSE, FALSE)
	   : NULL);
      if (h != NULL
	  && (h->ref_regular
	      || h->def_regular))
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FINI, 0))
	    return FALSE;
	}

      s = bfd_get_section_by_name (output_bfd, ".preinit_array");
      if (s != NULL && s->linker_has_input)
	{
	  /* DT_PREINIT_ARRAY is not allowed in shared library.  */
	  if (! info->executable)
	    {
	      bfd *sub;
	      asection *o;

	      for (sub = info->input_bfds; sub != NULL;
		   sub = sub->link_next)
		if (bfd_get_flavour (sub) == bfd_target_elf_flavour)
		  for (o = sub->sections; o != NULL; o = o->next)
		    if (elf_section_data (o)->this_hdr.sh_type
			== SHT_PREINIT_ARRAY)
		      {
			(*_bfd_error_handler)
			  (_("%B: .preinit_array section is not allowed in DSO"),
			   sub);
			break;
		      }

	      bfd_set_error (bfd_error_nonrepresentable_section);
	      return FALSE;
	    }

	  if (!_bfd_elf_add_dynamic_entry (info, DT_PREINIT_ARRAY, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_PREINIT_ARRAYSZ, 0))
	    return FALSE;
	}
      s = bfd_get_section_by_name (output_bfd, ".init_array");
      if (s != NULL && s->linker_has_input)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_INIT_ARRAY, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_INIT_ARRAYSZ, 0))
	    return FALSE;
	}
      s = bfd_get_section_by_name (output_bfd, ".fini_array");
      if (s != NULL && s->linker_has_input)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FINI_ARRAY, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_FINI_ARRAYSZ, 0))
	    return FALSE;
	}

      dynstr = bfd_get_linker_section (dynobj, ".dynstr");
      /* If .dynstr is excluded from the link, we don't want any of
	 these tags.  Strictly, we should be checking each section
	 individually;  This quick check covers for the case where
	 someone does a /DISCARD/ : { *(*) }.  */
      if (dynstr != NULL && dynstr->output_section != bfd_abs_section_ptr)
	{
	  bfd_size_type strsize;

	  strsize = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
	  if ((info->emit_hash
	       && !_bfd_elf_add_dynamic_entry (info, DT_HASH, 0))
	      || (info->emit_gnu_hash
		  && !_bfd_elf_add_dynamic_entry (info, DT_GNU_HASH, 0))
	      || !_bfd_elf_add_dynamic_entry (info, DT_STRTAB, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_SYMTAB, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_STRSZ, strsize)
	      || !_bfd_elf_add_dynamic_entry (info, DT_SYMENT,
					      bed->s->sizeof_sym))
	    return FALSE;
	}
    }

  /* The backend must work out the sizes of all the other dynamic
     sections.  */
  if (dynobj != NULL
      && bed->elf_backend_size_dynamic_sections != NULL
      && ! (*bed->elf_backend_size_dynamic_sections) (output_bfd, info))
    return FALSE;

  if (! _bfd_elf_maybe_strip_eh_frame_hdr (info))
    return FALSE;

  if (dynobj != NULL && elf_hash_table (info)->dynamic_sections_created)
    {
      unsigned long section_sym_count;
      struct bfd_elf_version_tree *verdefs;
      asection *s;

      /* Set up the version definition section.  */
      s = bfd_get_linker_section (dynobj, ".gnu.version_d");
      BFD_ASSERT (s != NULL);

      /* We may have created additional version definitions if we are
	 just linking a regular application.  */
      verdefs = info->version_info;

      /* Skip anonymous version tag.  */
      if (verdefs != NULL && verdefs->vernum == 0)
	verdefs = verdefs->next;

      if (verdefs == NULL && !info->create_default_symver)
	s->flags |= SEC_EXCLUDE;
      else
	{
	  unsigned int cdefs;
	  bfd_size_type size;
	  struct bfd_elf_version_tree *t;
	  bfd_byte *p;
	  Elf_Internal_Verdef def;
	  Elf_Internal_Verdaux defaux;
	  struct bfd_link_hash_entry *bh;
	  struct elf_link_hash_entry *h;
	  const char *name;

	  cdefs = 0;
	  size = 0;

	  /* Make space for the base version.  */
	  size += sizeof (Elf_External_Verdef);
	  size += sizeof (Elf_External_Verdaux);
	  ++cdefs;

	  /* Make space for the default version.  */
	  if (info->create_default_symver)
	    {
	      size += sizeof (Elf_External_Verdef);
	      ++cdefs;
	    }

	  for (t = verdefs; t != NULL; t = t->next)
	    {
	      struct bfd_elf_version_deps *n;

	      /* Don't emit base version twice.  */
	      if (t->vernum == 0)
		continue;

	      size += sizeof (Elf_External_Verdef);
	      size += sizeof (Elf_External_Verdaux);
	      ++cdefs;

	      for (n = t->deps; n != NULL; n = n->next)
		size += sizeof (Elf_External_Verdaux);
	    }

	  s->size = size;
	  s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
	  if (s->contents == NULL && s->size != 0)
	    return FALSE;

	  /* Fill in the version definition section.  */

	  p = s->contents;

	  def.vd_version = VER_DEF_CURRENT;
	  def.vd_flags = VER_FLG_BASE;
	  def.vd_ndx = 1;
	  def.vd_cnt = 1;
	  if (info->create_default_symver)
	    {
	      def.vd_aux = 2 * sizeof (Elf_External_Verdef);
	      def.vd_next = sizeof (Elf_External_Verdef);
	    }
	  else
	    {
	      def.vd_aux = sizeof (Elf_External_Verdef);
	      def.vd_next = (sizeof (Elf_External_Verdef)
			     + sizeof (Elf_External_Verdaux));
	    }

	  if (soname_indx != (bfd_size_type) -1)
	    {
	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
				      soname_indx);
	      def.vd_hash = bfd_elf_hash (soname);
	      defaux.vda_name = soname_indx;
	      name = soname;
	    }
	  else
	    {
	      bfd_size_type indx;

	      name = lbasename (output_bfd->filename);
	      def.vd_hash = bfd_elf_hash (name);
	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					  name, FALSE);
	      if (indx == (bfd_size_type) -1)
		return FALSE;
	      defaux.vda_name = indx;
	    }
	  defaux.vda_next = 0;

	  _bfd_elf_swap_verdef_out (output_bfd, &def,
				    (Elf_External_Verdef *) p);
	  p += sizeof (Elf_External_Verdef);
	  if (info->create_default_symver)
	    {
	      /* Add a symbol representing this version.  */
	      bh = NULL;
	      if (! (_bfd_generic_link_add_one_symbol
		     (info, dynobj, name, BSF_GLOBAL, bfd_abs_section_ptr,
		      0, NULL, FALSE,
		      get_elf_backend_data (dynobj)->collect, &bh)))
		return FALSE;
	      h = (struct elf_link_hash_entry *) bh;
	      h->non_elf = 0;
	      h->def_regular = 1;
	      h->type = STT_OBJECT;
	      h->verinfo.vertree = NULL;

	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;

	      /* Create a duplicate of the base version with the same
		 aux block, but different flags.  */
	      def.vd_flags = 0;
	      def.vd_ndx = 2;
	      def.vd_aux = sizeof (Elf_External_Verdef);
	      if (verdefs)
		def.vd_next = (sizeof (Elf_External_Verdef)
			       + sizeof (Elf_External_Verdaux));
	      else
		def.vd_next = 0;
	      _bfd_elf_swap_verdef_out (output_bfd, &def,
					(Elf_External_Verdef *) p);
	      p += sizeof (Elf_External_Verdef);
	    }
	  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
				     (Elf_External_Verdaux *) p);
	  p += sizeof (Elf_External_Verdaux);

	  for (t = verdefs; t != NULL; t = t->next)
	    {
	      unsigned int cdeps;
	      struct bfd_elf_version_deps *n;

	      /* Don't emit the base version twice.  */
	      if (t->vernum == 0)
		continue;

	      cdeps = 0;
	      for (n = t->deps; n != NULL; n = n->next)
		++cdeps;

	      /* Add a symbol representing this version.  */
	      bh = NULL;
	      if (! (_bfd_generic_link_add_one_symbol
		     (info, dynobj, t->name, BSF_GLOBAL, bfd_abs_section_ptr,
		      0, NULL, FALSE,
		      get_elf_backend_data (dynobj)->collect, &bh)))
		return FALSE;
	      h = (struct elf_link_hash_entry *) bh;
	      h->non_elf = 0;
	      h->def_regular = 1;
	      h->type = STT_OBJECT;
	      h->verinfo.vertree = t;

	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;

	      def.vd_version = VER_DEF_CURRENT;
	      def.vd_flags = 0;
	      if (t->globals.list == NULL
		  && t->locals.list == NULL
		  && ! t->used)
		def.vd_flags |= VER_FLG_WEAK;
	      def.vd_ndx = t->vernum + (info->create_default_symver ? 2 : 1);
	      def.vd_cnt = cdeps + 1;
	      def.vd_hash = bfd_elf_hash (t->name);
	      def.vd_aux = sizeof (Elf_External_Verdef);
	      def.vd_next = 0;

	      /* If a basever node is next, it *must* be the last node in
		 the chain, otherwise Verdef construction breaks.  */
	      if (t->next != NULL && t->next->vernum == 0)
		BFD_ASSERT (t->next->next == NULL);

	      if (t->next != NULL && t->next->vernum != 0)
		def.vd_next = (sizeof (Elf_External_Verdef)
			       + (cdeps + 1) * sizeof (Elf_External_Verdaux));

	      _bfd_elf_swap_verdef_out (output_bfd, &def,
					(Elf_External_Verdef *) p);
	      p += sizeof (Elf_External_Verdef);

	      defaux.vda_name = h->dynstr_index;
	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
				      h->dynstr_index);
	      defaux.vda_next = 0;
	      if (t->deps != NULL)
		defaux.vda_next = sizeof (Elf_External_Verdaux);
	      t->name_indx = defaux.vda_name;

	      _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
					 (Elf_External_Verdaux *) p);
	      p += sizeof (Elf_External_Verdaux);

	      for (n = t->deps; n != NULL; n = n->next)
		{
		  if (n->version_needed == NULL)
		    {
		      /* This can happen if there was an error in the
			 version script.  */
		      defaux.vda_name = 0;
		    }
		  else
		    {
		      defaux.vda_name = n->version_needed->name_indx;
		      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
					      defaux.vda_name);
		    }
		  if (n->next == NULL)
		    defaux.vda_next = 0;
		  else
		    defaux.vda_next = sizeof (Elf_External_Verdaux);

		  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
					     (Elf_External_Verdaux *) p);
		  p += sizeof (Elf_External_Verdaux);
		}
	    }

	  if (!_bfd_elf_add_dynamic_entry (info, DT_VERDEF, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_VERDEFNUM, cdefs))
	    return FALSE;

	  elf_tdata (output_bfd)->cverdefs = cdefs;
	}

      if ((info->new_dtags && info->flags) || (info->flags & DF_STATIC_TLS))
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FLAGS, info->flags))
	    return FALSE;
	}
      else if (info->flags & DF_BIND_NOW)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_BIND_NOW, 0))
	    return FALSE;
	}

      if (info->flags_1)
	{
	  if (info->executable)
	    info->flags_1 &= ~ (DF_1_INITFIRST
				| DF_1_NODELETE
				| DF_1_NOOPEN);
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FLAGS_1, info->flags_1))
	    return FALSE;
	}

      /* Work out the size of the version reference section.  */

      s = bfd_get_linker_section (dynobj, ".gnu.version_r");
      BFD_ASSERT (s != NULL);
      {
	struct elf_find_verdep_info sinfo;

	sinfo.info = info;
	sinfo.vers = elf_tdata (output_bfd)->cverdefs;
	if (sinfo.vers == 0)
	  sinfo.vers = 1;
	sinfo.failed = FALSE;

	elf_link_hash_traverse (elf_hash_table (info),
				_bfd_elf_link_find_version_dependencies,
				&sinfo);
	if (sinfo.failed)
	  return FALSE;

	if (elf_tdata (output_bfd)->verref == NULL)
	  s->flags |= SEC_EXCLUDE;
	else
	  {
	    Elf_Internal_Verneed *t;
	    unsigned int size;
	    unsigned int crefs;
	    bfd_byte *p;

	    /* Build the version dependency section.  */
	    size = 0;
	    crefs = 0;
	    for (t = elf_tdata (output_bfd)->verref;
		 t != NULL;
		 t = t->vn_nextref)
	      {
		Elf_Internal_Vernaux *a;

		size += sizeof (Elf_External_Verneed);
		++crefs;
		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  size += sizeof (Elf_External_Vernaux);
	      }

	    s->size = size;
	    s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
	    if (s->contents == NULL)
	      return FALSE;

	    p = s->contents;
	    for (t = elf_tdata (output_bfd)->verref;
		 t != NULL;
		 t = t->vn_nextref)
	      {
		unsigned int caux;
		Elf_Internal_Vernaux *a;
		bfd_size_type indx;

		caux = 0;
		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  ++caux;

		t->vn_version = VER_NEED_CURRENT;
		t->vn_cnt = caux;
		indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					    elf_dt_name (t->vn_bfd) != NULL
					    ? elf_dt_name (t->vn_bfd)
					    : lbasename (t->vn_bfd->filename),
					    FALSE);
		if (indx == (bfd_size_type) -1)
		  return FALSE;
		t->vn_file = indx;
		t->vn_aux = sizeof (Elf_External_Verneed);
		if (t->vn_nextref == NULL)
		  t->vn_next = 0;
		else
		  t->vn_next = (sizeof (Elf_External_Verneed)
				+ caux * sizeof (Elf_External_Vernaux));

		_bfd_elf_swap_verneed_out (output_bfd, t,
					   (Elf_External_Verneed *) p);
		p += sizeof (Elf_External_Verneed);

		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  {
		    a->vna_hash = bfd_elf_hash (a->vna_nodename);
		    indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
						a->vna_nodename, FALSE);
		    if (indx == (bfd_size_type) -1)
		      return FALSE;
		    a->vna_name = indx;
		    if (a->vna_nextptr == NULL)
		      a->vna_next = 0;
		    else
		      a->vna_next = sizeof (Elf_External_Vernaux);

		    _bfd_elf_swap_vernaux_out (output_bfd, a,
					       (Elf_External_Vernaux *) p);
		    p += sizeof (Elf_External_Vernaux);
		  }
	      }

	    if (!_bfd_elf_add_dynamic_entry (info, DT_VERNEED, 0)
		|| !_bfd_elf_add_dynamic_entry (info, DT_VERNEEDNUM, crefs))
	      return FALSE;

	    elf_tdata (output_bfd)->cverrefs = crefs;
	  }
      }

      if ((elf_tdata (output_bfd)->cverrefs == 0
	   && elf_tdata (output_bfd)->cverdefs == 0)
	  || _bfd_elf_link_renumber_dynsyms (output_bfd, info,
					     &section_sym_count) == 0)
	{
	  s = bfd_get_linker_section (dynobj, ".gnu.version");
	  s->flags |= SEC_EXCLUDE;
	}
    }
  return TRUE;
}

/* Find the first non-excluded output section.  We'll use its
   section symbol for some emitted relocs.  */
void
_bfd_elf_init_1_index_section (bfd *output_bfd, struct bfd_link_info *info)
{
  asection *s;

  for (s = output_bfd->sections; s != NULL; s = s->next)
    if ((s->flags & (SEC_EXCLUDE | SEC_ALLOC)) == SEC_ALLOC
	&& !_bfd_elf_link_omit_section_dynsym (output_bfd, info, s))
      {
	elf_hash_table (info)->text_index_section = s;
	break;
      }
}

/* Find two non-excluded output sections, one for code, one for data.
   We'll use their section symbols for some emitted relocs.  */
void
_bfd_elf_init_2_index_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  asection *s;

  /* Data first, since setting text_index_section changes
     _bfd_elf_link_omit_section_dynsym.  */
  for (s = output_bfd->sections; s != NULL; s = s->next)
    if (((s->flags & (SEC_EXCLUDE | SEC_ALLOC | SEC_READONLY)) == SEC_ALLOC)
	&& !_bfd_elf_link_omit_section_dynsym (output_bfd, info, s))
      {
	elf_hash_table (info)->data_index_section = s;
	break;
      }

  for (s = output_bfd->sections; s != NULL; s = s->next)
    if (((s->flags & (SEC_EXCLUDE | SEC_ALLOC | SEC_READONLY))
	 == (SEC_ALLOC | SEC_READONLY))
	&& !_bfd_elf_link_omit_section_dynsym (output_bfd, info, s))
      {
	elf_hash_table (info)->text_index_section = s;
	break;
      }

  if (elf_hash_table (info)->text_index_section == NULL)
    elf_hash_table (info)->text_index_section
      = elf_hash_table (info)->data_index_section;
}

bfd_boolean
bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
{
  const struct elf_backend_data *bed;

  if (!is_elf_hash_table (info->hash))
    return TRUE;

  bed = get_elf_backend_data (output_bfd);
  (*bed->elf_backend_init_index_section) (output_bfd, info);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd *dynobj;
      asection *s;
      bfd_size_type dynsymcount;
      unsigned long section_sym_count;
      unsigned int dtagcount;

      dynobj = elf_hash_table (info)->dynobj;

      /* Assign dynsym indicies.  In a shared library we generate a
	 section symbol for each output section, which come first.
	 Next come all of the back-end allocated local dynamic syms,
	 followed by the rest of the global symbols.  */

      dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info,
						    &section_sym_count);

      /* Work out the size of the symbol version section.  */
      s = bfd_get_linker_section (dynobj, ".gnu.version");
      BFD_ASSERT (s != NULL);
      if (dynsymcount != 0
	  && (s->flags & SEC_EXCLUDE) == 0)
	{
	  s->size = dynsymcount * sizeof (Elf_External_Versym);
	  s->contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
	  if (s->contents == NULL)
	    return FALSE;

	  if (!_bfd_elf_add_dynamic_entry (info, DT_VERSYM, 0))
	    return FALSE;
	}

      /* Set the size of the .dynsym and .hash sections.  We counted
	 the number of dynamic symbols in elf_link_add_object_symbols.
	 We will build the contents of .dynsym and .hash when we build
	 the final symbol table, because until then we do not know the
	 correct value to give the symbols.  We built the .dynstr
	 section as we went along in elf_link_add_object_symbols.  */
      s = bfd_get_linker_section (dynobj, ".dynsym");
      BFD_ASSERT (s != NULL);
      s->size = dynsymcount * bed->s->sizeof_sym;

      if (dynsymcount != 0)
	{
	  s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
	  if (s->contents == NULL)
	    return FALSE;

	  /* The first entry in .dynsym is a dummy symbol.
	     Clear all the section syms, in case we don't output them all.  */
	  ++section_sym_count;
	  memset (s->contents, 0, section_sym_count * bed->s->sizeof_sym);
	}

      elf_hash_table (info)->bucketcount = 0;

      /* Compute the size of the hashing table.  As a side effect this
	 computes the hash values for all the names we export.  */
      if (info->emit_hash)
	{
	  unsigned long int *hashcodes;
	  struct hash_codes_info hashinf;
	  bfd_size_type amt;
	  unsigned long int nsyms;
	  size_t bucketcount;
	  size_t hash_entry_size;

	  /* Compute the hash values for all exported symbols.  At the same
	     time store the values in an array so that we could use them for
	     optimizations.  */
	  amt = dynsymcount * sizeof (unsigned long int);
	  hashcodes = (unsigned long int *) bfd_malloc (amt);
	  if (hashcodes == NULL)
	    return FALSE;
	  hashinf.hashcodes = hashcodes;
	  hashinf.error = FALSE;

	  /* Put all hash values in HASHCODES.  */
	  elf_link_hash_traverse (elf_hash_table (info),
				  elf_collect_hash_codes, &hashinf);
	  if (hashinf.error)
	    {
	      free (hashcodes);
	      return FALSE;
	    }

	  nsyms = hashinf.hashcodes - hashcodes;
	  bucketcount
	    = compute_bucket_count (info, hashcodes, nsyms, 0);
	  free (hashcodes);

	  if (bucketcount == 0)
	    return FALSE;

	  elf_hash_table (info)->bucketcount = bucketcount;

	  s = bfd_get_linker_section (dynobj, ".hash");
	  BFD_ASSERT (s != NULL);
	  hash_entry_size = elf_section_data (s)->this_hdr.sh_entsize;
	  s->size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
	  s->contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
	  if (s->contents == NULL)
	    return FALSE;

	  bfd_put (8 * hash_entry_size, output_bfd, bucketcount, s->contents);
	  bfd_put (8 * hash_entry_size, output_bfd, dynsymcount,
		   s->contents + hash_entry_size);
	}

      if (info->emit_gnu_hash)
	{
	  size_t i, cnt;
	  unsigned char *contents;
	  struct collect_gnu_hash_codes cinfo;
	  bfd_size_type amt;
	  size_t bucketcount;

	  memset (&cinfo, 0, sizeof (cinfo));

	  /* Compute the hash values for all exported symbols.  At the same
	     time store the values in an array so that we could use them for
	     optimizations.  */
	  amt = dynsymcount * 2 * sizeof (unsigned long int);
	  cinfo.hashcodes = (long unsigned int *) bfd_malloc (amt);
	  if (cinfo.hashcodes == NULL)
	    return FALSE;

	  cinfo.hashval = cinfo.hashcodes + dynsymcount;
	  cinfo.min_dynindx = -1;
	  cinfo.output_bfd = output_bfd;
	  cinfo.bed = bed;

	  /* Put all hash values in HASHCODES.  */
	  elf_link_hash_traverse (elf_hash_table (info),
				  elf_collect_gnu_hash_codes, &cinfo);
	  if (cinfo.error)
	    {
	      free (cinfo.hashcodes);
	      return FALSE;
	    }

	  bucketcount
	    = compute_bucket_count (info, cinfo.hashcodes, cinfo.nsyms, 1);

	  if (bucketcount == 0)
	    {
	      free (cinfo.hashcodes);
	      return FALSE;
	    }

	  s = bfd_get_linker_section (dynobj, ".gnu.hash");
	  BFD_ASSERT (s != NULL);

	  if (cinfo.nsyms == 0)
	    {
	      /* Empty .gnu.hash section is special.  */
	      BFD_ASSERT (cinfo.min_dynindx == -1);
	      free (cinfo.hashcodes);
	      s->size = 5 * 4 + bed->s->arch_size / 8;
	      contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
	      if (contents == NULL)
		return FALSE;
	      s->contents = contents;
	      /* 1 empty bucket.  */
	      bfd_put_32 (output_bfd, 1, contents);
	      /* SYMIDX above the special symbol 0.  */
	      bfd_put_32 (output_bfd, 1, contents + 4);
	      /* Just one word for bitmask.  */
	      bfd_put_32 (output_bfd, 1, contents + 8);
	      /* Only hash fn bloom filter.  */
	      bfd_put_32 (output_bfd, 0, contents + 12);
	      /* No hashes are valid - empty bitmask.  */
	      bfd_put (bed->s->arch_size, output_bfd, 0, contents + 16);
	      /* No hashes in the only bucket.  */
	      bfd_put_32 (output_bfd, 0,
			  contents + 16 + bed->s->arch_size / 8);
	    }
	  else
	    {
	      unsigned long int maskwords, maskbitslog2, x;
	      BFD_ASSERT (cinfo.min_dynindx != -1);

	      x = cinfo.nsyms;
	      maskbitslog2 = 1;
	      while ((x >>= 1) != 0)
		++maskbitslog2;
	      if (maskbitslog2 < 3)
		maskbitslog2 = 5;
	      else if ((1 << (maskbitslog2 - 2)) & cinfo.nsyms)
		maskbitslog2 = maskbitslog2 + 3;
	      else
		maskbitslog2 = maskbitslog2 + 2;
	      if (bed->s->arch_size == 64)
		{
		  if (maskbitslog2 == 5)
		    maskbitslog2 = 6;
		  cinfo.shift1 = 6;
		}
	      else
		cinfo.shift1 = 5;
	      cinfo.mask = (1 << cinfo.shift1) - 1;
	      cinfo.shift2 = maskbitslog2;
	      cinfo.maskbits = 1 << maskbitslog2;
	      maskwords = 1 << (maskbitslog2 - cinfo.shift1);
	      amt = bucketcount * sizeof (unsigned long int) * 2;
	      amt += maskwords * sizeof (bfd_vma);
	      cinfo.bitmask = (bfd_vma *) bfd_malloc (amt);
	      if (cinfo.bitmask == NULL)
		{
		  free (cinfo.hashcodes);
		  return FALSE;
		}

	      cinfo.counts = (long unsigned int *) (cinfo.bitmask + maskwords);
	      cinfo.indx = cinfo.counts + bucketcount;
	      cinfo.symindx = dynsymcount - cinfo.nsyms;
	      memset (cinfo.bitmask, 0, maskwords * sizeof (bfd_vma));

	      /* Determine how often each hash bucket is used.  */
	      memset (cinfo.counts, 0, bucketcount * sizeof (cinfo.counts[0]));
	      for (i = 0; i < cinfo.nsyms; ++i)
		++cinfo.counts[cinfo.hashcodes[i] % bucketcount];

	      for (i = 0, cnt = cinfo.symindx; i < bucketcount; ++i)
		if (cinfo.counts[i] != 0)
		  {
		    cinfo.indx[i] = cnt;
		    cnt += cinfo.counts[i];
		  }
	      BFD_ASSERT (cnt == dynsymcount);
	      cinfo.bucketcount = bucketcount;
	      cinfo.local_indx = cinfo.min_dynindx;

	      s->size = (4 + bucketcount + cinfo.nsyms) * 4;
	      s->size += cinfo.maskbits / 8;
	      contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
	      if (contents == NULL)
		{
		  free (cinfo.bitmask);
		  free (cinfo.hashcodes);
		  return FALSE;
		}

	      s->contents = contents;
	      bfd_put_32 (output_bfd, bucketcount, contents);
	      bfd_put_32 (output_bfd, cinfo.symindx, contents + 4);
	      bfd_put_32 (output_bfd, maskwords, contents + 8);
	      bfd_put_32 (output_bfd, cinfo.shift2, contents + 12);
	      contents += 16 + cinfo.maskbits / 8;

	      for (i = 0; i < bucketcount; ++i)
		{
		  if (cinfo.counts[i] == 0)
		    bfd_put_32 (output_bfd, 0, contents);
		  else
		    bfd_put_32 (output_bfd, cinfo.indx[i], contents);
		  contents += 4;
		}

	      cinfo.contents = contents;

	      /* Renumber dynamic symbols, populate .gnu.hash section.  */
	      elf_link_hash_traverse (elf_hash_table (info),
				      elf_renumber_gnu_hash_syms, &cinfo);

	      contents = s->contents + 16;
	      for (i = 0; i < maskwords; ++i)
		{
		  bfd_put (bed->s->arch_size, output_bfd, cinfo.bitmask[i],
			   contents);
		  contents += bed->s->arch_size / 8;
		}

	      free (cinfo.bitmask);
	      free (cinfo.hashcodes);
	    }
	}

      s = bfd_get_linker_section (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);

      elf_finalize_dynstr (output_bfd, info);

      s->size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);

      for (dtagcount = 0; dtagcount <= info->spare_dynamic_tags; ++dtagcount)
	if (!_bfd_elf_add_dynamic_entry (info, DT_NULL, 0))
	  return FALSE;
    }

  return TRUE;
}

/* Make sure sec_info_type is cleared if sec_info is cleared too.  */

static void
merge_sections_remove_hook (bfd *abfd ATTRIBUTE_UNUSED,
			    asection *sec)
{
  BFD_ASSERT (sec->sec_info_type == SEC_INFO_TYPE_MERGE);
  sec->sec_info_type = SEC_INFO_TYPE_NONE;
}

/* Finish SHF_MERGE section merging.  */

bfd_boolean
_bfd_elf_merge_sections (bfd *abfd, struct bfd_link_info *info)
{
  bfd *ibfd;
  asection *sec;

  if (!is_elf_hash_table (info->hash))
    return FALSE;

  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    if ((ibfd->flags & DYNAMIC) == 0)
      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	if ((sec->flags & SEC_MERGE) != 0
	    && !bfd_is_abs_section (sec->output_section))
	  {
	    struct bfd_elf_section_data *secdata;

	    secdata = elf_section_data (sec);
	    if (! _bfd_add_merge_section (abfd,
					  &elf_hash_table (info)->merge_info,
					  sec, &secdata->sec_info))
	      return FALSE;
	    else if (secdata->sec_info)
	      sec->sec_info_type = SEC_INFO_TYPE_MERGE;
	  }

  if (elf_hash_table (info)->merge_info != NULL)
    _bfd_merge_sections (abfd, info, elf_hash_table (info)->merge_info,
			 merge_sections_remove_hook);
  return TRUE;
}

/* Create an entry in an ELF linker hash table.  */

struct bfd_hash_entry *
_bfd_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table,
			    const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = (struct bfd_hash_entry *)
          bfd_hash_allocate (table, sizeof (struct elf_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf_link_hash_entry *ret = (struct elf_link_hash_entry *) entry;
      struct elf_link_hash_table *htab = (struct elf_link_hash_table *) table;

      /* Set local fields.  */
      ret->indx = -1;
      ret->dynindx = -1;
      ret->got = htab->init_got_refcount;
      ret->plt = htab->init_plt_refcount;
      memset (&ret->size, 0, (sizeof (struct elf_link_hash_entry)
			      - offsetof (struct elf_link_hash_entry, size)));
      /* Assume that we have been called by a non-ELF symbol reader.
	 This flag is then reset by the code which reads an ELF input
	 file.  This ensures that a symbol created by a non-ELF symbol
	 reader will have the flag set correctly.  */
      ret->non_elf = 1;
    }

  return entry;
}

/* Copy data from an indirect symbol to its direct symbol, hiding the
   old indirect symbol.  Also used for copying flags to a weakdef.  */

void
_bfd_elf_link_hash_copy_indirect (struct bfd_link_info *info,
				  struct elf_link_hash_entry *dir,
				  struct elf_link_hash_entry *ind)
{
  struct elf_link_hash_table *htab;

  /* Copy down any references that we may have already seen to the
     symbol which just became indirect.  */

  dir->ref_dynamic |= ind->ref_dynamic;
  dir->ref_regular |= ind->ref_regular;
  dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
  dir->non_got_ref |= ind->non_got_ref;
  dir->needs_plt |= ind->needs_plt;
  dir->pointer_equality_needed |= ind->pointer_equality_needed;

  if (ind->root.type != bfd_link_hash_indirect)
    return;

  /* Copy over the global and procedure linkage table refcount entries.
     These may have been already set up by a check_relocs routine.  */
  htab = elf_hash_table (info);
  if (ind->got.refcount > htab->init_got_refcount.refcount)
    {
      if (dir->got.refcount < 0)
	dir->got.refcount = 0;
      dir->got.refcount += ind->got.refcount;
      ind->got.refcount = htab->init_got_refcount.refcount;
    }

  if (ind->plt.refcount > htab->init_plt_refcount.refcount)
    {
      if (dir->plt.refcount < 0)
	dir->plt.refcount = 0;
      dir->plt.refcount += ind->plt.refcount;
      ind->plt.refcount = htab->init_plt_refcount.refcount;
    }

  if (ind->dynindx != -1)
    {
      if (dir->dynindx != -1)
	_bfd_elf_strtab_delref (htab->dynstr, dir->dynstr_index);
      dir->dynindx = ind->dynindx;
      dir->dynstr_index = ind->dynstr_index;
      ind->dynindx = -1;
      ind->dynstr_index = 0;
    }
}

void
_bfd_elf_link_hash_hide_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *h,
				bfd_boolean force_local)
{
  /* STT_GNU_IFUNC symbol must go through PLT.  */
  if (h->type != STT_GNU_IFUNC)
    {
      h->plt = elf_hash_table (info)->init_plt_offset;
      h->needs_plt = 0;
    }
  if (force_local)
    {
      h->forced_local = 1;
      if (h->dynindx != -1)
	{
	  h->dynindx = -1;
	  _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				  h->dynstr_index);
	}
    }
}

/* Initialize an ELF linker hash table.  *TABLE has been zeroed by our
   caller.  */

bfd_boolean
_bfd_elf_link_hash_table_init
  (struct elf_link_hash_table *table,
   bfd *abfd,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *),
   unsigned int entsize,
   enum elf_target_id target_id)
{
  bfd_boolean ret;
  int can_refcount = get_elf_backend_data (abfd)->can_refcount;

  table->init_got_refcount.refcount = can_refcount - 1;
  table->init_plt_refcount.refcount = can_refcount - 1;
  table->init_got_offset.offset = -(bfd_vma) 1;
  table->init_plt_offset.offset = -(bfd_vma) 1;
  /* The first dynamic symbol is a dummy.  */
  table->dynsymcount = 1;

  ret = _bfd_link_hash_table_init (&table->root, abfd, newfunc, entsize);

  table->root.type = bfd_link_elf_hash_table;
  table->hash_table_id = target_id;

  return ret;
}

/* Create an ELF linker hash table.  */

struct bfd_link_hash_table *
_bfd_elf_link_hash_table_create (bfd *abfd)
{
  struct elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_link_hash_table);

  ret = (struct elf_link_hash_table *) bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (ret, abfd, _bfd_elf_link_hash_newfunc,
				       sizeof (struct elf_link_hash_entry),
				       GENERIC_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  return &ret->root;
}

/* Destroy an ELF linker hash table.  */

void
_bfd_elf_link_hash_table_free (struct bfd_link_hash_table *hash)
{
  struct elf_link_hash_table *htab = (struct elf_link_hash_table *) hash;
  if (htab->dynstr != NULL)
    _bfd_elf_strtab_free (htab->dynstr);
  _bfd_merge_sections_free (htab->merge_info);
  _bfd_generic_link_hash_table_free (hash);
}

/* This is a hook for the ELF emulation code in the generic linker to
   tell the backend linker what file name to use for the DT_NEEDED
   entry for a dynamic object.  */

void
bfd_elf_set_dt_needed_name (bfd *abfd, const char *name)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    elf_dt_name (abfd) = name;
}

int
bfd_elf_get_dyn_lib_class (bfd *abfd)
{
  int lib_class;
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    lib_class = elf_dyn_lib_class (abfd);
  else
    lib_class = 0;
  return lib_class;
}

void
bfd_elf_set_dyn_lib_class (bfd *abfd, enum dynamic_lib_link_class lib_class)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    elf_dyn_lib_class (abfd) = lib_class;
}

/* Get the list of DT_NEEDED entries for a link.  This is a hook for
   the linker ELF emulation code.  */

struct bfd_link_needed_list *
bfd_elf_get_needed_list (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *info)
{
  if (! is_elf_hash_table (info->hash))
    return NULL;
  return elf_hash_table (info)->needed;
}

/* Get the list of DT_RPATH/DT_RUNPATH entries for a link.  This is a
   hook for the linker ELF emulation code.  */

struct bfd_link_needed_list *
bfd_elf_get_runpath_list (bfd *abfd ATTRIBUTE_UNUSED,
			  struct bfd_link_info *info)
{
  if (! is_elf_hash_table (info->hash))
    return NULL;
  return elf_hash_table (info)->runpath;
}

/* Get the name actually used for a dynamic object for a link.  This
   is the SONAME entry if there is one.  Otherwise, it is the string
   passed to bfd_elf_set_dt_needed_name, or it is the filename.  */

const char *
bfd_elf_get_dt_soname (bfd *abfd)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    return elf_dt_name (abfd);
  return NULL;
}

/* Get the list of DT_NEEDED entries from a BFD.  This is a hook for
   the ELF linker emulation code.  */

bfd_boolean
bfd_elf_get_bfd_needed_list (bfd *abfd,
			     struct bfd_link_needed_list **pneeded)
{
  asection *s;
  bfd_byte *dynbuf = NULL;
  unsigned int elfsec;
  unsigned long shlink;
  bfd_byte *extdyn, *extdynend;
  size_t extdynsize;
  void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);

  *pneeded = NULL;

  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour
      || bfd_get_format (abfd) != bfd_object)
    return TRUE;

  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s == NULL || s->size == 0)
    return TRUE;

  if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
    goto error_return;

  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
  if (elfsec == SHN_BAD)
    goto error_return;

  shlink = elf_elfsections (abfd)[elfsec]->sh_link;

  extdynsize = get_elf_backend_data (abfd)->s->sizeof_dyn;
  swap_dyn_in = get_elf_backend_data (abfd)->s->swap_dyn_in;

  extdyn = dynbuf;
  extdynend = extdyn + s->size;
  for (; extdyn < extdynend; extdyn += extdynsize)
    {
      Elf_Internal_Dyn dyn;

      (*swap_dyn_in) (abfd, extdyn, &dyn);

      if (dyn.d_tag == DT_NULL)
	break;

      if (dyn.d_tag == DT_NEEDED)
	{
	  const char *string;
	  struct bfd_link_needed_list *l;
	  unsigned int tagv = dyn.d_un.d_val;
	  bfd_size_type amt;

	  string = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
	  if (string == NULL)
	    goto error_return;

	  amt = sizeof *l;
	  l = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
	  if (l == NULL)
	    goto error_return;

	  l->by = abfd;
	  l->name = string;
	  l->next = *pneeded;
	  *pneeded = l;
	}
    }

  free (dynbuf);

  return TRUE;

 error_return:
  if (dynbuf != NULL)
    free (dynbuf);
  return FALSE;
}

struct elf_symbuf_symbol
{
  unsigned long st_name;	/* Symbol name, index in string tbl */
  unsigned char st_info;	/* Type and binding attributes */
  unsigned char st_other;	/* Visibilty, and target specific */
};

struct elf_symbuf_head
{
  struct elf_symbuf_symbol *ssym;
  bfd_size_type count;
  unsigned int st_shndx;
};

struct elf_symbol
{
  union
    {
      Elf_Internal_Sym *isym;
      struct elf_symbuf_symbol *ssym;
    } u;
  const char *name;
};

/* Sort references to symbols by ascending section number.  */

static int
elf_sort_elf_symbol (const void *arg1, const void *arg2)
{
  const Elf_Internal_Sym *s1 = *(const Elf_Internal_Sym **) arg1;
  const Elf_Internal_Sym *s2 = *(const Elf_Internal_Sym **) arg2;

  return s1->st_shndx - s2->st_shndx;
}

static int
elf_sym_name_compare (const void *arg1, const void *arg2)
{
  const struct elf_symbol *s1 = (const struct elf_symbol *) arg1;
  const struct elf_symbol *s2 = (const struct elf_symbol *) arg2;
  return strcmp (s1->name, s2->name);
}

static struct elf_symbuf_head *
elf_create_symbuf (bfd_size_type symcount, Elf_Internal_Sym *isymbuf)
{
  Elf_Internal_Sym **ind, **indbufend, **indbuf;
  struct elf_symbuf_symbol *ssym;
  struct elf_symbuf_head *ssymbuf, *ssymhead;
  bfd_size_type i, shndx_count, total_size;

  indbuf = (Elf_Internal_Sym **) bfd_malloc2 (symcount, sizeof (*indbuf));
  if (indbuf == NULL)
    return NULL;

  for (ind = indbuf, i = 0; i < symcount; i++)
    if (isymbuf[i].st_shndx != SHN_UNDEF)
      *ind++ = &isymbuf[i];
  indbufend = ind;

  qsort (indbuf, indbufend - indbuf, sizeof (Elf_Internal_Sym *),
	 elf_sort_elf_symbol);

  shndx_count = 0;
  if (indbufend > indbuf)
    for (ind = indbuf, shndx_count++; ind < indbufend - 1; ind++)
      if (ind[0]->st_shndx != ind[1]->st_shndx)
	shndx_count++;

  total_size = ((shndx_count + 1) * sizeof (*ssymbuf)
		+ (indbufend - indbuf) * sizeof (*ssym));
  ssymbuf = (struct elf_symbuf_head *) bfd_malloc (total_size);
  if (ssymbuf == NULL)
    {
      free (indbuf);
      return NULL;
    }

  ssym = (struct elf_symbuf_symbol *) (ssymbuf + shndx_count + 1);
  ssymbuf->ssym = NULL;
  ssymbuf->count = shndx_count;
  ssymbuf->st_shndx = 0;
  for (ssymhead = ssymbuf, ind = indbuf; ind < indbufend; ssym++, ind++)
    {
      if (ind == indbuf || ssymhead->st_shndx != (*ind)->st_shndx)
	{
	  ssymhead++;
	  ssymhead->ssym = ssym;
	  ssymhead->count = 0;
	  ssymhead->st_shndx = (*ind)->st_shndx;
	}
      ssym->st_name = (*ind)->st_name;
      ssym->st_info = (*ind)->st_info;
      ssym->st_other = (*ind)->st_other;
      ssymhead->count++;
    }
  BFD_ASSERT ((bfd_size_type) (ssymhead - ssymbuf) == shndx_count
	      && (((bfd_hostptr_t) ssym - (bfd_hostptr_t) ssymbuf)
		  == total_size));

  free (indbuf);
  return ssymbuf;
}

/* Check if 2 sections define the same set of local and global
   symbols.  */

static bfd_boolean
bfd_elf_match_symbols_in_sections (asection *sec1, asection *sec2,
				   struct bfd_link_info *info)
{
  bfd *bfd1, *bfd2;
  const struct elf_backend_data *bed1, *bed2;
  Elf_Internal_Shdr *hdr1, *hdr2;
  bfd_size_type symcount1, symcount2;
  Elf_Internal_Sym *isymbuf1, *isymbuf2;
  struct elf_symbuf_head *ssymbuf1, *ssymbuf2;
  Elf_Internal_Sym *isym, *isymend;
  struct elf_symbol *symtable1 = NULL, *symtable2 = NULL;
  bfd_size_type count1, count2, i;
  unsigned int shndx1, shndx2;
  bfd_boolean result;

  bfd1 = sec1->owner;
  bfd2 = sec2->owner;

  /* Both sections have to be in ELF.  */
  if (bfd_get_flavour (bfd1) != bfd_target_elf_flavour
      || bfd_get_flavour (bfd2) != bfd_target_elf_flavour)
    return FALSE;

  if (elf_section_type (sec1) != elf_section_type (sec2))
    return FALSE;

  shndx1 = _bfd_elf_section_from_bfd_section (bfd1, sec1);
  shndx2 = _bfd_elf_section_from_bfd_section (bfd2, sec2);
  if (shndx1 == SHN_BAD || shndx2 == SHN_BAD)
    return FALSE;

  bed1 = get_elf_backend_data (bfd1);
  bed2 = get_elf_backend_data (bfd2);
  hdr1 = &elf_tdata (bfd1)->symtab_hdr;
  symcount1 = hdr1->sh_size / bed1->s->sizeof_sym;
  hdr2 = &elf_tdata (bfd2)->symtab_hdr;
  symcount2 = hdr2->sh_size / bed2->s->sizeof_sym;

  if (symcount1 == 0 || symcount2 == 0)
    return FALSE;

  result = FALSE;
  isymbuf1 = NULL;
  isymbuf2 = NULL;
  ssymbuf1 = (struct elf_symbuf_head *) elf_tdata (bfd1)->symbuf;
  ssymbuf2 = (struct elf_symbuf_head *) elf_tdata (bfd2)->symbuf;

  if (ssymbuf1 == NULL)
    {
      isymbuf1 = bfd_elf_get_elf_syms (bfd1, hdr1, symcount1, 0,
				       NULL, NULL, NULL);
      if (isymbuf1 == NULL)
	goto done;

      if (!info->reduce_memory_overheads)
	elf_tdata (bfd1)->symbuf = ssymbuf1
	  = elf_create_symbuf (symcount1, isymbuf1);
    }

  if (ssymbuf1 == NULL || ssymbuf2 == NULL)
    {
      isymbuf2 = bfd_elf_get_elf_syms (bfd2, hdr2, symcount2, 0,
				       NULL, NULL, NULL);
      if (isymbuf2 == NULL)
	goto done;

      if (ssymbuf1 != NULL && !info->reduce_memory_overheads)
	elf_tdata (bfd2)->symbuf = ssymbuf2
	  = elf_create_symbuf (symcount2, isymbuf2);
    }

  if (ssymbuf1 != NULL && ssymbuf2 != NULL)
    {
      /* Optimized faster version.  */
      bfd_size_type lo, hi, mid;
      struct elf_symbol *symp;
      struct elf_symbuf_symbol *ssym, *ssymend;

      lo = 0;
      hi = ssymbuf1->count;
      ssymbuf1++;
      count1 = 0;
      while (lo < hi)
	{
	  mid = (lo + hi) / 2;
	  if (shndx1 < ssymbuf1[mid].st_shndx)
	    hi = mid;
	  else if (shndx1 > ssymbuf1[mid].st_shndx)
	    lo = mid + 1;
	  else
	    {
	      count1 = ssymbuf1[mid].count;
	      ssymbuf1 += mid;
	      break;
	    }
	}

      lo = 0;
      hi = ssymbuf2->count;
      ssymbuf2++;
      count2 = 0;
      while (lo < hi)
	{
	  mid = (lo + hi) / 2;
	  if (shndx2 < ssymbuf2[mid].st_shndx)
	    hi = mid;
	  else if (shndx2 > ssymbuf2[mid].st_shndx)
	    lo = mid + 1;
	  else
	    {
	      count2 = ssymbuf2[mid].count;
	      ssymbuf2 += mid;
	      break;
	    }
	}

      if (count1 == 0 || count2 == 0 || count1 != count2)
	goto done;

      symtable1 = (struct elf_symbol *)
          bfd_malloc (count1 * sizeof (struct elf_symbol));
      symtable2 = (struct elf_symbol *)
          bfd_malloc (count2 * sizeof (struct elf_symbol));
      if (symtable1 == NULL || symtable2 == NULL)
	goto done;

      symp = symtable1;
      for (ssym = ssymbuf1->ssym, ssymend = ssym + count1;
	   ssym < ssymend; ssym++, symp++)
	{
	  symp->u.ssym = ssym;
	  symp->name = bfd_elf_string_from_elf_section (bfd1,
							hdr1->sh_link,
							ssym->st_name);
	}

      symp = symtable2;
      for (ssym = ssymbuf2->ssym, ssymend = ssym + count2;
	   ssym < ssymend; ssym++, symp++)
	{
	  symp->u.ssym = ssym;
	  symp->name = bfd_elf_string_from_elf_section (bfd2,
							hdr2->sh_link,
							ssym->st_name);
	}

      /* Sort symbol by name.  */
      qsort (symtable1, count1, sizeof (struct elf_symbol),
	     elf_sym_name_compare);
      qsort (symtable2, count1, sizeof (struct elf_symbol),
	     elf_sym_name_compare);

      for (i = 0; i < count1; i++)
	/* Two symbols must have the same binding, type and name.  */
	if (symtable1 [i].u.ssym->st_info != symtable2 [i].u.ssym->st_info
	    || symtable1 [i].u.ssym->st_other != symtable2 [i].u.ssym->st_other
	    || strcmp (symtable1 [i].name, symtable2 [i].name) != 0)
	  goto done;

      result = TRUE;
      goto done;
    }

  symtable1 = (struct elf_symbol *)
      bfd_malloc (symcount1 * sizeof (struct elf_symbol));
  symtable2 = (struct elf_symbol *)
      bfd_malloc (symcount2 * sizeof (struct elf_symbol));
  if (symtable1 == NULL || symtable2 == NULL)
    goto done;

  /* Count definitions in the section.  */
  count1 = 0;
  for (isym = isymbuf1, isymend = isym + symcount1; isym < isymend; isym++)
    if (isym->st_shndx == shndx1)
      symtable1[count1++].u.isym = isym;

  count2 = 0;
  for (isym = isymbuf2, isymend = isym + symcount2; isym < isymend; isym++)
    if (isym->st_shndx == shndx2)
      symtable2[count2++].u.isym = isym;

  if (count1 == 0 || count2 == 0 || count1 != count2)
    goto done;

  for (i = 0; i < count1; i++)
    symtable1[i].name
      = bfd_elf_string_from_elf_section (bfd1, hdr1->sh_link,
					 symtable1[i].u.isym->st_name);

  for (i = 0; i < count2; i++)
    symtable2[i].name
      = bfd_elf_string_from_elf_section (bfd2, hdr2->sh_link,
					 symtable2[i].u.isym->st_name);

  /* Sort symbol by name.  */
  qsort (symtable1, count1, sizeof (struct elf_symbol),
	 elf_sym_name_compare);
  qsort (symtable2, count1, sizeof (struct elf_symbol),
	 elf_sym_name_compare);

  for (i = 0; i < count1; i++)
    /* Two symbols must have the same binding, type and name.  */
    if (symtable1 [i].u.isym->st_info != symtable2 [i].u.isym->st_info
	|| symtable1 [i].u.isym->st_other != symtable2 [i].u.isym->st_other
	|| strcmp (symtable1 [i].name, symtable2 [i].name) != 0)
      goto done;

  result = TRUE;

done:
  if (symtable1)
    free (symtable1);
  if (symtable2)
    free (symtable2);
  if (isymbuf1)
    free (isymbuf1);
  if (isymbuf2)
    free (isymbuf2);

  return result;
}

/* Return TRUE if 2 section types are compatible.  */

bfd_boolean
_bfd_elf_match_sections_by_type (bfd *abfd, const asection *asec,
				 bfd *bbfd, const asection *bsec)
{
  if (asec == NULL
      || bsec == NULL
      || abfd->xvec->flavour != bfd_target_elf_flavour
      || bbfd->xvec->flavour != bfd_target_elf_flavour)
    return TRUE;

  return elf_section_type (asec) == elf_section_type (bsec);
}

/* Final phase of ELF linker.  */

/* A structure we use to avoid passing large numbers of arguments.  */

struct elf_final_link_info
{
  /* General link information.  */
  struct bfd_link_info *info;
  /* Output BFD.  */
  bfd *output_bfd;
  /* Symbol string table.  */
  struct bfd_strtab_hash *symstrtab;
  /* .dynsym section.  */
  asection *dynsym_sec;
  /* .hash section.  */
  asection *hash_sec;
  /* symbol version section (.gnu.version).  */
  asection *symver_sec;
  /* Buffer large enough to hold contents of any section.  */
  bfd_byte *contents;
  /* Buffer large enough to hold external relocs of any section.  */
  void *external_relocs;
  /* Buffer large enough to hold internal relocs of any section.  */
  Elf_Internal_Rela *internal_relocs;
  /* Buffer large enough to hold external local symbols of any input
     BFD.  */
  bfd_byte *external_syms;
  /* And a buffer for symbol section indices.  */
  Elf_External_Sym_Shndx *locsym_shndx;
  /* Buffer large enough to hold internal local symbols of any input
     BFD.  */
  Elf_Internal_Sym *internal_syms;
  /* Array large enough to hold a symbol index for each local symbol
     of any input BFD.  */
  long *indices;
  /* Array large enough to hold a section pointer for each local
     symbol of any input BFD.  */
  asection **sections;
  /* Buffer to hold swapped out symbols.  */
  bfd_byte *symbuf;
  /* And one for symbol section indices.  */
  Elf_External_Sym_Shndx *symshndxbuf;
  /* Number of swapped out symbols in buffer.  */
  size_t symbuf_count;
  /* Number of symbols which fit in symbuf.  */
  size_t symbuf_size;
  /* And same for symshndxbuf.  */
  size_t shndxbuf_size;
  /* Number of STT_FILE syms seen.  */
  size_t filesym_count;
};

/* This struct is used to pass information to elf_link_output_extsym.  */

struct elf_outext_info
{
  bfd_boolean failed;
  bfd_boolean localsyms;
  bfd_boolean need_second_pass;
  bfd_boolean second_pass;
  struct elf_final_link_info *flinfo;
};


/* Support for evaluating a complex relocation.

   Complex relocations are generalized, self-describing relocations.  The
   implementation of them consists of two parts: complex symbols, and the
   relocations themselves.

   The relocations are use a reserved elf-wide relocation type code (R_RELC
   external / BFD_RELOC_RELC internal) and an encoding of relocation field
   information (start bit, end bit, word width, etc) into the addend.  This
   information is extracted from CGEN-generated operand tables within gas.

   Complex symbols are mangled symbols (BSF_RELC external / STT_RELC
   internal) representing prefix-notation expressions, including but not
   limited to those sorts of expressions normally encoded as addends in the
   addend field.  The symbol mangling format is:

   <node> := <literal>
          |  <unary-operator> ':' <node>
          |  <binary-operator> ':' <node> ':' <node>
	  ;

   <literal> := 's' <digits=N> ':' <N character symbol name>
             |  'S' <digits=N> ':' <N character section name>
	     |  '#' <hexdigits>
	     ;

   <binary-operator> := as in C
   <unary-operator> := as in C, plus "0-" for unambiguous negation.  */

static void
set_symbol_value (bfd *bfd_with_globals,
		  Elf_Internal_Sym *isymbuf,
		  size_t locsymcount,
		  size_t symidx,
		  bfd_vma val)
{
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry *h;
  size_t extsymoff = locsymcount;

  if (symidx < locsymcount)
    {
      Elf_Internal_Sym *sym;

      sym = isymbuf + symidx;
      if (ELF_ST_BIND (sym->st_info) == STB_LOCAL)
	{
	  /* It is a local symbol: move it to the
	     "absolute" section and give it a value.  */
	  sym->st_shndx = SHN_ABS;
	  sym->st_value = val;
	  return;
	}
      BFD_ASSERT (elf_bad_symtab (bfd_with_globals));
      extsymoff = 0;
    }

  /* It is a global symbol: set its link type
     to "defined" and give it a value.  */

  sym_hashes = elf_sym_hashes (bfd_with_globals);
  h = sym_hashes [symidx - extsymoff];
  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
  h->root.type = bfd_link_hash_defined;
  h->root.u.def.value = val;
  h->root.u.def.section = bfd_abs_section_ptr;
}

static bfd_boolean
resolve_symbol (const char *name,
		bfd *input_bfd,
		struct elf_final_link_info *flinfo,
		bfd_vma *result,
		Elf_Internal_Sym *isymbuf,
		size_t locsymcount)
{
  Elf_Internal_Sym *sym;
  struct bfd_link_hash_entry *global_entry;
  const char *candidate = NULL;
  Elf_Internal_Shdr *symtab_hdr;
  size_t i;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;

  for (i = 0; i < locsymcount; ++ i)
    {
      sym = isymbuf + i;

      if (ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	continue;

      candidate = bfd_elf_string_from_elf_section (input_bfd,
						   symtab_hdr->sh_link,
						   sym->st_name);
#ifdef DEBUG
      printf ("Comparing string: '%s' vs. '%s' = 0x%lx\n",
	      name, candidate, (unsigned long) sym->st_value);
#endif
      if (candidate && strcmp (candidate, name) == 0)
	{
	  asection *sec = flinfo->sections [i];

	  *result = _bfd_elf_rel_local_sym (input_bfd, sym, &sec, 0);
	  *result += sec->output_offset + sec->output_section->vma;
#ifdef DEBUG
	  printf ("Found symbol with value %8.8lx\n",
		  (unsigned long) *result);
#endif
	  return TRUE;
	}
    }

  /* Hmm, haven't found it yet. perhaps it is a global.  */
  global_entry = bfd_link_hash_lookup (flinfo->info->hash, name,
				       FALSE, FALSE, TRUE);
  if (!global_entry)
    return FALSE;

  if (global_entry->type == bfd_link_hash_defined
      || global_entry->type == bfd_link_hash_defweak)
    {
      *result = (global_entry->u.def.value
		 + global_entry->u.def.section->output_section->vma
		 + global_entry->u.def.section->output_offset);
#ifdef DEBUG
      printf ("Found GLOBAL symbol '%s' with value %8.8lx\n",
	      global_entry->root.string, (unsigned long) *result);
#endif
      return TRUE;
    }

  return FALSE;
}

static bfd_boolean
resolve_section (const char *name,
		 asection *sections,
		 bfd_vma *result)
{
  asection *curr;
  unsigned int len;

  for (curr = sections; curr; curr = curr->next)
    if (strcmp (curr->name, name) == 0)
      {
	*result = curr->vma;
	return TRUE;
      }

  /* Hmm. still haven't found it. try pseudo-section names.  */
  for (curr = sections; curr; curr = curr->next)
    {
      len = strlen (curr->name);
      if (len > strlen (name))
	continue;

      if (strncmp (curr->name, name, len) == 0)
	{
	  if (strncmp (".end", name + len, 4) == 0)
	    {
	      *result = curr->vma + curr->size;
	      return TRUE;
	    }

	  /* Insert more pseudo-section names here, if you like.  */
	}
    }

  return FALSE;
}

static void
undefined_reference (const char *reftype, const char *name)
{
  _bfd_error_handler (_("undefined %s reference in complex symbol: %s"),
		      reftype, name);
}

static bfd_boolean
eval_symbol (bfd_vma *result,
	     const char **symp,
	     bfd *input_bfd,
	     struct elf_final_link_info *flinfo,
	     bfd_vma dot,
	     Elf_Internal_Sym *isymbuf,
	     size_t locsymcount,
	     int signed_p)
{
  size_t len;
  size_t symlen;
  bfd_vma a;
  bfd_vma b;
  char symbuf[4096];
  const char *sym = *symp;
  const char *symend;
  bfd_boolean symbol_is_section = FALSE;

  len = strlen (sym);
  symend = sym + len;

  if (len < 1 || len > sizeof (symbuf))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  switch (* sym)
    {
    case '.':
      *result = dot;
      *symp = sym + 1;
      return TRUE;

    case '#':
      ++sym;
      *result = strtoul (sym, (char **) symp, 16);
      return TRUE;

    case 'S':
      symbol_is_section = TRUE;
    case 's':
      ++sym;
      symlen = strtol (sym, (char **) symp, 10);
      sym = *symp + 1; /* Skip the trailing ':'.  */

      if (symend < sym || symlen + 1 > sizeof (symbuf))
	{
	  bfd_set_error (bfd_error_invalid_operation);
	  return FALSE;
	}

      memcpy (symbuf, sym, symlen);
      symbuf[symlen] = '\0';
      *symp = sym + symlen;

      /* Is it always possible, with complex symbols, that gas "mis-guessed"
	 the symbol as a section, or vice-versa. so we're pretty liberal in our
	 interpretation here; section means "try section first", not "must be a
	 section", and likewise with symbol.  */

      if (symbol_is_section)
	{
	  if (!resolve_section (symbuf, flinfo->output_bfd->sections, result)
	      && !resolve_symbol (symbuf, input_bfd, flinfo, result,
				  isymbuf, locsymcount))
	    {
	      undefined_reference ("section", symbuf);
	      return FALSE;
	    }
	}
      else
	{
	  if (!resolve_symbol (symbuf, input_bfd, flinfo, result,
			       isymbuf, locsymcount)
	      && !resolve_section (symbuf, flinfo->output_bfd->sections,
				   result))
	    {
	      undefined_reference ("symbol", symbuf);
	      return FALSE;
	    }
	}

      return TRUE;

      /* All that remains are operators.  */

#define UNARY_OP(op)						\
  if (strncmp (sym, #op, strlen (#op)) == 0)			\
    {								\
      sym += strlen (#op);					\
      if (*sym == ':')						\
	++sym;							\
      *symp = sym;						\
      if (!eval_symbol (&a, symp, input_bfd, flinfo, dot,	\
			isymbuf, locsymcount, signed_p))	\
	return FALSE;						\
      if (signed_p)						\
	*result = op ((bfd_signed_vma) a);			\
      else							\
	*result = op a;						\
      return TRUE;						\
    }

#define BINARY_OP(op)						\
  if (strncmp (sym, #op, strlen (#op)) == 0)			\
    {								\
      sym += strlen (#op);					\
      if (*sym == ':')						\
	++sym;							\
      *symp = sym;						\
      if (!eval_symbol (&a, symp, input_bfd, flinfo, dot,	\
			isymbuf, locsymcount, signed_p))	\
	return FALSE;						\
      ++*symp;							\
      if (!eval_symbol (&b, symp, input_bfd, flinfo, dot,	\
			isymbuf, locsymcount, signed_p))	\
	return FALSE;						\
      if (signed_p)						\
	*result = ((bfd_signed_vma) a) op ((bfd_signed_vma) b);	\
      else							\
	*result = a op b;					\
      return TRUE;						\
    }

    default:
      UNARY_OP  (0-);
      BINARY_OP (<<);
      BINARY_OP (>>);
      BINARY_OP (==);
      BINARY_OP (!=);
      BINARY_OP (<=);
      BINARY_OP (>=);
      BINARY_OP (&&);
      BINARY_OP (||);
      UNARY_OP  (~);
      UNARY_OP  (!);
      BINARY_OP (*);
      BINARY_OP (/);
      BINARY_OP (%);
      BINARY_OP (^);
      BINARY_OP (|);
      BINARY_OP (&);
      BINARY_OP (+);
      BINARY_OP (-);
      BINARY_OP (<);
      BINARY_OP (>);
#undef UNARY_OP
#undef BINARY_OP
      _bfd_error_handler (_("unknown operator '%c' in complex symbol"), * sym);
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }
}

static void
put_value (bfd_vma size,
	   unsigned long chunksz,
	   bfd *input_bfd,
	   bfd_vma x,
	   bfd_byte *location)
{
  location += (size - chunksz);

  for (; size; size -= chunksz, location -= chunksz, x >>= (chunksz * 8))
    {
      switch (chunksz)
	{
	default:
	case 0:
	  abort ();
	case 1:
	  bfd_put_8 (input_bfd, x, location);
	  break;
	case 2:
	  bfd_put_16 (input_bfd, x, location);
	  break;
	case 4:
	  bfd_put_32 (input_bfd, x, location);
	  break;
	case 8:
#ifdef BFD64
	  bfd_put_64 (input_bfd, x, location);
#else
	  abort ();
#endif
	  break;
	}
    }
}

static bfd_vma
get_value (bfd_vma size,
	   unsigned long chunksz,
	   bfd *input_bfd,
	   bfd_byte *location)
{
  int shift;
  bfd_vma x = 0;

  /* Sanity checks.  */
  BFD_ASSERT (chunksz <= sizeof (x)
	      && size >= chunksz
	      && chunksz != 0
	      && (size % chunksz) == 0
	      && input_bfd != NULL
	      && location != NULL);

  if (chunksz == sizeof (x))
    {
      BFD_ASSERT (size == chunksz);

      /* Make sure that we do not perform an undefined shift operation.
	 We know that size == chunksz so there will only be one iteration
	 of the loop below.  */
      shift = 0;
    }
  else
    shift = 8 * chunksz;

  for (; size; size -= chunksz, location += chunksz)
    {
      switch (chunksz)
	{
	case 1:
	  x = (x << shift) | bfd_get_8 (input_bfd, location);
	  break;
	case 2:
	  x = (x << shift) | bfd_get_16 (input_bfd, location);
	  break;
	case 4:
	  x = (x << shift) | bfd_get_32 (input_bfd, location);
	  break;
#ifdef BFD64
	case 8:
	  x = (x << shift) | bfd_get_64 (input_bfd, location);
	  break;
#endif
	default:
	  abort ();
	}
    }
  return x;
}

static void
decode_complex_addend (unsigned long *start,   /* in bits */
		       unsigned long *oplen,   /* in bits */
		       unsigned long *len,     /* in bits */
		       unsigned long *wordsz,  /* in bytes */
		       unsigned long *chunksz, /* in bytes */
		       unsigned long *lsb0_p,
		       unsigned long *signed_p,
		       unsigned long *trunc_p,
		       unsigned long encoded)
{
  * start     =  encoded        & 0x3F;
  * len       = (encoded >>  6) & 0x3F;
  * oplen     = (encoded >> 12) & 0x3F;
  * wordsz    = (encoded >> 18) & 0xF;
  * chunksz   = (encoded >> 22) & 0xF;
  * lsb0_p    = (encoded >> 27) & 1;
  * signed_p  = (encoded >> 28) & 1;
  * trunc_p   = (encoded >> 29) & 1;
}

bfd_reloc_status_type
bfd_elf_perform_complex_relocation (bfd *input_bfd,
				    asection *input_section ATTRIBUTE_UNUSED,
				    bfd_byte *contents,
				    Elf_Internal_Rela *rel,
				    bfd_vma relocation)
{
  bfd_vma shift, x, mask;
  unsigned long start, oplen, len, wordsz, chunksz, lsb0_p, signed_p, trunc_p;
  bfd_reloc_status_type r;

  /*  Perform this reloc, since it is complex.
      (this is not to say that it necessarily refers to a complex
      symbol; merely that it is a self-describing CGEN based reloc.
      i.e. the addend has the complete reloc information (bit start, end,
      word size, etc) encoded within it.).  */

  decode_complex_addend (&start, &oplen, &len, &wordsz,
			 &chunksz, &lsb0_p, &signed_p,
			 &trunc_p, rel->r_addend);

  mask = (((1L << (len - 1)) - 1) << 1) | 1;

  if (lsb0_p)
    shift = (start + 1) - len;
  else
    shift = (8 * wordsz) - (start + len);

  /* FIXME: octets_per_byte.  */
  x = get_value (wordsz, chunksz, input_bfd, contents + rel->r_offset);

#ifdef DEBUG
  printf ("Doing complex reloc: "
	  "lsb0? %ld, signed? %ld, trunc? %ld, wordsz %ld, "
	  "chunksz %ld, start %ld, len %ld, oplen %ld\n"
	  "    dest: %8.8lx, mask: %8.8lx, reloc: %8.8lx\n",
	  lsb0_p, signed_p, trunc_p, wordsz, chunksz, start, len,
	  oplen, (unsigned long) x, (unsigned long) mask,
	  (unsigned long) relocation);
#endif

  r = bfd_reloc_ok;
  if (! trunc_p)
    /* Now do an overflow check.  */
    r = bfd_check_overflow ((signed_p
			     ? complain_overflow_signed
			     : complain_overflow_unsigned),
			    len, 0, (8 * wordsz),
			    relocation);

  /* Do the deed.  */
  x = (x & ~(mask << shift)) | ((relocation & mask) << shift);

#ifdef DEBUG
  printf ("           relocation: %8.8lx\n"
	  "         shifted mask: %8.8lx\n"
	  " shifted/masked reloc: %8.8lx\n"
	  "               result: %8.8lx\n",
	  (unsigned long) relocation, (unsigned long) (mask << shift),
	  (unsigned long) ((relocation & mask) << shift), (unsigned long) x);
#endif
  /* FIXME: octets_per_byte.  */
  put_value (wordsz, chunksz, input_bfd, x, contents + rel->r_offset);
  return r;
}

/* When performing a relocatable link, the input relocations are
   preserved.  But, if they reference global symbols, the indices
   referenced must be updated.  Update all the relocations found in
   RELDATA.  */

static void
elf_link_adjust_relocs (bfd *abfd,
			struct bfd_elf_section_reloc_data *reldata)
{
  unsigned int i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_byte *erela;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  bfd_vma r_type_mask;
  int r_sym_shift;
  unsigned int count = reldata->count;
  struct elf_link_hash_entry **rel_hash = reldata->hashes;

  if (reldata->hdr->sh_entsize == bed->s->sizeof_rel)
    {
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
    }
  else if (reldata->hdr->sh_entsize == bed->s->sizeof_rela)
    {
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  else
    abort ();

  if (bed->s->int_rels_per_ext_rel > MAX_INT_RELS_PER_EXT_REL)
    abort ();

  if (bed->s->arch_size == 32)
    {
      r_type_mask = 0xff;
      r_sym_shift = 8;
    }
  else
    {
      r_type_mask = 0xffffffff;
      r_sym_shift = 32;
    }

  erela = reldata->hdr->contents;
  for (i = 0; i < count; i++, rel_hash++, erela += reldata->hdr->sh_entsize)
    {
      Elf_Internal_Rela irela[MAX_INT_RELS_PER_EXT_REL];
      unsigned int j;

      if (*rel_hash == NULL)
	continue;

      BFD_ASSERT ((*rel_hash)->indx >= 0);

      (*swap_in) (abfd, erela, irela);
      for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
	irela[j].r_info = ((bfd_vma) (*rel_hash)->indx << r_sym_shift
			   | (irela[j].r_info & r_type_mask));
      (*swap_out) (abfd, irela, erela);
    }
}

struct elf_link_sort_rela
{
  union {
    bfd_vma offset;
    bfd_vma sym_mask;
  } u;
  enum elf_reloc_type_class type;
  /* We use this as an array of size int_rels_per_ext_rel.  */
  Elf_Internal_Rela rela[1];
};

static int
elf_link_sort_cmp1 (const void *A, const void *B)
{
  const struct elf_link_sort_rela *a = (const struct elf_link_sort_rela *) A;
  const struct elf_link_sort_rela *b = (const struct elf_link_sort_rela *) B;
  int relativea, relativeb;

  relativea = a->type == reloc_class_relative;
  relativeb = b->type == reloc_class_relative;

  if (relativea < relativeb)
    return 1;
  if (relativea > relativeb)
    return -1;
  if ((a->rela->r_info & a->u.sym_mask) < (b->rela->r_info & b->u.sym_mask))
    return -1;
  if ((a->rela->r_info & a->u.sym_mask) > (b->rela->r_info & b->u.sym_mask))
    return 1;
  if (a->rela->r_offset < b->rela->r_offset)
    return -1;
  if (a->rela->r_offset > b->rela->r_offset)
    return 1;
  return 0;
}

static int
elf_link_sort_cmp2 (const void *A, const void *B)
{
  const struct elf_link_sort_rela *a = (const struct elf_link_sort_rela *) A;
  const struct elf_link_sort_rela *b = (const struct elf_link_sort_rela *) B;

  if (a->type < b->type)
    return -1;
  if (a->type > b->type)
    return 1;
  if (a->u.offset < b->u.offset)
    return -1;
  if (a->u.offset > b->u.offset)
    return 1;
  if (a->rela->r_offset < b->rela->r_offset)
    return -1;
  if (a->rela->r_offset > b->rela->r_offset)
    return 1;
  return 0;
}

static size_t
elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
{
  asection *dynamic_relocs;
  asection *rela_dyn;
  asection *rel_dyn;
  bfd_size_type count, size;
  size_t i, ret, sort_elt, ext_size;
  bfd_byte *sort, *s_non_relative, *p;
  struct elf_link_sort_rela *sq;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int i2e = bed->s->int_rels_per_ext_rel;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  struct bfd_link_order *lo;
  bfd_vma r_sym_mask;
  bfd_boolean use_rela;

  /* Find a dynamic reloc section.  */
  rela_dyn = bfd_get_section_by_name (abfd, ".rela.dyn");
  rel_dyn  = bfd_get_section_by_name (abfd, ".rel.dyn");
  if (rela_dyn != NULL && rela_dyn->size > 0
      && rel_dyn != NULL && rel_dyn->size > 0)
    {
      bfd_boolean use_rela_initialised = FALSE;

      /* This is just here to stop gcc from complaining.
	 It's initialization checking code is not perfect.  */
      use_rela = TRUE;

      /* Both sections are present.  Examine the sizes
	 of the indirect sections to help us choose.  */
      for (lo = rela_dyn->map_head.link_order; lo != NULL; lo = lo->next)
	if (lo->type == bfd_indirect_link_order)
	  {
	    asection *o = lo->u.indirect.section;

	    if ((o->size % bed->s->sizeof_rela) == 0)
	      {
		if ((o->size % bed->s->sizeof_rel) == 0)
		  /* Section size is divisible by both rel and rela sizes.
		     It is of no help to us.  */
		  ;
		else
		  {
		    /* Section size is only divisible by rela.  */
		    if (use_rela_initialised && (use_rela == FALSE))
		      {
			_bfd_error_handler
			  (_("%B: Unable to sort relocs - they are in more than one size"), abfd);
			bfd_set_error (bfd_error_invalid_operation);
			return 0;
		      }
		    else
		      {
			use_rela = TRUE;
			use_rela_initialised = TRUE;
		      }
		  }
	      }
	    else if ((o->size % bed->s->sizeof_rel) == 0)
	      {
		/* Section size is only divisible by rel.  */
		if (use_rela_initialised && (use_rela == TRUE))
		  {
		    _bfd_error_handler
		      (_("%B: Unable to sort relocs - they are in more than one size"), abfd);
		    bfd_set_error (bfd_error_invalid_operation);
		    return 0;
		  }
		else
		  {
		    use_rela = FALSE;
		    use_rela_initialised = TRUE;
		  }
	      }
	    else
	      {
		/* The section size is not divisible by either - something is wrong.  */
		_bfd_error_handler
		  (_("%B: Unable to sort relocs - they are of an unknown size"), abfd);
		bfd_set_error (bfd_error_invalid_operation);
		return 0;
	      }
	  }

      for (lo = rel_dyn->map_head.link_order; lo != NULL; lo = lo->next)
	if (lo->type == bfd_indirect_link_order)
	  {
	    asection *o = lo->u.indirect.section;

	    if ((o->size % bed->s->sizeof_rela) == 0)
	      {
		if ((o->size % bed->s->sizeof_rel) == 0)
		  /* Section size is divisible by both rel and rela sizes.
		     It is of no help to us.  */
		  ;
		else
		  {
		    /* Section size is only divisible by rela.  */
		    if (use_rela_initialised && (use_rela == FALSE))
		      {
			_bfd_error_handler
			  (_("%B: Unable to sort relocs - they are in more than one size"), abfd);
			bfd_set_error (bfd_error_invalid_operation);
			return 0;
		      }
		    else
		      {
			use_rela = TRUE;
			use_rela_initialised = TRUE;
		      }
		  }
	      }
	    else if ((o->size % bed->s->sizeof_rel) == 0)
	      {
		/* Section size is only divisible by rel.  */
		if (use_rela_initialised && (use_rela == TRUE))
		  {
		    _bfd_error_handler
		      (_("%B: Unable to sort relocs - they are in more than one size"), abfd);
		    bfd_set_error (bfd_error_invalid_operation);
		    return 0;
		  }
		else
		  {
		    use_rela = FALSE;
		    use_rela_initialised = TRUE;
		  }
	      }
	    else
	      {
		/* The section size is not divisible by either - something is wrong.  */
		_bfd_error_handler
		  (_("%B: Unable to sort relocs - they are of an unknown size"), abfd);
		bfd_set_error (bfd_error_invalid_operation);
		return 0;
	      }
	  }

      if (! use_rela_initialised)
	/* Make a guess.  */
	use_rela = TRUE;
    }
  else if (rela_dyn != NULL && rela_dyn->size > 0)
    use_rela = TRUE;
  else if (rel_dyn != NULL && rel_dyn->size > 0)
    use_rela = FALSE;
  else
    return 0;

  if (use_rela)
    {
      dynamic_relocs = rela_dyn;
      ext_size = bed->s->sizeof_rela;
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  else
    {
      dynamic_relocs = rel_dyn;
      ext_size = bed->s->sizeof_rel;
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
    }

  size = 0;
  for (lo = dynamic_relocs->map_head.link_order; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      size += lo->u.indirect.section->size;

  if (size != dynamic_relocs->size)
    return 0;

  sort_elt = (sizeof (struct elf_link_sort_rela)
	      + (i2e - 1) * sizeof (Elf_Internal_Rela));

  count = dynamic_relocs->size / ext_size;
  if (count == 0)
    return 0;
  sort = (bfd_byte *) bfd_zmalloc (sort_elt * count);

  if (sort == NULL)
    {
      (*info->callbacks->warning)
	(info, _("Not enough memory to sort relocations"), 0, abfd, 0, 0);
      return 0;
    }

  if (bed->s->arch_size == 32)
    r_sym_mask = ~(bfd_vma) 0xff;
  else
    r_sym_mask = ~(bfd_vma) 0xffffffff;

  for (lo = dynamic_relocs->map_head.link_order; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	bfd_byte *erel, *erelend;
	asection *o = lo->u.indirect.section;

	if (o->contents == NULL && o->size != 0)
	  {
	    /* This is a reloc section that is being handled as a normal
	       section.  See bfd_section_from_shdr.  We can't combine
	       relocs in this case.  */
	    free (sort);
	    return 0;
	  }
	erel = o->contents;
	erelend = o->contents + o->size;
	/* FIXME: octets_per_byte.  */
	p = sort + o->output_offset / ext_size * sort_elt;

	while (erel < erelend)
	  {
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;

	    (*swap_in) (abfd, erel, s->rela);
	    s->type = (*bed->elf_backend_reloc_type_class) (info, o, s->rela);
	    s->u.sym_mask = r_sym_mask;
	    p += sort_elt;
	    erel += ext_size;
	  }
      }

  qsort (sort, count, sort_elt, elf_link_sort_cmp1);

  for (i = 0, p = sort; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
      if (s->type != reloc_class_relative)
	break;
    }
  ret = i;
  s_non_relative = p;

  sq = (struct elf_link_sort_rela *) s_non_relative;
  for (; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *sp = (struct elf_link_sort_rela *) p;
      if (((sp->rela->r_info ^ sq->rela->r_info) & r_sym_mask) != 0)
	sq = sp;
      sp->u.offset = sq->rela->r_offset;
    }

  qsort (s_non_relative, count - ret, sort_elt, elf_link_sort_cmp2);

  for (lo = dynamic_relocs->map_head.link_order; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	bfd_byte *erel, *erelend;
	asection *o = lo->u.indirect.section;

	erel = o->contents;
	erelend = o->contents + o->size;
	/* FIXME: octets_per_byte.  */
	p = sort + o->output_offset / ext_size * sort_elt;
	while (erel < erelend)
	  {
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
	    (*swap_out) (abfd, s->rela, erel);
	    p += sort_elt;
	    erel += ext_size;
	  }
      }

  free (sort);
  *psec = dynamic_relocs;
  return ret;
}

/* Flush the output symbols to the file.  */

static bfd_boolean
elf_link_flush_output_syms (struct elf_final_link_info *flinfo,
			    const struct elf_backend_data *bed)
{
  if (flinfo->symbuf_count > 0)
    {
      Elf_Internal_Shdr *hdr;
      file_ptr pos;
      bfd_size_type amt;

      hdr = &elf_tdata (flinfo->output_bfd)->symtab_hdr;
      pos = hdr->sh_offset + hdr->sh_size;
      amt = flinfo->symbuf_count * bed->s->sizeof_sym;
      if (bfd_seek (flinfo->output_bfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (flinfo->symbuf, amt, flinfo->output_bfd) != amt)
	return FALSE;

      hdr->sh_size += amt;
      flinfo->symbuf_count = 0;
    }

  return TRUE;
}

/* Add a symbol to the output symbol table.  */

static int
elf_link_output_sym (struct elf_final_link_info *flinfo,
		     const char *name,
		     Elf_Internal_Sym *elfsym,
		     asection *input_sec,
		     struct elf_link_hash_entry *h)
{
  bfd_byte *dest;
  Elf_External_Sym_Shndx *destshndx;
  int (*output_symbol_hook)
    (struct bfd_link_info *, const char *, Elf_Internal_Sym *, asection *,
     struct elf_link_hash_entry *);
  const struct elf_backend_data *bed;

  bed = get_elf_backend_data (flinfo->output_bfd);
  output_symbol_hook = bed->elf_backend_link_output_symbol_hook;
  if (output_symbol_hook != NULL)
    {
      int ret = (*output_symbol_hook) (flinfo->info, name, elfsym, input_sec, h);
      if (ret != 1)
	return ret;
    }

  if (name == NULL || *name == '\0')
    elfsym->st_name = 0;
  else if (input_sec->flags & SEC_EXCLUDE)
    elfsym->st_name = 0;
  else
    {
      elfsym->st_name = (unsigned long) _bfd_stringtab_add (flinfo->symstrtab,
							    name, TRUE, FALSE);
      if (elfsym->st_name == (unsigned long) -1)
	return 0;
    }

  if (flinfo->symbuf_count >= flinfo->symbuf_size)
    {
      if (! elf_link_flush_output_syms (flinfo, bed))
	return 0;
    }

  dest = flinfo->symbuf + flinfo->symbuf_count * bed->s->sizeof_sym;
  destshndx = flinfo->symshndxbuf;
  if (destshndx != NULL)
    {
      if (bfd_get_symcount (flinfo->output_bfd) >= flinfo->shndxbuf_size)
	{
	  bfd_size_type amt;

	  amt = flinfo->shndxbuf_size * sizeof (Elf_External_Sym_Shndx);
	  destshndx = (Elf_External_Sym_Shndx *) bfd_realloc (destshndx,
                                                              amt * 2);
	  if (destshndx == NULL)
	    return 0;
	  flinfo->symshndxbuf = destshndx;
	  memset ((char *) destshndx + amt, 0, amt);
	  flinfo->shndxbuf_size *= 2;
	}
      destshndx += bfd_get_symcount (flinfo->output_bfd);
    }

  bed->s->swap_symbol_out (flinfo->output_bfd, elfsym, dest, destshndx);
  flinfo->symbuf_count += 1;
  bfd_get_symcount (flinfo->output_bfd) += 1;

  return 1;
}

/* Return TRUE if the dynamic symbol SYM in ABFD is supported.  */

static bfd_boolean
check_dynsym (bfd *abfd, Elf_Internal_Sym *sym)
{
  if (sym->st_shndx >= (SHN_LORESERVE & 0xffff)
      && sym->st_shndx < SHN_LORESERVE)
    {
      /* The gABI doesn't support dynamic symbols in output sections
	 beyond 64k.  */
      (*_bfd_error_handler)
	(_("%B: Too many sections: %d (>= %d)"),
	 abfd, bfd_count_sections (abfd), SHN_LORESERVE & 0xffff);
      bfd_set_error (bfd_error_nonrepresentable_section);
      return FALSE;
    }
  return TRUE;
}

/* For DSOs loaded in via a DT_NEEDED entry, emulate ld.so in
   allowing an unsatisfied unversioned symbol in the DSO to match a
   versioned symbol that would normally require an explicit version.
   We also handle the case that a DSO references a hidden symbol
   which may be satisfied by a versioned symbol in another DSO.  */

static bfd_boolean
elf_link_check_versioned_symbol (struct bfd_link_info *info,
				 const struct elf_backend_data *bed,
				 struct elf_link_hash_entry *h)
{
  bfd *abfd;
  struct elf_link_loaded_list *loaded;

  if (!is_elf_hash_table (info->hash))
    return FALSE;

  /* Check indirect symbol.  */
  while (h->root.type == bfd_link_hash_indirect)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  switch (h->root.type)
    {
    default:
      abfd = NULL;
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      abfd = h->root.u.undef.abfd;
      if ((abfd->flags & DYNAMIC) == 0
	  || (elf_dyn_lib_class (abfd) & DYN_DT_NEEDED) == 0)
	return FALSE;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      abfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      abfd = h->root.u.c.p->section->owner;
      break;
    }
  BFD_ASSERT (abfd != NULL);

  for (loaded = elf_hash_table (info)->loaded;
       loaded != NULL;
       loaded = loaded->next)
    {
      bfd *input;
      Elf_Internal_Shdr *hdr;
      bfd_size_type symcount;
      bfd_size_type extsymcount;
      bfd_size_type extsymoff;
      Elf_Internal_Shdr *versymhdr;
      Elf_Internal_Sym *isym;
      Elf_Internal_Sym *isymend;
      Elf_Internal_Sym *isymbuf;
      Elf_External_Versym *ever;
      Elf_External_Versym *extversym;

      input = loaded->abfd;

      /* We check each DSO for a possible hidden versioned definition.  */
      if (input == abfd
	  || (input->flags & DYNAMIC) == 0
	  || elf_dynversym (input) == 0)
	continue;

      hdr = &elf_tdata (input)->dynsymtab_hdr;

      symcount = hdr->sh_size / bed->s->sizeof_sym;
      if (elf_bad_symtab (input))
	{
	  extsymcount = symcount;
	  extsymoff = 0;
	}
      else
	{
	  extsymcount = symcount - hdr->sh_info;
	  extsymoff = hdr->sh_info;
	}

      if (extsymcount == 0)
	continue;

      isymbuf = bfd_elf_get_elf_syms (input, hdr, extsymcount, extsymoff,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	return FALSE;

      /* Read in any version definitions.  */
      versymhdr = &elf_tdata (input)->dynversym_hdr;
      extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
      if (extversym == NULL)
	goto error_ret;

      if (bfd_seek (input, versymhdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bread (extversym, versymhdr->sh_size, input)
	      != versymhdr->sh_size))
	{
	  free (extversym);
	error_ret:
	  free (isymbuf);
	  return FALSE;
	}

      ever = extversym + extsymoff;
      isymend = isymbuf + extsymcount;
      for (isym = isymbuf; isym < isymend; isym++, ever++)
	{
	  const char *name;
	  Elf_Internal_Versym iver;
	  unsigned short version_index;

	  if (ELF_ST_BIND (isym->st_info) == STB_LOCAL
	      || isym->st_shndx == SHN_UNDEF)
	    continue;

	  name = bfd_elf_string_from_elf_section (input,
						  hdr->sh_link,
						  isym->st_name);
	  if (strcmp (name, h->root.root.string) != 0)
	    continue;

	  _bfd_elf_swap_versym_in (input, ever, &iver);

	  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
	      && !(h->def_regular
		   && h->forced_local))
	    {
	      /* If we have a non-hidden versioned sym, then it should
		 have provided a definition for the undefined sym unless
		 it is defined in a non-shared object and forced local.
	       */
	      abort ();
	    }

	  version_index = iver.vs_vers & VERSYM_VERSION;
	  if (version_index == 1 || version_index == 2)
	    {
	      /* This is the base or first version.  We can use it.  */
	      free (extversym);
	      free (isymbuf);
	      return TRUE;
	    }
	}

      free (extversym);
      free (isymbuf);
    }

  return FALSE;
}

/* Add an external symbol to the symbol table.  This is called from
   the hash table traversal routine.  When generating a shared object,
   we go through the symbol table twice.  The first time we output
   anything that might have been forced to local scope in a version
   script.  The second time we output the symbols that are still
   global symbols.  */

static bfd_boolean
elf_link_output_extsym (struct bfd_hash_entry *bh, void *data)
{
  struct elf_link_hash_entry *h = (struct elf_link_hash_entry *) bh;
  struct elf_outext_info *eoinfo = (struct elf_outext_info *) data;
  struct elf_final_link_info *flinfo = eoinfo->flinfo;
  bfd_boolean strip;
  Elf_Internal_Sym sym;
  asection *input_sec;
  const struct elf_backend_data *bed;
  long indx;
  int ret;

  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
    }

  /* Decide whether to output this symbol in this pass.  */
  if (eoinfo->localsyms)
    {
      if (!h->forced_local)
	return TRUE;
      if (eoinfo->second_pass
	  && !((h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak)
	       && h->root.u.def.section->output_section != NULL))
	return TRUE;
    }
  else
    {
      if (h->forced_local)
	return TRUE;
    }

  bed = get_elf_backend_data (flinfo->output_bfd);

  if (h->root.type == bfd_link_hash_undefined)
    {
      /* If we have an undefined symbol reference here then it must have
	 come from a shared library that is being linked in.  (Undefined
	 references in regular files have already been handled unless
	 they are in unreferenced sections which are removed by garbage
	 collection).  */
      bfd_boolean ignore_undef = FALSE;

      /* Some symbols may be special in that the fact that they're
	 undefined can be safely ignored - let backend determine that.  */
      if (bed->elf_backend_ignore_undef_symbol)
	ignore_undef = bed->elf_backend_ignore_undef_symbol (h);

      /* If we are reporting errors for this situation then do so now.  */
      if (!ignore_undef
	  && h->ref_dynamic
	  && (!h->ref_regular || flinfo->info->gc_sections)
	  && !elf_link_check_versioned_symbol (flinfo->info, bed, h)
	  && flinfo->info->unresolved_syms_in_shared_libs != RM_IGNORE)
	{
	  if (!(flinfo->info->callbacks->undefined_symbol
		(flinfo->info, h->root.root.string,
		 h->ref_regular ? NULL : h->root.u.undef.abfd,
		 NULL, 0,
		 (flinfo->info->unresolved_syms_in_shared_libs
		  == RM_GENERATE_ERROR))))
	    {
	      bfd_set_error (bfd_error_bad_value);
	      eoinfo->failed = TRUE;
	      return FALSE;
	    }
	}
    }

  /* We should also warn if a forced local symbol is referenced from
     shared libraries.  */
  if (!flinfo->info->relocatable
      && flinfo->info->executable
      && h->forced_local
      && h->ref_dynamic
      && h->def_regular
      && !h->dynamic_def
      && h->ref_dynamic_nonweak
      && !elf_link_check_versioned_symbol (flinfo->info, bed, h))
    {
      bfd *def_bfd;
      const char *msg;
      struct elf_link_hash_entry *hi = h;

      /* Check indirect symbol.  */
      while (hi->root.type == bfd_link_hash_indirect)
	hi = (struct elf_link_hash_entry *) hi->root.u.i.link;

      if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL)
	msg = _("%B: internal symbol `%s' in %B is referenced by DSO");
      else if (ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
	msg = _("%B: hidden symbol `%s' in %B is referenced by DSO");
      else
	msg = _("%B: local symbol `%s' in %B is referenced by DSO");
      def_bfd = flinfo->output_bfd;
      if (hi->root.u.def.section != bfd_abs_section_ptr)
	def_bfd = hi->root.u.def.section->owner;
      (*_bfd_error_handler) (msg, flinfo->output_bfd, def_bfd,
			     h->root.root.string);
      bfd_set_error (bfd_error_bad_value);
      eoinfo->failed = TRUE;
      return FALSE;
    }

  /* We don't want to output symbols that have never been mentioned by
     a regular file, or that we have been told to strip.  However, if
     h->indx is set to -2, the symbol is used by a reloc and we must
     output it.  */
  if (h->indx == -2)
    strip = FALSE;
  else if ((h->def_dynamic
	    || h->ref_dynamic
	    || h->root.type == bfd_link_hash_new)
	   && !h->def_regular
	   && !h->ref_regular)
    strip = TRUE;
  else if (flinfo->info->strip == strip_all)
    strip = TRUE;
  else if (flinfo->info->strip == strip_some
	   && bfd_hash_lookup (flinfo->info->keep_hash,
			       h->root.root.string, FALSE, FALSE) == NULL)
    strip = TRUE;
  else if ((h->root.type == bfd_link_hash_defined
	    || h->root.type == bfd_link_hash_defweak)
	   && ((flinfo->info->strip_discarded
		&& discarded_section (h->root.u.def.section))
	       || (h->root.u.def.section->owner != NULL
		   && (h->root.u.def.section->owner->flags & BFD_PLUGIN) != 0)))
    strip = TRUE;
  else if ((h->root.type == bfd_link_hash_undefined
	    || h->root.type == bfd_link_hash_undefweak)
	   && h->root.u.undef.abfd != NULL
	   && (h->root.u.undef.abfd->flags & BFD_PLUGIN) != 0)
    strip = TRUE;
  else
    strip = FALSE;

  /* If we're stripping it, and it's not a dynamic symbol, there's
     nothing else to do unless it is a forced local symbol or a
     STT_GNU_IFUNC symbol.  */
  if (strip
      && h->dynindx == -1
      && h->type != STT_GNU_IFUNC
      && !h->forced_local)
    return TRUE;

  sym.st_value = 0;
  sym.st_size = h->size;
  sym.st_other = h->other;
  if (h->forced_local)
    {
      sym.st_info = ELF_ST_INFO (STB_LOCAL, h->type);
      /* Turn off visibility on local symbol.  */
      sym.st_other &= ~ELF_ST_VISIBILITY (-1);
    }
  /* Set STB_GNU_UNIQUE only if symbol is defined in regular object.  */
  else if (h->unique_global && h->def_regular)
    sym.st_info = ELF_ST_INFO (STB_GNU_UNIQUE, h->type);
  else if (h->root.type == bfd_link_hash_undefweak
	   || h->root.type == bfd_link_hash_defweak)
    sym.st_info = ELF_ST_INFO (STB_WEAK, h->type);
  else
    sym.st_info = ELF_ST_INFO (STB_GLOBAL, h->type);
  sym.st_target_internal = h->target_internal;

  switch (h->root.type)
    {
    default:
    case bfd_link_hash_new:
    case bfd_link_hash_warning:
      abort ();
      return FALSE;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      input_sec = bfd_und_section_ptr;
      sym.st_shndx = SHN_UNDEF;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
	input_sec = h->root.u.def.section;
	if (input_sec->output_section != NULL)
	  {
	    if (eoinfo->localsyms && flinfo->filesym_count == 1)
	      {
		bfd_boolean second_pass_sym
		  = (input_sec->owner == flinfo->output_bfd
		     || input_sec->owner == NULL
		     || (input_sec->flags & SEC_LINKER_CREATED) != 0
		     || (input_sec->owner->flags & BFD_LINKER_CREATED) != 0);

		eoinfo->need_second_pass |= second_pass_sym;
		if (eoinfo->second_pass != second_pass_sym)
		  return TRUE;
	      }

	    sym.st_shndx =
	      _bfd_elf_section_from_bfd_section (flinfo->output_bfd,
						 input_sec->output_section);
	    if (sym.st_shndx == SHN_BAD)
	      {
		(*_bfd_error_handler)
		  (_("%B: could not find output section %A for input section %A"),
		   flinfo->output_bfd, input_sec->output_section, input_sec);
		bfd_set_error (bfd_error_nonrepresentable_section);
		eoinfo->failed = TRUE;
		return FALSE;
	      }

	    /* ELF symbols in relocatable files are section relative,
	       but in nonrelocatable files they are virtual
	       addresses.  */
	    sym.st_value = h->root.u.def.value + input_sec->output_offset;
	    if (!flinfo->info->relocatable)
	      {
		sym.st_value += input_sec->output_section->vma;
		if (h->type == STT_TLS)
		  {
		    asection *tls_sec = elf_hash_table (flinfo->info)->tls_sec;
		    if (tls_sec != NULL)
		      sym.st_value -= tls_sec->vma;
		    else
		      {
			/* The TLS section may have been garbage collected.  */
			BFD_ASSERT (flinfo->info->gc_sections
				    && !input_sec->gc_mark);
		      }
		  }
	      }
	  }
	else
	  {
	    BFD_ASSERT (input_sec->owner == NULL
			|| (input_sec->owner->flags & DYNAMIC) != 0);
	    sym.st_shndx = SHN_UNDEF;
	    input_sec = bfd_und_section_ptr;
	  }
      }
      break;

    case bfd_link_hash_common:
      input_sec = h->root.u.c.p->section;
      sym.st_shndx = bed->common_section_index (input_sec);
      sym.st_value = 1 << h->root.u.c.p->alignment_power;
      break;

    case bfd_link_hash_indirect:
      /* These symbols are created by symbol versioning.  They point
	 to the decorated version of the name.  For example, if the
	 symbol foo@@@@GNU_1.2 is the default, which should be used when
	 foo is used with no version, then we add an indirect symbol
	 foo which points to foo@@@@GNU_1.2.  We ignore these symbols,
	 since the indirected symbol is already in the hash table.  */
      return TRUE;
    }

  /* Give the processor backend a chance to tweak the symbol value,
     and also to finish up anything that needs to be done for this
     symbol.  FIXME: Not calling elf_backend_finish_dynamic_symbol for
     forced local syms when non-shared is due to a historical quirk.
     STT_GNU_IFUNC symbol must go through PLT.  */
  if ((h->type == STT_GNU_IFUNC
       && h->def_regular
       && !flinfo->info->relocatable)
      || ((h->dynindx != -1
	   || h->forced_local)
	  && ((flinfo->info->shared
	       && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak))
	      || !h->forced_local)
	  && elf_hash_table (flinfo->info)->dynamic_sections_created))
    {
      if (! ((*bed->elf_backend_finish_dynamic_symbol)
	     (flinfo->output_bfd, flinfo->info, h, &sym)))
	{
	  eoinfo->failed = TRUE;
	  return FALSE;
	}
    }

  /* If we are marking the symbol as undefined, and there are no
     non-weak references to this symbol from a regular object, then
     mark the symbol as weak undefined; if there are non-weak
     references, mark the symbol as strong.  We can't do this earlier,
     because it might not be marked as undefined until the
     finish_dynamic_symbol routine gets through with it.  */
  if (sym.st_shndx == SHN_UNDEF
      && h->ref_regular
      && (ELF_ST_BIND (sym.st_info) == STB_GLOBAL
	  || ELF_ST_BIND (sym.st_info) == STB_WEAK))
    {
      int bindtype;
      unsigned int type = ELF_ST_TYPE (sym.st_info);

      /* Turn an undefined IFUNC symbol into a normal FUNC symbol. */
      if (type == STT_GNU_IFUNC)
	type = STT_FUNC;

      if (h->ref_regular_nonweak)
	bindtype = STB_GLOBAL;
      else
	bindtype = STB_WEAK;
      sym.st_info = ELF_ST_INFO (bindtype, type);
    }

  /* If this is a symbol defined in a dynamic library, don't use the
     symbol size from the dynamic library.  Relinking an executable
     against a new library may introduce gratuitous changes in the
     executable's symbols if we keep the size.  */
  if (sym.st_shndx == SHN_UNDEF
      && !h->def_regular
      && h->def_dynamic)
    sym.st_size = 0;

  /* If a non-weak symbol with non-default visibility is not defined
     locally, it is a fatal error.  */
  if (!flinfo->info->relocatable
      && ELF_ST_VISIBILITY (sym.st_other) != STV_DEFAULT
      && ELF_ST_BIND (sym.st_info) != STB_WEAK
      && h->root.type == bfd_link_hash_undefined
      && !h->def_regular)
    {
      const char *msg;

      if (ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED)
	msg = _("%B: protected symbol `%s' isn't defined");
      else if (ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL)
	msg = _("%B: internal symbol `%s' isn't defined");
      else
	msg = _("%B: hidden symbol `%s' isn't defined");
      (*_bfd_error_handler) (msg, flinfo->output_bfd, h->root.root.string);
      bfd_set_error (bfd_error_bad_value);
      eoinfo->failed = TRUE;
      return FALSE;
    }

  /* If this symbol should be put in the .dynsym section, then put it
     there now.  We already know the symbol index.  We also fill in
     the entry in the .hash section.  */
  if (flinfo->dynsym_sec != NULL
      && h->dynindx != -1
      && elf_hash_table (flinfo->info)->dynamic_sections_created)
    {
      bfd_byte *esym;

      /* Since there is no version information in the dynamic string,
	 if there is no version info in symbol version section, we will
	 have a run-time problem.  */
      if (h->verinfo.verdef == NULL)
	{
	  char *p = strrchr (h->root.root.string, ELF_VER_CHR);

	  if (p && p [1] != '\0')
	    {
	      (*_bfd_error_handler)
		(_("%B: No symbol version section for versioned symbol `%s'"),
		 flinfo->output_bfd, h->root.root.string);
	      eoinfo->failed = TRUE;
	      return FALSE;
	    }
	}

      sym.st_name = h->dynstr_index;
      esym = flinfo->dynsym_sec->contents + h->dynindx * bed->s->sizeof_sym;
      if (!check_dynsym (flinfo->output_bfd, &sym))
	{
	  eoinfo->failed = TRUE;
	  return FALSE;
	}
      bed->s->swap_symbol_out (flinfo->output_bfd, &sym, esym, 0);

      if (flinfo->hash_sec != NULL)
	{
	  size_t hash_entry_size;
	  bfd_byte *bucketpos;
	  bfd_vma chain;
	  size_t bucketcount;
	  size_t bucket;

	  bucketcount = elf_hash_table (flinfo->info)->bucketcount;
	  bucket = h->u.elf_hash_value % bucketcount;

	  hash_entry_size
	    = elf_section_data (flinfo->hash_sec)->this_hdr.sh_entsize;
	  bucketpos = ((bfd_byte *) flinfo->hash_sec->contents
		       + (bucket + 2) * hash_entry_size);
	  chain = bfd_get (8 * hash_entry_size, flinfo->output_bfd, bucketpos);
	  bfd_put (8 * hash_entry_size, flinfo->output_bfd, h->dynindx,
		   bucketpos);
	  bfd_put (8 * hash_entry_size, flinfo->output_bfd, chain,
		   ((bfd_byte *) flinfo->hash_sec->contents
		    + (bucketcount + 2 + h->dynindx) * hash_entry_size));
	}

      if (flinfo->symver_sec != NULL && flinfo->symver_sec->contents != NULL)
	{
	  Elf_Internal_Versym iversym;
	  Elf_External_Versym *eversym;

	  if (!h->def_regular)
	    {
	      if (h->verinfo.verdef == NULL)
		iversym.vs_vers = 0;
	      else
		iversym.vs_vers = h->verinfo.verdef->vd_exp_refno + 1;
	    }
	  else
	    {
	      if (h->verinfo.vertree == NULL)
		iversym.vs_vers = 1;
	      else
		iversym.vs_vers = h->verinfo.vertree->vernum + 1;
	      if (flinfo->info->create_default_symver)
		iversym.vs_vers++;
	    }

	  if (h->hidden)
	    iversym.vs_vers |= VERSYM_HIDDEN;

	  eversym = (Elf_External_Versym *) flinfo->symver_sec->contents;
	  eversym += h->dynindx;
	  _bfd_elf_swap_versym_out (flinfo->output_bfd, &iversym, eversym);
	}
    }

  /* If we're stripping it, then it was just a dynamic symbol, and
     there's nothing else to do.  */
  if (strip || (input_sec->flags & SEC_EXCLUDE) != 0)
    return TRUE;

  indx = bfd_get_symcount (flinfo->output_bfd);
  ret = elf_link_output_sym (flinfo, h->root.root.string, &sym, input_sec, h);
  if (ret == 0)
    {
      eoinfo->failed = TRUE;
      return FALSE;
    }
  else if (ret == 1)
    h->indx = indx;
  else if (h->indx == -2)
    abort();

  return TRUE;
}

/* Return TRUE if special handling is done for relocs in SEC against
   symbols defined in discarded sections.  */

static bfd_boolean
elf_section_ignore_discarded_relocs (asection *sec)
{
  const struct elf_backend_data *bed;

  switch (sec->sec_info_type)
    {
    case SEC_INFO_TYPE_STABS:
    case SEC_INFO_TYPE_EH_FRAME:
      return TRUE;
    default:
      break;
    }

  bed = get_elf_backend_data (sec->owner);
  if (bed->elf_backend_ignore_discarded_relocs != NULL
      && (*bed->elf_backend_ignore_discarded_relocs) (sec))
    return TRUE;

  return FALSE;
}

/* Return a mask saying how ld should treat relocations in SEC against
   symbols defined in discarded sections.  If this function returns
   COMPLAIN set, ld will issue a warning message.  If this function
   returns PRETEND set, and the discarded section was link-once and the
   same size as the kept link-once section, ld will pretend that the
   symbol was actually defined in the kept section.  Otherwise ld will
   zero the reloc (at least that is the intent, but some cooperation by
   the target dependent code is needed, particularly for REL targets).  */

unsigned int
_bfd_elf_default_action_discarded (asection *sec)
{
  if (sec->flags & SEC_DEBUGGING)
    return PRETEND;

  if (strcmp (".eh_frame", sec->name) == 0)
    return 0;

  if (strcmp (".gcc_except_table", sec->name) == 0)
    return 0;

  return COMPLAIN | PRETEND;
}

/* Find a match between a section and a member of a section group.  */

static asection *
match_group_member (asection *sec, asection *group,
		    struct bfd_link_info *info)
{
  asection *first = elf_next_in_group (group);
  asection *s = first;

  while (s != NULL)
    {
      if (bfd_elf_match_symbols_in_sections (s, sec, info))
	return s;

      s = elf_next_in_group (s);
      if (s == first)
	break;
    }

  return NULL;
}

/* Check if the kept section of a discarded section SEC can be used
   to replace it.  Return the replacement if it is OK.  Otherwise return
   NULL.  */

asection *
_bfd_elf_check_kept_section (asection *sec, struct bfd_link_info *info)
{
  asection *kept;

  kept = sec->kept_section;
  if (kept != NULL)
    {
      if ((kept->flags & SEC_GROUP) != 0)
	kept = match_group_member (sec, kept, info);
      if (kept != NULL
	  && ((sec->rawsize != 0 ? sec->rawsize : sec->size)
	      != (kept->rawsize != 0 ? kept->rawsize : kept->size)))
	kept = NULL;
      sec->kept_section = kept;
    }
  return kept;
}

/* Link an input file into the linker output file.  This function
   handles all the sections and relocations of the input file at once.
   This is so that we only have to read the local symbols once, and
   don't have to keep them in memory.  */

static bfd_boolean
elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
{
  int (*relocate_section)
    (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
     Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
  bfd *output_bfd;
  Elf_Internal_Shdr *symtab_hdr;
  size_t locsymcount;
  size_t extsymoff;
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  long *pindex;
  asection **ppsection;
  asection *o;
  const struct elf_backend_data *bed;
  struct elf_link_hash_entry **sym_hashes;
  bfd_size_type address_size;
  bfd_vma r_type_mask;
  int r_sym_shift;
  bfd_boolean have_file_sym = FALSE;

  output_bfd = flinfo->output_bfd;
  bed = get_elf_backend_data (output_bfd);
  relocate_section = bed->elf_backend_relocate_section;

  /* If this is a dynamic object, we don't want to do anything here:
     we don't want the local symbols, and we don't want the section
     contents.  */
  if ((input_bfd->flags & DYNAMIC) != 0)
    return TRUE;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  if (elf_bad_symtab (input_bfd))
    {
      locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      extsymoff = 0;
    }
  else
    {
      locsymcount = symtab_hdr->sh_info;
      extsymoff = symtab_hdr->sh_info;
    }

  /* Read the local symbols.  */
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
  if (isymbuf == NULL && locsymcount != 0)
    {
      isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
				      flinfo->internal_syms,
				      flinfo->external_syms,
				      flinfo->locsym_shndx);
      if (isymbuf == NULL)
	return FALSE;
    }

  /* Find local symbol sections and adjust values of symbols in
     SEC_MERGE sections.  Write out those local symbols we know are
     going into the output file.  */
  isymend = isymbuf + locsymcount;
  for (isym = isymbuf, pindex = flinfo->indices, ppsection = flinfo->sections;
       isym < isymend;
       isym++, pindex++, ppsection++)
    {
      asection *isec;
      const char *name;
      Elf_Internal_Sym osym;
      long indx;
      int ret;

      *pindex = -1;

      if (elf_bad_symtab (input_bfd))
	{
	  if (ELF_ST_BIND (isym->st_info) != STB_LOCAL)
	    {
	      *ppsection = NULL;
	      continue;
	    }
	}

      if (isym->st_shndx == SHN_UNDEF)
	isec = bfd_und_section_ptr;
      else if (isym->st_shndx == SHN_ABS)
	isec = bfd_abs_section_ptr;
      else if (isym->st_shndx == SHN_COMMON)
	isec = bfd_com_section_ptr;
      else
	{
	  isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);
	  if (isec == NULL)
	    {
	      /* Don't attempt to output symbols with st_shnx in the
		 reserved range other than SHN_ABS and SHN_COMMON.  */
	      *ppsection = NULL;
	      continue;
	    }
	  else if (isec->sec_info_type == SEC_INFO_TYPE_MERGE
		   && ELF_ST_TYPE (isym->st_info) != STT_SECTION)
	    isym->st_value =
	      _bfd_merged_section_offset (output_bfd, &isec,
					  elf_section_data (isec)->sec_info,
					  isym->st_value);
	}

      *ppsection = isec;

      /* Don't output the first, undefined, symbol.  */
      if (ppsection == flinfo->sections)
	continue;

      if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
	{
	  /* We never output section symbols.  Instead, we use the
	     section symbol of the corresponding section in the output
	     file.  */
	  continue;
	}

      /* If we are stripping all symbols, we don't want to output this
	 one.  */
      if (flinfo->info->strip == strip_all)
	continue;

      /* If we are discarding all local symbols, we don't want to
	 output this one.  If we are generating a relocatable output
	 file, then some of the local symbols may be required by
	 relocs; we output them below as we discover that they are
	 needed.  */
      if (flinfo->info->discard == discard_all)
	continue;

      /* If this symbol is defined in a section which we are
	 discarding, we don't need to keep it.  */
      if (isym->st_shndx != SHN_UNDEF
	  && isym->st_shndx < SHN_LORESERVE
	  && bfd_section_removed_from_list (output_bfd,
					    isec->output_section))
	continue;

      /* Get the name of the symbol.  */
      name = bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	return FALSE;

      /* See if we are discarding symbols with this name.  */
      if ((flinfo->info->strip == strip_some
	   && (bfd_hash_lookup (flinfo->info->keep_hash, name, FALSE, FALSE)
	       == NULL))
	  || (((flinfo->info->discard == discard_sec_merge
		&& (isec->flags & SEC_MERGE) && !flinfo->info->relocatable)
	       || flinfo->info->discard == discard_l)
	      && bfd_is_local_label_name (input_bfd, name)))
	continue;

      if (ELF_ST_TYPE (isym->st_info) == STT_FILE)
	{
	  have_file_sym = TRUE;
	  flinfo->filesym_count += 1;
	}
      if (!have_file_sym)
	{
	  /* In the absence of debug info, bfd_find_nearest_line uses
	     FILE symbols to determine the source file for local
	     function symbols.  Provide a FILE symbol here if input
	     files lack such, so that their symbols won't be
	     associated with a previous input file.  It's not the
	     source file, but the best we can do.  */
	  have_file_sym = TRUE;
	  flinfo->filesym_count += 1;
	  memset (&osym, 0, sizeof (osym));
	  osym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
	  osym.st_shndx = SHN_ABS;
	  if (!elf_link_output_sym (flinfo, input_bfd->filename, &osym,
				    bfd_abs_section_ptr, NULL))
	    return FALSE;
	}

      osym = *isym;

      /* Adjust the section index for the output file.  */
      osym.st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
							 isec->output_section);
      if (osym.st_shndx == SHN_BAD)
	return FALSE;

      /* ELF symbols in relocatable files are section relative, but
	 in executable files they are virtual addresses.  Note that
	 this code assumes that all ELF sections have an associated
	 BFD section with a reasonable value for output_offset; below
	 we assume that they also have a reasonable value for
	 output_section.  Any special sections must be set up to meet
	 these requirements.  */
      osym.st_value += isec->output_offset;
      if (!flinfo->info->relocatable)
	{
	  osym.st_value += isec->output_section->vma;
	  if (ELF_ST_TYPE (osym.st_info) == STT_TLS)
	    {
	      /* STT_TLS symbols are relative to PT_TLS segment base.  */
	      BFD_ASSERT (elf_hash_table (flinfo->info)->tls_sec != NULL);
	      osym.st_value -= elf_hash_table (flinfo->info)->tls_sec->vma;
	    }
	}

      indx = bfd_get_symcount (output_bfd);
      ret = elf_link_output_sym (flinfo, name, &osym, isec, NULL);
      if (ret == 0)
	return FALSE;
      else if (ret == 1)
	*pindex = indx;
    }

  if (bed->s->arch_size == 32)
    {
      r_type_mask = 0xff;
      r_sym_shift = 8;
      address_size = 4;
    }
  else
    {
      r_type_mask = 0xffffffff;
      r_sym_shift = 32;
      address_size = 8;
    }

  /* Relocate the contents of each section.  */
  sym_hashes = elf_sym_hashes (input_bfd);
  for (o = input_bfd->sections; o != NULL; o = o->next)
    {
      bfd_byte *contents;

      if (! o->linker_mark)
	{
	  /* This section was omitted from the link.  */
	  continue;
	}

      if (flinfo->info->relocatable
	  && (o->flags & (SEC_LINKER_CREATED | SEC_GROUP)) == SEC_GROUP)
	{
	  /* Deal with the group signature symbol.  */
	  struct bfd_elf_section_data *sec_data = elf_section_data (o);
	  unsigned long symndx = sec_data->this_hdr.sh_info;
	  asection *osec = o->output_section;

	  if (symndx >= locsymcount
	      || (elf_bad_symtab (input_bfd)
		  && flinfo->sections[symndx] == NULL))
	    {
	      struct elf_link_hash_entry *h = sym_hashes[symndx - extsymoff];
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	      /* Arrange for symbol to be output.  */
	      h->indx = -2;
	      elf_section_data (osec)->this_hdr.sh_info = -2;
	    }
	  else if (ELF_ST_TYPE (isymbuf[symndx].st_info) == STT_SECTION)
	    {
	      /* We'll use the output section target_index.  */
	      asection *sec = flinfo->sections[symndx]->output_section;
	      elf_section_data (osec)->this_hdr.sh_info = sec->target_index;
	    }
	  else
	    {
	      if (flinfo->indices[symndx] == -1)
		{
		  /* Otherwise output the local symbol now.  */
		  Elf_Internal_Sym sym = isymbuf[symndx];
		  asection *sec = flinfo->sections[symndx]->output_section;
		  const char *name;
		  long indx;
		  int ret;

		  name = bfd_elf_string_from_elf_section (input_bfd,
							  symtab_hdr->sh_link,
							  sym.st_name);
		  if (name == NULL)
		    return FALSE;

		  sym.st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
								    sec);
		  if (sym.st_shndx == SHN_BAD)
		    return FALSE;

		  sym.st_value += o->output_offset;

		  indx = bfd_get_symcount (output_bfd);
		  ret = elf_link_output_sym (flinfo, name, &sym, o, NULL);
		  if (ret == 0)
		    return FALSE;
		  else if (ret == 1)
		    flinfo->indices[symndx] = indx;
		  else
		    abort ();
		}
	      elf_section_data (osec)->this_hdr.sh_info
		= flinfo->indices[symndx];
	    }
	}

      if ((o->flags & SEC_HAS_CONTENTS) == 0
	  || (o->size == 0 && (o->flags & SEC_RELOC) == 0))
	continue;

      if ((o->flags & SEC_LINKER_CREATED) != 0)
	{
	  /* Section was created by _bfd_elf_link_create_dynamic_sections
	     or somesuch.  */
	  continue;
	}

      /* Get the contents of the section.  They have been cached by a
	 relaxation routine.  Note that o is a section in an input
	 file, so the contents field will not have been set by any of
	 the routines which work on output files.  */
      if (elf_section_data (o)->this_hdr.contents != NULL)
	contents = elf_section_data (o)->this_hdr.contents;
      else
	{
	  contents = flinfo->contents;
	  if (! bfd_get_full_section_contents (input_bfd, o, &contents))
	    return FALSE;
	}

      if ((o->flags & SEC_RELOC) != 0)
	{
	  Elf_Internal_Rela *internal_relocs;
	  Elf_Internal_Rela *rel, *relend;
	  int action_discarded;
	  int ret;

	  /* Get the swapped relocs.  */
	  internal_relocs
	    = _bfd_elf_link_read_relocs (input_bfd, o, flinfo->external_relocs,
					 flinfo->internal_relocs, FALSE);
	  if (internal_relocs == NULL
	      && o->reloc_count > 0)
	    return FALSE;

	  /* We need to reverse-copy input .ctors/.dtors sections if
	     they are placed in .init_array/.finit_array for output.  */
	  if (o->size > address_size
	      && ((strncmp (o->name, ".ctors", 6) == 0
		   && strcmp (o->output_section->name,
			      ".init_array") == 0)
		  || (strncmp (o->name, ".dtors", 6) == 0
		      && strcmp (o->output_section->name,
				 ".fini_array") == 0))
	      && (o->name[6] == 0 || o->name[6] == '.'))
	    {
	      if (o->size != o->reloc_count * address_size)
		{
		  (*_bfd_error_handler)
		    (_("error: %B: size of section %A is not "
		       "multiple of address size"),
		     input_bfd, o);
		  bfd_set_error (bfd_error_on_input);
		  return FALSE;
		}
	      o->flags |= SEC_ELF_REVERSE_COPY;
	    }

	  action_discarded = -1;
	  if (!elf_section_ignore_discarded_relocs (o))
	    action_discarded = (*bed->action_discarded) (o);

	  /* Run through the relocs evaluating complex reloc symbols and
	     looking for relocs against symbols from discarded sections
	     or section symbols from removed link-once sections.
	     Complain about relocs against discarded sections.  Zero
	     relocs against removed link-once sections.  */

	  rel = internal_relocs;
	  relend = rel + o->reloc_count * bed->s->int_rels_per_ext_rel;
	  for ( ; rel < relend; rel++)
	    {
	      unsigned long r_symndx = rel->r_info >> r_sym_shift;
	      unsigned int s_type;
	      asection **ps, *sec;
	      struct elf_link_hash_entry *h = NULL;
	      const char *sym_name;

	      if (r_symndx == STN_UNDEF)
		continue;

	      if (r_symndx >= locsymcount
		  || (elf_bad_symtab (input_bfd)
		      && flinfo->sections[r_symndx] == NULL))
		{
		  h = sym_hashes[r_symndx - extsymoff];

		  /* Badly formatted input files can contain relocs that
		     reference non-existant symbols.  Check here so that
		     we do not seg fault.  */
		  if (h == NULL)
		    {
		      char buffer [32];

		      sprintf_vma (buffer, rel->r_info);
		      (*_bfd_error_handler)
			(_("error: %B contains a reloc (0x%s) for section %A "
			   "that references a non-existent global symbol"),
			 input_bfd, o, buffer);
		      bfd_set_error (bfd_error_bad_value);
		      return FALSE;
		    }

		  while (h->root.type == bfd_link_hash_indirect
			 || h->root.type == bfd_link_hash_warning)
		    h = (struct elf_link_hash_entry *) h->root.u.i.link;

		  s_type = h->type;

		  ps = NULL;
		  if (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak)
		    ps = &h->root.u.def.section;

		  sym_name = h->root.root.string;
		}
	      else
		{
		  Elf_Internal_Sym *sym = isymbuf + r_symndx;

		  s_type = ELF_ST_TYPE (sym->st_info);
		  ps = &flinfo->sections[r_symndx];
		  sym_name = bfd_elf_sym_name (input_bfd, symtab_hdr,
					       sym, *ps);
		}

	      if ((s_type == STT_RELC || s_type == STT_SRELC)
		  && !flinfo->info->relocatable)
		{
		  bfd_vma val;
		  bfd_vma dot = (rel->r_offset
				 + o->output_offset + o->output_section->vma);
#ifdef DEBUG
		  printf ("Encountered a complex symbol!");
		  printf (" (input_bfd %s, section %s, reloc %ld\n",
			  input_bfd->filename, o->name,
			  (long) (rel - internal_relocs));
		  printf (" symbol: idx  %8.8lx, name %s\n",
			  r_symndx, sym_name);
		  printf (" reloc : info %8.8lx, addr %8.8lx\n",
			  (unsigned long) rel->r_info,
			  (unsigned long) rel->r_offset);
#endif
		  if (!eval_symbol (&val, &sym_name, input_bfd, flinfo, dot,
				    isymbuf, locsymcount, s_type == STT_SRELC))
		    return FALSE;

		  /* Symbol evaluated OK.  Update to absolute value.  */
		  set_symbol_value (input_bfd, isymbuf, locsymcount,
				    r_symndx, val);
		  continue;
		}

	      if (action_discarded != -1 && ps != NULL)
		{
		  /* Complain if the definition comes from a
		     discarded section.  */
		  if ((sec = *ps) != NULL && discarded_section (sec))
		    {
		      BFD_ASSERT (r_symndx != STN_UNDEF);
		      if (action_discarded & COMPLAIN)
			(*flinfo->info->callbacks->einfo)
			  (_("%X`%s' referenced in section `%A' of %B: "
			     "defined in discarded section `%A' of %B\n"),
			   sym_name, o, input_bfd, sec, sec->owner);

		      /* Try to do the best we can to support buggy old
			 versions of gcc.  Pretend that the symbol is
			 really defined in the kept linkonce section.
			 FIXME: This is quite broken.  Modifying the
			 symbol here means we will be changing all later
			 uses of the symbol, not just in this section.  */
		      if (action_discarded & PRETEND)
			{
			  asection *kept;

			  kept = _bfd_elf_check_kept_section (sec,
							      flinfo->info);
			  if (kept != NULL)
			    {
			      *ps = kept;
			      continue;
			    }
			}
		    }
		}
	    }

	  /* Relocate the section by invoking a back end routine.

	     The back end routine is responsible for adjusting the
	     section contents as necessary, and (if using Rela relocs
	     and generating a relocatable output file) adjusting the
	     reloc addend as necessary.

	     The back end routine does not have to worry about setting
	     the reloc address or the reloc symbol index.

	     The back end routine is given a pointer to the swapped in
	     internal symbols, and can access the hash table entries
	     for the external symbols via elf_sym_hashes (input_bfd).

	     When generating relocatable output, the back end routine
	     must handle STB_LOCAL/STT_SECTION symbols specially.  The
	     output symbol is going to be a section symbol
	     corresponding to the output section, which will require
	     the addend to be adjusted.  */

	  ret = (*relocate_section) (output_bfd, flinfo->info,
				     input_bfd, o, contents,
				     internal_relocs,
				     isymbuf,
				     flinfo->sections);
	  if (!ret)
	    return FALSE;

	  if (ret == 2
	      || flinfo->info->relocatable
	      || flinfo->info->emitrelocations)
	    {
	      Elf_Internal_Rela *irela;
	      Elf_Internal_Rela *irelaend, *irelamid;
	      bfd_vma last_offset;
	      struct elf_link_hash_entry **rel_hash;
	      struct elf_link_hash_entry **rel_hash_list, **rela_hash_list;
	      Elf_Internal_Shdr *input_rel_hdr, *input_rela_hdr;
	      unsigned int next_erel;
	      bfd_boolean rela_normal;
	      struct bfd_elf_section_data *esdi, *esdo;

	      esdi = elf_section_data (o);
	      esdo = elf_section_data (o->output_section);
	      rela_normal = FALSE;

	      /* Adjust the reloc addresses and symbol indices.  */

	      irela = internal_relocs;
	      irelaend = irela + o->reloc_count * bed->s->int_rels_per_ext_rel;
	      rel_hash = esdo->rel.hashes + esdo->rel.count;
	      /* We start processing the REL relocs, if any.  When we reach
		 IRELAMID in the loop, we switch to the RELA relocs.  */
	      irelamid = irela;
	      if (esdi->rel.hdr != NULL)
		irelamid += (NUM_SHDR_ENTRIES (esdi->rel.hdr)
			     * bed->s->int_rels_per_ext_rel);
	      rel_hash_list = rel_hash;
	      rela_hash_list = NULL;
	      last_offset = o->output_offset;
	      if (!flinfo->info->relocatable)
		last_offset += o->output_section->vma;
	      for (next_erel = 0; irela < irelaend; irela++, next_erel++)
		{
		  unsigned long r_symndx;
		  asection *sec;
		  Elf_Internal_Sym sym;

		  if (next_erel == bed->s->int_rels_per_ext_rel)
		    {
		      rel_hash++;
		      next_erel = 0;
		    }

		  if (irela == irelamid)
		    {
		      rel_hash = esdo->rela.hashes + esdo->rela.count;
		      rela_hash_list = rel_hash;
		      rela_normal = bed->rela_normal;
		    }

		  irela->r_offset = _bfd_elf_section_offset (output_bfd,
							     flinfo->info, o,
							     irela->r_offset);
		  if (irela->r_offset >= (bfd_vma) -2)
		    {
		      /* This is a reloc for a deleted entry or somesuch.
			 Turn it into an R_*_NONE reloc, at the same
			 offset as the last reloc.  elf_eh_frame.c and
			 bfd_elf_discard_info rely on reloc offsets
			 being ordered.  */
		      irela->r_offset = last_offset;
		      irela->r_info = 0;
		      irela->r_addend = 0;
		      continue;
		    }

		  irela->r_offset += o->output_offset;

		  /* Relocs in an executable have to be virtual addresses.  */
		  if (!flinfo->info->relocatable)
		    irela->r_offset += o->output_section->vma;

		  last_offset = irela->r_offset;

		  r_symndx = irela->r_info >> r_sym_shift;
		  if (r_symndx == STN_UNDEF)
		    continue;

		  if (r_symndx >= locsymcount
		      || (elf_bad_symtab (input_bfd)
			  && flinfo->sections[r_symndx] == NULL))
		    {
		      struct elf_link_hash_entry *rh;
		      unsigned long indx;

		      /* This is a reloc against a global symbol.  We
			 have not yet output all the local symbols, so
			 we do not know the symbol index of any global
			 symbol.  We set the rel_hash entry for this
			 reloc to point to the global hash table entry
			 for this symbol.  The symbol index is then
			 set at the end of bfd_elf_final_link.  */
		      indx = r_symndx - extsymoff;
		      rh = elf_sym_hashes (input_bfd)[indx];
		      while (rh->root.type == bfd_link_hash_indirect
			     || rh->root.type == bfd_link_hash_warning)
			rh = (struct elf_link_hash_entry *) rh->root.u.i.link;

		      /* Setting the index to -2 tells
			 elf_link_output_extsym that this symbol is
			 used by a reloc.  */
		      BFD_ASSERT (rh->indx < 0);
		      rh->indx = -2;

		      *rel_hash = rh;

		      continue;
		    }

		  /* This is a reloc against a local symbol.  */

		  *rel_hash = NULL;
		  sym = isymbuf[r_symndx];
		  sec = flinfo->sections[r_symndx];
		  if (ELF_ST_TYPE (sym.st_info) == STT_SECTION)
		    {
		      /* I suppose the backend ought to fill in the
			 section of any STT_SECTION symbol against a
			 processor specific section.  */
		      r_symndx = STN_UNDEF;
		      if (bfd_is_abs_section (sec))
			;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec = sec->output_section;

			  /* If we have discarded a section, the output
			     section will be the absolute section.  In
			     case of discarded SEC_MERGE sections, use
			     the kept section.  relocate_section should
			     have already handled discarded linkonce
			     sections.  */
			  if (bfd_is_abs_section (osec)
			      && sec->kept_section != NULL
			      && sec->kept_section->output_section != NULL)
			    {
			      osec = sec->kept_section->output_section;
			      irela->r_addend -= osec->vma;
			    }

			  if (!bfd_is_abs_section (osec))
			    {
			      r_symndx = osec->target_index;
			      if (r_symndx == STN_UNDEF)
				{
				  irela->r_addend += osec->vma;
				  osec = _bfd_nearby_section (output_bfd, osec,
							      osec->vma);
				  irela->r_addend -= osec->vma;
				  r_symndx = osec->target_index;
				}
			    }
			}

		      /* Adjust the addend according to where the
			 section winds up in the output section.  */
		      if (rela_normal)
			irela->r_addend += sec->output_offset;
		    }
		  else
		    {
		      if (flinfo->indices[r_symndx] == -1)
			{
			  unsigned long shlink;
			  const char *name;
			  asection *osec;
			  long indx;

			  if (flinfo->info->strip == strip_all)
			    {
			      /* You can't do ld -r -s.  */
			      bfd_set_error (bfd_error_invalid_operation);
			      return FALSE;
			    }

			  /* This symbol was skipped earlier, but
			     since it is needed by a reloc, we
			     must output it now.  */
			  shlink = symtab_hdr->sh_link;
			  name = (bfd_elf_string_from_elf_section
				  (input_bfd, shlink, sym.st_name));
			  if (name == NULL)
			    return FALSE;

			  osec = sec->output_section;
			  sym.st_shndx =
			    _bfd_elf_section_from_bfd_section (output_bfd,
							       osec);
			  if (sym.st_shndx == SHN_BAD)
			    return FALSE;

			  sym.st_value += sec->output_offset;
			  if (!flinfo->info->relocatable)
			    {
			      sym.st_value += osec->vma;
			      if (ELF_ST_TYPE (sym.st_info) == STT_TLS)
				{
				  /* STT_TLS symbols are relative to PT_TLS
				     segment base.  */
				  BFD_ASSERT (elf_hash_table (flinfo->info)
					      ->tls_sec != NULL);
				  sym.st_value -= (elf_hash_table (flinfo->info)
						   ->tls_sec->vma);
				}
			    }

			  indx = bfd_get_symcount (output_bfd);
			  ret = elf_link_output_sym (flinfo, name, &sym, sec,
						     NULL);
			  if (ret == 0)
			    return FALSE;
			  else if (ret == 1)
			    flinfo->indices[r_symndx] = indx;
			  else
			    abort ();
			}

		      r_symndx = flinfo->indices[r_symndx];
		    }

		  irela->r_info = ((bfd_vma) r_symndx << r_sym_shift
				   | (irela->r_info & r_type_mask));
		}

	      /* Swap out the relocs.  */
	      input_rel_hdr = esdi->rel.hdr;
	      if (input_rel_hdr && input_rel_hdr->sh_size != 0)
		{
		  if (!bed->elf_backend_emit_relocs (output_bfd, o,
						     input_rel_hdr,
						     internal_relocs,
						     rel_hash_list))
		    return FALSE;
		  internal_relocs += (NUM_SHDR_ENTRIES (input_rel_hdr)
				      * bed->s->int_rels_per_ext_rel);
		  rel_hash_list += NUM_SHDR_ENTRIES (input_rel_hdr);
		}

	      input_rela_hdr = esdi->rela.hdr;
	      if (input_rela_hdr && input_rela_hdr->sh_size != 0)
		{
		  if (!bed->elf_backend_emit_relocs (output_bfd, o,
						     input_rela_hdr,
						     internal_relocs,
						     rela_hash_list))
		    return FALSE;
		}
	    }
	}

      /* Write out the modified section contents.  */
      if (bed->elf_backend_write_section
	  && (*bed->elf_backend_write_section) (output_bfd, flinfo->info, o,
						contents))
	{
	  /* Section written out.  */
	}
      else switch (o->sec_info_type)
	{
	case SEC_INFO_TYPE_STABS:
	  if (! (_bfd_write_section_stabs
		 (output_bfd,
		  &elf_hash_table (flinfo->info)->stab_info,
		  o, &elf_section_data (o)->sec_info, contents)))
	    return FALSE;
	  break;
	case SEC_INFO_TYPE_MERGE:
	  if (! _bfd_write_merged_section (output_bfd, o,
					   elf_section_data (o)->sec_info))
	    return FALSE;
	  break;
	case SEC_INFO_TYPE_EH_FRAME:
	  {
	    if (! _bfd_elf_write_section_eh_frame (output_bfd, flinfo->info,
						   o, contents))
	      return FALSE;
	  }
	  break;
	default:
	  {
	    /* FIXME: octets_per_byte.  */
	    if (! (o->flags & SEC_EXCLUDE))
	      {
		file_ptr offset = (file_ptr) o->output_offset;
		bfd_size_type todo = o->size;
		if ((o->flags & SEC_ELF_REVERSE_COPY))
		  {
		    /* Reverse-copy input section to output.  */
		    do
		      {
			todo -= address_size;
			if (! bfd_set_section_contents (output_bfd,
							o->output_section,
							contents + todo,
							offset,
							address_size))
			  return FALSE;
			if (todo == 0)
			  break;
			offset += address_size;
		      }
		    while (1);
		  }
		else if (! bfd_set_section_contents (output_bfd,
						     o->output_section,
						     contents,
						     offset, todo))
		  return FALSE;
	      }
	  }
	  break;
	}
    }

  return TRUE;
}

/* Generate a reloc when linking an ELF file.  This is a reloc
   requested by the linker, and does not come from any input file.  This
   is used to build constructor and destructor tables when linking
   with -Ur.  */

static bfd_boolean
elf_reloc_link_order (bfd *output_bfd,
		      struct bfd_link_info *info,
		      asection *output_section,
		      struct bfd_link_order *link_order)
{
  reloc_howto_type *howto;
  long indx;
  bfd_vma offset;
  bfd_vma addend;
  struct bfd_elf_section_reloc_data *reldata;
  struct elf_link_hash_entry **rel_hash_ptr;
  Elf_Internal_Shdr *rel_hdr;
  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
  Elf_Internal_Rela irel[MAX_INT_RELS_PER_EXT_REL];
  bfd_byte *erel;
  unsigned int i;
  struct bfd_elf_section_data *esdo = elf_section_data (output_section);

  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
  if (howto == NULL)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  addend = link_order->u.reloc.p->addend;

  if (esdo->rel.hdr)
    reldata = &esdo->rel;
  else if (esdo->rela.hdr)
    reldata = &esdo->rela;
  else
    {
      reldata = NULL;
      BFD_ASSERT (0);
    }

  /* Figure out the symbol index.  */
  rel_hash_ptr = reldata->hashes + reldata->count;
  if (link_order->type == bfd_section_reloc_link_order)
    {
      indx = link_order->u.reloc.p->u.section->target_index;
      BFD_ASSERT (indx != 0);
      *rel_hash_ptr = NULL;
    }
  else
    {
      struct elf_link_hash_entry *h;

      /* Treat a reloc against a defined symbol as though it were
	 actually against the section.  */
      h = ((struct elf_link_hash_entry *)
	   bfd_wrapped_link_hash_lookup (output_bfd, info,
					 link_order->u.reloc.p->u.name,
					 FALSE, FALSE, TRUE));
      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak))
	{
	  asection *section;

	  section = h->root.u.def.section;
	  indx = section->output_section->target_index;
	  *rel_hash_ptr = NULL;
	  /* It seems that we ought to add the symbol value to the
	     addend here, but in practice it has already been added
	     because it was passed to constructor_callback.  */
	  addend += section->output_section->vma + section->output_offset;
	}
      else if (h != NULL)
	{
	  /* Setting the index to -2 tells elf_link_output_extsym that
	     this symbol is used by a reloc.  */
	  h->indx = -2;
	  *rel_hash_ptr = h;
	  indx = 0;
	}
      else
	{
	  if (! ((*info->callbacks->unattached_reloc)
		 (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))
	    return FALSE;
	  indx = 0;
	}
    }

  /* If this is an inplace reloc, we must write the addend into the
     object file.  */
  if (howto->partial_inplace && addend != 0)
    {
      bfd_size_type size;
      bfd_reloc_status_type rstat;
      bfd_byte *buf;
      bfd_boolean ok;
      const char *sym_name;

      size = (bfd_size_type) bfd_get_reloc_size (howto);
      buf = (bfd_byte *) bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;
      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);
      switch (rstat)
	{
	case bfd_reloc_ok:
	  break;

	default:
	case bfd_reloc_outofrange:
	  abort ();

	case bfd_reloc_overflow:
	  if (link_order->type == bfd_section_reloc_link_order)
	    sym_name = bfd_section_name (output_bfd,
					 link_order->u.reloc.p->u.section);
	  else
	    sym_name = link_order->u.reloc.p->u.name;
	  if (! ((*info->callbacks->reloc_overflow)
		 (info, NULL, sym_name, howto->name, addend, NULL,
		  NULL, (bfd_vma) 0)))
	    {
	      free (buf);
	      return FALSE;
	    }
	  break;
	}
      ok = bfd_set_section_contents (output_bfd, output_section, buf,
				     link_order->offset, size);
      free (buf);
      if (! ok)
	return FALSE;
    }

  /* The address of a reloc is relative to the section in a
     relocatable file, and is a virtual address in an executable
     file.  */
  offset = link_order->offset;
  if (! info->relocatable)
    offset += output_section->vma;

  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
    {
      irel[i].r_offset = offset;
      irel[i].r_info = 0;
      irel[i].r_addend = 0;
    }
  if (bed->s->arch_size == 32)
    irel[0].r_info = ELF32_R_INFO (indx, howto->type);
  else
    irel[0].r_info = ELF64_R_INFO (indx, howto->type);

  rel_hdr = reldata->hdr;
  erel = rel_hdr->contents;
  if (rel_hdr->sh_type == SHT_REL)
    {
      erel += reldata->count * bed->s->sizeof_rel;
      (*bed->s->swap_reloc_out) (output_bfd, irel, erel);
    }
  else
    {
      irel[0].r_addend = addend;
      erel += reldata->count * bed->s->sizeof_rela;
      (*bed->s->swap_reloca_out) (output_bfd, irel, erel);
    }

  ++reldata->count;

  return TRUE;
}


/* Get the output vma of the section pointed to by the sh_link field.  */

static bfd_vma
elf_get_linked_section_vma (struct bfd_link_order *p)
{
  Elf_Internal_Shdr **elf_shdrp;
  asection *s;
  int elfsec;

  s = p->u.indirect.section;
  elf_shdrp = elf_elfsections (s->owner);
  elfsec = _bfd_elf_section_from_bfd_section (s->owner, s);
  elfsec = elf_shdrp[elfsec]->sh_link;
  /* PR 290:
     The Intel C compiler generates SHT_IA_64_UNWIND with
     SHF_LINK_ORDER.  But it doesn't set the sh_link or
     sh_info fields.  Hence we could get the situation
     where elfsec is 0.  */
  if (elfsec == 0)
    {
      const struct elf_backend_data *bed
	= get_elf_backend_data (s->owner);
      if (bed->link_order_error_handler)
	bed->link_order_error_handler
	  (_("%B: warning: sh_link not set for section `%A'"), s->owner, s);
      return 0;
    }
  else
    {
      s = elf_shdrp[elfsec]->bfd_section;
      return s->output_section->vma + s->output_offset;
    }
}


/* Compare two sections based on the locations of the sections they are
   linked to.  Used by elf_fixup_link_order.  */

static int
compare_link_order (const void * a, const void * b)
{
  bfd_vma apos;
  bfd_vma bpos;

  apos = elf_get_linked_section_vma (*(struct bfd_link_order **)a);
  bpos = elf_get_linked_section_vma (*(struct bfd_link_order **)b);
  if (apos < bpos)
    return -1;
  return apos > bpos;
}


/* Looks for sections with SHF_LINK_ORDER set.  Rearranges them into the same
   order as their linked sections.  Returns false if this could not be done
   because an output section includes both ordered and unordered
   sections.  Ideally we'd do this in the linker proper.  */

static bfd_boolean
elf_fixup_link_order (bfd *abfd, asection *o)
{
  int seen_linkorder;
  int seen_other;
  int n;
  struct bfd_link_order *p;
  bfd *sub;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  unsigned elfsec;
  struct bfd_link_order **sections;
  asection *s, *other_sec, *linkorder_sec;
  bfd_vma offset;

  other_sec = NULL;
  linkorder_sec = NULL;
  seen_other = 0;
  seen_linkorder = 0;
  for (p = o->map_head.link_order; p != NULL; p = p->next)
    {
      if (p->type == bfd_indirect_link_order)
	{
	  s = p->u.indirect.section;
	  sub = s->owner;
	  if (bfd_get_flavour (sub) == bfd_target_elf_flavour
	      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass
	      && (elfsec = _bfd_elf_section_from_bfd_section (sub, s))
	      && elfsec < elf_numsections (sub)
	      && elf_elfsections (sub)[elfsec]->sh_flags & SHF_LINK_ORDER
	      && elf_elfsections (sub)[elfsec]->sh_link < elf_numsections (sub))
	    {
	      seen_linkorder++;
	      linkorder_sec = s;
	    }
	  else
	    {
	      seen_other++;
	      other_sec = s;
	    }
	}
      else
	seen_other++;

      if (seen_other && seen_linkorder)
	{
	  if (other_sec && linkorder_sec)
	    (*_bfd_error_handler) (_("%A has both ordered [`%A' in %B] and unordered [`%A' in %B] sections"),
				   o, linkorder_sec,
				   linkorder_sec->owner, other_sec,
				   other_sec->owner);
	  else
	    (*_bfd_error_handler) (_("%A has both ordered and unordered sections"),
				   o);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
    }

  if (!seen_linkorder)
    return TRUE;

  sections = (struct bfd_link_order **)
    bfd_malloc (seen_linkorder * sizeof (struct bfd_link_order *));
  if (sections == NULL)
    return FALSE;
  seen_linkorder = 0;

  for (p = o->map_head.link_order; p != NULL; p = p->next)
    {
      sections[seen_linkorder++] = p;
    }
  /* Sort the input sections in the order of their linked section.  */
  qsort (sections, seen_linkorder, sizeof (struct bfd_link_order *),
	 compare_link_order);

  /* Change the offsets of the sections.  */
  offset = 0;
  for (n = 0; n < seen_linkorder; n++)
    {
      s = sections[n]->u.indirect.section;
      offset &= ~(bfd_vma) 0 << s->alignment_power;
      s->output_offset = offset;
      sections[n]->offset = offset;
      /* FIXME: octets_per_byte.  */
      offset += sections[n]->size;
    }

  free (sections);
  return TRUE;
}

static void
elf_final_link_free (bfd *obfd, struct elf_final_link_info *flinfo)
{
  asection *o;

  if (flinfo->symstrtab != NULL)
    _bfd_stringtab_free (flinfo->symstrtab);
  if (flinfo->contents != NULL)
    free (flinfo->contents);
  if (flinfo->external_relocs != NULL)
    free (flinfo->external_relocs);
  if (flinfo->internal_relocs != NULL)
    free (flinfo->internal_relocs);
  if (flinfo->external_syms != NULL)
    free (flinfo->external_syms);
  if (flinfo->locsym_shndx != NULL)
    free (flinfo->locsym_shndx);
  if (flinfo->internal_syms != NULL)
    free (flinfo->internal_syms);
  if (flinfo->indices != NULL)
    free (flinfo->indices);
  if (flinfo->sections != NULL)
    free (flinfo->sections);
  if (flinfo->symbuf != NULL)
    free (flinfo->symbuf);
  if (flinfo->symshndxbuf != NULL)
    free (flinfo->symshndxbuf);
  for (o = obfd->sections; o != NULL; o = o->next)
    {
      struct bfd_elf_section_data *esdo = elf_section_data (o);
      if ((o->flags & SEC_RELOC) != 0 && esdo->rel.hashes != NULL)
	free (esdo->rel.hashes);
      if ((o->flags & SEC_RELOC) != 0 && esdo->rela.hashes != NULL)
	free (esdo->rela.hashes);
    }
}

/* Do the final step of an ELF link.  */

bfd_boolean
bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean dynamic;
  bfd_boolean emit_relocs;
  bfd *dynobj;
  struct elf_final_link_info flinfo;
  asection *o;
  struct bfd_link_order *p;
  bfd *sub;
  bfd_size_type max_contents_size;
  bfd_size_type max_external_reloc_size;
  bfd_size_type max_internal_reloc_count;
  bfd_size_type max_sym_count;
  bfd_size_type max_sym_shndx_count;
  file_ptr off;
  Elf_Internal_Sym elfsym;
  unsigned int i;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *symtab_shndx_hdr;
  Elf_Internal_Shdr *symstrtab_hdr;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct elf_outext_info eoinfo;
  bfd_boolean merged;
  size_t relativecount = 0;
  asection *reldyn = 0;
  bfd_size_type amt;
  asection *attr_section = NULL;
  bfd_vma attr_size = 0;
  const char *std_attrs_section;

  if (! is_elf_hash_table (info->hash))
    return FALSE;

  if (info->shared)
    abfd->flags |= DYNAMIC;

  dynamic = elf_hash_table (info)->dynamic_sections_created;
  dynobj = elf_hash_table (info)->dynobj;

  emit_relocs = (info->relocatable
		 || info->emitrelocations);

  flinfo.info = info;
  flinfo.output_bfd = abfd;
  flinfo.symstrtab = _bfd_elf_stringtab_init ();
  if (flinfo.symstrtab == NULL)
    return FALSE;

  if (! dynamic)
    {
      flinfo.dynsym_sec = NULL;
      flinfo.hash_sec = NULL;
      flinfo.symver_sec = NULL;
    }
  else
    {
      flinfo.dynsym_sec = bfd_get_linker_section (dynobj, ".dynsym");
      flinfo.hash_sec = bfd_get_linker_section (dynobj, ".hash");
      /* Note that dynsym_sec can be NULL (on VMS).  */
      flinfo.symver_sec = bfd_get_linker_section (dynobj, ".gnu.version");
      /* Note that it is OK if symver_sec is NULL.  */
    }

  flinfo.contents = NULL;
  flinfo.external_relocs = NULL;
  flinfo.internal_relocs = NULL;
  flinfo.external_syms = NULL;
  flinfo.locsym_shndx = NULL;
  flinfo.internal_syms = NULL;
  flinfo.indices = NULL;
  flinfo.sections = NULL;
  flinfo.symbuf = NULL;
  flinfo.symshndxbuf = NULL;
  flinfo.symbuf_count = 0;
  flinfo.shndxbuf_size = 0;
  flinfo.filesym_count = 0;

  /* The object attributes have been merged.  Remove the input
     sections from the link, and set the contents of the output
     secton.  */
  std_attrs_section = get_elf_backend_data (abfd)->obj_attrs_section;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((std_attrs_section && strcmp (o->name, std_attrs_section) == 0)
	  || strcmp (o->name, ".gnu.attributes") == 0)
	{
	  for (p = o->map_head.link_order; p != NULL; p = p->next)
	    {
	      asection *input_section;

	      if (p->type != bfd_indirect_link_order)
		continue;
	      input_section = p->u.indirect.section;
	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &= ~SEC_HAS_CONTENTS;
	    }

	  attr_size = bfd_elf_obj_attr_size (abfd);
	  if (attr_size)
	    {
	      bfd_set_section_size (abfd, o, attr_size);
	      attr_section = o;
	      /* Skip this section later on.  */
	      o->map_head.link_order = NULL;
	    }
	  else
	    o->flags |= SEC_EXCLUDE;
	}
    }

  /* Count up the number of relocations we will output for each output
     section, so that we know the sizes of the reloc sections.  We
     also figure out some maximum sizes.  */
  max_contents_size = 0;
  max_external_reloc_size = 0;
  max_internal_reloc_count = 0;
  max_sym_count = 0;
  max_sym_shndx_count = 0;
  merged = FALSE;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct bfd_elf_section_data *esdo = elf_section_data (o);
      o->reloc_count = 0;

      for (p = o->map_head.link_order; p != NULL; p = p->next)
	{
	  unsigned int reloc_count = 0;
	  struct bfd_elf_section_data *esdi = NULL;

	  if (p->type == bfd_section_reloc_link_order
	      || p->type == bfd_symbol_reloc_link_order)
	    reloc_count = 1;
	  else if (p->type == bfd_indirect_link_order)
	    {
	      asection *sec;

	      sec = p->u.indirect.section;
	      esdi = elf_section_data (sec);

	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = TRUE;

	      if (sec->flags & SEC_MERGE)
		merged = TRUE;

	      if (esdo->this_hdr.sh_type == SHT_REL
		  || esdo->this_hdr.sh_type == SHT_RELA)
		/* Some backends use reloc_count in relocation sections
		   to count particular types of relocs.  Of course,
		   reloc sections themselves can't have relocations.  */
		reloc_count = 0;
	      else if (info->relocatable || info->emitrelocations)
		reloc_count = sec->reloc_count;
	      else if (bed->elf_backend_count_relocs)
		reloc_count = (*bed->elf_backend_count_relocs) (info, sec);

	      if (sec->rawsize > max_contents_size)
		max_contents_size = sec->rawsize;
	      if (sec->size > max_contents_size)
		max_contents_size = sec->size;

	      /* We are interested in just local symbols, not all
		 symbols.  */
	      if (bfd_get_flavour (sec->owner) == bfd_target_elf_flavour
		  && (sec->owner->flags & DYNAMIC) == 0)
		{
		  size_t sym_count;

		  if (elf_bad_symtab (sec->owner))
		    sym_count = (elf_tdata (sec->owner)->symtab_hdr.sh_size
				 / bed->s->sizeof_sym);
		  else
		    sym_count = elf_tdata (sec->owner)->symtab_hdr.sh_info;

		  if (sym_count > max_sym_count)
		    max_sym_count = sym_count;

		  if (sym_count > max_sym_shndx_count
		      && elf_symtab_shndx (sec->owner) != 0)
		    max_sym_shndx_count = sym_count;

		  if ((sec->flags & SEC_RELOC) != 0)
		    {
		      size_t ext_size = 0;

		      if (esdi->rel.hdr != NULL)
			ext_size = esdi->rel.hdr->sh_size;
		      if (esdi->rela.hdr != NULL)
			ext_size += esdi->rela.hdr->sh_size;

		      if (ext_size > max_external_reloc_size)
			max_external_reloc_size = ext_size;
		      if (sec->reloc_count > max_internal_reloc_count)
			max_internal_reloc_count = sec->reloc_count;
		    }
		}
	    }

	  if (reloc_count == 0)
	    continue;

	  o->reloc_count += reloc_count;

	  if (p->type == bfd_indirect_link_order
	      && (info->relocatable || info->emitrelocations))
	    {
	      if (esdi->rel.hdr)
		esdo->rel.count += NUM_SHDR_ENTRIES (esdi->rel.hdr);
	      if (esdi->rela.hdr)
		esdo->rela.count += NUM_SHDR_ENTRIES (esdi->rela.hdr);
	    }
	  else
	    {
	      if (o->use_rela_p)
		esdo->rela.count += reloc_count;
	      else
		esdo->rel.count += reloc_count;
	    }
	}

      if (o->reloc_count > 0)
	o->flags |= SEC_RELOC;
      else
	{
	  /* Explicitly clear the SEC_RELOC flag.  The linker tends to
	     set it (this is probably a bug) and if it is set
	     assign_section_numbers will create a reloc section.  */
	  o->flags &=~ SEC_RELOC;
	}

      /* If the SEC_ALLOC flag is not set, force the section VMA to
	 zero.  This is done in elf_fake_sections as well, but forcing
	 the VMA to 0 here will ensure that relocs against these
	 sections are handled correctly.  */
      if ((o->flags & SEC_ALLOC) == 0
	  && ! o->user_set_vma)
	o->vma = 0;
    }

  if (! info->relocatable && merged)
    elf_link_hash_traverse (elf_hash_table (info),
			    _bfd_elf_link_sec_merge_syms, abfd);

  /* Figure out the file positions for everything but the symbol table
     and the relocs.  We set symcount to force assign_section_numbers
     to create a symbol table.  */
  bfd_get_symcount (abfd) = info->strip == strip_all ? 0 : 1;
  BFD_ASSERT (! abfd->output_has_begun);
  if (! _bfd_elf_compute_section_file_positions (abfd, info))
    goto error_return;

  /* Set sizes, and assign file positions for reloc sections.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct bfd_elf_section_data *esdo = elf_section_data (o);
      if ((o->flags & SEC_RELOC) != 0)
	{
	  if (esdo->rel.hdr
	      && !(_bfd_elf_link_size_reloc_section (abfd, &esdo->rel)))
	    goto error_return;

	  if (esdo->rela.hdr
	      && !(_bfd_elf_link_size_reloc_section (abfd, &esdo->rela)))
	    goto error_return;
	}

      /* Now, reset REL_COUNT and REL_COUNT2 so that we can use them
	 to count upwards while actually outputting the relocations.  */
      esdo->rel.count = 0;
      esdo->rela.count = 0;
    }

  _bfd_elf_assign_file_positions_for_relocs (abfd);

  /* We have now assigned file positions for all the sections except
     .symtab and .strtab.  We start the .symtab section at the current
     file position, and write directly to it.  We build the .strtab
     section in memory.  */
  bfd_get_symcount (abfd) = 0;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  /* sh_name is set in prep_headers.  */
  symtab_hdr->sh_type = SHT_SYMTAB;
  /* sh_flags, sh_addr and sh_size all start off zero.  */
  symtab_hdr->sh_entsize = bed->s->sizeof_sym;
  /* sh_link is set in assign_section_numbers.  */
  /* sh_info is set below.  */
  /* sh_offset is set just below.  */
  symtab_hdr->sh_addralign = (bfd_vma) 1 << bed->s->log_file_align;

  off = elf_next_file_pos (abfd);
  off = _bfd_elf_assign_file_position_for_section (symtab_hdr, off, TRUE);

  /* Note that at this point elf_next_file_pos (abfd) is
     incorrect.  We do not yet know the size of the .symtab section.
     We correct next_file_pos below, after we do know the size.  */

  /* Allocate a buffer to hold swapped out symbols.  This is to avoid
     continuously seeking to the right position in the file.  */
  if (! info->keep_memory || max_sym_count < 20)
    flinfo.symbuf_size = 20;
  else
    flinfo.symbuf_size = max_sym_count;
  amt = flinfo.symbuf_size;
  amt *= bed->s->sizeof_sym;
  flinfo.symbuf = (bfd_byte *) bfd_malloc (amt);
  if (flinfo.symbuf == NULL)
    goto error_return;
  if (elf_numsections (abfd) > (SHN_LORESERVE & 0xFFFF))
    {
      /* Wild guess at number of output symbols.  realloc'd as needed.  */
      amt = 2 * max_sym_count + elf_numsections (abfd) + 1000;
      flinfo.shndxbuf_size = amt;
      amt *= sizeof (Elf_External_Sym_Shndx);
      flinfo.symshndxbuf = (Elf_External_Sym_Shndx *) bfd_zmalloc (amt);
      if (flinfo.symshndxbuf == NULL)
	goto error_return;
    }

  /* Start writing out the symbol table.  The first symbol is always a
     dummy symbol.  */
  if (info->strip != strip_all
      || emit_relocs)
    {
      elfsym.st_value = 0;
      elfsym.st_size = 0;
      elfsym.st_info = 0;
      elfsym.st_other = 0;
      elfsym.st_shndx = SHN_UNDEF;
      elfsym.st_target_internal = 0;
      if (elf_link_output_sym (&flinfo, NULL, &elfsym, bfd_und_section_ptr,
			       NULL) != 1)
	goto error_return;
    }

  /* Output a symbol for each section.  We output these even if we are
     discarding local symbols, since they are used for relocs.  These
     symbols have no names.  We store the index of each one in the
     index field of the section, so that we can find it again when
     outputting relocs.  */
  if (info->strip != strip_all
      || emit_relocs)
    {
      elfsym.st_size = 0;
      elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
      elfsym.st_other = 0;
      elfsym.st_value = 0;
      elfsym.st_target_internal = 0;
      for (i = 1; i < elf_numsections (abfd); i++)
	{
	  o = bfd_section_from_elf_index (abfd, i);
	  if (o != NULL)
	    {
	      o->target_index = bfd_get_symcount (abfd);
	      elfsym.st_shndx = i;
	      if (!info->relocatable)
		elfsym.st_value = o->vma;
	      if (elf_link_output_sym (&flinfo, NULL, &elfsym, o, NULL) != 1)
		goto error_return;
	    }
	}
    }

  /* Allocate some memory to hold information read in from the input
     files.  */
  if (max_contents_size != 0)
    {
      flinfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
      if (flinfo.contents == NULL)
	goto error_return;
    }

  if (max_external_reloc_size != 0)
    {
      flinfo.external_relocs = bfd_malloc (max_external_reloc_size);
      if (flinfo.external_relocs == NULL)
	goto error_return;
    }

  if (max_internal_reloc_count != 0)
    {
      amt = max_internal_reloc_count * bed->s->int_rels_per_ext_rel;
      amt *= sizeof (Elf_Internal_Rela);
      flinfo.internal_relocs = (Elf_Internal_Rela *) bfd_malloc (amt);
      if (flinfo.internal_relocs == NULL)
	goto error_return;
    }

  if (max_sym_count != 0)
    {
      amt = max_sym_count * bed->s->sizeof_sym;
      flinfo.external_syms = (bfd_byte *) bfd_malloc (amt);
      if (flinfo.external_syms == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (Elf_Internal_Sym);
      flinfo.internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
      if (flinfo.internal_syms == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (long);
      flinfo.indices = (long int *) bfd_malloc (amt);
      if (flinfo.indices == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (asection *);
      flinfo.sections = (asection **) bfd_malloc (amt);
      if (flinfo.sections == NULL)
	goto error_return;
    }

  if (max_sym_shndx_count != 0)
    {
      amt = max_sym_shndx_count * sizeof (Elf_External_Sym_Shndx);
      flinfo.locsym_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (flinfo.locsym_shndx == NULL)
	goto error_return;
    }

  if (elf_hash_table (info)->tls_sec)
    {
      bfd_vma base, end = 0;
      asection *sec;

      for (sec = elf_hash_table (info)->tls_sec;
	   sec && (sec->flags & SEC_THREAD_LOCAL);
	   sec = sec->next)
	{
	  bfd_size_type size = sec->size;

	  if (size == 0
	      && (sec->flags & SEC_HAS_CONTENTS) == 0)
	    {
	      struct bfd_link_order *ord = sec->map_tail.link_order;

	      if (ord != NULL)
		size = ord->offset + ord->size;
	    }
	  end = sec->vma + size;
	}
      base = elf_hash_table (info)->tls_sec->vma;
      /* Only align end of TLS section if static TLS doesn't have special
	 alignment requirements.  */
      if (bed->static_tls_alignment == 1)
	end = align_power (end,
			   elf_hash_table (info)->tls_sec->alignment_power);
      elf_hash_table (info)->tls_size = end - base;
    }

  /* Reorder SHF_LINK_ORDER sections.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (!elf_fixup_link_order (abfd, o))
	return FALSE;
    }

  /* Since ELF permits relocations to be against local symbols, we
     must have the local symbols available when we do the relocations.
     Since we would rather only read the local symbols once, and we
     would rather not keep them in memory, we handle all the
     relocations for a single input file at the same time.

     Unfortunately, there is no way to know the total number of local
     symbols until we have seen all of them, and the local symbol
     indices precede the global symbol indices.  This means that when
     we are generating relocatable output, and we see a reloc against
     a global symbol, we can not know the symbol index until we have
     finished examining all the local symbols to see which ones we are
     going to output.  To deal with this, we keep the relocations in
     memory, and don't output them until the end of the link.  This is
     an unfortunate waste of memory, but I don't see a good way around
     it.  Fortunately, it only happens when performing a relocatable
     link, which is not the common case.  FIXME: If keep_memory is set
     we could write the relocs out and then read them again; I don't
     know how bad the memory loss will be.  */

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    sub->output_has_begun = FALSE;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->map_head.link_order; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && (bfd_get_flavour ((sub = p->u.indirect.section->owner))
		  == bfd_target_elf_flavour)
	      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass)
	    {
	      if (! sub->output_has_begun)
		{
		  if (! elf_link_input_bfd (&flinfo, sub))
		    goto error_return;
		  sub->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! elf_reloc_link_order (abfd, info, o, p))
		goto error_return;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		{
		  if (p->type == bfd_indirect_link_order
		      && (bfd_get_flavour (sub)
			  == bfd_target_elf_flavour)
		      && (elf_elfheader (sub)->e_ident[EI_CLASS]
			  != bed->s->elfclass))
		    {
		      const char *iclass, *oclass;

		      if (bed->s->elfclass == ELFCLASS64)
			{
			  iclass = "ELFCLASS32";
			  oclass = "ELFCLASS64";
			}
		      else
			{
			  iclass = "ELFCLASS64";
			  oclass = "ELFCLASS32";
			}

		      bfd_set_error (bfd_error_wrong_format);
		      (*_bfd_error_handler)
			(_("%B: file class %s incompatible with %s"),
			 sub, iclass, oclass);
		    }

		  goto error_return;
		}
	    }
	}
    }

  /* Free symbol buffer if needed.  */
  if (!info->reduce_memory_overheads)
    {
      for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
	if (bfd_get_flavour (sub) == bfd_target_elf_flavour
	    && elf_tdata (sub)->symbuf)
	  {
	    free (elf_tdata (sub)->symbuf);
	    elf_tdata (sub)->symbuf = NULL;
	  }
    }

  /* Output a FILE symbol so that following locals are not associated
     with the wrong input file.  */
  memset (&elfsym, 0, sizeof (elfsym));
  elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
  elfsym.st_shndx = SHN_ABS;

  if (flinfo.filesym_count > 1
      && !elf_link_output_sym (&flinfo, NULL, &elfsym,
			       bfd_und_section_ptr, NULL))
    return FALSE;

  /* Output any global symbols that got converted to local in a
     version script or due to symbol visibility.  We do this in a
     separate step since ELF requires all local symbols to appear
     prior to any global symbols.  FIXME: We should only do this if
     some global symbols were, in fact, converted to become local.
     FIXME: Will this work correctly with the Irix 5 linker?  */
  eoinfo.failed = FALSE;
  eoinfo.flinfo = &flinfo;
  eoinfo.localsyms = TRUE;
  eoinfo.need_second_pass = FALSE;
  eoinfo.second_pass = FALSE;
  bfd_hash_traverse (&info->hash->table, elf_link_output_extsym, &eoinfo);
  if (eoinfo.failed)
    return FALSE;

  if (flinfo.filesym_count == 1
      && !elf_link_output_sym (&flinfo, NULL, &elfsym,
			       bfd_und_section_ptr, NULL))
    return FALSE;

  if (eoinfo.need_second_pass)
    {
      eoinfo.second_pass = TRUE;
      bfd_hash_traverse (&info->hash->table, elf_link_output_extsym, &eoinfo);
      if (eoinfo.failed)
	return FALSE;
    }

  /* If backend needs to output some local symbols not present in the hash
     table, do it now.  */
  if (bed->elf_backend_output_arch_local_syms)
    {
      typedef int (*out_sym_func)
	(void *, const char *, Elf_Internal_Sym *, asection *,
	 struct elf_link_hash_entry *);

      if (! ((*bed->elf_backend_output_arch_local_syms)
	     (abfd, info, &flinfo, (out_sym_func) elf_link_output_sym)))
	return FALSE;
    }

  /* That wrote out all the local symbols.  Finish up the symbol table
     with the global symbols. Even if we want to strip everything we
     can, we still need to deal with those global symbols that got
     converted to local in a version script.  */

  /* The sh_info field records the index of the first non local symbol.  */
  symtab_hdr->sh_info = bfd_get_symcount (abfd);

  if (dynamic
      && flinfo.dynsym_sec != NULL
      && flinfo.dynsym_sec->output_section != bfd_abs_section_ptr)
    {
      Elf_Internal_Sym sym;
      bfd_byte *dynsym = flinfo.dynsym_sec->contents;
      long last_local = 0;

      /* Write out the section symbols for the output sections.  */
      if (info->shared || elf_hash_table (info)->is_relocatable_executable)
	{
	  asection *s;

	  sym.st_size = 0;
	  sym.st_name = 0;
	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	  sym.st_other = 0;
	  sym.st_target_internal = 0;

	  for (s = abfd->sections; s != NULL; s = s->next)
	    {
	      int indx;
	      bfd_byte *dest;
	      long dynindx;

	      dynindx = elf_section_data (s)->dynindx;
	      if (dynindx <= 0)
		continue;
	      indx = elf_section_data (s)->this_idx;
	      BFD_ASSERT (indx > 0);
	      sym.st_shndx = indx;
	      if (! check_dynsym (abfd, &sym))
		return FALSE;
	      sym.st_value = s->vma;
	      dest = dynsym + dynindx * bed->s->sizeof_sym;
	      if (last_local < dynindx)
		last_local = dynindx;
	      bed->s->swap_symbol_out (abfd, &sym, dest, 0);
	    }
	}

      /* Write out the local dynsyms.  */
      if (elf_hash_table (info)->dynlocal)
	{
	  struct elf_link_local_dynamic_entry *e;
	  for (e = elf_hash_table (info)->dynlocal; e ; e = e->next)
	    {
	      asection *s;
	      bfd_byte *dest;

	      /* Copy the internal symbol and turn off visibility.
		 Note that we saved a word of storage and overwrote
		 the original st_name with the dynstr_index.  */
	      sym = e->isym;
	      sym.st_other &= ~ELF_ST_VISIBILITY (-1);

	      s = bfd_section_from_elf_index (e->input_bfd,
					      e->isym.st_shndx);
	      if (s != NULL)
		{
		  sym.st_shndx =
		    elf_section_data (s->output_section)->this_idx;
		  if (! check_dynsym (abfd, &sym))
		    return FALSE;
		  sym.st_value = (s->output_section->vma
				  + s->output_offset
				  + e->isym.st_value);
		}

	      if (last_local < e->dynindx)
		last_local = e->dynindx;

	      dest = dynsym + e->dynindx * bed->s->sizeof_sym;
	      bed->s->swap_symbol_out (abfd, &sym, dest, 0);
	    }
	}

      elf_section_data (flinfo.dynsym_sec->output_section)->this_hdr.sh_info =
	last_local + 1;
    }

  /* We get the global symbols from the hash table.  */
  eoinfo.failed = FALSE;
  eoinfo.localsyms = FALSE;
  eoinfo.flinfo = &flinfo;
  bfd_hash_traverse (&info->hash->table, elf_link_output_extsym, &eoinfo);
  if (eoinfo.failed)
    return FALSE;

  /* If backend needs to output some symbols not present in the hash
     table, do it now.  */
  if (bed->elf_backend_output_arch_syms)
    {
      typedef int (*out_sym_func)
	(void *, const char *, Elf_Internal_Sym *, asection *,
	 struct elf_link_hash_entry *);

      if (! ((*bed->elf_backend_output_arch_syms)
	     (abfd, info, &flinfo, (out_sym_func) elf_link_output_sym)))
	return FALSE;
    }

  /* Flush all symbols to the file.  */
  if (! elf_link_flush_output_syms (&flinfo, bed))
    return FALSE;

  /* Now we know the size of the symtab section.  */
  off += symtab_hdr->sh_size;

  symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (symtab_shndx_hdr->sh_name != 0)
    {
      symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
      symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
      amt = bfd_get_symcount (abfd) * sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_size = amt;

      off = _bfd_elf_assign_file_position_for_section (symtab_shndx_hdr,
						       off, TRUE);

      if (bfd_seek (abfd, symtab_shndx_hdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bwrite (flinfo.symshndxbuf, amt, abfd) != amt))
	return FALSE;
    }


  /* Finish up and write out the symbol string table (.strtab)
     section.  */
  symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;
  /* sh_name was set in prep_headers.  */
  symstrtab_hdr->sh_type = SHT_STRTAB;
  symstrtab_hdr->sh_flags = 0;
  symstrtab_hdr->sh_addr = 0;
  symstrtab_hdr->sh_size = _bfd_stringtab_size (flinfo.symstrtab);
  symstrtab_hdr->sh_entsize = 0;
  symstrtab_hdr->sh_link = 0;
  symstrtab_hdr->sh_info = 0;
  /* sh_offset is set just below.  */
  symstrtab_hdr->sh_addralign = 1;

  off = _bfd_elf_assign_file_position_for_section (symstrtab_hdr, off, TRUE);
  elf_next_file_pos (abfd) = off;

  if (bfd_get_symcount (abfd) > 0)
    {
      if (bfd_seek (abfd, symstrtab_hdr->sh_offset, SEEK_SET) != 0
	  || ! _bfd_stringtab_emit (abfd, flinfo.symstrtab))
	return FALSE;
    }

  /* Adjust the relocs to have the correct symbol indices.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct bfd_elf_section_data *esdo = elf_section_data (o);
      if ((o->flags & SEC_RELOC) == 0)
	continue;

      if (esdo->rel.hdr != NULL)
	elf_link_adjust_relocs (abfd, &esdo->rel);
      if (esdo->rela.hdr != NULL)
	elf_link_adjust_relocs (abfd, &esdo->rela);

      /* Set the reloc_count field to 0 to prevent write_relocs from
	 trying to swap the relocs out itself.  */
      o->reloc_count = 0;
    }

  if (dynamic && info->combreloc && dynobj != NULL)
    relativecount = elf_link_sort_relocs (abfd, info, &reldyn);

  /* If we are linking against a dynamic object, or generating a
     shared library, finish up the dynamic linking information.  */
  if (dynamic)
    {
      bfd_byte *dyncon, *dynconend;

      /* Fix up .dynamic entries.  */
      o = bfd_get_linker_section (dynobj, ".dynamic");
      BFD_ASSERT (o != NULL);

      dyncon = o->contents;
      dynconend = o->contents + o->size;
      for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  unsigned int type;

	  bed->s->swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      continue;
	    case DT_NULL:
	      if (relativecount > 0 && dyncon + bed->s->sizeof_dyn < dynconend)
		{
		  switch (elf_section_data (reldyn)->this_hdr.sh_type)
		    {
		    case SHT_REL: dyn.d_tag = DT_RELCOUNT; break;
		    case SHT_RELA: dyn.d_tag = DT_RELACOUNT; break;
		    default: continue;
		    }
		  dyn.d_un.d_val = relativecount;
		  relativecount = 0;
		  break;
		}
	      continue;

	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;
	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      {
		struct elf_link_hash_entry *h;

		h = elf_link_hash_lookup (elf_hash_table (info), name,
					  FALSE, FALSE, TRUE);
		if (h != NULL
		    && (h->root.type == bfd_link_hash_defined
			|| h->root.type == bfd_link_hash_defweak))
		  {
		    dyn.d_un.d_ptr = h->root.u.def.value;
		    o = h->root.u.def.section;
		    if (o->output_section != NULL)
		      dyn.d_un.d_ptr += (o->output_section->vma
					 + o->output_offset);
		    else
		      {
			/* The symbol is imported from another shared
			   library and does not apply to this one.  */
			dyn.d_un.d_ptr = 0;
		      }
		    break;
		  }
	      }
	      continue;

	    case DT_PREINIT_ARRAYSZ:
	      name = ".preinit_array";
	      goto get_size;
	    case DT_INIT_ARRAYSZ:
	      name = ".init_array";
	      goto get_size;
	    case DT_FINI_ARRAYSZ:
	      name = ".fini_array";
	    get_size:
	      o = bfd_get_section_by_name (abfd, name);
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%B: could not find output section %s"), abfd, name);
		  goto error_return;
		}
	      if (o->size == 0)
		(*_bfd_error_handler)
		  (_("warning: %s section has zero size"), name);
	      dyn.d_un.d_val = o->size;
	      break;

	    case DT_PREINIT_ARRAY:
	      name = ".preinit_array";
	      goto get_vma;
	    case DT_INIT_ARRAY:
	      name = ".init_array";
	      goto get_vma;
	    case DT_FINI_ARRAY:
	      name = ".fini_array";
	      goto get_vma;

	    case DT_HASH:
	      name = ".hash";
	      goto get_vma;
	    case DT_GNU_HASH:
	      name = ".gnu.hash";
	      goto get_vma;
	    case DT_STRTAB:
	      name = ".dynstr";
	      goto get_vma;
	    case DT_SYMTAB:
	      name = ".dynsym";
	      goto get_vma;
	    case DT_VERDEF:
	      name = ".gnu.version_d";
	      goto get_vma;
	    case DT_VERNEED:
	      name = ".gnu.version_r";
	      goto get_vma;
	    case DT_VERSYM:
	      name = ".gnu.version";
	    get_vma:
	      o = bfd_get_section_by_name (abfd, name);
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%B: could not find output section %s"), abfd, name);
		  goto error_return;
		}
	      if (elf_section_data (o->output_section)->this_hdr.sh_type == SHT_NOTE)
		{
		  (*_bfd_error_handler)
		    (_("warning: section '%s' is being made into a note"), name);
		  bfd_set_error (bfd_error_nonrepresentable_section);
		  goto error_return;
		}
	      dyn.d_un.d_ptr = o->vma;
	      break;

	    case DT_REL:
	    case DT_RELA:
	    case DT_RELSZ:
	    case DT_RELASZ:
	      if (dyn.d_tag == DT_REL || dyn.d_tag == DT_RELSZ)
		type = SHT_REL;
	      else
		type = SHT_RELA;
	      dyn.d_un.d_val = 0;
	      dyn.d_un.d_ptr = 0;
	      for (i = 1; i < elf_numsections (abfd); i++)
		{
		  Elf_Internal_Shdr *hdr;

		  hdr = elf_elfsections (abfd)[i];
		  if (hdr->sh_type == type
		      && (hdr->sh_flags & SHF_ALLOC) != 0)
		    {
		      if (dyn.d_tag == DT_RELSZ || dyn.d_tag == DT_RELASZ)
			dyn.d_un.d_val += hdr->sh_size;
		      else
			{
			  if (dyn.d_un.d_ptr == 0
			      || hdr->sh_addr < dyn.d_un.d_ptr)
			    dyn.d_un.d_ptr = hdr->sh_addr;
			}
		    }
		}
	      break;
	    }
	  bed->s->swap_dyn_out (dynobj, &dyn, dyncon);
	}
    }

  /* If we have created any dynamic sections, then output them.  */
  if (dynobj != NULL)
    {
      if (! (*bed->elf_backend_finish_dynamic_sections) (abfd, info))
	goto error_return;

      /* Check for DT_TEXTREL (late, in case the backend removes it).  */
      if (((info->warn_shared_textrel && info->shared)
	   || info->error_textrel)
	  && (o = bfd_get_linker_section (dynobj, ".dynamic")) != NULL)
	{
	  bfd_byte *dyncon, *dynconend;

	  dyncon = o->contents;
	  dynconend = o->contents + o->size;
	  for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)
	    {
	      Elf_Internal_Dyn dyn;

	      bed->s->swap_dyn_in (dynobj, dyncon, &dyn);

	      if (dyn.d_tag == DT_TEXTREL)
		{
		  if (info->error_textrel)
		    info->callbacks->einfo
		      (_("%P%X: read-only segment has dynamic relocations.\n"));
		  else
		    info->callbacks->einfo
		      (_("%P: warning: creating a DT_TEXTREL in a shared object.\n"));
		  break;
		}
	    }
	}

      for (o = dynobj->sections; o != NULL; o = o->next)
	{
	  if ((o->flags & SEC_HAS_CONTENTS) == 0
	      || o->size == 0
	      || o->output_section == bfd_abs_section_ptr)
	    continue;
	  if ((o->flags & SEC_LINKER_CREATED) == 0)
	    {
	      /* At this point, we are only interested in sections
		 created by _bfd_elf_link_create_dynamic_sections.  */
	      continue;
	    }
	  if (elf_hash_table (info)->stab_info.stabstr == o)
	    continue;
	  if (elf_hash_table (info)->eh_info.hdr_sec == o)
	    continue;
	  if (strcmp (o->name, ".dynstr") != 0)
	    {
	      /* FIXME: octets_per_byte.  */
	      if (! bfd_set_section_contents (abfd, o->output_section,
					      o->contents,
					      (file_ptr) o->output_offset,
					      o->size))
		goto error_return;
	    }
	  else
	    {
	      /* The contents of the .dynstr section are actually in a
		 stringtab.  */
	      off = elf_section_data (o->output_section)->this_hdr.sh_offset;
	      if (bfd_seek (abfd, off, SEEK_SET) != 0
		  || ! _bfd_elf_strtab_emit (abfd,
					     elf_hash_table (info)->dynstr))
		goto error_return;
	    }
	}
    }

  if (info->relocatable)
    {
      bfd_boolean failed = FALSE;

      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
      if (failed)
	goto error_return;
    }

  /* If we have optimized stabs strings, output them.  */
  if (elf_hash_table (info)->stab_info.stabstr != NULL)
    {
      if (! _bfd_write_stab_strings (abfd, &elf_hash_table (info)->stab_info))
	goto error_return;
    }

  if (! _bfd_elf_write_section_eh_frame_hdr (abfd, info))
    goto error_return;

  elf_final_link_free (abfd, &flinfo);

  elf_linker (abfd) = TRUE;

  if (attr_section)
    {
      bfd_byte *contents = (bfd_byte *) bfd_malloc (attr_size);
      if (contents == NULL)
	return FALSE;	/* Bail out and fail.  */
      bfd_elf_set_obj_attr_contents (abfd, contents, attr_size);
      bfd_set_section_contents (abfd, attr_section, contents, 0, attr_size);
      free (contents);
    }

  return TRUE;

 error_return:
  elf_final_link_free (abfd, &flinfo);
  return FALSE;
}

/* Initialize COOKIE for input bfd ABFD.  */

static bfd_boolean
init_reloc_cookie (struct elf_reloc_cookie *cookie,
		   struct bfd_link_info *info, bfd *abfd)
{
  Elf_Internal_Shdr *symtab_hdr;
  const struct elf_backend_data *bed;

  bed = get_elf_backend_data (abfd);
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  cookie->abfd = abfd;
  cookie->sym_hashes = elf_sym_hashes (abfd);
  cookie->bad_symtab = elf_bad_symtab (abfd);
  if (cookie->bad_symtab)
    {
      cookie->locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      cookie->extsymoff = 0;
    }
  else
    {
      cookie->locsymcount = symtab_hdr->sh_info;
      cookie->extsymoff = symtab_hdr->sh_info;
    }

  if (bed->s->arch_size == 32)
    cookie->r_sym_shift = 8;
  else
    cookie->r_sym_shift = 32;

  cookie->locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
  if (cookie->locsyms == NULL && cookie->locsymcount != 0)
    {
      cookie->locsyms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					      cookie->locsymcount, 0,
					      NULL, NULL, NULL);
      if (cookie->locsyms == NULL)
	{
	  info->callbacks->einfo (_("%P%X: can not read symbols: %E\n"));
	  return FALSE;
	}
      if (info->keep_memory)
	symtab_hdr->contents = (bfd_byte *) cookie->locsyms;
    }
  return TRUE;
}

/* Free the memory allocated by init_reloc_cookie, if appropriate.  */

static void
fini_reloc_cookie (struct elf_reloc_cookie *cookie, bfd *abfd)
{
  Elf_Internal_Shdr *symtab_hdr;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  if (cookie->locsyms != NULL
      && symtab_hdr->contents != (unsigned char *) cookie->locsyms)
    free (cookie->locsyms);
}

/* Initialize the relocation information in COOKIE for input section SEC
   of input bfd ABFD.  */

static bfd_boolean
init_reloc_cookie_rels (struct elf_reloc_cookie *cookie,
			struct bfd_link_info *info, bfd *abfd,
			asection *sec)
{
  const struct elf_backend_data *bed;

  if (sec->reloc_count == 0)
    {
      cookie->rels = NULL;
      cookie->relend = NULL;
    }
  else
    {
      bed = get_elf_backend_data (abfd);

      cookie->rels = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
						info->keep_memory);
      if (cookie->rels == NULL)
	return FALSE;
      cookie->rel = cookie->rels;
      cookie->relend = (cookie->rels
			+ sec->reloc_count * bed->s->int_rels_per_ext_rel);
    }
  cookie->rel = cookie->rels;
  return TRUE;
}

/* Free the memory allocated by init_reloc_cookie_rels,
   if appropriate.  */

static void
fini_reloc_cookie_rels (struct elf_reloc_cookie *cookie,
			asection *sec)
{
  if (cookie->rels && elf_section_data (sec)->relocs != cookie->rels)
    free (cookie->rels);
}

/* Initialize the whole of COOKIE for input section SEC.  */

static bfd_boolean
init_reloc_cookie_for_section (struct elf_reloc_cookie *cookie,
			       struct bfd_link_info *info,
			       asection *sec)
{
  if (!init_reloc_cookie (cookie, info, sec->owner))
    goto error1;
  if (!init_reloc_cookie_rels (cookie, info, sec->owner, sec))
    goto error2;
  return TRUE;

 error2:
  fini_reloc_cookie (cookie, sec->owner);
 error1:
  return FALSE;
}

/* Free the memory allocated by init_reloc_cookie_for_section,
   if appropriate.  */

static void
fini_reloc_cookie_for_section (struct elf_reloc_cookie *cookie,
			       asection *sec)
{
  fini_reloc_cookie_rels (cookie, sec);
  fini_reloc_cookie (cookie, sec->owner);
}

/* Garbage collect unused sections.  */

/* Default gc_mark_hook.  */

asection *
_bfd_elf_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
		       Elf_Internal_Rela *rel ATTRIBUTE_UNUSED,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  const char *sec_name;

  if (h != NULL)
    {
      switch (h->root.type)
	{
	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
	  return h->root.u.def.section;

	case bfd_link_hash_common:
	  return h->root.u.c.p->section;

	case bfd_link_hash_undefined:
	case bfd_link_hash_undefweak:
	  /* To work around a glibc bug, keep all XXX input sections
	     when there is an as yet undefined reference to __start_XXX
	     or __stop_XXX symbols.  The linker will later define such
	     symbols for orphan input sections that have a name
	     representable as a C identifier.  */
	  if (strncmp (h->root.root.string, "__start_", 8) == 0)
	    sec_name = h->root.root.string + 8;
	  else if (strncmp (h->root.root.string, "__stop_", 7) == 0)
	    sec_name = h->root.root.string + 7;
	  else
	    sec_name = NULL;

	  if (sec_name && *sec_name != '\0')
	    {
	      bfd *i;

	      for (i = info->input_bfds; i; i = i->link_next)
		{
		  sec = bfd_get_section_by_name (i, sec_name);
		  if (sec)
		    sec->flags |= SEC_KEEP;
		}
	    }
	  break;

	default:
	  break;
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

/* COOKIE->rel describes a relocation against section SEC, which is
   a section we've decided to keep.  Return the section that contains
   the relocation symbol, or NULL if no section contains it.  */

asection *
_bfd_elf_gc_mark_rsec (struct bfd_link_info *info, asection *sec,
		       elf_gc_mark_hook_fn gc_mark_hook,
		       struct elf_reloc_cookie *cookie)
{
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  r_symndx = cookie->rel->r_info >> cookie->r_sym_shift;
  if (r_symndx == STN_UNDEF)
    return NULL;

  if (r_symndx >= cookie->locsymcount
      || ELF_ST_BIND (cookie->locsyms[r_symndx].st_info) != STB_LOCAL)
    {
      h = cookie->sym_hashes[r_symndx - cookie->extsymoff];
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
      h->mark = 1;
      /* If this symbol is weak and there is a non-weak definition, we
	 keep the non-weak definition because many backends put
	 dynamic reloc info on the non-weak definition for code
	 handling copy relocs.  */
      if (h->u.weakdef != NULL)
	h->u.weakdef->mark = 1;
      return (*gc_mark_hook) (sec, info, cookie->rel, h, NULL);
    }

  return (*gc_mark_hook) (sec, info, cookie->rel, NULL,
			  &cookie->locsyms[r_symndx]);
}

/* COOKIE->rel describes a relocation against section SEC, which is
   a section we've decided to keep.  Mark the section that contains
   the relocation symbol.  */

bfd_boolean
_bfd_elf_gc_mark_reloc (struct bfd_link_info *info,
			asection *sec,
			elf_gc_mark_hook_fn gc_mark_hook,
			struct elf_reloc_cookie *cookie)
{
  asection *rsec;

  rsec = _bfd_elf_gc_mark_rsec (info, sec, gc_mark_hook, cookie);
  if (rsec && !rsec->gc_mark)
    {
      if (bfd_get_flavour (rsec->owner) != bfd_target_elf_flavour
	  || (rsec->owner->flags & DYNAMIC) != 0)
	rsec->gc_mark = 1;
      else if (!_bfd_elf_gc_mark (info, rsec, gc_mark_hook))
	return FALSE;
    }
  return TRUE;
}

/* The mark phase of garbage collection.  For a given section, mark
   it and any sections in this section's group, and all the sections
   which define symbols to which it refers.  */

bfd_boolean
_bfd_elf_gc_mark (struct bfd_link_info *info,
		  asection *sec,
		  elf_gc_mark_hook_fn gc_mark_hook)
{
  bfd_boolean ret;
  asection *group_sec, *eh_frame;

  sec->gc_mark = 1;

  /* Mark all the sections in the group.  */
  group_sec = elf_section_data (sec)->next_in_group;
  if (group_sec && !group_sec->gc_mark)
    if (!_bfd_elf_gc_mark (info, group_sec, gc_mark_hook))
      return FALSE;

  /* Look through the section relocs.  */
  ret = TRUE;
  eh_frame = elf_eh_frame_section (sec->owner);
  if ((sec->flags & SEC_RELOC) != 0
      && sec->reloc_count > 0
      && sec != eh_frame)
    {
      struct elf_reloc_cookie cookie;

      if (!init_reloc_cookie_for_section (&cookie, info, sec))
	ret = FALSE;
      else
	{
	  for (; cookie.rel < cookie.relend; cookie.rel++)
	    if (!_bfd_elf_gc_mark_reloc (info, sec, gc_mark_hook, &cookie))
	      {
		ret = FALSE;
		break;
	      }
	  fini_reloc_cookie_for_section (&cookie, sec);
	}
    }

  if (ret && eh_frame && elf_fde_list (sec))
    {
      struct elf_reloc_cookie cookie;

      if (!init_reloc_cookie_for_section (&cookie, info, eh_frame))
	ret = FALSE;
      else
	{
	  if (!_bfd_elf_gc_mark_fdes (info, sec, eh_frame,
				      gc_mark_hook, &cookie))
	    ret = FALSE;
	  fini_reloc_cookie_for_section (&cookie, eh_frame);
	}
    }

  return ret;
}

/* Keep debug and special sections.  */

bfd_boolean
_bfd_elf_gc_mark_extra_sections (struct bfd_link_info *info,
				 elf_gc_mark_hook_fn mark_hook ATTRIBUTE_UNUSED)
{
  bfd *ibfd;

  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      asection *isec;
      bfd_boolean some_kept;
      bfd_boolean debug_frag_seen;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      /* Ensure all linker created sections are kept,
	 see if any other section is already marked,
	 and note if we have any fragmented debug sections.  */
      debug_frag_seen = some_kept = FALSE;
      for (isec = ibfd->sections; isec != NULL; isec = isec->next)
	{
	  if ((isec->flags & SEC_LINKER_CREATED) != 0)
	    isec->gc_mark = 1;
	  else if (isec->gc_mark)
	    some_kept = TRUE;

	  if (debug_frag_seen == FALSE
	      && (isec->flags & SEC_DEBUGGING)
	      && CONST_STRNEQ (isec->name, ".debug_line."))
	    debug_frag_seen = TRUE;
	}

      /* If no section in this file will be kept, then we can
	 toss out the debug and special sections.  */
      if (!some_kept)
	continue;

      /* Keep debug and special sections like .comment when they are
	 not part of a group, or when we have single-member groups.  */
      for (isec = ibfd->sections; isec != NULL; isec = isec->next)
	if ((elf_next_in_group (isec) == NULL
	     || elf_next_in_group (isec) == isec)
	    && ((isec->flags & SEC_DEBUGGING) != 0
		|| (isec->flags & (SEC_ALLOC | SEC_LOAD | SEC_RELOC)) == 0))
	  isec->gc_mark = 1;

      if (! debug_frag_seen)
	continue;

      /* Look for CODE sections which are going to be discarded,
	 and find and discard any fragmented debug sections which
	 are associated with that code section.  */
      for (isec = ibfd->sections; isec != NULL; isec = isec->next)
	if ((isec->flags & SEC_CODE) != 0
	    && isec->gc_mark == 0)
	  {
	    unsigned int ilen;
	    asection *dsec;

	    ilen = strlen (isec->name);

	    /* Association is determined by the name of the debug section
	       containing the name of the code section as a suffix.  For
	       example .debug_line.text.foo is a debug section associated
	       with .text.foo.  */
	    for (dsec = ibfd->sections; dsec != NULL; dsec = dsec->next)
	      {
		unsigned int dlen;

		if (dsec->gc_mark == 0
		    || (dsec->flags & SEC_DEBUGGING) == 0)
		  continue;

		dlen = strlen (dsec->name);

		if (dlen > ilen
		    && strncmp (dsec->name + (dlen - ilen),
				isec->name, ilen) == 0)
		  {
		    dsec->gc_mark = 0;
		    break;
		  }
	      }
	  }
    }
  return TRUE;
}

/* Sweep symbols in swept sections.  Called via elf_link_hash_traverse.  */

struct elf_gc_sweep_symbol_info
{
  struct bfd_link_info *info;
  void (*hide_symbol) (struct bfd_link_info *, struct elf_link_hash_entry *,
		       bfd_boolean);
};

static bfd_boolean
elf_gc_sweep_symbol (struct elf_link_hash_entry *h, void *data)
{
  if (!h->mark
      && (((h->root.type == bfd_link_hash_defined
	    || h->root.type == bfd_link_hash_defweak)
	   && !(h->def_regular
		&& h->root.u.def.section->gc_mark))
	  || h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak))
    {
      struct elf_gc_sweep_symbol_info *inf;

      inf = (struct elf_gc_sweep_symbol_info *) data;
      (*inf->hide_symbol) (inf->info, h, TRUE);
      h->def_regular = 0;
      h->ref_regular = 0;
      h->ref_regular_nonweak = 0;
    }

  return TRUE;
}

/* The sweep phase of garbage collection.  Remove all garbage sections.  */

typedef bfd_boolean (*gc_sweep_hook_fn)
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);

static bfd_boolean
elf_gc_sweep (bfd *abfd, struct bfd_link_info *info)
{
  bfd *sub;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  gc_sweep_hook_fn gc_sweep_hook = bed->gc_sweep_hook;
  unsigned long section_sym_count;
  struct elf_gc_sweep_symbol_info sweep_info;

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *o;

      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
	continue;

      for (o = sub->sections; o != NULL; o = o->next)
	{
	  /* When any section in a section group is kept, we keep all
	     sections in the section group.  If the first member of
	     the section group is excluded, we will also exclude the
	     group section.  */
	  if (o->flags & SEC_GROUP)
	    {
	      asection *first = elf_next_in_group (o);
	      o->gc_mark = first->gc_mark;
	    }

	  if (o->gc_mark)
	    continue;

	  /* Skip sweeping sections already excluded.  */
	  if (o->flags & SEC_EXCLUDE)
	    continue;

	  /* Since this is early in the link process, it is simple
	     to remove a section from the output.  */
	  o->flags |= SEC_EXCLUDE;

	  if (info->print_gc_sections && o->size != 0)
	    _bfd_error_handler (_("Removing unused section '%s' in file '%B'"), sub, o->name);

	  /* But we also have to update some of the relocation
	     info we collected before.  */
	  if (gc_sweep_hook
	      && (o->flags & SEC_RELOC) != 0
	      && o->reloc_count > 0
	      && !bfd_is_abs_section (o->output_section))
	    {
	      Elf_Internal_Rela *internal_relocs;
	      bfd_boolean r;

	      internal_relocs
		= _bfd_elf_link_read_relocs (o->owner, o, NULL, NULL,
					     info->keep_memory);
	      if (internal_relocs == NULL)
		return FALSE;

	      r = (*gc_sweep_hook) (o->owner, info, o, internal_relocs);

	      if (elf_section_data (o)->relocs != internal_relocs)
		free (internal_relocs);

	      if (!r)
		return FALSE;
	    }
	}
    }

  /* Remove the symbols that were in the swept sections from the dynamic
     symbol table.  GCFIXME: Anyone know how to get them out of the
     static symbol table as well?  */
  sweep_info.info = info;
  sweep_info.hide_symbol = bed->elf_backend_hide_symbol;
  elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol,
			  &sweep_info);

  _bfd_elf_link_renumber_dynsyms (abfd, info, &section_sym_count);
  return TRUE;
}

/* Propagate collected vtable information.  This is called through
   elf_link_hash_traverse.  */

static bfd_boolean
elf_gc_propagate_vtable_entries_used (struct elf_link_hash_entry *h, void *okp)
{
  /* Those that are not vtables.  */
  if (h->vtable == NULL || h->vtable->parent == NULL)
    return TRUE;

  /* Those vtables that do not have parents, we cannot merge.  */
  if (h->vtable->parent == (struct elf_link_hash_entry *) -1)
    return TRUE;

  /* If we've already been done, exit.  */
  if (h->vtable->used && h->vtable->used[-1])
    return TRUE;

  /* Make sure the parent's table is up to date.  */
  elf_gc_propagate_vtable_entries_used (h->vtable->parent, okp);

  if (h->vtable->used == NULL)
    {
      /* None of this table's entries were referenced.  Re-use the
	 parent's table.  */
      h->vtable->used = h->vtable->parent->vtable->used;
      h->vtable->size = h->vtable->parent->vtable->size;
    }
  else
    {
      size_t n;
      bfd_boolean *cu, *pu;

      /* Or the parent's entries into ours.  */
      cu = h->vtable->used;
      cu[-1] = TRUE;
      pu = h->vtable->parent->vtable->used;
      if (pu != NULL)
	{
	  const struct elf_backend_data *bed;
	  unsigned int log_file_align;

	  bed = get_elf_backend_data (h->root.u.def.section->owner);
	  log_file_align = bed->s->log_file_align;
	  n = h->vtable->parent->vtable->size >> log_file_align;
	  while (n--)
	    {
	      if (*pu)
		*cu = TRUE;
	      pu++;
	      cu++;
	    }
	}
    }

  return TRUE;
}

static bfd_boolean
elf_gc_smash_unused_vtentry_relocs (struct elf_link_hash_entry *h, void *okp)
{
  asection *sec;
  bfd_vma hstart, hend;
  Elf_Internal_Rela *relstart, *relend, *rel;
  const struct elf_backend_data *bed;
  unsigned int log_file_align;

  /* Take care of both those symbols that do not describe vtables as
     well as those that are not loaded.  */
  if (h->vtable == NULL || h->vtable->parent == NULL)
    return TRUE;

  BFD_ASSERT (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak);

  sec = h->root.u.def.section;
  hstart = h->root.u.def.value;
  hend = hstart + h->size;

  relstart = _bfd_elf_link_read_relocs (sec->owner, sec, NULL, NULL, TRUE);
  if (!relstart)
    return *(bfd_boolean *) okp = FALSE;
  bed = get_elf_backend_data (sec->owner);
  log_file_align = bed->s->log_file_align;

  relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;

  for (rel = relstart; rel < relend; ++rel)
    if (rel->r_offset >= hstart && rel->r_offset < hend)
      {
	/* If the entry is in use, do nothing.  */
	if (h->vtable->used
	    && (rel->r_offset - hstart) < h->vtable->size)
	  {
	    bfd_vma entry = (rel->r_offset - hstart) >> log_file_align;
	    if (h->vtable->used[entry])
	      continue;
	  }
	/* Otherwise, kill it.  */
	rel->r_offset = rel->r_info = rel->r_addend = 0;
      }

  return TRUE;
}

/* Mark sections containing dynamically referenced symbols.  When
   building shared libraries, we must assume that any visible symbol is
   referenced.  */

bfd_boolean
bfd_elf_gc_mark_dynamic_ref_symbol (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info = (struct bfd_link_info *) inf;

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && (h->ref_dynamic
	  || ((!info->executable || info->export_dynamic)
	      && h->def_regular
	      && ELF_ST_VISIBILITY (h->other) != STV_INTERNAL
	      && ELF_ST_VISIBILITY (h->other) != STV_HIDDEN
	      && (strchr (h->root.root.string, ELF_VER_CHR) != NULL
		  || !bfd_hide_sym_by_version (info->version_info,
					       h->root.root.string)))))
    h->root.u.def.section->flags |= SEC_KEEP;

  return TRUE;
}

/* Keep all sections containing symbols undefined on the command-line,
   and the section containing the entry symbol.  */

void
_bfd_elf_gc_keep (struct bfd_link_info *info)
{
  struct bfd_sym_chain *sym;

  for (sym = info->gc_sym_list; sym != NULL; sym = sym->next)
    {
      struct elf_link_hash_entry *h;

      h = elf_link_hash_lookup (elf_hash_table (info), sym->name,
				FALSE, FALSE, FALSE);

      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && !bfd_is_abs_section (h->root.u.def.section))
	h->root.u.def.section->flags |= SEC_KEEP;
    }
}

/* Do mark and sweep of unused sections.  */

bfd_boolean
bfd_elf_gc_sections (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean ok = TRUE;
  bfd *sub;
  elf_gc_mark_hook_fn gc_mark_hook;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (!bed->can_gc_sections
      || !is_elf_hash_table (info->hash))
    {
      (*_bfd_error_handler)(_("Warning: gc-sections option ignored"));
      return TRUE;
    }

  bed->gc_keep (info);

  /* Try to parse each bfd's .eh_frame section.  Point elf_eh_frame_section
     at the .eh_frame section if we can mark the FDEs individually.  */
  _bfd_elf_begin_eh_frame_parsing (info);
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *sec;
      struct elf_reloc_cookie cookie;

      sec = bfd_get_section_by_name (sub, ".eh_frame");
      while (sec && init_reloc_cookie_for_section (&cookie, info, sec))
	{
	  _bfd_elf_parse_eh_frame (sub, info, sec, &cookie);
	  if (elf_section_data (sec)->sec_info
	      && (sec->flags & SEC_LINKER_CREATED) == 0)
	    elf_eh_frame_section (sub) = sec;
	  fini_reloc_cookie_for_section (&cookie, sec);
	  sec = bfd_get_next_section_by_name (sec);
	}
    }
  _bfd_elf_end_eh_frame_parsing (info);

  /* Apply transitive closure to the vtable entry usage info.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_propagate_vtable_entries_used,
			  &ok);
  if (!ok)
    return FALSE;

  /* Kill the vtable relocations that were not used.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_smash_unused_vtentry_relocs,
			  &ok);
  if (!ok)
    return FALSE;

  /* Mark dynamically referenced symbols.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    elf_link_hash_traverse (elf_hash_table (info),
			    bed->gc_mark_dynamic_ref,
			    info);

  /* Grovel through relocs to find out who stays ...  */
  gc_mark_hook = bed->gc_mark_hook;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *o;

      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
	continue;

      /* Start at sections marked with SEC_KEEP (ref _bfd_elf_gc_keep).
	 Also treat note sections as a root, if the section is not part
	 of a group.  */
      for (o = sub->sections; o != NULL; o = o->next)
	if (!o->gc_mark
	    && (o->flags & SEC_EXCLUDE) == 0
	    && ((o->flags & SEC_KEEP) != 0
		|| (elf_section_data (o)->this_hdr.sh_type == SHT_NOTE
		    && elf_next_in_group (o) == NULL )))
	  {
	    if (!_bfd_elf_gc_mark (info, o, gc_mark_hook))
	      return FALSE;
	  }
    }

  /* Allow the backend to mark additional target specific sections.  */
  bed->gc_mark_extra_sections (info, gc_mark_hook);

  /* ... and mark SEC_EXCLUDE for those that go.  */
  return elf_gc_sweep (abfd, info);
}

/* Called from check_relocs to record the existence of a VTINHERIT reloc.  */

bfd_boolean
bfd_elf_gc_record_vtinherit (bfd *abfd,
			     asection *sec,
			     struct elf_link_hash_entry *h,
			     bfd_vma offset)
{
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
  struct elf_link_hash_entry **search, *child;
  bfd_size_type extsymcount;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols at
     this point.  */
  extsymcount = elf_tdata (abfd)->symtab_hdr.sh_size / bed->s->sizeof_sym;
  if (!elf_bad_symtab (abfd))
    extsymcount -= elf_tdata (abfd)->symtab_hdr.sh_info;

  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes + extsymcount;

  /* Hunt down the child symbol, which is in this section at the same
     offset as the relocation.  */
  for (search = sym_hashes; search != sym_hashes_end; ++search)
    {
      if ((child = *search) != NULL
	  && (child->root.type == bfd_link_hash_defined
	      || child->root.type == bfd_link_hash_defweak)
	  && child->root.u.def.section == sec
	  && child->root.u.def.value == offset)
	goto win;
    }

  (*_bfd_error_handler) ("%B: %A+%lu: No symbol found for INHERIT",
			 abfd, sec, (unsigned long) offset);
  bfd_set_error (bfd_error_invalid_operation);
  return FALSE;

 win:
  if (!child->vtable)
    {
      child->vtable = (struct elf_link_virtual_table_entry *)
          bfd_zalloc (abfd, sizeof (*child->vtable));
      if (!child->vtable)
	return FALSE;
    }
  if (!h)
    {
      /* This *should* only be the absolute section.  It could potentially
	 be that someone has defined a non-global vtable though, which
	 would be bad.  It isn't worth paging in the local symbols to be
	 sure though; that case should simply be handled by the assembler.  */

      child->vtable->parent = (struct elf_link_hash_entry *) -1;
    }
  else
    child->vtable->parent = h;

  return TRUE;
}

/* Called from check_relocs to record the existence of a VTENTRY reloc.  */

bfd_boolean
bfd_elf_gc_record_vtentry (bfd *abfd ATTRIBUTE_UNUSED,
			   asection *sec ATTRIBUTE_UNUSED,
			   struct elf_link_hash_entry *h,
			   bfd_vma addend)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  unsigned int log_file_align = bed->s->log_file_align;

  if (!h->vtable)
    {
      h->vtable = (struct elf_link_virtual_table_entry *)
          bfd_zalloc (abfd, sizeof (*h->vtable));
      if (!h->vtable)
	return FALSE;
    }

  if (addend >= h->vtable->size)
    {
      size_t size, bytes, file_align;
      bfd_boolean *ptr = h->vtable->used;

      /* While the symbol is undefined, we have to be prepared to handle
	 a zero size.  */
      file_align = 1 << log_file_align;
      if (h->root.type == bfd_link_hash_undefined)
	size = addend + file_align;
      else
	{
	  size = h->size;
	  if (addend >= size)
	    {
	      /* Oops!  We've got a reference past the defined end of
		 the table.  This is probably a bug -- shall we warn?  */
	      size = addend + file_align;
	    }
	}
      size = (size + file_align - 1) & -file_align;

      /* Allocate one extra entry for use as a "done" flag for the
	 consolidation pass.  */
      bytes = ((size >> log_file_align) + 1) * sizeof (bfd_boolean);

      if (ptr)
	{
	  ptr = (bfd_boolean *) bfd_realloc (ptr - 1, bytes);

	  if (ptr != NULL)
	    {
	      size_t oldbytes;

	      oldbytes = (((h->vtable->size >> log_file_align) + 1)
			  * sizeof (bfd_boolean));
	      memset (((char *) ptr) + oldbytes, 0, bytes - oldbytes);
	    }
	}
      else
	ptr = (bfd_boolean *) bfd_zmalloc (bytes);

      if (ptr == NULL)
	return FALSE;

      /* And arrange for that done flag to be at index -1.  */
      h->vtable->used = ptr + 1;
      h->vtable->size = size;
    }

  h->vtable->used[addend >> log_file_align] = TRUE;

  return TRUE;
}

/* Map an ELF section header flag to its corresponding string.  */
typedef struct
{
  char *flag_name;
  flagword flag_value;
} elf_flags_to_name_table;

static elf_flags_to_name_table elf_flags_to_names [] =
{
  { "SHF_WRITE", SHF_WRITE },
  { "SHF_ALLOC", SHF_ALLOC },
  { "SHF_EXECINSTR", SHF_EXECINSTR },
  { "SHF_MERGE", SHF_MERGE },
  { "SHF_STRINGS", SHF_STRINGS },
  { "SHF_INFO_LINK", SHF_INFO_LINK},
  { "SHF_LINK_ORDER", SHF_LINK_ORDER},
  { "SHF_OS_NONCONFORMING", SHF_OS_NONCONFORMING},
  { "SHF_GROUP", SHF_GROUP },
  { "SHF_TLS", SHF_TLS },
  { "SHF_MASKOS", SHF_MASKOS },
  { "SHF_EXCLUDE", SHF_EXCLUDE },
};

/* Returns TRUE if the section is to be included, otherwise FALSE.  */
bfd_boolean
bfd_elf_lookup_section_flags (struct bfd_link_info *info,
			      struct flag_info *flaginfo,
			      asection *section)
{
  const bfd_vma sh_flags = elf_section_flags (section);

  if (!flaginfo->flags_initialized)
    {
      bfd *obfd = info->output_bfd;
      const struct elf_backend_data *bed = get_elf_backend_data (obfd);
      struct flag_info_list *tf = flaginfo->flag_list;
      int with_hex = 0;
      int without_hex = 0;

      for (tf = flaginfo->flag_list; tf != NULL; tf = tf->next)
	{
	  unsigned i;
	  flagword (*lookup) (char *);

	  lookup = bed->elf_backend_lookup_section_flags_hook;
	  if (lookup != NULL)
	    {
	      flagword hexval = (*lookup) ((char *) tf->name);

	      if (hexval != 0)
		{
		  if (tf->with == with_flags)
		    with_hex |= hexval;
		  else if (tf->with == without_flags)
		    without_hex |= hexval;
		  tf->valid = TRUE;
		  continue;
		}
	    }
	  for (i = 0; i < ARRAY_SIZE (elf_flags_to_names); ++i)
	    {
	      if (strcmp (tf->name, elf_flags_to_names[i].flag_name) == 0)
		{
		  if (tf->with == with_flags)
		    with_hex |= elf_flags_to_names[i].flag_value;
		  else if (tf->with == without_flags)
		    without_hex |= elf_flags_to_names[i].flag_value;
		  tf->valid = TRUE;
		  break;
		}
	    }
	  if (!tf->valid)
	    {
	      info->callbacks->einfo
		(_("Unrecognized INPUT_SECTION_FLAG %s\n"), tf->name);
	      return FALSE;
	    }
	}
      flaginfo->flags_initialized = TRUE;
      flaginfo->only_with_flags |= with_hex;
      flaginfo->not_with_flags |= without_hex;
    }

  if ((flaginfo->only_with_flags & sh_flags) != flaginfo->only_with_flags)
    return FALSE;

  if ((flaginfo->not_with_flags & sh_flags) != 0)
    return FALSE;

  return TRUE;
}

struct alloc_got_off_arg {
  bfd_vma gotoff;
  struct bfd_link_info *info;
};

/* We need a special top-level link routine to convert got reference counts
   to real got offsets.  */

static bfd_boolean
elf_gc_allocate_got_offsets (struct elf_link_hash_entry *h, void *arg)
{
  struct alloc_got_off_arg *gofarg = (struct alloc_got_off_arg *) arg;
  bfd *obfd = gofarg->info->output_bfd;
  const struct elf_backend_data *bed = get_elf_backend_data (obfd);

  if (h->got.refcount > 0)
    {
      h->got.offset = gofarg->gotoff;
      gofarg->gotoff += bed->got_elt_size (obfd, gofarg->info, h, NULL, 0);
    }
  else
    h->got.offset = (bfd_vma) -1;

  return TRUE;
}

/* And an accompanying bit to work out final got entry offsets once
   we're done.  Should be called from final_link.  */

bfd_boolean
bfd_elf_gc_common_finalize_got_offsets (bfd *abfd,
					struct bfd_link_info *info)
{
  bfd *i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_vma gotoff;
  struct alloc_got_off_arg gofarg;

  BFD_ASSERT (abfd == info->output_bfd);

  if (! is_elf_hash_table (info->hash))
    return FALSE;

  /* The GOT offset is relative to the .got section, but the GOT header is
     put into the .got.plt section, if the backend uses it.  */
  if (bed->want_got_plt)
    gotoff = 0;
  else
    gotoff = bed->got_header_size;

  /* Do the local .got entries first.  */
  for (i = info->input_bfds; i; i = i->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_size_type j, locsymcount;
      Elf_Internal_Shdr *symtab_hdr;

      if (bfd_get_flavour (i) != bfd_target_elf_flavour)
	continue;

      local_got = elf_local_got_refcounts (i);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (i)->symtab_hdr;
      if (elf_bad_symtab (i))
	locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      else
	locsymcount = symtab_hdr->sh_info;

      for (j = 0; j < locsymcount; ++j)
	{
	  if (local_got[j] > 0)
	    {
	      local_got[j] = gotoff;
	      gotoff += bed->got_elt_size (abfd, info, NULL, i, j);
	    }
	  else
	    local_got[j] = (bfd_vma) -1;
	}
    }

  /* Then the global .got entries.  .plt refcounts are handled by
     adjust_dynamic_symbol  */
  gofarg.gotoff = gotoff;
  gofarg.info = info;
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_allocate_got_offsets,
			  &gofarg);
  return TRUE;
}

/* Many folk need no more in the way of final link than this, once
   got entry reference counting is enabled.  */

bfd_boolean
bfd_elf_gc_common_final_link (bfd *abfd, struct bfd_link_info *info)
{
  if (!bfd_elf_gc_common_finalize_got_offsets (abfd, info))
    return FALSE;

  /* Invoke the regular ELF backend linker to do all the work.  */
  return bfd_elf_final_link (abfd, info);
}

bfd_boolean
bfd_elf_reloc_symbol_deleted_p (bfd_vma offset, void *cookie)
{
  struct elf_reloc_cookie *rcookie = (struct elf_reloc_cookie *) cookie;

  if (rcookie->bad_symtab)
    rcookie->rel = rcookie->rels;

  for (; rcookie->rel < rcookie->relend; rcookie->rel++)
    {
      unsigned long r_symndx;

      if (! rcookie->bad_symtab)
	if (rcookie->rel->r_offset > offset)
	  return FALSE;
      if (rcookie->rel->r_offset != offset)
	continue;

      r_symndx = rcookie->rel->r_info >> rcookie->r_sym_shift;
      if (r_symndx == STN_UNDEF)
	return TRUE;

      if (r_symndx >= rcookie->locsymcount
	  || ELF_ST_BIND (rcookie->locsyms[r_symndx].st_info) != STB_LOCAL)
	{
	  struct elf_link_hash_entry *h;

	  h = rcookie->sym_hashes[r_symndx - rcookie->extsymoff];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && discarded_section (h->root.u.def.section))
	    return TRUE;
	  else
	    return FALSE;
	}
      else
	{
	  /* It's not a relocation against a global symbol,
	     but it could be a relocation against a local
	     symbol for a discarded section.  */
	  asection *isec;
	  Elf_Internal_Sym *isym;

	  /* Need to: get the symbol; get the section.  */
	  isym = &rcookie->locsyms[r_symndx];
	  isec = bfd_section_from_elf_index (rcookie->abfd, isym->st_shndx);
	  if (isec != NULL && discarded_section (isec))
	    return TRUE;
	}
      return FALSE;
    }
  return FALSE;
}

/* Discard unneeded references to discarded sections.
   Returns TRUE if any section's size was changed.  */
/* This function assumes that the relocations are in sorted order,
   which is true for all known assemblers.  */

bfd_boolean
bfd_elf_discard_info (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_reloc_cookie cookie;
  asection *stab, *eh;
  const struct elf_backend_data *bed;
  bfd *abfd;
  bfd_boolean ret = FALSE;

  if (info->traditional_format
      || !is_elf_hash_table (info->hash))
    return FALSE;

  _bfd_elf_begin_eh_frame_parsing (info);
  for (abfd = info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    {
      if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
	continue;

      bed = get_elf_backend_data (abfd);

      eh = NULL;
      if (!info->relocatable)
	{
	  eh = bfd_get_section_by_name (abfd, ".eh_frame");
	  while (eh != NULL
		 && (eh->size == 0
		     || bfd_is_abs_section (eh->output_section)))
	    eh = bfd_get_next_section_by_name (eh);
	}

      stab = bfd_get_section_by_name (abfd, ".stab");
      if (stab != NULL
	  && (stab->size == 0
	      || bfd_is_abs_section (stab->output_section)
	      || stab->sec_info_type != SEC_INFO_TYPE_STABS))
	stab = NULL;

      if (stab == NULL
	  && eh == NULL
	  && bed->elf_backend_discard_info == NULL)
	continue;

      if (!init_reloc_cookie (&cookie, info, abfd))
	return FALSE;

      if (stab != NULL
	  && stab->reloc_count > 0
	  && init_reloc_cookie_rels (&cookie, info, abfd, stab))
	{
	  if (_bfd_discard_section_stabs (abfd, stab,
					  elf_section_data (stab)->sec_info,
					  bfd_elf_reloc_symbol_deleted_p,
					  &cookie))
	    ret = TRUE;
	  fini_reloc_cookie_rels (&cookie, stab);
	}

      while (eh != NULL
	     && init_reloc_cookie_rels (&cookie, info, abfd, eh))
	{
	  _bfd_elf_parse_eh_frame (abfd, info, eh, &cookie);
	  if (_bfd_elf_discard_section_eh_frame (abfd, info, eh,
						 bfd_elf_reloc_symbol_deleted_p,
						 &cookie))
	    ret = TRUE;
	  fini_reloc_cookie_rels (&cookie, eh);
	  eh = bfd_get_next_section_by_name (eh);
	}

      if (bed->elf_backend_discard_info != NULL
	  && (*bed->elf_backend_discard_info) (abfd, &cookie, info))
	ret = TRUE;

      fini_reloc_cookie (&cookie, abfd);
    }
  _bfd_elf_end_eh_frame_parsing (info);

  if (info->eh_frame_hdr
      && !info->relocatable
      && _bfd_elf_discard_section_eh_frame_hdr (output_bfd, info))
    ret = TRUE;

  return ret;
}

bfd_boolean
_bfd_elf_section_already_linked (bfd *abfd,
				 asection *sec,
				 struct bfd_link_info *info)
{
  flagword flags;
  const char *name, *key;
  struct bfd_section_already_linked *l;
  struct bfd_section_already_linked_hash_entry *already_linked_list;

  if (sec->output_section == bfd_abs_section_ptr)
    return FALSE;

  flags = sec->flags;

  /* Return if it isn't a linkonce section.  A comdat group section
     also has SEC_LINK_ONCE set.  */
  if ((flags & SEC_LINK_ONCE) == 0)
    return FALSE;

  /* Don't put group member sections on our list of already linked
     sections.  They are handled as a group via their group section.  */
  if (elf_sec_group (sec) != NULL)
    return FALSE;

  /* For a SHT_GROUP section, use the group signature as the key.  */
  name = sec->name;
  if ((flags & SEC_GROUP) != 0
      && elf_next_in_group (sec) != NULL
      && elf_group_name (elf_next_in_group (sec)) != NULL)
    key = elf_group_name (elf_next_in_group (sec));
  else
    {
      /* Otherwise we should have a .gnu.linkonce.<type>.<key> section.  */
      if (CONST_STRNEQ (name, ".gnu.linkonce.")
	  && (key = strchr (name + sizeof (".gnu.linkonce.") - 1, '.')) != NULL)
	key++;
      else
	/* Must be a user linkonce section that doesn't follow gcc's
	   naming convention.  In this case we won't be matching
	   single member groups.  */
	key = name;
    }

  already_linked_list = bfd_section_already_linked_table_lookup (key);

  for (l = already_linked_list->entry; l != NULL; l = l->next)
    {
      /* We may have 2 different types of sections on the list: group
	 sections with a signature of <key> (<key> is some string),
	 and linkonce sections named .gnu.linkonce.<type>.<key>.
	 Match like sections.  LTO plugin sections are an exception.
	 They are always named .gnu.linkonce.t.<key> and match either
	 type of section.  */
      if (((flags & SEC_GROUP) == (l->sec->flags & SEC_GROUP)
	   && ((flags & SEC_GROUP) != 0
	       || strcmp (name, l->sec->name) == 0))
	  || (l->sec->owner->flags & BFD_PLUGIN) != 0)
	{
	  /* The section has already been linked.  See if we should
	     issue a warning.  */
	  if (!_bfd_handle_already_linked (sec, l, info))
	    return FALSE;

	  if (flags & SEC_GROUP)
	    {
	      asection *first = elf_next_in_group (sec);
	      asection *s = first;

	      while (s != NULL)
		{
		  s->output_section = bfd_abs_section_ptr;
		  /* Record which group discards it.  */
		  s->kept_section = l->sec;
		  s = elf_next_in_group (s);
		  /* These lists are circular.  */
		  if (s == first)
		    break;
		}
	    }

	  return TRUE;
	}
    }

  /* A single member comdat group section may be discarded by a
     linkonce section and vice versa.  */
  if ((flags & SEC_GROUP) != 0)
    {
      asection *first = elf_next_in_group (sec);

      if (first != NULL && elf_next_in_group (first) == first)
	/* Check this single member group against linkonce sections.  */
	for (l = already_linked_list->entry; l != NULL; l = l->next)
	  if ((l->sec->flags & SEC_GROUP) == 0
	      && bfd_elf_match_symbols_in_sections (l->sec, first, info))
	    {
	      first->output_section = bfd_abs_section_ptr;
	      first->kept_section = l->sec;
	      sec->output_section = bfd_abs_section_ptr;
	      break;
	    }
    }
  else
    /* Check this linkonce section against single member groups.  */
    for (l = already_linked_list->entry; l != NULL; l = l->next)
      if (l->sec->flags & SEC_GROUP)
	{
	  asection *first = elf_next_in_group (l->sec);

	  if (first != NULL
	      && elf_next_in_group (first) == first
	      && bfd_elf_match_symbols_in_sections (first, sec, info))
	    {
	      sec->output_section = bfd_abs_section_ptr;
	      sec->kept_section = first;
	      break;
	    }
	}

  /* Do not complain on unresolved relocations in `.gnu.linkonce.r.F'
     referencing its discarded `.gnu.linkonce.t.F' counterpart - g++-3.4
     specific as g++-4.x is using COMDAT groups (without the `.gnu.linkonce'
     prefix) instead.  `.gnu.linkonce.r.*' were the `.rodata' part of its
     matching `.gnu.linkonce.t.*'.  If `.gnu.linkonce.r.F' is not discarded
     but its `.gnu.linkonce.t.F' is discarded means we chose one-only
     `.gnu.linkonce.t.F' section from a different bfd not requiring any
     `.gnu.linkonce.r.F'.  Thus `.gnu.linkonce.r.F' should be discarded.
     The reverse order cannot happen as there is never a bfd with only the
     `.gnu.linkonce.r.F' section.  The order of sections in a bfd does not
     matter as here were are looking only for cross-bfd sections.  */

  if ((flags & SEC_GROUP) == 0 && CONST_STRNEQ (name, ".gnu.linkonce.r."))
    for (l = already_linked_list->entry; l != NULL; l = l->next)
      if ((l->sec->flags & SEC_GROUP) == 0
	  && CONST_STRNEQ (l->sec->name, ".gnu.linkonce.t."))
	{
	  if (abfd != l->sec->owner)
	    sec->output_section = bfd_abs_section_ptr;
	  break;
	}

  /* This is the first section with this name.  Record it.  */
  if (!bfd_section_already_linked_table_insert (already_linked_list, sec))
    info->callbacks->einfo (_("%F%P: already_linked_table: %E\n"));
  return sec->output_section == bfd_abs_section_ptr;
}

bfd_boolean
_bfd_elf_common_definition (Elf_Internal_Sym *sym)
{
  return sym->st_shndx == SHN_COMMON;
}

unsigned int
_bfd_elf_common_section_index (asection *sec ATTRIBUTE_UNUSED)
{
  return SHN_COMMON;
}

asection *
_bfd_elf_common_section (asection *sec ATTRIBUTE_UNUSED)
{
  return bfd_com_section_ptr;
}

bfd_vma
_bfd_elf_default_got_elt_size (bfd *abfd,
			       struct bfd_link_info *info ATTRIBUTE_UNUSED,
			       struct elf_link_hash_entry *h ATTRIBUTE_UNUSED,
			       bfd *ibfd ATTRIBUTE_UNUSED,
			       unsigned long symndx ATTRIBUTE_UNUSED)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  return bed->s->arch_size / 8;
}

/* Routines to support the creation of dynamic relocs.  */

/* Returns the name of the dynamic reloc section associated with SEC.  */

static const char *
get_dynamic_reloc_section_name (bfd *       abfd,
				asection *  sec,
				bfd_boolean is_rela)
{
  char *name;
  const char *old_name = bfd_get_section_name (NULL, sec);
  const char *prefix = is_rela ? ".rela" : ".rel";

  if (old_name == NULL)
    return NULL;

  name = bfd_alloc (abfd, strlen (prefix) + strlen (old_name) + 1);
  sprintf (name, "%s%s", prefix, old_name);

  return name;
}

/* Returns the dynamic reloc section associated with SEC.
   If necessary compute the name of the dynamic reloc section based
   on SEC's name (looked up in ABFD's string table) and the setting
   of IS_RELA.  */

asection *
_bfd_elf_get_dynamic_reloc_section (bfd *       abfd,
				    asection *  sec,
				    bfd_boolean is_rela)
{
  asection * reloc_sec = elf_section_data (sec)->sreloc;

  if (reloc_sec == NULL)
    {
      const char * name = get_dynamic_reloc_section_name (abfd, sec, is_rela);

      if (name != NULL)
	{
	  reloc_sec = bfd_get_linker_section (abfd, name);

	  if (reloc_sec != NULL)
	    elf_section_data (sec)->sreloc = reloc_sec;
	}
    }

  return reloc_sec;
}

/* Returns the dynamic reloc section associated with SEC.  If the
   section does not exist it is created and attached to the DYNOBJ
   bfd and stored in the SRELOC field of SEC's elf_section_data
   structure.

   ALIGNMENT is the alignment for the newly created section and
   IS_RELA defines whether the name should be .rela.<SEC's name>
   or .rel.<SEC's name>.  The section name is looked up in the
   string table associated with ABFD.  */

asection *
_bfd_elf_make_dynamic_reloc_section (asection *         sec,
				     bfd *		dynobj,
				     unsigned int	alignment,
				     bfd *              abfd,
				     bfd_boolean        is_rela)
{
  asection * reloc_sec = elf_section_data (sec)->sreloc;

  if (reloc_sec == NULL)
    {
      const char * name = get_dynamic_reloc_section_name (abfd, sec, is_rela);

      if (name == NULL)
	return NULL;

      reloc_sec = bfd_get_linker_section (dynobj, name);

      if (reloc_sec == NULL)
	{
	  flagword flags = (SEC_HAS_CONTENTS | SEC_READONLY
			    | SEC_IN_MEMORY | SEC_LINKER_CREATED);
	  if ((sec->flags & SEC_ALLOC) != 0)
	    flags |= SEC_ALLOC | SEC_LOAD;

	  reloc_sec = bfd_make_section_anyway_with_flags (dynobj, name, flags);
	  if (reloc_sec != NULL)
	    {
	      /* _bfd_elf_get_sec_type_attr chooses a section type by
		 name.  Override as it may be wrong, eg. for a user
		 section named "auto" we'll get ".relauto" which is
		 seen to be a .rela section.  */
	      elf_section_type (reloc_sec) = is_rela ? SHT_RELA : SHT_REL;
	      if (! bfd_set_section_alignment (dynobj, reloc_sec, alignment))
		reloc_sec = NULL;
	    }
	}

      elf_section_data (sec)->sreloc = reloc_sec;
    }

  return reloc_sec;
}

/* Copy the ELF symbol type associated with a linker hash entry.  */
void
_bfd_elf_copy_link_hash_symbol_type (bfd *abfd ATTRIBUTE_UNUSED,
    struct bfd_link_hash_entry * hdest,
    struct bfd_link_hash_entry * hsrc)
{
  struct elf_link_hash_entry *ehdest = (struct elf_link_hash_entry *)hdest;
  struct elf_link_hash_entry *ehsrc = (struct elf_link_hash_entry *)hsrc;

  ehdest->type = ehsrc->type;
  ehdest->target_internal = ehsrc->target_internal;
}

/* Append a RELA relocation REL to section S in BFD.  */

void
elf_append_rela (bfd *abfd, asection *s, Elf_Internal_Rela *rel)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_byte *loc = s->contents + (s->reloc_count++ * bed->s->sizeof_rela);
  BFD_ASSERT (loc + bed->s->sizeof_rela <= s->contents + s->size);
  bed->s->swap_reloca_out (abfd, rel, loc);
}

/* Append a REL relocation REL to section S in BFD.  */

void
elf_append_rel (bfd *abfd, asection *s, Elf_Internal_Rela *rel)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_byte *loc = s->contents + (s->reloc_count++ * bed->s->sizeof_rel);
  BFD_ASSERT (loc + bed->s->sizeof_rel <= s->contents + s->size);
  bed->s->swap_reloc_out (abfd, rel, loc);
}
@


1.498
log
@	* elflink.c (_bfd_elf_merge_symbol): Set *poldbfd, *poldweak,
	and *poldalignment before exiting when !relocs_compatible.
@
text
@d3312 12
d3781 1
a3781 2
      if (!(*info->callbacks->notice) (info, NULL, abfd, NULL,
				       notice_as_needed, 0, NULL))
a4474 2
      if (bed->as_needed_cleanup)
	(*bed->as_needed_cleanup) (abfd, info);
d4536 1
a4536 2
      if (!(*info->callbacks->notice) (info, NULL, abfd, NULL,
				       notice_not_needed, 0, NULL))
d4549 1
a4549 2
      if (!(*info->callbacks->notice) (info, NULL, abfd, NULL,
				       notice_needed, 0, NULL))
@


1.497
log
@	* elflink.c (_bfd_elf_define_linkage_sym): Don't set STV_INTERNAL
	symbols to STV_HIDDEN.
@
text
@a953 5
  /* This code is for coping with dynamic objects, and is only useful
     if we are doing an ELF link.  */
  if (!(*bed->relocs_compatible) (abfd->xvec, info->output_bfd->xvec))
    return TRUE;

d961 43
a1047 39
  /* OLDBFD and OLDSEC are a BFD and an ASECTION associated with the
     existing symbol.  */

  switch (h->root.type)
    {
    default:
      oldbfd = NULL;
      oldsec = NULL;
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      oldbfd = h->root.u.undef.abfd;
      oldsec = NULL;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      oldbfd = h->root.u.def.section->owner;
      oldsec = h->root.u.def.section;
      break;

    case bfd_link_hash_common:
      oldbfd = h->root.u.c.p->section->owner;
      oldsec = h->root.u.c.p->section;
      if (pold_alignment)
	*pold_alignment = h->root.u.c.p->alignment_power;
      break;
    }
  if (poldbfd && *poldbfd == NULL)
    *poldbfd = oldbfd;

  /* Differentiate strong and weak symbols.  */
  newweak = bind == STB_WEAK;
  oldweak = (h->root.type == bfd_link_hash_defweak
	     || h->root.type == bfd_link_hash_undefweak);
  if (pold_weak)
    *pold_weak = oldweak;

@


1.496
log
@	PR ld/15762
	PR ld/12761
	* elflink.c (elf_link_add_object_symbols): Correct test in
	last patch.  Remove unnecessary code.
@
text
@d88 2
a89 1
  h->other = (h->other & ~ELF_ST_VISIBILITY (-1)) | STV_HIDDEN;
@


1.495
log
@	PR ld/15762
	PR ld/12761
	* elflink.c (elf_link_add_object_symbols): Don't clobber
	.gnu.warning.symbol sections when shared.
@
text
@d3347 1
d3389 1
a3389 1
  if (info->executable || info->shared)
d3391 1
a3391 1
      asection *s;
d3393 2
a3394 1
      for (s = abfd->sections; s != NULL; s = s->next)
d3396 2
a3397 1
	  const char *name;
d3399 1
a3399 5
	  name = bfd_get_section_name (abfd, s);
	  if (CONST_STRNEQ (name, ".gnu.warning."))
	    {
	      char *msg;
	      bfd_size_type sz;
d3401 21
a3421 1
	      name += sizeof ".gnu.warning." - 1;
d3423 4
a3426 27
	      /* If this is a shared object, then look up the symbol
		 in the hash table.  If it is there, and it is already
		 been defined, then we will not be using the entry
		 from this shared object, so we don't need to warn.
		 FIXME: If we see the definition in a regular object
		 later on, we will warn, but we shouldn't.  The only
		 fix is to keep track of what warnings we are supposed
		 to emit, and then handle them all at the end of the
		 link.  */
	      if (dynamic)
		{
		  struct elf_link_hash_entry *h;

		  h = elf_link_hash_lookup (htab, name, FALSE, FALSE, TRUE);

		  /* FIXME: What about bfd_link_hash_common?  */
		  if (h != NULL
		      && (h->root.type == bfd_link_hash_defined
			  || h->root.type == bfd_link_hash_defweak))
		    {
		      /* We don't want to issue this warning.  Clobber
			 the section size so that the warning does not
			 get copied into the output file.  */
		      s->size = 0;
		      continue;
		    }
		}
d3428 2
a3429 4
	      sz = s->size;
	      msg = (char *) bfd_alloc (abfd, sz + 1);
	      if (msg == NULL)
		goto error_return;
d3431 1
a3431 2
	      if (! bfd_get_section_contents (abfd, s, msg, 0, sz))
		goto error_return;
d3433 4
a3436 1
	      msg[sz] = '\0';
d3438 9
a3446 15
	      if (! (_bfd_generic_link_add_one_symbol
		     (info, abfd, name, BSF_WARNING, s, 0, msg,
		      FALSE, bed->collect, NULL)))
		goto error_return;

	      if (!info->relocatable && !info->shared)
		{
		  /* Clobber the section size so that the warning does
		     not get copied into the output file.  */
		  s->size = 0;

		  /* Also set SEC_EXCLUDE, so that symbols defined in
		     the warning section don't get copied to the output.  */
		  s->flags |= SEC_EXCLUDE;
		}
a3471 1
      asection *s;
@


1.494
log
@	* elflink.c (elf_link_add_object_symbols): Don't omit reading
	of symbols when hashes already exist.
@
text
@d3447 1
a3447 1
	      if (! info->relocatable)
@


1.493
log
@	* elflink.c (elf_link_add_object_symbols): Don't save symbol
	hashes around loading as-needed library.  Zero them on allocation,
	and restore to initial all-zero state if library not needed.
	Arrange to reuse hashes if we load library again later.
@
text
@d3702 1
a3702 1
  if (sym_hash == NULL && extsymcount != 0)
a3708 4
      /* We store a pointer to the hash table entry for each external
	 symbol.  */
      amt = extsymcount * sizeof (struct elf_link_hash_entry *);
      sym_hash = (struct elf_link_hash_entry **) bfd_zalloc (abfd, amt);
d3710 9
a3718 2
	goto error_free_sym;
      elf_sym_hashes (abfd) = sym_hash;
@


1.492
log
@	PR binutils/15417
	* elflink.c (elf_link_add_object_symbols): Initialise 'idx' to
	zero.
@
text
@a3340 1
  void *old_hash;
a3346 1
  size_t hashsize = 0;
d3701 2
a3702 2
  sym_hash = NULL;
  if (extsymcount != 0)
d3712 1
a3712 1
      sym_hash = (struct elf_link_hash_entry **) bfd_alloc (abfd, amt);
d3765 1
a3765 2
      hashsize = extsymcount * sizeof (struct elf_link_hash_entry *);
      old_tab = bfd_malloc (tabsize + entsize + hashsize);
d3781 3
a3783 4
      /* Clone the symbol table and sym hashes.  Remember some
	 pointers into the symbol table, and dynamic symbol count.  */
      old_hash = (char *) old_tab + tabsize;
      old_ent = (char *) old_hash + hashsize;
a3784 1
      memcpy (old_hash, sym_hash, hashsize);
a3840 1
      *sym_hash = NULL;
d4474 3
a4476 3
      old_hash = (char *) old_tab + tabsize;
      old_ent = (char *) old_hash + hashsize;
      sym_hash = elf_sym_hashes (abfd);
a4480 1
      memcpy (sym_hash, old_hash, hashsize);
@


1.491
log
@	* elflink.c (bfd_elf_record_link_assignment): Dont make
	STV_INTERNAL symbols STV_HIDDEN.
@
text
@d4668 1
a4668 1
	  size_t i, j, idx;
@


1.490
log
@	* elflink.c (_bfd_elf_gc_mark_extra_sections): Remove mark from
	fragmented .debug_line sections associated with unmarked code
	sections.

	* dwarf.c (read_debug_line_header): New function.  Reads in a
	header in a .debug_line section.
	(display_debug_lines_raw): Use new function.  Handle fragmentary
	.debug_line sections.
	(display_debug_lines_decoded): Likewise.
	* readelf.c (process_section_headers): Handle fragmenatry
	.debug_line sections.
	(display_debug_section): Likewise.

	* as.c (Options): Add -gdwarf-sections.
	(parse_args): Likewise.
	* as.h (flag_dwarf_sections): Declare.
	* dwarf2dbg.c (emit_fixed_inc_line_addr): Skip section changes.
	(process_entries): When -gdwarf-sections is enabled generate
	fragmentary .debug_line sections.
	(out_debug_line): Set the section for the .debug_line section end
	symbol.
	* doc/as.texinfo: Document -gdwarf-sections.
	* NEWS: Mention -gdwarf-sections.

	* gas/elf/dwarf2-3.d: Fix expected readelf output.

	* scripttempl/DWARF.sc: Add support for .debug_line.* and
	.debug_line_end.
@
text
@d576 2
a577 1
      h->other = (h->other & ~ELF_ST_VISIBILITY (-1)) | STV_HIDDEN;
@


1.489
log
@oops - revert accidental commit
@
text
@d11817 1
d11822 4
a11825 3
      /* Ensure all linker created sections are kept, and see whether
	 any other section is already marked.  */
      some_kept = FALSE;
d11832 5
d11840 1
a11840 1
	 toss out debug sections.  */
d11852 39
@


1.488
log
@	* ecoff.c: casting the return value of BFD_ALIGN to int
	* elf32-tic6x.c: removing unused variables
	* elf32-v850.c: redefine the type of a variable (int -> bfd_vma)
	* vms-alpha.c: initialize a variable
@
text
@a11844 38
      /* Look for CODE sections which are going to be discarded.  */
      for (isec = ibfd->sections; isec != NULL; isec = isec->next)
	if ((isec->flags & SEC_CODE) != 0
	    && isec->gc_mark == 0)
	  {
	    unsigned int ilen;
	    asection *dsec;

	    ilen = strlen (isec->name);

	    /* Determine if there are any debug sections associated
	       with this code section.  If so, remove their mark 
	       (which may have been set above) so that they can be
	       garbage collected as well.

	       Association is determined by the name of the debug section
	       containing the name of the code section as a suffix.  For
	       example .debug_line.text.foo is a debug section associated
	       with .text.foo.  */
	    for (dsec = ibfd->sections; dsec != NULL; dsec = dsec->next)
	      {
		unsigned int dlen;

		if (dsec->gc_mark == 0
		    || (dsec->flags & SEC_DEBUGGING) == 0)
		  continue;

		dlen = strlen (dsec->name);

		if (dlen > ilen
		    && strncmp (dsec->name + (dlen - ilen),
				isec->name, ilen) == 0)
		  {
		    dsec->gc_mark = 0;
		    break;
		  }
	      }
	  }
@


1.487
log
@	* elflink.c (elf_link_add_object_symbols): Revert accidental commit.
@
text
@d2 1
a2 3
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
   Free Software Foundation, Inc.
d11845 38
@


1.486
log
@	* bfd.c (bfd_error_type, bfd_errmsgs): Add bfd_error_missing_dso.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_add_object_symbols): Use new error.
@
text
@a4439 1
		  && h->ref_regular_nonweak
@


1.485
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d4446 1
a4446 5
		  (*_bfd_error_handler)
		    (_("note: '%s' is defined in DSO %B"
		       " so try adding it to the linker command line"),
		     abfd, name);
		  bfd_set_error (bfd_error_invalid_operation);
@


1.484
log
@	* elflink.c (_bfd_elf_add_default_symbol): Preserve section
	over _bfd_elf_merge_symbol calls.
@
text
@a8099 1
  int copya, copyb;
d8101 4
a8108 6
  copya = (a->type == reloc_class_copy) * 2 + (a->type == reloc_class_plt);
  copyb = (b->type == reloc_class_copy) * 2 + (b->type == reloc_class_plt);
  if (copya < copyb)
    return -1;
  if (copya > copyb)
    return 1;
d8334 1
a8334 1
	    s->type = (*bed->elf_backend_reloc_type_class) (s->rela);
@


1.483
log
@	* elflink.c (elf_link_add_object_symbols): Add assertion for
	common override alignment check code.  Formatting.
@
text
@d1603 1
d1630 2
a1631 1
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &sec, &value,
d1739 2
a1740 1
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &sec, &value,
@


1.482
log
@	* elflink.c (_bfd_elf_merge_symbol): Set old_alignment for
	usual common symbols as well as for dynamic.  Add poldbfd param.
	Save old bfd.  Adjust callers.
	(_bfd_elf_add_default_symbol): Add poldbfd param.  Pass "section"
	and "value" by value, not pointer.  Adjust caller.
	(elf_link_add_object_symbols): Combine undef_bfd and old_bfd vars.
	Delete code to set same.  Use old_bfd and old_alignment from
	_bfd_elf_merge_symbol instead.  Add default symbol before
	alignment and size checks.  Wrap overlong lines.
@
text
@d4258 3
d4304 2
a4305 1
	  if ((isym->st_size != 0 && isym->st_shndx != SHN_UNDEF)
@


1.481
log
@	* elflink.c (_bfd_elf_add_default_symbol): Delete "override" param.
	(elf_link_add_object_symbols): Don't call _bfd_elf_add_default_symbol
	when override is true.
@
text
@d898 12
a909 11
/* This function is called when we want to define a new symbol.  It
   handles the various cases which arise when we find a definition in
   a dynamic object, or when there is already a definition in a
   dynamic object.  The new symbol is described by NAME, SYM, PSEC,
   and PVALUE.  We set SYM_HASH to the hash table entry.  We set
   OVERRIDE if the old symbol is overriding a new definition.  We set
   TYPE_CHANGE_OK if it is OK for the type to change.  We set
   SIZE_CHANGE_OK if it is OK for the size to change.  By OK to
   change, we mean that we shouldn't warn if the type or size does
   change.  We set POLD_ALIGNMENT if an old common symbol in a dynamic
   object is overridden by a regular object.  */
d918 2
a921 1
		       struct elf_link_hash_entry **sym_hash,
d1035 2
d1039 2
d1577 1
a1577 1
   symbol is described by H, NAME, SYM, PSEC, VALUE, and OVERRIDE.  We
d1586 3
a1588 2
			     asection **psec,
			     bfd_vma *value,
a1602 1
  asection *sec;
d1629 2
a1630 3
  sec = *psec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
			      NULL, NULL, &hi, &skip, &override,
d1737 2
a1738 3
  sec = *psec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
			      NULL, NULL, &hi, &skip, &override,
a3837 1
      bfd * undef_bfd = NULL;
a3982 16
	  /* If this is a definition of a symbol which was previously
	     referenced, then make a note of the bfd that contained the
	     reference.  This is used if we need to refer to the source
	     of the reference later on.  */
	  if (! bfd_is_und_section (sec))
	    {
	      h = elf_link_hash_lookup (elf_hash_table (info), name,
					FALSE, FALSE, FALSE);

	      if (h != NULL
		  && (h->root.type == bfd_link_hash_undefined
		      || h->root.type == bfd_link_hash_undefweak)
		  && h->root.u.undef.abfd)
		undef_bfd = h->root.u.undef.abfd;
	    }

d4090 3
a4092 17
	  /* If necessary, make a second attempt to locate the bfd
	     containing an unresolved reference to the current symbol.  */
	  if (! bfd_is_und_section (sec) && undef_bfd == NULL)
	    {
	      h = elf_link_hash_lookup (elf_hash_table (info), name,
					FALSE, FALSE, FALSE);

	      if (h != NULL
		  && (h->root.type == bfd_link_hash_undefined
		      || h->root.type == bfd_link_hash_undefweak)
		  && h->root.u.undef.abfd)
		undef_bfd = h->root.u.undef.abfd;
	    }

	  if (!_bfd_elf_merge_symbol (abfd, info, name, isym, &sec,
				      &value, &old_weak, &old_alignment,
				      sym_hash, &skip, &override,
a4106 22
	  /* Remember the old alignment if this is a common symbol, so
	     that we don't reduce the alignment later on.  We can't
	     check later, because _bfd_generic_link_add_one_symbol
	     will set a default for the alignment which we want to
	     override. We also remember the old bfd where the existing
	     definition comes from.  */
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      old_bfd = h->root.u.def.section->owner;
	      break;

	    case bfd_link_hash_common:
	      old_bfd = h->root.u.c.p->section->owner;
	      old_alignment = h->root.u.c.p->alignment_power;
	      break;
	    }

d4176 67
a4242 1
	  bfd_boolean dynsym;
d4287 2
a4288 2
		      (_("Warning: alignment %u of common symbol `%s' in %B"
			 " is greater than the alignment (%u) of its section %A"),
d4321 1
a4321 1
	     covered by --warn-common.  Allow changed between different
d4354 3
a4356 6
	  /* Set a flag in the hash table entry indicating the type of
	     reference or definition we just found.  Keep a count of
	     the number of dynamic symbols we find.  A dynamic symbol
	     is one which is referenced or defined by both a regular
	     object and a shared object.  */
	  dynsym = FALSE;
d4358 1
a4358 2
	  /* Plugin symbols aren't normal.  Don't set def_regular or
	     ref_regular for them, nor make them dynamic.  */
a4359 53
	    ;
	  else if (! dynamic)
	    {
	      if (! definition)
		{
		  h->ref_regular = 1;
		  if (bind != STB_WEAK)
		    h->ref_regular_nonweak = 1;
		}
	      else
		{
		  h->def_regular = 1;
		  if (h->def_dynamic)
		    {
		      h->def_dynamic = 0;
		      h->ref_dynamic = 1;
		    }
		}

	      /* If the indirect symbol has been forced local, don't
		 make the real symbol dynamic.  */
	      if ((h == hi || !hi->forced_local)
		  && (! info->executable
		      || h->def_dynamic
		      || h->ref_dynamic))
		dynsym = TRUE;
	    }
	  else
	    {
	      if (! definition)
		{
		  h->ref_dynamic = 1;
		  hi->ref_dynamic = 1;
		}
	      else
		{
		  h->def_dynamic = 1;
		  hi->def_dynamic = 1;
		}

	      /* If the indirect symbol has been forced local, don't
		 make the real symbol dynamic.  */
	      if ((h == hi || !hi->forced_local)
		  && (h->def_regular
		      || h->ref_regular
		      || (h->u.weakdef != NULL
			  && ! new_weakdef
			  && h->u.weakdef->dynindx != -1)))
		dynsym = TRUE;
	    }

	  /* We don't want to make debug symbol dynamic.  */
	  if (definition && (sec->flags & SEC_DEBUGGING) && !info->relocatable)
a4367 8
	  /* Check to see if we need to add an indirect symbol for
	     the default name.  */
	  if (definition
	      || (!override && h->root.type == bfd_link_hash_common))
	    if (!_bfd_elf_add_default_symbol (abfd, info, h, name, isym,
					      &sec, &value, &dynsym))
	      goto error_free_vers;

d4418 2
a4419 2
		   && (undef_bfd == NULL
		       || (undef_bfd->flags & BFD_PLUGIN) == 0))
d4432 1
a4432 1
	      if (undef_bfd != NULL
d4438 1
a4438 1
		     undef_bfd, name);
d4440 2
a4441 1
		    (_("note: '%s' is defined in DSO %B so try adding it to the linker command line"),
@


1.480
log
@	* elflink.c (_bfd_elf_merge_symbol): Use local var holding value
	of *sym_hash.
@
text
@d1582 1
a1582 2
			     bfd_boolean *dynsym,
			     bfd_boolean override)
d1593 1
a1605 18
  if (override)
    {
      /* We are overridden by an old definition. We need to check if we
	 need to create the indirect symbol from the default name.  */
      hi = elf_link_hash_lookup (elf_hash_table (info), name, TRUE,
				 FALSE, FALSE);
      BFD_ASSERT (hi != NULL);
      if (hi == h)
	return TRUE;
      while (hi->root.type == bfd_link_hash_indirect
	     || hi->root.type == bfd_link_hash_warning)
	{
	  hi = (struct elf_link_hash_entry *) hi->root.u.i.link;
	  if (hi == h)
	    return TRUE;
	}
    }

d4410 2
a4411 1
	  if (definition || h->root.type == bfd_link_hash_common)
d4413 1
a4413 2
					      &sec, &value, &dynsym,
					      override))
@


1.479
log
@	* elflink.c (_bfd_elf_merge_symbol): Don't discard TLS symbols here.
	Wrap long lines.
	(elf_link_add_object_symbols): Discard TLS symbols for --just-syms
	early in symbol loop.
@
text
@d1188 1
a1188 1
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
d1196 1
a1196 3
	      struct elf_link_hash_entry *vh = *sym_hash;

	      vh->root.type = h->root.type;
d1198 1
a1198 1
	      (*bed->elf_backend_copy_indirect_symbol) (info, vh, h);
d1200 1
a1200 1
	      h->root.u.i.link = (struct bfd_link_hash_entry *) vh;
d1217 1
a1217 1
	      h = vh;
d1220 1
a1220 1
	    h = *sym_hash;
d1497 2
a1498 2
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
d1543 2
a1544 2
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
@


1.478
log
@	* elf-bfd.h (struct elf_backend_data <merge_symbol>): Update proto.
	(_bfd_elf_init_reloc_shdr): Delete.
	* elf.c (_bfd_elf_init_reloc_shdr): Make static.
	* elf64-x86-64.c (elf_x86_64_merge_symbol): Trim parameters to
	just what is needed.
	* elflink.c (_bfd_elf_merge_symbol): Update bed->merge_symbol call.
@
text
@a940 9
  /* Silently discard TLS symbols from --just-syms.  There's no way to
     combine a static TLS block with a new TLS block for this executable.  */
  if (ELF_ST_TYPE (sym->st_info) == STT_TLS
      && sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
    {
      *skip = TRUE;
      return TRUE;
    }

d1139 2
a1140 1
	  (_("%s: TLS definition in %B section %A mismatches non-TLS definition in %B section %A"),
d1144 2
a1145 1
	  (_("%s: TLS reference in %B mismatches non-TLS reference in %B"),
d1149 2
a1150 1
	  (_("%s: TLS definition in %B section %A mismatches non-TLS reference in %B"),
d1154 2
a1155 1
	  (_("%s: TLS reference in %B mismatches non-TLS definition in %B section %A"),
d3974 7
@


1.477
log
@	* elf-bfd.h (_bfd_elf_merge_symbol): Delete declaration.
	* elflink.c (_bfd_elf_merge_symbol): Make static.
	* elf32-sh-symbian.c (sh_symbian_relocate_section): Don't call
	_bfd_elf_merge_symbol, call _bfd_generic_link_add_one_symbol.
@
text
@d1350 6
a1355 9
  if (bed->merge_symbol
      && !bed->merge_symbol (info, sym_hash, h, sym, psec, pvalue,
			     pold_alignment, skip, override,
			     type_change_ok, size_change_ok,
			     &newdyn, &newdef, &newdyncommon, &newweak,
			     abfd, &sec,
			     &olddyn, &olddef, &olddyncommon, &oldweak,
			     oldbfd, &oldsec))
    return FALSE;
@


1.476
log
@	PR ld/15270
	* elflink.c (elf_link_add_object_symbols): Don't set def_regular
	or ref_regular for BFD_PLUGIN owned syms, or have them affect
	def_dynamic/ref_dynamic.
	(_bfd_elf_fix_symbol_flags): Don't set def_regular for BFD_PLUGIN
	owned syms.
@
text
@d910 1
a910 1
bfd_boolean
@


1.475
log
@	* elf32-h8300 (h8_relax_section): Add new relaxation of mov
	@@(disp:32,ERx) to mov @@(disp:16,ERx).
	(R_H8_DISP32A16): New reloc.
	Comments added and corrected.
	* reloc.c (BFD_RELOC_H8_DISP32A16): New reloc.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* ld.texinfo (H8/300): Add description of relaxation of
	mov @@(disp:32,ERx) to mov @@(disp:16,ERx).

	* ld-h8300/h8300.exp: Add new relax-7 test on ELF.
	* ld-h8300/relax-2.s: Add other direction and .w/.l variants of
	mov insns.
	* ld-h8300/relax-2.d: Update expected disassembly.
	* ld-h8300/relax-7a.s: New: tests for mov @@(disp:32,ERx) -> mov
	@@(disp:16,ERx).
	* ld-h8300/relax-7b.s: New: Likewise.
	* ld-h8300/relax-7.d: New: expected disassembly.

	* config/tc-h8300.c (do_a_fix_imm): Add relaxation of mov
	@@(disp:32,ERx) to mov @@(disp:16,ERx) insns by new reloc
	R_H8_DISP32A16.
	* config/tc-h8300.h: Remove duplicated defines.
@
text
@d2494 1
a2494 1
      && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
d4364 6
a4369 1
	  if (! dynamic)
a4422 4
	  /* Nor should we make plugin symbols dynamic.  */
	  if ((abfd->flags & BFD_PLUGIN) != 0)
	    dynsym = FALSE;

@


1.474
log
@bfd/
	* elflink.c (_bfd_elf_make_dynamic_reloc_section): Override
	sh_type according to is_rela.
ld/testsuite/
	* ld-elf/rel.c, ld-elf/relmain.c, ld-elf/relmain.out: New test.
	* ld-elf/shared.exp: Build and run it.
@
text
@d4501 1
@


1.473
log
@	PR ld/12549
bfd/
	* elflink.c (elf_link_add_object_symbols): Exclude weak refs when
	considering whether an --as-needed library is needed.
ld/
	* ld.texinfo (--as-needed): Update.
ld/testsuite/
	* ld-elf/pr14862.out: Expect no output.
@
text
@d13028 5
@


1.472
log
@Set unique_global only for definition

bfd/

	PR ld/15167
	* elf64-ia64-vms.c (elf64_vms_link_add_object_symbols): Set
	unique_global only for definition.
	* elflink.c (_bfd_elf_merge_symbol): Don't set unique_global
	here.
	(elf_link_add_object_symbols): Set unique_global only
	for definition.

ld/testsuite/

	PR ld/15167
	* ld-unique/unique.exp: Add a test for shared library with
	reference.
@
text
@d4485 1
a4485 1
		   && h->ref_regular
d4488 1
a4488 1
		  || (h->ref_dynamic
@


1.471
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Rename segment_map to seg_map.
	Delete num_locals and num_globals.
	(elf_num_locals, elf_num_globals): Don't define.
	(elf_seg_map, elf_next_file_pos, elf_eh_frame_hdr, elf_linker,
	elf_stack_flags, elf_strtab_sec, elf_shstrtab_sec): Define.
	* bfd.c, * elf-eh-frame.c, * elf-nacl.c, * elf-vxworks.c, * elf.c,
	* elf32-arm.c, * elf32-lm32.c, * elf32-ppc.c, * elf32-rx.c,
	* elf32-spu.c, * elf64-hppa.c, * elfcode.h, * elflink.c,
	* elfnn-ia64.c, * elfxx-mips.c: Use newly defined elf_obj_tdata
	accessor macros.
	* elf.c (elf_map_symbols): Add pnum_locals param.  Return
	number of locals syms via new param.
	(swap_out_syms): Adjust to suit elf_map_symbols change.
ld/
	* emultempl/elf-generic.em: Use newly defined elf_obj_tdata
	accessor macros.
@
text
@a1264 3
  if (bind == STB_GNU_UNIQUE)
    h->unique_global = 1;

a4196 2
      if (is_elf_hash_table (htab))
	h->unique_global = (flags & BSF_GNU_UNIQUE) != 0;
d4423 4
a4426 1
	    h->target_internal = isym->st_target_internal;
@


1.470
log
@	PR ld/12549
	* elf-bfd.h (_bfd_elf_strtab_clear_refs): Delete.
	(_bfd_elf_strtab_clear_all_refs): Declare.
	(_bfd_elf_strtab_resize): Declare.
	* elf-strtab.c (_bfd_elf_strtab_clear_refs): Delete.
	(_bfd_elf_strtab_clear_all_refs): New function.
	(_bfd_elf_strtab_resize): Likewise.
	* elflink.c (elf_link_add_object_symbols): Use _bfd_elf_strtab_resize.
@
text
@d5670 1
a5670 1
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;
d5672 1
a5672 1
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W;
d5699 1
a5699 1
	elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | exec;
d10786 1
a10786 1
  off = elf_tdata (abfd)->next_file_pos;
d10789 1
a10789 1
  /* Note that at this point elf_tdata (abfd)->next_file_pos is
d11245 1
a11245 1
  elf_tdata (abfd)->next_file_pos = off;
d11541 1
a11541 1
  elf_tdata (abfd)->linker = TRUE;
@


1.469
log
@Don't add DT_NEEDED for references from the dummy bfd

bfd/

	PR ld/15146
	* elflink.c (elf_link_add_object_symbols): Don't add DT_NEEDED
	for references from the dummy bfd.

ld/

	PR ld/15146
	* plugin.c (plugin_notice): Replace the undefined dummy bfd with
	the real one.

ld/testsuite/

	PR ld/15146
	* ld-plugin/pr15146.d: New file.
	* ld-plugin/pr15146a.c: Likewise.
	* ld-plugin/pr15146b.c: Likewise.
	* ld-plugin/pr15146c.c: Likewise.
	* ld-plugin/pr15146d.c: Likewise.

	* ld-plugin/lto.exp: Add tests for PR ld/15146.
@
text
@d4557 1
a4557 1
      _bfd_elf_strtab_clear_refs (htab->dynstr, old_dynstr_size);
@


1.468
log
@Also track weak references

	PR ld/15149
	* elflink.c (elf_link_add_object_symbols): Also track weak
	references.
@
text
@d4483 1
d4487 3
a4489 1
		   && h->ref_regular)
@


1.467
log
@	* elfcode.h (elf_checksum_contents): Free contents.
	* elf-bfd.h (_bfd_elf_link_hash_table_free): Declare.
	* elflink.c (_bfd_elf_link_hash_table_free): New function.
	(elf_final_link_free): New function, extracted from..
	(bfd_elf_final_link): ..here.  Always call
	_bfd_elf_write_section_eh_frame_hdr.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Default to
	_bfd_elf_link_hash_table_free.
	* libbfd-in.h (_bfd_merge_sections_free): Declare.
	* libbfd.h: Regenerate.
	* merge.c (_bfd_merge_sections_free): New function.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): Free
	hdr_info->array.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): Call
	_bfd_elf_link_hash_table_free.
	* elf32-arm.c (elf32_arm_link_hash_table_free): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_free): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_free): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_free): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_free): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_free): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_free): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_free): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_hash_table_free): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_free): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_free): Likewise.
	* elfnn-ia64.c (elfNN_ia64_hash_table_free): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Don't define.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Dont' define.
@
text
@d4005 3
a4007 3
	     referenced in a non-weak manner then make a note of the bfd
	     that contained the reference.  This is used if we need to
	     refer to the source of the reference later on.  */
d4010 2
a4011 1
	      h = elf_link_hash_lookup (elf_hash_table (info), name, FALSE, FALSE, FALSE);
d4014 2
a4015 1
		  && h->root.type == bfd_link_hash_undefined
d4128 1
a4128 2
	     containing an unresolved, non-weak reference to the
	     current symbol.  */
d4131 2
a4132 1
	      h = elf_link_hash_lookup (elf_hash_table (info), name, FALSE, FALSE, FALSE);
d4135 2
a4136 1
		  && h->root.type == bfd_link_hash_undefined
@


1.466
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d6965 12
d10447 36
d11530 2
a11531 5
  if (info->eh_frame_hdr)
    {
      if (! _bfd_elf_write_section_eh_frame_hdr (abfd, info))
	goto error_return;
    }
d11533 1
a11533 30
  if (flinfo.symstrtab != NULL)
    _bfd_stringtab_free (flinfo.symstrtab);
  if (flinfo.contents != NULL)
    free (flinfo.contents);
  if (flinfo.external_relocs != NULL)
    free (flinfo.external_relocs);
  if (flinfo.internal_relocs != NULL)
    free (flinfo.internal_relocs);
  if (flinfo.external_syms != NULL)
    free (flinfo.external_syms);
  if (flinfo.locsym_shndx != NULL)
    free (flinfo.locsym_shndx);
  if (flinfo.internal_syms != NULL)
    free (flinfo.internal_syms);
  if (flinfo.indices != NULL)
    free (flinfo.indices);
  if (flinfo.sections != NULL)
    free (flinfo.sections);
  if (flinfo.symbuf != NULL)
    free (flinfo.symbuf);
  if (flinfo.symshndxbuf != NULL)
    free (flinfo.symshndxbuf);
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct bfd_elf_section_data *esdo = elf_section_data (o);
      if ((o->flags & SEC_RELOC) != 0 && esdo->rel.hashes != NULL)
	free (esdo->rel.hashes);
      if ((o->flags & SEC_RELOC) != 0 && esdo->rela.hashes != NULL)
	free (esdo->rela.hashes);
    }
d11550 1
a11550 31
  if (flinfo.symstrtab != NULL)
    _bfd_stringtab_free (flinfo.symstrtab);
  if (flinfo.contents != NULL)
    free (flinfo.contents);
  if (flinfo.external_relocs != NULL)
    free (flinfo.external_relocs);
  if (flinfo.internal_relocs != NULL)
    free (flinfo.internal_relocs);
  if (flinfo.external_syms != NULL)
    free (flinfo.external_syms);
  if (flinfo.locsym_shndx != NULL)
    free (flinfo.locsym_shndx);
  if (flinfo.internal_syms != NULL)
    free (flinfo.internal_syms);
  if (flinfo.indices != NULL)
    free (flinfo.indices);
  if (flinfo.sections != NULL)
    free (flinfo.sections);
  if (flinfo.symbuf != NULL)
    free (flinfo.symbuf);
  if (flinfo.symshndxbuf != NULL)
    free (flinfo.symshndxbuf);
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct bfd_elf_section_data *esdo = elf_section_data (o);
      if ((o->flags & SEC_RELOC) != 0 && esdo->rel.hashes != NULL)
	free (esdo->rel.hashes);
      if ((o->flags & SEC_RELOC) != 0 && esdo->rela.hashes != NULL)
	free (esdo->rela.hashes);
    }

@


1.465
log
@Set STB_GNU_UNIQUE only if symbol is defined in regular object

bfd/

	PR ld/15107
	* elflink.c (elf_link_output_extsym): Set STB_GNU_UNIQUE only if
	symbol is defined in regular object.

ld/testsuite/

	PR ld/15107
	* ld-unique/unique_empty.s: Add reference to "b".
@
text
@d6911 2
a6912 1
/* Initialize an ELF linker hash table.  */
a6926 1
  memset (table, 0, sizeof * table);
d6950 1
a6950 1
  ret = (struct elf_link_hash_table *) bfd_malloc (amt);
@


1.464
log
@ld: change --enable-new-dtags to only generate new dtags

The "new" dtags options have been around for 14+ years, so there
shouldn't be a need to generate both new & old tags anymore.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d8871 2
a8872 1
  else if (h->unique_global)
@


1.463
log
@	* elf-bfd.h (struct elf_link_hash_entry): Delete dynamic_weak.
	Add ref_dynamic_nonweak.
	* elflink.c (_bfd_elf_mark_dynamic_def_weak): Delete.
	(_bfd_elf_merge_symbol): Don't call above function.  Move
	setting of ref_dynamic_nonweak and dynamic_def earlier.  Don't
	clear dynamic_def.
	(elf_link_add_object_symbols): Delete redundant "override" test.
	Don't set dynamic_def here.
	(elf_link_output_extsym): Update.
@
text
@d5733 1
d5737 1
a5737 2
	  if (indx == (bfd_size_type) -1
	      || !_bfd_elf_add_dynamic_entry (info, DT_RPATH, indx))
d5740 3
a5742 6
	  if  (info->new_dtags)
	    {
	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr, indx);
	      if (!_bfd_elf_add_dynamic_entry (info, DT_RUNPATH, indx))
		return FALSE;
	    }
@


1.462
log
@	* elf-bfd.h (_bfd_elf_strtab_refcount): Declare.
	* elf-strtab.c (_bfd_elf_strtab_refcount): New function.
	* elflink.c (elf_add_dt_needed_tag): Use _bfd_elf_strtab_refcount.
@
text
@a897 27
/* Mark if a symbol has a definition in a dynamic object or is
   weak in all dynamic objects.  */

static void
_bfd_elf_mark_dynamic_def_weak (struct elf_link_hash_entry *h,
				asection *sec, int bind)
{
  if (!h->dynamic_def)
    {
      if (!bfd_is_und_section (sec))
	h->dynamic_def = 1;
      else
	{
	  /* Check if this symbol is weak in all dynamic objects. If it
	     is the first time we see it in a dynamic object, we mark
	     if it is weak. Otherwise, we clear it.  */
	  if (!h->ref_dynamic)
	    {
	      if (bind == STB_WEAK)
		h->dynamic_weak = 1;
	    }
	  else if (bind != STB_WEAK)
	    h->dynamic_weak = 0;
	}
    }
}

d974 1
a974 1
     refereences and not all compilers emit symbol type for undefined
d978 29
a1063 5
  /* NEWDYN and OLDDYN indicate whether the new or old symbol,
     respectively, is from a dynamic object.  */

  newdyn = (abfd->flags & DYNAMIC) != 0;

a1166 10
  /* We need to remember if a symbol has a definition in a dynamic
     object or is weak in all dynamic objects. Internal and hidden
     visibility will make it unavailable to dynamic objects.  */
  if (newdyn)
    {
      _bfd_elf_mark_dynamic_def_weak (h, sec, bind);
      if (h != hi)
	_bfd_elf_mark_dynamic_def_weak (hi, sec, bind);
    }

a1219 1
	      h->dynamic_def = 0;
a1258 1
      h->dynamic_def = 0;
a4177 1
	      && ! override
a4401 1
		  h->dynamic_def = 1;
a4402 1
		  hi->dynamic_def = 1;
d8796 1
a8796 1
      && !h->dynamic_weak
@


1.461
log
@	PR ld/12549
	* elf-bfd.h (_bfd_elf_strtab_clear_refs): Declare.
	(_bfd_elf_strtab_clear_all_refs): Define.
	* elf-strtab.c (_bfd_elf_strtab_clear_refs): New function.
	(_bfd_elf_strtab_clear_all_refs): Delete.
	* elflink.c (elf_link_add_object_symbols): Clear out added
	strtab refs.  Correct handling of warning common symbols.
@
text
@a3093 1
  bfd_size_type oldsize;
a3099 1
  oldsize = _bfd_elf_strtab_size (hash_table->dynstr);
d3104 1
a3104 1
  if (oldsize == _bfd_elf_strtab_size (hash_table->dynstr))
@


1.460
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d3388 1
d3838 1
d4571 1
d4584 2
a4585 1
	      if (h->dynindx >= old_dynsymcount)
d4590 1
a4590 1
		 since it can still be loaded at the run-time by another
d4609 1
d4611 1
a4611 1
	      else if (h->root.type == bfd_link_hash_common)
@


1.459
log
@	* elflink.c (get_value): Prevent the use of an undefined shift
	operation.  Add sanity checks.
@
text
@d3715 1
a3715 1
      elf_dt_audit (abfd) = audit; 
d4032 1
a4032 1
	  
d11759 1
a11759 1
	      
d12516 1
a12516 1
	      info->callbacks->einfo 
d12984 1
a12984 1
  sprintf (name, "%s%s", prefix, old_name); 
@


1.458
log
@Fix and use elf_append_rel

	* elf32-i386.c (elf_i386_relocate_section): Replace
	bfd_elf32_swap_reloc_out with elf_append_rel.
	(elf_i386_finish_dynamic_symbol): Likewise.

	* elflink.c (elf_append_rel): Call swap_reloc_out instead of
	swap_reloca_out.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
d7920 1
d7923 20
a7946 3
	default:
	case 0:
	  abort ();
d7948 1
a7948 1
	  x = (x << (8 * chunksz)) | bfd_get_8 (input_bfd, location);
d7951 1
a7951 1
	  x = (x << (8 * chunksz)) | bfd_get_16 (input_bfd, location);
d7954 1
a7954 1
	  x = (x << (8 * chunksz)) | bfd_get_32 (input_bfd, location);
d7956 1
d7958 4
a7961 3
#ifdef BFD64
	  x = (x << (8 * chunksz)) | bfd_get_64 (input_bfd, location);
#else
a7962 2
#endif
	  break;
@


1.457
log
@Remove ref_dynamic_nonweak added by accident

bfd/

2012-11-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/14862
	* elf-bfd.h (elf_link_hash_entry): Remove ref_dynamic_nonweak
	added by accident.
	(elf_link_add_object_symbols): Don't set nor check
	ref_dynamic_nonweak.

ld/testsuite/

2012-11-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/14862
	* ld-elf/shared.exp (build_tests): Build libpr14862-1.o and
	libpr14862.so.
	(run_tests): Test pr14862.

	* ld-elf/pr14862-1.c: New file.
	* ld-elf/pr14862-2.c: Likewise.
	* ld-elf/pr14862.map: Likewise.
	* ld-elf/pr14862.out: Likewise.
@
text
@d13080 1
a13080 1
  bed->s->swap_reloca_out (abfd, rel, loc);
@


1.456
log
@
bfd:
        * elf32-arm.c (elf32_arm_print_private_bfd_data): Recognise and
        display the new ARM hard-float/soft-float ABI flags for EABI_VER5
        (elf32_arm_post_process_headers): Add the hard-float/soft-float
        ABI flag as appropriate for ET_DYN/ET_EXEC in EABI_VER5.

binutils:
        * readelf.c (decode_ARM_machine_flags): Recognise and display the
        new ARM hard-float/soft-float ABI flags for EABI_VER5. Split out
        the code for EABI_VER4 and EABI_VER5 to allow this.

elfcpp:
        * arm.h: New enum for EABI soft- and hard-float flags.

gold:
        * gold.cc (Target_arm::do_adjust_elf_header): Add the
        hard-float/soft-float ABI flag as appropriate for ET_DYN/ET_EXEC
        in EABI_VER5.

include:
        * elf/arm.h (EF_ARM_ABI_FLOAT_SOFT): New define.
        (EF_ARM_ABI_FLOAT_HARD): Likewise.

ld/testsuite:
        * ld-arm/eabi-hard-float.s: New test source.
        * ld-arm/eabi-soft-float.s: New test source.
        * ld-arm/eabi-hard-float.d: New test.
        * ld-arm/eabi-soft-float.d: New test.
        * ld-arm/eabi-soft-float-ABI4.d: New test.
        * ld-arm/eabi-soft-float-r.d: New test.
        * ld-arm/arm-elf.xp: Use the new tests.

binutils:
	PR binutils/14779
	* configure.in: Add checks for wchar.h and mbstate_t.
	* config.in: Regenerate.
	* configure: Regenerate.
	* readelf.c: Conditionally include wchar.h.
	(print_symbol): Conditionally use mbstate_t.
@
text
@a4396 2
		      /* PR 12549: Note if the dynamic reference is weak.  */
		      h->ref_dynamic_nonweak = (bind != STB_WEAK);
a4413 3
		  /* PR 12549: Note if the dynamic reference is weak.  */
		  hi->ref_dynamic_nonweak =
		    h->ref_dynamic_nonweak = (bind != STB_WEAK);
d4501 2
a4502 2
		   && h->ref_regular_nonweak)
		  || (h->ref_dynamic_nonweak
@


1.455
log
@	bfd/
	* bfd-in.h (bfd_elf_stack_segment_size): Declare.
	* bfd-in2.h: Rebuilt.
	* elfxx-target.h (elf_backend_stack_align): New.
	(elfNN_bed): Add it.
	* elf-bfd.h (struct elf_backend_data): Add stack_align field.
	* elf.c (bfd_elf_map_sections_to_segments): Pay attention to
	stack_align and stacksize for PT_GNU_STACK segment.
	(assign_file_positions_for_non_load_sections): Set p_memsz for
	PT_GNU_STACK segment.
	(copy_elf_program_header): Copy PT_GNU_STACK size.
	* elflink.c (bfd_elf_stack_segment_size): New function, taken from
	uclinux backends.
	(bfd_elf_size_dynamic_sections): Determine
	PT_GNU_STACK requirements after calling backend.  Pay attention to
	stacksize.
	* elf32-bfin.c (elf32_bfinfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_bfinfdpic_modify_program_headers): Delete.
	(elf32_bfingfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-frv.c (frvfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_frvfdpic_modify_program_headers): Delete.
	(elf32_frvfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-lm32.c (lm32_elf_always_size_sections): Leave
	PT_GNU_STACK creation to underlying elf support.  Check
	__stacksize here for backwards compatibility, and set it if
	needed.
	(lm32_elf_modify_segment_map): Delete.
	(lm32_elf_modify_program_headers): Delete.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_segment_map): Don't override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-sh.c (sh_elf_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(sh_elf_modify_program_headers): Delete.
	(sh_elf_copy_private_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-tic6x.c (elf32_tic6x_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_tic6x_modify_program_headers): Delete.
	(elf32_tic6x_copy_private_data): Delete.
	(elf_backend_stack_align): Override.
	(bfd_elf32_bfd_copy_private_bfd_data): Don't override.
	(elf_backend_modify_program_headers): Don't override.

	include/
	* bfdlink.h (struct bfd_link_info): Add stacksize option.

	ld/
	* ld.texinfo (stack-size): New option.
	* emultempl/elf32.em: Add stack-size option.

	ld/testsuite/
	* ld-elf/binutils.exp: Add -z stack-size=0.
	* ld-elf/elf.exp: Add stack-exec and stack-size tests.
	* ld-elf/orphan-region.d: Add stack-size option. Remove xfail.
	* ld-elf/stack-exec.rd: New.
	* ld-elf/stack-size.rd: New.
	* ld-elf/stack.s: New.
	* ld-scripts/empty-aligned.d: Add stack-size option.
	* ld-sh/fdpic-stack-set.d: New.
	* ld-tic6x/shlib-1.rd: Remove __stacksize symbol.
	* ld-tic6x/shlib-1b.rd: Likewise.
	* ld-tic6x/shlib-1r.rd: Likewise.
	* ld-tic6x/shlib-1rb.rd: Likewise.
	* ld-tic6x/shlib-app-1.rd: Likewise.
	* ld-tic6x/shlib-app-1b.rd: Likewise.
	* ld-tic6x/shlib-app-1r.rd: Likewise.
	* ld-tic6x/shlib-app-1rb.rd: Likewise.
	* ld-tic6x/shlib-noindex.rd: Likewise.
	* ld-tic6x/static-app-1.rd: Likewise.
	* ld-tic6x/static-app-1b.rd: Likewise.
	* ld-tic6x/static-app-1r.rd: Likewise.
	* ld-tic6x/static-app-1rb.rd: Likewise.
@
text
@d4397 2
d4416 3
d4506 2
a4507 2
		   && h->ref_regular)
		  || (h->ref_dynamic
@


1.454
log
@Properly handle common symbol and weak function

bfd/

	PR ld/14591
	* elf-bfd.h (_bfd_elf_merge_symbol): Add an argument to return
	if the old symbol is weak.

	* elf32-sh-symbian.c (sh_symbian_relocate_section): Update
	_bfd_elf_merge_symbol call.

	* elflink.c (_bfd_elf_merge_symbol): Add an argument to return
	if the old symbol is weak.
	(_bfd_elf_add_default_symbol): Update _bfd_elf_merge_symbol
	call.
	(elf_link_add_object_symbols): Don't update symbol type from a
	weak definition.  Update symbol type from a common symbol when
	overriding a weak symbol.

ld/testsuite/

	PR ld/14591
	* ld-elf/comm-data.exp (run_ld_link_tests): Add comm-data3a and
	comm-data3b tests.

	* ld-ifunc/ifunc.exp (run_ld_link_exec_tests): New.

	* ld-elf/comm-data3.sd: New file.
	* ld-elf/comm-data3a.s: Likewise.
	* ld-elf/comm-data3b.s: Likewise.
	* ld-ifunc/ifunc-17a-i386.d: Likewise.
	* ld-ifunc/ifunc-17a-x86-64.d: Likewise.
	* ld-ifunc/ifunc-17a.s: Likewise.
	* ld-ifunc/ifunc-17b-i386.d: Likewise.
	* ld-ifunc/ifunc-17b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-17b.s: Likewise.
	* ld-ifunc/ifunc-common-1.out: Likewise.
	* ld-ifunc/ifunc-common-1a.c: Likewise.
	* ld-ifunc/ifunc-common-1b.c: Likewise.
@
text
@d5570 59
d5658 20
d5707 5
a5711 7
      if (notesec)
	{
	  elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | exec;
	  if (exec && info->relocatable
	      && notesec->output_section != bfd_abs_section_ptr)
	    notesec->output_section->flags |= SEC_CODE;
	}
a5713 17
  /* Any syms created from now on start with -1 in
     got.refcount/offset and plt.refcount/offset.  */
  elf_hash_table (info)->init_got_refcount
    = elf_hash_table (info)->init_got_offset;
  elf_hash_table (info)->init_plt_refcount
    = elf_hash_table (info)->init_plt_offset;

  if (info->relocatable
      && !_bfd_elf_size_group_sections (info))
    return FALSE;

  /* The backend may have to create some sections regardless of whether
     we're dynamic or not.  */
  if (bed->elf_backend_always_size_sections
      && ! (*bed->elf_backend_always_size_sections) (output_bfd, info))
    return FALSE;

@


1.453
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d944 1
d1047 2
d1671 1
a1671 1
			      NULL, &hi, &skip, &override,
d1780 1
a1780 1
			      NULL, &hi, &skip, &override,
d3874 2
d4008 1
d4154 1
a4154 1
				      &value, &old_alignment,
d4216 1
d4220 1
a4220 1
	  && (flags & BSF_WEAK) != 0
d4349 3
a4351 1
	      && (definition || h->type == STT_NOTYPE))
@


1.452
log
@	* elflink.c (_bfd_elf_merge_symbol): Also override the version
	a dynamic symbol defaulted to if preempted with a hidden or
	internal definition.
@
text
@d190 1
d258 3
a260 1
  if (!_bfd_elf_define_linkage_sym (abfd, info, s, "_DYNAMIC"))
@


1.451
log
@	bfd/
	* elflink.c (bfd_elf_record_link_assignment): Remove --defsym
	symbols special case.

	ld/
	* ldexp.h (etree_union): Add defsym member to the assign member
	structure.
	(exp_assign): Add hidden argument to prototype.
	* ldexp.c (exp_fold_tree_1): Use the defsym member to handle
	--defsym symbols.
	(exp_assop): Add defsym argument, initialize the defsym member
	of the assign structure.
	(exp_assign): Handle hidden symbols.
	(exp_defsym): Update to use the defsym argument to exp_assop.
	(exp_provide): Update to handle the defsym argument to exp_assop.
	* ldlex.l (HIDDEN): New token.
	* ldgram.y (HIDDEN): Likewise.
	(assignment, section): Update calls to exp_assign.
	* ldctor.c (ldctor_build_sets): Likewise.
	* mri.c (mri_format): Likewise.
	* ldlang.c (lang_insert_orphan, lang_leave_overlay): Likewise.
	(open_input_bfds): Remove --defsym symbols special case.
	* emultempl/beos.em (gld_${EMULATION_NAME}_set_symbols): Update
	call to exp_assign.
	* emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/xtensaelf.em (ld_xtensa_insert_page_offsets):
	Likewise.
	* ld.texinfo (Assigning Values to Symbols): Add HIDDEN.
	(HIDDEN): New subsection.
@
text
@d1213 9
a1221 7
	      /* Protected symbols will override the dynamic definition
		 with default version.  */
	      if (ELF_ST_VISIBILITY (sym->st_other) == STV_PROTECTED)
		{
		  h->root.u.i.link = (struct bfd_link_hash_entry *) vh;
		  vh->dynamic_def = 1;
		  vh->ref_dynamic = 1;
d1224 8
a1231 8
		{
		  h->root.type = vh->root.type;
		  vh->ref_dynamic = 0;
		  /* We have to hide it here since it was made dynamic
		     global with extra bits when the symbol info was
		     copied from the old dynamic definition.  */
		  (*bed->elf_backend_hide_symbol) (info, vh, TRUE);
		}
@


1.450
log
@	PR ld/14323
	* elflink.c (elf_sort_symbol): Sort by size too.
	(elf_link_add_object_symbols <weakdefs>): Simplify binary search.
	Do not depend on ordering of symbol aliases.  Match largest size.
@
text
@d572 1
a572 1
  if (provide && hidden)
@


1.450.4.1
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d572 1
a572 1
  if (hidden)
d1213 9
a1221 3

	      h->root.u.i.link = (struct bfd_link_hash_entry *) vh;
	      if (ELF_ST_VISIBILITY (sym->st_other) != STV_PROTECTED)
d1223 6
a1228 5
		  /* If the new symbol is hidden or internal, completely undo
		     any dynamic link state.  */
		  (*bed->elf_backend_hide_symbol) (info, h, TRUE);
		  h->forced_local = 0;
		  h->ref_dynamic = 0;
a1229 9
	      else
		h->ref_dynamic = 1;

	      h->def_dynamic = 0;
	      h->dynamic_def = 0;
	      /* FIXME: Should we check type and size for protected symbol?  */
	      h->size = 0;
	      h->type = 0;

@


1.450.4.2
log
@bfd/
2012-09-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/14591
	* elf-bfd.h (_bfd_elf_merge_symbol): Add an argument to return
	if the old symbol is weak.

	* elf32-sh-symbian.c (sh_symbian_relocate_section): Update
	_bfd_elf_merge_symbol call.

	* elflink.c (_bfd_elf_merge_symbol): Add an argument to return
	if the old symbol is weak.
	(_bfd_elf_add_default_symbol): Update _bfd_elf_merge_symbol
	call.
	(elf_link_add_object_symbols): Don't update symbol type from a
	weak definition.  Update symbol type from a common symbol when
	overriding a weak symbol.

ld/testsuite/
2012-09-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/14591
	* ld-elf/comm-data.exp (run_ld_link_tests): Add comm-data3a and
	comm-data3b tests.

	* ld-ifunc/ifunc.exp (run_ld_link_exec_tests): New.

	* ld-elf/comm-data3.sd: New file.
	* ld-elf/comm-data3a.s: Likewise.
	* ld-elf/comm-data3b.s: Likewise.
	* ld-ifunc/ifunc-17a-i386.d: Likewise.
	* ld-ifunc/ifunc-17a-x86-64.d: Likewise.
	* ld-ifunc/ifunc-17a.s: Likewise.
	* ld-ifunc/ifunc-17b-i386.d: Likewise.
	* ld-ifunc/ifunc-17b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-17b.s: Likewise.
	* ld-ifunc/ifunc-common-1.out: Likewise.
	* ld-ifunc/ifunc-common-1a.c: Likewise.
	* ld-ifunc/ifunc-common-1b.c: Likewise.
@
text
@a940 1
		       bfd_boolean *pold_weak,
a1042 2
  if (pold_weak)
    *pold_weak = oldweak;
d1665 1
a1665 1
			      NULL, NULL, &hi, &skip, &override,
d1774 1
a1774 1
			      NULL, NULL, &hi, &skip, &override,
a3867 2
      bfd_boolean new_weak;
      bfd_boolean old_weak;
a3999 1
      old_weak = FALSE;
d4145 1
a4145 1
				      &value, &old_weak, &old_alignment,
a4206 1
      new_weak = (flags & BSF_WEAK) != 0;
d4210 1
a4210 1
	  && new_weak
d4339 1
a4339 3
	      && ((definition && !new_weak)
		  || (old_weak && h->root.type == bfd_link_hash_common)
		  || h->type == STT_NOTYPE))
@


1.450.4.3
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@d895 27
d998 1
a998 1
     references and not all compilers emit symbol type for undefined
a1001 29
  /* NEWDYN and OLDDYN indicate whether the new or old symbol,
     respectively, is from a dynamic object.  */

  newdyn = (abfd->flags & DYNAMIC) != 0;

  /* ref_dynamic_nonweak and dynamic_def flags track actual undefined
     syms and defined syms in dynamic libraries respectively.
     ref_dynamic on the other hand can be set for a symbol defined in
     a dynamic library, and def_dynamic may not be set;  When the
     definition in a dynamic lib is overridden by a definition in the
     executable use of the symbol in the dynamic lib becomes a
     reference to the executable symbol.  */
  if (newdyn)
    {
      if (bfd_is_und_section (sec))
	{
	  if (bind != STB_WEAK)
	    {
	      h->ref_dynamic_nonweak = 1;
	      hi->ref_dynamic_nonweak = 1;
	    }
	}
      else
	{
	  h->dynamic_def = 1;
	  hi->dynamic_def = 1;
	}
    }

d1059 5
d1167 10
d1230 1
d1270 1
d3091 1
d3098 1
d3103 1
a3103 1
  if (_bfd_elf_strtab_refcount (hash_table->dynstr, strindex) != 1)
a3384 1
  bfd_size_type old_dynstr_size = 0;
a3833 1
      old_dynstr_size = _bfd_elf_strtab_size (htab->dynstr);
d4190 1
d4415 1
d4417 1
a4565 1
      _bfd_elf_strtab_clear_refs (htab->dynstr, old_dynstr_size);
d4578 1
a4578 2
	      if (h->dynindx >= old_dynsymcount
		  && h->dynstr_index < old_dynstr_size)
d4583 1
a4583 1
		 since it can still be loaded at run time by another
a4601 1
		  h = (struct elf_link_hash_entry *) h->root.u.i.link;
d4603 1
a4603 1
	      if (h->root.type == bfd_link_hash_common)
d8730 1
a8730 1
      && h->ref_dynamic_nonweak
d13017 1
a13017 1
  bed->s->swap_reloc_out (abfd, rel, loc);
@


1.450.4.4
log
@	PR ld/12549
	* elf-bfd.h (_bfd_elf_strtab_clear_refs): Delete.
	(_bfd_elf_strtab_clear_all_refs): Declare.
	(_bfd_elf_strtab_resize): Declare.
	* elf-strtab.c (_bfd_elf_strtab_clear_refs): Delete.
	(_bfd_elf_strtab_clear_all_refs): New function.
	(_bfd_elf_strtab_resize): Likewise.
	* elflink.c (elf_link_add_object_symbols): Use _bfd_elf_strtab_resize.
@
text
@d4548 1
a4548 1
      _bfd_elf_strtab_restore_size (htab->dynstr, old_dynstr_size);
@


1.450.4.5
log
@	PR ld/15762
	PR ld/12761
	* elflink.c (elf_link_add_object_symbols): Don't clobber
	.gnu.warning.symbol sections when shared.
@
text
@d3471 1
a3471 1
	      if (!info->relocatable && !info->shared)
@


1.450.4.6
log
@	PR ld/15762
	PR ld/12761
	* elflink.c (elf_link_add_object_symbols): Correct test in
	last patch.  Remove unnecessary code.
@
text
@a3370 1
  asection *s;
d3412 1
a3412 1
  for (s = abfd->sections; s != NULL; s = s->next)
d3414 1
a3414 1
      const char *name;
d3416 1
a3416 2
      name = bfd_get_section_name (abfd, s);
      if (CONST_STRNEQ (name, ".gnu.warning."))
d3418 1
a3418 4
	  char *msg;
	  bfd_size_type sz;

	  name += sizeof ".gnu.warning." - 1;
d3420 2
a3421 10
	  /* If this is a shared object, then look up the symbol
	     in the hash table.  If it is there, and it is already
	     been defined, then we will not be using the entry
	     from this shared object, so we don't need to warn.
	     FIXME: If we see the definition in a regular object
	     later on, we will warn, but we shouldn't.  The only
	     fix is to keep track of what warnings we are supposed
	     to emit, and then handle them all at the end of the
	     link.  */
	  if (dynamic)
d3423 2
a3424 1
	      struct elf_link_hash_entry *h;
d3426 1
a3426 1
	      h = elf_link_hash_lookup (htab, name, FALSE, FALSE, TRUE);
d3428 27
a3454 6
	      /* FIXME: What about bfd_link_hash_common?  */
	      if (h != NULL
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak))
		continue;
	    }
d3456 4
a3459 4
	  sz = s->size;
	  msg = (char *) bfd_alloc (abfd, sz + 1);
	  if (msg == NULL)
	    goto error_return;
d3461 2
a3462 2
	  if (! bfd_get_section_contents (abfd, s, msg, 0, sz))
	    goto error_return;
d3464 1
a3464 1
	  msg[sz] = '\0';
d3466 4
a3469 4
	  if (! (_bfd_generic_link_add_one_symbol
		 (info, abfd, name, BSF_WARNING, s, 0, msg,
		  FALSE, bed->collect, NULL)))
	    goto error_return;
d3471 10
a3480 9
	  if (!info->relocatable && info->executable)
	    {
	      /* Clobber the section size so that the warning does
		 not get copied into the output file.  */
	      s->size = 0;

	      /* Also set SEC_EXCLUDE, so that symbols defined in
		 the warning section don't get copied to the output.  */
	      s->flags |= SEC_EXCLUDE;
d3506 1
@


1.449
log
@Properly handle indirect symbols

2012-07-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3351
	* elflink.c (_bfd_elf_update_dynamic_flags): New.
	(_bfd_elf_merge_symbol): Update both real and indirect symbol
	dynamic flags.
	(_bfd_elf_add_default_symbol): Make the real symbol dynamic if
	the indirect symbol is defined in a shared library.
	(elf_link_add_object_symbols): Likewise.  If the indirect
	symbol has been forced local, don't make the real symbol
	dynamic.
	(elf_link_check_versioned_symbol): Check indirect symbol.
	(elf_link_output_extsym): Use real symbol definition when
	reporting indirect symbol error.  Check version info for
	dynamic versioned symbol.

2012-07-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3351
	* ld-elf/indirect.exp: New file.
	* ld-elf/indirect1a.c: Likewise.
	* ld-elf/indirect1b.c: Likewise.
	* ld-elf/indirect1c.c: Likewise.
	* ld-elf/indirect2.c: Likewise.
	* ld-elf/indirect3.out: Likewise.
	* ld-elf/indirect3a.c: Likewise.
	* ld-elf/indirect3b.c: Likewise.
	* ld-elf/indirect3c.c: Likewise.
	* ld-elf/indirect4.out: Likewise.
	* ld-elf/indirect4a.c: Likewise.
	* ld-elf/indirect4b.c: Likewise.
	* ld-elf/indirect4c.c: Likewise.
@
text
@d3148 1
a3148 1
/* Sort symbol by value and section.  */
d3167 2
a3168 1
  return 0;
a4729 1
	  long ilook;
a4742 1
	  ilook = -1;
d4745 1
a4745 1
	  while (i < j)
d4749 1
a4749 1
	      h = sorted_sym_hash [idx];
d4763 1
a4763 4
		    {
		      ilook = idx;
		      break;
		    }
d4768 1
a4768 1
	  if (ilook == -1)
d4771 16
a4786 1
	  for (i = ilook; i < sym_count; i++)
d4788 1
a4788 1
	      h = sorted_sym_hash [i];
d4791 2
a4792 2
	      if (h->root.u.def.value != vlook
		  || h->root.u.def.section != slook)
@


1.448
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d895 27
d950 1
d989 3
a991 2
  /* For merging, we only care about real symbols.  */

d1167 1
a1167 1
  if (newdyn && !h->dynamic_def)
d1169 3
a1171 15
      if (!bfd_is_und_section (sec))
	h->dynamic_def = 1;
      else
	{
	  /* Check if this symbol is weak in all dynamic objects. If it
	     is the first time we see it in a dynamic object, we mark
	     if it is weak. Otherwise, we clear it.  */
	  if (!h->ref_dynamic)
	    {
	      if (bind == STB_WEAK)
		h->dynamic_weak = 1;
	    }
	  else if (bind != STB_WEAK)
	    h->dynamic_weak = 0;
	}
d1183 1
d1744 1
d3860 1
d4193 3
d4384 7
a4390 3
	      if (! info->executable
		  || h->def_dynamic
		  || h->ref_dynamic)
d4396 4
a4399 1
		h->ref_dynamic = 1;
d4404 2
d4407 9
a4415 5
	      if (h->def_regular
		  || h->ref_regular
		  || (h->u.weakdef != NULL
		      && ! new_weakdef
		      && h->u.weakdef->dynindx != -1))
d8480 4
d8713 5
d8726 2
a8727 2
      if (h->root.u.def.section != bfd_abs_section_ptr)
	def_bfd = h->root.u.def.section->owner;
d8977 17
@


1.447
log
@bfd/
	* elflink.c (elf_link_input_bfd): Provide a file symbol for
	each input file with local syms, if the input lacks such.
	(bfd_elf_final_link): Add a file symbol to mark end of locals
	for which we can associate with input files.
	(struct elf_final_link_info): Add filesym_count field.
	(struct elf_outext_info): Add need_second_pass and second_pass.
	(elf_link_output_extsym): Detect symbols defined in the output
	file, emit them on second pass over locals.
ld/testsuite/
Update to suit added STT_FILE symbols.
@
text
@d107 2
a108 2
  s = bfd_get_section_by_name (abfd, ".got");
  if (s != NULL && (s->flags & SEC_LINKER_CREATED) != 0)
d782 1
a782 2
	      && (ip = bfd_get_section_by_name (htab->dynobj, p->name)) != NULL
	      && (ip->flags & SEC_LINKER_CREATED)
d3038 1
a3038 1
  s = bfd_get_section_by_name (hash_table->dynobj, ".dynamic");
d3086 1
a3086 1
      sdyn = bfd_get_section_by_name (hash_table->dynobj, ".dynamic");
d3183 1
a3183 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d3232 1
a3232 1
      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
d3264 1
a3264 1
      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
d5605 1
a5605 1
      *sinterpptr = bfd_get_section_by_name (dynobj, ".interp");
d5873 1
a5873 1
      dynstr = bfd_get_section_by_name (dynobj, ".dynstr");
d5913 1
a5913 1
      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
d6176 1
a6176 1
      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
d6288 1
a6288 1
	  s = bfd_get_section_by_name (dynobj, ".gnu.version");
d6372 1
a6372 1
      s = bfd_get_section_by_name (dynobj, ".gnu.version");
d6392 1
a6392 1
      s = bfd_get_section_by_name (dynobj, ".dynsym");
d6450 1
a6450 1
	  s = bfd_get_section_by_name (dynobj, ".hash");
d6504 1
a6504 1
	  s = bfd_get_section_by_name (dynobj, ".gnu.hash");
d6632 1
a6632 1
      s = bfd_get_section_by_name (dynobj, ".dynstr");
d10347 2
a10348 2
      flinfo.dynsym_sec = bfd_get_section_by_name (dynobj, ".dynsym");
      flinfo.hash_sec = bfd_get_section_by_name (dynobj, ".hash");
d10350 1
a10350 1
      flinfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
d11079 1
a11079 1
      o = bfd_get_section_by_name (dynobj, ".dynamic");
d11255 1
a11255 1
	  && (o = bfd_get_section_by_name (dynobj, ".dynamic")) != NULL)
d11296 1
a11296 3
	  if ((elf_section_data (o->output_section)->this_hdr.sh_type
	       != SHT_STRTAB)
	      && (strcmp (bfd_get_section_name (abfd, o), ".dynstr") != 0))
d12842 1
a12842 1
	  reloc_sec = bfd_get_section_by_name (abfd, name);
d12878 1
a12878 1
      reloc_sec = bfd_get_section_by_name (dynobj, name);
d12882 2
a12883 3
	  flagword flags;

	  flags = (SEC_HAS_CONTENTS | SEC_READONLY | SEC_IN_MEMORY | SEC_LINKER_CREATED);
d12887 1
a12887 1
	  reloc_sec = bfd_make_section_with_flags (dynobj, name, flags);
@


1.446
log
@	PR ld/14170
	* elflink.c (_bfd_elf_merge_symbol): When a symbol defined in
	a dynamic library finds a new instance with non-default
	visibility in a regular object, correctly handle symbols
	already on the undefs list and undo dynamic symbol state when
	the new symbol is hidden or internal.
@
text
@d7406 2
d7416 2
d8612 5
d8771 13
d9136 1
d9272 23
d10367 1
d10842 11
d10862 2
d10868 13
@


1.445
log
@	PR ld/13909
	* elf-eh-frame.c (_bfd_elf_eh_frame_present): New function.
	(_bfd_elf_maybe_strip_eh_frame_hdr): Use it here.
	* elf-bfd.h (_bfd_elf_eh_frame_present): Declare.
	* elflink.c (bfd_elf_size_dynamic_sections): Let the backend
	size dynamic sections before stripping eh_frame_hdr.
	(bfd_elf_gc_sections): Handle multiple .eh_frame sections.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Drop glink_eh_frame
	if no other .eh_frame sections exist.
	* elf64-ppc.c (ppc64_elf_size_stubs): Likewise.
	* elf32-i386.c (elf_i386_create_dynamic_sections): Don't size
	or alloc plt_eh_frame here..
	(elf_i386_size_dynamic_sections): ..do it here instead.  Don't
	specially keep sgotplt, iplt, tgotplt, sdynbss for symbols.
	(elf_i386_finish_dynamic_sections): Check plt_eh_frame->contents
	before writing plt offset.
	* elf64-x86-64.c (elf_x86_64_create_dynamic_sections): Don't size
	or alloc plt_eh_frame here..
	(elf_x86_64_size_dynamic_sections): ..do it here instead.
	(elf_x86_64_finish_dynamic_sections): Check plt_eh_frame->contents
	before writing plt offset.
@
text
@d1219 8
a1226 2
      if ((h->root.u.undef.next || info->hash->undefs_tail == &h->root)
	  && bfd_is_und_section (sec))
a1227 6
	  /* If the new symbol is undefined and the old symbol was
	     also undefined before, we need to make sure
	     _bfd_generic_link_add_one_symbol doesn't mess
	     up the linker hash table undefs list.  Since the old
	     definition came from a dynamic object, it is still on the
	     undefs list.  */
d1237 1
a1237 1
      if (h->def_dynamic)
d1239 5
a1243 2
	  h->def_dynamic = 0;
	  h->ref_dynamic = 1;
d1245 4
@


1.444
log
@	PR ld/13909
	* elflink.c (bfd_elf_discard_info): Don't ignore dynamic BFDs.
@
text
@a5586 3
  if (! _bfd_elf_maybe_strip_eh_frame_hdr (info))
    return FALSE;

d5589 1
a5589 6
  /* If there were no dynamic objects in the link, there is nothing to
     do here.  */
  if (dynobj == NULL)
    return TRUE;

  if (elf_hash_table (info)->dynamic_sections_created)
d5892 2
a5893 1
  if (bed->elf_backend_size_dynamic_sections
d5897 4
a5900 1
  if (elf_hash_table (info)->dynamic_sections_created)
d12001 1
a12001 1
      if (sec && init_reloc_cookie_for_section (&cookie, info, sec))
d12004 2
a12005 1
	  if (elf_section_data (sec)->sec_info)
d12008 1
@


1.443
log
@	* elflink.c (bfd_elf_discard_info): Look for next .eh_frame if
	first one is zero size or discarded.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Set most of
	glink_eh_frame contents here..
	(ppc_elf_finish_dynamic_sections): ..rather than here.  Just set
	offset to .glink.
@
text
@a12484 3
      if ((abfd->flags & DYNAMIC) != 0)
	continue;

@


1.442
log
@	* elflink.c (bfd_elf_discard_info): Handle multiple .eh_frame
	sections attached to a BFD.
	* section.c (bfd_get_section_by_name): Rewrite description.
	(bfd_get_next_section_by_name): New function.
	* bfd-in2.h: Regenerate.
@
text
@d12492 4
a12495 4
	  if (eh != NULL
	      && (eh->size == 0
		  || bfd_is_abs_section (eh->output_section)))
	    eh = NULL;
@


1.441
log
@	* elflink.c: Rename flaginfo to flinfo throughout, except..
	(bfd_elf_lookup_section_flags): ..here, rename finfo to flaginfo.
	Formatting, style.  Simplify flag match.
@
text
@d12525 2
a12526 2
      if (eh != NULL
	  && init_reloc_cookie_rels (&cookie, info, abfd, eh))
d12534 1
@


1.440
log
@
Add support for PowerPC VLE.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	* NEWS:  Mention PowerPC VLE port.

2012-05-14  James Lemke <jwlemke@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* bfd.c (bfd_lookup_section_flags): Add section parm.
	* ecoff.c (bfd_debug_section): Remove flag_info initializer.
	* elf-bfd.h (bfd_elf_section_data): Move in section_flag_info.
	(bfd_elf_lookup_section_flags): Add section parm.
	* elf32-ppc.c (is_ppc_vle): New function.
	(ppc_elf_modify_segment_map): New function.
	(elf_backend_modify_segment_map): Define.
	(has_vle_insns): New define.
	* elf32-ppc.h (ppc_elf_modify_segment_map): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): Add return value & parm.
	Move in logic to omit / include a section.
	* libbfd-in.h (bfd_link_info): Add section parm.
	(bfd_generic_lookup_section_flags): Likewise.
	* reloc.c (bfd_generic_lookup_section_flags): Likewise.
	* section.c (bfd_section): Move out section_flag_info.
	(BFD_FAKE_SECTION): Remove flag_info initializer.
	* targets.c (_bfd_lookup_section_flags): Add section parm.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* archures.c (bfd_mach_ppc_vle): New.
	* bfd-in2.h: Regenerated.
	* cpu-powerpc.c (bfd_powerpc_archs): New entry for vle.
	* elf32-ppc.c (split16_format_type): New enumeration.
	(ppc_elf_vle_split16): New function.
	(HOWTO): Add entries for R_PPC_VLE relocations.
	(ppc_elf_reloc_type_lookup): Handle PPC_VLE relocations.
	(ppc_elf_section_flags): New function.
	(ppc_elf_lookup_section_flags): New function.
	(ppc_elf_section_processing): New function.
	(ppc_elf_check_relocs): Handle PPC_VLE relocations.
	(ppc_elf_relocation_section): Likewise.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_section_flags): Define.
	(elf_backend_section_processing): Define.
	* elf32-ppc.h (ppc_elf_section_processing): Declare.
	* libbfd.h: Regenerated.
	* reloc.c (BFD_RELOC_PPC_VLE_REL8, BFD_RELOC_PPC_VLE_REL15,
	BFD_RELOC_PPC_VLE_REL24, BFD_RELOC_PPC_VLE_LO16A,
	BFD_RELOC_PPC_VLE_LO16D, BFD_RELOC_PPC_VLE_HI16A,
	BFD_RELOC_PPC_VLE_HI16D, BFD_RELOC_PPC_VLE_HA16A,
	BFD_RELOC_PPC_VLE_HA16D, BFD_RELOC_PPC_VLE_SDA21,
	BFD_RELOC_PPC_VLE_SDA21_LO, BFD_RELOC_PPC_VLE_SDAREL_LO16A,
	BFD_RELOC_PPC_VLE_SDAREL_LO16D, BFD_RELOC_PPC_VLE_SDAREL_HI16A,
	BFD_RELOC_PPC_VLE_SDAREL_HI16D, BFD_RELOC_PPC_VLE_SDAREL_HA16A,
	BFD_RELOC_PPC_VLE_SDAREL_HA16D): New bfd relocations.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (insn_validate): New func of existing code to call..
	(ppc_setup_opcodes): ..from 2 places here.
	Revise for second (VLE) opcode table.
	Add #ifdef'd code to print opcode tables.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Allow out-of-order
	for the VLE conditional branches.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/
	* config/tc-ppc.c (PPC_VLE_SPLIT16A): New macro.
	(PPC_VLE_SPLIT16D): New macro.
	(PPC_VLE_LO16A): New macro.
	(PPC_VLE_LO16D): New macro.
	(PPC_VLE_HI16A): New macro.
	(PPC_VLE_HI16D): New macro.
	(PPC_VLE_HA16A): New macro.
	(PPC_VLE_HA16D): New macro.
	(PPC_APUINFO_VLE): New definition.
	(md_chars_to_number): New function.
	(md_parse_option): Check for combinations of little
	endian and -mvle.
	(md_show_usage): Document -mvle.
	(ppc_arch): Recognize VLE.
	(ppc_mach): Recognize bfd_mach_ppc_vle.
	(ppc_setup_opcodes): Print the opcode table if
	* config/tc-ppc.h (ppc_frag_check): Declare.
	* doc/c-ppc.texi: Document -mvle.
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	gas/
	* config/tc-ppc.h (ppc_dw2_line_min_insn_length): Declare.
	(DWARF2_LINE_MIN_INSN_LENGTH): Redefine.
	* config/tc-ppc.c (ppc_dw2_line_min_insn_length): New.
	* dwarf2dbg.c (scale_addr_delta): Handle values of 1
	for DWARF2_LINE_MIN_INSN_LENGTH.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/testsuite/
	* gas/ppc/ppc.exp: Run new tests.
	* gas/ppc/vle-reloc.d: New test.
	* gas/ppc/vle-reloc.s: New test.
	* gas/ppc/vle-simple-1.d: New test.
	* gas/ppc/vle-simple-1.s: New test.
	* gas/ppc/vle-simple-2.d: New test.
	* gas/ppc/vle-simple-2.s: New test.
	* gas/ppc/vle-simple-3.d: New test.
	* gas/ppc/vle-simple-3.s: New test.
	* gas/ppc/vle-simple-4.d: New test.
	* gas/ppc/vle-simple-4.s: New test.
	* gas/ppc/vle-simple-5.d: New test.
	* gas/ppc/vle-simple-5.s: New test.
	* gas/ppc/vle-simple-6.d: New test.
	* gas/ppc/vle-simple-6.s: New test.
	* gas/ppc/vle.d: New test.
	* gas/ppc/vle.s: New test.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>
	include/elf/
	* ppc.h (SEC_PPC_VLE): Remove.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
	    James Lemke  <jwlemke@@codesourcery.com>

	include/elf/
	* ppc.h (R_PPC_VLE_REL8): New reloction.
	(R_PPC_VLE_REL15): Likewise.
	(R_PPC_VLE_REL24): Likewise.
	(R_PPC_VLE_LO16A): Likewise.
	(R_PPC_VLE_LO16D): Likewise.
	(R_PPC_VLE_HI16A): Likewise.
	(R_PPC_VLE_HI16D): Likewise.
	(R_PPC_VLE_HA16A): Likewise.
	(R_PPC_VLE_HA16D): Likewise.
	(R_PPC_VLE_SDA21): Likewise.
	(R_PPC_VLE_SDA21_LO): Likewise.
	(R_PPC_VLE_SDAREL_LO16A): Likewise.
	(R_PPC_VLE_SDAREL_LO16D): Likewise.
	(R_PPC_VLE_SDAREL_HI16A): Likewise.
	(R_PPC_VLE_SDAREL_HI16D): Likewise.
	(R_PPC_VLE_SDAREL_HA16A): Likewise.
	(R_PPC_VLE_SDAREL_HA16D): Likewise.
	(SEC_PPC_VLE): Remove.
	(PF_PPC_VLE): New program header flag.
	(SHF_PPC_VLE): New section header flag.
	(vle_opcodes, vle_num_opcodes): New.
	(VLE_OP): New macro.
	(VLE_OP_TO_SEG): New macro.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	include/opcode/
	* ppc.h (PPC_OPCODE_VLE): New definition.
	(PPC_OP_SA): New macro.
	(PPC_OP_SE_VLE): New macro.
	(PPC_OP): Use a variable shift amount.
	(powerpc_operand): Update comments.
	(PPC_OPSHIFT_INV): New macro.
	(PPC_OPERAND_CR): Replace with...
	(PPC_OPERAND_CR_BIT): ...this and
	(PPC_OPERAND_CR_REG): ...this.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/
	* ldlang.c (walk_wild_consider_section): Don't copy section_flag_list.
	Pass it to callback.
	(walk_wild_section_general): Pass section_flag_list to callback.
	(lang_add_section): Add sflag_list parm.
	Move out logic to keep / omit a section & call bfd_lookup_section_flags.
	(output_section_callback_fast): Add sflag_list parm.
	Add new parm to lang_add_section calls.
	(output_section_callback): Likewise.
	(check_section_callback): Add sflag_list parm.
	(lang_place_orphans): Add new parm to lang_add_section calls.
	(gc_section_callback): Add sflag_list parm.
	(find_relro_section_callback): Likewise.
	* ldlang.h (callback_t): Add flag_info parm.
	(lang_add_section): Add sflag_list parm.
	* emultempl/armelf.em (elf32_arm_add_stub_section):
	Add lang_add_section parm.
	* emultempl/beos.em (gld*_place_orphan): Likewise.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/mipself.em (mips_add_stub_section): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_*_place_orphan): Likewise.
	* emultempl/pep.em (gld_*_place_orphan): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/vms.em (vms_place_orphan): Likewise.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/powerpc.exp: Create ppceabitests.
	* ld-powerpc/vle-multiseg.s: New.
	* ld-powerpc/vle-multiseg-1.d: New.
	* ld-powerpc/vle-multiseg-1.ld: New.
	* ld-powerpc/vle-multiseg-2.d: New.
	* ld-powerpc/vle-multiseg-2.ld: New.
	* ld-powerpc/vle-multiseg-3.d: New.
	* ld-powerpc/vle-multiseg-3.ld: New.
	* ld-powerpc/vle-multiseg-4.d: New.
	* ld-powerpc/vle-multiseg-4.ld: New.
	* ld-powerpc/vle-multiseg-5.d: New.
	* ld-powerpc/vle-multiseg-5.ld: New.
	* ld-powerpc/vle-multiseg-6.d: New.
	* ld-powerpc/vle-multiseg-6.ld: New.
	* ld-powerpc/vle-multiseg-6a.s: New.
	* ld-powerpc/vle-multiseg-6b.s: New.
	* ld-powerpc/vle-multiseg-6c.s: New.
	* ld-powerpc/vle-multiseg-6d.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/apuinfo.rd: Update for VLE.
	* ld-powerpc/vle-reloc-1.d: New.
	* ld-powerpc/vle-reloc-1.s: New.
	* ld-powerpc/vle-reloc-2.d: New.
	* ld-powerpc/vle-reloc-2.s: New.
	* ld-powerpc/vle-reloc-3.d: New.
	* ld-powerpc/vle-reloc-3.s: New.
	* ld-powerpc/vle-reloc-def-1.s: New.
	* ld-powerpc/vle-reloc-def-2.s: New.
	* ld-powerpc/vle-reloc-def-3.s: New.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	opcodes/
	* ppc-dis.c (get_powerpc_dialect): Use is_ppc_vle.
	(PPC_OPCD_SEGS, VLE_OPCD_SEGS): New defines.
	(vle_opcd_indices): New array.
	(lookup_vle): New function.
	(disassemble_init_powerpc): Revise for second (VLE) opcode table.
	(print_insn_powerpc): Likewise.
	* ppc-opc.c: Likewise.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>
	    Nathan Froyd <froydnj@@codesourcery.com>

	opcodes/
	* ppc-opc.c (insert_arx, extract_arx): New functions.
	(insert_ary, extract_ary): New functions.
	(insert_li20, extract_li20): New functions.
	(insert_rx, extract_rx): New functions.
	(insert_ry, extract_ry): New functions.
	(insert_sci8, extract_sci8): New functions.
	(insert_sci8n, extract_sci8n): New functions.
	(insert_sd4h, extract_sd4h): New functions.
	(insert_sd4w, extract_sd4w): New functions.
	(insert_vlesi, extract_vlesi): New functions.
	(insert_vlensi, extract_vlensi): New functions.
	(insert_vleui, extract_vleui): New functions.
	(insert_vleil, extract_vleil): New functions.
 	(BI_MASK, BB_MASK, BT): Use PPC_OPERAND_CR_BIT.
 	(BI16, BI32, BO32, B8): New.
	(B15, B24, CRD32, CRS): New.
 	(CRD, OBF, BFA, CR, CRFS): Use PPC_OPERAND_CR_REG.
	(DB, IMM20, RD, Rx, ARX, RY, RZ): New.
	(ARY, SCLSCI8, SCLSCI8N, SE_SD, SE_SDH): New.
	(SH6_MASK): Use PPC_OPSHIFT_INV.
	(SI8, UI5, OIMM5, UI7, BO16): New.
	(VLESIMM, VLENSIMM, VLEUIMM, VLEUIMML): New.
	(XT6, XA6, XB6, XB6S, XC6): Use PPC_OPSHIFT_INV.
	(ALLOW8_SPRG): New.
	(insert_sprg, extract_sprg): Check ALLOW8_SPRG.
	(OPVUP, OPVUP_MASK OPVUP): New
	(BD8, BD8_MASK, BD8IO, BD8IO_MASK): New.
	(EBD8IO, EBD8IO1_MASK, EBD8IO2_MASK, EBD8IO3_MASK): New.
	(BD15, BD15_MASK, EBD15, EBD15_MASK, EBD15BI, EBD15BI_MASK): New.
	(BD24,BD24_MASK, C_LK, C_LK_MASK, C, C_MASK): New.
 	(IA16, IA16_MASK, I16A, I16A_MASK, I16L, I16L_MASK): New.
	(IM7, IM7_MASK, LI20, LI20_MASK, SCI8, SCI8_MASK): New.
	(SCI8BF, SCI8BF_MASK, SD4, SD4_MASK): New.
	(SE_IM5, SE_IM5_MASK): New.
	(SE_R, SE_R_MASK, SE_RR, SE_RR_MASK): New.
	(EX, EX_MASK, BO16F, BO16T, BO32F, BO32T): New.
	(BO32DNZ, BO32DZ): New.
	(NO371, PPCSPE, PPCISEL, PPCEFS, MULHW): Include PPC_OPCODE_VLE.
	(PPCVLE): New.
	(powerpc_opcodes): Add new VLE instructions.  Update existing
	instruction to include PPCVLE if supported.
	* ppc-dis.c (ppc_opts): Add vle entry.
	(get_powerpc_dialect): New function.
	(powerpc_init_dialect): VLE support.
	(print_insn_big_powerpc): Call get_powerpc_dialect.
	(print_insn_little_powerpc): Likewise.
	(operand_value_powerpc): Handle negative shift counts.
	(print_insn_powerpc): Handle 2-byte instruction lengths.
@
text
@d7411 1
a7411 1
  struct elf_final_link_info *flaginfo;
d7488 1
a7488 1
		struct elf_final_link_info *flaginfo,
d7517 1
a7517 1
	  asection *sec = flaginfo->sections [i];
d7530 1
a7530 1
  global_entry = bfd_link_hash_lookup (flaginfo->info->hash, name,
d7599 1
a7599 1
	     struct elf_final_link_info *flaginfo,
d7659 2
a7660 2
	  if (!resolve_section (symbuf, flaginfo->output_bfd->sections, result)
	      && !resolve_symbol (symbuf, input_bfd, flaginfo, result,
d7669 1
a7669 1
	  if (!resolve_symbol (symbuf, input_bfd, flaginfo, result,
d7671 1
a7671 1
	      && !resolve_section (symbuf, flaginfo->output_bfd->sections,
d7690 1
a7690 1
      if (!eval_symbol (&a, symp, input_bfd, flaginfo, dot,	\
d7707 1
a7707 1
      if (!eval_symbol (&a, symp, input_bfd, flaginfo, dot,	\
d7711 1
a7711 1
      if (!eval_symbol (&b, symp, input_bfd, flaginfo, dot,	\
d8309 1
a8309 1
elf_link_flush_output_syms (struct elf_final_link_info *flaginfo,
d8312 1
a8312 1
  if (flaginfo->symbuf_count > 0)
d8318 1
a8318 1
      hdr = &elf_tdata (flaginfo->output_bfd)->symtab_hdr;
d8320 3
a8322 3
      amt = flaginfo->symbuf_count * bed->s->sizeof_sym;
      if (bfd_seek (flaginfo->output_bfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (flaginfo->symbuf, amt, flaginfo->output_bfd) != amt)
d8326 1
a8326 1
      flaginfo->symbuf_count = 0;
d8335 1
a8335 1
elf_link_output_sym (struct elf_final_link_info *flaginfo,
d8348 1
a8348 1
  bed = get_elf_backend_data (flaginfo->output_bfd);
d8352 1
a8352 1
      int ret = (*output_symbol_hook) (flaginfo->info, name, elfsym, input_sec, h);
d8363 1
a8363 1
      elfsym->st_name = (unsigned long) _bfd_stringtab_add (flaginfo->symstrtab,
d8369 1
a8369 1
  if (flaginfo->symbuf_count >= flaginfo->symbuf_size)
d8371 1
a8371 1
      if (! elf_link_flush_output_syms (flaginfo, bed))
d8375 2
a8376 2
  dest = flaginfo->symbuf + flaginfo->symbuf_count * bed->s->sizeof_sym;
  destshndx = flaginfo->symshndxbuf;
d8379 1
a8379 1
      if (bfd_get_symcount (flaginfo->output_bfd) >= flaginfo->shndxbuf_size)
d8383 1
a8383 1
	  amt = flaginfo->shndxbuf_size * sizeof (Elf_External_Sym_Shndx);
d8388 1
a8388 1
	  flaginfo->symshndxbuf = destshndx;
d8390 1
a8390 1
	  flaginfo->shndxbuf_size *= 2;
d8392 1
a8392 1
      destshndx += bfd_get_symcount (flaginfo->output_bfd);
d8395 3
a8397 3
  bed->s->swap_symbol_out (flaginfo->output_bfd, elfsym, dest, destshndx);
  flaginfo->symbuf_count += 1;
  bfd_get_symcount (flaginfo->output_bfd) += 1;
d8585 1
a8585 1
  struct elf_final_link_info *flaginfo = eoinfo->flaginfo;
d8612 1
a8612 1
  bed = get_elf_backend_data (flaginfo->output_bfd);
d8631 10
a8640 8
	  && (!h->ref_regular || flaginfo->info->gc_sections)
	  && ! elf_link_check_versioned_symbol (flaginfo->info, bed, h)
	  && flaginfo->info->unresolved_syms_in_shared_libs != RM_IGNORE)
	{
	  if (! (flaginfo->info->callbacks->undefined_symbol
		 (flaginfo->info, h->root.root.string,
		  h->ref_regular ? NULL : h->root.u.undef.abfd,
		  NULL, 0, flaginfo->info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)))
d8651 2
a8652 2
  if (!flaginfo->info->relocatable
      && flaginfo->info->executable
d8658 1
a8658 1
      && ! elf_link_check_versioned_symbol (flaginfo->info, bed, h))
d8669 1
a8669 1
      def_bfd = flaginfo->output_bfd;
d8672 1
a8672 1
      (*_bfd_error_handler) (msg, flaginfo->output_bfd, def_bfd,
d8691 1
a8691 1
  else if (flaginfo->info->strip == strip_all)
d8693 2
a8694 2
  else if (flaginfo->info->strip == strip_some
	   && bfd_hash_lookup (flaginfo->info->keep_hash,
d8699 1
a8699 1
	   && ((flaginfo->info->strip_discarded
d8760 1
a8760 1
	      _bfd_elf_section_from_bfd_section (flaginfo->output_bfd,
d8766 1
a8766 1
		   flaginfo->output_bfd, input_sec->output_section, input_sec);
d8776 1
a8776 1
	    if (! flaginfo->info->relocatable)
d8781 1
a8781 1
		    asection *tls_sec = elf_hash_table (flaginfo->info)->tls_sec;
d8787 1
a8787 1
			BFD_ASSERT (flaginfo->info->gc_sections
d8826 1
a8826 1
       && !flaginfo->info->relocatable)
d8829 1
a8829 1
	  && ((flaginfo->info->shared
d8833 1
a8833 1
	  && elf_hash_table (flaginfo->info)->dynamic_sections_created))
d8836 1
a8836 1
	     (flaginfo->output_bfd, flaginfo->info, h, &sym)))
d8879 1
a8879 1
  if (! flaginfo->info->relocatable
d8893 1
a8893 1
      (*_bfd_error_handler) (msg, flaginfo->output_bfd, h->root.root.string);
d8902 1
a8902 1
  if (flaginfo->dynsym_sec != NULL
d8904 1
a8904 1
      && elf_hash_table (flaginfo->info)->dynamic_sections_created)
d8909 2
a8910 2
      esym = flaginfo->dynsym_sec->contents + h->dynindx * bed->s->sizeof_sym;
      if (! check_dynsym (flaginfo->output_bfd, &sym))
d8915 1
a8915 1
      bed->s->swap_symbol_out (flaginfo->output_bfd, &sym, esym, 0);
d8917 1
a8917 1
      if (flaginfo->hash_sec != NULL)
d8925 1
a8925 1
	  bucketcount = elf_hash_table (flaginfo->info)->bucketcount;
d8929 2
a8930 2
	    = elf_section_data (flaginfo->hash_sec)->this_hdr.sh_entsize;
	  bucketpos = ((bfd_byte *) flaginfo->hash_sec->contents
d8932 5
a8936 4
	  chain = bfd_get (8 * hash_entry_size, flaginfo->output_bfd, bucketpos);
	  bfd_put (8 * hash_entry_size, flaginfo->output_bfd, h->dynindx, bucketpos);
	  bfd_put (8 * hash_entry_size, flaginfo->output_bfd, chain,
		   ((bfd_byte *) flaginfo->hash_sec->contents
d8940 1
a8940 1
      if (flaginfo->symver_sec != NULL && flaginfo->symver_sec->contents != NULL)
d8958 1
a8958 1
	      if (flaginfo->info->create_default_symver)
d8965 1
a8965 1
	  eversym = (Elf_External_Versym *) flaginfo->symver_sec->contents;
d8967 1
a8967 1
	  _bfd_elf_swap_versym_out (flaginfo->output_bfd, &iversym, eversym);
d8976 2
a8977 2
  indx = bfd_get_symcount (flaginfo->output_bfd);
  ret = elf_link_output_sym (flaginfo, h->root.root.string, &sym, input_sec, h);
d9091 1
a9091 1
elf_link_input_bfd (struct elf_final_link_info *flaginfo, bfd *input_bfd)
d9112 1
a9112 1
  output_bfd = flaginfo->output_bfd;
d9139 3
a9141 3
				      flaginfo->internal_syms,
				      flaginfo->external_syms,
				      flaginfo->locsym_shndx);
d9150 1
a9150 1
  for (isym = isymbuf, pindex = flaginfo->indices, ppsection = flaginfo->sections;
d9198 1
a9198 1
      if (ppsection == flaginfo->sections)
d9211 1
a9211 1
      if (flaginfo->info->strip == strip_all)
d9219 1
a9219 1
      if (flaginfo->info->discard == discard_all)
d9237 2
a9238 2
      if ((flaginfo->info->strip == strip_some
	   && (bfd_hash_lookup (flaginfo->info->keep_hash, name, FALSE, FALSE)
d9240 3
a9242 3
	  || (((flaginfo->info->discard == discard_sec_merge
		&& (isec->flags & SEC_MERGE) && ! flaginfo->info->relocatable)
	       || flaginfo->info->discard == discard_l)
d9262 1
a9262 1
      if (! flaginfo->info->relocatable)
d9268 2
a9269 2
	      BFD_ASSERT (elf_hash_table (flaginfo->info)->tls_sec != NULL);
	      osym.st_value -= elf_hash_table (flaginfo->info)->tls_sec->vma;
d9274 1
a9274 1
      ret = elf_link_output_sym (flaginfo, name, &osym, isec, NULL);
d9306 1
a9306 1
      if (flaginfo->info->relocatable
d9316 1
a9316 1
		  && flaginfo->sections[symndx] == NULL))
d9329 1
a9329 1
	      asection *sec = flaginfo->sections[symndx]->output_section;
d9334 1
a9334 1
	      if (flaginfo->indices[symndx] == -1)
d9338 1
a9338 1
		  asection *sec = flaginfo->sections[symndx]->output_section;
d9357 1
a9357 1
		  ret = elf_link_output_sym (flaginfo, name, &sym, o, NULL);
d9361 1
a9361 1
		    flaginfo->indices[symndx] = indx;
d9366 1
a9366 1
		= flaginfo->indices[symndx];
d9389 1
a9389 1
	  contents = flaginfo->contents;
d9403 2
a9404 2
	    = _bfd_elf_link_read_relocs (input_bfd, o, flaginfo->external_relocs,
					 flaginfo->internal_relocs, FALSE);
d9457 1
a9457 1
		      && flaginfo->sections[r_symndx] == NULL))
d9495 1
a9495 1
		  ps = &flaginfo->sections[r_symndx];
d9501 1
a9501 1
		  && !flaginfo->info->relocatable)
d9517 1
a9517 1
		  if (!eval_symbol (&val, &sym_name, input_bfd, flaginfo, dot,
d9535 1
a9535 1
			(*flaginfo->info->callbacks->einfo)
d9551 1
a9551 1
							      flaginfo->info);
d9582 1
a9582 1
	  ret = (*relocate_section) (output_bfd, flaginfo->info,
d9586 1
a9586 1
				     flaginfo->sections);
d9591 2
a9592 2
	      || flaginfo->info->relocatable
	      || flaginfo->info->emitrelocations)
d9622 1
a9622 1
	      if (!flaginfo->info->relocatable)
d9644 1
a9644 1
							     flaginfo->info, o,
d9662 1
a9662 1
		  if (!flaginfo->info->relocatable)
d9673 1
a9673 1
			  && flaginfo->sections[r_symndx] == NULL))
d9706 1
a9706 1
		  sec = flaginfo->sections[r_symndx];
d9759 1
a9759 1
		      if (flaginfo->indices[r_symndx] == -1)
d9766 1
a9766 1
			  if (flaginfo->info->strip == strip_all)
d9790 1
a9790 1
			  if (! flaginfo->info->relocatable)
d9797 1
a9797 1
				  BFD_ASSERT (elf_hash_table (flaginfo->info)
d9799 1
a9799 1
				  sym.st_value -= (elf_hash_table (flaginfo->info)
d9805 1
a9805 1
			  ret = elf_link_output_sym (flaginfo, name, &sym, sec,
d9810 1
a9810 1
			    flaginfo->indices[r_symndx] = indx;
d9815 1
a9815 1
		      r_symndx = flaginfo->indices[r_symndx];
d9850 1
a9850 1
	  && (*bed->elf_backend_write_section) (output_bfd, flaginfo->info, o,
d9860 1
a9860 1
		  &elf_hash_table (flaginfo->info)->stab_info,
d9871 1
a9871 1
	    if (! _bfd_elf_write_section_eh_frame (output_bfd, flaginfo->info,
d10248 1
a10248 1
  struct elf_final_link_info flaginfo;
d10285 4
a10288 4
  flaginfo.info = info;
  flaginfo.output_bfd = abfd;
  flaginfo.symstrtab = _bfd_elf_stringtab_init ();
  if (flaginfo.symstrtab == NULL)
d10293 3
a10295 3
      flaginfo.dynsym_sec = NULL;
      flaginfo.hash_sec = NULL;
      flaginfo.symver_sec = NULL;
d10299 2
a10300 2
      flaginfo.dynsym_sec = bfd_get_section_by_name (dynobj, ".dynsym");
      flaginfo.hash_sec = bfd_get_section_by_name (dynobj, ".hash");
d10302 1
a10302 1
      flaginfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
d10306 12
a10317 12
  flaginfo.contents = NULL;
  flaginfo.external_relocs = NULL;
  flaginfo.internal_relocs = NULL;
  flaginfo.external_syms = NULL;
  flaginfo.locsym_shndx = NULL;
  flaginfo.internal_syms = NULL;
  flaginfo.indices = NULL;
  flaginfo.sections = NULL;
  flaginfo.symbuf = NULL;
  flaginfo.symshndxbuf = NULL;
  flaginfo.symbuf_count = 0;
  flaginfo.shndxbuf_size = 0;
d10545 1
a10545 1
    flaginfo.symbuf_size = 20;
d10547 2
a10548 2
    flaginfo.symbuf_size = max_sym_count;
  amt = flaginfo.symbuf_size;
d10550 2
a10551 2
  flaginfo.symbuf = (bfd_byte *) bfd_malloc (amt);
  if (flaginfo.symbuf == NULL)
d10557 1
a10557 1
      flaginfo.shndxbuf_size = amt;
d10559 2
a10560 2
      flaginfo.symshndxbuf = (Elf_External_Sym_Shndx *) bfd_zmalloc (amt);
      if (flaginfo.symshndxbuf == NULL)
d10575 1
a10575 1
      if (elf_link_output_sym (&flaginfo, NULL, &elfsym, bfd_und_section_ptr,
d10602 1
a10602 1
	      if (elf_link_output_sym (&flaginfo, NULL, &elfsym, o, NULL) != 1)
d10612 2
a10613 2
      flaginfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
      if (flaginfo.contents == NULL)
d10619 2
a10620 2
      flaginfo.external_relocs = bfd_malloc (max_external_reloc_size);
      if (flaginfo.external_relocs == NULL)
d10628 2
a10629 2
      flaginfo.internal_relocs = (Elf_Internal_Rela *) bfd_malloc (amt);
      if (flaginfo.internal_relocs == NULL)
d10636 2
a10637 2
      flaginfo.external_syms = (bfd_byte *) bfd_malloc (amt);
      if (flaginfo.external_syms == NULL)
d10641 2
a10642 2
      flaginfo.internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
      if (flaginfo.internal_syms == NULL)
d10646 2
a10647 2
      flaginfo.indices = (long int *) bfd_malloc (amt);
      if (flaginfo.indices == NULL)
d10651 2
a10652 2
      flaginfo.sections = (asection **) bfd_malloc (amt);
      if (flaginfo.sections == NULL)
d10659 2
a10660 2
      flaginfo.locsym_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (flaginfo.locsym_shndx == NULL)
d10734 1
a10734 1
		  if (! elf_link_input_bfd (&flaginfo, sub))
d10799 1
a10799 1
  eoinfo.flaginfo = &flaginfo;
d10814 1
a10814 1
	     (abfd, info, &flaginfo, (out_sym_func) elf_link_output_sym)))
d10827 2
a10828 2
      && flaginfo.dynsym_sec != NULL
      && flaginfo.dynsym_sec->output_section != bfd_abs_section_ptr)
d10831 1
a10831 1
      bfd_byte *dynsym = flaginfo.dynsym_sec->contents;
d10903 1
a10903 1
      elf_section_data (flaginfo.dynsym_sec->output_section)->this_hdr.sh_info =
d10910 1
a10910 1
  eoinfo.flaginfo = &flaginfo;
d10924 1
a10924 1
	     (abfd, info, &flaginfo, (out_sym_func) elf_link_output_sym)))
d10929 1
a10929 1
  if (! elf_link_flush_output_syms (&flaginfo, bed))
d10948 1
a10948 1
	  || (bfd_bwrite (flaginfo.symshndxbuf, amt, abfd) != amt))
d10960 1
a10960 1
  symstrtab_hdr->sh_size = _bfd_stringtab_size (flaginfo.symstrtab);
d10973 1
a10973 1
	  || ! _bfd_stringtab_emit (abfd, flaginfo.symstrtab))
d11267 22
a11288 22
  if (flaginfo.symstrtab != NULL)
    _bfd_stringtab_free (flaginfo.symstrtab);
  if (flaginfo.contents != NULL)
    free (flaginfo.contents);
  if (flaginfo.external_relocs != NULL)
    free (flaginfo.external_relocs);
  if (flaginfo.internal_relocs != NULL)
    free (flaginfo.internal_relocs);
  if (flaginfo.external_syms != NULL)
    free (flaginfo.external_syms);
  if (flaginfo.locsym_shndx != NULL)
    free (flaginfo.locsym_shndx);
  if (flaginfo.internal_syms != NULL)
    free (flaginfo.internal_syms);
  if (flaginfo.indices != NULL)
    free (flaginfo.indices);
  if (flaginfo.sections != NULL)
    free (flaginfo.sections);
  if (flaginfo.symbuf != NULL)
    free (flaginfo.symbuf);
  if (flaginfo.symshndxbuf != NULL)
    free (flaginfo.symshndxbuf);
d11313 22
a11334 22
  if (flaginfo.symstrtab != NULL)
    _bfd_stringtab_free (flaginfo.symstrtab);
  if (flaginfo.contents != NULL)
    free (flaginfo.contents);
  if (flaginfo.external_relocs != NULL)
    free (flaginfo.external_relocs);
  if (flaginfo.internal_relocs != NULL)
    free (flaginfo.internal_relocs);
  if (flaginfo.external_syms != NULL)
    free (flaginfo.external_syms);
  if (flaginfo.locsym_shndx != NULL)
    free (flaginfo.locsym_shndx);
  if (flaginfo.internal_syms != NULL)
    free (flaginfo.internal_syms);
  if (flaginfo.indices != NULL)
    free (flaginfo.indices);
  if (flaginfo.sections != NULL)
    free (flaginfo.sections);
  if (flaginfo.symbuf != NULL)
    free (flaginfo.symbuf);
  if (flaginfo.symshndxbuf != NULL)
    free (flaginfo.symshndxbuf);
d12229 1
a12229 1
			      struct flag_info *finfo,
d12232 1
a12232 1
  const bfd_vma sh_flags = elf_section_flags(section);
d12234 1
a12234 1
  if (finfo->flags_initialized == FALSE)
d12236 3
a12238 3
      const struct elf_backend_data *bed =
	get_elf_backend_data (info->output_bfd);
      struct flag_info_list *tf = finfo->flag_list;
d12242 1
a12242 1
      for (tf = finfo->flag_list; tf != NULL; tf = tf->next)
d12245 1
d12247 2
a12248 1
	  if (bed->elf_backend_lookup_section_flags_hook)
d12250 1
a12250 2
	      flagword hexval =
	        (*bed->elf_backend_lookup_section_flags_hook) ((char*)tf->name);
d12262 1
a12262 3
	  for (i = 0;
	       i < sizeof(elf_flags_to_names) / sizeof(elf_flags_to_name_table);
	       ++i)
d12264 1
a12264 1
	      if (!strcmp (tf->name, elf_flags_to_names[i].flag_name))
d12274 1
a12274 1
	  if (tf->valid == FALSE)
d12277 1
a12277 1
		    (_("Unrecognized INPUT_SECTION_FLAG %s\n"), tf->name);
d12281 3
a12283 3
      finfo->flags_initialized = TRUE;
      finfo->only_with_flags |= with_hex;
      finfo->not_with_flags |= without_hex;
d12286 1
a12286 5
  if (finfo->only_with_flags != 0
      && finfo->not_with_flags != 0
      && ((finfo->not_with_flags & sh_flags) != 0
           || (finfo->only_with_flags & sh_flags)
               != finfo->only_with_flags))
d12289 1
a12289 7
  if (finfo->only_with_flags != 0
      && (finfo->only_with_flags & sh_flags)
          != finfo->only_with_flags)
    return FALSE;

  if (finfo->not_with_flags != 0
      && (finfo->not_with_flags & sh_flags) != 0)
@


1.439
log
@	PR binutils/13121
	Rename 'finfo' to 'flaginfo' to avoid conflicts with
	AIX system headers.
@
text
@d12223 2
a12224 1
void
d12226 2
a12227 1
			      struct flag_info *flaginfo)
d12229 1
a12229 5
  bfd *output_bfd = info->output_bfd;
  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
  struct flag_info_list *tf = flaginfo->flag_list;
  int with_hex = 0;
  int without_hex = 0;
d12231 1
a12231 1
  for (tf = flaginfo->flag_list; tf != NULL; tf = tf->next)
d12233 7
a12239 2
      int i;
      if (bed->elf_backend_lookup_section_flags_hook)
d12241 1
a12241 2
	  flagword hexval =
	     (*bed->elf_backend_lookup_section_flags_hook) ((char *) tf->name);
d12243 1
a12243 1
	  if (hexval != 0)
d12245 12
a12256 6
	      if (tf->with == with_flags)
		with_hex |= hexval;
	      else if (tf->with == without_flags)
		without_hex |= hexval;
	      tf->valid = TRUE;
	      continue;
d12258 15
a12272 4
	}
      for (i = 0; i < 12; i++)
	{
	  if (!strcmp (tf->name, elf_flags_to_names[i].flag_name))
d12274 3
a12276 6
	      if (tf->with == with_flags)
		with_hex |= elf_flags_to_names[i].flag_value;
	      else if (tf->with == without_flags)
		without_hex |= elf_flags_to_names[i].flag_value;
	      tf->valid = TRUE;
	      continue;
d12279 3
a12281 6
      if (tf->valid == FALSE)
	{
	  info->callbacks->einfo 
		(_("Unrecognized INPUT_SECTION_FLAG %s\n"), tf->name);
	  return;
	}
a12282 3
 flaginfo->flags_initialized = TRUE;
 flaginfo->only_with_flags |= with_hex;
 flaginfo->not_with_flags |= without_hex;
d12284 17
a12300 1
 return;
@


1.438
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d7411 1
a7411 1
  struct elf_final_link_info *finfo;
d7488 1
a7488 1
		struct elf_final_link_info *finfo,
d7517 1
a7517 1
	  asection *sec = finfo->sections [i];
d7530 1
a7530 1
  global_entry = bfd_link_hash_lookup (finfo->info->hash, name,
d7599 1
a7599 1
	     struct elf_final_link_info *finfo,
d7659 2
a7660 2
	  if (!resolve_section (symbuf, finfo->output_bfd->sections, result)
	      && !resolve_symbol (symbuf, input_bfd, finfo, result,
d7669 1
a7669 1
	  if (!resolve_symbol (symbuf, input_bfd, finfo, result,
d7671 1
a7671 1
	      && !resolve_section (symbuf, finfo->output_bfd->sections,
d7690 1
a7690 1
      if (!eval_symbol (&a, symp, input_bfd, finfo, dot,	\
d7707 1
a7707 1
      if (!eval_symbol (&a, symp, input_bfd, finfo, dot,	\
d7711 1
a7711 1
      if (!eval_symbol (&b, symp, input_bfd, finfo, dot,	\
d8309 1
a8309 1
elf_link_flush_output_syms (struct elf_final_link_info *finfo,
d8312 1
a8312 1
  if (finfo->symbuf_count > 0)
d8318 1
a8318 1
      hdr = &elf_tdata (finfo->output_bfd)->symtab_hdr;
d8320 3
a8322 3
      amt = finfo->symbuf_count * bed->s->sizeof_sym;
      if (bfd_seek (finfo->output_bfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo->symbuf, amt, finfo->output_bfd) != amt)
d8326 1
a8326 1
      finfo->symbuf_count = 0;
d8335 1
a8335 1
elf_link_output_sym (struct elf_final_link_info *finfo,
d8348 1
a8348 1
  bed = get_elf_backend_data (finfo->output_bfd);
d8352 1
a8352 1
      int ret = (*output_symbol_hook) (finfo->info, name, elfsym, input_sec, h);
d8363 1
a8363 1
      elfsym->st_name = (unsigned long) _bfd_stringtab_add (finfo->symstrtab,
d8369 1
a8369 1
  if (finfo->symbuf_count >= finfo->symbuf_size)
d8371 1
a8371 1
      if (! elf_link_flush_output_syms (finfo, bed))
d8375 2
a8376 2
  dest = finfo->symbuf + finfo->symbuf_count * bed->s->sizeof_sym;
  destshndx = finfo->symshndxbuf;
d8379 1
a8379 1
      if (bfd_get_symcount (finfo->output_bfd) >= finfo->shndxbuf_size)
d8383 1
a8383 1
	  amt = finfo->shndxbuf_size * sizeof (Elf_External_Sym_Shndx);
d8388 1
a8388 1
	  finfo->symshndxbuf = destshndx;
d8390 1
a8390 1
	  finfo->shndxbuf_size *= 2;
d8392 1
a8392 1
      destshndx += bfd_get_symcount (finfo->output_bfd);
d8395 3
a8397 3
  bed->s->swap_symbol_out (finfo->output_bfd, elfsym, dest, destshndx);
  finfo->symbuf_count += 1;
  bfd_get_symcount (finfo->output_bfd) += 1;
d8585 1
a8585 1
  struct elf_final_link_info *finfo = eoinfo->finfo;
d8612 1
a8612 1
  bed = get_elf_backend_data (finfo->output_bfd);
d8631 3
a8633 3
	  && (!h->ref_regular || finfo->info->gc_sections)
	  && ! elf_link_check_versioned_symbol (finfo->info, bed, h)
	  && finfo->info->unresolved_syms_in_shared_libs != RM_IGNORE)
d8635 2
a8636 2
	  if (! (finfo->info->callbacks->undefined_symbol
		 (finfo->info, h->root.root.string,
d8638 1
a8638 1
		  NULL, 0, finfo->info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)))
d8649 2
a8650 2
  if (!finfo->info->relocatable
      && finfo->info->executable
d8656 1
a8656 1
      && ! elf_link_check_versioned_symbol (finfo->info, bed, h))
d8667 1
a8667 1
      def_bfd = finfo->output_bfd;
d8670 1
a8670 1
      (*_bfd_error_handler) (msg, finfo->output_bfd, def_bfd,
d8689 1
a8689 1
  else if (finfo->info->strip == strip_all)
d8691 2
a8692 2
  else if (finfo->info->strip == strip_some
	   && bfd_hash_lookup (finfo->info->keep_hash,
d8697 1
a8697 1
	   && ((finfo->info->strip_discarded
d8758 1
a8758 1
	      _bfd_elf_section_from_bfd_section (finfo->output_bfd,
d8764 1
a8764 1
		   finfo->output_bfd, input_sec->output_section, input_sec);
d8774 1
a8774 1
	    if (! finfo->info->relocatable)
d8779 1
a8779 1
		    asection *tls_sec = elf_hash_table (finfo->info)->tls_sec;
d8785 1
a8785 1
			BFD_ASSERT (finfo->info->gc_sections
d8824 1
a8824 1
       && !finfo->info->relocatable)
d8827 1
a8827 1
	  && ((finfo->info->shared
d8831 1
a8831 1
	  && elf_hash_table (finfo->info)->dynamic_sections_created))
d8834 1
a8834 1
	     (finfo->output_bfd, finfo->info, h, &sym)))
d8877 1
a8877 1
  if (! finfo->info->relocatable
d8891 1
a8891 1
      (*_bfd_error_handler) (msg, finfo->output_bfd, h->root.root.string);
d8900 1
a8900 1
  if (finfo->dynsym_sec != NULL
d8902 1
a8902 1
      && elf_hash_table (finfo->info)->dynamic_sections_created)
d8907 2
a8908 2
      esym = finfo->dynsym_sec->contents + h->dynindx * bed->s->sizeof_sym;
      if (! check_dynsym (finfo->output_bfd, &sym))
d8913 1
a8913 1
      bed->s->swap_symbol_out (finfo->output_bfd, &sym, esym, 0);
d8915 1
a8915 1
      if (finfo->hash_sec != NULL)
d8923 1
a8923 1
	  bucketcount = elf_hash_table (finfo->info)->bucketcount;
d8927 2
a8928 2
	    = elf_section_data (finfo->hash_sec)->this_hdr.sh_entsize;
	  bucketpos = ((bfd_byte *) finfo->hash_sec->contents
d8930 4
a8933 4
	  chain = bfd_get (8 * hash_entry_size, finfo->output_bfd, bucketpos);
	  bfd_put (8 * hash_entry_size, finfo->output_bfd, h->dynindx, bucketpos);
	  bfd_put (8 * hash_entry_size, finfo->output_bfd, chain,
		   ((bfd_byte *) finfo->hash_sec->contents
d8937 1
a8937 1
      if (finfo->symver_sec != NULL && finfo->symver_sec->contents != NULL)
d8955 1
a8955 1
	      if (finfo->info->create_default_symver)
d8962 1
a8962 1
	  eversym = (Elf_External_Versym *) finfo->symver_sec->contents;
d8964 1
a8964 1
	  _bfd_elf_swap_versym_out (finfo->output_bfd, &iversym, eversym);
d8973 2
a8974 2
  indx = bfd_get_symcount (finfo->output_bfd);
  ret = elf_link_output_sym (finfo, h->root.root.string, &sym, input_sec, h);
d9088 1
a9088 1
elf_link_input_bfd (struct elf_final_link_info *finfo, bfd *input_bfd)
d9109 1
a9109 1
  output_bfd = finfo->output_bfd;
d9136 3
a9138 3
				      finfo->internal_syms,
				      finfo->external_syms,
				      finfo->locsym_shndx);
d9147 1
a9147 1
  for (isym = isymbuf, pindex = finfo->indices, ppsection = finfo->sections;
d9195 1
a9195 1
      if (ppsection == finfo->sections)
d9208 1
a9208 1
      if (finfo->info->strip == strip_all)
d9216 1
a9216 1
      if (finfo->info->discard == discard_all)
d9234 2
a9235 2
      if ((finfo->info->strip == strip_some
	   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE, FALSE)
d9237 3
a9239 3
	  || (((finfo->info->discard == discard_sec_merge
		&& (isec->flags & SEC_MERGE) && ! finfo->info->relocatable)
	       || finfo->info->discard == discard_l)
d9259 1
a9259 1
      if (! finfo->info->relocatable)
d9265 2
a9266 2
	      BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
	      osym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
d9271 1
a9271 1
      ret = elf_link_output_sym (finfo, name, &osym, isec, NULL);
d9303 1
a9303 1
      if (finfo->info->relocatable
d9313 1
a9313 1
		  && finfo->sections[symndx] == NULL))
d9326 1
a9326 1
	      asection *sec = finfo->sections[symndx]->output_section;
d9331 1
a9331 1
	      if (finfo->indices[symndx] == -1)
d9335 1
a9335 1
		  asection *sec = finfo->sections[symndx]->output_section;
d9354 1
a9354 1
		  ret = elf_link_output_sym (finfo, name, &sym, o, NULL);
d9358 1
a9358 1
		    finfo->indices[symndx] = indx;
d9363 1
a9363 1
		= finfo->indices[symndx];
d9386 1
a9386 1
	  contents = finfo->contents;
d9400 2
a9401 2
	    = _bfd_elf_link_read_relocs (input_bfd, o, finfo->external_relocs,
					 finfo->internal_relocs, FALSE);
d9454 1
a9454 1
		      && finfo->sections[r_symndx] == NULL))
d9492 1
a9492 1
		  ps = &finfo->sections[r_symndx];
d9498 1
a9498 1
		  && !finfo->info->relocatable)
d9514 1
a9514 1
		  if (!eval_symbol (&val, &sym_name, input_bfd, finfo, dot,
d9532 1
a9532 1
			(*finfo->info->callbacks->einfo)
d9548 1
a9548 1
							      finfo->info);
d9579 1
a9579 1
	  ret = (*relocate_section) (output_bfd, finfo->info,
d9583 1
a9583 1
				     finfo->sections);
d9588 2
a9589 2
	      || finfo->info->relocatable
	      || finfo->info->emitrelocations)
d9619 1
a9619 1
	      if (!finfo->info->relocatable)
d9641 1
a9641 1
							     finfo->info, o,
d9659 1
a9659 1
		  if (!finfo->info->relocatable)
d9670 1
a9670 1
			  && finfo->sections[r_symndx] == NULL))
d9703 1
a9703 1
		  sec = finfo->sections[r_symndx];
d9756 1
a9756 1
		      if (finfo->indices[r_symndx] == -1)
d9763 1
a9763 1
			  if (finfo->info->strip == strip_all)
d9787 1
a9787 1
			  if (! finfo->info->relocatable)
d9794 1
a9794 1
				  BFD_ASSERT (elf_hash_table (finfo->info)
d9796 1
a9796 1
				  sym.st_value -= (elf_hash_table (finfo->info)
d9802 1
a9802 1
			  ret = elf_link_output_sym (finfo, name, &sym, sec,
d9807 1
a9807 1
			    finfo->indices[r_symndx] = indx;
d9812 1
a9812 1
		      r_symndx = finfo->indices[r_symndx];
d9847 1
a9847 1
	  && (*bed->elf_backend_write_section) (output_bfd, finfo->info, o,
d9857 1
a9857 1
		  &elf_hash_table (finfo->info)->stab_info,
d9868 1
a9868 1
	    if (! _bfd_elf_write_section_eh_frame (output_bfd, finfo->info,
d10245 1
a10245 1
  struct elf_final_link_info finfo;
d10282 4
a10285 4
  finfo.info = info;
  finfo.output_bfd = abfd;
  finfo.symstrtab = _bfd_elf_stringtab_init ();
  if (finfo.symstrtab == NULL)
d10290 3
a10292 3
      finfo.dynsym_sec = NULL;
      finfo.hash_sec = NULL;
      finfo.symver_sec = NULL;
d10296 2
a10297 2
      finfo.dynsym_sec = bfd_get_section_by_name (dynobj, ".dynsym");
      finfo.hash_sec = bfd_get_section_by_name (dynobj, ".hash");
d10299 1
a10299 1
      finfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
d10303 12
a10314 12
  finfo.contents = NULL;
  finfo.external_relocs = NULL;
  finfo.internal_relocs = NULL;
  finfo.external_syms = NULL;
  finfo.locsym_shndx = NULL;
  finfo.internal_syms = NULL;
  finfo.indices = NULL;
  finfo.sections = NULL;
  finfo.symbuf = NULL;
  finfo.symshndxbuf = NULL;
  finfo.symbuf_count = 0;
  finfo.shndxbuf_size = 0;
d10542 1
a10542 1
    finfo.symbuf_size = 20;
d10544 2
a10545 2
    finfo.symbuf_size = max_sym_count;
  amt = finfo.symbuf_size;
d10547 2
a10548 2
  finfo.symbuf = (bfd_byte *) bfd_malloc (amt);
  if (finfo.symbuf == NULL)
d10554 1
a10554 1
      finfo.shndxbuf_size = amt;
d10556 2
a10557 2
      finfo.symshndxbuf = (Elf_External_Sym_Shndx *) bfd_zmalloc (amt);
      if (finfo.symshndxbuf == NULL)
d10572 1
a10572 1
      if (elf_link_output_sym (&finfo, NULL, &elfsym, bfd_und_section_ptr,
d10599 1
a10599 1
	      if (elf_link_output_sym (&finfo, NULL, &elfsym, o, NULL) != 1)
d10609 2
a10610 2
      finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
      if (finfo.contents == NULL)
d10616 2
a10617 2
      finfo.external_relocs = bfd_malloc (max_external_reloc_size);
      if (finfo.external_relocs == NULL)
d10625 2
a10626 2
      finfo.internal_relocs = (Elf_Internal_Rela *) bfd_malloc (amt);
      if (finfo.internal_relocs == NULL)
d10633 2
a10634 2
      finfo.external_syms = (bfd_byte *) bfd_malloc (amt);
      if (finfo.external_syms == NULL)
d10638 2
a10639 2
      finfo.internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
      if (finfo.internal_syms == NULL)
d10643 2
a10644 2
      finfo.indices = (long int *) bfd_malloc (amt);
      if (finfo.indices == NULL)
d10648 2
a10649 2
      finfo.sections = (asection **) bfd_malloc (amt);
      if (finfo.sections == NULL)
d10656 2
a10657 2
      finfo.locsym_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (finfo.locsym_shndx == NULL)
d10731 1
a10731 1
		  if (! elf_link_input_bfd (&finfo, sub))
d10796 1
a10796 1
  eoinfo.finfo = &finfo;
d10811 1
a10811 1
	     (abfd, info, &finfo, (out_sym_func) elf_link_output_sym)))
d10824 2
a10825 2
      && finfo.dynsym_sec != NULL
      && finfo.dynsym_sec->output_section != bfd_abs_section_ptr)
d10828 1
a10828 1
      bfd_byte *dynsym = finfo.dynsym_sec->contents;
d10900 1
a10900 1
      elf_section_data (finfo.dynsym_sec->output_section)->this_hdr.sh_info =
d10907 1
a10907 1
  eoinfo.finfo = &finfo;
d10921 1
a10921 1
	     (abfd, info, &finfo, (out_sym_func) elf_link_output_sym)))
d10926 1
a10926 1
  if (! elf_link_flush_output_syms (&finfo, bed))
d10945 1
a10945 1
	  || (bfd_bwrite (finfo.symshndxbuf, amt, abfd) != amt))
d10957 1
a10957 1
  symstrtab_hdr->sh_size = _bfd_stringtab_size (finfo.symstrtab);
d10970 1
a10970 1
	  || ! _bfd_stringtab_emit (abfd, finfo.symstrtab))
d11264 22
a11285 22
  if (finfo.symstrtab != NULL)
    _bfd_stringtab_free (finfo.symstrtab);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
  if (finfo.external_syms != NULL)
    free (finfo.external_syms);
  if (finfo.locsym_shndx != NULL)
    free (finfo.locsym_shndx);
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.indices != NULL)
    free (finfo.indices);
  if (finfo.sections != NULL)
    free (finfo.sections);
  if (finfo.symbuf != NULL)
    free (finfo.symbuf);
  if (finfo.symshndxbuf != NULL)
    free (finfo.symshndxbuf);
d11310 22
a11331 22
  if (finfo.symstrtab != NULL)
    _bfd_stringtab_free (finfo.symstrtab);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
  if (finfo.external_syms != NULL)
    free (finfo.external_syms);
  if (finfo.locsym_shndx != NULL)
    free (finfo.locsym_shndx);
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.indices != NULL)
    free (finfo.indices);
  if (finfo.sections != NULL)
    free (finfo.sections);
  if (finfo.symbuf != NULL)
    free (finfo.symbuf);
  if (finfo.symshndxbuf != NULL)
    free (finfo.symshndxbuf);
d12225 1
a12225 1
			      struct flag_info *finfo)
d12229 1
a12229 1
  struct flag_info_list *tf = finfo->flag_list;
d12233 1
a12233 1
  for (tf = finfo->flag_list; tf != NULL; tf = tf->next)
d12270 3
a12272 3
 finfo->flags_initialized = TRUE;
 finfo->only_with_flags |= with_hex;
 finfo->not_with_flags |= without_hex;
@


1.437
log
@Set reloc_count to 0 for reloc sections

bfd/

2012-04-13  Alan Modra  <amodra@@gmail.com>

	PR ld/13947
	* elflink.c (bfd_elf_final_link): Set reloc_count to 0 for
	reloc sections.

ld/testsuite/

2012-04-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13947
	* ld-x86-64/x86-64.exp: Run pr13947.
	* ld-x86-64/pr13947.d: New file.
	* ld-x86-64/pr13947.s: Likewise.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011
d940 1
a940 1
      && sec->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
d2709 1
a2709 1
      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
d3500 1
a3500 1
	  && s->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
d3897 1
a3897 1
	  else if (elf_discarded_section (sec))
d4862 1
a4862 1
		  stab->sec_info_type = ELF_INFO_TYPE_STABS;
a6644 11
/* Indicate that we are only retrieving symbol values from this
   section.  */

void
_bfd_elf_link_just_syms (asection *sec, struct bfd_link_info *info)
{
  if (is_elf_hash_table (info->hash))
    sec->sec_info_type = ELF_INFO_TYPE_JUST_SYMS;
  _bfd_generic_link_just_syms (sec, info);
}

d6651 2
a6652 2
  BFD_ASSERT (sec->sec_info_type == ELF_INFO_TYPE_MERGE);
  sec->sec_info_type = ELF_INFO_TYPE_NONE;
d6680 1
a6680 1
	      sec->sec_info_type = ELF_INFO_TYPE_MERGE;
d8698 1
a8698 1
		&& elf_discarded_section (h->root.u.def.section))
d8998 2
a8999 2
    case ELF_INFO_TYPE_STABS:
    case ELF_INFO_TYPE_EH_FRAME:
d9184 1
a9184 1
	  else if (isec->sec_info_type == ELF_INFO_TYPE_MERGE
d9528 1
a9528 1
		  if ((sec = *ps) != NULL && elf_discarded_section (sec))
d9854 1
a9854 1
	case ELF_INFO_TYPE_STABS:
d9861 1
a9861 1
	case ELF_INFO_TYPE_MERGE:
d9866 1
a9866 1
	case ELF_INFO_TYPE_EH_FRAME:
d12417 1
a12417 1
	      && elf_discarded_section (h->root.u.def.section))
d12433 1
a12433 1
	  if (isec != NULL && elf_discarded_section (isec))
d12484 1
a12484 1
	      || stab->sec_info_type != ELF_INFO_TYPE_STABS))
@


1.436
log
@	* configure.ac (ia64*-*-*vms*): Add support for ld.
	* configure: Regenerate.

	* scripttempl/ia64vms.sc: New file.
	* emultempl/vms.em (_before_parse): Support for ia64.
	(elf64-ia64-vms): New fragment for ia64.
	* emulparams/elf64_ia64_vms.sh: New file.
	* configure.tgt (ia64-*-*vms*): Add.
	* Makefile.am (ALL_64_EMULATION_SOURCES): Add eelf64_ia64_vms.c
	(eelf64_ia64_vms.c): New rule.
	* Makefile.in: Regenerate.

	* elflink.c (elf_link_output_extsym): Add a guard.
	(bfd_elf_final_link): Remove assertion.
	(bfd_elf_final_link): Add a guard.
	* elfnn-ia64.c (INCLUDE_IA64_VMS): Removed.
	(elfNN_vms_section_from_shdr, elfNN_vms_object_p)
	(elfNN_vms_post_process_headers, elfNN_vms_section_processing)
	(elfNN_vms_final_write_processing, elfNN_vms_close_and_cleanup):
	Remove.
	(elfNN-ia64-vms target): Move to ...
	* elf64-ia64-vms.c: New file.
	* configure.in (bfd_elf64_ia64_vms_vec): Add elf64-ia64-vms.lo
	* Makefile.am (BFD64_BACKENDS): Add elf64-ia64-vms.lo.
	(BFD64_BACKENDS_CFILES): Ad elf64-ia64-vms.c.
	* configure: Regenerate.
	* Makefile.in: Regenerate.
@
text
@d10399 7
a10405 1
	      if (info->relocatable || info->emitrelocations)
@


1.435
log
@	* elflink.c (_bfd_elf_gc_mark_reloc): Don't delve into dynamic
	libraries.
@
text
@d8911 2
a8912 1
  if (h->dynindx != -1
d10309 1
a10309 1
      BFD_ASSERT (finfo.dynsym_sec != NULL);
d10829 1
@


1.434
log
@	* linker.c (_bfd_nearby_section): New function, split out from..
	(fix_syms): ..here.
	* bfd-in.h (_bfd_nearby_section): Declare.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't use text_index_section or
	data_index_section with ld -q or ld -r output relocs against
	stripped output sections.  Instead use _bfd_nearby_section.
@
text
@d11593 2
a11594 1
      if (bfd_get_flavour (rsec->owner) != bfd_target_elf_flavour)
@


1.433
log
@	* elflink.c (_bfd_elf_gc_mark_rsec): Mark weakdef syms too.
	(_bfd_elf_fix_symbol_flags): When a weakdef is def_regular, clear
	the correct h->u.weakdef.
@
text
@d9750 5
a9754 14
				  struct elf_link_hash_table *htab;
				  asection *oi;

				  htab = elf_hash_table (finfo->info);
				  oi = htab->text_index_section;
				  if ((osec->flags & SEC_READONLY) == 0
				      && htab->data_index_section != NULL)
				    oi = htab->data_index_section;

				  if (oi != NULL)
				    {
				      irela->r_addend += osec->vma - oi->vma;
				      r_symndx = oi->target_index;
				    }
a9755 2

			      BFD_ASSERT (r_symndx != STN_UNDEF);
@


1.432
log
@	PR ld/12772
	* elflink.c (elf_gc_sweep_symbol): Discard unmarked symbols
	defined in shared libraries.
@
text
@a2512 10
      struct elf_link_hash_entry *weakdef;

      weakdef = h->u.weakdef;
      while (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      BFD_ASSERT (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak);
      BFD_ASSERT (weakdef->def_dynamic);

d2516 1
a2516 1
      if (weakdef->def_regular)
d2520 8
d11576 6
@


1.431
log
@	PR ld/13468
	* elflink.c (bfd_elf_final_link): Don't segfault when checking
	for DT_TEXTREL and .dynamic does not exist.
@
text
@d11728 2
a11729 1
	   && !h->root.u.def.section->gc_mark)
@


1.430
log
@	* elflink.c (_bfd_elf_create_got_section): Replace
	bfd_make_section_with_flags with bfd_make_section_anyway_with_flags.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_create_glink): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
@
text
@d11191 3
a11193 2
      if ((info->warn_shared_textrel && info->shared)
	  || info->error_textrel)
a11196 4
	  /* Fix up .dynamic entries.  */
	  o = bfd_get_section_by_name (dynobj, ".dynamic");
	  BFD_ASSERT (o != NULL);

@


1.429
log
@	* elflink.c (bfd_elf_gc_mark_dynamic_ref_symbol): Mark syms in
	executables when export_dynamic.
@
text
@d113 5
a117 5
  s = bfd_make_section_with_flags (abfd,
				   (bed->rela_plts_and_copies_p
				    ? ".rela.got" : ".rel.got"),
				   (bed->dynamic_sec_flags
				    | SEC_READONLY));
d123 1
a123 1
  s = bfd_make_section_with_flags (abfd, ".got", flags);
d131 1
a131 1
      s = bfd_make_section_with_flags (abfd, ".got.plt", flags);
d209 2
a210 2
      s = bfd_make_section_with_flags (abfd, ".interp",
				       flags | SEC_READONLY);
d217 2
a218 2
  s = bfd_make_section_with_flags (abfd, ".gnu.version_d",
				   flags | SEC_READONLY);
d223 2
a224 2
  s = bfd_make_section_with_flags (abfd, ".gnu.version",
				   flags | SEC_READONLY);
d229 2
a230 2
  s = bfd_make_section_with_flags (abfd, ".gnu.version_r",
				   flags | SEC_READONLY);
d235 2
a236 2
  s = bfd_make_section_with_flags (abfd, ".dynsym",
				   flags | SEC_READONLY);
d241 2
a242 2
  s = bfd_make_section_with_flags (abfd, ".dynstr",
				   flags | SEC_READONLY);
d246 1
a246 1
  s = bfd_make_section_with_flags (abfd, ".dynamic", flags);
d262 2
a263 1
      s = bfd_make_section_with_flags (abfd, ".hash", flags | SEC_READONLY);
d272 2
a273 2
      s = bfd_make_section_with_flags (abfd, ".gnu.hash",
				       flags | SEC_READONLY);
d324 1
a324 1
  s = bfd_make_section_with_flags (abfd, ".plt", pltflags);
d341 4
a344 4
  s = bfd_make_section_with_flags (abfd,
				   (bed->rela_plts_and_copies_p
				    ? ".rela.plt" : ".rel.plt"),
				   flags | SEC_READONLY);
d361 2
a362 3
      s = bfd_make_section_with_flags (abfd, ".dynbss",
				       (SEC_ALLOC
					| SEC_LINKER_CREATED));
d379 4
a382 4
	  s = bfd_make_section_with_flags (abfd,
					   (bed->rela_plts_and_copies_p
					    ? ".rela.bss" : ".rel.bss"),
					   flags | SEC_READONLY);
@


1.428
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d11950 1
a11950 1
	  || (!info->executable
@


1.427
log
@	PR ld/13311
	* elflink.c (elf_link_output_extsym): Correct test for warning when
	forced local executable syms are referenced from shared libraries.
@
text
@d11580 1
d11728 6
a11733 9
  if (((h->root.type == bfd_link_hash_defined
	|| h->root.type == bfd_link_hash_defweak)
       && !h->root.u.def.section->gc_mark
       && (!(h->root.u.def.section->owner->flags & DYNAMIC)
	   || (h->plt.refcount <= 0
	       && h->got.refcount <= 0)))
      || (h->root.type == bfd_link_hash_undefined
	  && h->plt.refcount <= 0
	  && h->got.refcount <= 0))
d11735 3
a11737 2
      struct elf_gc_sweep_symbol_info *inf =
	(struct elf_gc_sweep_symbol_info *) data;
d11739 3
@


1.426
log
@	PR ld/13254
include/
	* bfdlink.h (struct bfd_link_info): Add error_textrel.
bfd/
	* elflink.c (bfd_elf_final_link): Emit error_textrel error.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	-z text, -z notext, -z textoff options for all targets having
	shared lib support.
@
text
@d8662 2
a8663 2
  if (! finfo->info->relocatable
      && (! finfo->info->shared)
d8666 1
@


1.425
log
@Preserve the maximum alignment/size for common symbols.

bfd/

2011-10-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13250
	* elflink.c (elf_link_add_object_symbols): Preserve the maximum
	alignment and size for common symbols.

ld/testsuite/

2011-10-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13250
	* ld-elf/shared.exp (build_tests): Add tests for PR ld/13250.
	(run_tests): Likewise.

	* ld-elf/pr13250-1.c: New.
	* ld-elf/pr13250-2.c: Likewise.
	* ld-elf/pr13250-3.c: Likewise.
@
text
@d11190 2
a11191 1
      if (info->warn_shared_textrel && info->shared)
d11209 6
a11214 2
		 info->callbacks->einfo
		    (_("%P: warning: creating a DT_TEXTREL in a shared object.\n"));
@


1.424
log
@	PR ld/13229
	PR ld/13244
	* elflink.c (elf_link_add_object_symbols): Don't make IR symbols
	dynamic.
@
text
@d4518 2
d4529 14
d4551 7
@


1.423
log
@	* elflink.c (elf_link_output_extsym): Strip defined plugin symbols
	even when strip_discarded is false.
@
text
@d4379 1
d4381 5
a4385 4
	    {
	      /* We don't want to make debug symbol dynamic.  */
	      dynsym = FALSE;
	    }
@


1.422
log
@	PR ld/13233
	* elflink.c (_bfd_elf_gc_mark_extra_sections): Mark single member
	debug and special section groups.
@
text
@d8682 6
a8687 4
  else if (finfo->info->strip_discarded
	   && (h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	   && elf_discarded_section (h->root.u.def.section))
@


1.421
log
@Fix --gc-sections failure with symbol versioning.

bfd/

2011-09-28  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13195
	* elflink.c (_bfd_elf_merge_symbol): Don't set dynamic_def when
	clearing def_dynamic.
	(elf_link_add_object_symbols): Likewise.  Set dynamic_def when
	setting def_dynamic.
	(bfd_elf_gc_mark_dynamic_ref_symbol): Check if a symbol is
	versioned.

ld/testsuite/

2011-09-28  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13195
	* ld-elf/elf.exp: Add a C link testcase for PR ld/13195.

	* ld-elf/pr13195.c: New.
	* ld-elf/pr13195.d: Likewise.
	* ld-elf/pr13195.s: Likewise.
	* ld-elf/pr13195.t: Likewise.
@
text
@d11671 1
a11671 1
	 not part of a group.  */
d11673 2
a11674 1
	if (elf_next_in_group (isec) == NULL
@


1.420
log
@Also hide symbols without PLT nor GOT references.

bfd/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13177
	* elflink.c (elf_gc_sweep_symbol): Also hide symbols without PLT
	nor GOT references.

ld/testsuite/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13177
	* ld-elf/pr13177.d: New.
	* ld-elf/pr13177.s: Likewise.
@
text
@a1240 1
	  h->dynamic_def = 1;
a4354 1
		      h->dynamic_def = 1;
d4367 4
a4370 1
		h->def_dynamic = 1;
d11918 3
a11920 2
	      && !bfd_hide_sym_by_version (info->version_info,
					   h->root.root.string))))
@


1.420.2.1
log
@	PR ld/13233
	* elflink.c (_bfd_elf_gc_mark_extra_sections): Mark single member
	debug and special section groups.
@
text
@d11670 1
a11670 1
	 not part of a group, or when we have single-member groups.  */
d11672 1
a11672 2
	if ((elf_next_in_group (isec) == NULL
	     || elf_next_in_group (isec) == isec)
@


1.420.2.2
log
@Fix --gc-sections failure with symbol versioning.

bfd/

2011-09-29  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13195
	* elflink.c (_bfd_elf_merge_symbol): Don't set dynamic_def when
	clearing def_dynamic.
	(elf_link_add_object_symbols): Likewise.  Set dynamic_def when
	setting def_dynamic.
	(bfd_elf_gc_mark_dynamic_ref_symbol): Check if a symbol is
	versioned.

ld/testsuite/

2011-09-29  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13195
	* ld-elf/elf.exp: Add a C link testcase for PR ld/13195.

	* ld-elf/pr13195.c: New.
	* ld-elf/pr13195.d: Likewise.
	* ld-elf/pr13195.s: Likewise.
	* ld-elf/pr13195.t: Likewise.
@
text
@d1241 1
d4356 1
d4369 1
a4369 4
		{
		  h->def_dynamic = 1;
		  h->dynamic_def = 1;
		}
d11918 2
a11919 3
	      && (strchr (h->root.root.string, ELF_VER_CHR) != NULL
		  || !bfd_hide_sym_by_version (info->version_info,
					       h->root.root.string)))))
@


1.420.2.3
log
@Revert the fix for PR ld/13177.

bfd/

2011-10-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13177
	* elflink.c (elf_gc_sweep_symbol): Don't hide symbols without PLT
	nor GOT references.

ld/testsuite/

2011-10-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13177
	* ld-elf/pr13177.d: Removed.
	* ld-elf/pr13177.s: Likewise.
@
text
@d11694 9
a11702 4
  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && !h->root.u.def.section->gc_mark
      && !(h->root.u.def.section->owner->flags & DYNAMIC))
d11705 1
a11705 1
          (struct elf_gc_sweep_symbol_info *) data;
@


1.420.2.4
log
@	Apply mainline patches
	2011-10-08  Alan Modra  <amodra@@gmail.com>
	* elflink.c (elf_link_output_extsym): Strip defined plugin symbols
	even when strip_discarded is false.
@
text
@d8682 4
a8685 6
  else if ((h->root.type == bfd_link_hash_defined
	    || h->root.type == bfd_link_hash_defweak)
	   && ((finfo->info->strip_discarded
		&& elf_discarded_section (h->root.u.def.section))
	       || (h->root.u.def.section->owner != NULL
		   && (h->root.u.def.section->owner->flags & BFD_PLUGIN) != 0)))
@


1.420.2.5
log
@	PR ld/13229
	PR ld/13244
	Apply mainline patches
	2011-10-08  Alan Modra  <amodra@@gmail.com>
	* elflink.c (elf_link_add_object_symbols): Don't make IR symbols
	dynamic.
@
text
@a4378 1
	  /* We don't want to make debug symbol dynamic.  */
d4380 4
a4383 5
	    dynsym = FALSE;

	  /* Nor should we make plugin symbols dynamic.  */
	  if ((abfd->flags & BFD_PLUGIN) != 0)
	    dynsym = FALSE;
@


1.420.2.6
log
@	PR ld/13250
bfd/
	2011-10-08  H.J. Lu  <hongjiu.lu@@intel.com>
	* elflink.c (elf_link_add_object_symbols): Preserve the maximum
	alignment and size for common symbols.
ld/testsuite/
	2011-10-08  H.J. Lu  <hongjiu.lu@@intel.com>
	* ld-elf/shared.exp (build_tests): Add tests for PR ld/13250.
	(run_tests): Likewise.
	* ld-elf/pr13250-1.c: New.
	* ld-elf/pr13250-2.c: Likewise.
	* ld-elf/pr13250-3.c: Likewise.
@
text
@a4517 2
	  bfd_size_type size;
	  unsigned int alignment_power;
a4526 14
	      /* Preserve the maximum alignment and size for common
		 symbols even if this dynamic lib isn't on DT_NEEDED
		 since it can still be loaded at the run-time by another
		 dynamic lib.  */
	      if (h->root.type == bfd_link_hash_common)
		{
		  size = h->root.u.c.size;
		  alignment_power = h->root.u.c.p->alignment_power;
		}
	      else
		{
		  size = 0;
		  alignment_power = 0;
		}
a4534 7
	      else if (h->root.type == bfd_link_hash_common)
		{
		  if (size > h->root.u.c.size)
		    h->root.u.c.size = size;
		  if (alignment_power > h->root.u.c.p->alignment_power)
		    h->root.u.c.p->alignment_power = alignment_power;
		}
@


1.420.2.7
log
@	PR ld/13254
include/
	2011-10-19  Alan Modra  <amodra@@gmail.com>
	* bfdlink.h (struct bfd_link_info): Add error_textrel.
bfd/
	2011-10-19  Alan Modra  <amodra@@gmail.com>
	* elflink.c (bfd_elf_final_link): Emit error_textrel error.
ld/
	2011-10-19  Alan Modra  <amodra@@gmail.com>
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	-z text, -z notext, -z textoff options for all targets having
	shared lib support.
@
text
@d11190 1
a11190 2
      if ((info->warn_shared_textrel && info->shared)
	  || info->error_textrel)
d11208 2
a11209 6
		  if (info->error_textrel)
		    info->callbacks->einfo
		      (_("%P%X: read-only segment has dynamic relocations.\n"));
		  else
		    info->callbacks->einfo
		      (_("%P: warning: creating a DT_TEXTREL in a shared object.\n"));
@


1.420.2.8
log
@	PR ld/13311
	2011-10-19  Alan Modra  <amodra@@gmail.com>
	* elflink.c (elf_link_output_extsym): Correct test for warning when
	forced local executable syms are referenced from shared libraries.
@
text
@d8662 2
a8663 2
  if (!finfo->info->relocatable
      && finfo->info->executable
a8665 1
      && h->def_regular
@


1.420.2.9
log
@	* elflink.c (bfd_elf_gc_mark_dynamic_ref_symbol): Mark syms in
	executables when export_dynamic.
@
text
@d11943 1
a11943 1
	  || ((!info->executable || info->export_dynamic)
@


1.420.2.10
log
@	* elflink.c (_bfd_elf_create_got_section): Replace
	bfd_make_section_with_flags with bfd_make_section_anyway_with_flags.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_create_glink): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
@
text
@d113 5
a117 5
  s = bfd_make_section_anyway_with_flags (abfd,
					  (bed->rela_plts_and_copies_p
					   ? ".rela.got" : ".rel.got"),
					  (bed->dynamic_sec_flags
					   | SEC_READONLY));
d123 1
a123 1
  s = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
d131 1
a131 1
      s = bfd_make_section_anyway_with_flags (abfd, ".got.plt", flags);
d209 2
a210 2
      s = bfd_make_section_anyway_with_flags (abfd, ".interp",
					      flags | SEC_READONLY);
d217 2
a218 2
  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version_d",
					  flags | SEC_READONLY);
d223 2
a224 2
  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version",
					  flags | SEC_READONLY);
d229 2
a230 2
  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version_r",
					  flags | SEC_READONLY);
d235 2
a236 2
  s = bfd_make_section_anyway_with_flags (abfd, ".dynsym",
					  flags | SEC_READONLY);
d241 2
a242 2
  s = bfd_make_section_anyway_with_flags (abfd, ".dynstr",
					  flags | SEC_READONLY);
d246 1
a246 1
  s = bfd_make_section_anyway_with_flags (abfd, ".dynamic", flags);
d262 1
a262 2
      s = bfd_make_section_anyway_with_flags (abfd, ".hash",
					      flags | SEC_READONLY);
d271 2
a272 2
      s = bfd_make_section_anyway_with_flags (abfd, ".gnu.hash",
					      flags | SEC_READONLY);
d323 1
a323 1
  s = bfd_make_section_anyway_with_flags (abfd, ".plt", pltflags);
d340 4
a343 4
  s = bfd_make_section_anyway_with_flags (abfd,
					  (bed->rela_plts_and_copies_p
					   ? ".rela.plt" : ".rel.plt"),
					  flags | SEC_READONLY);
d360 3
a362 2
      s = bfd_make_section_anyway_with_flags (abfd, ".dynbss",
					      (SEC_ALLOC | SEC_LINKER_CREATED));
d379 4
a382 4
	  s = bfd_make_section_anyway_with_flags (abfd,
						  (bed->rela_plts_and_copies_p
						   ? ".rela.bss" : ".rel.bss"),
						  flags | SEC_READONLY);
@


1.420.2.11
log
@	PR ld/13468
	* elflink.c (bfd_elf_final_link): Don't segfault when checking
	for DT_TEXTREL and .dynamic does not exist.
@
text
@d11191 2
a11192 3
      if (((info->warn_shared_textrel && info->shared)
	   || info->error_textrel)
	  && (o = bfd_get_section_by_name (dynobj, ".dynamic")) != NULL)
d11196 4
@


1.420.2.12
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
d940 1
a940 1
      && sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
d2711 1
a2711 1
      && sec->sec_info_type == SEC_INFO_TYPE_MERGE)
d3502 1
a3502 1
	  && s->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
d3899 1
a3899 1
	  else if (discarded_section (sec))
d4864 1
a4864 1
		  stab->sec_info_type = SEC_INFO_TYPE_STABS;
d6647 11
d6664 2
a6665 2
  BFD_ASSERT (sec->sec_info_type == SEC_INFO_TYPE_MERGE);
  sec->sec_info_type = SEC_INFO_TYPE_NONE;
d6693 1
a6693 1
	      sec->sec_info_type = SEC_INFO_TYPE_MERGE;
d8711 1
a8711 1
		&& discarded_section (h->root.u.def.section))
d9010 2
a9011 2
    case SEC_INFO_TYPE_STABS:
    case SEC_INFO_TYPE_EH_FRAME:
d9196 1
a9196 1
	  else if (isec->sec_info_type == SEC_INFO_TYPE_MERGE
d9540 1
a9540 1
		  if ((sec = *ps) != NULL && discarded_section (sec))
d9877 1
a9877 1
	case SEC_INFO_TYPE_STABS:
d9884 1
a9884 1
	case SEC_INFO_TYPE_MERGE:
d9889 1
a9889 1
	case SEC_INFO_TYPE_EH_FRAME:
d12418 1
a12418 1
	      && discarded_section (h->root.u.def.section))
d12434 1
a12434 1
	  if (isec != NULL && discarded_section (isec))
d12485 1
a12485 1
	      || stab->sec_info_type != SEC_INFO_TYPE_STABS))
@


1.419
log
@Check if a symbol is hidden by linker script.

bfd/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfd-in.h (bfd_elf_size_dynamic_sections): Remove pointer
	to struct bfd_elf_version_tree.

	* elflink.c (elf_info_failed): Remove verdefs.
	(_bfd_elf_export_symbol): Updated.
	_bfd_elf_link_assign_sym_version): Likewise.
	(bfd_elf_size_dynamic_sections): Remove pointer to struct
	bfd_elf_version_tree.  Updated.
	(bfd_elf_gc_mark_dynamic_ref_symbol): Check if a symbol is hidden
	by linker script.

	* linker.c (bfd_hide_sym_by_version): New.

	* bfd-in2.h: Regenerated.

include/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfdlink.h (bfd_link_info): Add version_info.

ld/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ldlang.c (lang_elf_version_info): Removed.
	(lang_register_vers_node): Replace lang_elf_version_info with
	link_info.version_info.
	(lang_add_vers_depend): Likewise.
	* pe-dll.c (process_def_file_and_drectve): Likewise.
	* emultempl/solaris2.em (elf_solaris2_before_allocation): Likewise.

	* ldlang.h (lang_elf_version_info): Removed.

	* plugin.c  (is_visible_from_outside): Check if symbol is hidden
	by version script.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
	Remove lang_elf_version_info.

ld/testsuite/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ld-elf/pr12975.d: New.
	* ld-elf/pr12975.s: Likewise.
	* ld-elf/pr12975.t: Likewise.
@
text
@d11692 9
a11700 4
  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && !h->root.u.def.section->gc_mark
      && !(h->root.u.def.section->owner->flags & DYNAMIC))
d11703 1
a11703 1
          (struct elf_gc_sweep_symbol_info *) data;
@


1.418
log
@	PR ld/12762
bfd/
	* bfd-in.h (struct bfd_section_already_linked): Forward declare.
	(_bfd_handle_already_linked): Declare.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Define as
	_bfd_coff_section_already_linked.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* cofflink.c (coff_link_add_symbols): Revert 2011-07-09 changes.
	* elf-bfd.h: Likewise.
	* libbfd-in.h: Likewise.
	* targets.c: Likewise.
	* linker.c (bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(_bfd_generic_section_already_linked): Likewise.  Call
	_bfd_handle_already_linked.
	(_bfd_handle_already_linked): New function, split out from..
	* elflink.c (_bfd_elf_section_already_linked): ..here.  Revert
	2011-07-09 changes.  Avoid unnecessary strcmp when matching
	already_linked_list entries.  Match plugin linkonce section.
	(section_signature): Delete.
	* coffgen.c (_bfd_coff_section_already_linked): New function.
	* libcoff-in.h (_bfd_coff_section_already_linked): Declare.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (section_already_linked): Revert 2011-07-09 changes.
	* plugin.c: Likewise.
	(asymbol_from_plugin_symbol): Create linkonce section for syms
	with comdat_key.
@
text
@a38 1
  struct bfd_elf_version_tree *verdefs;
d1822 3
a1824 2
      && (h->def_regular
	  || h->ref_regular))
d1826 1
a1826 5
      bfd_boolean hide;

      if (eif->verdefs == NULL
	  || (bfd_find_version_for_sym (eif->verdefs, h->root.root.string, &hide)
	      && !hide))
d1828 2
a1829 5
	  if (! bfd_elf_link_record_dynamic_symbol (eif->info, h))
	    {
	      eif->failed = TRUE;
	      return FALSE;
	    }
d1977 1
a1977 1
      for (t = sinfo->verdefs; t != NULL; t = t->next)
d2046 2
a2047 1
	  if (sinfo->verdefs != NULL && sinfo->verdefs->vernum == 0)
d2049 3
a2051 1
	  for (pp = &sinfo->verdefs; *pp != NULL; pp = &(*pp)->next)
d2077 1
a2077 1
  if (h->verinfo.vertree == NULL && sinfo->verdefs != NULL)
d2081 3
a2083 2
      h->verinfo.vertree = bfd_find_version_for_sym (sinfo->verdefs,
						 h->root.root.string, &hide);
d5493 1
a5493 2
			       asection **sinterpptr,
			       struct bfd_elf_version_tree *verdefs)
a5669 1
      eif.verdefs = verdefs;
d5685 1
a5685 1
      for (t = verdefs; t != NULL; t = t->next)
a5737 1
      asvinfo.verdefs = verdefs;
d5750 1
a5750 1
	  for (t = verdefs; t != NULL; t = t->next)
d5883 1
d5892 1
a5892 1
      verdefs = asvinfo.verdefs;
d11911 3
a11913 1
	      && ELF_ST_VISIBILITY (h->other) != STV_HIDDEN)))
@


1.417
log
@	PR ld/12762
bfd/
	* elflink.c (_bfd_elf_section_already_linked): Return matched
	status.  Remove COFF comdat section handling.
	* linker.c (_bfd_generic_section_already_linked): Return matched
	status.  Don't set SEC_GROUP in l_flags for plugin entries.
	(bfd_section_already_linked): Update prototype.
	* targets.c (_section_already_linked): Likewise.
	* elf-bfd.h (_bfd_elf_section_already_linked): Likewise.
	* libbfd-in.h (_bfd_generic_section_already_linked): Likewise.
	(_bfd_nolink_section_already_linked): Update.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* plugin.c (add_symbols): Exclude comdat_key symbols from symbol
	table if already seen.
@
text
@a12504 13
/* For a SHT_GROUP section, return the group signature.  For other
   sections, return the normal section name.  */

static const char *
section_signature (asection *sec)
{
  if ((sec->flags & SEC_GROUP) != 0
      && elf_next_in_group (sec) != NULL
      && elf_group_name (elf_next_in_group (sec)) != NULL)
    return elf_group_name (elf_next_in_group (sec));
  return sec->name;
}

d12507 1
a12507 1
				 struct already_linked *linked,
d12511 1
a12511 1
  const char *name, *p;
a12513 2
  asection *sec, *l_sec;
  bfd_boolean matched;
d12515 21
a12535 6
  p = name = linked->comdat_key;
  if (name)
    {
      sec = NULL;
      flags = SEC_GROUP | SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
    }
d12538 1
a12538 36
      sec = linked->u.sec;
      if (sec->output_section == bfd_abs_section_ptr)
	return FALSE;

      flags = sec->flags;

      /* Return if it isn't a linkonce section.  A comdat group section
	 also has SEC_LINK_ONCE set.  */
      if ((flags & SEC_LINK_ONCE) == 0)
	return FALSE;

      /* Don't put group member sections on our list of already linked
	 sections.  They are handled as a group via their group section.
	 */
      if (elf_sec_group (sec) != NULL)
	return FALSE;

      /* FIXME: When doing a relocatable link, we may have trouble
	 copying relocations in other sections that refer to local symbols
	 in the section being discarded.  Those relocations will have to
	 be converted somehow; as of this writing I'm not sure that any of
	 the backends handle that correctly.

	 It is tempting to instead not discard link once sections when
	 doing a relocatable link (technically, they should be discarded
	 whenever we are building constructors).  However, that fails,
	 because the linker winds up combining all the link once sections
	 into a single large link once section, which defeats the purpose
	 of having link once sections in the first place.

	 Also, not merging link once sections in a relocatable link
	 causes trouble for MIPS ELF, which relies on link once semantics
	 to handle the .reginfo section correctly.  */

      name = section_signature (sec);

d12540 2
a12541 3
	  && ((p = strchr (name + sizeof (".gnu.linkonce.") - 1, '.'))
	      != NULL))
	p++;
d12543 4
a12546 1
	p = name;
d12549 1
a12549 1
  already_linked_list = bfd_section_already_linked_table_lookup (p);
a12552 19
      flagword l_flags;
      bfd *l_owner;
      const char *l_name = l->linked.comdat_key;
      if (l_name)
	{
	  l_sec = NULL;
	  l_owner = l->linked.u.abfd;
	  l_flags = (SEC_GROUP
		     | SEC_LINK_ONCE
		     | SEC_LINK_DUPLICATES_DISCARD);
	}
      else
	{
	  l_sec = l->linked.u.sec;
	  l_owner = l_sec->owner;
	  l_flags = l_sec->flags;
	  l_name = section_signature (l_sec);
	}

d12554 9
a12562 3
	 sections and linkonce sections.  Match like sections.  */
      if ((flags & SEC_GROUP) == (l_flags & SEC_GROUP)
	  && strcmp (name, l_name) == 0)
d12566 4
a12569 1
	  switch (flags & SEC_LINK_DUPLICATES)
d12571 2
a12572 2
	    default:
	      abort ();
d12574 1
a12574 9
	    case SEC_LINK_DUPLICATES_DISCARD:
	      /* If we found an LTO IR match for this comdat group on
		 the first pass, replace it with the LTO output on the
		 second pass.  We can't simply choose real object
		 files over IR because the first pass may contain a
		 mix of LTO and normal objects and we must keep the
		 first match, be it IR or real.  */
	      if (info->loading_lto_outputs
		  && (l_owner->flags & BFD_PLUGIN) != 0)
d12576 7
a12582 2
		  l->linked = *linked;
		  return FALSE;
d12584 1
a12584 1
	      break;
d12586 3
a12588 5
	    case SEC_LINK_DUPLICATES_ONE_ONLY:
	      (*_bfd_error_handler)
		(_("%B: ignoring duplicate section `%A'"),
		 abfd, sec);
	      break;
d12590 5
a12594 9
	    case SEC_LINK_DUPLICATES_SAME_SIZE:
	      if (!sec || !l_sec)
		abort ();

	      if (sec->size != l_sec->size)
		(*_bfd_error_handler)
		  (_("%B: duplicate section `%A' has different size"),
		   abfd, sec);
	      break;
d12596 9
a12604 31
	    case SEC_LINK_DUPLICATES_SAME_CONTENTS:
	      if (!sec || !l_sec)
		abort ();

	      if (sec->size != l_sec->size)
		(*_bfd_error_handler)
		  (_("%B: duplicate section `%A' has different size"),
		   abfd, sec);
	      else if (sec->size != 0)
		{
		  bfd_byte *sec_contents, *l_sec_contents;

		  if (!bfd_malloc_and_get_section (abfd, sec, &sec_contents))
		    (*_bfd_error_handler)
		      (_("%B: warning: could not read contents of section `%A'"),
		       abfd, sec);
		  else if (!bfd_malloc_and_get_section (l_sec->owner, l_sec,
							&l_sec_contents))
		    (*_bfd_error_handler)
		      (_("%B: warning: could not read contents of section `%A'"),
		       l_sec->owner, l_sec);
		  else if (memcmp (sec_contents, l_sec_contents, sec->size) != 0)
		    (*_bfd_error_handler)
		      (_("%B: warning: duplicate section `%A' has different contents"),
		       abfd, sec);

		  if (sec_contents)
		    free (sec_contents);
		  if (l_sec_contents)
		    free (l_sec_contents);
		}
d12607 7
d12615 3
a12617 1
	  if (sec)
a12618 5
	      /* Set the output_section field so that lang_add_section
		 does not create a lang_input_section structure for this
		 section.  Since there might be a symbol in the section
		 being discarded, we must retain a pointer to the section
		 which we are really going to use.  */
d12620 2
a12621 18
	      sec->kept_section = l_sec;

	      if (flags & SEC_GROUP)
		{
		  asection *first = elf_next_in_group (sec);
		  asection *s = first;

		  while (s != NULL)
		    {
		      s->output_section = bfd_abs_section_ptr;
		      /* Record which group discards it.  */
		      s->kept_section = l_sec;
		      s = elf_next_in_group (s);
		      /* These lists are circular.  */
		      if (s == first)
			break;
		    }
		}
a12622 2

	  return TRUE;
a12623 7
    }

  matched = FALSE;
  if (sec)
    {
      /* A single member comdat group section may be discarded by a
	 linkonce section and vice versa.  */
d12625 16
a12640 1
      if ((flags & SEC_GROUP) != 0)
d12642 3
a12644 25
	  asection *first = elf_next_in_group (sec);

	  if (first != NULL && elf_next_in_group (first) == first)
	    /* Check this single member group against linkonce sections.  */
	    for (l = already_linked_list->entry; l != NULL; l = l->next)
	      {
		if (l->linked.comdat_key == NULL)
		  {
		    l_sec = l->linked.u.sec;

		    if ((l_sec->flags & SEC_GROUP) == 0
			&& bfd_coff_get_comdat_section (l_sec->owner,
							l_sec) == NULL
			&& bfd_elf_match_symbols_in_sections (l_sec,
							      first,
							      info))
		      {
			first->output_section = bfd_abs_section_ptr;
			first->kept_section = l_sec;
			sec->output_section = bfd_abs_section_ptr;
			matched = TRUE;
			break;
		      }
		  }
	      }
a12645 62
      else
	/* Check this linkonce section against single member groups.  */
	for (l = already_linked_list->entry; l != NULL; l = l->next)
	  {
	    if (l->linked.comdat_key == NULL)
	      {
		l_sec = l->linked.u.sec;

		if (l_sec->flags & SEC_GROUP)
		  {
		    asection *first = elf_next_in_group (l_sec);

		    if (first != NULL
			&& elf_next_in_group (first) == first
			&& bfd_elf_match_symbols_in_sections (first,
							      sec,
							      info))
		      {
			sec->output_section = bfd_abs_section_ptr;
			sec->kept_section = first;
			matched = TRUE;
			break;
		      }
		  }
	      }
	  }

      /* Do not complain on unresolved relocations in `.gnu.linkonce.r.F'
	 referencing its discarded `.gnu.linkonce.t.F' counterpart -
	 g++-3.4 specific as g++-4.x is using COMDAT groups (without the
	 `.gnu.linkonce' prefix) instead.  `.gnu.linkonce.r.*' were the
	 `.rodata' part of its matching `.gnu.linkonce.t.*'.  If
	 `.gnu.linkonce.r.F' is not discarded but its `.gnu.linkonce.t.F'
	 is discarded means we chose one-only `.gnu.linkonce.t.F' section
	 from a different bfd not requiring any `.gnu.linkonce.r.F'.
	 Thus `.gnu.linkonce.r.F' should be discarded.  The reverse order
	 cannot happen as there is never a bfd with only the
	 `.gnu.linkonce.r.F' section.  The order of sections in a bfd
	 does not matter as here were are looking only for cross-bfd
	 sections.  */

      if ((flags & SEC_GROUP) == 0
	  && CONST_STRNEQ (name, ".gnu.linkonce.r."))
	for (l = already_linked_list->entry; l != NULL; l = l->next)
	  {
	    if (l->linked.comdat_key == NULL)
	      {
		l_sec = l->linked.u.sec;

		if ((l_sec->flags & SEC_GROUP) == 0
		    && CONST_STRNEQ (l_sec->name, ".gnu.linkonce.t."))
		  {
		    if (abfd != l_sec->owner)
		      {
			sec->output_section = bfd_abs_section_ptr;
			matched = TRUE;
		      }
		    break;
		  }
	      }
	  }
    }
d12648 1
a12648 2
  if (! bfd_section_already_linked_table_insert (already_linked_list,
						 linked))
d12650 1
a12650 1
  return matched;
@


1.416
log
@	* elflink.c (_bfd_elf_fix_symbol_flags): Loop on indirect syms.
	(_bfd_elf_adjust_dynamic_symbol): Remove FIXME.
@
text
@d12518 1
a12518 1
void
d12528 1
d12540 1
a12540 1
	return;
d12547 1
a12547 1
	return;
d12553 1
a12553 1
	return;
a12585 1
      bfd_boolean l_coff_comdat_sec;
a12595 1
	  l_coff_comdat_sec = FALSE;
a12601 2
	  l_coff_comdat_sec
	    = !!bfd_coff_get_comdat_section (l_sec->owner, l_sec);
d12608 1
a12608 2
	  && strcmp (name, l_name) == 0
	  && !l_coff_comdat_sec)
d12628 1
a12628 1
		  return;
d12710 1
a12710 1
	  return;
d12714 1
d12742 1
d12768 1
d12801 4
a12804 1
		      sec->output_section = bfd_abs_section_ptr;
d12815 1
@


1.415
log
@Also skip BFD_PLUGIN when setting stack_flags.

2011-07-11  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12982
	* elflink.c (bfd_elf_size_dynamic_sections): Also skip BFD_PLUGIN
	when setting stack_flags.
@
text
@d2520 1
a2520 1
      if (h->root.type == bfd_link_hash_indirect)
d2624 2
a2625 4
      /* If we get to this point, we know there is an implicit
	 reference by a regular object file via the weak symbol H.
	 FIXME: Is this really true?  What if the traversal finds
	 H->U.WEAKDEF before it finds H?  */
d2628 2
@


1.414
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@d5528 2
a5529 1
	  if (inputobj->flags & (DYNAMIC | EXEC_P | BFD_LINKER_CREATED))
@


1.413
log
@	PR ld/12942
bfd/
	* elflink.c (elf_link_add_object_symbols): Use elf_discarded_section
	rather than kept_section to determine whether a symbol is from
	a discarded section.
	* cofflink.c (coff_link_add_symbols): Make symbols from discarded
	sections appear undefined.

	* elf-bfd.h (_bfd_elf_section_already_linked): Replace
	"asection *" with "struct already_linked *".
	* libbfd-in.h (_bfd_nolink_section_already_linked): Likewise.
	(_bfd_generic_section_already_linked): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(struct already_linked): New.
	(struct bfd_section_already_linked): Use it.
	* elflink.c (_bfd_elf_section_already_linked): Replace.
	"asection *" with "struct already_linked *".  Replace the plugin
	dummy with the LTO output.
	* linker.c (_bfd_generic_section_already_linked): Likewise.
	* targets.c (struct already_linked): Add forward declaration.
	(bfd_target): Replace "struct bfd_section *" with
	"struct already_linked *" in _section_already_linked.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

include/
	* bfdlink.h (bfd_link_info): Add loading_lto_outputs.

ld/
	* ldlang.c (section_already_linked): Pass "struct already_linked *"
	to bfd_section_already_linked.
	(lang_process): Set link_info.loading_lto_outputs before
	loading LTO outputs.
	* plugin.c: Include "libbfd.h".
	(add_symbols): Call bfd_section_already_linked with comdat_key.
@
text
@d12170 77
@


1.412
log
@	* elflink.c (_bfd_elf_merge_symbol): Allow type changes for
	plugin symbols.  Fix segfault on linker scrip defined syms.
@
text
@d3903 1
a3903 1
	  else if (sec->kept_section)
d12441 2
a12442 1
_bfd_elf_section_already_linked (bfd *abfd, asection *sec,
d12449 1
d12451 6
a12456 37
  if (sec->output_section == bfd_abs_section_ptr)
    return;

  flags = sec->flags;

  /* Return if it isn't a linkonce section.  A comdat group section
     also has SEC_LINK_ONCE set.  */
  if ((flags & SEC_LINK_ONCE) == 0)
    return;

  /* Don't put group member sections on our list of already linked
     sections.  They are handled as a group via their group section.  */
  if (elf_sec_group (sec) != NULL)
    return;

  /* FIXME: When doing a relocatable link, we may have trouble
     copying relocations in other sections that refer to local symbols
     in the section being discarded.  Those relocations will have to
     be converted somehow; as of this writing I'm not sure that any of
     the backends handle that correctly.

     It is tempting to instead not discard link once sections when
     doing a relocatable link (technically, they should be discarded
     whenever we are building constructors).  However, that fails,
     because the linker winds up combining all the link once sections
     into a single large link once section, which defeats the purpose
     of having link once sections in the first place.

     Also, not merging link once sections in a relocatable link
     causes trouble for MIPS ELF, which relies on link once semantics
     to handle the .reginfo section correctly.  */

  name = section_signature (sec);

  if (CONST_STRNEQ (name, ".gnu.linkonce.")
      && (p = strchr (name + sizeof (".gnu.linkonce.") - 1, '.')) != NULL)
    p++;
d12458 44
a12501 1
    p = name;
d12507 23
d12532 3
a12534 3
      if ((flags & SEC_GROUP) == (l->sec->flags & SEC_GROUP)
	  && strcmp (name, section_signature (l->sec)) == 0
	  && bfd_coff_get_comdat_section (l->sec->owner, l->sec) == NULL)
d12544 12
d12565 4
a12568 1
	      if (sec->size != l->sec->size)
d12575 4
a12578 1
	      if (sec->size != l->sec->size)
d12590 1
a12590 1
		  else if (!bfd_malloc_and_get_section (l->sec->owner, l->sec,
d12594 1
a12594 1
		       l->sec->owner, l->sec);
d12608 25
a12632 22
	  /* Set the output_section field so that lang_add_section
	     does not create a lang_input_section structure for this
	     section.  Since there might be a symbol in the section
	     being discarded, we must retain a pointer to the section
	     which we are really going to use.  */
	  sec->output_section = bfd_abs_section_ptr;
	  sec->kept_section = l->sec;

	  if (flags & SEC_GROUP)
	    {
	      asection *first = elf_next_in_group (sec);
	      asection *s = first;

	      while (s != NULL)
		{
		  s->output_section = bfd_abs_section_ptr;
		  /* Record which group discards it.  */
		  s->kept_section = l->sec;
		  s = elf_next_in_group (s);
		  /* These lists are circular.  */
		  if (s == first)
		    break;
d12640 16
a12655 2
  /* A single member comdat group section may be discarded by a
     linkonce section and vice versa.  */
d12657 54
a12710 3
  if ((flags & SEC_GROUP) != 0)
    {
      asection *first = elf_next_in_group (sec);
d12712 2
a12713 2
      if (first != NULL && elf_next_in_group (first) == first)
	/* Check this single member group against linkonce sections.  */
d12715 14
a12728 9
	  if ((l->sec->flags & SEC_GROUP) == 0
	      && bfd_coff_get_comdat_section (l->sec->owner, l->sec) == NULL
	      && bfd_elf_match_symbols_in_sections (l->sec, first, info))
	    {
	      first->output_section = bfd_abs_section_ptr;
	      first->kept_section = l->sec;
	      sec->output_section = bfd_abs_section_ptr;
	      break;
	    }
a12729 38
  else
    /* Check this linkonce section against single member groups.  */
    for (l = already_linked_list->entry; l != NULL; l = l->next)
      if (l->sec->flags & SEC_GROUP)
	{
	  asection *first = elf_next_in_group (l->sec);

	  if (first != NULL
	      && elf_next_in_group (first) == first
	      && bfd_elf_match_symbols_in_sections (first, sec, info))
	    {
	      sec->output_section = bfd_abs_section_ptr;
	      sec->kept_section = first;
	      break;
	    }
	}

  /* Do not complain on unresolved relocations in `.gnu.linkonce.r.F'
     referencing its discarded `.gnu.linkonce.t.F' counterpart - g++-3.4
     specific as g++-4.x is using COMDAT groups (without the `.gnu.linkonce'
     prefix) instead.  `.gnu.linkonce.r.*' were the `.rodata' part of its
     matching `.gnu.linkonce.t.*'.  If `.gnu.linkonce.r.F' is not discarded
     but its `.gnu.linkonce.t.F' is discarded means we chose one-only
     `.gnu.linkonce.t.F' section from a different bfd not requiring any
     `.gnu.linkonce.r.F'.  Thus `.gnu.linkonce.r.F' should be discarded.
     The reverse order cannot happen as there is never a bfd with only the
     `.gnu.linkonce.r.F' section.  The order of sections in a bfd does not
     matter as here were are looking only for cross-bfd sections.  */

  if ((flags & SEC_GROUP) == 0 && CONST_STRNEQ (name, ".gnu.linkonce.r."))
    for (l = already_linked_list->entry; l != NULL; l = l->next)
      if ((l->sec->flags & SEC_GROUP) == 0
	  && CONST_STRNEQ (l->sec->name, ".gnu.linkonce.t."))
	{
	  if (abfd != l->sec->owner)
	    sec->output_section = bfd_abs_section_ptr;
	  break;
	}
d12732 2
a12733 1
  if (! bfd_section_already_linked_table_insert (already_linked_list, sec))
@


1.411
log
@	PR ld/12851
	* elflink.c (_bfd_elf_gc_mark_extra_sections): New function.
	(elf_gc_sweep): Don't treat debug and sections like .comment
	specially here.
	(bfd_elf_gc_sections): Treat note sections as gc roots only when
	not part of a group.  Always call gc_mark_extra_sections.
	* elf-bfd.h (_bfd_elf_gc_mark_extra_sections): Declare.
	* elfxx-target.h (elf_backend_gc_mark_extra_sections): Default to
	_bfd_elf_gc_mark_extra_sections.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): Call
	_bfd_elf_gc_mark_extra_sections.
	* elf32-tic6x.c (elf32_tic6x_gc_mark_extra_sections): Likewise.
@
text
@d1083 4
d1089 3
a1091 3
  if ((ELF_ST_TYPE (sym->st_info) == STT_TLS || h->type == STT_TLS)
      && ELF_ST_TYPE (sym->st_info) != h->type
      && oldbfd != NULL)
d1430 2
a1431 1
      if (!((oldbfd->flags & BFD_PLUGIN) != 0
@


1.410
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d11636 43
a11735 6
	  else if ((o->flags & (SEC_DEBUGGING | SEC_LINKER_CREATED)) != 0
		   || (o->flags & (SEC_ALLOC | SEC_LOAD | SEC_RELOC)) == 0)
	    {
	      /* Keep debug and special sections.  */
	      o->gc_mark = 1;
	    }
d12006 3
a12008 1
      /* Also keep SHT_NOTE sections.  */
d12010 2
a12011 1
	if ((o->flags & SEC_EXCLUDE) == 0
d12013 6
a12018 4
		|| elf_section_data (o)->this_hdr.sh_type == SHT_NOTE)
	    && !o->gc_mark)
	  if (!_bfd_elf_gc_mark (info, o, gc_mark_hook))
	    return FALSE;
d12022 1
a12022 2
  if (bed->gc_mark_extra_sections)
    bed->gc_mark_extra_sections (info, gc_mark_hook);
@


1.409
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): If the
	backend does not provide a function for creating dynamic sections
	then fail.
	(bfd_elf_final_link): Issue a warning message if a dynamic section
	has the SHT_NOTE type.
	(bfd_elf_final_link): Do not look for dynamic strings in a section
	that does not have the SHT_STRTAB type or the name .dynstr.
	* elf32-arm.c (elf32_arm_finish_dynamic_sections): Fail if the got
	section is not in the output binary.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_sections): Likewise.

	* ld-elf/elf.exp: Add test for linking a shared library with a
	broken linker script that marks dynamic sections as being notes.
	* ld-elf/note-3.s: New test source file.
	* ld-elf/note-3.t: New test linker script.
	* ld-elf/note-3.l: Expected output from the linker.
	* lib/ld-lib.exp (run_ld_link_tests): Improve description.
@
text
@a724 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a743 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a1808 4
  /* Ignore this if we won't export it.  */
  if (!eif->info->export_dynamic && !h->dynamic)
    return TRUE;

d1813 3
a1815 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
a1851 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a1936 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a2551 11
  if (h->root.type == bfd_link_hash_warning)
    {
      h->got = elf_hash_table (eif->info)->init_got_offset;
      h->plt = elf_hash_table (eif->info)->init_plt_offset;

      /* When warning symbols are created, they **replace** the "real"
	 entry in the hash table, thus we never get to see the real
	 symbol in a hash traversal.  So look at it now.  */
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
    }

a2706 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a3153 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a5145 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a5213 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a5263 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

d8567 1
a8567 1
elf_link_output_extsym (struct elf_link_hash_entry *h, void *data)
d8569 1
d10785 1
a10785 2
  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
			  &eoinfo);
d10894 1
a10894 2
  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
			  &eoinfo);
a11647 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a11758 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a11819 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a11866 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a12138 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.408
log
@Check relocations in note sections for --gc-sections.

bfd/

2011-06-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12851
	* elflink.c (elf_gc_sweep): Don't check SHT_NOTE sections here.
	(bfd_elf_gc_sections): Also check SHT_NOTE sections.

ld/testsuite/

2011-06-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12851
	* ld-elf/pr12851.d: New.
	* ld-elf/pr12851.s: Likewise.
@
text
@d289 2
a290 1
  if (! (*bed->elf_backend_create_dynamic_sections) (abfd, info))
d11152 7
d11246 1
a11246 1
	      || strcmp (bfd_get_section_name (abfd, o), ".dynstr") != 0)
@


1.407
log
@	* elflink.c (_bfd_elf_archive_symbol_lookup): Follow warning and
	indirect links here.
@
text
@d11731 1
a11731 2
		   || (o->flags & (SEC_ALLOC | SEC_LOAD | SEC_RELOC)) == 0
		   || elf_section_data (o)->this_hdr.sh_type == SHT_NOTE)
d11733 1
a11733 1
	      /* Keep debug, special and SHT_NOTE sections.  */
d12015 1
d12017 4
a12020 1
	if ((o->flags & (SEC_EXCLUDE | SEC_KEEP)) == SEC_KEEP && !o->gc_mark)
@


1.406
log
@	* elf-bfd.h (SYMBOL_REFERENCES_LOCAL): Remove most of comment.
	* elflink.c (_bfd_elf_symbol_refs_local_p): Expand
	local_protected comment.
@
text
@d4914 1
a4914 1
  h = elf_link_hash_lookup (elf_hash_table (info), name, FALSE, FALSE, FALSE);
d4937 1
a4937 1
  h = elf_link_hash_lookup (elf_hash_table (info), copy, FALSE, FALSE, FALSE);
d4944 1
a4944 1
				FALSE, FALSE, FALSE);
@


1.405
log
@	PR ld/12761
	* elflink.c (elf_link_add_object_symbols): Process .gnu.warning
	sections when building shared libraries.

	* lib/ld-lib.exp (run_cc_link_tests): Add an optional 8th
	parameter - an expected warning message from the linker.
	* ld-elf/shared.exp (build_tests): Expect a warning message when
	building the libbarw.so library.

	* ld-elf/shared.exp: Run library building tests even when not
	building a native toolchain.
@
text
@d2884 4
a2887 2
     symbols be treated as dynamic symbols, even when we know that the
     dynamic linker will resolve them locally.  */
@


1.404
log
@	PR ld/12760
include/
	* bfdlink.h (struct bfd_link_callbacks <notice>): Add "flags" and
	"string" param.
bfd/
	* coff-aux.c (coff_m68k_aux_link_add_one_symbol): Adjust "notice" call.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
ld/
	* ldmain.c (notice): Add "flags" and "string" param.
	* plugin.c (plugin_notice): Likewise.  Handle indirect, warning
	and constructor syms.
@
text
@d3426 2
a3427 1
  if (info->executable)
@


1.403
log
@Reverse copy .ctors/.dtors sections if needed.

bfd/

2011-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12730
	* elf.c (_bfd_elf_section_offset): Check SEC_ELF_REVERSE_COPY.

	* elflink.c (elf_link_input_bfd): Reverse copy .ctors/.dtors
	sections if needed.

	* section.c (SEC_ELF_REVERSE_COPY): New.
	* bfd-in2.h: Regenerated.

ld/testsuite/

2011-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12730
	* ld-elf/elf.exp (array_tests): Add "pr12730".
	(array_tests_pie): New.
	(array_tests_static): Add -static for "static init array mixed".
	Add "static pr12730".  Run array_tests_pie for Linux.

	* ld-elf/init-mixed.c (ctor1007): Renamed to ...
	(ctor1007a): This.
	(ctor1007b): New.
	(ctors1007): Remove ctor1007.  Add ctor1007b and ctor1007a.
	(dtor1007): Renamed to ...
	(dtor1007a): This.
	(dtor1007b): New.
	(dtors1007): Remove dtor1007.  Add dtor1007b and dtor1007a.
	(ctor65535): Renamed to ...
	(ctor65535a): This.
	(ctor65535b): New.
	(ctors65535): Remove ctor65535.  Add ctor65535b and ctor65535a.
	(dtor65535): Renamed to ...
	(dtor65535a): This.
	(dtor65535b): New.
	(dtors65535): Remove dtor65535.  Add dtor65535b and dtor65535a.

	* ld-elf/pr12730.cc: New.
	* ld-elf/pr12730.out: Likewise.
@
text
@d3817 1
a3817 1
				       notice_as_needed))
d4564 1
a4564 1
				       notice_not_needed))
d4578 1
a4578 1
				       notice_needed))
@


1.402
log
@	PR ld/12365
	PR ld/12696
include/
	* bfdlink.h (ENUM_BITFIELD): Define.
	(struct bfd_link_hash_entry): Make "type" a bitfield.  Add "non_ir_ref".
	(struct bfd_link_callbacks <notice>): Pass bfd_link_hash_entry pointer
	rather than "name".
bfd/
	* coff-aux.c (coff_m68k_aux_link_add_one_symbol): Update "notice" call.
	* linker.c (_bfd_link_hash_newfunc): Clear bitfields.
	(_bfd_generic_link_add_one_symbol): Update "notice" call.
	* elflink.c (_bfd_elf_merge_symbol): Don't skip weak redefs when
	it is a redef of an IR symbol in a real BFD.
ld/
	* ldmain.c (notice): Delete "name" param, add "h".
	* plugin.c (plugin_notice): Likewise.  Set non_ir_ref.  Handle
	redefinitions of IR symbols in real BFDs.
	(plugin_multiple_definition, plugin_multiple_common): Delete.
	(non_ironly_hash, init_non_ironly_hash): Delete.
	(is_visible_from_outside): Traverse entry_symbol chain.
	(get_symbols): Use non_ir_ref flag rather than hash lookup.
@
text
@d9123 3
d9296 13
a9412 2
	  bfd_vma r_type_mask;
	  int r_sym_shift;
d9424 10
a9433 1
	  if (bed->s->arch_size == 32)
d9435 10
a9444 7
	      r_type_mask = 0xff;
	      r_sym_shift = 8;
	    }
	  else
	    {
	      r_type_mask = 0xffffffff;
	      r_sym_shift = 32;
d9905 28
a9932 6
	    if (! (o->flags & SEC_EXCLUDE)
		&& ! bfd_set_section_contents (output_bfd, o->output_section,
					       contents,
					       (file_ptr) o->output_offset,
					       o->size))
	      return FALSE;
@


1.401
log
@	* libbfd.c (bfd_log2): Do return rounded up value.
	* elflink.c (bfd_elf_size_dynsym_hash_dynstr): Replace bfd_log2
	call with expanded old round down version of the function.
@
text
@d1430 4
a1433 1
      *skip = TRUE;
@


1.400
log
@	* archive.c (_bfd_get_elt_at_filepos): Don't release n_nfd.
	* elflink.c (elf_link_add_object_symbols): Delete redundant code.
@
text
@d6540 1
a6540 1
	      unsigned long int maskwords, maskbitslog2;
d6543 4
a6546 1
	      maskbitslog2 = bfd_log2 (cinfo.nsyms) + 1;
@


1.399
log
@	PR ld/12365
bfd/
	* elfcode.h (elf_slurp_symbol_table): Put common plugin IR symbols
	in their own common section.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Don't lose flags
	if common section is pre-existing.
	(_bfd_generic_link_add_one_symbol): Likewise.
ld/
	* ldfile.c (ldfile_try_open_bfd): Move code creating and switching
	to plugin IR BFD..
	* ldmain.c (add_archive_element): ..and similar code here..
	* plugin.c (plugin_maybe_claim): ..to here.  New function.
	(plugin_call_claim_file): Make static.
	(asymbol_from_plugin_symbol): Set ELF st_shndx for common syms.
	(plugin_multiple_common): New function.
	(plugin_call_all_symbols_read): Hook in plugin_multiple_common.
	* plugin.h (plugin_call_claim_file): Don't declare.
	(plugin_maybe_claim): Declare.
@
text
@d4240 1
a4240 4
	  if (align > old_alignment
	      /* Permit an alignment power of zero if an alignment of one
		 is specified and no other alignments have been specified.  */
	      || (isym->st_value == 1 && old_alignment == 0))
@


1.398
log
@	PR ld/12365
include/
	* bfdlink.h (struct bfd_link_callbacks): Modify multiple_definition
	and multiple_common parameters to pass in a bfd_link_hash_entry
	pointer rather than name,bfd etc. found in the hash entry.
bfd/
	* elflink.c (_bfd_elf_merge_symbol): Update multiple_common calls.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.  Call
	multiple_definition regardless of allow_multiple_definition.
	* simple.c (simple_dummy_multiple_definition): Update.
	* xcofflink.c (xcoff_link_add_symbols): Update multiple_definition
	calls.
ld/
	* ldmain.c (multiple_definition): Take a bfd_link_hash_entry
	pointer arg rather than "name", "obfd", "osec", "oval".  Add code
	removed from linker.c.  Hack around xcofflink.c oddity in
	passing NULL nbfd.
	(multiple_common): Similarly.
	* plugin.c (orig_allow_multiple_defs): Delete.
	(plugin_call_all_symbols_read): Don't twiddle allow_multiple_definition.
	(plugin_multiple_definition): Update.
@
text
@d3940 17
a3956 2
	  && ELF_ST_TYPE (isym->st_info) == STT_TLS
	  && !info->relocatable)
d3962 3
a3964 5
	      tcomm = bfd_make_section_with_flags (abfd, ".tcommon",
						   (SEC_ALLOC
						    | SEC_IS_COMMON
						    | SEC_LINKER_CREATED
						    | SEC_THREAD_LOCAL));
@


1.397
log
@	PR ld/12365
	PR ld/12672
bfd/
	* bfd.c (BFD_PLUGIN): Define.
	(BFD_FLAGS_SAVED, BFD_FLAGS_FOR_BFD_USE_MASK): Add BFD_PLUGIN.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_output_extsym): Strip undefined plugin syms.
	* opncls.c (bfd_make_readable): Don't lose original bfd flags.
ld/
	* ldfile.c (ldfile_try_open_bfd): Don't attempt any plugin action
	when no_more_claiming.
	* ldmain.c (add_archive_element): Likewise.
	(multiple_definition): Remove plugin_multiple_definition call.
	(notice): Remove plugin_notice call.
	* ldlang.c (lang_list_insert_after, void lang_list_remove_tail): Move.
	Delete prototype.
	(plugin_insert): New static var.
	(open_input_bfds): Only rescan libs after plugin insert point.
	(lang_gc_sections): Omit plugin claimed files.
	(lang_process): Set plugin_insert.  Only rescan when plugin adds
	objects.
	* plugin.h (no_more_claiming): Declare.
	(plugin_notice, plugin_multiple_definition): Don't declare.
	* plugin.c: Formatting.
	(orig_notice_all, orig_allow_multiple_defs, orig_callbacks,
	plugin_callbacks): New static vars.
	(no_more_claiming): Make global.
	(plugin_cached_allow_multiple_defs): Delete.
	(plugin_get_ir_dummy_bfd): Set SEC_EXCLUDE on dummy .text section,
	use newer bfd_make_section variant.  Make COMMON section too.
	Error handling.  Correct setting of gp size.
	(asymbol_from_plugin_symbol): Properly cast last arg of concat.
	(message): Likewise for ACONCAT.
	(asymbol_from_plugin_symbol): Use our COMMON section.
	(get_symbols): When report_plugin_symbols, show visibility too.
	(init_non_ironly_hash): Move.  Don't test non_ironly_hash.
	(plugin_load_plugins): Save state of linker callbacks, set up to
	call plugin_notice instead.  Call init_non_ironly_hash here.
	(plugin_call_all_symbols_read): Set plugin_multiple_definition in
	plugin callbacks.
	(plugin_notice): Rewrite.
	(plugin_multiple_definition): Make static, call original callback.
ld/testsuite/
	* ld-plugin/plugin-7.d: Adjust for plugin changes.
	* ld-plugin/plugin-8.d: Likewise.
	* ld-plugin/plugin.exp: Pass --verbose=2 for visibility test, and
	compare ld output to..
	* ld-plugin/plugin-12.d: New.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009, 2010
d1364 1
a1364 2
	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
d1515 1
a1515 2
	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
@


1.396
log
@include/elf/
	* internal.h (elf_internal_sym): Add st_target_internal.
	* arm.h (arm_st_branch_type): New enum.
	(ARM_SYM_BRANCH_TYPE): New macro.

bfd/
	* elf-bfd.h (elf_link_hash_entry): Add target_internal.
	* elf.c (swap_out_syms): Set st_target_internal for each
	Elf_Internal_Sym.
	* elfcode.h (elf_swap_symbol_in): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Likewise.
	* elf32-sh-symbian.c (sh_symbian_relocate_section): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* elflink.c (elf_link_output_extsym): Likewise.
	(bfd_elf_final_link): Likewise.
	(elf_link_add_object_symbols): Copy st_target_internal
	to the hash table if we see a definition.
	(_bfd_elf_copy_link_hash_symbol_type): Copy target_internal.
	* elf32-arm.c (elf32_arm_stub_hash_entry): Replace st_type with
	a branch_type field.
	(a8_erratum_fix, a8_erratum_reloc): Likewise.
	(arm_type_of_stub): Replace actual_st_type with an
	actual_branch_type parameter.
	(arm_build_one_stub): Use branch types rather than st_types to
	determine the type of branch.
	(cortex_a8_erratum_scan): Likewise.
	(elf32_arm_size_stubs): Likewise.
	(bfd_elf32_arm_process_before_allocation): Likewise.
	(allocate_dynrelocs_for_symbol): Likewise.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf32_arm_final_link_relocate): Replace sym_flags parameter with
	a branch_type parameter.
	(elf32_arm_relocate_section): Update call accordingly.
	(elf32_arm_adjust_dynamic_symbol): Don't check STT_ARM_TFUNC.
	(elf32_arm_output_map_sym): Initialize st_target_internal.
	(elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_symbol_processing): Delete.
	(elf32_arm_swap_symbol_in): Convert STT_ARM_TFUNCs into STT_FUNCs.
	Use st_target_internal to record the branch type.
	(elf32_arm_swap_symbol_out): Use st_target_internal to test for
	Thumb functions.
	(elf32_arm_is_function_type): Delete.
	(elf_backend_symbol_processing): Likewise.
	(elf_backend_is_function_type): Likewise.

gas/
	* config/tc-arm.c (arm_adjust_symtab): Set the branch type
	for Thumb symbols.

ld/
	* emultempl/armelf.em (gld${EMULATION_NAME}_finish): Check
	eh->target_internal.

opcodes/
	* arm-dis.c (get_sym_code_type): Don't check for STT_ARM_TFUNC.
	Use branch types instead.
	(print_insn): Likewise.
@
text
@d8707 5
@


1.395
log
@	* elflink.c (is_reloc_section): Remove function.
	(get_dynamic_reloc_section_name): Construct string manually.
@
text
@d4399 3
d8735 1
d10527 1
d10545 1
d10796 1
d12715 1
@


1.394
log
@bfd/ld: handle ABI prefixes in version scripts

The default language in version scripts is supposed to be C, but no
symbol demangling is performed on the symbols by default.  This makes
targets with a symbol prefix to fail with most version scripts out
there.  So strip away this prefix by default.

This fixes many tests (real world and ld's testsuite) for Blackfin
targets and doesn't seem to cause regressions for x86_64.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@a12599 14
/* Return true if NAME is a name of a relocation
   section associated with section S.  */

static bfd_boolean
is_reloc_section (bfd_boolean rela, const char * name, asection * s)
{
  if (rela)
    return CONST_STRNEQ (name, ".rela")
      && strcmp (bfd_get_section_name (NULL, s), name + 5) == 0;

  return CONST_STRNEQ (name, ".rel")
    && strcmp (bfd_get_section_name (NULL, s), name + 4) == 0;
}

d12607 3
a12609 3
  const char * name;
  unsigned int strndx = elf_elfheader (abfd)->e_shstrndx;
  unsigned int shnam = _bfd_elf_single_rel_hdr (sec)->sh_name;
d12611 1
a12611 2
  name = bfd_elf_string_from_elf_section (abfd, strndx, shnam);
  if (name == NULL)
d12614 2
a12615 12
  if (! is_reloc_section (is_rela, name, sec))
    {
      static bfd_boolean complained = FALSE;

      if (! complained)
	{
	  (*_bfd_error_handler)
	    (_("%B: bad relocation section name `%s\'"),  abfd, name);
	  complained = TRUE;
	}
      name = NULL;
    }
@


1.393
log
@Move elfXX_r_info/elfXX_r_sym to elfcode.h.

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfcode.h (NAME(elf,r_info)): New.
	(NAME(elf,r_sym)): Likewise.

	* elflink.c (elf64_r_info): Removed.
	(elf32_r_info): Likewise.
	(elf64_r_sym): Likewise.
	(elf32_r_sym): Likewise.
@
text
@d5713 1
a5713 1
	      char *newname, *p;
d5716 1
d5718 1
a5718 1
	      namelen = strlen (name);
d5726 2
a5727 1
	      memcpy (newname, name, namelen);
@


1.392
log
@Add x86-64 ILP32 support.

bfd/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* archures.c (bfd_mach_x64_32): New.
	(bfd_mach_x64_32_intel_syntax): Likewise.
	* bfd-in2.h: Regenerated.

	* config.bfd (targ64_selvecs): Add bfd_elf32_x86_64_vec for
	i[3-7]86-*-linux-*.
	(targ_selvecs): Add bfd_elf32_x86_64_vec for x86_64-*-linux-*.

	* configure.in: Support bfd_elf32_x86_64_vec.
	* configure: Regenerated.

	* cpu-i386.c (bfd_x64_32_arch_intel_syntax): New.
	(bfd_x64_32_arch): Likewise.

	* elf-bfd.h (elf_append_rela): New prototype.
	(elf_append_rel): Likewise.
	(elf64_r_info): Likewise.
	(elf32_r_info): Likewise.
	(elf64_r_sym): Likewise.
	(elf32_r_sym): Likewise.

	* elf64-x86-64.c (ABI_64_P): New.
	(elf_x86_64_info_to_howto): Replace ELF64_R_TYPE with
	ELF32_R_TYPE.  Replace ELF64_ST_TYPE with ELF_ST_TYPE.
	(elf_x86_64_check_tls_transition):Likewise.
	(elf_x86_64_check_relocs): Likewise.
	(elf_x86_64_gc_mark_hook):Likewise.
	(elf_x86_64_gc_sweep_hook): Likewise.
	(elf_x86_64_relocate_section): Likewise.
	(elf_x86_64_reloc_type_class): Likewise.
	(ELF_DYNAMIC_INTERPRETER): Renamed to ...
	(ELF64_DYNAMIC_INTERPRETER): This.
	(ELF32_DYNAMIC_INTERPRETER): New.
	(elf_x86_64_link_hash_table): Add r_info, r_sym, swap_reloca_out,
	dynamic_interpreter and dynamic_interpreter_size.
	(elf_x86_64_get_local_sym_hash): Replace ELF64_R_SYM with
	htab->r_sym.  Replace ELF64_R_INFO with htab->r_info.
	(elf_x86_64_get_local_sym_hash): Likewise.
	(elf_x86_64_check_tls_transition):Likewise.
	(elf_x86_64_check_relocs): Likewise.
	(elf_x86_64_gc_mark_hook):Likewise.
	(elf_x86_64_gc_sweep_hook): Likewise.
	(elf_x86_64_relocate_section): Likewise.
	(elf_x86_64_finish_dynamic_symbol): Likewise.
	(elf_x86_64_finish_local_dynamic_symbol): Likewise.
	(elf_x86_64_link_hash_table_create): Initialize r_info, r_sym,
	swap_reloca_out, dynamic_interpreter and dynamic_interpreter_size.
	(elf_x86_64_check_relocs): Check ABI_64_P when requesting for
	PIC.
	(elf_x86_64_relocate_section): Likewise.
	(elf64_x86_64_adjust_dynamic_symbol): Replace sizeof
	(Elf64_External_Rela) with bed->s->sizeof_rela.
	(elf64_x86_64_allocate_dynrelocs): Likewise.
	(elf64_x86_64_size_dynamic_sections): Likewise.
	(elf64_x86_64_finish_dynamic_symbol): Likewise.
	(elf64_x86_64_append_rela): Removed.
	(elf32_x86_64_elf_object_p): New.
	Add bfd_elf32_x86_64_vec.

	* elf64-x86-64.c (elf64_x86_64_xxx): Renamed to ...
	(elf_x86_64_xxx): This.

	* elflink.c (bfd_elf_final_link): Check ELF file class on error.
	(elf_append_rela): New.
	(elf_append_rel): Likewise.
	(elf64_r_info): Likewise.
	(elf32_r_info): Likewise.
	(elf64_r_sym): Likewise.
	(elf32_r_sym): Likewise.

	* targets.c (bfd_elf32_x86_64_vec): New.
	(_bfd_target_vector): Add bfd_elf32_x86_64_vec.

gas/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (x86_elf_abi): New.
	(i386_mach): Return bfd_mach_x64_32 for ILP32.
	(OPTION_N32): Likewise.
	(md_longopts): Add "n32" for ELF.
	(md_parse_option): Handle OPTION_N32.
	(md_show_usage): Add --n32.
	(i386_target_format): Update and check x86_elf_abi.

	* config/tc-i386.h (ELF_TARGET_FORMAT32): New.

	* doc/as.texinfo: Document --n32.
	* doc/c-i386.texi: Likewise.

gas/testsuite/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/ilp32/lns/ilp32.exp: New.
	* gas/i386/ilp32/lns/lns-common-1.d: Likewise.
	* gas/i386/ilp32/lns/lns-duplicate.d: Likewise.

	* gas/i386/ilp32/cfi/cfi-common-1.d: New.
	* gas/i386/ilp32/cfi/cfi-common-2.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-3.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-4.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-5.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-6.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-7.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-x86_64.d: Likewise.
	* gas/i386/ilp32/cfi/ilp32.exp: Likewise.
	* gas/i386/ilp32/elf/ehopt0.d: Likewise.
	* gas/i386/ilp32/elf/equ-reloc.d: Likewise.
	* gas/i386/ilp32/elf/file.d: Likewise.
	* gas/i386/ilp32/elf/group0a.d: Likewise.
	* gas/i386/ilp32/elf/group0b.d: Likewise.
	* gas/i386/ilp32/elf/group1a.d: Likewise.
	* gas/i386/ilp32/elf/group1b.d: Likewise.
	* gas/i386/ilp32/elf/ifunc-1.d: Likewise.
	* gas/i386/ilp32/elf/ilp32.exp: Likewise.
	* gas/i386/ilp32/elf/redef.d: Likewise.
	* gas/i386/ilp32/elf/section0.d: Likewise.
	* gas/i386/ilp32/elf/section1.d: Likewise.
	* gas/i386/ilp32/elf/section3.d: Likewise.
	* gas/i386/ilp32/elf/section4.d: Likewise.
	* gas/i386/ilp32/elf/section6.d: Likewise.
	* gas/i386/ilp32/elf/section7.d: Likewise.
	* gas/i386/ilp32/elf/struct.d: Likewise.
	* gas/i386/ilp32/elf/symtab.d: Likewise.
	* gas/i386/ilp32/elf/symver.d: Likewise.

	* gas/i386/ilp32/ilp32.exp: New.
	* gas/i386/ilp32/immed64.d: Likewise.
	* gas/i386/ilp32/mixed-mode-reloc64.d: Likewise.
	* gas/i386/ilp32/reloc64.d: Likewise.
	* gas/i386/ilp32/rex.d: Likewise.
	* gas/i386/ilp32/rexw.d: Likewise.
	* gas/i386/ilp32/svme64.d: Likewise.
	* gas/i386/ilp32/x86-64-addr32.d: Likewise.
	* gas/i386/ilp32/x86-64-addr32-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-aes.d: Likewise.
	* gas/i386/ilp32/x86-64-aes-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-amdfam10.d: Likewise.
	* gas/i386/ilp32/x86-64-arch-1.d: Likewise.
	* gas/i386/ilp32/x86-64-arch-2.d: Likewise.
	* gas/i386/ilp32/x86-64-avx.d: Likewise.
	* gas/i386/ilp32/x86-64-avx-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-avx-swap.d: Likewise.
	* gas/i386/ilp32/x86-64-avx-swap-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-branch.d: Likewise.
	* gas/i386/ilp32/x86-64-cbw.d: Likewise.
	* gas/i386/ilp32/x86-64-cbw-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-clmul.d: Likewise.
	* gas/i386/ilp32/x86-64-clmul-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-crc32.d: Likewise.
	* gas/i386/ilp32/x86-64-crc32-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-crx.d: Likewise.
	* gas/i386/ilp32/x86-64-crx-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64.d: Likewise.
	* gas/i386/ilp32/x86-64-disp.d: Likewise.
	* gas/i386/ilp32/x86-64-disp-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-drx.d: Likewise.
	* gas/i386/ilp32/x86-64-drx-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-ept.d: Likewise.
	* gas/i386/ilp32/x86-64-ept-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-fma4.d: Likewise.
	* gas/i386/ilp32/x86-64-fma.d: Likewise.
	* gas/i386/ilp32/x86-64-fma-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-gidt.d: Likewise.
	* gas/i386/ilp32/x86-64-ifunc.d: Likewise.
	* gas/i386/ilp32/x86-64-intel64.d: Likewise.
	* gas/i386/ilp32/x86-64-io.d: Likewise.
	* gas/i386/ilp32/x86-64-io-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-io-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-localpic.d: Likewise.
	* gas/i386/ilp32/x86-64-mem.d: Likewise.
	* gas/i386/ilp32/x86-64-mem-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-movbe.d: Likewise.
	* gas/i386/ilp32/x86-64-movbe-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-core2.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-k8.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-nocona.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-pentium.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-2.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-3.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-4-core2.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-4.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-4-k8.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-5.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-5-k8.d: Likewise.
	* gas/i386/ilp32/x86-64-nops.d: Likewise.
	* gas/i386/ilp32/x86-64-opcode.d: Likewise.
	* gas/i386/ilp32/x86-64-opcode-inval.d: Likewise.
	* gas/i386/ilp32/x86-64-opcode-inval-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-opts.d: Likewise.
	* gas/i386/ilp32/x86-64-opts-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-pcrel.d: Likewise.
	* gas/i386/ilp32/x86-64-reg.d: Likewise.
	* gas/i386/ilp32/x86-64-reg-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-rep.d: Likewise.
	* gas/i386/ilp32/x86-64-rep-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-rip.d: Likewise.
	* gas/i386/ilp32/x86-64-rip-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sib.d: Likewise.
	* gas/i386/ilp32/x86-64-sib-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-simd.d: Likewise.
	* gas/i386/ilp32/x86-64-simd-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-simd-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-sse2avx.d: Likewise.
	* gas/i386/ilp32/x86-64-sse2avx-opts.d: Likewise.
	* gas/i386/ilp32/x86-64-sse2avx-opts-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sse3.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_1.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_1-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_2.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_2-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-check.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-check-none.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-check-warn.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-noavx.d: Likewise.
	* gas/i386/ilp32/x86-64-ssse3.d: Likewise.
	* gas/i386/ilp32/x86-64-stack.d: Likewise.
	* gas/i386/ilp32/x86-64-stack-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-stack-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-unwind.d: Likewise.
	* gas/i386/ilp32/x86-64-vmx.d: Likewise.
	* gas/i386/ilp32/x86-64-xsave.d: Likewise.
	* gas/i386/ilp32/x86-64-xsave-intel.d: Likewise.

ld/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/elf32_x86_64.sh: New.

	* configure.tgt (targ64_extra_emuls): Add elf32_x86_64 for
	i[3-7]86-*-linux-*.
	(targ_extra_libpath): Likewise.
	(targ_extra_emuls): Add elf32_x86_64 for x86_64-*-linux-*.
	(targ_extra_libpath): Likewise.

	* Makefile.am (ALL_64_EMULATION_SOURCES): Add eelf32_x86_64.c.
	(eelf32_x86_64.c): New.
	* Makefile.in: Regenerated.

opcodes/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (print_insn): Support bfd_mach_x64_32 and
	bfd_mach_x64_32_intel_syntax.
@
text
@a12753 32

/* Function for ELF64_R_INFO.  */

bfd_vma
elf64_r_info (bfd_vma sym, bfd_vma type)
{
  return ELF64_R_INFO (sym, type);
}

/* Function for ELF32_R_INFO.  */

bfd_vma
elf32_r_info (bfd_vma sym, bfd_vma type)
{
  return ELF32_R_INFO (sym, type);
}

/* Function for ELF64_R_SYM .  */

bfd_vma
elf64_r_sym (bfd_vma r_info)
{
  return ELF64_R_SYM (r_info);
}

/* Function for ELF32_R_SYM .  */

bfd_vma
elf32_r_sym (bfd_vma r_info)
{
  return ELF32_R_SYM (r_info);
}
@


1.391
log
@	* aoutx.h (aout_link_check_ar_symbols): Formatting.
	* cofflink.c (coff_link_check_ar_symbols): Likewise.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols,
	xcoff_link_check_dynamic_ar_symbols): Likewise.

	* aoutx.h (aout_link_check_archive_element): Simplify code dealing
	with add_archive_element substitute BFD.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* ecoff.c (ecoff_link_check_archive_element): Likewise.
	(ecoff_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.

	* aoutx.h (aout_link_check_archive_element): Free symbols from old
	bfd if !keep_memory.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.
@
text
@d10693 28
a10720 1
		goto error_return;
d12732 54
@


1.390
log
@Optimize for add_archive_element.

bfd/

2010-12-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_link_add_archive_symbols): Remove subsbfd.

ld/

2010-12-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (load_symbols): Optimize for add_archive_element.
@
text
@d5076 2
a5077 2
	  if (! (*info->callbacks->add_archive_element)
				(info, element, symdef->name, &element))
d5079 1
a5079 1
	  if (! bfd_link_add_symbols (element, info))
@


1.389
log
@	PR ld/12277
	* elflink.c (elf_link_output_extsym): Set bfd_error on symbol
	and section errors.  Allow better translation of error messages.
@
text
@a5013 1
	  bfd *subsbfd = NULL;
d5077 1
a5077 1
				(info, element, symdef->name, &subsbfd))
d5079 1
a5079 3
	  /* Potentially, the add_archive_element hook may have set a
	     substitute BFD for us.  */
	  if (! bfd_link_add_symbols (subsbfd ? subsbfd : element, info))
@


1.388
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@d8646 1
d8663 15
a8677 10
      (*_bfd_error_handler)
	(_("%B: %s symbol `%s' in %B is referenced by DSO"),
	 finfo->output_bfd,
	 h->root.u.def.section == bfd_abs_section_ptr
	 ? finfo->output_bfd : h->root.u.def.section->owner,
	 ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	 ? "internal"
	 : ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	 ? "hidden" : "local",
	 h->root.root.string);
d8762 1
d8880 10
a8889 8
      (*_bfd_error_handler)
	(_("%B: %s symbol `%s' isn't defined"),
	 finfo->output_bfd,
	 ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED
	 ? "protected"
	 : ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL
	 ? "internal" : "hidden",
	 h->root.root.string);
@


1.388.2.1
log
@backport from mainline
@
text
@d5014 1
d5077 2
a5078 2
	  if (!(*info->callbacks
		->add_archive_element) (info, element, symdef->name, &element))
d5080 3
a5082 1
	  if (!bfd_link_add_symbols (element, info))
a8645 1
	      bfd_set_error (bfd_error_bad_value);
d8662 10
a8671 15
      bfd *def_bfd;
      const char *msg;

      if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL)
	msg = _("%B: internal symbol `%s' in %B is referenced by DSO");
      else if (ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
	msg = _("%B: hidden symbol `%s' in %B is referenced by DSO");
      else
	msg = _("%B: local symbol `%s' in %B is referenced by DSO");
      def_bfd = finfo->output_bfd;
      if (h->root.u.def.section != bfd_abs_section_ptr)
	def_bfd = h->root.u.def.section->owner;
      (*_bfd_error_handler) (msg, finfo->output_bfd, def_bfd,
			     h->root.root.string);
      bfd_set_error (bfd_error_bad_value);
a8755 1
		bfd_set_error (bfd_error_nonrepresentable_section);
d8873 8
a8880 10
      const char *msg;

      if (ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED)
	msg = _("%B: protected symbol `%s' isn't defined");
      else if (ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL)
	msg = _("%B: internal symbol `%s' isn't defined");
      else
	msg = _("%B: hidden symbol `%s' isn't defined");
      (*_bfd_error_handler) (msg, finfo->output_bfd, h->root.root.string);
      bfd_set_error (bfd_error_bad_value);
@


1.388.2.2
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@d1364 2
a1365 1
	     (info, &h->root, abfd, bfd_link_hash_common, sym->st_size)))
d1431 1
a1431 4
      /* Don't skip new non-IR weak syms.  */
      if (!((oldbfd->flags & BFD_PLUGIN) != 0
	    && (abfd->flags & BFD_PLUGIN) == 0))
	*skip = TRUE;
d1516 2
a1517 1
	     (info, &h->root, abfd, bfd_link_hash_common, sym->st_size)))
d3942 2
a3943 17
	  && (abfd->flags & BFD_PLUGIN) != 0)
	{
	  asection *xc = bfd_get_section_by_name (abfd, "COMMON");

	  if (xc == NULL)
	    {
	      flagword sflags = (SEC_ALLOC | SEC_IS_COMMON | SEC_KEEP
				 | SEC_EXCLUDE);
	      xc = bfd_make_section_with_flags (abfd, "COMMON", sflags);
	      if (xc == NULL)
		goto error_free_vers;
	    }
	  sec = xc;
	}
      else if (isym->st_shndx == SHN_COMMON
	       && ELF_ST_TYPE (isym->st_info) == STT_TLS
	       && !info->relocatable)
d3949 5
a3953 3
	      flagword sflags = (SEC_ALLOC | SEC_THREAD_LOCAL | SEC_IS_COMMON
				 | SEC_LINKER_CREATED);
	      tcomm = bfd_make_section_with_flags (abfd, ".tcommon", sflags);
a8701 5
  else if ((h->root.type == bfd_link_hash_undefined
	    || h->root.type == bfd_link_hash_undefweak)
	   && h->root.u.undef.abfd != NULL
	   && (h->root.u.undef.abfd->flags & BFD_PLUGIN) != 0)
    strip = TRUE;
@


1.388.2.3
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d2884 2
a2885 4
     symbols be treated as dynamic symbols.  If the address of a
     function not defined in an executable is set to that function's
     plt entry in the executable, then the address of the function in
     a shared library must also be the plt entry in the executable.  */
d3817 1
a3817 1
				       notice_as_needed, 0, NULL))
d4243 4
a4246 1
	  if (align > old_alignment)
d4564 1
a4564 1
				       notice_not_needed, 0, NULL))
d4578 1
a4578 1
				       notice_needed, 0, NULL))
d5727 1
a5727 1
	      char *newname, *p, leading_char;
a5729 1
	      leading_char = bfd_get_symbol_leading_char (output_bfd);
d5731 1
a5731 1
	      namelen = strlen (name) + (leading_char != '\0');
d5739 1
a5739 2
	      newname[0] = leading_char;
	      memcpy (newname + (leading_char != '\0'), name, namelen);
d6541 1
a6541 1
	      unsigned long int maskwords, maskbitslog2, x;
d6544 1
a6544 4
	      x = cinfo.nsyms;
	      maskbitslog2 = 1;
	      while ((x >>= 1) != 0)
		++maskbitslog2;
@


1.388.2.4
log
@	* elflink.c (_bfd_elf_merge_symbol): Allow type changes for
	plugin symbols.  Fix segfault on linker scrip defined syms.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011
a1087 4
  /* Plugin symbol type isn't currently set.  Stop bogus errors.  */
  if (oldbfd != NULL && (oldbfd->flags & BFD_PLUGIN) != 0)
    *type_change_ok = TRUE;

d1090 3
a1092 3
  else if (oldbfd != NULL
	   && ELF_ST_TYPE (sym->st_info) != h->type
	   && (ELF_ST_TYPE (sym->st_info) == STT_TLS || h->type == STT_TLS))
d1431 1
a1431 2
      if (!(oldbfd != NULL
	    && (oldbfd->flags & BFD_PLUGIN) != 0
@


1.387
log
@	* elf-bfd.h (struct elf_backend_data): New member
	static_tls_alignment.
	* elfxx-target.h (elf_backend_static_tls_alignment): Provide
	default.
	(elfNN_bed): Initialize static_tls_alignment.
	* elflink.c (bfd_elf_final_link): Don't round end of TLS section
	if static TLS has special alignment requirements.
	* elf32-i386.c (elf_i386_tpoff): Define bed, static_tls_size.
	Consider static_tls_alignment.
	(elf_backend_static_tls_alignment): Redefine for Solaris 2.
	Undef again for VxWorks.
	* elf64-x86-64.c (elf64_x86_64_tpoff):  Define bed,
	static_tls_size.
	Consider static_tls_alignment.
	(elf_backend_static_tls_alignment): Redefine for Solaris 2.
	Undef again for Intel L1OM.
@
text
@a9356 2
	  bfd_size_type amt = o->rawsize ? o->rawsize : o->size;

d9358 1
a9358 1
	  if (! bfd_get_section_contents (input_bfd, o, contents, 0, amt))
@


1.386
log
@Applied patch series for LD plugin interface (six parts).

[PATCH] Add infrastructure for plugin API; functionality to follow.

    include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* plugin-api.h (LDPT_GNU_LD_VERSION): New ld_plugin_tag enum member.

    ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* configure.in: Add AC_CHECKs for file io and dlfcn headers and
	functions and AC_SEARCH for -ldl.
	(enable_plugins): New shell variable set if above tests find dlopen
	functionality.
	(ENABLE_PLUGINS): Add related automake conditional.
	* configure: Regenerate.
	* config.in: Likewise.
	* Makefile.am (PLUGIN_C): Declare plugin C source file, conditional
	on ENABLE_PLUGINS being defined.
	(PLUGIN_H): Likewise for header file.
	(PLUGIN_OBJECT): Likewise for object file.
	(PLUGIN_CFLAGS): Likewise -D flag required to compile plugin support.
	(AM_CPPFLAGS): Use PLUGIN_CFLAGS.
	(CFILES): Use PLUGIN_C.
	(HFILES): Use PLUGIN_H.
	(OFILES): Use PLUGIN_OBJECT.
	(ld_new_SOURCES): Use PLUGIN_C.
	(noinst_LTLIBRARIES)[ENABLE_PLUGINS]: Declare test plugin.
	(libldtestplug_la_SOURCES)[ENABLE_PLUGINS]: Add automake definition
	for test plugin.
	(libldtestplug_la_CFLAGS)[ENABLE_PLUGINS]: Likewise.
	(libldtestplug_la_LDFLAGS)[ENABLE_PLUGINS]: Likewise.
	* Makefile.in: Regenerate.
	* sysdep.h: Include stdarg.h, unistd.h and one of fcntl.h or
	sys/file.h where available.  Include dlfcn.h when ENABLE_PLUGINS.
	(O_RDONLY): Supply default definition likewise to bfd's sysdep.h
	(O_WRONLY): Likewise.
	(O_RDWR): Likewise.
	(O_ACCMODE): Likewise.
	(O_BINARY): Likewise.
	(SEEK_SET): Likewise.
	(SEEK_CUR): Likewise.
	(SEEK_END): Likewise.
	* ldmisc.c (vfinfo): Make non-static.  Add %p format char.
	* ldmisc.h (vfinfo): Declare extern prototype.
	* lexsup.c (enum option_values)[ENABLE_PLUGINS]: Add new entries for
	OPTION_PLUGIN and OPTION_PLUGIN_OPT.
	(ld_options[])[ENABLE_PLUGINS]: Add option data for the above two.
	(parse_args)[ENABLE_PLUGINS]: Handle them, and load all plugins once
	option parsing is complete.
	* ldmain.c (main)[ENABLE_PLUGINS]: Call plugin cleanup hooks just
	after lang_finish.
	* plugin.c: New source file.
	* plugin.h: Likewise new header.
	* testplug.c: New source file.

    ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* ld-bootstrap/bootstrap.exp: Skip static tests also if LD plugins
	are enabled.
	* lib/ld-lib.exp (proc regexp_diff): Extend verbose debug output.
	(proc set_file_contents): Write a file with the supplied content.
	(run_ld_link_tests): Add new 'ld' action to test linker output.
	(proc check_plugin_api_available): Return true if linker under test
	supports the plugin API.
	* ld-plugin/func.c: New test source file.
	* ld-plugin/main.c: Likewise.
	* ld-plugin/text.c: Likewise.
	* ld-plugin/plugin-1.d: New dump test output pattern script.
	* ld-plugin/plugin-2.d: Likewise.
	* ld-plugin/plugin-3.d: Likewise.
	* ld-plugin/plugin-4.d: Likewise.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin.exp: New test control script.
---
[PATCH] Implement claim file and all symbols read hooks and add symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ldfile.c (ldfile_try_open_bfd)[ENABLE_PLUGINS]: Don't return early
	during compat checks if they pass, instead offer any successfully
	opened and accepted file to the plugin claim file hooks chain.  Create
	a dummy bfd to accept symbols added by the plugin, if the plugin
	claims the file.
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Call plugin all symbols
	read hook chain before ldemul_after_open.
	* ldlang.h (struct lang_input_statement_struct): Add new single-bit
	'claimed' flag.
	* plugin.c (IRONLY_SUFFIX): New macro for dummy bfd file suffix.
	(IRONLY_SUFFIX_LEN): Length of the above string.
	(plugin_get_ir_dummy_bfd): New function to create the dummy bfd used
	to store symbols for ir-only files.
	(is_ir_dummy_bfd): New function to check if a bfd is ir-only.
	(asymbol_from_plugin_symbol): New function converts symbol formats.
	(add_symbols): Call it to convert plugin syms to bfd syms and add
	them to the dummy bfd.
	* plugin.h: Add missing include guards.
	(plugin_get_ir_dummy_bfd): Add prototype.
	(is_ir_dummy_bfd): Likewise.
	* testplug.c (TV_MESSAGE): New helper macro.
	(struct claim_file): New struct.
	(claim_file_t): New typedef.
	(tag_names[]): Make static and const.
	(claimfiles_list): New variable.
	(claimfiles_tail_chain_ptr): Likewise.
	(last_claimfile): Likewise.
	(record_claim_file): Record a file to claim on a singly-linked list.
	(parse_symdefstr): Parse an ASCII representation of a symbol from a
	plugin option into the fields of a struct ld_plugin_symbol.
	(record_claimed_file_symbol):  Use it to parse plugin option for
	adding a symbol.
	(parse_option): Parse claim file and add symbol options.
	(dump_tv_tag): Use TV_MESSAGE.
	(onload): Likewise.
	(onclaim_file): Make static.  Use TV_MESSAGE.  Scan list of files to
	claim and claim this file if required, adding any symbols specified.
	(onall_symbols_read): Make static and use TV_MESSAGE.
	(oncleanup): Likewise.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ld-plugin/plugin-3.d: Enable regexes for new functionality.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin-6.d: New testcase.
	* ld-plugin/plugin-7.d: Likewise.
	* ld-plugin/plugin.exp: Use 'nm' on compiled test objects to determine
	whether symbols in plugin arguments need an underscore prefix.  Add
	new plugin-6.d and plugin-7.d testcases.
---
[PATCH] Implement get symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ldmain.c (notice)[ENABLE_PLUGINS]: Call plugin_notice.
	* plugin.c (non_ironly_hash): Add new bfd hash table.
	(plugin_load_plugins): Exit early if no plugins to load.  If plugins
	do load successfully, set notice_all flag in link info.
	(get_symbols): Implement.
	(plugin_load_plugins): Exit early if no plugins to load, else after
	loading plugins successfully enable notice_all mode.
	(init_non_ironly_hash): Lazily init non_ironly_hash table.
	(plugin_notice): Record symbols referenced from non-IR files in the
	non_ironly_hash.  Suppress tracing, cref generation and nocrossrefs
	tracking for symbols from dummy IR bfds.
	* plugin.h: Fix formatting.
	(plugin_notice): Add prototype.
	* testplug.c (dumpresolutions): New global var.
	(parse_options): Accept "dumpresolutions".
	(onall_symbols_read): Get syms and dump resolutions if it was given.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ld-plugin/plugin-8.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Implement add input file, add input lib and set extra lib path callbacks.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Move invocation of
	plugin_call_all_symbols_read to before setting of gc_sym_list, and
	open any new input files that may have been added during it.
	* ldmain.c (multiple_definition)[ENABLE_PLUGINS]: Call out to
	plugin_multiple_definition and let it have first say over what to do
	with the clashing definitions.
	* plugin.c (no_more_claiming): New boolean variable.
	(plugin_cached_allow_multiple_defs): Likewise.
	(add_input_file): Implement.
	(add_input_library): Likewise.
	(set_extra_library_path): Likewise.
	(plugin_call_claim_file): Don't do anything when no_more_claiming set.
	(plugin_call_all_symbols_read): Set it.  Disable link info
	"allow_multiple_definition" flag, but cache its value.
	(plugin_multiple_definition): New function.
	* plugin.h (plugin_multiple_definition): Add prototype.
	* testplug.c (addfile_enum_t): New enumerated typedef.
	(add_file_t): New struct typedef.
	(addfiles_list): New variable.
	(addfiles_tail_chain_ptr): Likewise.
	(record_add_file): New function.
	(parse_option): Parse "add:", "lib:" and "dir:" options and call it.
	(onall_symbols_read): Iterate the list of new files, libs and dirs,
	adding them.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ld-plugin/plugin-9.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Add ELF symbol visibility support to plugin interface.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* plugin.c (asymbol_from_plugin_symbol): If the bfd is an ELF bfd,
	find the elf symbol data and set the visibility in the st_other field.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* ld-plugin/plugin-ignore.d: New dump test control script.
	* ld-plugin/plugin-vis-1.d: Likewise.
	* ld-plugin/plugin.exp: Add list of ELF-only tests and run them if
	testing on an ELF target.
---
[PATCH] Add archive support to plugin interface.

  bfd/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* aoutx.h (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* cofflink.c (coff_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(coff_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* ecoff.c (read_ext_syms_and_strs): New function holds symbol-reading
	code factored-out from ecoff_link_check_archive_element.
	(reread_ext_syms_and_strs): Clear old symbols and call it.
	(ecoff_link_check_archive_element):  Use the above.  Handle substitute
	BFD if one is set by add_archive_element callback.
	(ecoff_link_add_archive_symbols): Likewise allow bfd substitution.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it was
	set during add_archive_element callback in the above.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Handle substitute
	BFD if one is set by add_archive_element callback.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols): Take new "subsbfd"
	reference parameter and pass it when invoking add_archive_element
	callback.
	(xcoff_link_check_ar_symbols): Likewise.
	(xcoff_link_check_archive_element): Handle bfd substitution if it was
	set by callback in the above.

  include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* bfdlink.h (struct_bfd_link_callbacks): Document new argument
	to add_archive_element callback used to return a replacement bfd which
	is to be added to the hash table in place of the original element.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ldlang.c (load_symbols): Handle bfd subsitution when calling the
	add_archive_element callback.
	* ldmain.c (add_archive_element)[ENABLE_PLUGINS]: Offer the archive
	member to the plugins and if claimed set "subsbfd" output parameter to
	point to the dummy IR-only BFD.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ld-plugin/plugin-10.d: New dump test control script.
	* ld-plugin/plugin-11.d: Likewise.
	* ld-plugin/plugin.exp: Run them.
---
@
text
@d10627 5
a10631 1
      end = align_power (end, elf_hash_table (info)->tls_sec->alignment_power);
@


1.385
log
@	* elflink.c (_bfd_elf_link_output_relocs): Delete unused variable
	"output_rel_hdr".
@
text
@d5014 1
d5077 2
a5078 2
	  if (! (*info->callbacks->add_archive_element) (info, element,
							 symdef->name))
d5080 3
a5082 1
	  if (! bfd_link_add_symbols (element, info))
@


1.384
log
@Fix build with -DDEBUG=7
@
text
@a2343 1
  Elf_Internal_Shdr *output_rel_hdr;
a2349 1
  output_rel_hdr = NULL;
@


1.383
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d7887 2
a7888 1
	  oplen, x, mask,  relocation);
d7908 2
a7909 2
	  relocation, (mask << shift),
	  ((relocation & mask) << shift), x);
d9468 2
a9469 1
			  input_bfd->filename, o->name, rel - internal_relocs);
@


1.382
log
@Clear non_elf on ELF linker defined symbols.

2010-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11812
	* elf32-i386.c (elf_i386_size_dynamic_sections): Don't
	 allocate .got.plt section if there are no GOT nor PLT
	 entries and there is no refeence to _GLOBAL_OFFSET_TABLE_.
	 * elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Li.kewise.

	* elflink.c (_bfd_elf_define_linkage_sym): Clear non_elf.
@
text
@d2199 1
a2199 1
   REL_HDR2 relocations.  */
a2207 1
  Elf_Internal_Shdr *rel_hdr;
d2211 2
d2214 2
a2215 2
  if (elf_section_data (o)->relocs != NULL)
    return elf_section_data (o)->relocs;
a2219 2
  rel_hdr = &elf_section_data (o)->rel_hdr;

d2236 6
a2241 1
      bfd_size_type size = rel_hdr->sh_size;
a2242 2
      if (elf_section_data (o)->rel_hdr2)
	size += elf_section_data (o)->rel_hdr2->sh_size;
d2249 17
a2265 11
  if (!elf_link_read_relocs_from_section (abfd, o, rel_hdr,
					  external_relocs,
					  internal_relocs))
    goto error_return;
  if (elf_section_data (o)->rel_hdr2
      && (!elf_link_read_relocs_from_section
	  (abfd, o,
	   elf_section_data (o)->rel_hdr2,
	   ((bfd_byte *) external_relocs) + rel_hdr->sh_size,
	   internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
			      * bed->s->int_rels_per_ext_rel))))
d2270 1
a2270 1
    elf_section_data (o)->relocs = internal_relocs;
d2298 1
a2298 2
				  Elf_Internal_Shdr *rel_hdr,
				  asection *o)
d2300 1
a2300 12
  bfd_size_type reloc_count;
  bfd_size_type num_rel_hashes;

  /* Figure out how many relocations there will be.  */
  if (rel_hdr == &elf_section_data (o)->rel_hdr)
    reloc_count = elf_section_data (o)->rel_count;
  else
    reloc_count = elf_section_data (o)->rel_count2;

  num_rel_hashes = o->reloc_count;
  if (num_rel_hashes < reloc_count)
    num_rel_hashes = reloc_count;
d2303 1
a2303 1
  rel_hdr->sh_size = rel_hdr->sh_entsize * reloc_count;
d2313 1
a2313 4
  /* We only allocate one set of hash entries, so we only do it the
     first time we are called.  */
  if (elf_section_data (o)->rel_hashes == NULL
      && num_rel_hashes)
d2318 1
a2318 1
          bfd_zmalloc (num_rel_hashes * sizeof (struct elf_link_hash_entry *));
d2322 1
a2322 1
      elf_section_data (o)->rel_hashes = p;
d2343 1
a2345 1
  unsigned int *rel_countp = NULL;
d2348 1
d2353 3
a2355 2
  if (elf_section_data (output_section)->rel_hdr.sh_entsize
      == input_rel_hdr->sh_entsize)
d2357 2
a2358 2
      output_rel_hdr = &elf_section_data (output_section)->rel_hdr;
      rel_countp = &elf_section_data (output_section)->rel_count;
d2360 2
a2361 3
  else if (elf_section_data (output_section)->rel_hdr2
	   && (elf_section_data (output_section)->rel_hdr2->sh_entsize
	       == input_rel_hdr->sh_entsize))
d2363 2
a2364 2
      output_rel_hdr = elf_section_data (output_section)->rel_hdr2;
      rel_countp = &elf_section_data (output_section)->rel_count2;
d2375 2
a2376 10
  bed = get_elf_backend_data (output_bfd);
  if (input_rel_hdr->sh_entsize == bed->s->sizeof_rel)
    swap_out = bed->s->swap_reloc_out;
  else if (input_rel_hdr->sh_entsize == bed->s->sizeof_rela)
    swap_out = bed->s->swap_reloca_out;
  else
    abort ();

  erel = output_rel_hdr->contents;
  erel += *rel_countp * input_rel_hdr->sh_entsize;
d2389 1
a2389 1
  *rel_countp += NUM_SHDR_ENTRIES (input_rel_hdr);
d7917 2
a7918 2
   referenced must be updated.  Update all the relocations in
   REL_HDR (there are COUNT of them), using the data in REL_HASH.  */
d7922 1
a7922 3
			Elf_Internal_Shdr *rel_hdr,
			unsigned int count,
			struct elf_link_hash_entry **rel_hash)
d7931 2
d7934 1
a7934 1
  if (rel_hdr->sh_entsize == bed->s->sizeof_rel)
d7939 1
a7939 1
  else if (rel_hdr->sh_entsize == bed->s->sizeof_rela)
d7961 2
a7962 2
  erela = rel_hdr->contents;
  for (i = 0; i < count; i++, rel_hash++, erela += rel_hdr->sh_entsize)
d9552 1
a9552 1
	      Elf_Internal_Rela *irelaend;
d9555 2
a9556 2
	      struct elf_link_hash_entry **rel_hash_list;
	      Elf_Internal_Shdr *input_rel_hdr, *input_rel_hdr2;
d9559 1
d9561 3
a9563 4
	      input_rel_hdr = &elf_section_data (o)->rel_hdr;
	      rela_normal = (bed->rela_normal
			     && (input_rel_hdr->sh_entsize
				 == bed->s->sizeof_rela));
d9569 7
a9575 3
	      rel_hash = (elf_section_data (o->output_section)->rel_hashes
			  + elf_section_data (o->output_section)->rel_count
			  + elf_section_data (o->output_section)->rel_count2);
d9577 1
d9593 7
d9791 2
a9792 9
	      if (input_rel_hdr->sh_size != 0
		  && !bed->elf_backend_emit_relocs (output_bfd, o,
						    input_rel_hdr,
						    internal_relocs,
						    rel_hash_list))
		return FALSE;

	      input_rel_hdr2 = elf_section_data (o)->rel_hdr2;
	      if (input_rel_hdr2 && input_rel_hdr2->sh_size != 0)
d9794 5
d9802 5
d9808 1
a9808 1
						     input_rel_hdr2,
d9810 1
a9810 1
						     rel_hash_list))
d9876 1
d9883 1
d9894 10
d9905 1
a9905 3
  rel_hash_ptr = (elf_section_data (output_section)->rel_hashes
		  + elf_section_data (output_section)->rel_count
		  + elf_section_data (output_section)->rel_count2);
d10017 1
a10017 1
  rel_hdr = &elf_section_data (output_section)->rel_hdr;
d10021 1
a10021 2
      erel += (elf_section_data (output_section)->rel_count
	       * bed->s->sizeof_rel);
d10027 1
a10027 2
      erel += (elf_section_data (output_section)->rel_count
	       * bed->s->sizeof_rela);
d10031 1
a10031 1
  ++elf_section_data (output_section)->rel_count;
a10316 1
	  unsigned int *rel_count1;
d10369 1
a10369 1
		      size_t ext_size;
d10371 4
a10374 3
		      ext_size = esdi->rel_hdr.sh_size;
		      if (esdi->rel_hdr2 != NULL)
			ext_size += esdi->rel_hdr2->sh_size;
d10389 12
a10400 17
	  /* MIPS may have a mix of REL and RELA relocs on sections.
	     To support this curious ABI we keep reloc counts in
	     elf_section_data too.  We must be careful to add the
	     relocations from the input section to the right output
	     count.  FIXME: Get rid of one count.  We have
	     o->reloc_count == esdo->rel_count + esdo->rel_count2.  */
	  rel_count1 = &esdo->rel_count;
	  if (esdi != NULL)
	    {
	      bfd_boolean same_size;
	      bfd_size_type entsize1;

	      entsize1 = esdi->rel_hdr.sh_entsize;
	      /* PR 9827: If the header size has not been set yet then
		 assume that it will match the output section's reloc type.  */
	      if (entsize1 == 0)
		entsize1 = o->use_rela_p ? bed->s->sizeof_rela : bed->s->sizeof_rel;
d10402 1
a10402 28
		BFD_ASSERT (entsize1 == bed->s->sizeof_rel
			    || entsize1 == bed->s->sizeof_rela);
	      same_size = !o->use_rela_p == (entsize1 == bed->s->sizeof_rel);

	      if (!same_size)
		rel_count1 = &esdo->rel_count2;

	      if (esdi->rel_hdr2 != NULL)
		{
		  bfd_size_type entsize2 = esdi->rel_hdr2->sh_entsize;
		  unsigned int alt_count;
		  unsigned int *rel_count2;

		  BFD_ASSERT (entsize2 != entsize1
			      && (entsize2 == bed->s->sizeof_rel
				  || entsize2 == bed->s->sizeof_rela));

		  rel_count2 = &esdo->rel_count2;
		  if (!same_size)
		    rel_count2 = &esdo->rel_count;

		  /* The following is probably too simplistic if the
		     backend counts output relocs unusually.  */
		  BFD_ASSERT (bed->elf_backend_count_relocs == NULL);
		  alt_count = NUM_SHDR_ENTRIES (esdi->rel_hdr2);
		  *rel_count2 += alt_count;
		  reloc_count -= alt_count;
		}
a10403 1
	  *rel_count1 += reloc_count;
d10440 1
d10443 2
a10444 2
	  if (!(_bfd_elf_link_size_reloc_section
		(abfd, &elf_section_data (o)->rel_hdr, o)))
d10447 2
a10448 3
	  if (elf_section_data (o)->rel_hdr2
	      && !(_bfd_elf_link_size_reloc_section
		   (abfd, elf_section_data (o)->rel_hdr2, o)))
d10454 2
a10455 2
      elf_section_data (o)->rel_count = 0;
      elf_section_data (o)->rel_count2 = 0;
d10887 1
d10891 4
a10894 8
      elf_link_adjust_relocs (abfd, &elf_section_data (o)->rel_hdr,
			      elf_section_data (o)->rel_count,
			      elf_section_data (o)->rel_hashes);
      if (elf_section_data (o)->rel_hdr2 != NULL)
	elf_link_adjust_relocs (abfd, elf_section_data (o)->rel_hdr2,
				elf_section_data (o)->rel_count2,
				(elf_section_data (o)->rel_hashes
				 + elf_section_data (o)->rel_count));
d11189 5
a11193 3
      if ((o->flags & SEC_RELOC) != 0
	  && elf_section_data (o)->rel_hashes != NULL)
	free (elf_section_data (o)->rel_hashes);
d11235 5
a11239 3
      if ((o->flags & SEC_RELOC) != 0
	  && elf_section_data (o)->rel_hashes != NULL)
	free (elf_section_data (o)->rel_hashes);
d12583 1
a12583 1
  unsigned int shnam = elf_section_data (sec)->rel_hdr.sh_name;
@


1.381
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d89 1
@


1.380
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elflink.c (bfd_elf_reloc_symbol_deleted_p): Compare the symbol index
	to STN_UNDEF, not SHN_UNDEF.
@
text
@d2173 1
a2173 1
      else if (r_symndx != 0)
d9503 1
a9503 1
		      BFD_ASSERT (r_symndx != 0);
d9670 1
a9670 1
		      r_symndx = 0;
d9699 1
a9699 1
			      if (r_symndx == 0)
d9717 1
a9717 1
			      BFD_ASSERT (r_symndx != 0);
d11474 1
a11474 1
  if (r_symndx == 0)
@


1.379
log
@bfd/
	* elf.c (bfd_elf_get_default_section_type): Don't test SEC_NEVER_LOAD.
	* elflink.c (elf_link_input_bfd): Likewise.
ld/
	* ld.texinfo (NOLOAD): Do not erroneously state that contents will
	appear in output file.
	* ldlang.c (lang_add_section): Clear SEC_HAS_CONTENTS on noload
	unless SEC_COFF_SHARED_LIBRARY.
	(map_input_to_output_sections): Don't set SEC_HAS_CONTENTS for noload
	output sections.
	(lang_size_sections_1): Don't test SEC_NEVER_LOAD when deciding
	to update dot in region.  Ditto when setting SEC_ALLOC if dot
	advanced due to assignment.
	* ldwrite.c (build_link_order): Don't test SEC_NEVER_LOAD.
@
text
@d12199 1
a12199 1
      if (r_symndx == SHN_UNDEF)
@


1.378
log
@	* elflink.c (bfd_elf_final_link): Correct calculation of
	max_external_reloc_size.
@
text
@d2832 1
a2832 1
   undefined symbols.  The two functions are vitually identical except
a9845 1
		&& ! (o->output_section->flags & SEC_NEVER_LOAD)
@


1.377
log
@	* elflink.c (_bfd_elf_dynamic_symbol_p): Rename param.  Make
	common syms local.
	(_bfd_elf_symbol_refs_local_p): Expand comment.
	(elf_link_output_extsym): Fix style nit.
@
text
@d10363 4
a10366 1
		      ext_size = elf_section_data (sec)->rel_hdr.sh_size;
@


1.376
log
@Don't set unique_global for non-ELF hash link table.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11939
	* elflink.c (elf_link_add_object_symbols): Don't set
	unique_global for non-ELF hash link table.
@
text
@d2773 1
a2773 1
			   bfd_boolean ignore_protected)
d2812 1
a2812 1
      if (!ignore_protected || !bed->is_function_type (h->type))
d2821 1
a2821 1
  if (!h->def_regular)
d2832 9
a2840 1
   undefined symbols and weak symbols.  */
d8646 1
a8646 1
      if (ignore_undef == FALSE
@


1.375
log
@Don't check relocation if input ELF object ID doesn't match output.

bfd/

2010-08-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11933
	* elflink.c (elf_link_add_object_symbols): Don't check relocation
	if input ELF object ID doesn't match output.

ld/testsuite/

2010-08-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11933
	* ld-x86-64/mixed1a.s: New.
	* ld-x86-64/mixed1b.s: Likewise.
	* ld-x86-64/mixed2a.s: Likewise.
	* ld-x86-64/mixed2b.s: Likewise.

	* ld-x86-64/x86-64.exp: Text mixed x86_64 and i386 inputs.
@
text
@d4194 2
a4195 1
      h->unique_global = (flags & BSF_GNU_UNIQUE) != 0;
@


1.374
log
@        PR ld/11843
        * elflink.c (compute_bucket_count): Avoid futile long searches for
        the best bucket size.
@
text
@d4794 1
@


1.373
log
@Add ATTRIBUTE_UNUSED to info in compute_bucket_count.

2010-07-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (compute_bucket_count): Add ATTRIBUTE_UNUSED to info.
@
text
@d5377 1
d5462 1
d5464 4
@


1.372
log
@	* bfd/elflink.c (_bfd_elf_merge_symbol): Tighten up the test for early
	exit due to merging the same weak symbol to test that the symbols are
	actually weak.
@
text
@d5355 1
a5355 1
compute_bucket_count (struct bfd_link_info *info,
@


1.371
log
@Check !executable instead of shared for PIE.

2010-03-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11413
	* elflink.c (_bfd_elf_add_default_symbol): Check !executable
	instead of shared.
@
text
@d1016 5
d1028 1
a1249 5
  /* Differentiate strong and weak symbols.  */
  newweak = bind == STB_WEAK;
  oldweak = (h->root.type == bfd_link_hash_defweak
	     || h->root.type == bfd_link_hash_undefweak);

@


1.370
log
@	ld:
	* Makefile.am (ALL_EMULATIONS): Add eelf32_sparc_sol2.o,
	eelf_i386_sol2.o.
	(ALL_64_EMULATIONS): Add eelf_x86_64_sol2.o, eelf64_sparc_sol2.o.
	(eelf32_sparc_sol2.c): New rule.
	(eelf64_sparc_sol2.c): Likewise.
	(eelf_x86_64_sol2.c): Likewise.
	(eelf_i386_sol2.c): Likewise.
	* Makefile.in: Regenerate.
	* configure.tgt (i[3-7]86-*-solaris2*): Change targ_emul to
	elf_i386_sol2.
	Add elf_i386_ldso, elf_x86_64_sol2 to targ_extra_emuls.
	(x86_64-*-solaris2*): Change targ_emul to elf_x86_64_sol2.
	Add elf_x86_64, elf_i386_sol2, elf_i386 to targ_extra_emuls.
	(sparc-*-solaris2.[0-6]*): Change targ_emul to elf32_sparc_sol2.
	Add target_extra_emuls.
	(sparc-*-solaris2*): Change targ_emul to elf32_sparc_sol2.
	Add elf32_sparc, elf64_sparc_sol2 to targ_extra_emuls.
	(sparcv9-*-solaris2*): Change targ_emul to elf64_sparc_sol2.
	Add elf64_sparc, elf32_sparc_sol2 to target_extra_emuls.
	* emulparams/elf32_sparc_sol2.sh: New file.
	* emulparams/elf64_sparc_sol2.sh: New file.
	* emulparams/elf_i386_sol2.sh: New file.
	* emulparams/elf_x86_64_sol2.sh: New file.
	* emultempl/solaris2.em: New file.

	bfd:
	* elflink.c (bfd_elf_size_dynamic_sections): Don't emit base
	version twice.
	Skip it when constructing def.vd_next.

	* elf32-i386.c (TARGET_LITTLE_SYM): Redefine to
	bfd_elf32_i386_sol2_vec.
	(TARGET_LITTLE_NAME): Redefine to elf32-i386-sol2.
	(elf32_bed): Redefine to elf32_i386_sol2_bed.
	(elf_backend_want_plt_sym): Redefine to 1.

	* elf64-x86-64.c (TARGET_LITTLE_SYM): Redefine to
	bfd_elf64_x86_64_sol2_vec.
	(TARGET_LITTLE_NAME): Redefine to elf64-x86-64-sol2.
	(elf64_bed): Redefine to elf64_x86_64_sol2_bed.
	(elf_backend_want_plt_sym): Redefine to 1.

	* config.bfd (i[3-7]86-*-solaris2*): Set targ_defvec to
	bfd_elf32_i386_sol2_vec.
	Replace bfd_elf64_x86_64_vec by bfd_elf64_x86_64_sol2_vec in
	targ64_selvecs.
	(x86_64-*-solaris2*): Set targ_defvec to bfd_elf32_i386_sol2_vec.
	Replace bfd_elf64_x86_64_vec by bfd_elf64_x86_64_sol2_vec in
	targ_selvecs.

	* configure.in: Handle bfd_elf32_i386_sol2_vec,
	bfd_elf64_x86_64_sol2_vec.
	* configure: Regenerate.

	* targets.c (bfd_elf32_i386_sol2_vec): Declare.
	(bfd_elf64_x86_64_sol2_vec): Declare.
	(_bfd_target_vector): Add bfd_elf32_i386_sol2_vec,
	bfd_elf64_x86_64_sol2_vec.
@
text
@d1718 1
a1718 1
	      if (info->shared
d1787 1
a1787 1
		  if (info->shared
@


1.369
log
@bfd/
	* elf.c (_bfd_elf_fixup_group_sections): New function, split out from..
	(_bfd_elf_copy_private_header_data): ..here.
	* elflink.c (_bfd_elf_size_group_sections): New function.
	(bfd_elf_size_dynamic_sections): Call it.
	* elf-bfd.h (_bfd_elf_size_group_sections): Declare.
	(_bfd_elf_fixup_group_sections): Declare.
ld/
	* ldlang.c (unique_section_p): Add os param.  Allow group
	sections to match /DISCARD/.  Update all callers.
	* emultempl/genelf.em (gld${EMULATION_NAME}_before_allocation): New.
	(LDEMUL_BEFORE_ALLOCATION): Define.
ld/testsuite/
	* ld-elf/group.ld: Discard .dropme sections.
	* ld-elf/group10.d, * ld-elf/group10.s: New test.
@
text
@d5949 4
d6052 4
d6087 7
a6093 1
	      if (t->next != NULL)
d6194 1
a6194 1
	    /* Build the version definition section.  */
@


1.368
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d5484 14
d5572 4
@


1.367
log
@Properly check undefined symbols when gc_sections is active.

bfd/

2010-01-26  Alan Modra  <amodra@@gmail.com>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11218
	* elflink.c (elf_link_output_extsym): Do not ignore undefined
	symbols with ref_regular set when gc_sections is active.

ld/testsuite/

2010-01-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11218
	* ld-gc/dummy.s: New.
	* ld-gc/pr11218-1.c: Likewise.
	* ld-gc/pr11218-2.c: Likewise.
	* ld-gc/pr11218.d: Likewise.
@
text
@d6785 2
a6786 1
   unsigned int entsize)
d6800 1
d6802 1
d6820 2
a6821 1
				       sizeof (struct elf_link_hash_entry)))
@


1.366
log
@        * elflink.c (elf_link_add_object_symbols): Look up name of
        undefined symbol both before and after versioning has been
        applied.  Do not bother with symbols that are weakly undefined.
@
text
@d8582 3
a8584 1
	 references in regular files have already been handled).  */
d8595 1
a8595 1
	  && ! h->ref_regular
d8600 2
a8601 1
		 (finfo->info, h->root.root.string, h->root.u.undef.abfd,
@


1.365
log
@Fix PR ld/11138

bfd/

2010-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11138
	* elflink.c (elf_link_check_versioned_symbol): Don't abort if
	a symbol referenced by DSO is is defined in a non-shared object
	and forced local.

ld/testsuite/

2010-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11138
	* ld-elf/pr11138-1.c: New.
	* ld-elf/pr11138-1.map: Likewise.
	* ld-elf/pr11138-2.c: Likewise.
	* ld-elf/pr11138-2.map: Likewise.
	* ld-elf/pr11138.out: Likewise.

	* ld-elf/shared.exp (build_tests): Add libpr11138-1.so and
	libpr11138-2.o.
	(run_tests): Add 2 tests for PR ld/11138.
@
text
@d4002 14
d4123 4
a4126 4
	  /* If this is a definition of a previously undefined symbol
	     make a note of the bfd that contained the reference in
	     case we need to refer to it later on in error messages.  */
	  if (! bfd_is_und_section (sec))
d4131 1
a4131 2
		  && (h->root.type == bfd_link_hash_undefined
		      || h->root.type == bfd_link_hash_undefweak)
d4471 4
a4474 2
		 --no-add-needed is used.  */
	      if ((elf_dyn_lib_class (abfd) & DYN_NO_NEEDED) != 0)
d4478 1
a4478 1
		     undef_bfd == NULL ? info->output_bfd : undef_bfd, name);
@


1.364
log
@Set SEC_KEEP on section XXX for undefined __start_XXX/__stop_XXX

bfd/

2010-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11133
	* elflink.c (_bfd_elf_gc_mark_hook): Check section XXX for
	undefined __start_XXX/__stop_XXX in all input files and set
	SEC_KEEP.

ld/testsuite/

2010-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11133
	* ld-gc/gc.exp: Run start.

	* ld-gc/start.d: New.
	* ld-gc/start.s: Likewise.
@
text
@d8495 3
a8497 1
	  if ((iver.vs_vers & VERSYM_HIDDEN) == 0)
d8500 3
a8502 1
		 have provided a definition for the undefined sym.  */
@


1.363
log
@Always keep SHT_NOTE sections

bfd/

2010-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11143
	* elflink.c (elf_gc_sweep): Keep SHT_NOTE section.

ld/testsuite/

2010-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11143
	* ld-gc/gc.exp: Run abi-note.

	* ld-gc/abi-note.d: New.
	* ld-gc/abi-note.s: Likewise.
@
text
@d11334 2
d11347 27
@


1.362
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009
d11530 2
a11531 1
		   || (o->flags & (SEC_ALLOC | SEC_LOAD | SEC_RELOC)) == 0)
d11533 1
a11533 1
	      /* Keep debug and special sections.  */
@


1.361
log
@2009-11-23  Paul Brook  <paul@@codesourcery.com>

	ld/
	* ldexp.c: Copy symbol type for simple assignments.

	bfd/
	* libbfd-in.h (_bfd_generic_copy_link_hash_symbol_type): Add
	prototype.
	* elf-bfd.h (_bfd_elf_copy_link_hash_symbol_type): Add prototype.
	* linker.c (_bfd_generic_copy_link_hash_symbol_type): New function.
	* elflink.c (_bfd_elf_copy_link_hash_symbol_type): New function.
	* targets.c (BFD_JUMP_TABLE_LINK, struct bfd_target): Add
	_copy_link_hash_symbol_type.
	* bfd/coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* bfd/coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* aout-adobe.c (aout_32_bfd_copy_link_hash_symbol_type): Define.
	* aout-target.h (MY_bfd_copy_link_hash_symbol_type): Define.
	* aout-tic30.c (MY_bfd_copy_link_hash_symbol_type): Define.
	* binary.c (binary_bfd_copy_link_hash_symbol_type): Define.
	* bout.c (b_out_bfd_copy_link_hash_symbol_type): Define.
	* coffcode.h (coff_bfd_copy_link_hash_symbol_type): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_link_hash_symbol_type): Define.
	* i386msdos.c (msdos_bfd_copy_link_hash_symbol_type): Define.
	* i386os9k.c (os9k_bfd_copy_link_hash_symbol_type): Define.
	* ieee.c (ieee_bfd_copy_link_hash_symbol_type): Define.
	* ihex.c (ihex_bfd_copy_link_hash_symbol_type): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_link_hash_symbol_type): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_link_hash_symbol_type): Define.
	* mmo.c (mmo_bfd_copy_link_hash_symbol_type): Define.
	* nlm-target.h (nlm_bfd_copy_link_hash_symbol_type): Define.
	* oasys.c (oasys_bfd_copy_link_hash_symbol_type): Define.
	* pef.c (bfd_pef_bfd_copy_link_hash_symbol_type): Define.
	* ppcboot.c (ppcboot_bfd_copy_link_hash_symbol_type): Define.
	* som.c (som_bfd_copy_link_hash_symbol_type): Define.
	* srec.c (srec_bfd_copy_link_hash_symbol_type): Define.
	* tekhex.c (tekhex_bfd_copy_link_hash_symbol_type): Define.
	* versados.c (versados_bfd_copy_link_hash_symbol_type): Define.
	* vms.c (vms_bfd_copy_link_hash_symbol_type): Define.
	* xsym.c (bfd_sym_bfd_copy_link_hash_symbol_type): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	ld/testsuite
	* ld-arm/script-type.sym: New test.
	* ld-arm/script-type.s: New test.
	* ld-arm/script-type.s: New test.
@
text
@d188 1
a188 1
  register asection *s;
d573 1
a573 2
      const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);

a1185 2
	      const struct elf_backend_data *bed
		= get_elf_backend_data (abfd);
d1187 1
a1548 1
      const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d10111 3
a10113 3
  register asection *o;
  register struct bfd_link_order *p;
  register bfd *sub;
d10562 4
a10565 3
	      struct bfd_link_order *o = sec->map_tail.link_order;
	      if (o != NULL)
		size = o->offset + o->size;
@


1.360
log
@Don't return on STT_GNU_IFUNC symbol when stripping.

bfd/

2009-11-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10911
	* elflink.c (elf_link_output_extsym): Don't return on
	STT_GNU_IFUNC symbol when stripping.

ld/testsuite/

2009-11-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10911
	* ld-ifunc/ifunc-4a-x86.d: New.
@
text
@d12599 12
@


1.359
log
@        * elflink.c (elf_link_add_object_symbols): Improve error
        message generated when a symbol is left unresolved because a
        --no-add-needed command line option has prevented the
        inclusion of the DSO defining it.
@
text
@d8642 2
a8643 1
     nothing else to do unless it is a forced local symbol.  */
d8646 1
@


1.358
log
@	* elflink.c (elf_link_add_object_symbols): Don't force debug
	symbols local.
@
text
@d3880 1
d4112 14
d4465 4
a4468 1
		    (_("%B: invalid DSO for symbol `%s' definition"),
d4470 1
a4470 1
		  bfd_set_error (bfd_error_bad_value);
@


1.357
log
@	* elflink.c (_bfd_elf_merge_symbol): Revert previous patch.
@
text
@a4375 1
	      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
@


1.356
log
@Fix %s that should be %B in several message formats.
@
text
@d1113 1
a1113 1
	  (_("%B: TLS definition in %B section %A mismatches non-TLS definition in %B section %A"),
d1117 1
a1117 1
	  (_("%B: TLS reference in %B mismatches non-TLS reference in %B"),
d1121 1
a1121 1
	  (_("%B: TLS definition in %B section %A mismatches non-TLS reference in %B"),
d1125 1
a1125 1
	  (_("%B: TLS reference in %B mismatches non-TLS definition in %B section %A"),
@


1.355
log
@bfd/

2009-09-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10630
	* elflink.c (elf_link_output_extsym): Turn off visibility on
	local symbol.
	(bfd_elf_final_link): Turn off visibility on dynamic local
	symbol.

ld/testsuite/

2009-09-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10630
	* ld-alpha/tlsbin.rd: Remove HIDDEN/.hidden on local symbols.
	* ld-alpha/tlsbinr.rd: Likewise.
	* ld-alpha/tlspic.rd: Likewise.
	* ld-cris/libdso-2.d: Likewise.
	* ld-cris/locref1.d: Likewise.
	* ld-cris/locref2.d: Likewise.
	* ld-cris/tls-e-20a.d: Likewise.
	* ld-cris/tls-e-20.d: Likewise.
	* ld-cris/tls-e-80.d: Likewise.
	* ld-cris/tls-gc-68.d: Likewise.
	* ld-cris/tls-gc-69.d: Likewise.
	* ld-cris/tls-gc-70.d: Likewise.
	* ld-cris/tls-gc-75.d: Likewise.
	* ld-cris/tls-gc-76.d: Likewise.
	* ld-cris/tls-gc-79.d: Likewise.
	* ld-cris/tls-gd-1h.d: Likewise.
	* ld-cris/tls-gd-2h.d: Likewise.
	* ld-cris/tls-ld-4.d: Likewise.
	* ld-cris/tls-ld-5.d: Likewise.
	* ld-cris/tls-ld-6.d: Likewise.
	* ld-cris/tls-ld-7.d: Likewise.
	* ld-cris/tls-ldgd-14.d: Likewise.
	* ld-cris/tls-ldgd-15.d: Likewise.
	* ld-cris/tls-local-63.d: Likewise.
	* ld-cris/tls-local-64.d: Likewise.
	* ld-elf/pr9676.rd: Likewise.
	* ld-elf/pr9679.rd: Likewise.
	* ld-elfvsb/hidden2.d: Likewise.
	* ld-i386/tlsbindesc.rd: Likewise.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsdesc.rd: Likewise.
	* ld-i386/tlsgdesc.rd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlspic.rd: Likewise.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-sparc/gotop32.rd: Likewise.
	* ld-sparc/gotop64.rd: Likewise.
	* ld-sparc/tlssunbin32.rd: Likewise.
	* ld-sparc/tlssunbin64.rd: Likewise.
	* ld-sparc/tlssunnopic32.rd: Likewise.
	* ld-sparc/tlssunnopic64.rd: Likewise.
	* ld-sparc/tlssunpic32.rd: Likewise.
	* ld-sparc/tlssunpic64.rd: Likewise.
	* ld-x86-64/tlsbindesc.rd: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-x86-64/tlsdesc.rd: Likewise.
	* ld-x86-64/tlsgdesc.rd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-xtensa/tlsbin.rd: Likewise.
	* ld-xtensa/tlspic.rd: Likewise.

	* ld-elf/local1.d: New.
	* ld-elf/local1.map: Likewise.
	* ld-elf/local1.s: Likewise.
	* ld-ia64/local1.d: Likewise.
	* ld-ia64/local1.map: Likewise.
	* ld-ia64/local1.s: Likewise.
@
text
@d1113 1
a1113 1
	  (_("%s: TLS definition in %B section %A mismatches non-TLS definition in %B section %A"),
d1117 1
a1117 1
	  (_("%s: TLS reference in %B mismatches non-TLS reference in %B"),
d1121 1
a1121 1
	  (_("%s: TLS definition in %B section %A mismatches non-TLS reference in %B"),
d1125 1
a1125 1
	  (_("%s: TLS reference in %B mismatches non-TLS definition in %B section %A"),
d4451 1
a4451 1
		    (_("%s: invalid DSO for symbol `%s' definition"),
d12535 1
a12535 1
   
@


1.354
log
@bfd/
	* bfd-in.h (bfd_elf_size_dynamic_sections): Add audit and depaudit
	arguments.
	* elflink.c (bfd_elf_size_dynamic_sections): Generate DT_AUDIT,
	DT_DEPAUDIT from audit/depaudit arguments.
	(elf_finalize_dynstr): Finalize DT_AUDIT and DT_DEPAUDIT strtab entries.
	(elf_link_add_object_symbols): Set dt_audit target data when finding a
	DT_AUDIT.
	* bfd-in2.h: Regenerate.
	* bfd-elf.h: Add dt_audit to elf_obj_tdata, and elf_dt_audit macro.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_add_options): Add --audit,
	--depaudit, and -P options.
	(gld${EULATION_NAME}_handle_options): Ditto.
	(gld${EULATION_NAME}_list_options): Ditto.
	(gld${EMULATION_NAME}_append_to_separated_string): New function for
	handling rpath-like colon separated strings.
	(gld${EMULATION_NAME}_before_allocation): Pass the audit and depaudit
	libs to bfd.  Propagate DT_AUDIT from needed libs to depaudit.
	* ld.texinfo: Document new options.
ld/testsuite/
	* ld-elf/audit.exp: New.
	* ld-elf/audit.rd: New.
	* ld-elf/depaudit.rd: New.
	* ld-elf/depaudit2.rd: New.
@
text
@d8635 5
a8639 1
    sym.st_info = ELF_ST_INFO (STB_LOCAL, h->type);
d10711 1
a10711 4
	      sym.st_size = e->isym.st_size;
	      sym.st_other = e->isym.st_other;

	      /* Copy the internal symbol as is.
d10715 1
@


1.353
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d3237 2
d3530 1
d3659 5
d3716 3
d5465 2
d5619 22
@


1.352
log
@	* elflink.c: Add FIXMEs for some places that require octets_per_byte
	adjustments.
	* elf-eh-frame.c: Likewise.
	* merge.c: Likewise.
@
text
@d637 1
a637 1
  entry = bfd_alloc (input_bfd, amt);
d722 1
a722 1
  size_t *count = data;
d744 1
a744 1
  size_t *count = data;
d1627 1
a1627 1
  shortname = bfd_hash_allocate (&info->hash->table, shortlen + 1);
d1738 1
a1738 1
  shortname = bfd_hash_allocate (&info->hash->table, len);
d1812 1
a1812 1
  struct elf_info_failed *eif = data;
d1855 1
a1855 1
  struct elf_find_verdep_info *rinfo = data;
d1891 1
a1891 1
      t = bfd_zalloc (rinfo->info->output_bfd, amt);
d1904 1
a1904 1
  a = bfd_zalloc (rinfo->info->output_bfd, amt);
d1945 1
a1945 1
  sinfo = data;
d2002 1
a2002 1
	      alc = bfd_malloc (len);
d2049 1
a2049 1
	  t = bfd_zalloc (info->output_bfd, amt);
d2151 1
a2151 1
  erela = external_relocs;
d2229 1
a2229 1
	internal_relocs = alloc2 = bfd_alloc (abfd, size);
d2231 1
a2231 1
	internal_relocs = alloc2 = bfd_malloc (size);
d2314 1
a2314 1
  rel_hdr->contents = bfd_zalloc (abfd, rel_hdr->sh_size);
d2325 2
a2326 1
      p = bfd_zmalloc (num_rel_hashes * sizeof (struct elf_link_hash_entry *));
d2575 1
a2575 1
  struct elf_info_failed *eif = data;
d2756 1
a2756 1
      bfd *output_bfd = data;
d3071 1
a3071 1
  newcontents = bfd_realloc (s->contents, newsize);
d3186 1
a3186 1
  struct elf_strtab_hash *dynstr = data;
d3477 1
a3477 1
	      msg = bfd_alloc (abfd, sz + 1);
d3589 1
a3589 1
		  n = bfd_alloc (abfd, amt);
d3594 1
a3594 1
		  anm = bfd_alloc (abfd, amt);
d3612 1
a3612 1
		  n = bfd_alloc (abfd, amt);
d3617 1
a3617 1
		  anm = bfd_alloc (abfd, amt);
d3638 1
a3638 1
		  n = bfd_alloc (abfd, amt);
d3643 1
a3643 1
		  anm = bfd_alloc (abfd, amt);
d3747 1
a3747 1
      sym_hash = bfd_alloc (abfd, amt);
d3767 1
a3767 1
	  extversym = bfd_malloc (versymhdr->sh_size);
d4083 1
a4083 1
	      newname = bfd_hash_allocate (&htab->root.table, newlen);
d4388 2
a4389 1
		      nondeflt_vers = bfd_malloc (amt);
d4446 2
a4447 1
	      elf_dyn_lib_class (abfd) &= ~DYN_AS_NEEDED;
d4553 1
a4553 1
	  shortname = bfd_malloc (amt + 1);
d4611 1
a4611 1
      sorted_sym_hash = bfd_malloc (amt);
d4824 2
a4825 1
      n = bfd_alloc (abfd, sizeof (struct elf_link_loaded_list));
d4876 1
a4876 1
  copy = bfd_alloc (abfd, len);
d4953 2
a4954 2
  defined = bfd_zmalloc (amt);
  included = bfd_zmalloc (amt);
d5118 1
a5118 1
  struct hash_codes_info *inf = data;
d5135 1
a5135 1
      alc = bfd_malloc (p - name + 1);
d5189 1
a5189 1
  struct collect_gnu_hash_codes *s = data;
d5210 1
a5210 1
      alc = bfd_malloc (p - name + 1);
d5244 1
a5244 1
  struct collect_gnu_hash_codes *s = data;
d5356 1
a5356 1
      counts = bfd_malloc (amt);
d5638 1
a5638 1
	      newname = bfd_malloc (newlen);
d5876 1
a5876 1
	  s->contents = bfd_alloc (output_bfd, s->size);
d6114 1
a6114 1
	    s->contents = bfd_alloc (output_bfd, s->size);
d6274 1
a6274 1
	  s->contents = bfd_zalloc (output_bfd, s->size);
d6294 1
a6294 1
	  s->contents = bfd_alloc (output_bfd, s->size);
d6321 1
a6321 1
	  hashcodes = bfd_malloc (amt);
d6350 1
a6350 1
	  s->contents = bfd_zalloc (output_bfd, s->size);
d6373 1
a6373 1
	  cinfo.hashcodes = bfd_malloc (amt);
d6409 1
a6409 1
	      contents = bfd_zalloc (output_bfd, s->size);
d6453 1
a6453 1
	      cinfo.bitmask = bfd_malloc (amt);
d6460 1
a6460 1
	      cinfo.counts = (void *) (cinfo.bitmask + maskwords);
d6482 1
a6482 1
	      contents = bfd_zalloc (output_bfd, s->size);
d6606 2
a6607 1
      entry = bfd_hash_allocate (table, sizeof (struct elf_link_hash_entry));
d6748 1
a6748 1
  ret = bfd_malloc (amt);
d6891 1
a6891 1
	  l = bfd_alloc (abfd, amt);
d6963 1
a6963 1
  indbuf = bfd_malloc2 (symcount, sizeof (*indbuf));
d6983 1
a6983 1
  ssymbuf = bfd_malloc (total_size);
d7064 2
a7065 2
  ssymbuf1 = elf_tdata (bfd1)->symbuf;
  ssymbuf2 = elf_tdata (bfd2)->symbuf;
d7139 4
a7142 2
      symtable1 = bfd_malloc (count1 * sizeof (struct elf_symbol));
      symtable2 = bfd_malloc (count2 * sizeof (struct elf_symbol));
d7183 4
a7186 2
  symtable1 = bfd_malloc (symcount1 * sizeof (struct elf_symbol));
  symtable2 = bfd_malloc (symcount2 * sizeof (struct elf_symbol));
d7890 2
a7891 2
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
d7915 2
a7916 2
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
d8116 1
a8116 1
  sort = bfd_zmalloc (sort_elt * count);
d8285 2
a8286 1
	  destshndx = bfd_realloc (destshndx, amt * 2);
d8412 1
a8412 1
      extversym = bfd_malloc (versymhdr->sh_size);
d8480 1
a8480 1
  struct elf_outext_info *eoinfo = data;
d9822 2
a9823 2
      size = bfd_get_reloc_size (howto);
      buf = bfd_zmalloc (size);
d10381 1
a10381 1
  finfo.symbuf = bfd_malloc (amt);
d10390 1
a10390 1
      finfo.symshndxbuf = bfd_zmalloc (amt);
d10441 1
a10441 1
      finfo.contents = bfd_malloc (max_contents_size);
d10457 1
a10457 1
      finfo.internal_relocs = bfd_malloc (amt);
d10465 1
a10465 1
      finfo.external_syms = bfd_malloc (amt);
d10470 1
a10470 1
      finfo.internal_syms = bfd_malloc (amt);
d10475 1
a10475 1
      finfo.indices = bfd_malloc (amt);
d10480 1
a10480 1
      finfo.sections = bfd_malloc (amt);
d10488 1
a10488 1
      finfo.locsym_shndx = bfd_malloc (amt);
d11093 1
a11093 1
      bfd_byte *contents = bfd_malloc (attr_size);
d11435 2
a11436 1
      struct elf_gc_sweep_symbol_info *inf = data;
d11817 2
a11818 1
      child->vtable = bfd_zalloc (abfd, sizeof (*child->vtable));
d11850 2
a11851 1
      h->vtable = bfd_zalloc (abfd, sizeof (*h->vtable));
d11884 1
a11884 1
	  ptr = bfd_realloc (ptr - 1, bytes);
d11896 1
a11896 1
	ptr = bfd_zmalloc (bytes);
d11922 1
a11922 1
  struct alloc_got_off_arg *gofarg = arg;
d12022 1
a12022 1
  struct elf_reloc_cookie *rcookie = cookie;
@


1.352.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d637 1
a637 1
  entry = (struct elf_link_local_dynamic_entry *) bfd_alloc (input_bfd, amt);
d722 1
a722 1
  size_t *count = (size_t *) data;
d744 1
a744 1
  size_t *count = (size_t *) data;
d1627 1
a1627 1
  shortname = (char *) bfd_hash_allocate (&info->hash->table, shortlen + 1);
d1738 1
a1738 1
  shortname = (char *) bfd_hash_allocate (&info->hash->table, len);
d1812 1
a1812 1
  struct elf_info_failed *eif = (struct elf_info_failed *) data;
d1855 1
a1855 1
  struct elf_find_verdep_info *rinfo = (struct elf_find_verdep_info *) data;
d1891 1
a1891 1
      t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->info->output_bfd, amt);
d1904 1
a1904 1
  a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->info->output_bfd, amt);
d1945 1
a1945 1
  sinfo = (struct elf_info_failed *) data;
d2002 1
a2002 1
	      alc = (char *) bfd_malloc (len);
d2049 1
a2049 1
	  t = (struct bfd_elf_version_tree *) bfd_zalloc (info->output_bfd, amt);
d2151 1
a2151 1
  erela = (const bfd_byte *) external_relocs;
d2229 1
a2229 1
	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_alloc (abfd, size);
d2231 1
a2231 1
	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_malloc (size);
d2314 1
a2314 1
  rel_hdr->contents = (unsigned char *) bfd_zalloc (abfd, rel_hdr->sh_size);
d2325 1
a2325 2
      p = (struct elf_link_hash_entry **)
          bfd_zmalloc (num_rel_hashes * sizeof (struct elf_link_hash_entry *));
d2574 1
a2574 1
  struct elf_info_failed *eif = (struct elf_info_failed *) data;
d2755 1
a2755 1
      bfd *output_bfd = (bfd *) data;
d3070 1
a3070 1
  newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
d3185 1
a3185 1
  struct elf_strtab_hash *dynstr = (struct elf_strtab_hash *) data;
d3476 1
a3476 1
	      msg = (char *) bfd_alloc (abfd, sz + 1);
d3588 1
a3588 1
		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
d3593 1
a3593 1
		  anm = (char *) bfd_alloc (abfd, amt);
d3611 1
a3611 1
		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
d3616 1
a3616 1
		  anm = (char *) bfd_alloc (abfd, amt);
d3637 1
a3637 1
		  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
d3642 1
a3642 1
		  anm = (char *) bfd_alloc (abfd, amt);
d3746 1
a3746 1
      sym_hash = (struct elf_link_hash_entry **) bfd_alloc (abfd, amt);
d3766 1
a3766 1
	  extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
d4082 1
a4082 1
	      newname = (char *) bfd_hash_allocate (&htab->root.table, newlen);
d4387 1
a4387 2
		      nondeflt_vers =
                          (struct elf_link_hash_entry **) bfd_malloc (amt);
d4444 1
a4444 2
	      elf_dyn_lib_class (abfd) = (enum dynamic_lib_link_class)
                  (elf_dyn_lib_class (abfd) & ~DYN_AS_NEEDED);
d4550 1
a4550 1
	  shortname = (char *) bfd_malloc (amt + 1);
d4608 1
a4608 1
      sorted_sym_hash = (struct elf_link_hash_entry **) bfd_malloc (amt);
d4821 1
a4821 2
      n = (struct elf_link_loaded_list *)
          bfd_alloc (abfd, sizeof (struct elf_link_loaded_list));
d4872 1
a4872 1
  copy = (char *) bfd_alloc (abfd, len);
d4949 2
a4950 2
  defined = (bfd_boolean *) bfd_zmalloc (amt);
  included = (bfd_boolean *) bfd_zmalloc (amt);
d5114 1
a5114 1
  struct hash_codes_info *inf = (struct hash_codes_info *) data;
d5131 1
a5131 1
      alc = (char *) bfd_malloc (p - name + 1);
d5185 1
a5185 1
  struct collect_gnu_hash_codes *s = (struct collect_gnu_hash_codes *) data;
d5206 1
a5206 1
      alc = (char *) bfd_malloc (p - name + 1);
d5240 1
a5240 1
  struct collect_gnu_hash_codes *s = (struct collect_gnu_hash_codes *) data;
d5352 1
a5352 1
      counts = (unsigned long int *) bfd_malloc (amt);
d5634 1
a5634 1
	      newname = (char *) bfd_malloc (newlen);
d5872 1
a5872 1
	  s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
d6110 1
a6110 1
	    s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
d6270 1
a6270 1
	  s->contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
d6290 1
a6290 1
	  s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
d6317 1
a6317 1
	  hashcodes = (unsigned long int *) bfd_malloc (amt);
d6346 1
a6346 1
	  s->contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
d6369 1
a6369 1
	  cinfo.hashcodes = (long unsigned int *) bfd_malloc (amt);
d6405 1
a6405 1
	      contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
d6449 1
a6449 1
	      cinfo.bitmask = (bfd_vma *) bfd_malloc (amt);
d6456 1
a6456 1
	      cinfo.counts = (long unsigned int *) (cinfo.bitmask + maskwords);
d6478 1
a6478 1
	      contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
d6602 1
a6602 2
      entry = (struct bfd_hash_entry *)
          bfd_hash_allocate (table, sizeof (struct elf_link_hash_entry));
d6743 1
a6743 1
  ret = (struct elf_link_hash_table *) bfd_malloc (amt);
d6886 1
a6886 1
	  l = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
d6958 1
a6958 1
  indbuf = (Elf_Internal_Sym **) bfd_malloc2 (symcount, sizeof (*indbuf));
d6978 1
a6978 1
  ssymbuf = (struct elf_symbuf_head *) bfd_malloc (total_size);
d7059 2
a7060 2
  ssymbuf1 = (struct elf_symbuf_head *) elf_tdata (bfd1)->symbuf;
  ssymbuf2 = (struct elf_symbuf_head *) elf_tdata (bfd2)->symbuf;
d7134 2
a7135 4
      symtable1 = (struct elf_symbol *)
          bfd_malloc (count1 * sizeof (struct elf_symbol));
      symtable2 = (struct elf_symbol *)
          bfd_malloc (count2 * sizeof (struct elf_symbol));
d7176 2
a7177 4
  symtable1 = (struct elf_symbol *)
      bfd_malloc (symcount1 * sizeof (struct elf_symbol));
  symtable2 = (struct elf_symbol *)
      bfd_malloc (symcount2 * sizeof (struct elf_symbol));
d7881 2
a7882 2
  const struct elf_link_sort_rela *a = (const struct elf_link_sort_rela *) A;
  const struct elf_link_sort_rela *b = (const struct elf_link_sort_rela *) B;
d7906 2
a7907 2
  const struct elf_link_sort_rela *a = (const struct elf_link_sort_rela *) A;
  const struct elf_link_sort_rela *b = (const struct elf_link_sort_rela *) B;
d8107 1
a8107 1
  sort = (bfd_byte *) bfd_zmalloc (sort_elt * count);
d8276 1
a8276 2
	  destshndx = (Elf_External_Sym_Shndx *) bfd_realloc (destshndx,
                                                              amt * 2);
d8402 1
a8402 1
      extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);
d8470 1
a8470 1
  struct elf_outext_info *eoinfo = (struct elf_outext_info *) data;
d9812 2
a9813 2
      size = (bfd_size_type) bfd_get_reloc_size (howto);
      buf = (bfd_byte *) bfd_zmalloc (size);
d10371 1
a10371 1
  finfo.symbuf = (bfd_byte *) bfd_malloc (amt);
d10380 1
a10380 1
      finfo.symshndxbuf = (Elf_External_Sym_Shndx *) bfd_zmalloc (amt);
d10431 1
a10431 1
      finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
d10447 1
a10447 1
      finfo.internal_relocs = (Elf_Internal_Rela *) bfd_malloc (amt);
d10455 1
a10455 1
      finfo.external_syms = (bfd_byte *) bfd_malloc (amt);
d10460 1
a10460 1
      finfo.internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
d10465 1
a10465 1
      finfo.indices = (long int *) bfd_malloc (amt);
d10470 1
a10470 1
      finfo.sections = (asection **) bfd_malloc (amt);
d10478 1
a10478 1
      finfo.locsym_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
d11083 1
a11083 1
      bfd_byte *contents = (bfd_byte *) bfd_malloc (attr_size);
d11425 1
a11425 2
      struct elf_gc_sweep_symbol_info *inf =
          (struct elf_gc_sweep_symbol_info *) data;
d11806 1
a11806 2
      child->vtable = (struct elf_link_virtual_table_entry *)
          bfd_zalloc (abfd, sizeof (*child->vtable));
d11838 1
a11838 2
      h->vtable = (struct elf_link_virtual_table_entry *)
          bfd_zalloc (abfd, sizeof (*h->vtable));
d11871 1
a11871 1
	  ptr = (bfd_boolean *) bfd_realloc (ptr - 1, bytes);
d11883 1
a11883 1
	ptr = (bfd_boolean *) bfd_zmalloc (bytes);
d11909 1
a11909 1
  struct alloc_got_off_arg *gofarg = (struct alloc_got_off_arg *) arg;
d12009 1
a12009 1
  struct elf_reloc_cookie *rcookie = (struct elf_reloc_cookie *) cookie;
@


1.352.2.2
log
@        Import these patches from the mainline:

        2010-01-21  Nick Clifton  <nickc@@redhat.com>

        * elflink.c (elf_link_add_object_symbols): Look up name of
        undefined symbol both before and after versioning has been
        applied.  Do not bother with symbols that are weakly undefined.

        2009-11-05  Nick Clifton  <nickc@@redhat.com>

        * elflink.c (elf_link_add_object_symbols): Improve error
        message generated when a symbol is left unresolved because a
        --no-add-needed command line option has prevented the
        inclusion of the DSO defining it.

        2009-10-12  Roland McGrath  <roland@@frob.com>

        * elflink.c (elf_link_add_object_symbols, _bfd_elf_merge_symbol):
        Fix %s that should be %B in several message formats.
@
text
@d1113 1
a1113 1
	  (_("%B: TLS definition in %B section %A mismatches non-TLS definition in %B section %A"),
d1117 1
a1117 1
	  (_("%B: TLS reference in %B mismatches non-TLS reference in %B"),
d1121 1
a1121 1
	  (_("%B: TLS definition in %B section %A mismatches non-TLS reference in %B"),
d1125 1
a1125 1
	  (_("%B: TLS reference in %B mismatches non-TLS definition in %B section %A"),
a3868 1
      bfd * undef_bfd = NULL;
a3992 14
	  /* If this is a definition of a symbol which was previously
	     referenced in a non-weak manner then make a note of the bfd
	     that contained the reference.  This is used if we need to
	     refer to the source of the reference later on.  */
	  if (! bfd_is_und_section (sec))
	    {
	      h = elf_link_hash_lookup (elf_hash_table (info), name, FALSE, FALSE, FALSE);

	      if (h != NULL
		  && h->root.type == bfd_link_hash_undefined
		  && h->root.u.undef.abfd)
		undef_bfd = h->root.u.undef.abfd;
	    }

a4099 13
	  /* If necessary, make a second attempt to locate the bfd
	     containing an unresolved, non-weak reference to the
	     current symbol.  */
	  if (! bfd_is_und_section (sec) && undef_bfd == NULL)
	    {
	      h = elf_link_hash_lookup (elf_hash_table (info), name, FALSE, FALSE, FALSE);

	      if (h != NULL
		  && h->root.type == bfd_link_hash_undefined
		  && h->root.u.undef.abfd)
		undef_bfd = h->root.u.undef.abfd;
	    }

d4436 2
a4437 4
		 --no-add-needed is used and the reference was not
		 a weak one.  */
	      if (undef_bfd != NULL
		  && (elf_dyn_lib_class (abfd) & DYN_NO_NEEDED) != 0)
d4440 1
a4440 4
		    (_("%B: undefined reference to symbol '%s'"),
		     undef_bfd, name);
		  (*_bfd_error_handler)
		    (_("note: '%s' is defined in DSO %B so try adding it to the linker command line"),
d4442 1
a4442 1
		  bfd_set_error (bfd_error_invalid_operation);
@


1.351
log
@	* elflink.c (_bfd_elf_adjust_dynamic_symbol): Don't clear plt
	info for STT_GNU_IFUNC.
	* elf32-ppc.c (ppc_elf_check_relocs): Count a needed plt entry
	on got refs in case the symbol turns out to be ifunc.
	(ppc_elf_gc_sweep_hook): Similarly.
	(ppc_elf_adjust_dynamic_symbol): Adjust assertion.
	(allocate_dynrelocs): Don't specially allocate got relocs for ifunc.
	(ppc_elf_size_dynamic_sections): Likewise.
	(ppc_elf_relocate_section): Likewise.
@
text
@d7765 1
d7797 1
d8137 1
d8182 1
d9704 1
d10028 1
d11008 1
@


1.350
log
@        * config/obj-elf.c (obj_elf_type): Add code to support a type of
        gnu_unique_object.
        * doc/as.texinfo: Document new feature of .type directive.
        * NEWS: Mention support for gnu_unique_object symbol type.

        * common.h (STB_GNU_UNIQUE): Define.

        * NEWS: Mention the linker's support for symbols with a binding of
        STB_GNU_UNIQUE.

        * gas/elf/type.s: Add unique global symbol definition.
        * gas/elf/type.e: Add expected readelf output for global unique
        symbol.

        * elfcpp.h (enum STB): Add STB_GNU_UNIQUE.

        * readelf.c (get_symbol_binding): For Linux targeted files return
        UNIQUE for symbols with the STB_GNU_UNIQUE binding.
        * doc/binutils.texi: Document the meaning of the 'u' symbol
        binding in the output of nm and objdump --syms.

        * elf-bfd.h (struct elf_link_hash_entry): Add unique_global field.
        * elf.c (swap_out_syms): Set binding to STB_GNU_UNIQUE for symbols
        with the BSF_GNU_UNIQUE flag bit set.
        * elfcode.h (elf_slurp_symbol_table): Set the BSF_GNU_UNIQUE flag
        for symbols with STB_GNU_UNIQUE binding.
        * elflink.c (_bfd_elf_merge_symbol): Set unique_global for symbols
        with the STB_GNU_UNIQUE binding.
        (elf_link_add_object_symbols): Set the BSF_GNU_UNIQUE flag for
        symbols with STB_GNU_UNIQUE binding.  Set STB_GNU_UNIQUE for
        symbols with the unique_global field set.
        (elf_link_output_extsym): Set unique_global field for symbols with
        the STB_GNU_UNIQUE binding.
        * syms.c (struct bfd_symbol): Define BSF_GNU_UNIQUE flag bit.
        (bfd_print_symbol_vandf): Print a 'u' character for BSF_GNU_UNIQUE
        symbols.
        (bfd_decode_symclass): Return a 'u' character for BSF_GNU_UNIQUE
        symbols.
        * bfd-in2.h: Regenerate.
@
text
@d2608 1
@


1.349
log
@2009-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	 * elflink.c (elf_link_output_extsym): Revert the last change.
@
text
@d1251 3
d3877 1
a3877 1
      if (bind == STB_LOCAL)
d3879 1
d3885 2
a3886 3
	}
      else if (bind == STB_GLOBAL)
	{
d3889 11
a3899 5
	}
      else if (bind == STB_WEAK)
	flags = BSF_WEAK;
      else
	{
d3901 1
d4153 1
d4155 1
d8586 2
@


1.348
log
@2009-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	 PR ld/10433
	 * elflink.c (elf_link_output_extsym): Special case ifunc syms
	 when ref_regular, not def_regular.
@
text
@d8663 1
a8663 2
     STT_GNU_IFUNC symbol must go through PLT only if it is ever
     referenced.  */
d8665 1
a8665 1
       && h->ref_regular
@


1.347
log
@bfd/

2009-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	 PR ld/10426
	 * elflink.c (elf_link_add_object_symbols): Turn an IFUNC symbol
	 from a DSO into a normal FUNC symbol.
	 (elf_link_output_extsym): Turn an undefined IFUNC symbol into
	 a normal FUNC symbol.

ld/testsuite/

2009-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10426
	* ld-ifunc/ifunc.exp: Check test-1 and libtest-2.so.  Updated.

	* ld-ifunc/test-1.c: New.
	* ld-ifunc/test-2.c: Likewise.
@
text
@d8663 2
a8664 1
     STT_GNU_IFUNC symbol must go through PLT.  */
d8666 1
a8666 1
       && h->def_regular
@


1.346
log
@	* elf-bfd.h (struct elf_link_hash_entry): Clarify ref_regular
	and ref_regular_nonweak comment.
	* elflink.c (elf_link_output_extsym): Special case ifunc syms
	when def_regular, not ref_regular.
	(elf_link_add_object_symbols): Don't set needs_plt on ifunc syms,..
	* elf32-i386.c (elf_i386_check_relocs): ..set it here instead..
	* elf64-x86-64.c (elf64_x86_64_check_relocs): ..and here.
@
text
@d4282 15
a4296 7
	      if (h->type != STT_NOTYPE
		  && h->type != ELF_ST_TYPE (isym->st_info)
		  && ! type_change_ok)
		(*_bfd_error_handler)
		  (_("Warning: type of symbol `%s' changed"
		     " from %d to %d in %B"),
		   abfd, name, h->type, ELF_ST_TYPE (isym->st_info));
d4298 2
a4299 1
	      h->type = ELF_ST_TYPE (isym->st_info);
d8695 5
d8705 1
a8705 1
      sym.st_info = ELF_ST_INFO (bindtype, ELF_ST_TYPE (sym.st_info));
@


1.345
log
@2009-06-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_link_add_object_symbols): Avoid warning
	from -Wjump-misses-init in gcc 4.5.0.
@
text
@a4292 4
	  /* STT_GNU_IFUNC symbol must go through PLT.  */
	  if (h->type == STT_GNU_IFUNC)
	    h->needs_plt = 1;

d8656 1
a8656 1
       && h->ref_regular
@


1.344
log
@        * elflink.c (elf_link_sort_relocs): Return early if there are no
        relocs to sort.
@
text
@d3552 5
a3556 1
	    goto error_free_dyn;
d3640 1
a3640 5
		    {
		    error_free_dyn:
		      free (dynbuf);
		      goto error_return;
		    }
@


1.343
log
@2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-arm.c (create_got_section): Get existing .rela.got
	section.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	* elf32-lm32.c (create_got_section): Likewise.
	* elf32-m32r.c (create_got_section): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.

	* elflink.c (_bfd_elf_create_got_section): Properly initialize
	the GOT size.
@
text
@d8085 2
@


1.342
log
@2009-06-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in (elf): Add elf-ifunc.lo.

	* configure: Regenerated.
	* Makefile.in: Likewise.

	* elf-bfd.h (elf_link_hash_table): Add sgot, sgotplt,
	srelgot, splt, srelplt, igotplt, iplt, irelplt and irelifunc.

	* elf32-i386.c (elf_i386_link_hash_table): Remove sgot,
	sgotplt, srelgot, splt, srelplt, igotplt, iplt, irelplt and
	irelifunc.
	(elf_i386_link_hash_table_create): Likewise.
	(elf_i386_create_dynamic_sections): Likewise.
	(elf_i386_check_relocs): Likewise.
	(elf_i386_allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(elf_i386_finish_dynamic_sections): Likewise.
	(elf_i386_create_got_section): Removed.

	* elf64-x86-64.c (elf64_x86_64_link_hash_table): Remove sgot,
	sgotplt, srelgot, splt, srelplt, igotplt, iplt, irelplt and
	irelifunc.
	(elf64_x86_64_compute_jump_table_size): Updated.
	(elf64_x86_64_link_hash_table_create): Likewise.
	(elf64_x86_64_create_dynamic_sections): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	(elf64_x86_64_allocate_dynrelocs): Likewise.
	(elf64_x86_64_size_dynamic_sections): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
	(elf64_x86_64_finish_dynamic_symbol): Likewise.
	(elf64_x86_64_finish_dynamic_sections): Likewise.
	(elf64_x86_64_create_got_section): Removed.

	* elflink.c (_bfd_elf_create_got_section): Use log_file_align
	for pointer alignment.  Set up section pointers.
	(_bfd_elf_create_dynamic_sections): Likewise.
	(_bfd_elf_create_ifunc_sections): Moved to ...
	* elf-ifunc.c: Here.  New.

	* Makefile.am (BFD32_BACKENDS): Add elf-ifunc.lo.
	(BFD32_BACKENDS_CFILES): Add elf-ifunc.c.
	Run "make dep-am".
@
text
@a112 6
  s = bfd_make_section_with_flags (abfd, ".got", flags);
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  htab->sgot = s;

d123 6
d139 3
a154 3
  /* The first bit of the global offset table is the header.  */
  s->size += bed->got_header_size;

@


1.341
log
@bfd/

2009-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_link_hash_table): Add irelifunc.
	(elf_i386_link_hash_table_create): Initialize irelifunc.
	(elf_i386_check_relocs): Updated.  Set up irelifunc for
	shared objects.
	(elf_i386_allocate_dynrelocs): Use irelifunc for dynamic
	relocation for non-GOT reference of STT_GNU_IFUNC symbol in
	shared objects.
	(elf_i386_relocate_section): Likewise.

	* elf64-x86-64.c (elf64_x86_64_link_hash_table): Add irelifunc.
	(elf64_x86_64_link_hash_table_create): Initialize irelifunc.
	(elf64_x86_64_check_relocs): Updated.  Set up irelifunc for
	shared objects.
	(elf64_x86_64_allocate_dynrelocs): Use irelifunc for dynamic
	relocation for non-GOT reference of STT_GNU_IFUNC symbol in
	shared objects.
	(elf64_x86_64_relocate_section): Likewise.

	* elf-bfd.h (_bfd_elf_create_static_ifunc_sections): Renamed to
	...
	(_bfd_elf_create_ifunc_sections): This.

	* elflink.c (_bfd_elf_create_static_ifunc_sections): Renamd to
	...
	(_bfd_elf_create_ifunc_sections): This.  Create .rel[a].ifunc
	for shared objects.

ld/

2009-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* scripttempl/elf.sc: Add .rel.ifunc and .rela.ifunc.
@
text
@d104 1
a104 1
  int ptralign;
a110 15
  switch (bed->s->arch_size)
    {
    case 32:
      ptralign = 2;
      break;

    case 64:
      ptralign = 3;
      break;

    default:
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

d115 1
a115 1
      || !bfd_set_section_alignment (abfd, s, ptralign))
d117 11
d133 2
a134 1
	  || !bfd_set_section_alignment (abfd, s, ptralign))
d136 1
d145 2
a146 1
      h = _bfd_elf_define_linkage_sym (abfd, info, s, "_GLOBAL_OFFSET_TABLE_");
d305 1
d326 1
d346 1
a12495 92

/* Create sections needed by STT_GNU_IFUNC symbol.  */

bfd_boolean
_bfd_elf_create_ifunc_sections (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags, pltflags;
  int ptralign;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  flags = bed->dynamic_sec_flags;
  pltflags = flags;
  if (bed->plt_not_loaded)
    /* We do not clear SEC_ALLOC here because we still want the OS to
       allocate space for the section; it's just that there's nothing
       to read in from the object file.  */
    pltflags &= ~ (SEC_CODE | SEC_LOAD | SEC_HAS_CONTENTS);
  else
    pltflags |= SEC_ALLOC | SEC_CODE | SEC_LOAD;
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  if (info->shared)
    {
      /* We need to create .rel[a].ifunc for shared objects.  */
      const char *rel_sec = (bed->rela_plts_and_copies_p
			     ? ".rela.ifunc" : ".rel.ifunc");

      /* This function should be called only once.  */
      s = bfd_get_section_by_name (abfd, rel_sec);
      if (s != NULL)
	abort ();

      s = bfd_make_section_with_flags (abfd, rel_sec,
				       flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s,
					  bed->s->log_file_align))
	return FALSE;
    }
  else
    {
      /* This function should be called only once.  */
      s = bfd_get_section_by_name (abfd, ".iplt");
      if (s != NULL)
	abort ();

      /* We need to create .iplt, .rel[a].iplt, .igot and .igot.plt
	 for static executables.   */
      s = bfd_make_section_with_flags (abfd, ".iplt", pltflags);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
	return FALSE;

      s = bfd_make_section_with_flags (abfd,
				       (bed->rela_plts_and_copies_p
					? ".rela.iplt" : ".rel.iplt"),
				       flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s,
					  bed->s->log_file_align))
	return FALSE;

      switch (bed->s->arch_size)
	{ 
	case 32:
	  ptralign = 2;
	  break;

	case 64:
	  ptralign = 3;
	  break;

	default:
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      /* We don't need the .igot section if we have the .igot.plt
	 section.  */
      if (bed->want_got_plt)
	s = bfd_make_section_with_flags (abfd, ".igot.plt", flags);
      else
	s = bfd_make_section_with_flags (abfd, ".igot", flags);
      if (s == NULL
	  || !bfd_set_section_alignment (abfd, s, ptralign))
	return FALSE;
    }

  return TRUE;
}
@


1.340
log
@bfd/

2009-06-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (struct bfd_elf_section_data): Remove indirect_relocs.
	(_bfd_elf_make_ifunc_reloc_section): Removed.
	(_bfd_elf_is_ifunc_symbol): Likewise.
	(_bfd_elf_create_static_ifunc_sections): New.

	* elflink.c (_bfd_elf_adjust_dynamic_symbol): Move STT_GNU_IFUNC
	symbol check to ...
	(elf_link_add_object_symbols): Here.
	(_bfd_elf_link_hash_hide_symbol): Don't clean plt on
	STT_GNU_IFUNC symbol.
	(elf_link_output_extsym): Call elf_backend_finish_dynamic_symbol
	if a STT_GNU_IFUNC symbol is referenced in a non-shared object.
	(IFUNC_INFIX): Removed.
	(get_ifunc_reloc_section_name): Likewise.
	(_bfd_elf_make_ifunc_reloc_section): Likewise.
	(_bfd_elf_is_ifunc_symbol): Likewise.
	(_bfd_elf_create_static_ifunc_sections): New.

ld/

2009-06-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* scripttempl/elf.sc (PLT): Add "*(.iplt)".
	(GOT): Add "*(.igot.plt)a" and "*(.igot)".
	(GOTPLT): Add "*(.igot)".
	(__rel_iplt_start): New.
	(__rel_iplt_end): Likewise.
	(__rela_iplt_start): Likewise.
	(__rela_iplt_end): Likewise.
@
text
@d12495 1
a12495 2
/* Create sections needed by STT_GNU_IFUNC symbol for static
   executables.  */
d12498 1
a12498 2
_bfd_elf_create_static_ifunc_sections (bfd *abfd,
				       struct bfd_link_info *info)
d12503 1
a12503 1
  const struct elf_backend_data *bed;
a12504 11
  /* Should never be called for shared library.  */
  BFD_ASSERT (!info->shared);

  /* This function may be called more than once.  */
  s = bfd_get_section_by_name (abfd, ".iplt");
  if (s != NULL)
    return TRUE;

  bed = get_elf_backend_data (abfd);

  /* We need to create .iplt, .rel[a].iplt, .igot, .igot.plt,  */
a12505 1

d12517 1
a12517 14
  s = bfd_make_section_with_flags (abfd, ".iplt", pltflags);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;

  s = bfd_make_section_with_flags (abfd,
				   (bed->rela_plts_and_copies_p
				    ? ".rela.iplt" : ".rel.iplt"),
				   flags | SEC_READONLY);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  switch (bed->s->arch_size)
d12519 8
a12526 12
    case 32:
      ptralign = 2;
      break;

    case 64:
      ptralign = 3;
      break;

    default:
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }
d12528 2
a12529 6
  /* We don't need the .igot section if we have the .igot.plt
     section.  */

  if (bed->want_got_plt)
    {
      s = bfd_make_section_with_flags (abfd, ".igot.plt", flags);
d12531 2
a12532 1
	  || !bfd_set_section_alignment (abfd, s, ptralign))
d12537 42
a12578 1
      s = bfd_make_section_with_flags (abfd, ".igot", flags);
@


1.339
log
@2009-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_is_ifunc_symbol): New.

	* elf32-i386.c (is_indirect_symbol): Renamed to ...
	* elflink.c (_bfd_elf_is_ifunc_symbol): This.

	* elf32-i386.c (allocate_dynrelocs): Updated.
	(elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(elf64_x86_64_relocate_section): Likewise.

	* elf64-x86-64.c (is_indirect_symbol): Removed.
@
text
@a2677 7

  if (h->type == STT_GNU_IFUNC
      && (bed->elf_osabi == ELFOSABI_LINUX
	  /* GNU/Linux is still using the default value 0.  */
	  || bed->elf_osabi == ELFOSABI_NONE))
    h->needs_plt = 1;

d4291 4
d6669 6
a6674 2
  h->plt = elf_hash_table (info)->init_plt_offset;
  h->needs_plt = 0;
d8653 12
a8664 8
     forced local syms when non-shared is due to a historical quirk.  */
  if ((h->dynindx != -1
       || h->forced_local)
      && ((finfo->info->shared
	   && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak))
	  || !h->forced_local)
      && elf_hash_table (finfo->info)->dynamic_sections_created)
d12495 2
a12496 2
/* Returns the name of the ifunc using dynamic reloc section associated with SEC.  */
#define IFUNC_INFIX ".ifunc"
d12498 3
a12500 3
static const char *
get_ifunc_reloc_section_name (bfd *       abfd,
			      asection *  sec)
d12502 4
a12505 5
  const char *  dot;
  char *  name;
  const char *  base_name;
  unsigned int  strndx = elf_elfheader (abfd)->e_shstrndx;
  unsigned int  shnam = elf_section_data (sec)->rel_hdr.sh_name;
d12507 2
a12508 3
  base_name = bfd_elf_string_from_elf_section (abfd, strndx, shnam);
  if (base_name == NULL)
    return NULL;
d12510 4
a12513 3
  dot = strchr (base_name + 1, '.');
  name = bfd_alloc (abfd, strlen (base_name) + strlen (IFUNC_INFIX) + 1);
  sprintf (name, "%.*s%s%s", (int)(dot - base_name), base_name, IFUNC_INFIX, dot);
d12515 1
a12515 2
  return name;
}
d12517 2
a12518 4
/* Like _bfd_elf_make_dynamic_reloc_section but it creates a
   section for holding relocs against symbols with the STT_GNU_IFUNC
   type.  The section is attached to the OWNER bfd but it is created
   with a name based on SEC from ABFD.  */
d12520 10
a12529 7
asection *
_bfd_elf_make_ifunc_reloc_section (bfd *         abfd,
				   asection *    sec,
				   bfd *         owner,
				   unsigned int  align)
{
  asection * reloc_sec = elf_section_data (sec)->indirect_relocs;
d12531 4
a12534 3
  if (reloc_sec == NULL)
    {
      const char * name = get_ifunc_reloc_section_name (abfd, sec);
d12536 7
a12542 2
      if (name == NULL)
	return NULL;
d12544 5
a12548 1
      reloc_sec = bfd_get_section_by_name (owner, name);
d12550 3
a12552 3
      if (reloc_sec == NULL)
	{
	  flagword flags;
d12554 4
a12557 3
	  flags = (SEC_HAS_CONTENTS | SEC_READONLY | SEC_IN_MEMORY | SEC_LINKER_CREATED);
	  if ((sec->flags & SEC_ALLOC) != 0)
	    flags |= SEC_ALLOC | SEC_LOAD;
d12559 2
a12560 6
	  reloc_sec = bfd_make_section_with_flags (owner, name, flags);
	  
	  if (reloc_sec != NULL
	      && ! bfd_set_section_alignment (owner, reloc_sec, align))
	    reloc_sec = NULL;
	}
d12562 13
a12574 1
      elf_section_data (sec)->indirect_relocs = reloc_sec;
d12577 1
a12577 20
  return reloc_sec;
}

/* Returns true if the hash entry refers to a symbol marked for
   indirect handling during reloc processing.  */

bfd_boolean
_bfd_elf_is_ifunc_symbol (bfd *abfd, struct elf_link_hash_entry *h)
{
  const struct elf_backend_data * bed;

  if (abfd == NULL || h == NULL)
    return FALSE;

  bed = get_elf_backend_data (abfd);

  /* GNU/Linux is still using the default value ELFOSABI_NONE.  */
  return (h->type == STT_GNU_IFUNC
	  && (bed->elf_osabi == ELFOSABI_LINUX
	      || bed->elf_osabi == ELFOSABI_NONE));
@


1.338
log
@	* elflink.c (elf_link_input_bfd): Correct *pindex change in last
	commit.
@
text
@d12556 19
@


1.337
log
@	* elf-bfd.h (struct elf_backend_data
	<elf_backend_link_output_symbol_hook>): Return an int.
	* elf64-ppc.c (ppc64_elf_output_symbol_hook): Return 2 to drop
	symbols on deleted .opd entries.
	* elflink.c (elf_link_output_sym): Return without outputting sym
	if output_symbol_hook returns 2.
	(elf_link_output_extsym): Don't assign h->indx when symbol discarded.
	Abort if we must not discard sym.
	(elf_link_input_bfd): Similarly, don't set finfo->indices for
	local syms.
	(bfd_elf_final_link): Adjust elf_link_output_sym calls.
	* elf-vxworks.c (elf_vxworks_link_output_symbol_hook): Adjust for
	elf_backend_link_output_symbol_hook return type change.
	* elf32-arm.c (output_arch_syminfo): Likewise.
	(elf32_arm_output_map_sym, elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_output_arch_local_syms): Likewise.
	* elf32-cr16c.c (elf32_cr16c_link_output_symbol_hook): Likewise.
	* elf32-score.c (s3_bfd_score_elf_link_output_symbol_hook): Likewise.
	(bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score.h (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Likewise.
	* elf32-spu.c (spu_elf_output_symbol_hook): Likewise.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
@
text
@a9067 2
      *pindex = bfd_get_symcount (output_bfd);

@


1.336
log
@bfd/ChangeLog

	* elflink.c (find_version_for_sym):  Remove from here, ...
	* linker.c (bfd_find_version_for_sym):  ... rename, replace
	here, make public and update all callers.
	* bfd-in2.h:  Regenerate.

ld/ChangeLog

	* NEWS:  Mention new feature.
	* ld.texinfo (--version-script):  Document extent of PE support.
	(WIN32):  Mention --version-script.  Extend auto-export description.
	* pe-dll.c (process_def_file):  Use version script info to filter
	symbols from auto-export.
	* testsuite/ld-pe/vers-script-1.d:  New file.
	* testsuite/ld-pe/vers-script-2.d:  New file.
	* testsuite/ld-pe/vers-script-3.d:  New file.
	* testsuite/ld-pe/vers-script-4.d:  New file.
	* testsuite/ld-pe/vers-script-1.ver:  New file.
	* testsuite/ld-pe/vers-script-2.ver:  New file.
	* testsuite/ld-pe/vers-script-3.ver:  New file.
	* testsuite/ld-pe/vers-script-4.ver:  New file.
	* testsuite/ld-pe/vers-script-dll.c:  New file.
	* testsuite/ld-pe/vers-script.exp:  New test script.
@
text
@d8199 1
a8199 1
static bfd_boolean
d8208 1
a8208 1
  bfd_boolean (*output_symbol_hook)
d8217 3
a8219 2
      if (! (*output_symbol_hook) (finfo->info, name, elfsym, input_sec, h))
	return FALSE;
d8231 1
a8231 1
	return FALSE;
d8237 1
a8237 1
	return FALSE;
d8251 1
a8251 1
	    return FALSE;
d8263 1
a8263 1
  return TRUE;
d8449 2
d8793 3
a8795 3
  h->indx = bfd_get_symcount (finfo->output_bfd);

  if (! elf_link_output_sym (finfo, h->root.root.string, &sym, input_sec, h))
d8800 4
d8971 2
a9059 2
      /* If we get here, we are going to output this symbol.  */

d9089 3
a9091 1
      if (! elf_link_output_sym (finfo, name, &osym, isec, NULL))
d9093 2
d9143 2
d9159 3
a9161 2
		  finfo->indices[symndx] = bfd_get_symcount (output_bfd);
		  if (! elf_link_output_sym (finfo, name, &sym, o, NULL))
d9163 4
d9557 1
d9597 4
a9600 5
			  finfo->indices[r_symndx]
			    = bfd_get_symcount (output_bfd);

			  if (! elf_link_output_sym (finfo, name, &sym, sec,
						     NULL))
d9602 4
d10357 2
a10358 2
      if (! elf_link_output_sym (&finfo, NULL, &elfsym, bfd_und_section_ptr,
				 NULL))
d10383 1
a10383 1
	      if (!elf_link_output_sym (&finfo, NULL, &elfsym, o, NULL))
d10559 1
a10559 1
      typedef bfd_boolean (*out_sym_func)
d10670 1
a10670 1
      typedef bfd_boolean (*out_sym_func)
@


1.335
log
@include/elf
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * common.h (STT_GNU_IFUNC): Define.

elfcpp
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * (enum STT): Add STT_GNU_IFUNC.

gas
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * config/obj-elf.c (obj_elf_type): Add support for a
        gnu_indirect_function type.
        * config/tc-i386.c (tc_i386_fix_adjustable): Do not adjust fixups
        against indirect function symbols.
        * doc/as.texinfo (.type): Document the support for the
        gnu_indirect_function symbol type.
        * NEWS: Mention the new feature.

gas/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * gas/elf/elf.exp: Extend type test to include an ifunc symbol.
        Provide an alternative test for targets which do not support ifunc
        symbols.
        (type.s): Add entry for an ifunc symbol.
        (type.e): Add ifunc entry to expected symbol dump.
        (section2.e-armelf): Add  entry for ifunc symbol.
        (type-noifunc.s): New file.
        (type-noifunc.e): New file.

bfd/
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs
        section pointer.
        (struct elf_obj_data): Add has_ifunc_symbols boolean.
        * elf.c (swap_out_syms): Convert BSF_GNU_INDIRECT_FUNCTION flags
        into a STT_GNU_IFUNC symbol type.
        (_bfd_elf_is_function_type): Accept STT_GNU_IFUNC as a function
        type.
        (_bfd_elf_set_osabi): Set the osasbi field to ELFOSABI_LINUX if
        the binary contains ifunc symbols.
        * elfcode.h (elf_slurp_symbol_table): Translate the STT_GNU_IFUNC
        symbol type into a BSF_GNU_INDIRECT_FUNCTION flag.
        * elf32-i386.c (is_indirect_function): New function.
        (elf_i386_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf_i386_relocate_section): Emit a reloc against an ifunc symbol
        if necessary.
        (elf_i386_add_symbol_hook): New function. Set the
        has_ifunc_symbols field of the elf_obj_data structure if an ifunc
        symbol is encountered.
        (elf_backend_post_process_headers): Define.
        (elf_backend_add_symbol_hook): Define.
        (elf_i386_post_process_headers): Rename to
        elf_i388_fbsd_post_process_headers.
        * elf64-x86_64.c (IS_X86_64_PCREL_TYPE): New macro.
        (is_indirect_function): New function.
        (elf64_x86_64_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf64_x86_64_relocate_section): Emit a reloc against an ifunc
        symbol if necessary.
        (elf_i386_add_symbol_hook): Set the has_ifunc_symbols field of the
        elf_obj_data structure if an ifunc symbol is encountered.
        (elf_backend_post_process_headers): Define.
        * elflink.c (_bfd_elf_adjust_dynamic_symbol): Always create a PLT
        if we have ifunc symbols to handle.
        (get_ifunc_reloc_section_name): New function.  Computes the name
        for an ifunc section.
        (_bfd_elf_make_ifunc_reloc_section): New function.  Creates a
        section to hold ifunc relocs.
        * syms.c (BSF_GNU_INDIRECT_FUNCTION): Define.
        (bfd_print_symbol_vandf): Handle ifunc symbols.
        (bfd_decode_symclass): Likewise.
        * bfd-in2.h: Regenerate.

binutils
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * readelf.c (dump_relocations): Display a relocation against an
        ifunc symbol as if it were a function invocation.
        (get_symbol_type): Handle STT_GNU_IFUNC.

ld
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * NEWS: Mention support for IFUNC symbols.

ld/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * ld-ifunc: New directory.
        * ld-ifunc/ifunc.exp: New file: Run the IFUNC tests.
        * ld-ifunc/prog.c: New file.
        * ld-ifunc/lib.c: New file.
@
text
@a1800 74
static struct bfd_elf_version_tree *
find_version_for_sym (struct bfd_elf_version_tree *verdefs,
		      const char *sym_name,
		      bfd_boolean *hide)
{
  struct bfd_elf_version_tree *t;
  struct bfd_elf_version_tree *local_ver, *global_ver, *exist_ver;

  local_ver = NULL;
  global_ver = NULL;
  exist_ver = NULL;
  for (t = verdefs; t != NULL; t = t->next)
    {
      if (t->globals.list != NULL)
	{
	  struct bfd_elf_version_expr *d = NULL;

	  while ((d = (*t->match) (&t->globals, d, sym_name)) != NULL)
	    {
	      global_ver = t;
	      if (d->symver)
		exist_ver = t;
	      d->script = 1;
	      /* If the match is a wildcard pattern, keep looking for
		 a more explicit, perhaps even local, match.  */
	      if (d->literal)
		break;
	    }

	  if (d != NULL)
	    break;
	}

      if (t->locals.list != NULL)
	{
	  struct bfd_elf_version_expr *d = NULL;

	  while ((d = (*t->match) (&t->locals, d, sym_name)) != NULL)
	    {
	      local_ver = t;
	      /* If the match is a wildcard pattern, keep looking for
		 a more explicit, perhaps even global, match.  */
	      if (d->literal)
		{
		  /* An exact match overrides a global wildcard.  */
		  global_ver = NULL;
		  break;
		}
	    }

	  if (d != NULL)
	    break;
	}
    }

  if (global_ver != NULL)
    {
      /* If we already have a versioned symbol that matches the
	 node for this symbol, then we don't want to create a
	 duplicate from the unversioned symbol.  Instead hide the
	 unversioned symbol.  */
      *hide = exist_ver == global_ver;
      return global_ver;
    }

  if (local_ver != NULL)
    {
      *hide = TRUE;
      return local_ver;
    }

  return NULL;
}

d1827 1
a1827 1
	  || (find_version_for_sym (eif->verdefs, h->root.root.string, &hide)
d2089 1
a2089 1
      h->verinfo.vertree = find_version_for_sym (sinfo->verdefs,
@


1.334
log
@bfd/

2009-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_link_add_object_symbols): Warn alternate ELF
	machine code.

include/

2009-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Add warn_alternate_em.

ld/

2009-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (option_values): Add OPTION_WARN_ALTERNATE_EM.
	(ld_options): Likewise.
	(parse_args): Likewise.

	* ld.texinfo: Document --warn-alternate-em.

	* NEWS: Mention --warn-alternate-em.
@
text
@d2752 7
d12543 67
@


1.333
log
@2009-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_section_already_linked): Add `\n' for
	info->callbacks->einfo.
	* linker.c (_bfd_generic_section_already_linked): Likewise.
@
text
@d3428 1
d3484 11
@


1.332
log
@* elflink.c (elf_link_input_bfd): Don't try to resolve complex
relocs when doing a relocatable link.
@
text
@d12368 1
a12368 1
    info->callbacks->einfo (_("%F%P: already_linked_table: %E"));
@


1.331
log
@        PR 9934
        * elf-bfd.h (NUM_SHDR_ENTRIES): Cope with an empty section.
        * elflink.c (elf_link_read_relocs_from_section): Use
        NUM_SHDR_ENTRIES.  Gracefully handle the case where there are
        relocs but no symbol table.
        * elf32-arm.c (elf32_arm_check_relocs): Likewise.
@
text
@d9332 2
a9333 1
	      if (s_type == STT_RELC || s_type == STT_SRELC)
@


1.330
log
@        PR 9827
        * elflink.c (bfd_elf_final_link): When counting the relocations,
        if the header size has not been set yet then assume that it will
        match the output section's reloc type.
@
text
@d2205 1
a2205 1
  nsyms = symtab_hdr->sh_size / symtab_hdr->sh_entsize;
d2231 14
a2244 1
      if ((size_t) r_symndx >= nsyms)
d2247 2
a2248 2
	    (_("%B: bad reloc symbol index (0x%lx >= 0x%lx)"
	       " for offset 0x%lx in section `%A'"),
@


1.329
log
@binutils/
	* NEWS: Mention --as-needed change.
ld/
	* ld.texinfo (--as-needed): Update.
bfd/
	* elflink.c (on_needed_list): New function.
	(elf_link_add_object_symbols): Link in --as-needed libs if they
	satisfy undefined symbols in other libs.
@
text
@d10231 7
a10237 2
	      BFD_ASSERT (entsize1 == bed->s->sizeof_rel
			  || entsize1 == bed->s->sizeof_rela);
@


1.328
log
@2009-01-29  Daniel Jacobowitz  <dan@@codesourcery.com>
            Mark Shinwell  <shinwell@@codesourcery.com>
            Catherine Moore  <clm@@codesourcery.com>

	* elf-attrs.c, elflink.c, elfxx-mips.c: Correct typos in comments.
@
text
@d3202 10
d4447 5
a4451 2
	      && dynsym
	      && h->ref_regular)
@


1.327
log
@	PR 6022
	* elflink.c (find_version_for_sym): New function split out from,
	but without export_dynamic test, ..
	(_bfd_elf_link_assign_sym_version): ..here.
	(_bfd_elf_export_symbol): Use it.
@
text
@d1265 1
a1265 1
  /* Allow changes between different types of funciton symbol.  */
@


1.326
log
@	* elf-bfd.h (struct elf_assign_sym_version_info): Delete.
	(struct elf_info_failed, struct elf_find_verdep_info): Move to..
	* elflink.c: ..here, somewhat modified.
	* elf-bfd.h (_bfd_elf_add_default_symbol, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_link_size_reloc_section,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, bfd_elf_link_mark_dynamic_symbol): Don't
	declare..
	* elflink.c: ..and make static here.
	(_bfd_elf_link_find_version_dependencies): Adjust for removal
	of output_bfd from struct elf_find_verdep_info.
	(_bfd_elf_link_assign_sym_version): Similarly adjust to use
	struct elf_info_failed.
	(bfd_elf_size_dynamic_sections): Adjust.
@
text
@d1801 74
d1898 1
a1898 19
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;

      for (t = eif->verdefs; t != NULL; t = t->next)
	{
	  if (t->globals.list != NULL)
	    {
	      d = (*t->match) (&t->globals, NULL, h->root.root.string);
	      if (d != NULL)
		goto doit;
	    }

	  if (t->locals.list != NULL)
	    {
	      d = (*t->match) (&t->locals, NULL, h->root.root.string);
	      if (d != NULL)
		return TRUE;
	    }
	}
d1900 3
a1902 1
      if (!eif->verdefs)
a1903 1
	doit:
d2161 1
a2161 54
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_tree *local_ver, *global_ver, *exist_ver;
      struct bfd_elf_version_expr *d;

      /* See if can find what version this symbol is in.  If the
	 symbol is supposed to be local, then don't actually register
	 it.  */
      local_ver = NULL;
      global_ver = NULL;
      exist_ver = NULL;
      for (t = sinfo->verdefs; t != NULL; t = t->next)
	{
	  if (t->globals.list != NULL)
	    {
	      d = NULL;
	      while ((d = (*t->match) (&t->globals, d,
				       h->root.root.string)) != NULL)
		{
		  global_ver = t;
		  local_ver = NULL;
		  if (d->symver)
		    exist_ver = t;
		  d->script = 1;
		  /* If the match is a wildcard pattern, keep looking for
		     a more explicit, perhaps even local, match.  */
		  if (d->literal)
		    break;
		}

	      if (d != NULL)
		break;
	    }

	  if (t->locals.list != NULL)
	    {
	      d = NULL;
	      while ((d = (*t->match) (&t->locals, d,
				       h->root.root.string)) != NULL)
		{
		  local_ver = t;
		  /* If the match is a wildcard pattern, keep looking for
		     a more explicit, perhaps even global, match.  */
		  if (d->literal)
		    {
		      /* An exact match overrides a global wildcard.  */
		      global_ver = NULL;
		      break;
		    }
		}

	      if (d != NULL)
		break;
	    }
	}
d2163 4
a2166 17
      if (global_ver != NULL)
	{
	  h->verinfo.vertree = global_ver;
	  /* If we already have a versioned symbol that matches the
	     node for this symbol, then we don't want to create a
	     duplicate from the unversioned symbol.  Instead hide the
	     unversioned symbol.  */
	  if (exist_ver == global_ver)
	    (*bed->elf_backend_hide_symbol) (info, h, TRUE);
	}
      else if (local_ver != NULL)
	{
	  h->verinfo.vertree = local_ver;
	  if (!info->export_dynamic
	      || exist_ver == local_ver)
	    (*bed->elf_backend_hide_symbol) (info, h, TRUE);
	}
@


1.325
log
@bfd/

2009-01-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/9727
	* elflink.c (elf_gc_sweep): Exclude the group section if the
	first member of the section group is excluded.

ld/testsuite/

2009-01-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/9727
	* ld-elf/group8.s: New.
	* ld-elf/group8a.d: Likewise.
	* ld-elf/group8b.d: Likewise.
	* ld-elf/group9.s: Likewise.
	* ld-elf/group9a.d: Likewise.
	* ld-elf/group9b.d: Likewise.
@
text
@d33 26
d467 1
a467 1
void
d1567 1
a1567 1
bfd_boolean
d1804 1
a1804 1
bfd_boolean
d1863 1
a1863 1
bfd_boolean
d1884 3
a1886 1
  for (t = elf_tdata (rinfo->output_bfd)->verref; t != NULL; t = t->vn_nextref)
d1903 1
a1903 1
      t = bfd_zalloc (rinfo->output_bfd, amt);
d1911 2
a1912 2
      t->vn_nextref = elf_tdata (rinfo->output_bfd)->verref;
      elf_tdata (rinfo->output_bfd)->verref = t;
d1916 1
a1916 1
  a = bfd_zalloc (rinfo->output_bfd, amt);
d1947 1
a1947 1
bfd_boolean
d1950 1
a1950 1
  struct elf_assign_sym_version_info *sinfo;
d1978 1
a1978 1
  bed = get_elf_backend_data (sinfo->output_bfd);
d2061 1
a2061 1
	  t = bfd_zalloc (sinfo->output_bfd, amt);
d2090 1
a2090 1
	     sinfo->output_bfd, h->root.root.string);
d2354 1
a2354 1
bfd_boolean
d2493 1
a2493 1
bfd_boolean
d2636 1
a2636 1
bfd_boolean
d2806 1
a2806 1
bfd_boolean
d5479 1
a5479 1
  struct elf_assign_sym_version_info asvinfo;
a5689 1
      asvinfo.output_bfd = output_bfd;
a6093 1
	sinfo.output_bfd = output_bfd;
@


1.324
log
@bfd/
	* elflink.c (_bfd_elf_section_already_linked): Handle g++-3.4
	relocations in `.gnu.linkonce.r.*' referencing its `.gnu.linkonce.t.*'.

ld/testsuite/
	* ld-elf/linkoncerdiff.d, ld-elf/linkoncerdiff1.s,
	ld-elf/linkoncerdiff2.s: New.
@
text
@d11400 15
a11414 4
	  /* Keep debug and special sections.  */
	  if ((o->flags & (SEC_DEBUGGING | SEC_LINKER_CREATED)) != 0
	      || (o->flags & (SEC_ALLOC | SEC_LOAD | SEC_RELOC)) == 0)
	    o->gc_mark = 1;
@


1.323
log
@2009-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* coff-ppc.c: Add 2009 to Copyright.
	* elf32-cris.c: Likewise.
	* elflink.c: Likewise.
@
text
@d12284 22
@


1.322
log
@bfd/

2009-01-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/9679
	* elflink.c (elf_merge_st_other): New.
	(_bfd_elf_merge_symbol): Use it on skipped weak definitions and
	hide them if needed.
	(elf_link_add_object_symbols): Updated.

ld/testsuite/

2009-01-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/9679
	* ld-elf/pr9679-1.c: New.
	* ld-elf/pr9679-2.c: Likewise.
	* ld-elf/pr9679.rd: Likewise.

	* ld-elf/shared.exp (build_tests): Add test for libpr9679.so.
@
text
@d3 2
a4 1
   2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.321
log
@bfd/

2009-01-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/9676
	* elflink.c (elf_link_add_object_symbols): Update def_dynamic,
	ref_dynamic and dynamic_def fields when setting def_regular
	to 1.

ld/testsuite/

2009-01-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/9676
	* ld-elf/pr9676-1.c: New.
	* ld-elf/pr9676-2.c: Likewiswe.
	* ld-elf/pr9676-3.c: Likewiswe.
	* ld-elf/pr9676-4.c: Likewiswe.
	* ld-elf/pr9676.rd: Likewiswe.

	* ld-elf/shared.exp (build_tests): Add tests for libpr9676-1.a,
	libpr9676-2.a, libpr9676-3.so, libpr9676-4.so and
	libpr9676-4a.so.

	* lib/ld-lib.exp (ar_simple_create): New.
	(run_ld_link_tests): Support archive.
	(run_cc_link_tests): Likewiswe.
@
text
@d825 48
d1398 16
a1413 1
    *skip = TRUE;
d4310 2
a4311 36
	  /* If st_other has a processor-specific meaning, specific
	     code might be needed here. We never merge the visibility
	     attribute with the one from a dynamic object.  */
	  if (bed->elf_backend_merge_symbol_attribute)
	    (*bed->elf_backend_merge_symbol_attribute) (h, isym, definition,
							dynamic);

	  /* If this symbol has default visibility and the user has requested
	     we not re-export it, then mark it as hidden.  */
	  if (definition && !dynamic
	      && (abfd->no_export
		  || (abfd->my_archive && abfd->my_archive->no_export))
	      && ELF_ST_VISIBILITY (isym->st_other) != STV_INTERNAL)
	    isym->st_other = (STV_HIDDEN
			      | (isym->st_other & ~ELF_ST_VISIBILITY (-1)));

	  if (ELF_ST_VISIBILITY (isym->st_other) != 0 && !dynamic)
	    {
	      unsigned char hvis, symvis, other, nvis;

	      /* Only merge the visibility. Leave the remainder of the
		 st_other field to elf_backend_merge_symbol_attribute.  */
	      other = h->other & ~ELF_ST_VISIBILITY (-1);

	      /* Combine visibilities, using the most constraining one.  */
	      hvis   = ELF_ST_VISIBILITY (h->other);
	      symvis = ELF_ST_VISIBILITY (isym->st_other);
	      if (! hvis)
		nvis = symvis;
	      else if (! symvis)
		nvis = hvis;
	      else
		nvis = hvis < symvis ? hvis : symvis;

	      h->other = other | nvis;
	    }
@


1.320
log
@Remove STT_IFUNC support.
@
text
@d4299 9
a4307 1
		h->def_regular = 1;
@


1.319
log
@include/elf/
            * common.h (STT_IFUNC): Define.
elfcpp/
            * elfcpp.h (enum STT): Add STT_IFUNC.
bfd/
            * syms.c (struct bfd_symbol): Add new flag BSF_INDIRECT_FUNCTION.
            Remove redundant flag BFD_FORT_COMM_DEFAULT_VALUE.  Renumber flags
            to remove gaps.
            (bfd_print_symbol_vandf): Return 'i' for BSF_INDIRECT_FUNCTION.
            (bfd_decode_symclass): Likewise.
            * elf.c (swap_out_syms): Translate BSF_INDIRECT_FUNCTION into
            STT_IFUNC.
            (elf_find_function): Treat STT_IFUNC in the same way as STT_FUNC.
            (_bfd_elf_is_function_type): Likewise.
            * elf32-arm.c (arm_elf_find_function): Likewise.
            (elf32_arm_adjust_dynamic_symbol): Likewise.
            (elf32_arm_swap_symbol_in): Likewise.
            (elf32_arm_additional_program_headers): Likewise.
            * elf32-i386.c (is_indirect_symbol): New function.
            (elf_i386_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf_i386_relocate_section): Likewise.
            * elf64-x86-64.c (is_indirect_symbol): New function.
            (elf64_x86_64_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf64_x86_64_relocate_section): Likewise.
            * elfcode.h (elf_slurp_symbol_table): Translate STT_IFUNC into
            BSF_INDIRECT_FUNCTION.
            * elflink.c (_bfd_elf_adjust_dynamic_reloc_section): Add support
            for STT_IFUNC symbols.
            (get_ifunc_reloc_section_name): New function.
            (_bfd_elf_make_ifunc_reloc_section): New function.
            * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs field.
            * bfd-in2.h: Regenerate.
gas/
            * config/obj-elf.c (obj_elf_type): Add support for STT_IFUNC type.
            * doc/as.texinfo: Document new feature.
            * NEWS: Mention new feature.
gas/testsuite/
            * gas/elf/type.s: Add test of STT_IFUNC symbol type.
            * gas/elf/type.e: Update expected disassembly.
            * gas/elf/elf.exp: Update grep of symbol types.
ld/
            * NEWS: Mention new feature.
            * pe-dll.c (process_def_file): Replace use of redundant
            BFD_FORT_COMM_DEFAULT_VALUE with 0.
            * scripttempl/elf.sc: Add .rel.ifunc.dyn and .rela.ifunc.dyn
            sections.
ld/testsuite/
            * ld-mips-elf/reloc-1-n32.d: Updated expected output for reloc
            descriptions.
            * ld-mips-elf/reloc-1-n64.d: Likewise.
            * ld-i386/ifunc.d: New test.
            * ld-i386/ifunc.s: Source file for the new test.
            * ld-i386/i386.exp: Run the new test.
@
text
@a2655 6
  if (h->type == STT_IFUNC
      && (bed->elf_osabi == ELFOSABI_LINUX
	  /* GNU/Linux is still using the default value 0.  */
	  || bed->elf_osabi == ELFOSABI_NONE))
    h->needs_plt = 1;

a12403 68

#define IFUNC_INFIX ".ifunc"

/* Returns the name of the ifunc-using-dynamic-reloc section associated with SEC.  */

static const char *
get_ifunc_reloc_section_name (bfd *       abfd,
			      asection *  sec)
{
  const char *  dot;
  char *        name;
  const char *  base_name;
  unsigned int  strndx = elf_elfheader (abfd)->e_shstrndx;
  unsigned int  shnam = elf_section_data (sec)->rel_hdr.sh_name;

  base_name = bfd_elf_string_from_elf_section (abfd, strndx, shnam);
  if (base_name == NULL)
    return NULL;

  dot = strchr (base_name + 1, '.');
  name = bfd_alloc (abfd, strlen (base_name) + strlen (IFUNC_INFIX) + 1);
  sprintf (name, "%.*s%s%s", (int)(dot - base_name), base_name, IFUNC_INFIX, dot);

  return name;
}

/* Like _bfd_elf_make_dynamic_reloc_section but it creates a
   section for holding relocs against symbols with the STT_IFUNC
   type.  The section is attached to the OWNER bfd but it is created
   with a name based on SEC from ABFD.  */

asection *
_bfd_elf_make_ifunc_reloc_section (bfd *         abfd,
				   asection *    sec,
				   bfd *         owner,
				   unsigned int  align)
{
  asection * reloc_sec = elf_section_data (sec)->indirect_relocs;

  if (reloc_sec == NULL)
    {
      const char * name = get_ifunc_reloc_section_name (abfd, sec);

      if (name == NULL)
	return NULL;

      reloc_sec = bfd_get_section_by_name (owner, name);

      if (reloc_sec == NULL)
	{
	  flagword flags;

	  flags = (SEC_HAS_CONTENTS | SEC_READONLY | SEC_IN_MEMORY | SEC_LINKER_CREATED);
	  if ((sec->flags & SEC_ALLOC) != 0)
	    flags |= SEC_ALLOC | SEC_LOAD;

	  reloc_sec = bfd_make_section_with_flags (owner, name, flags);
	  
	  if (reloc_sec != NULL
	      && ! bfd_set_section_alignment (owner, reloc_sec, align))
	    reloc_sec = NULL;
	}

      elf_section_data (sec)->indirect_relocs = reloc_sec;
    }

  return reloc_sec;
}
@


1.318
log
@include/
	PR 7047
	* bfdlink.h (struct bfd_elf_version_expr): Delete "symbol".
	Add "literal".
bfd/
	PR 7047
	* configure.in: Bump version.
	* configure: Regenerate.
	* elflink.c (_bfd_elf_link_assign_sym_version): Continue matching
	against version nodes when a global match is a wildcard.  Similarly
	continue matching on local wildcard matches, rather than only
	continuing for "*".  Have any global wildcard match override a
	local wildcard match.  Correct logic hiding unversioned symbol.
	(bfd_elf_size_dynamic_sections): Update for changes to struct
	bfd_elf_version_expr.
ld/
	PR 7047
	* emultempl/ppc64elf.em (gld${EMULATION_NAME}_new_vers_pattern): Update
	for changes to struct bfd_elf_version_expr.
	* ldlang.c (lang_vers_match, version_expr_head_hash): Likewise.
	(version_expr_head_eq, lang_finalize_version_expr_head): Likewise.
	(lang_register_vers_node): Likewise.
	(lang_new_vers_pattern): Likewise.  Ensure "literal" is set when
	no glob chars found in "pattern".
	(realsymbol): Correct backslash quote logic.
	* ld.texinfo (VERSION): Warn about global wildcards.
@
text
@d2655 7
d12410 68
@


1.317
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d2013 1
a2013 1
      struct bfd_elf_version_tree *local_ver;
d2020 2
a2025 3
	      bfd_boolean matched;

	      matched = FALSE;
d2029 9
a2037 10
		if (d->symver)
		  matched = TRUE;
		else
		  {
		    /* There is a version without definition.  Make
		       the symbol the default definition for this
		       version.  */
		    h->verinfo.vertree = t;
		    local_ver = NULL;
		    d->script = 1;
d2039 2
a2040 1
		  }
a2042 4
	      else if (matched)
		/* There is no undefined version for this symbol. Hide the
		   default one.  */
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
d2052 8
a2059 5
		  /* If the match is "*", keep looking for a more
		     explicit, perhaps even global, match.
		     XXX: Shouldn't this be !d->wildcard instead?  */
		  if (d->pattern[0] != '*' || d->pattern[1] != '\0')
		    break;
d2067 11
a2077 1
      if (local_ver != NULL)
d2080 3
a2082 5
	  if (h->dynindx != -1
	      && ! info->export_dynamic)
	    {
	      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
	    }
d5575 1
a5575 1
	  if (!d->symver && d->symbol)
d5582 1
a5582 1
	      name = d->symbol;
d5640 1
a5640 1
	      if (!d->symver && !d->script)
@


1.316
log
@	* elf-bfd.h (struct elf_backend_data): New member got_elt_size.
	(_bfd_elf_default_got_elt_size): Declare.
	* elflink.c (struct alloc_got_off_arg): Replace member got_elt_size
	by new member info.
	(elf_gc_allocate_got_offsets): Adjust for calling bed->got_elt_size
	to get the element size instead of using a gofarg entry.
	(bfd_elf_gc_common_finalize_got_offsets): Similar.
	(_bfd_elf_default_got_elt_size): New function.
	* elfxx-target.h: New macro elf_backend_got_elt_size.
	(elfNN_bed): Use it.
@
text
@d12272 125
@


1.315
log
@	* elflink.c (bfd_elf_final_link): Move code reading relocs to..
	* elf32-spu.c (spu_elf_count_relocs): ..here.  Adjust params.
	* elf-bfd.h (struct elf_backend_data): Update elf_backend_count_relocs
	params.
@
text
@d11789 1
a11789 1
  unsigned int got_elt_size;
d11799 2
d11808 1
a11808 1
      gofarg->gotoff += gofarg->got_elt_size;
a11825 1
  unsigned int got_elt_size = bed->s->arch_size / 8;
d11828 2
d11865 1
a11865 1
	      gotoff += got_elt_size;
d11875 1
a11875 1
  gofarg.got_elt_size = got_elt_size;
d12261 11
@


1.314
log
@	* elflink.c (bfd_elf_final_link): Use d_ptr rather than d_val
	where Elf_Internal_Dyn holds an address.
@
text
@d10098 1
a10098 16
		{
		  Elf_Internal_Rela * relocs;

		  relocs = _bfd_elf_link_read_relocs (sec->owner, sec,
						      NULL, NULL,
						      info->keep_memory);

		  if (relocs != NULL)
		    {
		      reloc_count
			= (*bed->elf_backend_count_relocs) (sec, relocs);

		      if (elf_section_data (sec)->relocs != relocs)
			free (relocs);
		    }
		}
@


1.313
log
@bfd/
	* elf.c (bfd_elf_set_group_contents): Assign sh_info for ld -r when
	the signature symbol is global.
	* elflink.c (elf_link_input_bfd): Ensure group signature symbol
	is output when ld -r.  Set group sh_info when local.
	* linker.c (default_indirect_link_order): Handle group sections
	specially.
ld/
	* ldemul.c (ldemul_place_orphan): Add "name" param.
	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldlang.c (lang_place_orphans): Generate unique section names here..
	* emultempl/elf32.em (place_orphan): ..rather than here.  Don't
	directly use an existing output section statement that has no
	bfd section.
	* emultempl/pe.em (place_orphan): Likewise.
	* emultempl/pep.em (place_orphan): Likewise.
	* emultempl/beos.em (place_orphan): Adjust.
	* emultempl/spuelf.em (spu_place_special_section): Adjust
	place_orphan call.
	* emultempl/genelf.em (gld${EMULATION_NAME}_after_open): New function.
	(LDEMUL_AFTER_OPEN): Define.
@
text
@d10759 1
a10759 1
		    dyn.d_un.d_val = h->root.u.def.value;
d10762 1
a10762 1
		      dyn.d_un.d_val += (o->output_section->vma
d10768 1
a10768 1
			dyn.d_un.d_val = 0;
d10847 1
d10860 3
a10862 3
			  if (dyn.d_un.d_val == 0
			      || hdr->sh_addr < dyn.d_un.d_val)
			    dyn.d_un.d_val = hdr->sh_addr;
@


1.312
log
@	* elflink.c (elf_link_add_object_symbols): Don't ignore returned
	value of check_directives.
@
text
@d9065 57
@


1.311
log
@	* elf.c (_bfd_elf_init_private_section_data): Tweak union copy.
	(bfd_section_from_shdr): Don't change SHT_GROUP section name.
	* elflink.c (section_signature): New function.
	(_bfd_elf_section_already_linked): Use it.
@
text
@d4674 3
a4676 2
  if (bed->check_directives)
    (*bed->check_directives) (abfd, info);
@


1.310
log
@bfd/

2008-09-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/6877
	* elflink.c (_bfd_elf_merge_symbol): Allow a common symbol to
	override the function in a shared library.

ld/testsuite/

2008-09-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/6877
	* ld-elf/comm1.c: New.
	* ld-elf/func1.c: Likewise.

	* ld-elf/shared.exp: Add tests for libfunc1.so and comm1.
@
text
@d12000 13
d12014 1
a12014 1
_bfd_elf_section_already_linked (bfd *abfd, struct bfd_section *sec,
d12054 1
a12054 1
  name = bfd_get_section_name (abfd, sec);
d12069 1
a12069 1
	  && strcmp (name, l->sec->name) == 0
@


1.309
log
@bfd/
	Fix PR ld/3290 regression for cross-files DW_FORM_ref_addr relocations.
	* elflink.c (elf_link_add_object_symbols): Make debug symbols local
	now only for non-RELOCATABLE targets.

ld/testsuite/
	* ld-x86-64/dwarfreloc.exp, ld-x86-64/dwarfreloc.rd,
	ld-x86-64/dwarfreloc1.s, ld-x86-64/dwarfreloc2.s: New test.
@
text
@d857 1
a857 1
  bfd_boolean newweak, oldweak;
d975 9
d999 1
a999 2
      && !(bed->is_function_type (ELF_ST_TYPE (sym->st_info))
	   && bed->is_function_type (h->type)))
d1191 1
a1191 2
  if (bed->is_function_type (ELF_ST_TYPE (sym->st_info))
      && bed->is_function_type (h->type))
d1240 1
a1240 1
      && !bed->is_function_type (ELF_ST_TYPE (sym->st_info)))
d1252 1
a1252 1
      && !bed->is_function_type (h->type))
d1312 1
a1312 2
	      && (newweak
		  || bed->is_function_type (ELF_ST_TYPE (sym->st_info))))))
d1366 1
a1366 2
	      && (oldweak
		  || bed->is_function_type (h->type))))
d1386 11
a1396 1
	*type_change_ok = TRUE;
@


1.309.2.1
log
@backport 2008-09-28  Alan Modra  <amodra@@bigpond.net.au>
@
text
@a11984 13
/* For a SHT_GROUP section, return the group signature.  For other
   sections, return the normal section name.  */

static const char *
section_signature (asection *sec)
{
  if ((sec->flags & SEC_GROUP) != 0
      && elf_next_in_group (sec) != NULL
      && elf_group_name (elf_next_in_group (sec)) != NULL)
    return elf_group_name (elf_next_in_group (sec));
  return sec->name;
}

d11986 1
a11986 1
_bfd_elf_section_already_linked (bfd *abfd, asection *sec,
d12026 1
a12026 1
  name = section_signature (sec);
d12041 1
a12041 1
	  && strcmp (name, section_signature (l->sec)) == 0
@


1.309.2.2
log
@backport 2008-10-03  Alan Modra  <amodra@@bigpond.net.au>
@
text
@a9048 57
      if (finfo->info->relocatable
	  && (o->flags & (SEC_LINKER_CREATED | SEC_GROUP)) == SEC_GROUP)
	{
	  /* Deal with the group signature symbol.  */
	  struct bfd_elf_section_data *sec_data = elf_section_data (o);
	  unsigned long symndx = sec_data->this_hdr.sh_info;
	  asection *osec = o->output_section;

	  if (symndx >= locsymcount
	      || (elf_bad_symtab (input_bfd)
		  && finfo->sections[symndx] == NULL))
	    {
	      struct elf_link_hash_entry *h = sym_hashes[symndx - extsymoff];
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	      /* Arrange for symbol to be output.  */
	      h->indx = -2;
	      elf_section_data (osec)->this_hdr.sh_info = -2;
	    }
	  else if (ELF_ST_TYPE (isymbuf[symndx].st_info) == STT_SECTION)
	    {
	      /* We'll use the output section target_index.  */
	      asection *sec = finfo->sections[symndx]->output_section;
	      elf_section_data (osec)->this_hdr.sh_info = sec->target_index;
	    }
	  else
	    {
	      if (finfo->indices[symndx] == -1)
		{
		  /* Otherwise output the local symbol now.  */
		  Elf_Internal_Sym sym = isymbuf[symndx];
		  asection *sec = finfo->sections[symndx]->output_section;
		  const char *name;

		  name = bfd_elf_string_from_elf_section (input_bfd,
							  symtab_hdr->sh_link,
							  sym.st_name);
		  if (name == NULL)
		    return FALSE;

		  sym.st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
								    sec);
		  if (sym.st_shndx == SHN_BAD)
		    return FALSE;

		  sym.st_value += o->output_offset;

		  finfo->indices[symndx] = bfd_get_symcount (output_bfd);
		  if (! elf_link_output_sym (finfo, name, &sym, o, NULL))
		    return FALSE;
		}
	      elf_section_data (osec)->this_hdr.sh_info
		= finfo->indices[symndx];
	    }
	}

@


1.309.2.3
log
@baskport 2009-01-11  Jan Kratochvil  <jan.kratochvil@@redhat.com>
@
text
@a12233 22
  /* Do not complain on unresolved relocations in `.gnu.linkonce.r.F'
     referencing its discarded `.gnu.linkonce.t.F' counterpart - g++-3.4
     specific as g++-4.x is using COMDAT groups (without the `.gnu.linkonce'
     prefix) instead.  `.gnu.linkonce.r.*' were the `.rodata' part of its
     matching `.gnu.linkonce.t.*'.  If `.gnu.linkonce.r.F' is not discarded
     but its `.gnu.linkonce.t.F' is discarded means we chose one-only
     `.gnu.linkonce.t.F' section from a different bfd not requiring any
     `.gnu.linkonce.r.F'.  Thus `.gnu.linkonce.r.F' should be discarded.
     The reverse order cannot happen as there is never a bfd with only the
     `.gnu.linkonce.r.F' section.  The order of sections in a bfd does not
     matter as here were are looking only for cross-bfd sections.  */

  if ((flags & SEC_GROUP) == 0 && CONST_STRNEQ (name, ".gnu.linkonce.r."))
    for (l = already_linked_list->entry; l != NULL; l = l->next)
      if ((l->sec->flags & SEC_GROUP) == 0
	  && CONST_STRNEQ (l->sec->name, ".gnu.linkonce.t."))
	{
	  if (abfd != l->sec->owner)
	    sec->output_section = bfd_abs_section_ptr;
	  break;
	}

@


1.308
log
@	* elf.c (bfd_elf_get_elf_syms): Don't leak memory on error.
	* elflink.c (_bfd_elf_link_read_relocs): bfd_release on error.
	(elf_link_add_object_symbols): Don't leak memory on error.
	(bfd_elf_size_dynsym_hash_dynstr): Likewise.
	(elf_fixup_link_order): Free sections.
@
text
@d4297 1
a4297 1
	  if (definition && (sec->flags & SEC_DEBUGGING))
@


1.307
log
@bfd/
	* elf-bfd.h (elf_backend_data): Add a "rela_plts_and_copies_p" field.
	* elfxx-target.h (elf_backend_rela_plts_and_copies_p): New macro.
	(elfNN_bed): Use it.
	* elf.c (_bfd_elf_get_synthetic_symtab): Use rela_plts_and_copies_p
	instead of default_use_rela_p to choose between ".rel.plt" and
	".rela.plt".
	* elflink.c (_bfd_elf_create_dynamic_sections): Use
	rela_plts_and_copies_p instead of default_use_rela_p to choose
	between ".rel.plt" and ".rela.plt", and between ".rel.bss" and
	".rela.bss".
@
text
@d2181 1
a2181 1
	internal_relocs = bfd_alloc (abfd, size);
d2229 6
a2234 1
    free (alloc2);
d4634 5
a4638 1
			goto error_return;
d4649 1
a4649 1
			goto error_return;
d6261 4
a6264 1
	    return FALSE;
d6316 4
a6319 1
	    return FALSE;
d9865 1
@


1.306
log
@2008-07-22  Simon Baldwin  <simonb@@google.com>

        * elflink.c (elf_link_output_extsym): Set st_size to zero for
        symbols from dynamic libraries.
@
text
@d312 1
a312 1
				   (bed->default_use_rela_p
d350 1
a350 1
					   (bed->default_use_rela_p
@


1.305
log
@2008-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4424
	* elflink.c (_bfd_elf_merge_symbol): Call bed->relocs_compatible
	to check if 2 inputs are compatible.
@
text
@d8622 9
@


1.304
log
@	* elf.c (_bfd_elf_get_dynamic_reloc_upper_bound)
	(_bfd_elf_canonicalize_dynamic_reloc): Find dynamic relocations
	even if they are not loaded.
	* elflink.c (_bfd_elf_init_2_index_sections): Set data_index_section
	first.

	* ld-arm/symbian-seg1.s, ld-arm/symbian-seg1.d: New files.
	* ld-arm/arm-elf.exp: Run symbian-seg1.
@
text
@d884 2
d888 1
a888 1
  if (info->output_bfd->xvec != abfd->xvec)
a974 1
  bed = get_elf_backend_data (abfd);
@


1.303
log
@	* elflink.c (bfd_elf_size_dynamic_sections): Ignore GNU-stack note
	in EXEC_P bfds.
@
text
@d6134 2
d6137 1
a6137 2
    if (((s->flags & (SEC_EXCLUDE | SEC_ALLOC | SEC_READONLY))
	 == (SEC_ALLOC | SEC_READONLY))
d6140 1
a6140 1
	elf_hash_table (info)->text_index_section = s;
d6145 2
a6146 1
    if (((s->flags & (SEC_EXCLUDE | SEC_ALLOC | SEC_READONLY)) == SEC_ALLOC)
d6149 1
a6149 1
	elf_hash_table (info)->data_index_section = s;
@


1.302
log
@include/elf/
	* internal.h (Elf_Internal_Shdr): Change sh_link and sh_info from
	unsigned long to unsigned int.  Change sh_addralign to bfd_vma.
	Order struct as for external version.
bfd/
	* elf.c (_bfd_elf_make_section_from_shdr): Remove unnecessary cast.
	(_bfd_elf_assign_file_position_for_section): Simplify align.
	(_bfd_elf_init_reloc_shdr): Ensure shift expression wide enough
	for sh_addralign.
	(elf_fake_sections, swap_out_syms): Likewise.
	* elflink.c (bfd_elf_final_link): Likewise.
binutils/
	* readelf.c: Use %u throughout when printing sh_link or sh_info,
	%lu when printing sh_addralign.
	(process_version_sections): Use identical formats when printing
	all offset and sh_link fields.
@
text
@d5406 1
a5406 1
	  if (inputobj->flags & (DYNAMIC | BFD_LINKER_CREATED))
@


1.301
log
@include/elf/
	PR 5900
	* common.h (SHN_BAD): Delete.
	(SHN_LORESERVE .. SHN_HIRESERVE): Move to..
	* external.h: ..here.
	* internal.h (SHN_LORESERVE, SHN_HIRESERVE): Define.
	(SHN_LOPROC, SHN_HIPROC, SHN_LOOS, SHN_HIOS): Define.
	(SHN_ABS, SHN_COMMON, SHN_XINDEX, SHN_BAD): Define.
bfd/
	PR 5900
	* elf-bfd.h: Include elf/internal.h after elf/external.h.
	* elfcode.h (elf_swap_symbol_in): Map reserved shndx range.
	(elf_swap_symbol_out): Adjust SHN_XINDEX test.
	(elf_swap_ehdr_out): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.
	(valid_section_index_p): Delete.
	(elf_object_p): Don't increment section numbers over reserved range.
	Simplify test for valid sh_link, sh_info and e_shstrndx fields.
	(elf_write_shdrs_and_ehdr): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.  Don't increment section numbers over
	reserved range.
	* elf.c (bfd_elf_sym_name): Remove redundant tests on st_shndx.
	(bfd_section_from_shdr): Likewise.
	(group_signature): Range check before accessing elf_elfsections.
	(_bfd_elf_setup_sections): Likewise.
	(bfd_section_from_shdr): Likewise.
	(bfd_section_from_shdr): Don't increment section number over
	reserved sections.
	(assign_file_positions_for_non_load_sections): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(_bfd_elf_write_object_contents): Likewise.
	(assign_section_numbers): Likewise.  Adjust for changed SHN_*.
	(prep_headers): Delete unused variable.
	* elflink.c (bfd_elf_link_record_local_dynamic_symbol): Adjust
	for changed SHN_* values.
	(check_dynsym, elf_link_input_bfd): Likewise.
	(bfd_elf_final_link): Likewise.  Don't skip over reserved section
	range.
	(elf_fixup_link_order): Check that sh_link field is valid.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Make "index" unsigned.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): Range check before
	accesssing elf_elfsections.
	* elf32-avr.c (elf32_avr_size_stubs): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Adjust for changed
	SHN_* defines.  Test for SHN_BAD return from
	_bfd_elf_section_from_bfd_section
binutils/
	PR 5900
	* readelf.c (SECTION_HEADER_INDEX, SECTION_HEADER_NUM): Delete.
	Remove use throughout file.
	(SECTION_HEADER): Likewise.
	(dump_relocations): Don't adjust st_shndx for reserved range.
	(process_file_header): Mask SHN_XINDEX to values seen in external
	elf structs.  Simplify valid section index tests.
	(get_32bit_elf_symbols, get_64bit_elf_symbols): Mask SHN_XINDEX.
	Map reserved st_shndx to internal form.
	(process_section_groups): Test that group symbol st_shndx is in
	range, not just non-zero.  Delete reserved range check.
	(get_symbol_index_type): Mask "type" to 16 bits when printing PRC,
	OS or RSV.
gdb/
	PR 5900
	* elfread.c (elf_symtab_read): Make shndx an unsigned int.
	* mipsread.c: Include elf/internal.h.
	(read_alphacoff_dynamic_symtab): Map external reserved sym_shndx
	to internal range.
ld/testsuite/
	PR 5900
	* ld-elf/sec64k.exp: Update.
@
text
@d10169 1
a10169 1
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;
@


1.300
log
@	* elf-bfd.h (_bfd_elf_section_from_bfd_section): Update prototype.
	* elf.c (_bfd_elf_section_from_bfd_section): Return unsigned int,
	SHN_BAD on error.
	(_bfd_elf_print_private_bfd_data): Test for SHN_BAD result from
	_bfd_elf_section_from_bfd_section, not -1.
	(swap_out_syms): Likewise.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	(bfd_elf_get_bfd_needed_list): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.
	(elf_link_add_object_symbols): Don't bother testing for symbols
	using normal sections before calling bfd_section_from_elf_index.
	(elf_link_input_bfd, bfd_elf_final_link): Likewise.
	(bfd_elf_reloc_symbol_deleted_p): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elf32-spu.c (get_sym_h): Likewise.
	* elf32-xtensa.c (get_elf_r_symndx_section): Likewise.
	* elf64-ppc.c (opd_entry_value, get_sym_h, ppc64_elf_edit_toc): Ditto.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
@
text
@d621 1
a621 2
      && (entry->isym.st_shndx < SHN_LORESERVE
	  || entry->isym.st_shndx > SHN_HIRESERVE))
d8203 2
a8204 1
  if (sym->st_shndx > SHN_HIRESERVE)
d8210 1
a8210 1
	 abfd, bfd_count_sections (abfd), SHN_LORESERVE);
d8954 3
a8956 4
	  && (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
	  && (isec == NULL
	      || bfd_section_removed_from_list (output_bfd,
						isec->output_section)))
d9780 2
a9781 1
	      && elf_elfsections (sub)[elfsec]->sh_flags & SHF_LINK_ORDER)
d10189 1
a10189 1
  if (elf_numsections (abfd) > SHN_LORESERVE)
a10238 2
	  if (i == SHN_LORESERVE - 1)
	    i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
@


1.299
log
@2008-03-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/5789
	* elflink.c (_bfd_elf_symbol_refs_local_p): Always return true
	for hidden and local symbols.
@
text
@d3475 1
a3475 1
	  int elfsec;
d3482 1
a3482 1
	  if (elfsec == -1)
d3823 10
a3832 2
      else if (isym->st_shndx < SHN_LORESERVE
	       || isym->st_shndx > SHN_HIRESERVE)
a3846 13
      else if (isym->st_shndx == SHN_ABS)
	sec = bfd_abs_section_ptr;
      else if (isym->st_shndx == SHN_COMMON)
	{
	  sec = bfd_com_section_ptr;
	  /* What ELF calls the size we call the value.  What ELF
	     calls the value we call the alignment.  */
	  value = isym->st_size;
	}
      else
	{
	  /* Leave it up to the processor backend.  */
	}
d6748 1
a6748 1
  int elfsec;
d6768 1
a6768 1
  if (elfsec == -1)
d6940 1
a6940 1
  int shndx1, shndx2;
d6956 1
a6956 1
  if (shndx1 == -1 || shndx2 == -1)
d7013 1
a7013 1
	  if ((unsigned int) shndx1 < ssymbuf1[mid].st_shndx)
d7015 1
a7015 1
	  else if ((unsigned int) shndx1 > ssymbuf1[mid].st_shndx)
d7032 1
a7032 1
	  if ((unsigned int) shndx2 < ssymbuf2[mid].st_shndx)
d7034 1
a7034 1
	  else if ((unsigned int) shndx2 > ssymbuf2[mid].st_shndx)
d7097 1
a7097 1
    if (isym->st_shndx == (unsigned int) shndx1)
d7102 1
a7102 1
    if (isym->st_shndx == (unsigned int) shndx2)
d8902 5
a8906 2
      else if (isym->st_shndx < SHN_LORESERVE
	       || isym->st_shndx > SHN_HIRESERVE)
d8909 9
a8917 3
	  if (isec
	      && isec->sec_info_type == ELF_INFO_TYPE_MERGE
	      && ELF_ST_TYPE (isym->st_info) != STT_SECTION)
a8922 11
      else if (isym->st_shndx == SHN_ABS)
	isec = bfd_abs_section_ptr;
      else if (isym->st_shndx == SHN_COMMON)
	isec = bfd_com_section_ptr;
      else
	{
	  /* Don't attempt to output symbols with st_shnx in the
	     reserved range other than SHN_ABS and SHN_COMMON.  */
	  *ppsection = NULL;
	  continue;
	}
d10487 3
a10489 3
	      if (e->isym.st_shndx != SHN_UNDEF
		  && (e->isym.st_shndx < SHN_LORESERVE
		      || e->isym.st_shndx > SHN_HIRESERVE))
a10490 3
		  s = bfd_section_from_elf_index (e->input_bfd,
						  e->isym.st_shndx);

d11857 3
a11859 6
	  if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
	    {
	      isec = bfd_section_from_elf_index (rcookie->abfd, isym->st_shndx);
	      if (isec != NULL && elf_discarded_section (isec))
		return TRUE;
	    }
@


1.298
log
@2008-02-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/5788
	* elflink.c (elf_create_symbuf): Correct buffer size and
	position.
@
text
@d2792 5
a2824 4
  /* However, STV_HIDDEN or STV_INTERNAL ones must be local.  */
  if (ELF_ST_VISIBILITY (h->other) != STV_PROTECTED)
    return TRUE;

@


1.297
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@d6873 1
a6873 1
  bfd_size_type i, shndx_count;
d6893 3
a6895 2
  ssymbuf = bfd_malloc ((shndx_count + 1) * sizeof (*ssymbuf)
			+ (indbufend - indbuf) * sizeof (*ssymbuf));
d6902 1
a6902 1
  ssym = (struct elf_symbuf_symbol *) (ssymbuf + shndx_count);
d6920 3
a6922 1
  BFD_ASSERT ((bfd_size_type) (ssymhead - ssymbuf) == shndx_count);
@


1.296
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d8183 1
a8183 1
	  finfo->symshndxbuf = destshndx = bfd_realloc (destshndx, amt * 2);
d8186 1
@


1.295
log
@	* elflink.c (compute_bucket_count): Warning fixes.
@
text
@d887 1
a887 1
  if (info->hash->creator != abfd->xvec)
d3339 1
a3339 1
	  || htab->root.creator != abfd->xvec)
d3436 1
a3436 1
	  && htab->root.creator == abfd->xvec
d4677 1
a4677 1
      && (*bed->relocs_compatible) (abfd->xvec, htab->root.creator))
@


1.294
log
@	* elflink.c (_bfd_elf_link_output_relocs): Correct error return.
@
text
@d5237 4
a5240 2
compute_bucket_count (struct bfd_link_info *info, unsigned long int *hashcodes,
		      unsigned long int nsyms, int gnu_hash)
a5241 1
  size_t dynsymcount = elf_hash_table (info)->dynsymcount;
a5243 1
  bfd_size_type amt;
d5255 1
d5258 1
@


1.293
log
@bfd/
	PR 5604
	* elf-bfd.h (struct elf_backend_data): Add gc_keep.  Remove param
	names from others.
	(_bfd_elf_gc_keep): Declare.
	* elfxx-target.h (elf_backend_gc_keep): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_gc_keep): New function.
	(bfd_elf_gc_sections): Call gc_keep.
	* elf64-ppc.c (elf_backend_gc_keep): Define.
	(struct _ppc64_elf_section_data): Move .opd related fields to
	a struct so they don't occupy the same storage.  Adjust accesses
	throughout file.
	(ppc64_elf_gc_keep): New function, split out from..
	(ppc64_elf_gc_mark_hook): ..here.  Don't call _bfd_elf_gc_mark
	to mark .opd section, just set gc_mark.
	(ppc64_elf_edit_opd): Remove no_opd_opt parm.  Don't set opd->adjust
	unless we are changing .opd.  Test non-NULL opd->adjust at all
	accesses throughout file.
	* elf64-ppc.h (ppc64_elf_edit_opd): Update prototype.
ld/
	PR 5604
	* ldlang.c (lang_gc_sections): Move code to set SEC_KEEP on entry
	syms to _bfd_elf_gc_keep.
	* emultempl/ppc64elf.em (ppc_before_allocation): Don't call
	ppc64_elf_edit_opd if no_opd_opt.
@
text
@d2324 1
a2324 1
      bfd_set_error (bfd_error_wrong_object_format);
@


1.292
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d3 1
a3 1
   2005, 2006, 2007 Free Software Foundation, Inc.
d11466 23
d11506 2
d11564 1
a11564 1
    bed->gc_mark_extra_sections(info, gc_mark_hook);
@


1.291
log
@bfd/

2008-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/5522
	* elflink.c (elf_link_input_bfd): Don't write out a section if
	its output section is marked with SEC_NEVER_LOAD.

ld/testsuite/

2008-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/5522
	* ld-elf/noload-3.d: New file.
	* ld-elf/noload-3.s: Likewise.
	* ld-elf/noload-3.t: Likewise.
@
text
@a11476 2
      || info->relocatable
      || info->emitrelocations
@


1.290
log
@bfd/
	* elf-bfd.h (eh_cie_fde): Add u.fde.next_for_section and
	u.cie.gc_mark.
	(bfd_elf_section_data): Add fde_list.
	(elf_fde_list): New macro.
	(elf_obj_tdata): Add eh_frame_section.
	(elf_eh_frame_section): New macro.
	(_bfd_elf_gc_mark_reloc): Remove last parameter.
	(_bfd_elf_gc_mark_fdes): Declare.
	* elf-eh-frame.c (_bfd_elf_get_eh_frame_sec_info): Chain the FDEs
	for each input section.
	(mark_entry, _bfd_elf_gc_mark_fdes): New functions.
	* elflink.c (_bfd_elf_gc_mark_reloc): Remove is_eh parameter.
	(_bfd_elf_gc_mark): Update call accordingly.  Mark the relocations
	againts the section's FDEs.  Don't mark the bfd's elf_eh_frame_section.
	(bfd_elf_gc_sections): Parse each input bfd's .eh_frame before
	marking any input sections.  Remove the current EH handling.
	* section.c (bfd_section): Remove gc_mark_from_eh.
	* ecoff.c (bfd_debug_section): Update initializer accordingly.
@
text
@d9514 1
@


1.289
log
@bfd/
	* elf-bfd.h (eh_cie_fde): Add u.cie.  Document how u.fde.cie_inf
	changes when removed == 0.
	(eh_frame_hdr_info): Add parsed_eh_frames.
	(_bfd_elf_begin_eh_frame_parsing): Declare.
	(_bfd_elf_parse_eh_frame): Declare.
	(_bfd_elf_end_eh_frame_parsing): Declare.
	* elf-eh-frame.c (_bfd_elf_begin_eh_frame_parsing): New function.
	(_bfd_elf_parse_eh_frame): New function, split out from
	_bfd_elf_discard_section_eh_frame.  Make a first pass through the
	buffer to calculate the number of entries and CIEs.  Allocate memory
	for them before the main loop.  Replace current extended cie
	representation with a pair of pointers, one to the local eh_cie_fde
	and one to the full struct cie.  Allocate a separate array of struct
	cies if not merging.  Merge CIEs during the main loop and set up each
	u.cie.merged field.  Point an FDE's cie_inf field directly at the
	local CIE.  Initially assume that all entries should be removed.
	(_bfd_elf_end_eh_frame_parsing): New function.
	(_bfd_elf_discard_section_eh_frame): Assume that the section has
	already been parsed.  Use a separate pass to mark entries that
	need to be kept.  Use the u.cie.merged field to track a CIE's
	group representative.
	* elflink.c (bfd_elf_discard_info): Call _bfd_elf_parse_eh_frame
	before _bfd_elf_discard_section_eh_frame.  Wrap loop with calls to
	_bfd_elf_begin_eh_frame_parsing and _bfd_elf_end_eh_frame_parsing.
@
text
@d11140 1
a11140 2
   the relocation symbol.  IS_EH is true if the mark comes from
   .eh_frame.  */
d11146 1
a11146 2
			struct elf_reloc_cookie *cookie,
			bfd_boolean is_eh)
a11154 2
      else if (is_eh)
	rsec->gc_mark_from_eh = 1;
d11171 1
a11171 2
  bfd_boolean is_eh;
  asection *group_sec;
d11183 4
a11186 2
  is_eh = strcmp (sec->name, ".eh_frame") == 0;
  if ((sec->flags & SEC_RELOC) != 0 && sec->reloc_count > 0)
d11195 1
a11195 2
	    if (!_bfd_elf_gc_mark_reloc (info, sec, gc_mark_hook,
					 &cookie, is_eh))
d11203 16
d11484 19
a11541 62
  /* ... again for sections marked from eh_frame.  */
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *o;

      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
	continue;

      /* Keep .gcc_except_table.* if the associated .text.* (or the
	 associated .gnu.linkonce.t.* if .text.* doesn't exist) is
	 marked.  This isn't very nice, but the proper solution,
	 splitting .eh_frame up and using comdat doesn't pan out
	 easily due to needing special relocs to handle the
	 difference of two symbols in separate sections.
	 Don't keep code sections referenced by .eh_frame.  */
#define TEXT_PREFIX			".text."
#define TEXT_PREFIX2			".gnu.linkonce.t."
#define GCC_EXCEPT_TABLE_PREFIX		".gcc_except_table."
      for (o = sub->sections; o != NULL; o = o->next)
	if (!o->gc_mark && o->gc_mark_from_eh && (o->flags & SEC_CODE) == 0)
	  {
	    if (CONST_STRNEQ (o->name, GCC_EXCEPT_TABLE_PREFIX))
	      {
		char *fn_name;
		const char *sec_name;
		asection *fn_text;
		unsigned o_name_prefix_len , fn_name_prefix_len, tmp;

		o_name_prefix_len = strlen (GCC_EXCEPT_TABLE_PREFIX);
		sec_name = o->name + o_name_prefix_len;
		fn_name_prefix_len = strlen (TEXT_PREFIX);
		tmp = strlen (TEXT_PREFIX2);
		if (tmp > fn_name_prefix_len)
		  fn_name_prefix_len = tmp;
		fn_name
		  = bfd_malloc (fn_name_prefix_len + strlen (sec_name) + 1);
		if (fn_name == NULL)
		  return FALSE;

		/* Try the first prefix.  */
		sprintf (fn_name, "%s%s", TEXT_PREFIX, sec_name);
		fn_text = bfd_get_section_by_name (sub, fn_name);

		/* Try the second prefix.  */
		if (fn_text == NULL)
		  {
		    sprintf (fn_name, "%s%s", TEXT_PREFIX2, sec_name);
		    fn_text = bfd_get_section_by_name (sub, fn_name);
		  }

		free (fn_name);
		if (fn_text == NULL || !fn_text->gc_mark)
		  continue;
	      }

	    /* If not using specially named exception table section,
	       then keep whatever we are using.  */
	    if (!_bfd_elf_gc_mark (info, o, gc_mark_hook))
	      return FALSE;
	  }
    }

@


1.288
log
@bfd/
	* elf-bfd.h (_bfd_elf_gc_mark_rsec, _bfd_elf_gc_mark_reloc): Declare.
	(_bfd_elf_gc_mark): Use elf_gc_mark_hook_fn.
	* elflink.c (init_reloc_cookie, fini_reloc_cookie)
	(init_reloc_cookie_rels, fini_reloc_cookie_rels): New functions,
	split out from...
	(bfd_elf_discard_info): ...here.
	(init_reloc_cookie_for_section): New function.
	(fini_reloc_cookie_for_section): Likewise.
	(_bfd_elf_gc_mark_rsec, _bfd_elf_gc_mark_reloc): New functions,
	split out from...
	(_bfd_elf_gc_mark): ...here.  Use init_reloc_cookie_for_section
	and fini_reloc_cookie_for_section.
@
text
@d11897 1
d11948 1
d11962 1
@


1.287
log
@* elflink.c (elf_link_output_extsym): Weaken assertion: if --gc-section is set, there may be no TLS segment.
* lib/ld-lib.exp (check_gc_sections_available): New proc, based on the version in gcc/testsuite/lib/target-supports.exp.
* ld-elf/eld.exp: Use check_gc_sections_available.
@
text
@d10943 133
d11108 57
d11191 1
a11191 9
      Elf_Internal_Rela *relstart, *rel, *relend;
      Elf_Internal_Shdr *symtab_hdr;
      struct elf_link_hash_entry **sym_hashes;
      size_t nlocsyms;
      size_t extsymoff;
      bfd *input_bfd = sec->owner;
      const struct elf_backend_data *bed = get_elf_backend_data (input_bfd);
      Elf_Internal_Sym *isym = NULL;
      int r_sym_shift;
d11193 2
a11194 9
      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      sym_hashes = elf_sym_hashes (input_bfd);

      /* Read the local symbols.  */
      if (elf_bad_symtab (input_bfd))
	{
	  nlocsyms = symtab_hdr->sh_size / bed->s->sizeof_sym;
	  extsymoff = 0;
	}
a11195 4
	extsymoff = nlocsyms = symtab_hdr->sh_info;

      isym = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isym == NULL && nlocsyms != 0)
d11197 8
a11204 69
	  isym = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, nlocsyms, 0,
				       NULL, NULL, NULL);
	  if (isym == NULL)
	    return FALSE;
	}

      /* Read the relocations.  */
      relstart = _bfd_elf_link_read_relocs (input_bfd, sec, NULL, NULL,
					    info->keep_memory);
      if (relstart == NULL)
	{
	  ret = FALSE;
	  goto out1;
	}
      relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;

      if (bed->s->arch_size == 32)
	r_sym_shift = 8;
      else
	r_sym_shift = 32;

      for (rel = relstart; rel < relend; rel++)
	{
	  unsigned long r_symndx;
	  asection *rsec;
	  struct elf_link_hash_entry *h;

	  r_symndx = rel->r_info >> r_sym_shift;
	  if (r_symndx == 0)
	    continue;

	  if (r_symndx >= nlocsyms
	      || ELF_ST_BIND (isym[r_symndx].st_info) != STB_LOCAL)
	    {
	      h = sym_hashes[r_symndx - extsymoff];
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	      rsec = (*gc_mark_hook) (sec, info, rel, h, NULL);
	    }
	  else
	    {
	      rsec = (*gc_mark_hook) (sec, info, rel, NULL, &isym[r_symndx]);
	    }

	  if (rsec && !rsec->gc_mark)
	    {
	      if (bfd_get_flavour (rsec->owner) != bfd_target_elf_flavour)
		rsec->gc_mark = 1;
	      else if (is_eh)
		rsec->gc_mark_from_eh = 1;
	      else if (!_bfd_elf_gc_mark (info, rsec, gc_mark_hook))
		{
		  ret = FALSE;
		  goto out2;
		}
	    }
	}

    out2:
      if (elf_section_data (sec)->relocs != relstart)
	free (relstart);
    out1:
      if (isym != NULL && symtab_hdr->contents != (unsigned char *) isym)
	{
	  if (! info->keep_memory)
	    free (isym);
	  else
	    symtab_hdr->contents = (unsigned char *) isym;
a11206 1

a11888 1
  Elf_Internal_Shdr *symtab_hdr;
a11890 1
  unsigned int count;
d11929 2
a11930 14
      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
      cookie.abfd = abfd;
      cookie.sym_hashes = elf_sym_hashes (abfd);
      cookie.bad_symtab = elf_bad_symtab (abfd);
      if (cookie.bad_symtab)
	{
	  cookie.locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
	  cookie.extsymoff = 0;
	}
      else
	{
	  cookie.locsymcount = symtab_hdr->sh_info;
	  cookie.extsymoff = symtab_hdr->sh_info;
	}
d11932 3
a11934 7
      if (bed->s->arch_size == 32)
	cookie.r_sym_shift = 8;
      else
	cookie.r_sym_shift = 32;

      cookie.locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (cookie.locsyms == NULL && cookie.locsymcount != 0)
d11936 6
a11941 8
	  cookie.locsyms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						 cookie.locsymcount, 0,
						 NULL, NULL, NULL);
	  if (cookie.locsyms == NULL)
	    {
	      info->callbacks->einfo (_("%P%X: can not read symbols: %E\n"));
	      return FALSE;
	    }
d11944 2
a11945 1
      if (stab != NULL)
a11946 32
	  cookie.rels = NULL;
	  count = stab->reloc_count;
	  if (count != 0)
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, stab, NULL, NULL,
						     info->keep_memory);
	  if (cookie.rels != NULL)
	    {
	      cookie.rel = cookie.rels;
	      cookie.relend = cookie.rels;
	      cookie.relend += count * bed->s->int_rels_per_ext_rel;
	      if (_bfd_discard_section_stabs (abfd, stab,
					      elf_section_data (stab)->sec_info,
					      bfd_elf_reloc_symbol_deleted_p,
					      &cookie))
		ret = TRUE;
	      if (elf_section_data (stab)->relocs != cookie.rels)
		free (cookie.rels);
	    }
	}

      if (eh != NULL)
	{
	  cookie.rels = NULL;
	  count = eh->reloc_count;
	  if (count != 0)
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, eh, NULL, NULL,
						     info->keep_memory);
	  cookie.rel = cookie.rels;
	  cookie.relend = cookie.rels;
	  if (cookie.rels != NULL)
	    cookie.relend += count * bed->s->int_rels_per_ext_rel;

d11951 1
a11951 4

	  if (cookie.rels != NULL
	      && elf_section_data (eh)->relocs != cookie.rels)
	    free (cookie.rels);
d11958 1
a11958 8
      if (cookie.locsyms != NULL
	  && symtab_hdr->contents != (unsigned char *) cookie.locsyms)
	{
	  if (! info->keep_memory)
	    free (cookie.locsyms);
	  else
	    symtab_hdr->contents = (unsigned char *) cookie.locsyms;
	}
@


1.286
log
@	* elf-bfd.h (bfd_elf_perform_complex_relocation): Update prototype.
	* elflink.c (bfd_elf_perform_complex_relocation): Return status.
	Don't print reloc overflow message.
	* elf32-mep.c (mep_elf_relocate_section): Handle status from
	bfd_elf_perform_complex_relocation.
@
text
@d8539 9
a8547 4
		    /* STT_TLS symbols are relative to PT_TLS segment
		       base.  */
		    BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
		    sym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
@


1.285
log
@	* elf-bfd.h (bfd_elf_match_symbols_in_sections): Don't declare.
	* elflink.c (bfd_elf_match_symbols_in_sections): Make static.
	Remove section name comparisons.
@
text
@d7649 1
a7649 1
void
d7651 1
a7651 1
				    asection *input_section,
d7658 1
d7688 1
d7690 6
a7695 13
    {
      /* Now do an overflow check.  */
      if (bfd_check_overflow ((signed_p
			       ? complain_overflow_signed
			       : complain_overflow_unsigned),
			      len, 0, (8 * wordsz),
			      relocation) == bfd_reloc_overflow)
	(*_bfd_error_handler)
	  ("%s (%s + 0x%lx): relocation overflow: 0x%lx %sdoes not fit "
	   "within 0x%lx",
	   input_bfd->filename, input_section->name, rel->r_offset,
	   relocation, (signed_p ? "(signed) " : ""), mask);
    }
d7709 1
@


1.284
log
@	PR ld/4424
	* config.bfd (targ_selvecs): Add bfd_elf64_alpha_vec for
	alpha/FreeBSD.  Add bfd_elf64_sparc_vec for sparc64/FreeBSD.
	Add bfd_elf32_i386_vec and bfd_efi_app_ia32_vec for i386/FreeBSD.
	(targ64_selvecs): Set for i386/FreeBSD.
	* elf-bfd.h (elf_backend_data): Add relocs_compatible.
	(_bfd_elf_default_relocs_compatible): Declare.
	(_bfd_elf_relocs_compatible): Declare.
	* elfxx-target.h (elf_backend_relocs_compatible): Define.
	(elfNN_bed): Init new relocs_compatible field.
	* elflink.c (_bfd_elf_default_relocs_compatible): New function.
	(_bfd_elf_relocs_compatible): New function.
	(elf_link_add_object_symbols): Call bed->relocs_compatible.
	* elf32-i386.c (elf_backend_relocs_compatible): Define.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d6926 1
a6926 1
bfd_boolean
a6944 7
  /* If both are .gnu.linkonce sections, they have to have the same
     section name.  */
  if (CONST_STRNEQ (sec1->name, ".gnu.linkonce")
      && CONST_STRNEQ (sec2->name, ".gnu.linkonce"))
    return strcmp (sec1->name + sizeof ".gnu.linkonce",
		   sec2->name + sizeof ".gnu.linkonce") == 0;

a6952 9
  if ((elf_section_flags (sec1) & SHF_GROUP) != 0
      && (elf_section_flags (sec2) & SHF_GROUP) != 0)
    {
      /* If both are members of section groups, they have to have the
	 same group name.  */
      if (strcmp (elf_group_name (sec1), elf_group_name (sec2)) != 0)
	return FALSE;
    }

@


1.283
log
@	* elflink.c (_bfd_elf_check_kept_section): Use the section rawsize
	values if they are set.
@
text
@d3255 34
d4676 2
a4677 2
      && htab->root.creator == abfd->xvec
      && bed->check_relocs != NULL)
@


1.282
log
@PR 5160
* elflink.c (eval_symbol): Remove bufsz variable and use sizeof(symbuf) where necessary.
@
text
@d8789 3
a8791 1
      if (kept != NULL && sec->size != kept->size)
@


1.281
log
@	* elflink.c: Formatting.
@
text
@d7392 2
a7393 2
  int len;
  int symlen;
d7396 1
a7396 2
  const int bufsz = 4096;
  char symbuf[bufsz];
d7404 1
a7404 1
  if (len < 1 || len > bufsz)
d7429 1
a7429 1
      if (symend < sym || symlen + 1 > bufsz)
@


1.280
log
@bfd/
	* elflink.c (resolve_symbol): Handle symbols in SEC_MERGE
	sections.  Don't test symbol st_shndx.  Don't bother with
	bfd_link_hash_common symbols.  Print longs rather than ints
	in debug messages.
	(eval_symbol): Replace "sym" and "advanced" params with "symp".
	Replace "addr" and "section_offset" params with "dot".  Don't
	cast bfd_vma values to signed, cast them to bfd_signed_vma.
	(bfd_elf_perform_complex_relocation): Delete "output_bfd", "info",
	"local_syms" and "local_sections" params.  Add "relocation".
	Delete code calculating relocation value.
	(evaluate_complex_relocation_symbols): Delete function.  Fold into..
	(elf_link_input_bfd): ..existing code examining relocs.
	* elf-bfd.h (bfd_elf_perform_complex_relocation): Update prototype.
	* elf32-mep.c (mep_elf_check_relocs): Delete function.
	(mep_elf_gc_sweep_hook, mep_elf_gc_mark_hook): Likewise.
	(mep_elf_object_p): Don't set elf_bad_symtab.
	(elf_backend_check_relocs): Don't define.
	(elf_backend_gc_mark_hook, elf_backend_gc_sweep_hook): Likewise.
	(elf_backend_can_gc_sections, USE_RELA): Likwise.
	(mep_elf_relocate_section): Move bfd_elf_perform_complex_relocation
	call after we have calculated reloc value.  Delete local sym
	debug code.  Use RELOC_FOR_GLOBAL_SYMBOL.  Delete addend
	adjusting code..
	(elf_backend_rela_normal): ..instead define this.
ld/testsuite/
	* ld-selective/sel-dump.exp: Add am33, m88k, mep to xfails.
	* ld-selective/selective.exp: Don't run for same target list
	we xfail sel-dump.
@
text
@d455 1
a455 1
      || (d != NULL 
d504 1
a504 1
         the versioned symbol point to this one.  */
d5000 1
a5000 1
  
d7206 1
a7206 1
   relocations themselves. 
d7232 5
a7236 5
set_symbol_value (bfd *                         bfd_with_globals,
		  Elf_Internal_Sym *		isymbuf,
		  size_t			locsymcount,
		  size_t                        symidx,
		  bfd_vma                       val)
d7272 14
a7285 14
static bfd_boolean 
resolve_symbol (const char *                  name,
		bfd *                         input_bfd,
		struct elf_final_link_info *  finfo,
		bfd_vma *                     result,
		Elf_Internal_Sym *            isymbuf,
		size_t                        locsymcount)
{
  Elf_Internal_Sym *            sym;
  struct bfd_link_hash_entry *  global_entry;
  const char *                  candidate = NULL;
  Elf_Internal_Shdr *           symtab_hdr;
  size_t                        i;
  
d7317 2
a7318 1
  global_entry = bfd_link_hash_lookup (finfo->info->hash, name, FALSE, FALSE, TRUE);
d7321 1
a7321 1
  
d7325 3
a7327 3
      * result = global_entry->u.def.value 
	+ global_entry->u.def.section->output_section->vma 
	+ global_entry->u.def.section->output_offset;
d7333 1
a7333 1
    } 
d7339 3
a7341 3
resolve_section (const char *  name,
		 asection *    sections,
		 bfd_vma *     result)
d7343 2
a7344 2
  asection *    curr;
  unsigned int  len;
d7346 1
a7346 1
  for (curr = sections; curr; curr = curr->next)    
d7354 1
a7354 1
  for (curr = sections; curr; curr = curr->next)    
d7357 1
a7357 1
      if (len > strlen (name)) 
d7371 1
a7371 1
  
d7376 1
a7376 2
undefined_reference (const char *  reftype,
		     const char *  name)
d7378 2
a7379 1
  _bfd_error_handler (_("undefined %s reference in complex symbol: %s"), reftype, name);
d7383 15
a7397 15
eval_symbol (bfd_vma *                     result,
	     const char **                 symp,
	     bfd *                         input_bfd,
	     struct elf_final_link_info *  finfo,
	     bfd_vma                       dot,
	     Elf_Internal_Sym *            isymbuf,
	     size_t                        locsymcount,
	     int                           signed_p)
{
  int           len;
  int           symlen;
  bfd_vma       a;
  bfd_vma       b;
  const int     bufsz = 4096;
  char          symbuf [bufsz];
d7399 2
a7400 2
  const char *  symend;
  bfd_boolean   symbol_is_section = FALSE;
d7410 1
a7410 1
  
d7425 1
a7425 1
    case 's':      
d7430 1
a7430 1
      if ((symend < sym) || ((symlen + 1) > bufsz))
d7437 1
a7437 1
      symbuf [symlen] = '\0';
d7439 2
a7440 2
      
      /* Is it always possible, with complex symbols, that gas "mis-guessed" 
d7445 1
a7445 1
      if (symbol_is_section) 
d7454 2
a7455 2
	} 
      else 
d7468 1
a7468 1
      
d7475 2
a7476 2
      if (* sym == ':')						\
        ++ sym;							\
d7480 2
a7481 2
        return FALSE;						\
      if (signed_p)                                             \
d7483 2
a7484 2
      else                                                      \
        * result = op a;                                        \
d7492 2
a7493 2
      if (* sym == ':')						\
        ++ sym;							\
d7497 1
a7497 1
        return FALSE;						\
d7501 2
a7502 2
        return FALSE;						\
      if (signed_p)                                             \
d7504 2
a7505 2
      else                                                      \
        * result = a op b;                                      \
d7540 5
a7544 5
put_value (bfd_vma        size,
	   unsigned long  chunksz,
	   bfd *          input_bfd,
	   bfd_vma        x,
	   bfd_byte *     location)
d7548 1
a7548 1
  for (; size; size -= chunksz, location -= chunksz, x >>= (chunksz * 8)) 
d7575 5
a7579 5
static bfd_vma 
get_value (bfd_vma        size,
	   unsigned long  chunksz,
	   bfd *          input_bfd,
	   bfd_byte *     location)
d7583 1
a7583 1
  for (; size; size -= chunksz, location += chunksz) 
d7611 10
a7620 11
static void 
decode_complex_addend
    (unsigned long * start,   /* in bits */
     unsigned long * oplen,   /* in bits */
     unsigned long * len,     /* in bits */
     unsigned long * wordsz,  /* in bytes */
     unsigned long * chunksz,  /* in bytes */
     unsigned long * lsb0_p,
     unsigned long * signed_p,
     unsigned long * trunc_p,
     unsigned long encoded)
d7646 1
a7646 1
      word size, etc) encoded within it.).  */ 
d7648 3
a7650 3
  decode_complex_addend (& start, & oplen, & len, & wordsz, 
			 & chunksz, & lsb0_p, & signed_p, 
			 & trunc_p, rel->r_addend);
d7659 1
a7659 1
  x = get_value (wordsz, chunksz, input_bfd, contents + rel->r_offset);	  
d7673 4
a7676 4
      if (bfd_check_overflow ((signed_p ? 
			       complain_overflow_signed : 
			       complain_overflow_unsigned),
			      len, 0, (8 * wordsz), 
d7678 1
a7678 1
	(*_bfd_error_handler) 
d7680 1
a7680 1
	   "within 0x%lx", 
d7684 1
a7684 1
	  
d7693 1
a7693 1
	  relocation, (mask << shift), 
d8192 1
a8192 1
         beyond 64k.  */
d9920 1
a9920 1
	    
d10779 1
a10779 1
		 info->callbacks->einfo 
@


1.279
log
@	* elflink.c (set_symbol_value): Add isymbuf and locsymcount
	params.  Change symidx to a size_t.  Don't access past end
	of symbol buffer.
	(resolve_symbol): Add isymbuf param and use instead of
	finfo->internal_syms.
	(eval_symbol, evaluate_complex_relocation_symbols): Likewise.
	(elf_link_input_bfd): Don't read symbols specially for
	evaluate_complex_relocation_symbols.
@
text
@a7283 1
  asection *                    sec = NULL;
a7290 1
      sec = finfo->sections [i];
d7299 2
a7300 2
      printf ("Comparing string: '%s' vs. '%s' = 0x%x\n", 
	      name, candidate, (unsigned int)sym->st_value);
d7304 1
a7304 1
	  * result = sym->st_value;
d7306 2
a7307 11
	  if (sym->st_shndx > SHN_UNDEF && 
	      sym->st_shndx < SHN_LORESERVE)
	    {
#ifdef DEBUG
	      printf ("adjusting for sec '%s' @@ 0x%x + 0x%x\n",
		      sec->output_section->name, 
		      (unsigned int)sec->output_section->vma, 
		      (unsigned int)sec->output_offset);
#endif
	      * result += sec->output_offset + sec->output_section->vma;
	    }
d7309 2
a7310 1
	  printf ("Found symbol with effective value %8.8x\n", (unsigned int)* result);
d7328 2
a7329 2
      printf ("Found GLOBAL symbol '%s' with value %8.8x\n",
	      global_entry->root.string, (unsigned int)*result);
a7333 12
  if (global_entry->type == bfd_link_hash_common)
    {
      *result = global_entry->u.def.value +
	bfd_com_section_ptr->output_section->vma +
	bfd_com_section_ptr->output_offset;
#ifdef DEBUG
      printf ("Found COMMON symbol '%s' with value %8.8x\n",
	      global_entry->root.string, (unsigned int)*result);
#endif
      return TRUE;
    }
  
d7383 1
a7383 2
	     char *                        sym,
	     char **                       advanced,
d7386 1
a7386 2
	     bfd_vma                       addr,
	     bfd_vma                       section_offset,
d7397 1
d7413 2
a7414 2
      * result = addr + section_offset;
      * advanced = sym + 1;
d7418 2
a7419 2
      ++ sym;
      * result = strtoul (sym, advanced, 16);
d7425 3
a7427 3
      ++ sym;
      symlen = strtol (sym, &sym, 10);
      ++ sym; /* Skip the trailing ':'.  */
d7437 1
a7437 1
      * advanced = sym + symlen;
d7476 3
a7478 3
      if (!eval_symbol (&a, sym, &sym, input_bfd, finfo, addr,	\
			section_offset, isymbuf, locsymcount,	\
			signed_p))				\
d7481 1
a7481 1
        * result = op ((signed)a);         			\
a7483 1
      * advanced = sym; 					\
d7493 3
a7495 3
      if (!eval_symbol (&a, sym, &sym, input_bfd, finfo, addr,	\
			section_offset, isymbuf, locsymcount,	\
			signed_p))				\
d7497 3
a7499 4
      ++ sym;							\
      if (!eval_symbol (&b, sym, &sym, input_bfd, finfo, addr,	\
			section_offset, isymbuf, locsymcount,	\
			signed_p))				\
d7502 1
a7502 1
        * result = ((signed) a) op ((signed) b);	        \
a7504 1
      * advanced = sym;						\
a7537 135
/* Entry point to evaluator, called from elf_link_input_bfd.  */

static bfd_boolean
evaluate_complex_relocation_symbols (bfd *input_bfd,
				     struct elf_final_link_info *finfo,
				     Elf_Internal_Sym *isymbuf,
				     size_t locsymcount)
{
  const struct elf_backend_data * bed;
  Elf_Internal_Shdr *             symtab_hdr;
  struct elf_link_hash_entry **   sym_hashes;
  asection *                      reloc_sec;
  bfd_boolean                     result = TRUE;

  /* For each section, we're going to check and see if it has any
     complex relocations, and we're going to evaluate any of them
     we can.  */

  if (finfo->info->relocatable)
    return TRUE;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  bed = get_elf_backend_data (input_bfd);

  for (reloc_sec = input_bfd->sections; reloc_sec; reloc_sec = reloc_sec->next)
    {
      Elf_Internal_Rela * internal_relocs;
      unsigned long i;

      /* This section was omitted from the link.  */
      if (! reloc_sec->linker_mark)
	continue;

      /* Only process sections containing relocs.  */
      if ((reloc_sec->flags & SEC_RELOC) == 0)
	continue;

      if (reloc_sec->reloc_count == 0)
	continue;

      /* Read in the relocs for this section.  */
      internal_relocs
	= _bfd_elf_link_read_relocs (input_bfd, reloc_sec, NULL,
				     (Elf_Internal_Rela *) NULL,
				     FALSE);
      if (internal_relocs == NULL)
	continue;

      for (i = reloc_sec->reloc_count; i--;)
	{
	  Elf_Internal_Rela * rel;
	  char * sym_name;
	  bfd_vma index;
	  Elf_Internal_Sym * sym;
	  bfd_vma result;
	  bfd_vma section_offset;
	  bfd_vma addr;
	  int signed_p = 0;

	  rel = internal_relocs + i;
	  section_offset = reloc_sec->output_section->vma
	    + reloc_sec->output_offset;
	  addr = rel->r_offset;

	  index = ELF32_R_SYM (rel->r_info);
	  if (bed->s->arch_size == 64)
	    index >>= 24;

	  if (index == STN_UNDEF)
	    continue;

	  if (index < locsymcount)
	    {
	      /* The symbol is local.  */
	      sym = isymbuf + index;

	      /* We're only processing STT_RELC or STT_SRELC type symbols.  */
	      if ((ELF_ST_TYPE (sym->st_info) != STT_RELC) &&
		  (ELF_ST_TYPE (sym->st_info) != STT_SRELC))
		continue;

	      sym_name = bfd_elf_string_from_elf_section
		(input_bfd, symtab_hdr->sh_link, sym->st_name);

	      signed_p = (ELF_ST_TYPE (sym->st_info) == STT_SRELC);
	    }
	  else
	    {
	      /* The symbol is global.  */
	      struct elf_link_hash_entry * h;

	      if (elf_bad_symtab (input_bfd))
		continue;

	      h = sym_hashes [index - locsymcount];
	      while (   h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;

	      if (h->type != STT_RELC && h->type != STT_SRELC)
		continue;

	      signed_p = (h->type == STT_SRELC);
	      sym_name = (char *) h->root.root.string;
	    }
#ifdef DEBUG
	  printf ("Encountered a complex symbol!");
	  printf (" (input_bfd %s, section %s, reloc %ld\n",
		  input_bfd->filename, reloc_sec->name, i);
	  printf (" symbol: idx  %8.8lx, name %s\n",
		  index, sym_name);
	  printf (" reloc : info %8.8lx, addr %8.8lx\n",
		  rel->r_info, addr);
	  printf (" Evaluating '%s' ...\n ", sym_name);
#endif
	  if (eval_symbol (& result, sym_name, & sym_name, input_bfd, 
			   finfo, addr, section_offset, isymbuf, locsymcount,
			   signed_p))
	    /* Symbol evaluated OK.  Update to absolute value.  */
	    set_symbol_value (input_bfd, isymbuf, locsymcount, index, result);

	  else
	    result = FALSE;
	}

      if (internal_relocs != elf_section_data (reloc_sec)->relocs)
	free (internal_relocs);
    }

  /* If nothing went wrong, then we adjusted 
     everything we wanted to adjust.  */
  return result;
}

d7633 8
a7640 18
bfd_elf_perform_complex_relocation
    (bfd *                   output_bfd ATTRIBUTE_UNUSED,
     struct bfd_link_info *  info,
     bfd *                   input_bfd,
     asection *              input_section,
     bfd_byte *              contents,
     Elf_Internal_Rela *     rel,
     Elf_Internal_Sym *      local_syms,
     asection **             local_sections)
{
  const struct elf_backend_data * bed;
  Elf_Internal_Shdr * symtab_hdr;
  asection * sec;
  bfd_vma relocation = 0, shift, x;
  bfd_vma r_symndx;
  bfd_vma mask;
  unsigned long start, oplen, len, wordsz, 
    chunksz, lsb0_p, signed_p, trunc_p;
a7646 54
  r_symndx = ELF32_R_SYM (rel->r_info);
  bed = get_elf_backend_data (input_bfd);
  if (bed->s->arch_size == 64)
    r_symndx >>= 24;

#ifdef DEBUG
  printf ("Performing complex relocation %ld...\n", r_symndx);
#endif

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  if (r_symndx < symtab_hdr->sh_info)
    {
      /* The symbol is local.  */
      Elf_Internal_Sym * sym;

      sym = local_syms + r_symndx;
      sec = local_sections [r_symndx];
      relocation = sym->st_value;
      if (sym->st_shndx > SHN_UNDEF && 
	  sym->st_shndx < SHN_LORESERVE)
	relocation += (sec->output_offset +
		       sec->output_section->vma);
    }
  else
    {
      /* The symbol is global.  */
      struct elf_link_hash_entry **sym_hashes;
      struct elf_link_hash_entry * h;

      sym_hashes = elf_sym_hashes (input_bfd);
      h = sym_hashes [r_symndx];

      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      if (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
	{
	  sec = h->root.u.def.section;
	  relocation = h->root.u.def.value;

	  if (! bfd_is_abs_section (sec))
	    relocation += (sec->output_section->vma 
			   + sec->output_offset); 
	}
      if (h->root.type == bfd_link_hash_undefined
	  && !((*info->callbacks->undefined_symbol)
	       (info, h->root.root.string, input_bfd,
		input_section, rel->r_offset,
		info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		|| ELF_ST_VISIBILITY (h->other))))
	return;
    }
a8990 4
  if (! evaluate_complex_relocation_symbols (input_bfd, finfo, isymbuf,
					     locsymcount))
    return FALSE;

d9032 1
d9035 1
d9057 1
a9057 5
	  /* Run through the relocs looking for any against symbols
	     from discarded sections and section symbols from
	     removed link-once sections.  Complain about relocs
	     against discarded sections.  Zero relocs against removed
	     link-once sections.  */
d9059 20
a9078 3
	    {
	      Elf_Internal_Rela *rel, *relend;
	      unsigned int action = (*bed->action_discarded) (o);
d9080 3
a9082 3
	      rel = internal_relocs;
	      relend = rel + o->reloc_count * bed->s->int_rels_per_ext_rel;
	      for ( ; rel < relend; rel++)
d9084 8
a9091 4
		  unsigned long r_symndx = rel->r_info >> r_sym_shift;
		  asection **ps, *sec;
		  struct elf_link_hash_entry *h = NULL;
		  const char *sym_name;
d9093 8
a9100 2
		  if (r_symndx == STN_UNDEF)
		    continue;
d9102 10
a9111 5
		  if (r_symndx >= locsymcount
		      || (elf_bad_symtab (input_bfd)
			  && finfo->sections[r_symndx] == NULL))
		    {
		      h = sym_hashes[r_symndx - extsymoff];
d9113 5
a9117 6
		      /* Badly formatted input files can contain relocs that
			 reference non-existant symbols.  Check here so that
			 we do not seg fault.  */
		      if (h == NULL)
			{
			  char buffer [32];
d9119 5
a9123 8
			  sprintf_vma (buffer, rel->r_info);
			  (*_bfd_error_handler)
			    (_("error: %B contains a reloc (0x%s) for section %A "
			       "that references a non-existent global symbol"),
			     input_bfd, o, buffer);
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
d9125 18
a9142 7
		      while (h->root.type == bfd_link_hash_indirect
			     || h->root.type == bfd_link_hash_warning)
			h = (struct elf_link_hash_entry *) h->root.u.i.link;

		      if (h->root.type != bfd_link_hash_defined
			  && h->root.type != bfd_link_hash_defweak)
			continue;
d9144 5
a9148 11
		      ps = &h->root.u.def.section;
		      sym_name = h->root.root.string;
		    }
		  else
		    {
		      Elf_Internal_Sym *sym = isymbuf + r_symndx;
		      ps = &finfo->sections[r_symndx];
		      sym_name = bfd_elf_sym_name (input_bfd,
						   symtab_hdr,
						   sym, *ps);
		    }
d9150 2
d9157 1
a9157 1
		      if (action & COMPLAIN)
d9169 1
a9169 1
		      if (action & PRETEND)
@


1.278
log
@	* elf.c (bfd_section_from_shdr): Check bfd_alloc return.
	(elfcore_write_note): Check realloc return.
	* elflink.c (_bfd_elf_link_find_version_dependencies): Check
	bfd_zalloc return.
	(_bfd_elf_link_assign_sym_version): Check bfd_malloc return.
	(elf_link_add_object_symbols): Likewise.
	(struct hash_codes_info): New.
	(elf_collect_hash_codes): Return bfd_malloc error.
	(struct collect_gnu_hash_codes): Add "error".
	(elf_collect_gnu_hash_codes): Return bfd_malloc error.
	(bfd_elf_size_dynamic_sections): Check return status of
	_bfd_elf_link_find_version_dependencies.
	(bfd_elf_size_dynsym_hash_dynstr): Adjust for elf_collect_hash_codes
	and elf_collect_gnu_hash_codes changes.
	(elf_sym_name_compare): Formatting.
	(elf_fixup_link_order): Use bfd_malloc, not xmalloc.
@
text
@d7233 3
a7235 2
		  struct elf_final_link_info *  finfo,    
		  int                           symidx,
d7238 3
a7240 4
  bfd_boolean                    is_local;
  Elf_Internal_Sym *             sym;
  struct elf_link_hash_entry **  sym_hashes;
  struct elf_link_hash_entry *   h;
d7242 1
a7242 5
  sym_hashes = elf_sym_hashes (bfd_with_globals);
  sym = finfo->internal_syms + symidx;  
  is_local = ELF_ST_BIND(sym->st_info) == STB_LOCAL;
  
  if (is_local)
d7244 13
a7256 16
      /* It is a local symbol: move it to the
	 "absolute" section and give it a value.  */
      sym->st_shndx = SHN_ABS;
      sym->st_value = val;
    }
  else 
    {
      /* It is a global symbol: set its link type
	 to "defined" and give it a value.  */
      h = sym_hashes [symidx];	  
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
      h->root.type = bfd_link_hash_defined;
      h->root.u.def.value = val;
      h->root.u.def.section = bfd_abs_section_ptr;
d7258 12
d7277 1
d7291 1
a7291 1
      sym = finfo->internal_syms + i;
d7411 1
d7469 3
a7471 2
	  if ((resolve_section (symbuf, finfo->output_bfd->sections, result) != TRUE)
	      && (resolve_symbol (symbuf, input_bfd, finfo, result, locsymcount) != TRUE))
d7479 4
a7482 3
	  if ((resolve_symbol (symbuf, input_bfd, finfo, result, locsymcount) != TRUE)
	      && (resolve_section (symbuf, finfo->output_bfd->sections,
				   result) != TRUE))
d7499 3
a7501 3
      if (eval_symbol (& a, sym, & sym, input_bfd, finfo, addr, \
                       section_offset, locsymcount, signed_p)   \
	                                             != TRUE)	\
d7517 3
a7519 3
      if (eval_symbol (& a, sym, & sym, input_bfd, finfo, addr, \
                       section_offset, locsymcount, signed_p)   \
                                                     != TRUE)	\
d7522 3
a7524 3
      if (eval_symbol (& b, sym, & sym, input_bfd, finfo, addr, \
                       section_offset, locsymcount, signed_p)   \
                                                     != TRUE)	\
d7567 3
a7569 2
evaluate_complex_relocation_symbols (bfd * input_bfd,
				     struct elf_final_link_info * finfo,
d7639 1
a7639 1
	      sym = finfo->internal_syms + index;
d7681 1
a7681 1
			   finfo, addr, section_offset, locsymcount,
d7684 1
a7684 1
	    set_symbol_value (input_bfd, finfo, index, result);
a9078 9
  /* evaluate_complex_relocation_symbols looks for symbols in
     finfo->internal_syms.  */
  else if (isymbuf != NULL && locsymcount != 0)
    {
      bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
			    finfo->internal_syms,
			    finfo->external_syms,
			    finfo->locsym_shndx);
    }
d9216 2
a9217 1
  if (! evaluate_complex_relocation_symbols (input_bfd, finfo, locsymcount))
@


1.277
log
@bfd/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* elf-bfd.h (elf_obj_tdata): Remove relro.

	* elf.c (get_program_header_size): Check info->relro instead
	of elf_tdata (abfd)->relro.
	(_bfd_elf_map_sections_to_segments): Likewise.
	(assign_file_positions_for_load_sections): Don't set
	PT_GNU_RELRO segment alignment here.
	(assign_file_positions_for_non_load_sections): Properly set up
	PT_GNU_RELRO segment for copying executable/shared library.
	(rewrite_elf_program_header): Remove PT_GNU_RELRO segment.
	(copy_elf_program_header): Set p_size and p_size_valid fields for
	PT_GNU_RELRO segment.

include/elf/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* internal.h (elf_segment_map): Add p_size and p_size_valid.
	(ELF_IS_SECTION_IN_SEGMENT): Allow SHF_TLS sections in
	PT_GNU_RELRO segments.

ld/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* ldexp.h (ldexp_control): Add relro, relro_start_stat and
	relro_end_stat.

	* ldexp.c (fold_binary): Set expld.dataseg.relro to
	exp_dataseg_relro_start or exp_dataseg_relro_end when
	seeing DATA_SEGMENT_ALIGN or DATA_SEGMENT_RELRO_END,
	respectively.

	* ldlang.c (lang_size_sections_1): Properly set
	expld.dataseg.relro_start_stat and
	expld.dataseg.relro_end_stat.
	(find_relro_section_callback): New function.
	(lang_find_relro_sections_1): Likewise.
	(lang_find_relro_sections): Likewise.
	(lang_process): Call lang_find_relro_sections for
	non-relocatable link.

ld/testsuite/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* ld-elf/binutils.exp: Update "-z relro" tests to use relro1.s.
	Add "-z relro" tests with relro2.s.  Add "-z relro" tests with
	TLS for objcopy.

	* ld-elf/relro1.s: New file.
	* ld-elf/relro2.s: Likewise.
@
text
@d1810 5
d1909 4
a1912 1
		return FALSE;
d4289 2
d4449 2
d4995 6
d5007 1
a5007 1
  unsigned long **valuep = data;
d5025 5
d5039 1
a5039 1
  *(*valuep)++ = ha;
d5069 1
d5100 5
d5975 2
d6198 1
a6198 1
	  unsigned long int *hashcodesp;
d6211 2
a6212 1
	  hashcodesp = hashcodes;
d6216 3
a6218 1
				  elf_collect_hash_codes, &hashcodesp);
d6220 1
a6220 1
	  nsyms = hashcodesp - hashcodes;
d6269 2
d6834 1
a6834 2
  Elf_Internal_Sym **ind, **indbufend, **indbuf
    = bfd_malloc2 (symcount, sizeof (*indbuf));
d6839 1
d9987 3
a9989 1
    xmalloc (seen_linkorder * sizeof (struct bfd_link_order *));
@


1.276
log
@Revision of previous delta using bfd_vma cast instead of 1L.
@
text
@a5329 1
  elf_tdata (output_bfd)->relro = info->relro;
@


1.275
log
@* elflink.c (elf_fixup_link_order): Rewrite conversion of s->alignment_power
  into an offset mask in order to avoid a gcc error message.
@
text
@d9968 1
a9968 1
      offset &= (bfd_vma)~((1L << s->alignment_power) - 1L);
@


1.274
log
@2007-07-26  Michael Snyder  <msnyder@@svkmacdonelllnx>

	* linker.c (bfd_section_already_linked_table_insert): Change
	return type from void to boolean.  Return FALSE on failure.
	(_bfd_generic_section_already_linked): Test return value of
	bfd_section_already_linked_table_insert, call fatal on error.

	* elflink.c (_bfd_elf_section_already_linked): Test return value
	of bfd_section_already_linked_table_insert, call fatal on error.

	* libbfd-in.h (bfd_section_already_linked_table_insert): Update
	return type to bfd_boolean.

	* libbfd.h: Regenerate.
@
text
@d9968 1
a9968 1
      offset &= ~(bfd_vma)((1 << s->alignment_power) - 1);
@


1.274.2.1
log
@* elflink.c (elf_fixup_link_order): Rewrite conversion of s->alignment_power
  into an offset mask in order to avoid a gcc error message.
@
text
@d9968 1
a9968 1
      offset &= (bfd_vma)~((1L << s->alignment_power) - 1L);
@


1.273
log
@	* elflink.c (_bfd_elf_fix_symbol_flags): Remove unnecessary
	check on dynobj.  Remove bed shadow.
@
text
@d12238 2
a12239 1
  bfd_section_already_linked_table_insert (already_linked_list, sec);
@


1.272
log
@2007-07-24  Michael Snyder  <msnyder@@access-company.com>

	* elflink.c (bfd_elf_final_link): Avoid redundant frees -- return
	on bfd_malloc error rather than goto error_return.
@
text
@d2371 1
a2371 1
  const struct elf_backend_data *bed = NULL;
d2432 4
a2435 7
  if (elf_hash_table (eif->info)->dynobj)
    {
      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
      if (bed->elf_backend_fixup_symbol
	  && !(*bed->elf_backend_fixup_symbol) (eif->info, h))
	return FALSE;
    }
d2473 1
a2473 5
    {
      const struct elf_backend_data *bed;
      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
      (*bed->elf_backend_hide_symbol) (eif->info, h, TRUE);
    }
@


1.271
log
@	* elflink.c (_bfd_elf_link_just_syms, merge_sections_remove_hook,
	_bfd_elf_merge_sections, _bfd_elf_link_hash_newfunc,
	_bfd_elf_link_hash_copy_indirect, _bfd_elf_link_hash_hide_symbol,
	_bfd_elf_link_hash_table_init, _bfd_elf_link_hash_table_create,
	bfd_elf_set_dt_needed_name, bfd_elf_get_dyn_lib_class,
	bfd_elf_set_dyn_lib_class, bfd_elf_get_needed_list,
	bfd_elf_get_runpath_list, bfd_elf_get_dt_soname,
	bfd_elf_get_bfd_needed_list, struct elf_symbuf_symbol,
	struct elf_symbuf_head, struct elf_symbol, elf_sort_elf_symbol,
	elf_sym_name_compare, elf_create_symbuf,
	bfd_elf_match_symbols_in_sections,
	_bfd_elf_match_sections_by_type): Move to here..
	* elf.c: ..from here.
@
text
@d11046 1
a11046 1
	goto error_return;
@


1.270
log
@bfd/
	* elflink.c (_bfd_elf_fix_symbol_flags): Only assert the type
	of weakdef->root.type if weakdef has no regular definition.

ld/testsuite/
	* ld-elf/weak-dyn-1a.s, ld-elf/weak-dyn-1b.s, ld-elf/weak-dyn-1.ld,
	* ld-elf/weak-dyn-1.rd: New test.
	* ld-elf/elf.exp: Run it.
@
text
@d6392 307
d6700 414
@


1.269
log
@2007-07-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (bfd_elf_record_link_assignment): Handle indirect
	symbol.
	(_bfd_elf_merge_symbol): Properly update normal symbol when
	overriding the versioned symbol from a dynamic library.
@
text
@a2494 2
      BFD_ASSERT (weakdef->root.type == bfd_link_hash_defined
		  || weakdef->root.type == bfd_link_hash_defweak);
d2503 5
a2507 2
	(*bed->elf_backend_copy_indirect_symbol) (eif->info, weakdef,
						  h);
@


1.268
log
@	* elflink.c (elf_link_add_object_symbols): Return via
	error_free_vers on "notice" failure.
@
text
@d471 1
a471 1
  struct elf_link_hash_entry *h;
d473 1
d483 1
a483 5
  /* Since we're defining the symbol, don't let it seem to have not
     been defined.  record_dynamic_symbol and size_dynamic_sections
     may depend on this.  */
  if (h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_undefined)
d485 9
d497 2
a498 4
    }

  if (h->root.type == bfd_link_hash_new)
    {
d501 19
d1443 1
a1446 1
      flip->root.u.undef.abfd = h->root.u.undef.abfd;
@


1.267
log
@Switch sources over to use the GPL version 3
@
text
@d3677 1
a3677 2
	return FALSE;

d4384 1
a4384 1
	return FALSE;
d4398 1
a4398 1
	return FALSE;
@


1.266
log
@bfd:
	* elf-attrs.c: New.
	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
	(elf-attrs.lo): Generate dependencies.
	* Makefile.in: Regenerate.
	* configure.in (elf): Add elf-attrs.lo.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add entries for object
	attributes.
	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
	New.
	(struct elf_obj_tdata): Add entries for object attributes.
	(elf_known_obj_attributes, elf_other_obj_attributes,
	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
	New.
	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
	(bfd_section_from_shdr): Handle attributes sections.
	* elflink.c (bfd_elf_final_link): Handle attributes sections.
	* elfxx-target.h (elf_backend_obj_attrs_vendor,
	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	(elfNN_bed): Update.
	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
	aeabi_attribute_list): Remove.
	(struct elf32_arm_obj_tdata): Remove object attributes fields.
	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
	Update for new object attributes interfaces.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
	elf32_arm_add_eabi_attr_int, attr_strdup,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
	to generic code in elf-attrs.c.
	(elf32_arm_obj_attrs_arg_type): New.
	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
	(bfd_elf32_bfd_final_link): Remove.
	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
	attributes.
	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.

binutils:
	* readelf.c (display_gnu_attribute): New.
	(process_arm_specific): Rearrange as process_attributes.
	(process_arm_specific): Replace by wrapper of process_attributes.

gas:
	* as.c (create_obj_attrs_section): New.
	(main): Call create_obj_attrs_section for ELF.
	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
	skip_past_comma, s_vendor_attribute): New.
	(potable): Add gnu_attribute for ELF.
	* read.h (s_vendor_attribute): Declare.
	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
	round s_vendor_attribute.
	(aeabi_set_public_attributes): Update for new attributes
	interfaces.
	(arm_md_end): Remove attributes contents setting now done
	generically.

include/elf:
	* arm.h (elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
	Tag_Symbol, Tag_compatibility): Remove.
	* common.h (SHT_GNU_ATTRIBUTES): Define.

ld:
	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
	(ATTRS_SECTIONS): Define.
	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.265
log
@	* elflink.c (_bfd_elf_link_assign_sym_version): Improve error
	message for undefined version nodes.
	(elf_gc_sweep): Don't warn when zero size sections are
	removed.
@
text
@d9269 3
d9319 34
d10297 10
@


1.264
log
@2007-05-16  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	* elflink.c (_bfd_elf_adjust_dynamic_copy): Align dynamic bss
	section to the minimum alignment.
@
text
@d1950 1
a1950 1
	    (_("%B: undefined versioned symbol name %s"),
d10519 1
a10519 1
	  if (info->print_gc_sections == TRUE)
@


1.263
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d2619 1
a2619 1
  unsigned int power_of_two, orig_power_of_two;
d2624 11
a2634 3
     requirement of symbols defined in the section.  */
  power_of_two = bfd_get_section_alignment (dynbss->owner, dynbss);
  orig_power_of_two = bfd_get_section_alignment (sec->owner, sec);
d2636 2
a2637 1
  if (orig_power_of_two > power_of_two)
d2641 1
a2641 1
				       orig_power_of_two))
d2645 1
a2645 10
  /* We make sure that the symbol will be aligned properly.  Since we
     don't know its alignment requirement, we start with the maximum
     alignment and check low bits of the symbol address for the
     minimum alignment.  */
  mask = ((bfd_vma) 1 << orig_power_of_two) - 1;
  while ((h->root.u.def.value & mask) != 0)
    {
       mask >>= 1;
       --orig_power_of_two;
    }
@


1.262
log
@include/elf/
	* spu.h (R_SPU_PPU32, R_SPU_PPU64): Define.
bfd/
	* reloc.c (BFD_RELOC_SPU_PPU32, BFD_RELOC_SPU_PPU64): Define.
	* elf-bfd.h (struct elf_backend_data): Change return type of
	elf_backend_relocate_section to int.
	* elf32-spu.c (elf_howto_table): Add howtos for R_SPU_PPU32 and
	R_SPU_PPU64.
	(spu_elf_bfd_to_reloc_type): Convert new relocs.
	(spu_elf_count_relocs): New function.
	(elf_backend_count_relocs): Define.
	(spu_elf_relocate_section): Arrange to emit R_SPU_PPU32 and
	R_SPU_PPU64 relocs.
	* elflink.c (elf_link_input_bfd): Emit relocs if relocate_section
	returns 2.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* config/tc-spu.c (md_pseudo_table): Add int, long, quad.  Call
	spu_cons for word.
	(md_assemble): Tidy use of insn.flag.
	(get_imm): Likewise.  Handle uppercase input too.
	(spu_cons): New function.
	* config/tc-spu.h (tc_fix_adjustable): Don't adjust SPU_PPU relocs.
	(TC_FORCE_RELOCATION): Don't resolve them either.
binutils/
	* embedspu.sh (find_prog): Prefer prog in same dir as embedspu
	over one found on the users path.
	(main): Generate .reloc for each R_SPU_PPU* reloc.
@
text
@d2612 46
@


1.261
log
@	* elflink.c (bfd_elf_final_link): Correct reloc handling for
	elf_backend_count_relocs.
	(bfd_elf_discard_info): Print an error if we can't read syms.
@
text
@d8201 1
a8201 1
  bfd_boolean (*relocate_section)
a8214 1
  bfd_boolean emit_relocs;
a8226 3
  emit_relocs = (finfo->info->relocatable
		 || finfo->info->emitrelocations);

d8442 1
d8580 1
a8580 1
	  if (! (*relocate_section) (output_bfd, finfo->info,
d8584 2
a8585 1
				     finfo->sections))
d8588 3
a8590 1
	  if (emit_relocs)
@


1.260
log
@2007-05-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_link_sort_relocs): Return if both .rela.dyn
	and .rel.dyn aren't present.
@
text
@d9315 2
a9316 1
		  relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
d9319 4
a9322 1
		  reloc_count = (*bed->elf_backend_count_relocs) (sec, relocs);
d9324 3
a9326 2
		  if (elf_section_data (o)->relocs != relocs)
		    free (relocs);
d11155 4
a11158 1
	    return FALSE;
@


1.259
log
@* elflink.c (elf_link_sort_relocs): If both .rela.dyn and .rel.dyn sections
  are present examine the indirect sections in an attempt to compute the
  correct relocation size.  If there is any ambiguity, produce an error and
  refuse to sort.
@
text
@d7224 2
a7225 2
  asection * rela_dyn;
  asection * rel_dyn;
d7364 3
a7366 1
  else if (rela_dyn == NULL || rela_dyn->size == 0)
d7369 1
a7369 1
    use_rela = TRUE;
@


1.258
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d7223 3
a7225 1
  asection *reldyn;
d7236 1
d7238 125
a7362 9
  reldyn = bfd_get_section_by_name (abfd, ".rela.dyn");
  if (reldyn == NULL || reldyn->size == 0)
    {
      reldyn = bfd_get_section_by_name (abfd, ".rel.dyn");
      if (reldyn == NULL || reldyn->size == 0)
	return 0;
      ext_size = bed->s->sizeof_rel;
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
d7364 2
d7367 3
d7371 1
d7376 7
a7382 1
  count = reldyn->size / ext_size;
d7385 1
a7385 1
  for (lo = reldyn->map_head.link_order; lo != NULL; lo = lo->next)
d7387 1
a7387 4
      {
	asection *o = lo->u.indirect.section;
	size += o->size;
      }
d7389 1
a7389 1
  if (size != reldyn->size)
d7394 2
d7397 1
d7410 1
a7410 1
  for (lo = reldyn->map_head.link_order; lo != NULL; lo = lo->next)
d7427 1
d7431 1
d7462 1
a7462 1
  for (lo = reldyn->map_head.link_order; lo != NULL; lo = lo->next)
d7481 1
a7481 1
  *psec = reldyn;
@


1.257
log
@2007-04-17  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf.c (_bfd_elf_is_function_type): New function.
	* elflink.c (_bfd_elf_merge_symbol): Use bed->is_function_type.
	(_bfd_elf_dynamic_symbol_p, _bfd_elf_symbol_refs_local_p,
	is_global_data_symbol_definition, elf_link_add_object_symbols): Ditto.
	* elf-bfd.h (elf_backend_data): Add is_function_type.
	(_bfd_elf_is_function_type): Add prototype.
	* elfxx-target.h (elf_backend_is_function_type): Add default
	definition.
	(elfNN_bed): Add elf_backend_is_function_type.
	* elf32-arm.c (elf32_arm_is_function_type): New function.
	(elf_backend_is_function_type): Define.

	ld/testsuite/
	* ld-arm/preempt-app.s: New test.
	* ld-arm/preempt-app.sym: New.
	* ld-arm/arm-elf.exp: Add preempt-app.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.256
log
@	* elflink.c (bfd_elf_final_link): Don't free symbuf for
	non-elf input bfds.
	(bfd_elf_size_dynamic_sections): Don't access elf_section_data
	for non-elf input bfds.
@
text
@d950 1
d965 3
a967 1
      && h->type != STT_NOTYPE)
d1158 5
d1209 1
a1209 1
      && ELF_ST_TYPE (sym->st_info) != STT_FUNC)
d1221 1
a1221 1
      && h->type != STT_FUNC)
a1227 1
  bed = get_elf_backend_data (abfd);
d1282 1
a1282 1
		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC))))
d1337 1
a1337 1
		  || h->type == STT_FUNC)))
d2650 2
d2677 6
d2686 1
a2686 1
      if (!ignore_protected || h->type != STT_FUNC)
d2713 3
d2752 6
d2759 1
a2759 1
  if (h->type != STT_FUNC)
d2808 1
d2810 1
a2810 1
  if (ELF_ST_TYPE (sym->st_info) == STT_FUNC)
a2818 1
  bed = get_elf_backend_data (abfd);
d3826 3
a3828 2
	      || (vernum > 1 && (! bfd_is_abs_section (sec)
				 || ELF_ST_TYPE (isym->st_info) == STT_FUNC)))
d3975 1
a3975 1
	  && ELF_ST_TYPE (isym->st_info) != STT_FUNC
d4100 2
a4101 1
	     covered by --warn-common.  */
d4443 1
a4443 1
	      && h->type != STT_FUNC)
@


1.255
log
@bfd/

2007-04-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4304
	* elflink.c (bfd_elf_final_link): Call einfo callback in
	bfd_link_info instead of _bfd_error_handler for DT_TEXTREL
	warning.

ld/testsuite/

2007-04-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4304
	* ld-i386/i386.exp: Run "warn1".

	* ld-i386/warn1.d: New file.
	* ld-i386/warn1.s: Likewise.
@
text
@d5525 10
a5534 9
		for (o = sub->sections; o != NULL; o = o->next)
		  if (elf_section_data (o)->this_hdr.sh_type
		      == SHT_PREINIT_ARRAY)
		    {
		      (*_bfd_error_handler)
			(_("%B: .preinit_array section is not allowed in DSO"),
			 sub);
		      break;
		    }
d9537 2
a9538 1
	if (elf_tdata (sub)->symbuf)
@


1.254
log
@	PR ld/4267
	* elflink.c (evaluate_complex_relocation_symbols): Use bfd_vma
	for rel->r_info values.
	(bfd_elf_perform_complex_relocation): Likewise.
@
text
@d9947 2
a9948 2
		  _bfd_error_handler
		    (_("warning: creating a DT_TEXTREL in a shared object."));
@


1.253
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d6761 1
a6761 1
	  unsigned long index;
d6952 1
a6952 1
  unsigned long r_symndx;
@


1.252
log
@2007-02-22  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elflink.c (gc_mark_hook_fn): Remove.
	(_bfd_elf_gc_mark): Rename gc_mark_hook_fn to elf_gc_mark_hook_fn.
	(bfd_elf_gc_sections): Ditto.  Call gc_mark_extra_sections.
	* elf-bfd.h (elf_gc_mark_hook_fn): Define.
	(elf_backend_data): Add gc_mark_extra_sections.
	* elfxx-target.h (elf_backend_gc_mark_extra_sections): Provide default
	definition.
	(elfNN_bed): Add elf_backend_gc_mark_extra_sections.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): New function.
	(elf_backend_gc_mark_extra_sections): Define.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armelftests): Add gc-unwind.h.
	* ld-arm/gc-unwind.s: New file.
	* ld-arm/gc-unwind.d: New file.
@
text
@a8396 10

		      /* Remove the symbol reference from the reloc, but
			 don't kill the reloc completely.  This is so that
			 a zero value will be written into the section,
			 which may have non-zero contents put there by the
			 assembler.  Zero in things like an eh_frame fde
			 pc_begin allows stack unwinders to recognize the
			 fde as bogus.  */
		      rel->r_info &= r_type_mask;
		      rel->r_addend = 0;
d8550 4
a8553 2
			     case of discarded link-once and discarded
			     SEC_MERGE sections, use the kept section.  */
@


1.251
log
@	* elf-bfd.h (struct elf_backend_data): Add default_execstack.
	* elflink.c (bfd_elf_size_dynamic_sections): Heed default_execstack.
	* elfxx-target.h (elf_backend_default_execstack): Define to 1.
	(elfNN_bed): Init new field.
	* elf64-ppc.c (elf_backend_default_execstack): Define to 0.
@
text
@a10090 4
typedef asection * (*gc_mark_hook_fn)
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

d10128 1
a10128 1
		  gc_mark_hook_fn gc_mark_hook)
d10497 1
a10497 3
  asection * (*gc_mark_hook)
    (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *);
d10544 4
@


1.250
log
@bfd/

2007-02-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3953
	* elflink.c (_bfd_elf_add_default_symbol): Check warning symbol
	when adding default symbol.

ld/testsuite/

2007-02-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3953
	* ld-elf/beginwarn.c: New file.
	* ld-elf/warn.out: Likewise.

	* ld-elf/shared.exp (build_tests): Add "Build warn libbar.so".
	(run_tests): Add "Run warn with versioned libfoo.so".

	* lib/ld-lib.exp (default_ld_relocate): Make exec_output global
	and remove target first.
	(default_ld_link): Likewise.
	(default_ld_simple_link): Likewise.
	(run_ld_link_exec_tests): Take an optional linker warning and
	check it.
	(default_ld_link): Check pruned linker output.
@
text
@d5240 1
d5267 1
a5267 1
	  else
a5287 1
  bed = get_elf_backend_data (output_bfd);
@


1.249
log
@	* elflink.c (evaluate_complex_relocation_symbols): Ignore relocs
	with a zero symbol index.
@
text
@d1559 4
@


1.248
log
@	* elflink.c (bfd_elf_discard_info): Tidy setting of "eh".
@
text
@d6772 4
a6775 1
 
@


1.247
log
@2007-02-05  Dave Brolley  <brolley@@redhat.com>
            Stan Cox  <scox@@redhat.com>

        PR ld/3972
        * elflink.c (elf_link_input_bfd): Always setup finfo->internal_syms.
@
text
@d3 1
a3 1
   2005, 2006 Free Software Foundation, Inc.
d10941 5
a10945 3
      eh = bfd_get_section_by_name (abfd, ".eh_frame");
      if (info->relocatable
	  || (eh != NULL
d10947 3
a10949 2
		  || bfd_is_abs_section (eh->output_section))))
	eh = NULL;
@


1.246
log
@Support for Toshiba MeP and for complex relocations.
@
text
@d8085 9
@


1.245
log
@	* bfd-in2.h: Regenerate.
	* bfd-in.h (bfd_arm_vfp11_fix): New enum. Specify how VFP11
	instruction scanning should be done.
	(bfd_elf32_arm_init_maps, bfd_elf32_arm_vfp11_erratum_scan)
	(bfd_elf32_arm_vfp11_fix_veneer_locations): Add prototypes.
	(bfd_elf32_arm_set_target_relocs): Add vfp11 fix type argument to
	prototype.
	* elf-bfd.h (elf_backend_write_section): Add struct bfd_link_info
	argument.
	* elf32-arm.c (VFP11_ERRATUM_VENEER_SECTION_NAME)
	(VFP11_ERRATUM_VENEER_ENTRY_NAME): Define macros.
	(elf32_vfp11_erratum_type): New enum.
	(elf32_vfp11_erratum_list): New struct. List of veneers or jumps to
	veneers.
	(_arm_elf_section_data): Add mapsize, erratumcount, erratumlist.
	(elf32_arm_link_hash_table): Add vfp11_erratum_glue_size,
	vfp11_fix and num_vfp11_fixes fields.
	(elf32_arm_link_hash_table_create): Initialise vfp11_fix,
	vfp11_erratum_glue_size, num_vfp11_fixes fields.
	(VFP11_ERRATUM_VENEER_SIZE): Define. Size of an (ARM) veneer.
	(bfd_elf32_arm_allocate_interworking_sections): Initialise erratum
	glue section.
	(elf32_arm_section_map_add): Add an code/data mapping symbol entry
	to a section's map.
	(record_vfp11_erratum_veneer): Create a single veneer, and its
	associated symbols.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Add vfp11 erratum glue.
	(bfd_elf32_arm_init_maps): Initialise mapping symbol table for input
	BFDs.
	(bfd_elf32_arm_set_vfp11_fix): Set the type of erratum workaround
	required.
	(bfd_arm_vfp11_pipe): Define VFP11 instruction pipes.
	(bfd_arm_vfp11_regno): Recode a register number from a VFP11 insn.
	(bfd_arm_vfp11_write_mask): Update write mask according to coded
	register number.
	(bfd_arm_vfp11_antidependency): New function.
	(bfd_arm_vfp11_insn_decode): Decode a VFP11 insn.
	(elf32_arm_compare_mapping): Declare.
	(bfd_elf32_arm_vfp11_erratum_scan): Scan the sections of an input
	BFD for potential erratum-triggering insns. Record results.
	(bfd_elf32_arm_vfp11_fix_veneer_locations): Find out where veneers
	and branches to veneers have been placed in virtual memory after
	layout.
	(bfd_elf32_arm_set_target_relocs): Set vfp11_fix field in global
	hash table.
	(elf32_arm_output_symbol_hook): Remove.
	(elf32_arm_write_section): Output veneers, and branches to veneers.
	Use maps from input sections, not output sections, for code
	byte-swapping.
	* elf32-ppc.c (ppc_elf_write_section): Add dummy link_info argument.
	* elf32-score.c (_bfd_score_elf_write_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_write_section): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_write_section): Likewise.
@
text
@d6351 710
d8222 3
@


1.244
log
@bfd/

2007-01-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3831
	* elf-bfd.h (bfd_elf_link_mark_dynamic_symbol): Add an
	argument, Elf_Internal_Sym *.

	* elflink.c (bfd_elf_link_mark_dynamic_symbol): Mark a data
	symbol dynamic if info->dynamic_data is TRUE.
	(bfd_elf_record_link_assignment): Updated call to
	bfd_elf_record_link_assignment.
	(_bfd_elf_merge_symbol): Likewise.  Always call
	bfd_elf_link_mark_dynamic_symbol.

include/

2007-01-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3831
	* bfdlink.h (bfd_link_info): Rename dynamic to dynamic_list.
	Add dynamic and dynamic_data.

ld/

2007-01-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3831
	* NEWS: Mention -Bsymbolic-functions, --dynamic-list-data and
	--dynamic-list-cpp-new.

	* ld.texinfo: Document -Bsymbolic-functions, --dynamic-list-data
	and --dynamic-list-cpp-new.

	* ldlang.c (lang_append_dynamic_list_cpp_new): New.
	(lang_process): Change link_info.dynamic to
	link_info.dynamic_list.
	(lang_append_dynamic_list): Likewise.
	* ldmain.c (main): Likewise.  Initialize link_info.dynamic and
	link_info.dynamic_data to FALSE.

	* ldlang.h (lang_append_dynamic_list_cpp_new): New.

	* lexsup.c (option_values): Add OPTION_DYNAMIC_LIST_DATA and
	OPTION_DYNAMIC_LIST_CPP_NEW.
	(ld_options): Add entries for -Bsymbolic-functions,
	--dynamic-list-data and --dynamic-list-cpp-new.  Make
	-Bsymbolic-functions an alias of --dynamic-list-data.
	(parse_args): Change link_info.dynamic to link_info.dynamic_list.
	Set link_info.dynamic to TRUE for --dynamic-list and
	--dynamic-list-cpp-typeinfo.  Handle --dynamic-list-data and
	--dynamic-list-cpp-new.

ld/testsuite/

2007-01-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3831
	* ld-elf/del.cc: New.
	* ld-elf/dl5.cc: Likewise.
	* ld-elf/dl5.out: Likewise.
	* ld-elf/new.cc: Likewise.

	* ld-elf/shared.exp: Add tests for --dynamic-list-data and
	 --dynamic-list-cpp-new.
@
text
@d7957 2
a7958 1
	  && (*bed->elf_backend_write_section) (output_bfd, o, contents))
@


1.243
log
@bfd/

2006-12-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_link_add_object_symbols): Remember the symbol
	size only if it is defined.

ld/testsuite/

2006-12-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/wrap.exp: New file.
	* ld-elf/wrap1.c: Likewise.
	* ld-elf/wrap1.out: Likewise.
	* ld-elf/wrap1a.c: Likewise.
	* ld-elf/wrap1b.c: Likewise.
@
text
@d441 2
a442 1
				  struct elf_link_hash_entry *h)
d444 1
a444 1
  struct bfd_elf_dynamic_list *d = info->dynamic;
d446 2
a447 1
  if (d == NULL || info->relocatable)
d450 7
a456 1
  if ((*d->match) (&d->head, NULL, h->root.root.string))
d494 1
a494 1
      bfd_elf_link_mark_dynamic_symbol (info, h);
d872 5
a882 1
      bfd_elf_link_mark_dynamic_symbol (info, h);
@


1.242
log
@	* elf-bfd.h (struct elf_backend_data): Add as_needed_cleanup hook.
	* elfxx-target.h (elf_backend_as_needed_cleanup): Define.
	(elfNN_bed): Add as_needed_cleanup hook.
	* elflink.c (elf_link_add_object_symbols): Call it when reverting
	hash table changes for unneeded --as-needed input.
	* elf64-ppc64.c (elf_backend_as_needed_cleanup): Define.
	(ppc64_elf_as_needed_cleanup): New function.
@
text
@d4038 2
a4039 2
	  /* Remember the symbol size and type.  */
	  if (isym->st_size != 0
d4042 3
a4044 1
	      if (h->size != 0 && h->size != isym->st_size && ! size_change_ok)
@


1.241
log
@	* elflink.c (bfd_elf_gc_sections): Also search for corresponding
	sections with .gnu.linkonce.t. prefix.
@
text
@d4254 2
@


1.240
log
@bfd/

2006-12-07  H.J. Lu <hjl@@gnu.org>

	PR ld/3666
	* elflink.c (elf_link_add_object_symbols): Keep symbol
	visibility for symbols from discarded section.

ld/testsuite/

2006-12-07  H.J. Lu <hjl@@gnu.org>

	PR ld/3666
	* ld-elf/group3a.d: New file.
	* ld-elf/group3a.s: Likewise.
	* ld-elf/group3b.d: Likewise.
	* ld-elf/group3b.s: Likewise.
@
text
@d9812 2
a9813 1
      /* Keep .gcc_except_table.* if the associated .text.* is
d9820 1
d9830 1
a9830 2
		unsigned o_name_prefix_len  = strlen (GCC_EXCEPT_TABLE_PREFIX);
		unsigned fn_name_prefix_len = strlen (TEXT_PREFIX);
d9832 1
d9834 6
a9839 1
		fn_name = bfd_malloc (strlen (sec_name) + fn_name_prefix_len + 1);
d9842 2
d9846 8
@


1.239
log
@bfd/
2006-12-04  Jan Beulich  <jbeulich@@novell.com>

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Don't create
	.eh_frame_hdr section from here anymore.
	(bfd_elf_size_dynamic_sections): Call _bfd_elf_maybe_strip_eh_frame_hdr
	a little earlier.

ld/
2006-12-04  Jan Beulich  <jbeulich@@novell.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open): Create
	.eh_frame_hdr section here.

ld/testsuite/
2006-12-04  Jan Beulich  <jbeulich@@novell.com>

	* ld-elf/eh-frame-hdr.d: New.
	* ld-elf/eh-frame-hdr.s: New.
	* ld-ia64/tlsbin.dd, ld-ia64/tlsbin.sd: Don't depend on exact linkage
	table layout.
@
text
@d3685 2
a3686 2
	      /* Symbols from discarded section are undefined, and have
		 default visibility.  */
a3688 2
	      isym->st_other = (STV_DEFAULT
				| (isym->st_other & ~ ELF_ST_VISIBILITY (-1)));
@


1.238
log
@	* elflink.c (_bfd_elf_check_kept_section): Test for kept group
	section.  Save result of checks in kept_section.
	(_bfd_elf_section_already_linked): Tidy.  Correct comments.
	Ignore all group member sections.  Handle special matching of
	single-member groups against linkonce sections via their group
	section.  When such a match is found, set kept_section to the
	group member section rather than to the group.
@
text
@a187 10
  if (! info->traditional_format)
    {
      s = bfd_make_section_with_flags (abfd, ".eh_frame_hdr",
				       flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;
      elf_hash_table (info)->eh_info.hdr_sec = s;
    }

d5274 3
a5283 3
  if (! _bfd_elf_maybe_strip_eh_frame_hdr (info))
    return FALSE;

@


1.237
log
@bfd/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* elf-bfd.h (elf_obj_tdata): Add symbuf.
	(_bfd_elf_section_already_linked): Add struct bfd_link_info *.
	(_bfd_elf_check_kept_section): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.

	* elf.c (assign_section_numbers): Updated to add
	struct bfd_link_info *.
	(bfd_elf_match_symbols_in_sections): Updated. Cache symbol
	buffer if info->reduce_memory_overheads is false.

	* elflink.c (match_group_member): Updated to add
	struct bfd_link_info *.
	(_bfd_elf_check_kept_section): Likewise.
	(elf_link_input_bfd): Likewise.
	(_bfd_elf_section_already_linked): Likewise.
	(bfd_elf_final_link): Free symbol buffer if
	info->reduce_memory_overheads is false.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Add
	struct bfd_link_info *.
	(_bfd_generic_section_already_linked): Likewise.
	* libbfd.h: Regenerated.

	* linker.c (bfd_section_already_linked): Add
	struct bfd_link_info *.
	(_bfd_generic_section_already_linked): Likewise.
	* targets.c (bfd_target): Add struct bfd_link_info * to
	_section_already_linked.
	* bfd-in2.h: Regenerated.

include/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* bfdlink.h (bfd_link_info): Add reduce_memory_overheads.

ld/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* ld.h (args_type): Remove reduce_memory_overheads.

	* ldlang.c (lang_map): Updated.
	(section_already_linked): Likewise.
	(print_input_section): Likewise.
	* ldmain.c (main): Likewise.
	* lexsup.c (parse_args): Likewise.
@
text
@d7290 2
a7291 2
   to replace it. Return the replacement if it is OK. Otherwise return
   NULL. */
d7301 1
a7301 1
      if (elf_sec_group (sec) != NULL)
d7305 1
a10319 1
  asection *group;
a10320 2
  /* A single member comdat group section may be discarded by a
     linkonce section. See below.  */
d10326 4
a10329 2
  /* Check if it belongs to a section group.  */
  group = elf_sec_group (sec);
d10331 3
a10333 3
  /* Return if it isn't a linkonce section nor a member of a group.  A
     comdat group section also has SEC_LINK_ONCE set.  */
  if ((flags & SEC_LINK_ONCE) == 0 && group == NULL)
a10335 11
  if (group)
    {
      /* If this is the member of a single member comdat group, check if
	 the group should be discarded.  */
      if (elf_next_in_group (sec) == sec
	  && (group->flags & SEC_LINK_ONCE) != 0)
	sec = group;
      else
	return;
    }

d10365 2
a10366 5
      /* We may have 3 different sections on the list: group section,
	 comdat section and linkonce section. SEC may be a linkonce or
	 group section. We match a group section with a group section,
	 a linkonce section with a linkonce section, and ignore comdat
	 section.  */
d10454 4
a10457 1
  if (group)
d10459 14
a10472 19
      /* If this is the member of a single member comdat group and the
	 group hasn't be discarded, we check if it matches a linkonce
	 section. We only record the discarded comdat group. Otherwise
	 the undiscarded group will be discarded incorrectly later since
	 itself has been recorded.  */
      for (l = already_linked_list->entry; l != NULL; l = l->next)
	if ((l->sec->flags & SEC_GROUP) == 0
	    && bfd_coff_get_comdat_section (l->sec->owner, l->sec) == NULL
	    && bfd_elf_match_symbols_in_sections (l->sec,
						  elf_next_in_group (sec),
						  info))
	  {
	    elf_next_in_group (sec)->output_section = bfd_abs_section_ptr;
	    elf_next_in_group (sec)->kept_section = l->sec;
	    group->output_section = bfd_abs_section_ptr;
	    break;
	  }
      if (l == NULL)
	return;
d10475 1
a10475 3
    /* There is no direct match. But for linkonce section, we should
       check if there is a match with comdat group member. We always
       record the linkonce section, discarded or not.  */
d10486 1
a10486 1
	      sec->kept_section = l->sec;
@


1.236
log
@bfd/
	* section.c (SEC_KEEP): Update comment.
	* bfd-in2.h: Regenerate.
	* elflink.c (bfd_elf_gc_sections): Ignore SEC_EXCLUDE sections.
	* merge.c (_bfd_merge_sections): Set SEC_KEEP on excluded sections.
	* stabs.c (_bfd_discard_section_stabs): Likewise.
	(_bfd_link_section_stabs): Likewise.  Simplify abs_section check.
ld/
	* ldlang.c (lang_map): Don't say SEC_LINKER_CREATED and SEC_KEEP
	sections have been discarded.
	(lang_do_version_exports_section): Set SEC_KEEP on export section.
	* emultempl/elf32.em (before_allocation): Set SEC_KEEP on warning
	sections.
@
text
@d7270 2
a7271 1
match_group_member (asection *sec, asection *group)
d7278 1
a7278 1
      if (bfd_elf_match_symbols_in_sections (s, sec))
d7294 1
a7294 1
_bfd_elf_check_kept_section (asection *sec)
d7302 1
a7302 1
	kept = match_group_member (sec, kept);
d7655 2
a7656 1
			  kept = _bfd_elf_check_kept_section (sec);
d8805 11
d10312 2
a10313 1
_bfd_elf_section_already_linked (bfd *abfd, struct bfd_section * sec)
d10479 2
a10480 1
						  elf_next_in_group (sec)))
d10501 1
a10501 1
	      && bfd_elf_match_symbols_in_sections (first, sec))
@


1.235
log
@bfd/

2006-10-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3290
	* elflink.c (elf_link_add_object_symbols): Hide definitions in
	debug sections.

ld/testsuite/

2006-10-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3290
	* ld-elf/dummy.c: New file.
	* ld-elf/dwarf.exp: Likewise.
	* ld-elf/dwarf1.c: Likewise.
	* ld-elf/dwarf1.h: Likewise.
	* ld-elf/dwarf1.out: Likewise.
	* ld-elf/dwarf1main.c: Likewise.
@
text
@d9797 1
a9797 1
	if ((o->flags & SEC_KEEP) != 0 && !o->gc_mark)
@


1.234
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d4159 7
@


1.233
log
@	* elflink.c (_bfd_elf_merge_symbol): Discard references to TLS
	symbols from the --just-syms file.
@
text
@d715 2
d724 7
a735 1
	  bfd *dynobj = elf_hash_table (info)->dynobj;
d737 2
a738 2
	  if (dynobj != NULL
	      && (ip = bfd_get_section_by_name (dynobj, p->name)) != NULL
d774 2
d5945 45
d5993 2
d5998 3
a6003 1
      const struct elf_backend_data *bed;
a6041 1
      bed = get_elf_backend_data (output_bfd);
d7830 18
@


1.232
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d835 9
@


1.231
log
@* bfd-in.h (CONST_STRNCPY) : Delete.
  (LITSTRCPY) : New.
  (LITMEMCPY) : New.
* bfd-in2.h : Regenerate.
* elflink.c  (bfd_elf_gc_sections) : Use LITMEMCPY. Don't manually calculate string lengths.
* nlmcode.h (nlm_swap_auxiliary_headers_in) : Use LITMEMCPY.
* nlmconv.c (main) : Use LITMEMCPY.
* prdbg.c (tg_class_static_member) : Use LITSTRCPY.
@
text
@d9251 34
a9288 4
typedef asection * (*gc_mark_hook_fn)
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

@


1.230
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d9694 2
d9699 1
a9699 1
	    if (CONST_STRNEQ (o->name, ".gcc_except_table."))
a9700 1
		unsigned long len;
d9702 1
d9704 2
d9707 2
a9708 2
		len = strlen (o->name + 18) + 1;
		fn_name = bfd_malloc (len + 6);
d9711 1
a9711 2
		memcpy (fn_name, STRING_COMMA_LEN (".text."));
		memcpy (fn_name + 6, o->name + 18, len);
@


1.229
log
@bfd/

2006-09-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3197
	* elflink.c (elf_link_output_extsym): Compute bucket only if
	needed.

ld/testsuite/

2006-09-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3197
	* ld-elf/hash.d: New test.
@
text
@d3207 1
a3207 1
	  if (strncmp (name, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0)
d4555 1
a4555 1
	    if (strncmp (".stab", stab->name, 5) == 0
d9697 1
a9697 1
	    if (strncmp (o->name, ".gcc_except_table.", 18) == 0)
d9707 1
a9707 1
		memcpy (fn_name, ".text.", 6);
d10227 1
a10227 1
  if (strncmp (name, ".gnu.linkonce.", sizeof (".gnu.linkonce.") - 1) == 0
@


1.228
log
@bfd/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_link_hash_entry): Add a dynamic field.
	(bfd_elf_link_mark_dynamic_symbol): New.
	(SYMBOLIC_BIND): New.

	* elf32-i386.c (elf_i386_check_relocs): Replace info->symbolic
	with SYMBOLIC_BIND (info, h).
	(elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_check_relocs): Likewise.

	* elflink.c (bfd_elf_link_mark_dynamic_symbol): New.
	(bfd_elf_record_link_assignment): Call
	bfd_elf_link_mark_dynamic_symbol on new entry.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_export_symbol): Return if the symbol isn't exported.
	(_bfd_elf_fix_symbol_flags): Replace info->symbolic with
	SYMBOLIC_BIND (info, h).
	(_bfd_elf_dynamic_symbol_p): Likewise.
	(_bfd_elf_symbol_refs_local_p): Likewise.
	(bfd_elf_size_dynamic_sections): Updated.

include/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_elf_dynamic_list): New.
	(bfd_link_info): Add a dynamic field.

ld/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (CXX): Set to g++.
	(CXX_FOR_TARGET): Likewise.
	* Makefile.in: Regenerated.

	* NEWS: Mention --dynamic-list.

	* ld.texinfo: Document --dynamic-list.

	* ldgram.y: Support dynamic list.

	* ldlang.c (lang_process): Call lang_finalize_version_expr_head
	on link_info.dynamic if needed.
	(lang_append_dynamic_list): New.
	(lang_append_dynamic_list_cpp_typeinfo): New.
	* ldlang.h (lang_append_dynamic_list): Likewise.
	* ldlang.h (lang_append_dynamic_list_cpp_typeinfo): Likewise.

	* ldlex.h (input_enum): Add input_dynamic_list.
	* ldlex.l: Handle it.

	* ldmain.c (main): Initialize link_info.dynamic.

	* lexsup.c (option_values): Add OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.
	(ld_options): Add entries for OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.
	(parse_args): Handle OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.

ld/testsuite/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/dl1.c: New file.
	* ld-elf/dl1.list: Likewise.
	* ld-elf/dl1.out: Likewise.
	* ld-elf/dl1main.c: Likewise.
	* ld-elf/dl2.c: Likewise.
	* ld-elf/dl2.list: Likewise.
	* ld-elf/dl2a.out: Likewise.
	* ld-elf/dl2b.out: Likewise.
	* ld-elf/dl2main.c: Likewise.
	* ld-elf/dl2xxx.c: Likewise.
	* ld-elf/dl2xxx.list: Likewise.
	* ld-elf/dl3.cc: Likewise.
	* ld-elf/dl3.list: Likewise.
	* ld-elf/dl3a.out: Likewise.
	* ld-elf/dl3b.out: Likewise.
	* ld-elf/dl3header.h: Likewise.
	* ld-elf/dl3main.cc: Likewise.

	* ld-elf/shared.exp: Updated.

	* lib/ld-lib.exp (run_ld_link_exec_tests): Take an optional
	argument for source language. Use CC/CXX for link, depending
	on source language.
	(run_cc_link_tests): Likewise.
@
text
@a7063 2
      size_t bucketcount;
      size_t bucket;
a7074 3
      bucketcount = elf_hash_table (finfo->info)->bucketcount;
      bucket = h->u.elf_hash_value % bucketcount;

d7080 5
@


1.227
log
@	* elf32-mips.c, elf64-mips.c, elfn32-mips.c
	(elf_backend_merge_symbol_attribute): Define.
	* elflink.c (elf_link_add_object_symbols): Merge only the ELF
	visibility flags.
	* elfxx-mips.c (_bfd_mips_elf_merge_symbol_attribute): New function.
@
text
@d447 15
d495 4
a498 1
    h->non_elf = 0;
d861 1
d1648 4
d2405 1
a2405 1
      && (eif->info->symbolic
d2634 1
a2634 1
  binding_stays_local_p = info->executable || info->symbolic;
d2697 1
a2697 1
  if (info->executable || info->symbolic)
d5348 2
a5349 1
      if (info->export_dynamic)
@


1.226
log
@* ldmain.c (main): Initialise print_gc_sections field of link_info structure.
* lexsup.c: Add --print-gc-sections and --no-print-gc-sections switches.
* ld.texinfo: Document new switches.
* NEWS: Mention new switches.
* bfdlink.h (struct bfd_link_info): New field: print_gc_sections.
* elflink.c (elf_gc_sweep): If info.print_gc_sections is true, list removed sections to stderr.
@
text
@d4061 1
a4061 1
	  if (isym->st_other != 0 && !dynamic)
d4065 3
a4067 3
	      /* Take the balance of OTHER from the definition.  */
	      other = (definition ? isym->st_other : h->other);
	      other &= ~ ELF_ST_VISIBILITY (-1);
@


1.225
log
@bfd/
	* bfd-in.h (enum notice_asneeded_action): Define.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_add_object_symbols): Call linker "notice"
	function with NULL name for as-needed handling.
ld/
	* ld.h (handle_asneeded_cref): Declare.
	* ldcref.c: Include objalloc.h.
	(old_table, old_count, old_tab, alloc_mark): New variables.
	(tabsize, entsize, refsize, old_symcount): Likewise.
	(add_cref): Use bfd_hash_allocate for refs.
	(handle_asneeded_cref): New function.
	* ldmain.c (notice): Call handle_asneeded_cref for NULL name.
@
text
@d9359 2
a9360 1
struct elf_gc_sweep_symbol_info {
d9423 3
@


1.224
log
@	* elflink.c (bfd_elf_size_dynsym_hash_dynstr): Fix cinfo.shift2 value.
@
text
@d3554 7
d4251 6
d4267 3
@


1.223
log
@* elflink.c (bfd_elf_size_dynsym_hash_dynstr): Move declarations
to the start of a block.
@
text
@d6082 1
a6082 1
	      cinfo.shift2 = maskbitslog2 + cinfo.shift1;
@


1.222
log
@bfd/

2006-07-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2884
	* elflink.c (_bfd_elf_merge_symbol): Copy the symbol info from
	the old versioned dynamic definition to the new one with
	non-default visibility.  Hide the symbol if it is hidden or
	internal.

ld/testsuite/

2006-07-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2884
	* ld-elf/begin.c: New file.
	* ld-elf/end.c: Likewise.
	* ld-elf/endhidden.c: Likewise.
	* ld-elf/endprotected.c: Likewise.
	* ld-elf/foo.c: Likewise.
	* ld-elf/foo.map: Likewise.
	* ld-elf/hidden.out: Likewise.
	* ld-elf/main.c: Likewise.
	* ld-elf/normal.out: Likewise.
	* ld-elf/shared.exp: Likewise.

	* lib/ld-lib.exp (run_cc_link_tests): New.
@
text
@d6063 1
a6064 1
	      unsigned long int maskwords, maskbitslog2;
@


1.221
log
@include/
	* bfdlink.h (struct bfd_link_info): Add emit_hash and
	emit_gnu_hash bitfields.
include/elf/
	* common.h (SHT_GNU_HASH, DT_GNU_HASH): Define.
ld/
	* scripttempl/elf.sc: Add .gnu.hash section.
	* emultempl/elf32.em (OPTION_HASH_STYLE): Define.
	(gld${EMULATION_NAME}_add_options): Register --hash-style option.
	(gld${EMULATION_NAME}_handle_option): Handle it.
	(gld${EMULATION_NAME}_list_options): Document it.
	* ldmain.c (main): Initialize emit_hash and emit_gnu_hash.
	* ld.texinfo: Document --hash-style option.
bfd/
	* elf.c (_bfd_elf_print_private_bfd_data): Handle DT_GNU_HASH.
	(bfd_section_from_shdr, elf_fake_sections, assign_section_numbers):
	Handle SHT_GNU_HASH.
	(special_sections_g): Include .gnu.hash section.
	(bfd_elf_gnu_hash): New function.
	* elf-bfd.h (bfd_elf_gnu_hash, _bfd_elf_hash_symbol): New prototypes.
	(struct elf_backend_data): Add elf_hash_symbol method.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Create .hash
	only if info->emit_hash, create .gnu.hash section if
	info->emit_gnu_hash.
	(struct collect_gnu_hash_codes): New type.
	(elf_collect_gnu_hash_codes, elf_renumber_gnu_hash_syms,
	_bfd_elf_hash_symbol): New functions.
	(compute_bucket_count): Don't compute HASHCODES array, instead add
	that and NSYMS as arguments.  Use bed->s->sizeof_hash_entry
	instead of bed->s->arch_size / 8.  Fix .hash size estimation.
	When not optimizing, use the number of hashed symbols rather than
	dynsymcount.
	(bfd_elf_size_dynamic_sections): Only add DT_HASH if info->emit_hash,
	and ADD DT_GNU_HASH if info->emit_gnu_hash.
	(bfd_elf_size_dynsym_hash_dynstr): Size .hash only if info->emit_hash,
	adjust compute_bucket_count caller.  Create and populate .gnu.hash
	section if info->emit_gnu_hash.
	(elf_link_output_extsym): Only populate .hash section if
	finfo->hash_sec != NULL.
	(bfd_elf_final_link): Adjust assertion.  Handle DT_GNU_HASH.
	* elfxx-target.h (elf_backend_hash_symbol): Define if not yet defined.
	(elfNN_bed): Add elf_backend_hash_symbol.
	* elf64-x86-64.c (elf64_x86_64_hash_symbol): New function.
	(elf_backend_hash_symbol): Define.
	* elf32-i386.c (elf_i386_hash_symbol): New function.
	(elf_backend_hash_symbol): Define.
binutils/
	* readelf.c (get_dynamic_type): Handle DT_GNU_HASH.
	(get_section_type_name): Handle SHT_GNU_HASH.
	(dynamic_info_DT_GNU_HASH): New variable.
	(process_dynamic_section): Handle DT_GNU_HASH.
	(process_symbol_table): Print also DT_GNU_HASH histogram.
ld/testsuite/
	* ld-powerpc/tlsso32.r: Adjust.
	* ld-powerpc/tlsso32.d: Adjust.
	* ld-powerpc/tlsso32.g: Adjust.
	* ld-powerpc/tlsso.r: Adjust.
	* ld-powerpc/tlsso.g: Adjust.
	* ld-powerpc/tlstocso.g: Adjust.
@
text
@d1028 35
a1062 1
	h = *sym_hash;
@


1.220
log
@	* elflink.c (elf_link_add_object_symbols): Don't create .tcommon
	section for relocatable link.

	* ld-elf/tls_common.exp: New test.
	* ld-elf/tls_common.s: New file.
@
text
@d243 24
a266 6
  s = bfd_make_section_with_flags (abfd, ".hash",
				   flags | SEC_READONLY);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  elf_section_data (s)->this_hdr.sh_entsize = bed->s->sizeof_hash_entry;
d4832 125
d4978 2
a4979 1
compute_bucket_count (struct bfd_link_info *info)
a4982 2
  unsigned long int *hashcodes;
  unsigned long int *hashcodesp;
a4985 14
  /* Compute the hash values for all exported symbols.  At the same
     time store the values in an array so that we could use them for
     optimizations.  */
  amt = dynsymcount;
  amt *= sizeof (unsigned long int);
  hashcodes = bfd_malloc (amt);
  if (hashcodes == NULL)
    return 0;
  hashcodesp = hashcodes;

  /* Put all hash values in HASHCODES.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_collect_hash_codes, &hashcodesp);

a4991 1
      unsigned long int nsyms = hashcodesp - hashcodes;
a4994 1
      unsigned long int *counts ;
d4997 1
d5006 7
d5020 1
a5020 4
	{
	  free (hashcodes);
	  return 0;
	}
d5032 3
d5050 3
a5052 3
	  /* We in any case need 2 + NSYMS entries for the size values and
	     the chains.  */
	  max = (2 + nsyms) * (bed->s->arch_size / 8);
d5062 1
a5062 1
	  fact = i / (BFD_TARGET_PAGESIZE / (bed->s->arch_size / 8)) + 1;
d5073 1
a5073 1
	  fact = i / (BFD_TARGET_PAGESIZE / (bed->s->arch_size / 8)) + 1;
d5096 1
a5096 1
	  if (dynsymcount < elf_buckets[i + 1])
d5099 2
a5102 3
  /* Free the arrays we needed.  */
  free (hashcodes);

d5460 4
a5463 1
	  if (!_bfd_elf_add_dynamic_entry (info, DT_HASH, 0)
a5864 2
      size_t bucketcount = 0;
      size_t hash_entry_size;
d5915 2
d5919 17
a5935 1
      bucketcount = compute_bucket_count (info);
d5937 174
a6110 7
      s = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (s != NULL);
      hash_entry_size = elf_section_data (s)->this_hdr.sh_entsize;
      s->size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
      s->contents = bfd_zalloc (output_bfd, s->size);
      if (s->contents == NULL)
	return FALSE;
d6112 7
a6118 3
      bfd_put (8 * hash_entry_size, output_bfd, bucketcount, s->contents);
      bfd_put (8 * hash_entry_size, output_bfd, dynsymcount,
	       s->contents + hash_entry_size);
d6120 4
a6123 1
      elf_hash_table (info)->bucketcount = bucketcount;
a6991 3
      size_t hash_entry_size;
      bfd_byte *bucketpos;
      bfd_vma chain;
d7005 17
a7021 9
      hash_entry_size
	= elf_section_data (finfo->hash_sec)->this_hdr.sh_entsize;
      bucketpos = ((bfd_byte *) finfo->hash_sec->contents
		   + (bucket + 2) * hash_entry_size);
      chain = bfd_get (8 * hash_entry_size, finfo->output_bfd, bucketpos);
      bfd_put (8 * hash_entry_size, finfo->output_bfd, h->dynindx, bucketpos);
      bfd_put (8 * hash_entry_size, finfo->output_bfd, chain,
	       ((bfd_byte *) finfo->hash_sec->contents
		+ (bucketcount + 2 + h->dynindx) * hash_entry_size));
d8195 1
a8195 1
      BFD_ASSERT (finfo.dynsym_sec != NULL && finfo.hash_sec != NULL);
d8955 3
@


1.219
log
@	* elflink.c (elf_link_add_object_symbols): Save and restore
	struct bfd_hash_table table, size and count fields for
	as-needed libs.
@
text
@d3624 2
a3625 1
	  && ELF_ST_TYPE (isym->st_info) == STT_TLS)
@


1.218
log
@PR binutils/2735
* elflink.c (elf_link_add_object_symbols): Fix the warning message about
  mismatched alignments to allow for the case where the common alignment
  has been deduced from the section alignment.
* bfd.c (_bfd_default_error_handler): Update comment to explain why bfd
  and asection varargs are out of order.
  Explicitly catch and abort on NULL bfd and asection arguments.
@
text
@d3083 3
d3510 3
d4160 3
@


1.217
log
@bfd/
	PR ld/2723
	* elflink.c (bfd_elf_final_link): Don't output section symbols
	for special ELF sections.
ld/testsuite/
Update for removal of some section syms.
@
text
@d3925 15
a3939 5
		(*_bfd_error_handler)
		  (_("Warning: alignment %u of symbol `%s' in %B"
		     " is smaller than %u in %B"),
		   normal_bfd, common_bfd,
		   1 << normal_align, name, 1 << common_align);
@


1.216
log
@2006-05-24  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf-bfd.h (elf_backend_data): Add elf_backend_output_arch_local_syms
	* elf32-arm.c (output_arch_syminfo): Define.
	(elf32_arm_ouput_plt_map_sym, elf32_arm_output_plt_map,
	elf32_arm_output_arch_local_syms): New functions.
	(elf_backend_output_arch_local_syms): Define.
	* elflink.c (bfd_elf_final_link): Call
	elf_backend_output_arch_local_syms.
	* elfxx-target.h (elf_backend_output_arch_local_syms): Provide default
	definition.
	(elfNN_bed): Add elf_backend_output_arch_local_syms.
ld/testsuite/
	* ld-arm/arm-app-abs32.d: Update expected output.
	* ld-arm/arm-app.d: Ditto.
	* ld-arm/arm-lib-plt32.d: Ditto.
	* ld-arm/arm-lib.d: Ditto.
	* ld-arm/mixed-app-v5.d: Ditto.
	* ld-arm/mixed-app.d: Ditto.
	* ld-arm/mixed-lib.d: Ditto.
@
text
@d8128 1
d8133 8
a8140 8
	    o->target_index = bfd_get_symcount (abfd);
	  elfsym.st_shndx = i;
	  if (info->relocatable || o == NULL)
	    elfsym.st_value = 0;
	  else
	    elfsym.st_value = o->vma;
	  if (! elf_link_output_sym (&finfo, NULL, &elfsym, o, NULL))
	    goto error_return;
@


1.215
log
@bfd/
	* elflink.c (_bfd_elf_add_dynamic_entry): Remove DT_TEXTREL
	check.
	(bfd_elf_final_link): Add a late DT_TEXTREL check.
	* elfxx-mips.c (MIPS_ELF_READONLY_SECTION): Define.
	(mips_elf_create_dynamic_relocation): Set DF_TEXTREL.
	(_bfd_mips_elf_check_relocs): Delete MIPS_READONLY_SECTION.
	Use MIPS_ELF_READONLY_SECTION.
	(_bfd_mips_elf_size_dynamic_sections): Clear DF_TEXTREL after
	creating DT_TEXTREL.
	(_bfd_mips_elf_finish_dynamic_sections): Clear textrel markers
	if no text relocations were generated.
ld/testsuite/
	* ld-mips-elf/textrel-1.d: Relax some patterns.
@
text
@d8299 13
@


1.214
log
@	* elflink.c (elf_gc_sweep): Don't specially keep non-alloc,
	non-load sections if they have relocs.
@
text
@a2812 4
  if (info->warn_shared_textrel && info->shared && tag == DT_TEXTREL)
    _bfd_error_handler
      (_("warning: creating a DT_TEXTREL in a shared object."));

d8654 26
@


1.213
log
@2006-05-11  Michael Matz  <matz@@suse.de>

	* elflink.c (match_group_member): Correctly iterate group
	members.
@
text
@d8968 1
a8968 1
	      || (o->flags & (SEC_ALLOC | SEC_LOAD)) == 0)
@


1.212
log
@	PR 2342
	* elflink.c (_bfd_elf_default_action_discarded): Revert 2006-02-16.
@
text
@d6785 1
@


1.211
log
@	* dwarf2.c: Formatting.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Simplify
	output section check.
	* elf32-i370.c: Warning fixes inside #ifdef DEBUG.
	* elf32-m32c.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-v850.c: Similarly.
	* nlm32-sparc.c: Similarly.
	* elfcode.h: Similarly.
	(elf_symbol_flags): Delete.
	* elflink.c (elf_link_input_bfd): Comment typo.
@
text
@d6761 1
a6761 1
    return 0;
@


1.210
log
@2006-04-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2411
	* elflink.c (check_dynsym): New.
	(elf_link_output_extsym): Use it.
	(bfd_elf_final_link): Likewise.
@
text
@d7253 1
a7253 1
			 elf_bfd_discard_info rely on reloc offsets
@


1.210.2.1
log
@	PR 2342
	* elflink.c (_bfd_elf_default_action_discarded): Revert 2006-02-16.
@
text
@d6761 1
a6761 1
    return PRETEND;
@


1.210.2.2
log
@2006-05-11  Michael Matz  <matz@@suse.de>

	* elflink.c (match_group_member): Correctly iterate group
	members.
@
text
@a6784 1
      s = elf_next_in_group (s);
@


1.210.2.3
log
@	* elflink.c (elf_gc_sweep): Don't specially keep non-alloc,
	non-load sections if they have relocs.
@
text
@d8968 1
a8968 1
	      || (o->flags & (SEC_ALLOC | SEC_LOAD | SEC_RELOC)) == 0)
@


1.210.2.4
log
@bfd/
	* elflink.c (_bfd_elf_add_dynamic_entry): Remove DT_TEXTREL
	check.
	(bfd_elf_final_link): Add a late DT_TEXTREL check.
	* elfxx-mips.c (MIPS_ELF_READONLY_SECTION): Define.
	(mips_elf_create_dynamic_relocation): Set DF_TEXTREL.
	(_bfd_mips_elf_check_relocs): Delete MIPS_READONLY_SECTION.
	Use MIPS_ELF_READONLY_SECTION.
	(_bfd_mips_elf_size_dynamic_sections): Clear DF_TEXTREL after
	creating DT_TEXTREL.
	(_bfd_mips_elf_finish_dynamic_sections): Clear textrel markers
	if no text relocations were generated.
ld/testsuite/
	* ld-mips-elf/textrel-1.d: Relax some patterns.
@
text
@d2813 4
a8657 26
      /* Check for DT_TEXTREL (late, in case the backend removes it).  */
      if (info->warn_shared_textrel && info->shared)
	{
	  bfd_byte *dyncon, *dynconend;

	  /* Fix up .dynamic entries.  */
	  o = bfd_get_section_by_name (dynobj, ".dynamic");
	  BFD_ASSERT (o != NULL);

	  dyncon = o->contents;
	  dynconend = o->contents + o->size;
	  for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)
	    {
	      Elf_Internal_Dyn dyn;

	      bed->s->swap_dyn_in (dynobj, dyncon, &dyn);

	      if (dyn.d_tag == DT_TEXTREL)
		{
		  _bfd_error_handler
		    (_("warning: creating a DT_TEXTREL in a shared object."));
		  break;
		}
	    }
	}

@


1.210.2.5
log
@bfd/
	* bfd-in.h (enum notice_asneeded_action): Define.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_add_object_symbols): Call linker "notice"
	function with NULL name for as-needed handling.
ld/
	* ld.h (handle_asneeded_cref): Declare.
	* ldcref.c: Include objalloc.h.
	(old_table, old_tab, alloc_mark): New variables.
	(tabsize, entsize, refsize, old_symcount): Likewise.
	(add_cref): Use bfd_hash_allocate for refs.
	(handle_asneeded_cref): New function.
	* ldmain.c (notice): Call handle_asneeded_cref for NULL name.
@
text
@a3498 7
      /* Make a special call to the linker "notice" function to
	 tell it that we are about to handle an as-needed lib.  */
      if (!(*info->callbacks->notice) (info, NULL, abfd, NULL,
				       notice_as_needed))
	return FALSE;


a4171 6
      /* Make a special call to the linker "notice" function to
	 tell it that symbols added for crefs may need to be removed.  */
      if (!(*info->callbacks->notice) (info, NULL, abfd, NULL,
				       notice_not_needed))
	return FALSE;

a4181 3
      if (!(*info->callbacks->notice) (info, NULL, abfd, NULL,
				       notice_needed))
	return FALSE;
@


1.210.2.6
log
@	* elflink.c (bfd_elf_gc_sections): Also search for corresponding
	sections with .gnu.linkonce.t. prefix.
@
text
@d9258 1
a9258 2
      /* Keep .gcc_except_table.* if the associated .text.* (or the
	 associated .gnu.linkonce.t.* if .text.* doesn't exist) is
d9274 1
a9274 1
		fn_name = bfd_malloc (len + 16);
a9276 2

		/* Try the first prefix.  */
a9279 9

		/* Try the second prefix.  */
		if (fn_text == NULL)
		  {
		    memcpy (fn_name, ".gnu.linkonce.t.", 16);
		    memcpy (fn_name + 16, o->name + 18, len);
		    fn_text = bfd_get_section_by_name (sub, fn_name);
		  }

@


1.209
log
@2006-04-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2404
	* elflink.c (_bfd_elf_merge_symbol): Skip the default indirect
	symbol from the dynamic definition with the default version if
	its type and the type of existing regular definition mismatch.
@
text
@d6207 18
d6657 5
d8339 2
d8375 2
@


1.208
log
@	PR ld/2267
	* elflink.c (elf_fixup_link_order): Ensure `elfsec' is not a
	special section number that exceeds the number of ELF sections
	(eg. SHN_MIPS_SCOMMON).
@
text
@d892 20
@


1.207
log
@2006-03-17  Daniel Jacobowitz  <dan@@codesourcery.com>

	PR ld/2462
	* elflink.c (bfd_elf_final_link): Remove
	bed->elf_backend_emit_relocs from emit_relocs.
@
text
@d7668 1
a7668 1
  int elfsec;
d7685 2
a7686 1
	      && (elfsec = _bfd_elf_section_from_bfd_section (sub, s)) != -1
@


1.207.2.1
log
@2006-05-24  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	* bfd/elf-bfd.h (elf_backend_data): Add
	elf_backend_output_arch_local_syms
	* bfd/elf32-arm.c (output_arch_syminfo): Define.
	(elf32_arm_ouput_plt_map_sym, elf32_arm_output_plt_map,
	elf32_arm_output_arch_local_syms): New functions.
	(elf_backend_output_arch_local_syms): Define.
	* bfd/elflink.c (bfd_elf_final_link): Call
	elf_backend_output_arch_local_syms.
	* bfd/elfxx-target.h (elf_backend_output_arch_local_syms): Provide
	default definition.
	(elfNN_bed): Add elf_backend_output_arch_local_syms.
	* ld/testsuite/ld-arm/arm-app-abs32.d: Update expected output.
	* ld/testsuite/ld-arm/arm-app.d: Ditto.
	* ld/testsuite/ld-arm/arm-lib-plt32.d: Ditto.
	* ld/testsuite/ld-arm/arm-lib.d: Ditto.
	* ld/testsuite/ld-arm/mixed-app-v5.d: Ditto.
	* ld/testsuite/ld-arm/mixed-app.d: Ditto.
	* ld/testsuite/ld-arm/mixed-lib.d: Ditto.
@
text
@a8257 13
  /* If backend needs to output some local symbols not present in the hash
     table, do it now.  */
  if (bed->elf_backend_output_arch_local_syms)
    {
      typedef bfd_boolean (*out_sym_func)
	(void *, const char *, Elf_Internal_Sym *, asection *,
	 struct elf_link_hash_entry *);

      if (! ((*bed->elf_backend_output_arch_local_syms)
	     (abfd, info, &finfo, (out_sym_func) elf_link_output_sym)))
	return FALSE;
    }

@


1.207.2.2
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a891 20
  /* When we try to create a default indirect symbol from the dynamic
     definition with the default version, we skip it if its type and
     the type of existing regular definition mismatch.  We only do it
     if the existing regular definition won't be dynamic.  */
  if (pold_alignment == NULL
      && !info->shared
      && !info->export_dynamic
      && !h->ref_dynamic
      && newdyn
      && newdef
      && !olddyn
      && (olddef || h->root.type == bfd_link_hash_common)
      && ELF_ST_TYPE (sym->st_info) != h->type
      && ELF_ST_TYPE (sym->st_info) != STT_NOTYPE
      && h->type != STT_NOTYPE)
    {
      *skip = TRUE;
      return TRUE;
    }

d2793 4
a6186 18
/* Return TRUE if the dynamic symbol SYM in ABFD is supported.  */

static bfd_boolean
check_dynsym (bfd *abfd, Elf_Internal_Sym *sym)
{
  if (sym->st_shndx > SHN_HIRESERVE)
    {
      /* The gABI doesn't support dynamic symbols in output sections
         beyond 64k.  */
      (*_bfd_error_handler)
	(_("%B: Too many sections: %d (>= %d)"),
	 abfd, bfd_count_sections (abfd), SHN_LORESERVE);
      bfd_set_error (bfd_error_nonrepresentable_section);
      return FALSE;
    }
  return TRUE;
}

a6618 5
      if (! check_dynsym (finfo->output_bfd, &sym))
	{
	  eoinfo->failed = TRUE;
	  return FALSE;
	}
d6718 1
a6718 1
    return PRETEND;
a6741 1
      s = elf_next_in_group (s);
d7668 1
a7668 1
  unsigned elfsec;
d7685 1
a7685 2
	      && (elfsec = _bfd_elf_section_from_bfd_section (sub, s))
	      && elfsec < elf_numsections (sub)
a8307 2
	      if (! check_dynsym (abfd, &sym))
		return FALSE;
a8341 2
		  if (! check_dynsym (abfd, &sym))
		    return FALSE;
a8621 26
      /* Check for DT_TEXTREL (late, in case the backend removes it).  */
      if (info->warn_shared_textrel && info->shared)
	{
	  bfd_byte *dyncon, *dynconend;

	  /* Fix up .dynamic entries.  */
	  o = bfd_get_section_by_name (dynobj, ".dynamic");
	  BFD_ASSERT (o != NULL);

	  dyncon = o->contents;
	  dynconend = o->contents + o->size;
	  for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)
	    {
	      Elf_Internal_Dyn dyn;

	      bed->s->swap_dyn_in (dynobj, dyncon, &dyn);

	      if (dyn.d_tag == DT_TEXTREL)
		{
		  _bfd_error_handler
		    (_("warning: creating a DT_TEXTREL in a shared object."));
		  break;
		}
	    }
	}

d8932 1
a8932 1
	      || (o->flags & (SEC_ALLOC | SEC_LOAD | SEC_RELOC)) == 0)
@


1.207.2.3
log
@        Backport from mainline:

        2006-07-29  Richard Sandiford  <richard@@codesourcery.com>

        ld/
        * Makefile.am (eelf32b4300.c): Update dependencies.
        (eelf32bmip.c): Likewise.
        (eelf32bsmip.c): Likewise.
        (eelf32btsmip.c): Likewise.
        (eelf32btsmipn32.c): Likewise.
        (eelf32ltsmip.c): Likewise.
        (eelf32ltsmipn32.c): Likewise.
        (eelf32ebmip.c): Likewise.
        (eelf32ebmipvxworks.c): Likewise.
        (eelf32elmip.c): Likewise.
        (eelf32elmipvxworks.c): Likewise.
        (eelf32bmipn32.c): Likewise.
        (eelf32lmip.c): Likewise.
        (eelf32mipswindiss.c): Likewise.
        (eelf32lsmip.c): Likewise.
        (eelf64bmip.c): Likewise.
        (eelf64btsmip.c): Likewise.
        (eelf64ltsmip.c): Likewise.
        (emipsbig.c): Likewise.  Canonicalize ${GENSCRIPTS} line.
        (emipsbsd.c): Likewise.
        (emipsidt.c): Update dependencies.
        (emipsidtl.c): Likewise.
        (emipslit.c): Likewise.
        (emipslnews.c): Likewise.
        (emipspe.c): Likewise.  Fix ${GENSCRIPTS} invocation.
        * Makefile.in: Regenerate.
        * emulparams/elf32bmip.sh (EXTRA_EM_FILE): Define.
        * emulparams/elf32bmipn32-defs.sh (EXTRA_EM_FILE): Likewise.
        * emultempl/irix.em: Include emultempl/mipself.em.
        * emultempl/mipself.em: New file.

        ld/testsuite/
        * ld-mips-elf/hash1.s, ld-mips-elf/hash1a.d,
        * ld-mips-elf/hash1b.d, ld-mips-elf/hash1c.d: New tests.
        * ld-mips-elf/mips-elf.exp: Run them.

        2006-07-14  Jakub Jelinek  <jakub@@redhat.com>

        * elflink.c (bfd_elf_size_dynsym_hash_dynstr): Fix cinfo.shift2 value.

        2006-07-10  Jakub Jelinek  <jakub@@redhat.com>

        include/
        * bfdlink.h (struct bfd_link_info): Add emit_hash and
        emit_gnu_hash bitfields.

        include/elf/
        * common.h (SHT_GNU_HASH, DT_GNU_HASH): Define.

        ld/
        * scripttempl/elf.sc: Add .gnu.hash section.
        * emultempl/elf32.em (OPTION_HASH_STYLE): Define.
        (gld${EMULATION_NAME}_add_options): Register --hash-style option.
        (gld${EMULATION_NAME}_handle_option): Handle it.
        (gld${EMULATION_NAME}_list_options): Document it.
        * ldmain.c (main): Initialize emit_hash and emit_gnu_hash.
        * ld.texinfo: Document --hash-style option.

        ld/testsuite/
        * ld-powerpc/tlsso32.r: Adjust.
        * ld-powerpc/tlsso32.d: Adjust.
        * ld-powerpc/tlsso32.g: Adjust.
        * ld-powerpc/tlsso.r: Adjust.
        * ld-powerpc/tlsso.g: Adjust.
        * ld-powerpc/tlstocso.g: Adjust.

        bfd/
        * elf.c (_bfd_elf_print_private_bfd_data): Handle DT_GNU_HASH.
        (bfd_section_from_shdr, elf_fake_sections, assign_section_numbers):
        Handle SHT_GNU_HASH.
        (special_sections_g): Include .gnu.hash section.
        (bfd_elf_gnu_hash): New function.
        * elf-bfd.h (bfd_elf_gnu_hash, _bfd_elf_hash_symbol): New prototypes.
        (struct elf_backend_data): Add elf_hash_symbol method.
        * elflink.c (_bfd_elf_link_create_dynamic_sections): Create .hash
        only if info->emit_hash, create .gnu.hash section if
        info->emit_gnu_hash.
        (struct collect_gnu_hash_codes): New type.
        (elf_collect_gnu_hash_codes, elf_renumber_gnu_hash_syms,
        _bfd_elf_hash_symbol): New functions.
        (compute_bucket_count): Don't compute HASHCODES array, instead add
        that and NSYMS as arguments.  Use bed->s->sizeof_hash_entry
        instead of bed->s->arch_size / 8.  Fix .hash size estimation.
        When not optimizing, use the number of hashed symbols rather than
        dynsymcount.
        (bfd_elf_size_dynamic_sections): Only add DT_HASH if info->emit_hash,
        and ADD DT_GNU_HASH if info->emit_gnu_hash.
        (bfd_elf_size_dynsym_hash_dynstr): Size .hash only if info->emit_hash,
        adjust compute_bucket_count caller.  Create and populate .gnu.hash
        section if info->emit_gnu_hash.
        (elf_link_output_extsym): Only populate .hash section if
        finfo->hash_sec != NULL.
        (bfd_elf_final_link): Adjust assertion.  Handle DT_GNU_HASH.
        * elfxx-target.h (elf_backend_hash_symbol): Define if not yet defined.
        (elfNN_bed): Add elf_backend_hash_symbol.
        * elf64-x86-64.c (elf64_x86_64_hash_symbol): New function.
        (elf_backend_hash_symbol): Define.
        * elf32-i386.c (elf_i386_hash_symbol): New function.
        (elf_backend_hash_symbol): Define.

        binutils/
        * readelf.c (get_dynamic_type): Handle DT_GNU_HASH.
        (get_section_type_name): Handle SHT_GNU_HASH.
        (dynamic_info_DT_GNU_HASH): New variable.
        (process_dynamic_section): Handle DT_GNU_HASH.
        (process_symbol_table): Print also DT_GNU_HASH histogram.
@
text
@d243 6
a248 24
  if (info->emit_hash)
    {
      s = bfd_make_section_with_flags (abfd, ".hash", flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
	return FALSE;
      elf_section_data (s)->this_hdr.sh_entsize = bed->s->sizeof_hash_entry;
    }

  if (info->emit_gnu_hash)
    {
      s = bfd_make_section_with_flags (abfd, ".gnu.hash",
				       flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
	return FALSE;
      /* For 64-bit ELF, .gnu.hash is a non-uniform entity size section:
	 4 32-bit words followed by variable count of 64-bit words, then
	 variable count of 32-bit words.  */
      if (bed->s->arch_size == 64)
	elf_section_data (s)->this_hdr.sh_entsize = 0;
      else
	elf_section_data (s)->this_hdr.sh_entsize = 4;
    }
a4793 125
struct collect_gnu_hash_codes
{
  bfd *output_bfd;
  const struct elf_backend_data *bed;
  unsigned long int nsyms;
  unsigned long int maskbits;
  unsigned long int *hashcodes;
  unsigned long int *hashval;
  unsigned long int *indx;
  unsigned long int *counts;
  bfd_vma *bitmask;
  bfd_byte *contents;
  long int min_dynindx;
  unsigned long int bucketcount;
  unsigned long int symindx;
  long int local_indx;
  long int shift1, shift2;
  unsigned long int mask;
};

/* This function will be called though elf_link_hash_traverse to store
   all hash value of the exported symbols in an array.  */

static bfd_boolean
elf_collect_gnu_hash_codes (struct elf_link_hash_entry *h, void *data)
{
  struct collect_gnu_hash_codes *s = data;
  const char *name;
  char *p;
  unsigned long ha;
  char *alc = NULL;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->dynindx == -1)
    return TRUE;

  /* Ignore also local symbols and undefined symbols.  */
  if (! (*s->bed->elf_hash_symbol) (h))
    return TRUE;

  name = h->root.root.string;
  p = strchr (name, ELF_VER_CHR);
  if (p != NULL)
    {
      alc = bfd_malloc (p - name + 1);
      memcpy (alc, name, p - name);
      alc[p - name] = '\0';
      name = alc;
    }

  /* Compute the hash value.  */
  ha = bfd_elf_gnu_hash (name);

  /* Store the found hash value in the array for compute_bucket_count,
     and also for .dynsym reordering purposes.  */
  s->hashcodes[s->nsyms] = ha;
  s->hashval[h->dynindx] = ha;
  ++s->nsyms;
  if (s->min_dynindx < 0 || s->min_dynindx > h->dynindx)
    s->min_dynindx = h->dynindx;

  if (alc != NULL)
    free (alc);

  return TRUE;
}

/* This function will be called though elf_link_hash_traverse to do
   final dynaminc symbol renumbering.  */

static bfd_boolean
elf_renumber_gnu_hash_syms (struct elf_link_hash_entry *h, void *data)
{
  struct collect_gnu_hash_codes *s = data;
  unsigned long int bucket;
  unsigned long int val;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Ignore indirect symbols.  */
  if (h->dynindx == -1)
    return TRUE;

  /* Ignore also local symbols and undefined symbols.  */
  if (! (*s->bed->elf_hash_symbol) (h))
    {
      if (h->dynindx >= s->min_dynindx)
	h->dynindx = s->local_indx++;
      return TRUE;
    }

  bucket = s->hashval[h->dynindx] % s->bucketcount;
  val = (s->hashval[h->dynindx] >> s->shift1)
	& ((s->maskbits >> s->shift1) - 1);
  s->bitmask[val] |= ((bfd_vma) 1) << (s->hashval[h->dynindx] & s->mask);
  s->bitmask[val]
    |= ((bfd_vma) 1) << ((s->hashval[h->dynindx] >> s->shift2) & s->mask);
  val = s->hashval[h->dynindx] & ~(unsigned long int) 1;
  if (s->counts[bucket] == 1)
    /* Last element terminates the chain.  */
    val |= 1;
  bfd_put_32 (s->output_bfd, val,
	      s->contents + (s->indx[bucket] - s->symindx) * 4);
  --s->counts[bucket];
  h->dynindx = s->indx[bucket]++;
  return TRUE;
}

/* Return TRUE if symbol should be hashed in the `.gnu.hash' section.  */

bfd_boolean
_bfd_elf_hash_symbol (struct elf_link_hash_entry *h)
{
  return !(h->forced_local
	   || h->root.type == bfd_link_hash_undefined
	   || h->root.type == bfd_link_hash_undefweak
	   || ((h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak)
	       && h->root.u.def.section->output_section == NULL));
}

d4815 1
a4815 2
compute_bucket_count (struct bfd_link_info *info, unsigned long int *hashcodes,
		      unsigned long int nsyms, int gnu_hash)
d4819 2
d4824 14
d4844 1
d4848 1
a4850 1
      unsigned long int *counts;
a4858 7
      if (gnu_hash)
	{
	  if (minsize < 2)
	    minsize = 2;
	  if ((best_size & 31) == 0)
	    ++best_size;
	}
d4866 4
a4869 1
	return 0;
a4880 3
	  if (gnu_hash && (i & 31) == 0)
	    continue;

d4896 3
a4898 3
	  /* We in any case need 2 + DYNSYMCOUNT entries for the size values
	     and the chains.  */
	  max = (2 + dynsymcount) * bed->s->sizeof_hash_entry;
d4908 1
a4908 1
	  fact = i / (BFD_TARGET_PAGESIZE / bed->s->sizeof_hash_entry) + 1;
d4919 1
a4919 1
	  fact = i / (BFD_TARGET_PAGESIZE / bed->s->sizeof_hash_entry) + 1;
d4942 1
a4942 1
	  if (nsyms < elf_buckets[i + 1])
a4944 2
      if (gnu_hash && best_size < 2)
	best_size = 2;
d4947 3
d5307 1
a5307 4
	  if ((info->emit_hash
	       && !_bfd_elf_add_dynamic_entry (info, DT_HASH, 0))
	      || (info->emit_gnu_hash
		  && !_bfd_elf_add_dynamic_entry (info, DT_GNU_HASH, 0))
d5709 2
a5760 2
      elf_hash_table (info)->bucketcount = 0;

d5763 1
a5763 17
      if (info->emit_hash)
	{
	  unsigned long int *hashcodes;
	  unsigned long int *hashcodesp;
	  bfd_size_type amt;
	  unsigned long int nsyms;
	  size_t bucketcount;
	  size_t hash_entry_size;

	  /* Compute the hash values for all exported symbols.  At the same
	     time store the values in an array so that we could use them for
	     optimizations.  */
	  amt = dynsymcount * sizeof (unsigned long int);
	  hashcodes = bfd_malloc (amt);
	  if (hashcodes == NULL)
	    return FALSE;
	  hashcodesp = hashcodes;
d5765 7
a5771 3
	  /* Put all hash values in HASHCODES.  */
	  elf_link_hash_traverse (elf_hash_table (info),
				  elf_collect_hash_codes, &hashcodesp);
d5773 3
a5775 4
	  nsyms = hashcodesp - hashcodes;
	  bucketcount
	    = compute_bucket_count (info, hashcodes, nsyms, 0);
	  free (hashcodes);
d5777 1
a5777 178
	  if (bucketcount == 0)
	    return FALSE;

	  elf_hash_table (info)->bucketcount = bucketcount;

	  s = bfd_get_section_by_name (dynobj, ".hash");
	  BFD_ASSERT (s != NULL);
	  hash_entry_size = elf_section_data (s)->this_hdr.sh_entsize;
	  s->size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
	  s->contents = bfd_zalloc (output_bfd, s->size);
	  if (s->contents == NULL)
	    return FALSE;

	  bfd_put (8 * hash_entry_size, output_bfd, bucketcount, s->contents);
	  bfd_put (8 * hash_entry_size, output_bfd, dynsymcount,
		   s->contents + hash_entry_size);
	}

      if (info->emit_gnu_hash)
	{
	  size_t i, cnt;
	  unsigned char *contents;
	  struct collect_gnu_hash_codes cinfo;
	  bfd_size_type amt;
	  size_t bucketcount;

	  memset (&cinfo, 0, sizeof (cinfo));

	  /* Compute the hash values for all exported symbols.  At the same
	     time store the values in an array so that we could use them for
	     optimizations.  */
	  amt = dynsymcount * 2 * sizeof (unsigned long int);
	  cinfo.hashcodes = bfd_malloc (amt);
	  if (cinfo.hashcodes == NULL)
	    return FALSE;

	  cinfo.hashval = cinfo.hashcodes + dynsymcount;
	  cinfo.min_dynindx = -1;
	  cinfo.output_bfd = output_bfd;
	  cinfo.bed = bed;

	  /* Put all hash values in HASHCODES.  */
	  elf_link_hash_traverse (elf_hash_table (info),
				  elf_collect_gnu_hash_codes, &cinfo);

	  bucketcount
	    = compute_bucket_count (info, cinfo.hashcodes, cinfo.nsyms, 1);

	  if (bucketcount == 0)
	    {
	      free (cinfo.hashcodes);
	      return FALSE;
	    }

	  s = bfd_get_section_by_name (dynobj, ".gnu.hash");
	  BFD_ASSERT (s != NULL);

	  if (cinfo.nsyms == 0)
	    {
	      /* Empty .gnu.hash section is special.  */
	      BFD_ASSERT (cinfo.min_dynindx == -1);
	      free (cinfo.hashcodes);
	      s->size = 5 * 4 + bed->s->arch_size / 8;
	      contents = bfd_zalloc (output_bfd, s->size);
	      if (contents == NULL)
		return FALSE;
	      s->contents = contents;
	      /* 1 empty bucket.  */
	      bfd_put_32 (output_bfd, 1, contents);
	      /* SYMIDX above the special symbol 0.  */
	      bfd_put_32 (output_bfd, 1, contents + 4);
	      /* Just one word for bitmask.  */
	      bfd_put_32 (output_bfd, 1, contents + 8);
	      /* Only hash fn bloom filter.  */
	      bfd_put_32 (output_bfd, 0, contents + 12);
	      /* No hashes are valid - empty bitmask.  */
	      bfd_put (bed->s->arch_size, output_bfd, 0, contents + 16);
	      /* No hashes in the only bucket.  */
	      bfd_put_32 (output_bfd, 0,
			  contents + 16 + bed->s->arch_size / 8);
	    }
	  else
	    {
	      BFD_ASSERT (cinfo.min_dynindx != -1);
	      unsigned long int maskwords, maskbitslog2;

	      maskbitslog2 = bfd_log2 (cinfo.nsyms) + 1;
	      if (maskbitslog2 < 3)
		maskbitslog2 = 5;
	      else if ((1 << (maskbitslog2 - 2)) & cinfo.nsyms)
		maskbitslog2 = maskbitslog2 + 3;
	      else
		maskbitslog2 = maskbitslog2 + 2;
	      if (bed->s->arch_size == 64)
		{
		  if (maskbitslog2 == 5)
		    maskbitslog2 = 6;
		  cinfo.shift1 = 6;
		}
	      else
		cinfo.shift1 = 5;
	      cinfo.mask = (1 << cinfo.shift1) - 1;
	      cinfo.shift2 = maskbitslog2;
	      cinfo.maskbits = 1 << maskbitslog2;
	      maskwords = 1 << (maskbitslog2 - cinfo.shift1);
	      amt = bucketcount * sizeof (unsigned long int) * 2;
	      amt += maskwords * sizeof (bfd_vma);
	      cinfo.bitmask = bfd_malloc (amt);
	      if (cinfo.bitmask == NULL)
		{
		  free (cinfo.hashcodes);
		  return FALSE;
		}

	      cinfo.counts = (void *) (cinfo.bitmask + maskwords);
	      cinfo.indx = cinfo.counts + bucketcount;
	      cinfo.symindx = dynsymcount - cinfo.nsyms;
	      memset (cinfo.bitmask, 0, maskwords * sizeof (bfd_vma));

	      /* Determine how often each hash bucket is used.  */
	      memset (cinfo.counts, 0, bucketcount * sizeof (cinfo.counts[0]));
	      for (i = 0; i < cinfo.nsyms; ++i)
		++cinfo.counts[cinfo.hashcodes[i] % bucketcount];

	      for (i = 0, cnt = cinfo.symindx; i < bucketcount; ++i)
		if (cinfo.counts[i] != 0)
		  {
		    cinfo.indx[i] = cnt;
		    cnt += cinfo.counts[i];
		  }
	      BFD_ASSERT (cnt == dynsymcount);
	      cinfo.bucketcount = bucketcount;
	      cinfo.local_indx = cinfo.min_dynindx;

	      s->size = (4 + bucketcount + cinfo.nsyms) * 4;
	      s->size += cinfo.maskbits / 8;
	      contents = bfd_zalloc (output_bfd, s->size);
	      if (contents == NULL)
		{
		  free (cinfo.bitmask);
		  free (cinfo.hashcodes);
		  return FALSE;
		}

	      s->contents = contents;
	      bfd_put_32 (output_bfd, bucketcount, contents);
	      bfd_put_32 (output_bfd, cinfo.symindx, contents + 4);
	      bfd_put_32 (output_bfd, maskwords, contents + 8);
	      bfd_put_32 (output_bfd, cinfo.shift2, contents + 12);
	      contents += 16 + cinfo.maskbits / 8;

	      for (i = 0; i < bucketcount; ++i)
		{
		  if (cinfo.counts[i] == 0)
		    bfd_put_32 (output_bfd, 0, contents);
		  else
		    bfd_put_32 (output_bfd, cinfo.indx[i], contents);
		  contents += 4;
		}

	      cinfo.contents = contents;

	      /* Renumber dynamic symbols, populate .gnu.hash section.  */
	      elf_link_hash_traverse (elf_hash_table (info),
				      elf_renumber_gnu_hash_syms, &cinfo);

	      contents = s->contents + 16;
	      for (i = 0; i < maskwords; ++i)
		{
		  bfd_put (bed->s->arch_size, output_bfd, cinfo.bitmask[i],
			   contents);
		  contents += bed->s->arch_size / 8;
		}

	      free (cinfo.bitmask);
	      free (cinfo.hashcodes);
	    }
	}
d6646 3
d6662 9
a6670 17

      if (finfo->hash_sec != NULL)
	{
	  size_t hash_entry_size;
	  bfd_byte *bucketpos;
	  bfd_vma chain;

	  hash_entry_size
	    = elf_section_data (finfo->hash_sec)->this_hdr.sh_entsize;
	  bucketpos = ((bfd_byte *) finfo->hash_sec->contents
		       + (bucket + 2) * hash_entry_size);
	  chain = bfd_get (8 * hash_entry_size, finfo->output_bfd, bucketpos);
	  bfd_put (8 * hash_entry_size, finfo->output_bfd, h->dynindx, bucketpos);
	  bfd_put (8 * hash_entry_size, finfo->output_bfd, chain,
		   ((bfd_byte *) finfo->hash_sec->contents
		    + (bucketcount + 2 + h->dynindx) * hash_entry_size));
	}
d7844 1
a7844 1
      BFD_ASSERT (finfo.dynsym_sec != NULL);
a8602 3
	    case DT_GNU_HASH:
	      name = ".gnu.hash";
	      goto get_vma;
@


1.206
log
@	PR 2434
	* elflink.c (elf_link_add_object_symbols): Save and restore
	warning sym's linked sym.
@
text
@d7785 1
a7785 2
		 || info->emitrelocations
		 || bed->elf_backend_emit_relocs);
@


1.205
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d3460 1
d3463 6
a3468 1
	    entsize += htab->root.table.entsize;
d3496 1
d3502 6
d4140 2
d4144 1
d4147 6
d4163 1
a4163 1
 
d9174 1
a9174 1
	 splitting .eh_frame up and using comdat doesn't pan out 
@


1.204
log
@bfd/
	* elf-bfd.h (elf_link_hash_table): Add hplt field.
	* elflink.c (_bfd_elf_create_dynamic_sections): Initialize it.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Likewise.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_create_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_create_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_create_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table): Remove hgot and hplt.
	(elf_i386_link_hash_table_create): Don't initialize them.
	(elf_i386_size_dynamic_sections): Use the generic ELF hplt and
	hgot fields.
	(elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_link_hash_table): Remove hplt.
	(ppc_elf_size_dynamic_sections): Use the generic ELF hplt fields.
	(ppc_elf_finish_dynamic_symbol): Likewise.
@
text
@d29 1
a2878 92
/* Called via elf_link_hash_traverse, elf_smash_syms sets all symbols
   belonging to NOT_NEEDED to bfd_link_hash_new.  We know there are no
   references from regular objects to these symbols.

   ??? Should we do something about references from other dynamic
   obects?  If not, we potentially lose some warnings about undefined
   symbols.  But how can we recover the initial undefined / undefweak
   state?  */

struct elf_smash_syms_data
{
  bfd *not_needed;
  struct elf_link_hash_table *htab;
  bfd_boolean twiddled;
};

static bfd_boolean
elf_smash_syms (struct elf_link_hash_entry *h, void *data)
{
  struct elf_smash_syms_data *inf = (struct elf_smash_syms_data *) data;
  struct bfd_link_hash_entry *bh;

  switch (h->root.type)
    {
    default:
    case bfd_link_hash_new:
      return TRUE;

    case bfd_link_hash_undefined:
      if (h->root.u.undef.abfd != inf->not_needed)
	return TRUE;
      if (h->root.u.undef.weak != NULL
	  && h->root.u.undef.weak != inf->not_needed)
	{
	  /* Symbol was undefweak in u.undef.weak bfd, and has become
	     undefined in as-needed lib.  Restore weak.  */
	  h->root.type = bfd_link_hash_undefweak;
	  h->root.u.undef.abfd = h->root.u.undef.weak;
	  if (h->root.u.undef.next != NULL
	      || inf->htab->root.undefs_tail == &h->root)
	    inf->twiddled = TRUE;
	  return TRUE;
	}
      break;

    case bfd_link_hash_undefweak:
      if (h->root.u.undef.abfd != inf->not_needed)
	return TRUE;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      if (h->root.u.def.section->owner != inf->not_needed)
	return TRUE;
      break;

    case bfd_link_hash_common:
      if (h->root.u.c.p->section->owner != inf->not_needed)
	return TRUE;
      break;

    case bfd_link_hash_warning:
    case bfd_link_hash_indirect:
      elf_smash_syms ((struct elf_link_hash_entry *) h->root.u.i.link, data);
      if (h->root.u.i.link->type != bfd_link_hash_new)
	return TRUE;
      if (h->root.u.i.link->u.undef.abfd != inf->not_needed)
	return TRUE;
      break;
    }

  /* There is no way we can undo symbol table state from defined or
     defweak back to undefined.  */
  if (h->ref_regular)
    abort ();

  /* Set sym back to newly created state, but keep undef.next if it is
     being used as a list pointer.  */
  bh = h->root.u.undef.next;
  if (bh == &h->root)
    bh = NULL;
  if (bh != NULL || inf->htab->root.undefs_tail == &h->root)
    inf->twiddled = TRUE;
  (*inf->htab->root.table.newfunc) (&h->root.root,
				    &inf->htab->root.table,
				    h->root.root.string);
  h->root.u.undef.next = bh;
  h->root.u.undef.abfd = inf->not_needed;
  h->non_elf = 0;
  return TRUE;
}

a3047 8
  bfd_boolean (*add_symbol_hook)
    (bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
     const char **, flagword *, asection **, bfd_vma *);
  bfd_boolean (*check_relocs)
    (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
  bfd_boolean (*check_directives)
    (bfd *, struct bfd_link_info *);
  bfd_boolean collect;
d3064 1
a3064 1
  struct elf_link_hash_table * hash_table;
d3066 9
d3076 1
a3076 2
  hash_table = elf_hash_table (info);

a3077 2
  add_symbol_hook = bed->elf_add_symbol_hook;
  collect = bed->collect;
d3089 2
a3090 2
	  || !is_elf_hash_table (hash_table)
	  || hash_table->root.creator != abfd->xvec)
d3133 1
a3133 2
		  h = elf_link_hash_lookup (hash_table, name,
					    FALSE, FALSE, TRUE);
d3160 1
a3160 1
		      FALSE, collect, NULL)))
d3186 3
a3188 3
	  && is_elf_hash_table (hash_table)
	  && hash_table->root.creator == abfd->xvec
	  && ! hash_table->dynamic_sections_created)
d3194 1
a3194 1
  else if (!is_elf_hash_table (hash_table))
d3269 1
a3269 3
		  for (pn = & hash_table->needed;
		       *pn != NULL;
		       pn = &(*pn)->next)
d3341 1
a3341 3
	  for (pn = & hash_table->runpath;
	       *pn != NULL;
	       pn = &(*pn)->next)
d3449 50
a3499 1

d3551 2
a3552 1
      else if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
d3563 2
a3564 2
	      isym->st_other = STV_DEFAULT
			       | (isym->st_other & ~ ELF_ST_VISIBILITY(-1));
d3605 1
a3605 1
      else if (add_symbol_hook)
d3607 2
a3608 2
	  if (! (*add_symbol_hook) (abfd, info, isym, &name, &flags, &sec,
				    &value))
d3631 1
a3631 1
      type_change_ok = get_elf_backend_data (abfd)->type_change_ok;
d3636 1
a3636 1
      if (is_elf_hash_table (hash_table))
d3731 1
a3731 1
	      newname = bfd_alloc (abfd, newlen);
d3795 1
a3795 1
	     (info, abfd, name, flags, sec, value, NULL, FALSE, collect,
d3810 1
a3810 1
	  && is_elf_hash_table (hash_table)
d3853 1
a3853 1
      if (is_elf_hash_table (hash_table))
d3953 2
a3954 1
	    isym->st_other = STV_HIDDEN | (isym->st_other & ~ ELF_ST_VISIBILITY (-1));
d4027 1
a4027 1
		  if (! nondeflt_vers)
d4029 2
a4030 2
		      amt = (isymend - isym + 1)
			    * sizeof (struct elf_link_hash_entry *);
d4033 1
a4033 1
		  nondeflt_vers [nondeflt_vers_cnt++] = h;
d4045 1
a4045 1
		  if (! bfd_elf_link_record_dynamic_symbol (info, h->u.weakdef))
d4095 53
d4171 1
a4171 1
	       bfd_link_hash_lookup (&hash_table->root, shortname,
a4196 25
  if (extversym != NULL)
    {
      free (extversym);
      extversym = NULL;
    }

  if (isymbuf != NULL)
    free (isymbuf);
  isymbuf = NULL;

  if (!add_needed
      && (elf_dyn_lib_class (abfd) & DYN_AS_NEEDED) != 0)
    {
      /* Remove symbols defined in an as-needed shared lib that wasn't
	 needed.  */
      struct elf_smash_syms_data inf;
      inf.not_needed = abfd;
      inf.htab = hash_table;
      inf.twiddled = FALSE;
      elf_link_hash_traverse (hash_table, elf_smash_syms, &inf);
      if (inf.twiddled)
	bfd_link_repair_undef_list (&hash_table->root);
      weaks = NULL;
    }

d4336 2
a4337 3
  check_directives = get_elf_backend_data (abfd)->check_directives;
  if (check_directives)
    check_directives (abfd, info);
a4355 1
  check_relocs = get_elf_backend_data (abfd)->check_relocs;
d4357 3
a4359 3
      && is_elf_hash_table (hash_table)
      && hash_table->root.creator == abfd->xvec
      && check_relocs != NULL)
d4380 1
a4380 1
	  ok = (*check_relocs) (abfd, info, o, internal_relocs);
d4394 1
a4394 1
      && is_elf_hash_table (hash_table)
d4415 2
a4416 4
		if (! _bfd_link_section_stabs (abfd,
					       &hash_table->stab_info,
					       stab, stabstr,
					       &secdata->sec_info,
d4425 1
a4425 1
  if (is_elf_hash_table (hash_table) && add_needed)
d4434 2
a4435 2
      n->next = hash_table->loaded;
      hash_table->loaded = n;
d4441 2
@


1.203
log
@2006-02-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2218
	* elf-bfd.h (elf_backend_data): Add elf_backend_fixup_symbol.
	(_bfd_elf_link_hash_fixup_symbol): New.

	* elflink.c (_bfd_elf_link_hash_fixup_symbol): New.
	(_bfd_elf_fix_symbol_flags): Call elf_backend_fixup_symbol if
	it isn't NULL.

	* elfxx-ia64.c (elf_backend_fixup_symbol): Defined.

	* elfxx-target.h (elf_backend_fixup_symbol): New.
	(elfNN_bed): Initialize elf_backend_fixup_symbol.
@
text
@d266 1
d292 8
a299 4
  if (bed->want_plt_sym
      && !_bfd_elf_define_linkage_sym (abfd, info, s,
				       "_PROCEDURE_LINKAGE_TABLE_"))
    return FALSE;
@


1.202
log
@	* elflink.c (_bfd_elf_default_action_discarded): Return 0 for
	debug sections.
	(elf_link_input_bfd): Adjust comments.
@
text
@d2190 14
d2214 2
d2274 9
a2307 1
      const struct elf_backend_data *bed;
a2309 2
      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);

d2348 2
a2349 6
	{
	  const struct elf_backend_data *bed;

	  bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
	  (*bed->elf_backend_copy_indirect_symbol) (eif->info, weakdef, h);
	}
@


1.201
log
@	* elf-bfd.h (struct elf_backend_data): Add gc_mark_dynamic_ref.
	(bfd_elf_gc_mark_dynamic_ref_symbol): Declare.
	* elflink.c (bfd_elf_gc_mark_dynamic_ref_symbol): Rename from
	elf_gc_mark_dynamic_ref_symbol.  Make global.
	(bfd_elf_gc_sections): Call bed->gc_mark_dynamic_ref.
	* elfxx-target.h (elf_backend_gc_mark_dynamic_ref): Define.
	(elfNN_bed): Init new field.
	* elf64-ppc.c (elf_backend_gc_mark_dynamic_ref): Define.
	(ppc64_elf_gc_mark_dynamic_ref): New function.
@
text
@d6694 1
a6694 1
    return PRETEND;
d7010 1
a7010 2
	     link-once sections.  Preserve debug information as much
	     as we can.  */
d7082 1
a7082 2
			 versions of gcc.  If we've warned, or this is
			 debugging info, pretend that the symbol is
d7086 1
a7086 5
			 uses of the symbol, not just in this section.
			 The only thing that makes this half reasonable
			 is that we warn in non-debug sections, and
			 debug sections tend to come after other
			 sections.  */
@


1.200
log
@PR 1150
* elf-bfd.h (struct elf_backend_data): New field 'elf_backend_ignore_undef_symbol'.
* elfxx-target.h (elf_backend_ignore_undef_symbol): Define to NULL if not
  already defined.
  (elfNN_bed): Initialise the elf_backend_ignore_undef_symbol field.
* elfxx-mips.c (_bfd_mips_elf_ignore_undef_symbol): New function.
* elfxx-mips.h (elf_backend_ignore_undef_symbol): Define and prototype.
* elflink.c (elf_link_output_extsym): Check elf_backend_ignore_undef_symbol
  before reporting an undefined symbol in a shared library.
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d9070 2
a9071 2
static bfd_boolean
elf_gc_mark_dynamic_ref_symbol (struct elf_link_hash_entry *h, void *inf)
d9100 1
d9102 1
a9102 1
  if (!get_elf_backend_data (abfd)->can_gc_sections
d9128 1
a9128 1
			    elf_gc_mark_dynamic_ref_symbol,
d9132 1
a9132 1
  gc_mark_hook = get_elf_backend_data (abfd)->gc_mark_hook;
@


1.199
log
@	* elflink.c (elf_gc_mark_dynamic_ref_symbol): Use !info-executable
	to test for linking shared libs, not info->shared.
@
text
@d6349 26
a6374 16
  /* If we have an undefined symbol reference here then it must have
     come from a shared library that is being linked in.  (Undefined
     references in regular files have already been handled).  If we
     are reporting errors for this situation then do so now.  */
  if (h->root.type == bfd_link_hash_undefined
      && h->ref_dynamic
      && !h->ref_regular
      && ! elf_link_check_versioned_symbol (finfo->info, bed, h)
      && finfo->info->unresolved_syms_in_shared_libs != RM_IGNORE)
    {
      if (! ((*finfo->info->callbacks->undefined_symbol)
	     (finfo->info, h->root.root.string, h->root.u.undef.abfd,
	      NULL, 0, finfo->info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)))
	{
	  eoinfo->failed = TRUE;
	  return FALSE;
@


1.198
log
@bfd/

2005-12-07  Thiemo Seufer  <ths@@networkno.de>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1932
	* bfd-in.h (bfd_elf_record_link_assignment): Add output_bfd
	and hidden arguments.

	* bfd.c (bfd_hide_symbol): Removed.

	* bfd-in2.h: Regenerated.

	* elflink.c (bfd_elf_record_link_assignment): Handle hidden
	symbols which were provided by a linker script.

ld/

2005-12-07  Thiemo Seufer  <ths@@networkno.de>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1932
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_exp_assignment):
	Adjust bfd_elf_record_link_assignment call.

	* ldexp.c (exp_fold_tree_1): Remove call to bfd_hide_symbol.
@
text
@d9071 1
a9071 1
	  || (info->shared
@


1.197
log
@	* elf.c (elf_fake_sections): When calculating tbss size, just use
	the last link_order.
	(assign_file_positions_for_segments): Likewise.
	* elflink.c (bfd_elf_final_link): Likewise.
	(elf_reloc_link_order): Correct comment.
@
text
@d427 2
a428 1
bfd_elf_record_link_assignment (struct bfd_link_info *info,
d430 2
a431 1
				bfd_boolean provide)
d478 8
@


1.196
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d7397 1
a7397 1
   requested by the linker, and does come from any input file.  This
d8132 1
a8132 1
	  bfd_vma size = sec->size;
d8134 2
a8135 1
	  if (size == 0 && (sec->flags & SEC_HAS_CONTENTS) == 0)
d8137 3
a8139 5
	      struct bfd_link_order *o;

	      for (o = sec->map_head.link_order; o != NULL; o = o->next)
		if (size < o->offset + o->size)
		  size = o->offset + o->size;
@


1.195
log
@	* elflink.c (elf_link_input_bfd): Don't use linker_mark and
	SEC_EXCLUDE to test for sections dropped from output.  Instead,
	use bfd_section_removed_from_list on normal sections.  Don't
	attempt to handle symbols with unknown reserved section indices.
	* linker.c (_bfd_generic_link_output_symbols): Don't use
	linker_mark to test for symbols belonging to dropped sections.
	Do allow absolute symbols.
@
text
@d1286 1
a1286 1
      (*bed->elf_backend_copy_indirect_symbol) (bed, flip, h);
d1440 1
a1440 1
      (*bed->elf_backend_copy_indirect_symbol) (bed, ht, hi);
d1509 1
a1509 1
	  (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
d2320 1
a2320 1
	  (*bed->elf_backend_copy_indirect_symbol) (bed, weakdef, h);
d4142 1
a4142 1
	      (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
@


1.194
log
@2005-09-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_fixup_link_order): Report locations for mixed
	ordered and unordered input sections.
@
text
@d6830 4
a6833 2
	  /* Who knows?  */
	  isec = NULL;
d6864 3
a6866 5
	 discarding, we don't need to keep it, but note that
	 linker_mark is only reliable for sections that have contents.
	 For the benefit of the MIPS ELF linker, we check SEC_EXCLUDE
	 as well as linker_mark.  */
      if ((isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
d6868 2
a6869 8
	      || (! isec->linker_mark && (isec->flags & SEC_HAS_CONTENTS) != 0)
	      || (! finfo->info->relocatable
		  && (isec->flags & SEC_EXCLUDE) != 0)))
	continue;

      /* If the section is not in the output BFD's section list, it is not
	 being output.  */
      if (bfd_section_removed_from_list (output_bfd, isec->output_section))
@


1.193
log
@	* elflink.c (_bfd_elf_merge_symbol): Simplify.
@
text
@d7638 1
a7638 1
  asection *s;
d7641 2
d7647 1
a7647 4
      if (p->type == bfd_indirect_link_order
	  && (bfd_get_flavour ((sub = p->u.indirect.section->owner))
	      == bfd_target_elf_flavour)
	  && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass)
d7650 4
a7653 2
	  elfsec = _bfd_elf_section_from_bfd_section (sub, s);
	  if (elfsec != -1
d7655 4
a7658 1
	    seen_linkorder++;
d7660 4
a7663 1
	    seen_other++;
d7667 14
a7685 8
  if (seen_other && seen_linkorder)
    {
      (*_bfd_error_handler) (_("%A has both ordered and unordered sections"),
			     o);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

@


1.192
log
@2005-09-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_get_linked_section_vma): Fix a typo in comment.
	* elfxx-ia64.c (elf_backend_link_order_error_handler): Likewise.
@
text
@d855 1
a855 4
  if ((abfd->flags & DYNAMIC) != 0)
    newdyn = TRUE;
  else
    newdyn = FALSE;
d857 1
d860 1
a860 1
  else
d862 1
a862 3
      asection *hsec;

      /* This code handles the special SHN_MIPS_{TEXT,DATA} section
d864 1
a864 20
      switch (h->root.type)
	{
	default:
	  hsec = NULL;
	  break;

	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
	  hsec = h->root.u.def.section;
	  break;

	case bfd_link_hash_common:
	  hsec = h->root.u.c.p->section;
	  break;
	}

      if (hsec == NULL)
	olddyn = FALSE;
      else
	olddyn = (hsec->symbol->flags & BSF_DYNAMIC) != 0;
d870 1
a870 4
  if (bfd_is_und_section (sec) || bfd_is_com_section (sec))
    newdef = FALSE;
  else
    newdef = TRUE;
d872 3
a874 6
  if (h->root.type == bfd_link_hash_undefined
      || h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_common)
    olddef = FALSE;
  else
    olddef = TRUE;
@


1.191
log
@2005-09-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1263
	* elflink.c (elf_link_add_object_symbols): Abort for
	--just-symbols on DSO.
@
text
@d7614 1
a7614 1
     SHF_LINK_ORDER.  But it doesn't set theh sh_link or
@


1.190
log
@2005-09-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1301
	* elflink.c (_bfd_elf_merge_symbol): Don't check undefined
	symbol introduced by "ld -u" for TLS.
@
text
@d3294 1
a3294 2
	 Test for --just-symbols by looking at info set up by
	 _bfd_elf_link_just_syms.  */
d3297 1
a3297 1
	goto error_return;
@


1.189
log
@	* elflink.c (_bfd_elf_define_linkage_sym): Don't call
	bfd_elf_link_record_dynamic_symbol.  Call elf_backend_hide_symbol.
	(_bfd_elf_link_renumber_dynsyms): Formatting.
	(struct elf_gc_sweep_symbol_info): New.
	(elf_gc_sweep_symbol): Rewrite.
	(elf_gc_sweep): Adjust params and elf_gc_sweep_symbol call.
	Call _bfd_elf_link_renumber_dynsyms.
	(bfd_elf_gc_sections): Adjust elf_gc_sweep call.
@
text
@d905 2
a906 1
  /* Check TLS symbol.  */
d908 2
a909 1
      && ELF_ST_TYPE (sym->st_info) != h->type)
@


1.188
log
@	* elf-bfd.h (_bfd_elf_define_linkage_sym): Declare.
	* elflink.c (_bfd_elf_define_linkage_sym): New function, extracted
	from..
	(_bfd_elf_create_got_section): ..here.
	(_bfd_elf_link_create_dynamic_sections): Call it for _DYNAMIC.
	(_bfd_elf_create_dynamic_sections): ..and _PROCEDURE_LINKAGE_TABLE_.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Use
	_bfd_elf_define_linkage_sym.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf64-alpha.c (elf64_alpha_create_dynamic_sections): Likewise.
@
text
@d40 1
d63 2
a64 4
  if (!info->executable
      && !bfd_elf_link_record_dynamic_symbol (info, h))
    return NULL;

d738 2
a739 1
  return elf_hash_table (info)->dynsymcount = dynsymcount;
d8855 6
d8862 1
a8862 1
elf_gc_sweep_symbol (struct elf_link_hash_entry *h, void *idxptr)
a8863 2
  int *idx = idxptr;

d8867 8
a8874 5
  if (h->dynindx != -1
      && ((h->root.type != bfd_link_hash_defined
	   && h->root.type != bfd_link_hash_defweak)
	  || h->root.u.def.section->gc_mark))
    h->dynindx = (*idx)++;
d8885 1
a8885 1
elf_gc_sweep (struct bfd_link_info *info, gc_sweep_hook_fn gc_sweep_hook)
d8888 4
d8948 4
a8951 13
  {
    int i = 0;

    elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol, &i);

    /* There is an unused NULL entry at the head of the table which
       we must account for in our count.  Unless there weren't any
       symbols, which means we'll have no table at all.  */
    if (i != 0)
      ++i;

    elf_hash_table (info)->dynsymcount = i;
  }
d8953 1
d9190 1
a9190 4
  if (!elf_gc_sweep (info, get_elf_backend_data (abfd)->gc_sweep_hook))
    return FALSE;

  return TRUE;
@


1.187
log
@bfd/
	* elf32-ppc.c (struct elf_linker_section): Replace sym_val field
	with sym.
	(ppc_elf_relocate_section): Adjust for above.
	(create_sdata_sym): New function.
	(ppc_elf_create_linker_section): Call it.
	(ppc_elf_check_relocs): Correct has_sda_refs and non_got_refs.
	Create sdata syms for all SDA relocs.
	(ppc_elf_adjust_dynamic_symbol): Don't special case _SDA_BASE_
	and _SDA2_BASE_.
	(ppc_elf_set_sdata_syms): Delete.
	* elflink.c (bfd_elf_size_dynamic_sections): Don't create DT_INIT
	and DT_FINI tags unless associated section has input.
	(bfd_elf_set_symbol, _bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in.h (_bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c (ldemul_do_assignments, do_assignments_default): Delete.
	* ldemul.h (ldemul_do_assignments, do_assignments_default): Delete.
	(struct ld_emulation_xfer_struct): Remove do_assignments field.
	* ldlang.c (lang_do_assignments): Don't call ldemul_do_assignments.
	* emulparams/elf32ppc.sh (SDATA_START_SYMBOLS): New.
	(SDATA2_START_SYMBOLS, SBSS_START_SYMBOLS, SBSS_END_SYMBOLS): New.
	* emultempl/aix.em (ld_*_emulation): Delete do_assignments init.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/elf32.em: Likewise.
	(gld*_provide_bound_symbols): Delete.
	(gld*_provide_init_fini_syms): Delete.
	(gld*_before_allocation): Don't call ldemul_do_assignments.
	* emultempl/ppc32elf.em (ppc_do_assignments): Delete.
	(LDEMUL_DO_ASSIGNMENTS): Delete.
	* scripttempl/elf.sc: Provide init/fini syms.  Add SBSS_START_SYMBOLS,
	SBSS_END_SYMBOLS, SDATA2_START_SYMBOLS.
@
text
@d30 39
a74 1
  struct bfd_link_hash_entry *bh;
d119 3
a121 12
      bh = NULL;
      if (!(_bfd_generic_link_add_one_symbol
	    (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
	     0, NULL, FALSE, bed->collect, &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->def_regular = 1;
      h->type = STT_OBJECT;
      h->other = STV_HIDDEN;

      if (! info->executable
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
a122 2

      elf_hash_table (info)->hgot = h;
a161 2
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
d240 1
a240 21
  h = elf_link_hash_lookup (elf_hash_table (info), "_DYNAMIC",
			    FALSE, FALSE, FALSE);
  if (h != NULL)
    {
      /* Zap symbol defined in an as-needed lib that wasn't linked.
	 This is a symptom of a larger problem:  Absolute symbols
	 defined in shared libraries can't be overridden, because we
	 lose the link to the bfd which is via the symbol section.  */
      h->root.type = bfd_link_hash_new;
    }
  bh = &h->root;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_DYNAMIC", BSF_GLOBAL, s, 0, NULL, FALSE,
	  get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->def_regular = 1;
  h->type = STT_OBJECT;

  if (! info->executable
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d290 6
a295 19
  if (bed->want_plt_sym)
    {
      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
	 .plt section.  */
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s, 0, NULL,
	      FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->def_regular = 1;
      h->type = STT_OBJECT;

      if (! info->executable
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }
@


1.186
log
@bfd/
	* elflink.c (fix_syms, _bfd_elf_fix_excluded_sec_syms): Move to..
	* linker.c (fix_syms, _bfd_fix_excluded_sec_syms): ..here.
	* bfd-in.h (_bfd_fix_excluded_sec_syms): Rename.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c (ldemul_finish): Call ld_emulation->finish unconditionally.
	(finish_default): New function.
	* ldemul.h (finish_default): Declare.
	* emultempl/aix.em (gld*_before_allocation): Call
	before_allocation_default rather than strip_excluded_output_sections.
	(ld_*_emulation): Init finish field to finish_default.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
@
text
@d5035 1
d5239 2
a5240 1
      if (bfd_get_section_by_name (output_bfd, ".preinit_array") != NULL)
d5268 2
a5269 1
      if (bfd_get_section_by_name (output_bfd, ".init_array") != NULL)
d5275 2
a5276 1
      if (bfd_get_section_by_name (output_bfd, ".fini_array") != NULL)
a9847 49
static void
bfd_elf_set_symbol (struct elf_link_hash_entry *h, bfd_vma val,
		    struct bfd_section *s)
{
  h->root.type = bfd_link_hash_defined;
  h->root.u.def.section = s ? s : bfd_abs_section_ptr;
  h->root.u.def.value = val;
  h->def_regular = 1;
  h->type = STT_OBJECT;
  h->other = STV_HIDDEN | (h->other & ~ ELF_ST_VISIBILITY (-1));
  h->forced_local = 1;
}

/* Set NAME to VAL if the symbol exists and is not defined in a regular
   object file.  If S is NULL it is an absolute symbol, otherwise it is
   relative to that section.  */

void
_bfd_elf_provide_symbol (struct bfd_link_info *info, const char *name,
			 bfd_vma val, struct bfd_section *s)
{
  struct elf_link_hash_entry *h;

  bfd_elf_record_link_assignment (info, name, TRUE);

  h = elf_link_hash_lookup (elf_hash_table (info), name, FALSE, FALSE, FALSE);
  if (h != NULL
      && !(h->root.type == bfd_link_hash_defined
	   && h->root.u.def.section != NULL
	   && h->root.u.def.section != h->root.u.def.section->output_section))
    bfd_elf_set_symbol (h, val, s);
}

/* Set START and END to boundaries of SEC if they exist and are not
   defined in regular object files.  */

void
_bfd_elf_provide_section_bound_symbols (struct bfd_link_info *info,
					asection *sec,
					const char *start,
					const char *end)
{
  bfd_vma val = 0;
  _bfd_elf_provide_symbol (info, start, val, sec);
  if (sec != NULL)
    val = sec->size;
  _bfd_elf_provide_symbol (info, end, val, sec);
}

@


1.185
log
@	* elflink.c (elf_gc_sweep):  Set dynsymcount to correct value.
@
text
@a9892 33
/* Convert symbols in excluded output sections to absolute.  */

static bfd_boolean
fix_syms (struct bfd_link_hash_entry *h, void *data)
{
  bfd *obfd = (bfd *) data;

  if (h->type == bfd_link_hash_warning)
    h = h->u.i.link;

  if (h->type == bfd_link_hash_defined
      || h->type == bfd_link_hash_defweak)
    {
      asection *s = h->u.def.section;
      if (s != NULL
	  && s->output_section != NULL
	  && (s->output_section->flags & SEC_EXCLUDE) != 0
	  && bfd_section_removed_from_list (obfd, s->output_section))
	{
	  h->u.def.value += s->output_offset + s->output_section->vma;
	  h->u.def.section = bfd_abs_section_ptr;
	}
    }

  return TRUE;
}

void
_bfd_elf_fix_excluded_sec_syms (bfd *obfd, struct bfd_link_info *info)
{
  bfd_link_hash_traverse (info->hash, fix_syms, obfd);
}

@


1.184
log
@	* elf-bfd.h (struct elf_backend_data): Add action_discarded.
	(enum action_discarded): Move from..
	* elflink.c (enum action_discarded): ..here.
	(_bfd_elf_default_action_discarded): Rename from elf_action_discarded.
	Remove target specific section checks.
	(elf_link_input_bfd): Adjust.
	* elfxx-target.h (elf_backend_action_discarded): Define.
	(elfNN_bed): Init new field.
	* bfd-in.h (_bfd_elf_default_action_discarded): Declare.
	* bfd-in2.h: Regenerate.
	* elf-hppa.h (elf_hppa_action_discarded): New function.
	* elf32-hppa.c (elf_backend_action_discarded): Define.
	* elf64-hppa.c (elf_backend_action_discarded): Define.
	* elf32-ppc.c (ppc_elf_action_discarded): New function.
	(elf_backend_action_discarded): Define.
@
text
@d8946 6
@


1.183
log
@	* elflink.c (fix_syms): Handle symbols defined in input sections.
@
text
@a6692 6
enum action_discarded
  {
    COMPLAIN = 1,
    PRETEND = 2
  };

d6702 2
a6703 2
static unsigned int
elf_action_discarded (asection *sec)
a6713 6
  if (strcmp (".PARISC.unwind", sec->name) == 0)
    return 0;

  if (strcmp (".fixup", sec->name) == 0)
    return 0;

d7033 1
a7033 1
	      unsigned int action = elf_action_discarded (o);
@


1.182
log
@	* elflink.c (_bfd_elf_merge_symbol): Skip weak redefinition
	regardless of strength of previous definition.
@
text
@d9914 3
a9916 2
	  && s == s->output_section
	  && bfd_section_removed_from_list (obfd, s))
d9918 1
a9918 1
	  h->u.def.value += s->vma;
@


1.181
log
@	* elflink.c (elf_gc_mark_dynamic_ref_symbol): Handle -shared.
	(bfd_elf_gc_sections): Allow -gc-sections when -shared.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Correct for -shared.
@
text
@d1219 1
a1219 1
  if (newdef && olddef && newweak && !oldweak)
@


1.180
log
@	* elflink.c (elf_gc_sweep): Move gcc_except_table code..
	(bfd_elf_gc_sections): ..to here.
@
text
@d9075 3
a9077 2
/* Mark sections containing dynamically referenced symbols.  This is called
   through elf_link_hash_traverse.  */
d9080 1
a9080 2
elf_gc_mark_dynamic_ref_symbol (struct elf_link_hash_entry *h,
				void *okp ATTRIBUTE_UNUSED)
d9082 2
d9089 5
a9093 1
      && h->ref_dynamic)
a9112 1
      || info->shared
d9137 1
a9137 3
			    &ok);
  if (!ok)
    return FALSE;
@


1.179
log
@2005-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add common_definition,
	common_section_index, common_section, and merge_symbol.
	(_bfd_elf_common_definition): New.
	(_bfd_elf_common_section_index): New.
	(_bfd_elf_common_section): New.

	* elf.c (elf_fake_sections): Don't clear sh_flags.

	* elflink.c (_bfd_elf_merge_symbol): Call backend merge_symbol
	if it is available.
	(is_global_data_symbol_definition): Call backend
	common_definition instead of checking SHN_COMMON.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_output_extsym): Call backend common_section_index
	for common section index.
	(_bfd_elf_common_definition): New.
	(_bfd_elf_common_section_index): New.
	(_bfd_elf_common_section): New.

	* elfxx-target.h (elf_backend_common_definition): New.
	(elf_backend_common_section_index): New.
	(elf_backend_common_section): New.
	(elf_backend_merge_symbol): New.
	(elfNN_bed): Initialize common_definition, common_section_index,
	common_section, and merge_symbol.

	* section.c (BFD_FAKE_SECTION): New.
	(STD_SECTION): Use it.
	* bfd-in2.h: Regenerated.
@
text
@a8914 35
	  /* Keep .gcc_except_table.* if the associated .text.* is
	     marked.  This isn't very nice, but the proper solution,
	     splitting .eh_frame up and using comdat doesn't pan out 
	     easily due to needing special relocs to handle the
	     difference of two symbols in separate sections.
	     Don't keep code sections referenced by .eh_frame.  */
	  if (o->gc_mark_from_eh && (o->flags & SEC_CODE) == 0)
	    {
	      if (strncmp (o->name, ".gcc_except_table.", 18) == 0)
		{
		  unsigned long len;
		  char *fn_name;
		  asection *fn_text;

		  len = strlen (o->name + 18) + 1;
		  fn_name = bfd_malloc (len + 6);
		  if (fn_name == NULL)
		    return FALSE;
		  memcpy (fn_name, ".text.", 6);
		  memcpy (fn_name + 6, o->name + 18, len);
		  fn_text = bfd_get_section_by_name (sub, fn_name);
		  free (fn_name);
		  if (fn_text != NULL && fn_text->gc_mark)
		    o->gc_mark = 1;
		}

	      /* If not using specially named exception table section,
		 then keep whatever we are using.  */
	      else
		o->gc_mark = 1;

	      if (o->gc_mark)
		continue;
	    }

d9151 42
@


1.178
log
@2005-07-23  Olaf Hering <olh@@suse.de>

	* elflink.c (elf_link_input_bfd): Add '\n' for linker einfo
	callback.
@
text
@d783 1
d1125 13
d1214 1
a1214 1
      *psec = sec = bfd_com_section_ptr;
d2658 2
d2675 2
a2676 1
  if (sym->st_shndx == SHN_COMMON)
d3568 1
d3578 1
d3591 1
a3591 2
	  if (isym->st_shndx != SHN_UNDEF
	      && isym->st_shndx != SHN_COMMON)
d3882 1
a3882 2
      if ((isym->st_shndx == SHN_COMMON
	   || bfd_is_com_section (sec))
d3887 1
a3887 1
	  if (isym->st_shndx == SHN_COMMON)
d3913 1
a3913 1
	  if ((old_alignment || isym->st_shndx == SHN_COMMON)
d6518 1
a6518 1
      sym.st_shndx = SHN_COMMON;
d9920 18
@


1.177
log
@	PR ld/1021
	PR ld/1031
	* elflink.c (elf_link_add_object_symbols): Also append the version
	name to non-hidden absolute symbols that are functions.
@
text
@d7092 1
a7092 1
			     "defined in discarded section `%A' of %B"),
@


1.176
log
@	* elflink.c (bfd_elf_record_link_assignment): Remove output_bfd param.
	(_bfd_elf_provide_symbol): Allow redefinition of weak syms and those
	defined in output sections.  Call bfd_elf_record_link_assignment.
	* bfd-in.h (bfd_elf_record_link_assignment): Update prototype.
	* bfd-in2.h: Regenerate.
@
text
@d3690 3
a3692 3
	     However, we do not modify a non-hidden absolute
	     symbol, because it might be the version symbol
	     itself.  FIXME: What if it isn't?  */
d3694 2
a3695 1
	      || (vernum > 1 && ! bfd_is_abs_section (sec)))
@


1.175
log
@bfd/
	* bfd-in.h (_bfd_elf_fix_excluded_sec_syms): Declare.
	(_bfd_elf_provide_section_bound_symbols): Remove param name.
	Formatting.
	* bfd-in2.h: Regenerate.
	* elflink.c (bfd_elf_gc_sections): Don't call generic function.
	(_bfd_elf_provide_symbol): Formatting.
	(_bfd_elf_provide_section_bound_symbols): Remove all hacks, just
	create section relative syms.
	(fix_syms, _bfd_elf_fix_excluded_sec_syms): New functions.
	* elf32-ppc.c (ppc_elf_set_sdata_syms): Use
	_bfd_elf_provide_section_bound_symbols.
	* reloc.c (bfd_mark_used_section): Delete.
	(bfd_generic_gc_sections): Don't call the above.
ld/
	* ldlang.c (strip_excluded_output_sections): Don't call
	bfd_gc_sections.
	* emultempl/elf32.em (gld*_provide_bound_symbols): Move.
	(gld*_provide_init_fini_syms): Move.
	(gld*_before_allocation): Call the above from here..
	(gld*_finish): ..not here.  Call _bfd_elf_fix_excluded_sec_syms.
	* emultempl/hppaelf.em (hppaelf_finish): Likewise.
	* emultempl/ppc64elf.em (ppc_finish): Likewise.
@
text
@d436 1
a436 2
bfd_elf_record_link_assignment (bfd *output_bfd ATTRIBUTE_UNUSED,
				struct bfd_link_info *info,
d9845 2
d9848 4
a9851 1
  if (h != NULL && !h->def_regular)
@


1.174
log
@2005-07-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_symbol_refs_local_p): Revert the last
	change.
@
text
@a9121 3
  if (!info->gc_sections)
    return bfd_generic_gc_sections (abfd, info);

d9846 1
a9846 2
  h = elf_link_hash_lookup (elf_hash_table (info), name, FALSE, FALSE,
			    FALSE);
d9860 13
a9872 12
  struct elf_link_hash_entry *hs, *he;
  bfd_vma start_val, end_val;
  bfd_boolean do_start, do_end;

  /* Check if we need them or not first.  */
  hs = elf_link_hash_lookup (elf_hash_table (info), start, FALSE,
			     FALSE, FALSE);
  do_start = hs != NULL && !hs->def_regular;

  he = elf_link_hash_lookup (elf_hash_table (info), end, FALSE,
			     FALSE, FALSE);
  do_end = he != NULL && !he->def_regular;
d9874 2
a9875 2
  if (!do_start && !do_end)
    return;
d9877 2
a9878 1
  if (sec != NULL)
d9880 8
a9887 16
      start_val = sec->vma;
      end_val = start_val + sec->size;
    }
  else
    {
      /* We have to choose those values very carefully.  Some targets,
	 like alpha, may have relocation overflow with 0. "__bss_start"
	 should be defined in all cases.  */
      struct elf_link_hash_entry *h
	= elf_link_hash_lookup (elf_hash_table (info), "__bss_start",
				FALSE, FALSE, FALSE);
      if (h != NULL && h->root.type == bfd_link_hash_defined)
	start_val = h->root.u.def.value;
      else
	start_val = 0;
      end_val = start_val;
d9890 2
a9891 2
  if (do_start)
    bfd_elf_set_symbol (hs, start_val, NULL);
d9893 4
a9896 2
  if (do_end)
    bfd_elf_set_symbol (he, end_val, NULL);
@


1.173
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 975
	* elflink.c (_bfd_elf_symbol_refs_local_p): Only undefined
	symbol with default visibility is local.
@
text
@d2575 2
a2576 4
     resolve locally unless it has non-default visibility .  The sym
     is either undefined or dynamic.  */
  else if (!h->def_regular
	   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
@


1.172
log
@	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Ignore dynamic
	_SDA_BASE_ and _SDA2_BASE_ symbols.
	* elflink.c (_bfd_elf_provide_symbol): Correct comment.  Define
	sym if not def_regular.
	(_bfd_elf_provide_section_bound_symbols): Similarly.
@
text
@d2575 4
a2578 2
     resolve locally.  The sym is either undefined or dynamic.  */
  else if (!h->def_regular)
@


1.171
log
@	* elflink.c (_bfd_elf_gc_mark): Mark sections referenced by
	.eh_frame specially..
	(bfd_elf_gc_sections): ..rather than totally ignoring .eh_frame.
	Don't recheck sections we have already marked.
	(elf_gc_sweep): Keep non-code sections referenced from .eh_frame.
	* section.c (struct bfd_section): Add gc_mark_from_eh.
	(STD_SECTION): Adjust.
	* ecoff.c (bfd_debug_section): Adjust.
	* bfd-in2.h: Regenerate.
@
text
@d9839 3
a9841 2
/* Set NAME to VAL if the symbol exists and is undefined.  If val is NULL
   it is an absolute symbol, otherwise it is relative to that section.  */
d9851 1
a9851 2
  if (h != NULL && (h->root.type == bfd_link_hash_undefined
		    || h->root.type == bfd_link_hash_undefweak))
d9855 2
a9856 2
/* Set START and END to boundaries of SEC if they exist and are
   undefined.  */
d9871 1
a9871 3
  do_start = (hs != NULL
	      && (hs->root.type == bfd_link_hash_undefined
		  || hs->root.type == bfd_link_hash_undefweak));
d9875 1
a9875 3
  do_end = (he != NULL
	    && (he->root.type == bfd_link_hash_undefined
		|| he->root.type == bfd_link_hash_undefweak));
@


1.170
log
@	* elflink.c (elf_gc_sweep): Do not refcount on sections that have
	not been processed by check_relocs.
@
text
@d8736 1
d8749 1
d8826 2
d8898 35
d9167 3
a9169 12
	{
	  if (o->flags & SEC_KEEP)
	    {
	      /* _bfd_elf_discard_section_eh_frame knows how to discard
		 orphaned FDEs so don't mark sections referenced by the
		 EH frame section.  */
	      if (strcmp (o->name, ".eh_frame") == 0)
		o->gc_mark = 1;
	      else if (!_bfd_elf_gc_mark (info, o, gc_mark_hook))
		return FALSE;
	    }
	}
@


1.169
log
@2005-06-29  Paul Brook  <paul@@codesourcery.com>

	* bfd-in.h (_bfd_elf_provide_symbol): Update prototype.
	* bfd-in2.h: Regenerate.
	* elf32-ppc.c (ppc_elf_set_sdata_syms): Make sdata symbols section
	relative.
	* elflink.c (bfd_elf_set_symbol): Add section argument.
	(_bfd_elf_provide_symbol): Ditto.
	(_bfd_elf_provide_section_bound_symbols): Pass NULL section argument.
@
text
@d8905 3
a8907 1
	      && (o->flags & SEC_RELOC) && o->reloc_count > 0)
@


1.168
log
@2005-06-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_merge_symbol): Fix a typo in comment.
@
text
@d9795 2
a9796 1
bfd_elf_set_symbol (struct elf_link_hash_entry *h, bfd_vma val)
d9799 1
a9799 1
  h->root.u.def.section = bfd_abs_section_ptr;
d9807 2
a9808 1
/* Set NAME to VAL if the symbol exists and is undefined.  */
d9812 1
a9812 1
			 bfd_vma val)
d9820 1
a9820 1
    bfd_elf_set_symbol (h, val);
d9873 1
a9873 1
    bfd_elf_set_symbol (hs, start_val);
d9876 1
a9876 1
    bfd_elf_set_symbol (he, end_val);
@


1.167
log
@	* elflink.c (elf_mark_used_section): Delete.
	(bfd_elf_gc_sections): Call bfd_generic_gc_sections.
	* reloc.c (bfd_mark_used_section): New function.
	(bfd_generic_gc_sections): Call bfd_mark_used_section.
@
text
@d1191 2
a1192 2
     common symbol, and let _bfd_generic_link_add_one_symbol will do
     the right thing.  */
@


1.166
log
@include/
	* bfdlink.h (struct bfd_link_callbacks): Add einfo.
bfd/
	* configure.in: Bump version
	* configure: Regenerate.
	* elflink.c (elf_link_input_bfd): Use einfo linker callback to print
	discarded section sym refs and kill linker output.
	* simple.c (simple_dummy_einfo): New function.
	(bfd_simple_get_relocated_section_contents): Init callbacks.einfo.
ld/
	* ldmain.c (link_callbacks): Add einfo.
	(add_archive_element): Use passed info, not link_info.
	(constructor_callback): Likewise.
	(reloc_overflow): Don't handle null bfd specially.
	(reloc_dangerous, unattached_reloc): Likewise.
	* ldmisc.c (vfinfo <B>): Print "ld generated" for null bfd.
	(vfinfo <C, D, G>): Handle null bfd.  Wrap comments.
@
text
@a9069 21
/* Mark sections containing global symbols.  This is called through
   elf_link_hash_traverse.  */

static bfd_boolean
elf_mark_used_section (struct elf_link_hash_entry *h,
		       void *data ATTRIBUTE_UNUSED)
{
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->root.type == bfd_link_hash_defined
      || h->root.type == bfd_link_hash_defweak)
    {
      asection *s = h->root.u.def.section;
      if (s != NULL && s->output_section != NULL)
	s->output_section->flags |= SEC_KEEP;
    }

  return TRUE;
}

d9082 1
a9082 9
    {
      /* If we are called when info->gc_sections is 0, we will mark
	 all sections containing global symbols for non-relocatable
	 link.  */
      if (!info->relocatable)
	elf_link_hash_traverse (elf_hash_table (info),
				elf_mark_used_section, NULL);
      return TRUE;
    }
@


1.165
log
@	* elf-bfd.h (struct elf_link_hash_table): Delete init_refcount and
	init_offset.  Add init_got_refcount, init_plt_refcount,
	init_got_offset and init_plt_offset.
	* elf.c (_bfd_elf_link_hash_newfunc): Adjust for above change.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	(_bfd_elf_link_hash_table_init): Likewise.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_adjust_dynamic_symbol): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (GLINK_PLTRESOLVE): Now 16 insns.
	(LWZU_0_X_12, LWZ_0_4_30, LWZ_0_X_12, LWZ_11_X_11, LWZ_11_X_30,
	LWZ_12_4_12, LWZ_12_8_30, LWZ_12_X_12, SUB_11_11_30): Delete.
	(ADDIS_12_12, BCL_20_31, LWZU_0_12, LWZ_0_12, LWZ_11_11, LWZ_11_30,
	LWZ_12_12, MFLR_0, MFLR_12, MTLR_0, SUB_11_11_12): Define.
	(struct plt_entry): New.
	(ppc_elf_link_hash_table_create): Set new init_plt fields.
	(ppc_elf_copy_indirect_symbol): Handle merge of plt plist.  Don't
	use _bfd_elf_link_hash_copy_indirect.
	(update_plt_info, find_plt_ent): New functions.
	(ppc_elf_check_relocs): Handle R_PPC_PLTREL24 with non-zero addend
	and adjust for use of plt list rather than refcount.
	(ppc_elf_gc_sweep_hook): Likewise.
	(ppc_elf_tls_optimize): Likewise.
	(ppc_elf_adjust_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Likewise.
	(ppc_elf_relax_section): Likewise.
	(ppc_elf_relocate_section): Likewise.  Adjust R_PPC_PLTREL24 addends
	when performing a relocatable link.
	(ppc_elf_finish_dynamic_symbol): Likewise.  Write .glink stubs here..
	(ppc_elf_finish_dynamic_sections): ..rather than here.  Use new
	pic resolver stub.
@
text
@d7090 4
a7093 8
			{
			  (*_bfd_error_handler)
			    (_("`%s' referenced in section `%A' of %B: "
			       "defined in discarded section `%A' of %B"),
			     o, input_bfd, sec, sec->owner, sym_name);
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
@


1.164
log
@* elflink.c (bfd_elf_size_dynamic_sections): Use lbasename instead
of basename.
@
text
@d2365 2
a2366 2
      h->plt = elf_hash_table (eif->info)->init_offset;
      h->got = elf_hash_table (eif->info)->init_offset;
d2395 1
a2395 1
      h->plt = elf_hash_table (eif->info)->init_offset;
d4989 4
a4992 1
  elf_hash_table (info)->init_refcount = elf_hash_table (info)->init_offset;
@


1.163
log
@2005-05-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 939
	* elflink.c (elf_link_output_extsym): Use output_bfd if
	h->root.u.def.section is bfd_abs_section_ptr when reporting
	error.
@
text
@d5380 1
a5380 1
	      name = basename (output_bfd->filename);
d5603 1
a5603 1
					    : basename (t->vn_bfd->filename),
@


1.162
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Remove got_symbol_offset.
	* elfxx-target.h (elf_backend_got_symbol_offset): Delete.
	* elflink.c (_bfd_elf_create_got_section): Use zero in place of
	got_symbol_offset.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Likewise.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Delete ppc code.
	(elf_backend_got_symbol_offset): Don't define.
	* elf64-ppc.c (elf_backend_got_symbol_offset): Don't define.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Add got_header_size
	and got_gap.
	(ppc_elf_create_got): Tidy.
	(ppc_elf_create_dynamic_sections): Don't set SEC_IN_MEMORY for .plt.
	(ppc_elf_check_relocs): Reduce string comparisons by using elf.hgot.
	(ppc_elf_gc_sweep_hook): Likewise.
	(ppc_elf_relocate_section): Likewise.
	(ppc_elf_finish_dynamic_symbol): Likewise.
	(allocate_got): New function.
	(allocate_dynrelocs): Use allocate_got.
	(ppc_elf_size_dynamic_sections): Likewise.  Delay tlsld_got allocation
	so that local got can refcount it.  Set got_header_size.
	(ppc_elf_relocate_section): Use value of elf.hgot rather than hard-
	coded 4.
	(ppc_elf_finish_dynamic_sections): Likewise.
	(elf_backend_got_symbol_offset): Don't define.
	(elf_backend_got_header_size): Ditto.
ld/testsuite/
	* ld-powerpc/tlsexe32.d: Update for changed got layout.
	* ld-powerpc/tlsexe32.g: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.g: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
@
text
@d6382 3
a6384 1
	 finfo->output_bfd, h->root.u.def.section->owner,
@


1.161
log
@bfd/

2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_provide_section_bound_symbols): Use
	"__bss_start" instead of "_edata" as fallback.

ld/

2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* scripttempl/elf.sc: Document the usage of __bss_start.
@
text
@d84 1
a84 1
	     bed->got_symbol_offset, NULL, FALSE, bed->collect, &bh)))
d99 1
a99 1
  s->size += bed->got_header_size + bed->got_symbol_offset;
d923 1
a923 1
	  ntbfd = abfd; 
d3594 1
a3594 1
	         default visibility.  */
d7058 1
a7058 1
		      
d7666 1
a7666 1
  
d7698 1
a7698 1
  
d7702 1
a7702 1
  
d9068 1
a9068 1
 
d9089 1
a9089 1
 
d9159 1
a9159 1
		 EH frame section.  */  
d9756 1
a9756 1
	  
d9845 1
a9845 1
	            || h->root.type == bfd_link_hash_undefweak))
@


1.160
log
@2005-05-05  Paul Brook  <paul@@codesourcery.com>

bfd/
	* config.bfd: Use bfd_elf32_i386_vxworks_vec for i?86-*-vxworks.
	* configure.in: Add bfd_elf32_i386_vxworks_vec. i386 targets need
	elf-vxworks.lo.
	* configure: Regenerate.
	* Makefile.am (BFD32_BACKENDS): Add elf-vxworks.lo.
	(BFD32_BACKENDS_CFILES): Add elf-vxworks.c.
	(elf32-i386.lo): Depend on elf-vxworks.h.
	(elf-vxworks.lo): New rule.
	* Makefile.in: Regenerate.
	* elf-bfd.h (elf_backend_data): Update type of
	elf_backend_emit_relocs.
	(_bfd_elf_link_output_relocs): Update prototype.
	* elflink.c (_bfd_elf_link_output_relocs): Always use
	bed->elf_backend_emit_relocs when outputting relocations.
	* elfxx-target.h (elf_backend_emit_relocs): Default to
	_bfd_elf_link_output_relocs.
	* targets.c (bfd_elf32_i386_vxworks_vec): Declare.
	(_bfd_target_vector): Add bfd_elf32_i386_vxworks_vec.
	* elf32-i386.c: Add elf32-i386-vxworks target BFD.
	(elf_i386_plt0_entry): Remove padding.
	(elf_i386_pic_plt0_entry): Ditto.
	(PLTRESOLVE_RELOCS_SHLIB, PLTRESOLVE_RELOCS): Define.
	(PLT_NON_JUMP_SLOT_RELOCS): Define.
	(elf_i386_link_hash_table): Add srelplt2, hgot, hplt, is_vxworks and
	plt0_pad_byte fields.
	(elf_i386_link_hash_table_create): Zero them.
	(elf_i386_create_dynamic_sections): Create static relocation section.
	(allocate_dynrelocs): Allocate space for static PLT relocations.
	(elf_i386_size_dynamic_sections): Save shortcuts to PLT and GOT
	symbols.  Give PLT symbols function type.  Don't strip PLT sections
	if we have exported symbols from them.
	(elf_i386_finish_dynamic_symbol): Fill in VxWorks PLT static
	relocation section.  Don't mark _GLOBAL_OFFSET_TABLE_ as absolute on
	VxWorks.
	(elf_i386_finish_dynamic_sections): Allow different pad bytes.
	Add relocation for GOT location.  Fill in PLT static relocations.
	(elf_i386_vxworks_link_hash_table_create): New function.
	(elf_i386_vxworks_link_output_symbol_hook): New function.
	* elf-vxworks.h: New file.
gas/
	* config/tc-i386.h (ELF_TARGET_FORMAT): Define for TE_VXWORKS.
gas/testsuite/
	* gas/i386/i386.exp: Don't run divide test on vxworks.
ld/
	* Makefile.am: Add eelf_i386_vxworks.
	* Makefile.in: Regenerate.
	* configure.tgt: Make i?86-*-vxworks use targ_emul=elf_i386_vxworks.
	* emulparams/elf_i386_vxworks.sh: New file.
	* emulparams/vxworks.sh: New file.
	* scripttempl/elf.sc: Add DATA_END_SYMBOLS and ETEXT_NAME.
@
text
@d9886 1
a9886 1
	 like alpha, may have relocation overflow with 0. "_edata"
d9889 1
a9889 1
	= elf_link_hash_lookup (elf_hash_table (info), "_edata",
@


1.159
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d2137 3
a2139 1
			     Elf_Internal_Rela *internal_relocs)
d6783 1
a6783 2
		 || finfo->info->emitrelocations
		 || bed->elf_backend_emit_relocs);
d7163 1
a7165 2
	      bfd_boolean (*reloc_emitter)
		(bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *);
d7180 1
a7362 7
	      if (bed->elf_backend_emit_relocs
		  && !(finfo->info->relocatable
		       || finfo->info->emitrelocations))
		reloc_emitter = bed->elf_backend_emit_relocs;
	      else
		reloc_emitter = _bfd_elf_link_output_relocs;

d7364 4
a7367 2
		  && ! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
					 internal_relocs))
d7375 5
a7379 2
		  if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr2,
					  internal_relocs))
@


1.158
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 882
	* elflink.c (_bfd_elf_link_assign_sym_version): Allow version
	script on executable.
@
text
@d62 1
a62 1
  s = bfd_make_section (abfd, ".got");
a63 1
      || !bfd_set_section_flags (abfd, s, flags)
d69 1
a69 1
      s = bfd_make_section (abfd, ".got.plt");
a70 1
	  || !bfd_set_section_flags (abfd, s, flags)
d157 3
a159 3
      s = bfd_make_section (abfd, ".interp");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
d165 2
a166 1
      s = bfd_make_section (abfd, ".eh_frame_hdr");
a167 1
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d175 2
a176 1
  s = bfd_make_section (abfd, ".gnu.version_d");
a177 1
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d181 2
a182 1
  s = bfd_make_section (abfd, ".gnu.version");
a183 1
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d187 2
a188 1
  s = bfd_make_section (abfd, ".gnu.version_r");
a189 1
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d193 2
a194 1
  s = bfd_make_section (abfd, ".dynsym");
a195 1
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d199 3
a201 3
  s = bfd_make_section (abfd, ".dynstr");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
d204 1
a204 1
  s = bfd_make_section (abfd, ".dynamic");
a205 1
      || ! bfd_set_section_flags (abfd, s, flags)
d238 2
a239 1
  s = bfd_make_section (abfd, ".hash");
a240 1
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d280 1
a280 1
  s = bfd_make_section (abfd, ".plt");
a281 1
      || ! bfd_set_section_flags (abfd, s, pltflags)
d305 4
a308 2
  s = bfd_make_section (abfd,
			bed->default_use_rela_p ? ".rela.plt" : ".rel.plt");
a309 1
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d324 4
a327 3
      s = bfd_make_section (abfd, ".dynbss");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC | SEC_LINKER_CREATED))
d343 4
a346 3
	  s = bfd_make_section (abfd,
				(bed->default_use_rela_p
				 ? ".rela.bss" : ".rel.bss"));
a347 1
	      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d3627 6
a3632 6
	      tcomm = bfd_make_section (abfd, ".tcommon");
	      if (tcomm == NULL
		  || !bfd_set_section_flags (abfd, tcomm, (SEC_ALLOC
							   | SEC_IS_COMMON
							   | SEC_LINKER_CREATED
							   | SEC_THREAD_LOCAL)))
@


1.157
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@a1780 1
		      && info->shared
a1906 1
	      && info->shared
@


1.156
log
@bfd/

2005-05-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd-in.h (_bfd_elf_provide_section_bound_symbols): New.
	* bfd-in2.h: Regenerated.

	* elflink.c (bfd_elf_set_symbol): New.
	(_bfd_elf_provide_symbol): Call it.
	(_bfd_elf_provide_section_bound_symbols): New.

ld/

2005-05-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_provide_bound_symbols):
	Call _bfd_elf_provide_section_bound_symbols.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.155
log
@2005-05-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_merge_symbol): Only skip weak definitions
	at the end, if a strong definition has already been seen.
@
text
@d9827 12
d9851 33
d9885 2
a9886 7
      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = bfd_abs_section_ptr;
      h->root.u.def.value = val;
      h->def_regular = 1;
      h->type = STT_OBJECT;
      h->other = STV_HIDDEN | (h->other & ~ ELF_ST_VISIBILITY (-1));
      h->forced_local = 1;
d9888 20
@


1.154
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@a1080 7
  /* Skip weak definitions of symbols that are already defined.  */
  if (newdef && olddef && newweak && !oldweak)
    {
      *skip = TRUE;
      return TRUE;
    }

d1207 4
@


1.153
log
@Update the FSF address in the copyright/GPL notice
@
text
@a5291 1
      bfd_size_type dynsymcount;
a5293 3
      size_t bucketcount = 0;
      size_t hash_entry_size;
      unsigned int dtagcount;
d5308 1
a5308 1
	_bfd_strip_section_from_output (info, s);
d5562 1
a5562 1
	  _bfd_strip_section_from_output (info, s);
d5651 31
d5693 2
a5694 11
      if (dynsymcount == 0
	  || (verdefs == NULL && elf_tdata (output_bfd)->verref == NULL
	      && !info->create_default_symver))
	{
	  _bfd_strip_section_from_output (info, s);
	  /* The DYNSYMCOUNT might have changed if we were going to
	     output a dynamic symbol table entry for S.  */
	  dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info,
							&section_sym_count);
	}
      else
d5713 1
d5979 1
a5979 1
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
d6004 1
a6004 1
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
d6054 1
a6054 1
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
d7677 1
a7677 1
  for (p = o->link_order_head; p != NULL; p = p->next)
d7711 1
a7711 1
  for (p = o->link_order_head; p != NULL; p = p->next)
d7825 1
a7825 1
      for (p = o->link_order_head; p != NULL; p = p->next)
d8165 1
a8165 1
	      for (o = sec->link_order_head; o != NULL; o = o->next)
d8207 1
a8207 1
      for (p = o->link_order_head; p != NULL; p = p->next)
@


1.152
log
@2005-05-01  Paul Brook  <paul@@codesourcery.com>

	* elflink.c (_bfd_elf_merge_symbol): Skip weak definitions if a strong
	definition has already been seen.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.151
log
@Applied this patch for Julian Brown  <julian@@codesourcery.com>
* elflink.c (_bfd_elf_provide_symbol): Provide symbol for weak import.
@
text
@d1081 7
@


1.150
log
@2005-04-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_sym_name): Also take "asection *".

	* elf.c (bfd_elf_sym_name): Updated.
	(group_signature): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(ppc64_elf_relocate_section): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.c (elf_link_input_bfd): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Call
	bfd_elf_sym_name to get local symbol name when reporting errors.
@
text
@d9811 1
d9814 2
a9815 1
  if (h != NULL && h->root.type == bfd_link_hash_undefined)
@


1.149
log
@Remove spurious spaces added by previous delta
@
text
@d7054 3
a7056 1
		      sym_name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym);
@


1.148
log
@(elf_link_input_bfd): Handle the case where a badly formatted input file results
in a reloc which has no associated global symbol
@
text
@d7022 1
a7022 1
		      
@


1.147
log
@bfd/

2005-04-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 858
	* elflink.c (elf_link_input_bfd): Make non-debugging reference
	to discarded section an error.

ld/testsuite/

2005-04-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-discard/extern.d: Expect error.
	* ld-discard/start.d: Likewise.
	* ld-discard/static.d: Likewise.
@
text
@d7022 17
@


1.146
log
@	PR ld/815
	* elflink.c (elf_smash_syms): Clear undef.next if it's not being
	used as a list pointer.
@
text
@d7051 2
@


1.145
log
@bfd/

2005-04-13  Daniel Jacobowitz  <dan@@codesourcery.com>

	* elflink.c (elf_link_input_bfd): Update check for removed
	sections.

ld/testsuite/

2005-04-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/empty.d: New file.
	* ld-elf/empty.s: Likewise.
@
text
@d2938 2
a2939 1
  /* Set sym back to newly created state, but keep undefs list pointer.  */
d2941 2
@


1.144
log
@2005-03-31  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_check_kept_section): New.

	* elf.c (assign_section_numbers): When sh_link points to a
	discarded section, call _bfd_elf_check_kept_section to see if
	the kept section can be used. Otherwise reject sh_link
	pointing to discarded section.

	* elflink.c (_bfd_elf_check_kept_section): New.
	(elf_link_input_bfd): Use it.
@
text
@d6872 5
@


1.143
log
@2005-03-31  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_link_input_bfd): Remove the extra `\n' in
	error message.
	(_bfd_elf_section_already_linked): Likewise.
@
text
@d6703 20
a7035 2
		      asection *kept;

d7056 1
a7056 2
		      kept = sec->kept_section;
		      if (kept != NULL && (action & PRETEND))
d7058 4
a7061 4
			  if (elf_sec_group (sec) != NULL)
			    kept = match_group_member (sec, kept);
			  if (kept != NULL
			      && sec->size == kept->size)
@


1.142
log
@bfd/

2005-03-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd-in.h (_bfd_elf_provide_symbol): New.
	* bfd-in2.h: Regenerated.

	* elf32-ppc.c (set_linker_sym): Moved to elflink.c.
	(ppc_elf_set_sdata_syms): Call _bfd_elf_provide_symbol instead
	of set_linker_sym.

	* elflink.c (_bfd_elf_provide_symbol): New. Moved and renamed
	from elf32-ppc.c.

ld/

2005-03-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_provide_bound_symbols): New
	(gld${EMULATION_NAME}_finish): Call
	gld${EMULATION_NAME}_provide_bound_symbols to provide
	__preinit_array_start, __preinit_array_end, __init_array_start,
	__init_array_end, __fini_array_start and __fini_array_end.

	* scripttempl/elf.sc: Don't provide __preinit_array_start,
	__preinit_array_end, __init_array_start, __init_array_end,
	__fini_array_start nor __fini_array_end.
@
text
@d7023 1
a7023 1
			       "defined in discarded section `%A' of %B\n"),
d9643 1
a9643 1
		(_("%B: ignoring duplicate section `%A'\n"),
d9650 1
a9650 1
		  (_("%B: duplicate section `%A' has different size\n"),
d9657 1
a9657 1
		  (_("%B: duplicate section `%A' has different size\n"),
d9665 1
a9665 1
		      (_("%B: warning: could not read contents of section `%A'\n"),
d9670 1
a9670 1
		      (_("%B: warning: could not read contents of section `%A'\n"),
d9674 1
a9674 1
		      (_("%B: warning: duplicate section `%A' has different contents\n"),
@


1.141
log
@bfd/
	* elflink.c (elf_link_add_object_symbols): Set SEC_EXCLUDE on
	.gnu.warning.* sections.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Set
	SEC_EXCLUDE on .gnu.warning sections.
@
text
@d9757 21
@


1.140
log
@2005-03-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_mark_used_section): Remove check for special
	sections.
@
text
@d3243 4
@


1.139
log
@2005-03-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_mark_used_section): Check bfd_is_const_section
	for special sections.
@
text
@d9015 1
a9015 3
      if (s != NULL
	  && s->output_section != NULL
	  && !bfd_is_const_section (s->output_section))
@


1.138
log
@	* elf-bfd.h (_bfd_elf_link_renumber_dynsyms): Delete.
	* elflink.c (_bfd_elf_link_renumber_dynsyms): Make static, add
	section_sym_count param, and return number of section symbols.
	(bfd_elf_size_dynamic_sections): Clear section symbol area of
	.dynsym contents.  Don't bother calling swap_symbol_out on the
	first all-zero dynsym.
	(elf_mark_used_section): Formatting.  Avoid twiddling flags in
	special sections like bfd_abs_section.
	(bfd_elf_gc_sections): Spelling fix.
@
text
@d9015 3
a9017 1
      if (s != NULL && s->output_section != NULL && s->output_section != s)
@


1.137
log
@bfd/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_mark_used_section): New.
	(bfd_elf_gc_sections): Call elf_gc_mark_section for
	non-relocatable link if we don't do GC.

include/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Add gc_sections.

ld/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Remove
	unused empty output sections for non-relocatable link.

	* ld.h (args_type): Remove gc_sections.

	* ldlang.c (lang_mark_used_section): New.
	(lang_gc_sections): Use link_info.gc_sections instead of
	command_line.gc_sections.
	* ldmain.c (main): Likewise.
	* lexsup.c (parse_args): Likewise.
	* ldlang.c (lang_process): Call lang_mark_used_section.

	* ldmain.c (main): Initialize link_info.gc_sections to FALSE.

ld/testsuite/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-alpha/tlsbin.rd: Updated for empty section removal.
	* ld-alpha/tlsbinr.rd: Likewise.
	* ld-alpha/tlspic.rd: Likewise.
	* ld-arm/mixed-lib.sym: Likewise.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlspic.rd: Likewise.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-powerpc/apuinfo.rd: Likewise.
	* ld-powerpc/powerpc.exp: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-sh/tlsbin-2.d: Likewise.
	* ld-sh/tlspic-2.d: Likewise.
	* ld-sparc/tlssunbin32.rd: Likewise.
	* ld-sparc/tlssunnopic32.rd: Likewise.
	* ld-sparc/tlssunpic32.rd: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
@
text
@d710 4
a713 2
unsigned long
_bfd_elf_link_renumber_dynsyms (bfd *output_bfd, struct bfd_link_info *info)
d727 1
d5279 1
d5646 2
a5647 1
      dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);
d5659 2
a5660 1
	  dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);
a5681 3
      s->contents = bfd_alloc (output_bfd, s->size);
      if (s->contents == NULL && s->size != 0)
	return FALSE;
d5685 3
a5687 1
	  Elf_Internal_Sym isym;
d5689 4
a5692 8
	  /* The first entry in .dynsym is a dummy symbol.  */
	  isym.st_value = 0;
	  isym.st_size = 0;
	  isym.st_name = 0;
	  isym.st_info = 0;
	  isym.st_other = 0;
	  isym.st_shndx = 0;
	  bed->s->swap_symbol_out (output_bfd, &isym, s->contents, 0);
d9006 1
a9006 1
		     void *global ATTRIBUTE_UNUSED)
d9011 2
a9012 2
  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak))
d9014 3
a9016 3
      asection *s = h->root.u.def.section->output_section;
      if (s)
	s->flags |= SEC_KEEP;
d9036 1
a9036 1
	 all sections containing global symbols for non-relocable
@


1.136
log
@2005-02-28  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 757
	* elf-bfd.h (_bfd_elf_merge_symbol): Add a pointer to unsigned
	int.

	* elf32-sh-symbian.c (sh_symbian_relocate_section): Pass NULL
	to _bfd_elf_merge_symbol.

	* elflink.c (_bfd_elf_merge_symbol): Use the pointer to
	unsigned int to return the alignment of the old common symbol
	in the dynamic object.
	(_bfd_elf_add_default_symbol): Pass NULL to
	_bfd_elf_merge_symbol.
	(elf_link_add_object_symbols): Pass &old_alignment to
	_bfd_elf_merge_symbol. Get the alignment of the new common
	symbol in the dynamic object.
@
text
@d8999 3
d9003 18
d9032 11
@


1.136.2.1
log
@bfd/
	* elflink.c (elf_link_add_object_symbols): Set SEC_EXCLUDE on
	.gnu.warning.* sections.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Set
	SEC_EXCLUDE on .gnu.warning sections.
@
text
@a3239 4

		  /* Also set SEC_EXCLUDE, so that symbols defined in
		     the warning section don't get copied to the output.  */
		  s->flags |= SEC_EXCLUDE;
@


1.136.2.1.2.1
log
@2005-05-01  Paul Brook  <paul@@codesourcery.com>

	* bfd/elflink.c (_bfd_elf_merge_symbol): Skip weak definitions if a
	strong definition has already been seen.
@
text
@a1077 7
  /* Skip weak definitions of symbols that are already defined.  */
  if (newdef && olddef && newweak && !oldweak)
    {
      *skip = TRUE;
      return TRUE;
    }

@


1.136.2.2
log
@	PR ld/815
	* elflink.c (elf_smash_syms): Clear undef.next if it's not being
	used as a list pointer.
@
text
@d2935 1
a2935 2
  /* Set sym back to newly created state, but keep undef.next if it is
     being used as a list pointer.  */
a2936 2
  if (bh == &h->root)
    bh = NULL;
@


1.136.2.3
log
@(elf_link_input_bfd): Handle the case where a badly formatted input file results
in a reloc which has no associated global symbol.
@
text
@a6995 17

		      /* Badly formatted input files can contain relocs that
			 reference non-existant symbols.  Check here so that
			 we do not seg fault.  */
		      if (h == NULL)
			{
			  char buffer [32];

			  sprintf_vma (buffer, rel->r_info);
			  (*_bfd_error_handler)
			    (_("error: %B contains a reloc (0x%s) for section %A "
			       "that references a non-existent global symbol"),
			     input_bfd, o, buffer);
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}

@


1.136.2.4
log
@	PR ld/1021
	PR ld/1031
	* elflink.c (elf_link_add_object_symbols): Also append the version
	name to non-hidden absolute symbols that are functions.
@
text
@d3686 3
a3688 3
	     However, we do not modify a non-hidden absolute symbol
	     if it is not a function, because it might be the version
	     symbol itself.  FIXME: What if it isn't?  */
d3690 1
a3690 2
	      || (vernum > 1 && (! bfd_is_abs_section (sec)
				 || ELF_ST_TYPE (isym->st_info) == STT_FUNC)))
@


1.135
log
@	* elflink.c (elf_link_add_object_symbols): Force symbols in
	discarded COMDAT group sections to have default visibility.
@
text
@d759 2
a760 1
   change.  */
d769 1
d1274 4
a1277 3
      /* FIXME: We no longer know the alignment required by the symbol
	 in the dynamic object, so we just wind up using the one from
	 the regular object.  */
d1389 2
a1390 2
			      &hi, &skip, &override, &type_change_ok,
			      &size_change_ok))
d1493 2
a1494 2
			      &hi, &skip, &override, &type_change_ok,
			      &size_change_ok))
d3531 1
a3531 1
      asection *sec;
d3656 1
d3769 2
a3770 1
	  if (!_bfd_elf_merge_symbol (abfd, info, name, isym, &sec, &value,
d3852 2
a3853 1
      if (isym->st_shndx == SHN_COMMON
d3858 8
a3865 1
	  align = bfd_log2 (isym->st_value);
@


1.134
log
@2005-02-11  Paul Brook  <paul@@codesourcery.com>

	* elf-bfd.h (struct elf_link_hash_table): Add
	is_relocatable_executable.
	* elf.c (_bfd_elf_link_hash_table_init): Initialize it.
	* elflink.c (bfd_elf_link_record_dynamic_symbol): Create local dynamic
	symbols in relocatable executables.
	(bfd_elf_record_link_assignment): Create dynamic section symbols in
	relocatable executables.
	(_bfd_elf_link_renumber_dynsyms): Ditto.
	(bfd_elf_final_link): Ditto.
	* elf32-arm.c (elf32_arm_final_link_relocate): Copy absolute
	relocations into relocatable executables.
	(elf32_arm_check_relocs): Crate dynamic sections for relocatable
	executables.  Also copy absolute relocations.
	(elf32_arm_adjust_dynamic_symbol): Don't create copy relocations
	in relocatable executables.
	(allocate_dynrelocs): Copy relocations for relocatable executables.
	Output dynamic symbols for symbols defined in linker scripts.
@
text
@d3578 2
a3579 1
	      /* Symbols from discarded section are undefined.  */
d3582 2
@


1.133
log
@2005-02-10  Paul Brook  <paul@@codesourcery.com>

	* elflink.c (bfd_elf_record_link_assignment): Make hidden and internal
	symbols local.
	(elf_link_renumber_hash_table_dynsyms): Ignore local symbols.
	(elf_link_renumber_local_hash_table_dynsyms): New function.
	(_bfd_elf_link_renumber_dynsyms): Number local dynamic symbols.
ld/testsuite/
	* ld-elfvsb/hidden2.s: New file
	* ld-elfvsb/hidden2.d: New file
	* ld-elfvsb/hidden2.ld: New file
@
text
@d389 2
a390 1
	      return TRUE;
d498 2
a499 1
       || info->shared)
d715 1
a715 1
  if (info->shared)
d8172 1
a8172 1
      if (info->shared)
@


1.132
log
@	* bfd-in.h (BFD_LINKER_CREATED): Define.
	* bfd-in2.h: Rebuilt.
	* elflink.c (bfd_elf_size_dynamic_sections): Disregard
	BFD_LINKER_CREATED bfds when determining input bfds without
	.note.GNU-stack section.

	* emultempl/hppaelf.em (hppaelf_create_output_section_statements):
	Set BFD_LINKER_CREATED on the stubs bfd.
	* emultempl/ppc64elf.em (ppc_create_output_section_statements):
	Likewise.
@
text
@d487 8
d635 25
d703 4
a706 3
   symbol for each output section, which come first.  Next come all of
   the back-end allocated local dynamic syms, followed by the rest of
   the global symbols.  */
d724 4
@


1.131
log
@2005-02-08  Paul Brook  <paul@@codesourcery.com>

	* elflink.c (elf_link_input_bfd): Ignore symbols from null input
	sections.
@
text
@d4898 1
a4898 1
	  if (inputobj->flags & DYNAMIC)
@


1.130
log
@	* elflink.c (elf_link_add_object_symbols): Don't add "warning: "
	prefix here.
@
text
@d6785 2
a6786 2
	  && isec != NULL
	  && ((! isec->linker_mark && (isec->flags & SEC_HAS_CONTENTS) != 0)
@


1.129
log
@bfd/
	* elflink.c (bfd_elf_record_link_assignment): Do "provide" symbol
	lookup here.  Set to new before calling bfd_link_repair_undef_list.
	(elf_smash_syms): Check that u.undef.weak isn't the not_needed bfd.
ld/
	emultempl/elf32.em (gld${EMULATION_NAME}_find_exp_assignment): Don't
	look up symbol for etree_provide here.
@
text
@a3144 2
	      bfd_size_type prefix_len;
	      const char * gnu_warning_prefix = _("warning: ");
d3178 1
a3178 2
	      prefix_len = strlen (gnu_warning_prefix);
	      msg = bfd_alloc (abfd, prefix_len + sz + 1);
d3182 1
a3182 2
	      strcpy (msg, gnu_warning_prefix);
	      if (! bfd_get_section_contents (abfd, s, msg + prefix_len, 0, sz))
d3185 1
a3185 1
	      msg[prefix_len + sz] = '\0';
@


1.128
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Add u.undef.weak.
bfd/
	* linker.c (_bfd_generic_link_add_one_symbol): Set u.undef.weak.
	* elflink.c (elf_smash_syms): Restore symbols that were undefweak
	before the as-needed lib was loaded.  Abort on unexpected refs.
@
text
@d443 1
d448 2
a449 1
  h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, TRUE, FALSE);
d451 1
a451 1
    return FALSE;
d459 1
a459 2
      struct elf_link_hash_table *htab = elf_hash_table (info);

a461 1
      h->root.type = bfd_link_hash_new;
d2847 2
a2848 1
      if (h->root.u.undef.weak != NULL)
@


1.127
log
@	* elflink.c (elf_smash_syms): Expand comments.
	(elf_link_add_object_symbols): Only call elf_smash_syms for
	as-needed dynamic objects.
@
text
@d2845 15
d2886 5
@


1.126
log
@include/
	* bfdlink.h (bfd_link_repair_undef_list): Declare.
bfd/
	* elf64-ppc.c (ppc64_elf_check_directives): Move undefs list fixup..
	* linker.c (bfd_link_repair_undef_list): ..to new function, but don't
	remove anything but new and undefweak.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Override any
	existing _DYNAMIC.
	(_bfd_elf_create_dynamic_sections): Formatting.
	(bfd_elf_record_link_assignment): Call bfd_link_repair_undef_list.
	(_bfd_elf_merge_symbol): Don't handle as-needed syms here.
	(struct elf_smash_data): New.
	(elf_smash_syms): New function.
	(elf_link_add_object_symbols): Call elf_smash_syms.  Don't add
	unneeded dynamic objects to loaded list.
	(elf_link_output_extsym): Don't handle as-needed here.  Strip
	bfd_link_hash_new symbols.
	* elf32-cris.c (elf_cris_discard_excess_program_dynamics): Don't
	delref when dynindx is already -1.
	* elf64-alpha.c (elf64_alpha_output_extsym): Strip bfd_link_hash_new
	symbols.
	* elfxx-mips.c (mips_elf_output_extsym): Likewise.
ld/
	* ld.texinfo: Clarify --as-needed operation.
@
text
@d2818 6
a2823 1
   references to these symbols.  */
d4102 2
a4103 1
  if (!add_needed)
d4105 2
@


1.125
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d213 16
a228 8
     .dynamic section.  This call occurs before we have processed the
     symbols for any dynamic object, so we don't have to worry about
     overriding a dynamic definition.  We could set _DYNAMIC in a
     linker script, but we only want to define it if we are, in fact,
     creating a .dynamic section.  We don't want to define it if there
     is no .dynamic section, since on some ELF platforms the start up
     code examines it to decide how to initialize the process.  */
  bh = NULL;
d333 10
a342 10
     normally needed.  We need to create it here, though, so that the
     linker will map it to an output section.  We can't just create it
     only if we need it, because we will not know whether we need it
     until we have seen all the input files, and the first time the
     main linker code calls BFD after examining all the input files
     (size_dynamic_sections) the input sections have already been
     mapped to the output sections.  If the section turns out not to
     be needed, we can discard it later.  We will never need this
     section when generating a shared object, since they do not use
     copy relocs.  */
d453 1
a453 6
     may depend on this.
     ??? Changing bfd_link_hash_undefined to bfd_link_hash_new (or
     to bfd_link_hash_undefweak, see linker.c:link_action) runs the risk
     of some later symbol manipulation setting the symbol back to
     bfd_link_hash_undefined, and the linker trying to add the symbol to
     the undefs list twice.  */
d456 7
a462 1
    h->root.type = bfd_link_hash_new;
d740 1
a740 1
  bfd_boolean newweak, oldweak, old_asneeded;
a869 8
  /* If the old definition came from an as-needed dynamic library which
     wasn't found to be needed, treat the sym as undefined.  */
  old_asneeded = FALSE;
  if (newdyn
      && olddyn
      && (elf_dyn_lib_class (oldbfd) & DYN_AS_NEEDED) != 0)
    old_asneeded = TRUE;

a1071 1
      && !old_asneeded
d1123 1
a1123 1
      && ((olddef && !old_asneeded)
d1173 1
a1173 1
  if ((!newdyn || old_asneeded)
d2816 63
d4097 12
d4341 1
a4341 1
  if (is_elf_hash_table (hash_table))
a6247 1
      && (elf_dyn_lib_class (h->root.u.undef.abfd) & DYN_AS_NEEDED) == 0
d6289 2
a6290 1
	    || h->ref_dynamic)
@


1.124
log
@bfd/
	* elflink.c (elf_link_add_object_symbols): Don't create link dynamic
	sections immediately when linking shared libs.  Instead, wait until
	we know a lib is needed.
	(_bfd_elf_link_create_dynstrtab): Extract from..
	(_bfd_elf_link_create_dynamic_sections_): ..here.
	(elf_add_dt_needed_tag): Call _bfd_elf_link_create_dynstrtab and
	_bfd_elf_link_create_dynamic_sections.  Add abfd param.  Allow
	for non-existent .dynamic.
	(elf_link_output_extsym): Don't complain about undefined symbols
	in as-needed dynamic libs that aren't actually linked.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Formatting.
	(gld${EMULATION_NAME}_after_open): Ignore needed libs if they were
	only needed by an as-needed lib that didn't get linked.
@
text
@a7832 16
#if 0
  /* Some standard ELF linkers do this, but we don't because it causes
     bootstrap comparison failures.  */
  /* Output a file symbol for the output file as the second symbol.
     We output this even if we are discarding local symbols, although
     I'm not sure if this is correct.  */
  elfsym.st_value = 0;
  elfsym.st_size = 0;
  elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
  elfsym.st_other = 0;
  elfsym.st_shndx = SHN_ABS;
  if (! elf_link_output_sym (&finfo, bfd_get_filename (abfd),
			     &elfsym, bfd_abs_section_ptr, NULL))
    goto error_return;
#endif

@


1.123
log
@2005-01-19  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 679
	* elflink.c (_bfd_elf_dynamic_symbol_p): Only protected
	non-function symbols are local.
	(_bfd_elf_symbol_refs_local_p): Likewise.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d106 19
d147 2
a148 5
  /* Make sure that all dynamic sections use the same input BFD.  */
  if (elf_hash_table (info)->dynobj == NULL)
    elf_hash_table (info)->dynobj = abfd;
  else
    abfd = elf_hash_table (info)->dynobj;
d150 1
a205 8
  /* Create a strtab to hold the dynamic symbol names.  */
  if (elf_hash_table (info)->dynstr == NULL)
    {
      elf_hash_table (info)->dynstr = _bfd_elf_strtab_init ();
      if (elf_hash_table (info)->dynstr == NULL)
	return FALSE;
    }

d2758 2
a2759 1
elf_add_dt_needed_tag (struct bfd_link_info *info,
d2767 3
d2784 6
a2789 1
      BFD_ASSERT (sdyn != NULL);
d2791 8
a2798 14
      for (extdyn = sdyn->contents;
	   extdyn < sdyn->contents + sdyn->size;
	   extdyn += bed->s->sizeof_dyn)
	{
	  Elf_Internal_Dyn dyn;

	  bed->s->swap_dyn_in (hash_table->dynobj, extdyn, &dyn);
	  if (dyn.d_tag == DT_NEEDED
	      && dyn.d_un.d_val == strindex)
	    {
	      _bfd_elf_strtab_delref (hash_table->dynstr, strindex);
	      return 1;
	    }
	}
d2803 3
a3299 5
      /* If this is the first dynamic object found in the link, create
	 the special sections required for dynamic linking.  */
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	goto error_return;

d3316 1
a3316 1
      ret = elf_add_dt_needed_tag (info, soname, add_needed);
d3966 1
a3966 1
	      ret = elf_add_dt_needed_tag (info, soname, add_needed);
d6173 1
@


1.122
log
@	* elflink.c (_bfd_elf_merge_symbol): Treat old definitions from
	as-needed dynamic libs as undefined.
	(elf_link_add_object_symbols): Remove DYN_AS_NEEDED from as-needed
	libs when finding they are needed.
@
text
@d2482 1
a2482 1
      if (!ignore_protected)
d2545 4
@


1.121
log
@	* elf.c (bfd_elf_sym_name): Add symtab_hdr param.
	(group_signature): Update call.
	* elf-bfd.h (bfd_elf_sym_name): Update.
	* elf32-ppc.c (ppc_elf_relocate_section): Update.
	* elf64-ppc.c (ppc64_elf_edit_opd, ppc64_elf_edit_toc)
	(ppc64_elf_relocate_section): Update
	* elflink.c (elf_link_input_bfd): Update.
@
text
@d722 1
a722 1
  bfd_boolean newweak, oldweak;
d852 8
d1062 1
d1114 1
a1114 1
      && (olddef
d1164 1
a1164 1
  if (! newdyn
d3949 2
@


1.120
log
@	* elf.c (bfd_elf_sym_name): Rename from bfd_elf_local_sym_name.
	(group_signature): Update calls.
	* elf-bfd.h (bfd_elf_sym_name): Update.
	* elf32-ppc.c (ppc_elf_relocate_section): Update.
	* elf64-ppc.c (ppc64_elf_edit_opd, ppc64_elf_edit_toc)
	(ppc64_elf_relocate_section): Update
	* elflink.c (elf_link_input_bfd): Update.
@
text
@d6822 1
a6822 1
		      sym_name = bfd_elf_sym_name (input_bfd, sym);
@


1.119
log
@2004-12-01  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elflink.c (elf_link_add_object_symbols): Make symbols from discarded
	sections undefined.
ld/testsuite/
	* ld-elf/group1.d: New test.
	* ld-elf/group.ld, ld-elf/group1a.s, ld-elf/group1b.s: New test.
@
text
@d6822 1
a6822 1
		      sym_name = bfd_elf_local_sym_name (input_bfd, sym);
@


1.118
log
@bfd/
	* elf-bfd.h (_bfd_elf_slurp_version_tables): Update prototype.
	* elf.c (_bfd_elf_print_private_bfd_data): Pass extra argument.
	(_bfd_elf_slurp_version_tables): Add extra argument.  Create extra
	default version definition for unversioned symbols.
	* elfcode.h (elf_slurp_symbol_table): Pass extra argument.
	* elflink.c (elf_link_add_object_symbols): Pass extra argument to
	_bfd_elf_slurp_version_tables.  Set default version for unversioned
	imported symbols.
include/
	* bfdlink.h (bfd_link_info): Add default_imported_symver.
ld/
	* ld.texinfo: Document --default-imported-symver.
	* ldmain.c (main): Set link_info.default_imported_symver.
	* lexsup.c (option_values): Add OPTION_DEFAULT_IMPORTED_SYMVER.
	(ld_options): Add --default-imported-symver.
	(parse_args): Handle OPTION_DEFAULT_IMPORTED_SYMVER.
@
text
@d3428 6
@


1.117
log
@	* elflink.c (elf_link_add_object_symbols): Don't assume version
	indices are consecutive.
@
text
@d3350 2
a3351 1
      if (! _bfd_elf_slurp_version_tables (abfd))
d3503 1
a3503 1
	  if (ever != NULL)
d3505 8
a3512 2
	      _bfd_elf_swap_versym_in (abfd, ever, &iver);
	      vernum = iver.vs_vers & VERSYM_VERSION;
d3514 15
a3528 7
	      /* If this is a hidden symbol, or if it is not version
		 1, we append the version name to the symbol name.
		 However, we do not modify a non-hidden absolute
		 symbol, because it might be the version symbol
		 itself.  FIXME: What if it isn't?  */
	      if ((iver.vs_vers & VERSYM_HIDDEN) != 0
		  || (vernum > 1 && ! bfd_is_abs_section (sec)))
d3530 7
a3536 3
		  const char *verstr;
		  size_t namelen, verlen, newlen;
		  char *newname, *p;
d3538 1
a3538 1
		  if (isym->st_shndx != SHN_UNDEF)
d3540 6
a3545 17
		      if (vernum > elf_tdata (abfd)->cverdefs)
			verstr = NULL;
		      else if (vernum > 1)
			verstr =
			  elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;
		      else
			verstr = "";

		      if (verstr == NULL)
			{
			  (*_bfd_error_handler)
			    (_("%B: %s: invalid version %u (max %d)"),
			     abfd, name, vernum,
			     elf_tdata (abfd)->cverdefs);
			  bfd_set_error (bfd_error_bad_value);
			  goto error_free_vers;
			}
d3547 13
a3559 1
		  else
d3561 3
a3563 10
		      /* We cannot simply test for the number of
			 entries in the VERNEED section since the
			 numbers for the needed versions do not start
			 at 0.  */
		      Elf_Internal_Verneed *t;

		      verstr = NULL;
		      for (t = elf_tdata (abfd)->verref;
			   t != NULL;
			   t = t->vn_nextref)
d3565 1
a3565 3
			  Elf_Internal_Vernaux *a;

			  for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
d3567 2
a3568 5
			      if (a->vna_other == vernum)
				{
				  verstr = a->vna_nodename;
				  break;
				}
a3569 10
			  if (a != NULL)
			    break;
			}
		      if (verstr == NULL)
			{
			  (*_bfd_error_handler)
			    (_("%B: %s: invalid needed version %d"),
			     abfd, name, vernum);
			  bfd_set_error (bfd_error_bad_value);
			  goto error_free_vers;
d3571 10
d3582 1
d3584 6
a3589 6
		  namelen = strlen (name);
		  verlen = strlen (verstr);
		  newlen = namelen + verlen + 2;
		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
		      && isym->st_shndx != SHN_UNDEF)
		    ++newlen;
d3591 13
a3603 13
		  newname = bfd_alloc (abfd, newlen);
		  if (newname == NULL)
		    goto error_free_vers;
		  memcpy (newname, name, namelen);
		  p = newname + namelen;
		  *p++ = ELF_VER_CHR;
		  /* If this is a defined non-hidden version symbol,
		     we add another @@ to the name.  This indicates the
		     default version of the symbol.  */
		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
		      && isym->st_shndx != SHN_UNDEF)
		    *p++ = ELF_VER_CHR;
		  memcpy (p, verstr, verlen + 1);
d3605 1
a3605 2
		  name = newname;
		}
@


1.116
log
@	* elflink.c (_bfd_elf_create_got_section): Hide _GLOBAL_OFFSET_SYMBOL.
@
text
@d3521 9
a3529 1
		      if (vernum > elf_tdata (abfd)->dynverdef_hdr.sh_info)
d3534 1
a3534 1
			     elf_tdata (abfd)->dynverdef_hdr.sh_info);
a3537 5
		      else if (vernum > 1)
			verstr =
			  elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;
		      else
			verstr = "";
@


1.115
log
@bfd/
	* elflink.c (elf_finalize_dynstr): Skip shared aux structure.
	(bfd_elf_size_dynamic_sections): Create default version definition.
	(elf_link_output_extsym): Adjust for default symbol version.
include/
	* bfdlink.h (struct bfd_link_info): Add create_default_symver.
ld/
	* ld.texinfo: Document --default-symver.
	* ldmain.c (main): Set link_info.create_default_symver.
	* lexsup.c (enum option_values): Add OPTION_DEFAULT_SYMVER.
	(ld_options): Add default-symver.
	(parse_args): Handle OPTION_DEFAULT_SYMVER.
ld/testsuite/
	* ld-elfvers/vers.exp (build_binary): Add ldargs parameter.
	(build_vers_lib_pic_flags): New function.
	Add vers29 test.
	* ld-elfvers/vers29.c: New file.
	* ld-elfvers/vers29.dsym: New file.
	* ld-elfvers/vers29.ver: New file.
@
text
@d91 1
@


1.114
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2898 2
d5094 1
a5094 1
      if (verdefs == NULL)
d5104 3
d5116 7
d5148 11
a5158 3
	  def.vd_aux = sizeof (Elf_External_Verdef);
	  def.vd_next = (sizeof (Elf_External_Verdef)
			 + sizeof (Elf_External_Verdaux));
d5166 1
a5169 1
	      const char *name;
d5185 32
a5224 2
	      struct elf_link_hash_entry *h;
	      struct bfd_link_hash_entry *bh;
d5252 1
a5252 1
	      def.vd_ndx = t->vernum + 1;
d5449 2
a5450 1
	  || (verdefs == NULL && elf_tdata (output_bfd)->verref == NULL))
d6388 2
@


1.113
log
@	* elfarm-nabi.c (ELF_DYNAMIC_SEC_FLAGS): Add comment.
	* elflink.c (_bfd_elf_create_dynamic_sections): For a loaded PLT,
	set SEC_ALLOC and SEC_LOAD.
@
text
@d7219 2
a7220 1
		 (info, sym_name, howto->name, addend, NULL, NULL, 0)))
@


1.112
log
@bfd/
	* bfd-in2.h: Regenerate.
	* bfd.c (struct bfd): Add no_export.
	* elflink.c (elf_link_add_object_symbols): Handle no_export.
ld/
	* ldlang.c (struct excluded_lib, excluded_libs, add_excluded_libs)
	(check_excluded_libs): New.
	(load_symbols): Call check_excluded_libs.
	* ldlang.h (add_excluded_libs): New prototype.
	* emultempl/elf32.em (OPTION_EXCLUDED_LIBS): Define.
	(gld${EMULATION_NAME}_add_options): Add --exclude-libs.
	(gld${EMULATION_NAME}_handle_option): Handle --exclude-libs.
	* ld.texinfo (Command Line Variables): Document --exclude-libs.
	(Options Specific to i386 PE Targets): Remove --exclude-libs.
ld/testsuite/
	* ld-elf/exclude1.s, ld-elf/exclude2.s, ld-elf/exclude.exp: New.
@
text
@a254 1
  pltflags |= SEC_CODE;
d256 3
d260 2
@


1.111
log
@	* elflink.c (struct already_linked_section): Removed.
	(try_match_symbols_in_sections, already_linked): Removed.
	(_bfd_elf_section_already_linked): Skip ^\.gnu\.linkonce\.[^.]*\.
	prefix of section names when finding already_linked_table
	chain.  Compare section names.  Instead of calling already_linked,
	do it inline and only for sections in the same already_linked_list.
@
text
@d3781 8
@


1.110
log
@	* elflink.c (enum action_discarded): New.
	(elf_section_complain_discarded): Delete.
	(elf_action_discarded): New function subsuming the above and also
	controlling reloc behaviour.
	(elf_link_input_bfd): Use it.
@
text
@a9270 77
struct already_linked_section
{
  asection *sec;
  asection *linked;
};

/* Check if the member of a single member comdat group matches a
   linkonce section and vice versa.  */
static bfd_boolean
try_match_symbols_in_sections
  (struct bfd_section_already_linked_hash_entry *h, void *info)
{
  struct bfd_section_already_linked *l;
  struct already_linked_section *s
    = (struct already_linked_section *) info;

  if (elf_sec_group (s->sec) == NULL)
    {
      /* It is a linkonce section. Try to match it with the member of a
	 single member comdat group. */
      for (l = h->entry; l != NULL; l = l->next)
	if ((l->sec->flags & SEC_GROUP))
	  {
	    asection *first = elf_next_in_group (l->sec);

	    if (first != NULL
		&& elf_next_in_group (first) == first
		&& bfd_elf_match_symbols_in_sections (first, s->sec))
	      {
		s->linked = first;
		return FALSE;
	      }
	  }
    }
  else
    {
      /* It is the member of a single member comdat group. Try to match
	 it with a linkonce section.  */
      for (l = h->entry; l != NULL; l = l->next)
	if ((l->sec->flags & SEC_GROUP) == 0
	    && bfd_coff_get_comdat_section (l->sec->owner, l->sec) == NULL
	    && bfd_elf_match_symbols_in_sections (l->sec, s->sec))
	  {
	    s->linked = l->sec;
	    return FALSE;
	  }
    }

  return TRUE;
}

static bfd_boolean
already_linked (asection *sec, asection *group)
{
  struct already_linked_section result;

  result.sec = sec;
  result.linked = NULL;

  bfd_section_already_linked_table_traverse
    (try_match_symbols_in_sections, &result);

  if (result.linked)
    {
      sec->output_section = bfd_abs_section_ptr;
      sec->kept_section = result.linked;

      /* Also discard the group section.  */
      if (group)
	group->output_section = bfd_abs_section_ptr;

      return TRUE;
    }

  return FALSE;
}

d9275 1
a9275 1
  const char *name;
d9325 7
a9331 1
  already_linked_list = bfd_section_already_linked_table_lookup (name);
d9341 1
d9345 1
a9345 1
             issue a warning.  */
d9434 12
a9445 1
      if (! already_linked (elf_next_in_group (sec), group))
d9452 15
a9466 2
    already_linked (sec, group);
  
@


1.109
log
@	PR 233
	* elflink.c (elf_link_input_bfd): Try harder to support
	relocations against symbols in removed linkonce sections.
@
text
@d6377 14
a6390 2
/* Return TRUE if we should complain about a reloc in SEC against a
   symbol defined in a discarded section.  */
d6392 2
a6393 2
static bfd_boolean
elf_section_complain_discarded (asection *sec)
d6395 2
a6396 4
  if (strncmp (".stab", sec->name, 5) == 0
      && (!sec->name[5] ||
	  (sec->name[5] == '.' && ISDIGIT (sec->name[6]))))
    return FALSE;
d6399 1
a6399 1
    return FALSE;
d6402 1
a6402 1
    return FALSE;
d6405 1
a6405 1
    return FALSE;
d6408 1
a6408 1
    return FALSE;
d6410 1
a6410 1
  return TRUE;
d6705 1
a6705 1
	      bfd_boolean complain = elf_section_complain_discarded (o);
d6749 1
a6749 1
		      if (complain && (o->flags & SEC_DEBUGGING) == 0)
d6769 1
a6769 3
		      if (kept != NULL
			  && (complain
			      || (o->flags & SEC_DEBUGGING) != 0))
@


1.108
log
@	* elflink.c (elf_link_input_bfd): Revert PR 354 change.
@
text
@d6736 1
a6736 19
		      if ((o->flags & SEC_DEBUGGING) != 0)
			{
			  BFD_ASSERT (r_symndx != 0);

			  /* Try to preserve debug information.
			     FIXME: This is quite broken.  Modifying
			     the symbol here means we will be changing
			     all uses of the symbol, not just those in
			     debug sections.  The only thing that makes
			     this half reasonable is that debug sections
			     tend to come after other sections.  Of
			     course, that doesn't help with globals.
			     ??? All link-once sections of the same name
			     ought to define the same set of symbols, so
			     it would seem that globals ought to always
			     be defined in the kept section.  */
			  if (sec->kept_section != NULL)
			    {
			      asection *member;
d6738 2
a6739 18
			      /* Check if it is a linkonce section or
				 member of a comdat group.  */
			      if (elf_sec_group (sec) == NULL
				  && sec->size == sec->kept_section->size)
				{
				  *ps = sec->kept_section;
				  continue;
				}
			      else if (elf_sec_group (sec) != NULL
				       && (member = match_group_member (sec, sec->kept_section))
				       && sec->size == member->size)
				{
				  *ps = member;
				  continue;
				}
			    }
			}
		      else if (complain)
d6747 26
@


1.107
log
@	PR 354
	* elflink.c (elf_link_input_bfd): Check that relocs in SEC_ALLOC
	sections do not reference symbols in non-SEC_ALLOC sections.
@
text
@a6790 15

		  /* Check that loaded segments don't reference symbols
		     in non-loaded segments.  */
		  if ((o->flags & SEC_ALLOC) != 0
		      && sec != NULL
		      && !bfd_is_abs_section (sec)
		      && !elf_discarded_section (sec)
		      && sec->output_section != NULL
		      && (sec->output_section->flags & SEC_ALLOC) == 0)
		    {
		      (*_bfd_error_handler)
			(_("`%s' referenced in section `%A' of %B: "
			   "defined in non-loaded section `%A' of %B\n"),
			 o, input_bfd, sec, sec->owner, sym_name);
		    }
@


1.106
log
@	PR 437
	* elflink.c (elf_link_sort_relocs): Don't bomb on unusual sections.
	(_bfd_elf_link_omit_section_dynsym): Formatting.
@
text
@d6791 15
@


1.105
log
@Add linker option: --warn-shared-textrel to produce warnings when adding a
DT_TEXTREL to a shared object.
@
text
@d632 1
a632 2
	      && (ip = bfd_get_section_by_name (dynobj, p->name))
	      != NULL
d5714 8
@


1.104
log
@2004-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 414
	* elflink.c (_bfd_elf_merge_symbol): Check TLS symbol.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d2704 4
@


1.103
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d712 1
a712 1
  asection *sec;
d756 2
a757 1
  /* OLDBFD is a BFD associated with the existing symbol.  */
d763 1
d769 1
d775 1
d780 1
d848 48
@


1.102
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d475 2
a476 2
      if (h->weakdef != NULL
	  && h->weakdef->dynindx == -1)
d478 1
a478 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
d893 1
a893 1
      if ((h->root.und_next || info->hash->undefs_tail == &h->root)
d899 1
a899 1
	     up the linker hash table undefs list. Since the old
a902 1
	  /* FIXME: What if the new symbol is weak undefined?  */
d2195 1
a2195 1
  if (h->weakdef != NULL)
d2199 1
a2199 1
      weakdef = h->weakdef;
d2213 1
a2213 1
	h->weakdef = NULL;
d2270 1
a2270 1
	      && (h->weakdef == NULL || h->weakdef->dynindx == -1))))
d2315 1
a2315 1
  if (h->weakdef != NULL)
d2320 2
a2321 2
	 H->WEAKDEF before it finds H?  */
      h->weakdef->ref_regular = 1;
d2323 1
a2323 1
      if (! _bfd_elf_adjust_dynamic_symbol (h->weakdef, eif))
d3596 1
a3596 1
	  && h->weakdef == NULL)
d3610 1
a3610 1
	  h->weakdef = weaks;
d3775 1
a3775 1
		  || (h->weakdef != NULL
d3777 1
a3777 1
		      && h->weakdef->dynindx != -1))
d3810 1
a3810 1
	      if (h->weakdef != NULL
d3812 1
a3812 1
		  && h->weakdef->dynindx == -1)
d3814 1
a3814 1
		  if (! bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
d3979 2
a3980 2
	  weaks = hlook->weakdef;
	  hlook->weakdef = NULL;
d4031 1
a4031 1
		  hlook->weakdef = h;
d4474 1
a4474 1
  h->elf_hash_value = ha;
d6232 1
a6232 1
      bucket = h->elf_hash_value % bucketcount;
d8567 1
a8567 1
  if (h->vtable_parent == NULL)
d8571 1
a8571 1
  if (h->vtable_parent == (struct elf_link_hash_entry *) -1)
d8575 1
a8575 1
  if (h->vtable_entries_used && h->vtable_entries_used[-1])
d8579 1
a8579 1
  elf_gc_propagate_vtable_entries_used (h->vtable_parent, okp);
d8581 1
a8581 1
  if (h->vtable_entries_used == NULL)
d8585 2
a8586 2
      h->vtable_entries_used = h->vtable_parent->vtable_entries_used;
      h->vtable_entries_size = h->vtable_parent->vtable_entries_size;
d8594 1
a8594 1
      cu = h->vtable_entries_used;
d8596 1
a8596 1
      pu = h->vtable_parent->vtable_entries_used;
d8604 1
a8604 1
	  n = h->vtable_parent->vtable_entries_size >> log_file_align;
d8632 1
a8632 1
  if (h->vtable_parent == NULL)
d8654 2
a8655 2
	if (h->vtable_entries_used
	    && (rel->r_offset - hstart) < h->vtable_entries_size)
d8658 1
a8658 1
	    if (h->vtable_entries_used[entry])
d8801 6
d8814 1
a8814 1
      child->vtable_parent = (struct elf_link_hash_entry *) -1;
d8817 1
a8817 1
    child->vtable_parent = h;
d8833 8
a8840 1
  if (addend >= h->vtable_entries_size)
d8843 1
a8843 1
      bfd_boolean *ptr = h->vtable_entries_used;
d8874 1
a8874 1
	      oldbytes = (((h->vtable_entries_size >> log_file_align) + 1)
d8886 2
a8887 2
      h->vtable_entries_used = ptr + 1;
      h->vtable_entries_size = size;
d8890 1
a8890 1
  h->vtable_entries_used[addend >> log_file_align] = TRUE;
@


1.101
log
@	* elf64-ppc.c (struct ppc_link_hash_table): Add stub_globals.
	(is_ppc64_elf_target): Rename from is_ppc64_target.  Update all
	callers.
	(ppc_stub_name): Remove trailing "+0" on stub name.
	(create_linkage_sections): Create relocations for
	branch lookup table when --emit-relocs as well as when --shared.
	(ppc_build_one_stub): Emit relocs for long branch stubs.  Adjust
	relbrlt test.  For --emit-stub-syms, always output a sym even when
	one already exists on a plt call stub.  Put stub type in the stub
	symbol name.
	(ppc_size_one_stub): Size long branch stub relocs.  Adjust relbrlt
	test.
	(ppc64_elf_size_stubs): Count global sym stubs added.  Zero
	reloc_count in stub sections.  Adjust relbrlt test.
	(ppc64_elf_build_stubs): Adjust relbrlt test.  Tweak stats output.
	* elflink.c (bfd_elf_size_dynamic_sections): Fix comment typo.
	(elf_link_input_bfd): Ignore symbol index zero relocs when checking
	for relocs against discarded symbols.  Fix comments.
@
text
@d89 1
a89 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d216 1
a216 1
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d279 1
a279 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d366 1
a366 1
	      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
d442 1
a442 1
    h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
d449 2
a450 2
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d458 2
a459 2
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d462 1
a462 1
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d464 2
a465 2
  if (((h->elf_link_hash_flags & (ELF_LINK_HASH_DEF_DYNAMIC
				  | ELF_LINK_HASH_REF_DYNAMIC)) != 0
d752 1
a752 1
      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d787 1
a787 1
	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
d846 1
a846 1
  if (newdyn && (h->elf_link_hash_flags & ELF_LINK_DYNAMIC_DEF) == 0)
d849 1
a849 1
	h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_DEF;
d855 1
a855 1
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
d858 1
a858 1
		h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_WEAK;
d861 1
a861 1
	    h->elf_link_hash_flags &= ~ELF_LINK_DYNAMIC_WEAK;
d873 1
a873 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
d885 1
a885 1
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
d912 1
a912 1
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
d914 3
a916 3
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_DYNAMIC
				     | ELF_LINK_DYNAMIC_DEF);
d999 1
a999 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
d1106 1
a1106 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
d1188 1
a1188 1
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
d1190 2
a1191 2
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  flip->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
d1314 1
a1314 1
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
d1316 4
a1319 5
	  h->elf_link_hash_flags &=~ ELF_LINK_HASH_DEF_DYNAMIC;
	  hi->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	  if (hi->elf_link_hash_flags
	      & (ELF_LINK_HASH_REF_REGULAR
		 | ELF_LINK_HASH_DEF_REGULAR))
d1349 1
a1349 2
		  || ((hi->elf_link_hash_flags
		       & ELF_LINK_HASH_REF_DYNAMIC) != 0))
d1354 1
a1354 2
	      if ((hi->elf_link_hash_flags
		   & ELF_LINK_HASH_REF_REGULAR) != 0)
d1418 1
a1418 2
		      || ((hi->elf_link_hash_flags
			   & ELF_LINK_HASH_REF_DYNAMIC) != 0))
d1423 1
a1423 2
		  if ((hi->elf_link_hash_flags
		       & ELF_LINK_HASH_REF_REGULAR) != 0)
d1449 2
a1450 2
      && (h->elf_link_hash_flags
	  & (ELF_LINK_HASH_DEF_REGULAR | ELF_LINK_HASH_REF_REGULAR)) != 0)
d1505 2
a1506 2
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
d1596 1
a1596 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1621 1
a1621 1
	    h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
d1716 1
a1716 1
	h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
d2094 1
a2094 1
  if ((h->elf_link_hash_flags & ELF_LINK_NON_ELF) != 0)
d2101 4
a2104 2
	h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
d2110 4
a2113 2
	    h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
				       | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
d2115 1
a2115 1
	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d2119 2
a2120 2
	  && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	      || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0))
d2131 1
a2131 1
      /* Unfortunately, ELF_LINK_NON_ELF is only correct if the symbol
d2139 1
a2139 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
d2144 2
a2145 3
		 && (h->elf_link_hash_flags
		     & ELF_LINK_HASH_DEF_DYNAMIC) == 0)))
	h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d2151 1
a2151 1
     the symbol in a common section but the ELF_LINK_HASH_DEF_REGULAR
d2154 3
a2156 3
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
d2158 1
a2158 1
    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d2166 1
a2166 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0
d2171 1
a2171 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
d2208 1
a2208 1
      BFD_ASSERT (weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC);
d2213 1
a2213 1
      if ((weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
d2267 4
a2270 4
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0
      && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  || ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
d2279 1
a2279 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
d2286 1
a2286 1
  h->elf_link_hash_flags |= ELF_LINK_HASH_DYNAMIC_ADJUSTED;
d2322 1
a2322 1
      h->weakdef->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
d2335 1
a2335 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
d2400 1
a2400 1
  if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d2426 1
a2426 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2454 1
a2454 1
  else if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2458 1
a2458 1
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
a3633 1
	  int old_flags;
a3634 1
	  int new_flag;
a3751 1
	  old_flags = h->elf_link_hash_flags;
d3757 1
a3757 1
		  new_flag = ELF_LINK_HASH_REF_REGULAR;
d3759 1
a3759 1
		    new_flag |= ELF_LINK_HASH_REF_REGULAR_NONWEAK;
d3762 1
a3762 1
		new_flag = ELF_LINK_HASH_DEF_REGULAR;
d3764 2
a3765 2
		  || (old_flags & (ELF_LINK_HASH_DEF_DYNAMIC
				   | ELF_LINK_HASH_REF_DYNAMIC)) != 0)
d3771 1
a3771 1
		new_flag = ELF_LINK_HASH_REF_DYNAMIC;
d3773 3
a3775 3
		new_flag = ELF_LINK_HASH_DEF_DYNAMIC;
	      if ((old_flags & (ELF_LINK_HASH_DEF_REGULAR
				| ELF_LINK_HASH_REF_REGULAR)) != 0
a3781 2
	  h->elf_link_hash_flags |= new_flag;

d3835 1
a3835 2
	      && (h->elf_link_hash_flags
		  & ELF_LINK_HASH_REF_REGULAR) != 0)
d4860 1
a4860 2
		  && ((newh->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
d4919 2
a4920 2
	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
d4931 2
a4932 2
	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
d5121 2
a5122 2
	      h->elf_link_hash_flags &= ~ ELF_LINK_NON_ELF;
	      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d5986 1
a5986 1
      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d5991 1
a5991 1
      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
d6002 2
a6003 2
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
d6020 4
a6023 3
      && (h->elf_link_hash_flags
	  & (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC | ELF_LINK_DYNAMIC_DEF | ELF_LINK_DYNAMIC_WEAK))
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC)
d6044 4
a6047 4
  else if (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	    || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
d6067 1
a6067 1
      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d6073 1
a6073 1
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
d6160 1
a6160 1
       || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
d6164 1
a6164 1
	  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d6182 1
a6182 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
d6188 1
a6188 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK) != 0)
d6201 1
a6201 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d6249 1
a6249 1
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d6264 1
a6264 1
	  if ((h->elf_link_hash_flags & ELF_LINK_HIDDEN) != 0)
d8681 1
a8681 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC))
@


1.100
log
@(elf_link_add_object_symbols): Set the error code to bfd_error_wrong_format when
the input format does not match the output format.
@
text
@d4917 1
a4917 1
	 values later, in elf_bfd_final_link, but we must add the entries
d6651 3
d6846 1
a6846 1
			 set at the end of elf_bfd_final_link.  */
d7586 1
a7586 2
  /* That created the reloc sections.  Set their sizes, and assign
     them file positions, and allocate some buffers.  */
@


1.99
log
@	* config.bfd (arm*-*-symbianelf*): Use OS-specific target vectors.
	* configure.in (bfd_elf32_bigarm_symbian_vec): Add it.
	(bfd_elf32_littlearm_symbian_vec): Likewise.
	* configure: Regenerated.
	* elf-bfd.h (elf_backend_data): Add dynamic_sec_flags.
	* elf32-arm.h (PLT_HEADER_SIZE): Do not define.
	(PLT_ENTRY_SIZE): Likewise.
	(bfd_vma_elf32_arm_symbian_plt_entry): New
	variable.
	(elf32_arm_link_hash_table): Add plt_header_size, plt_entry_size,
	and symbian_p.
	(create_got_section): Don't create sections when generating BPABI
	objects.
	(elf32_arm_create_dynamic_sections): Tidy.
	(elf32_arm_link_hash_table_create): Set plt_header_size,
	plt_entry_size, and symbian_p.
	(elf32_arm_check_relocs): Do not mark .rel.dyn as loadable when
	generating BPABI objects.
	(allocate_dynrelocs): Use htab->plt_header_size, not
	PLT_HEADER_SIZE.  Do not add to .got.plt when
	generating BPABI objects.
	(elf32_arm_finish_dynamic_symbol): Generate Symbian OS PLTs.
	* elfarm-nabi.c: Add SymbianOS target vectors.
	* elflink.c (_bfd_elf_create_got_section): Use dynamic_sec_flags.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	* elfxx-target.h (ELF_DYNAMIC_SEC_FLAGS): New macro.
	(elfNN_bed): Use it.
	* targets.c (bfd_elf32_bigarm_symbian_vec): New variable.
	(bfd_elf32_littlearm_symbian_vec): Likewise.
	(_bfd_target_vector): Add them.

	* Makefile.am (TARG_ENV_HFILES): Add te-symbian.h.
	* Makefile.in: Regenerated.
	* configure.in: Set em for arm*-*-symbianelf*.
	* configure: Regenerated.
	* config/tc-arm.c (elf32_arm_target_format): Use Symbian target
	vectors when appropriate.
	* config/te-symbian.h: New file.

	* Makefile.am (ALL_EMULATIONS): Add earmsymbian.o.
	(earmsymbian.c): New target.
	* configure.tgt: Use armsymbian emulation for arm*-*-symbianelf*.
	* Makefile.in: Regenerated.
	* aclocal.m4: Likewise.
	* configure: Likewise.
	* emulparams/armsymbian.sh: New file.
@
text
@d2943 4
a2946 1
	  bfd_set_error (bfd_error_invalid_operation);
@


1.98
log
@	* elflink.c (_bfd_elf_section_already_linked): Handle
	SEC_LINK_DUPLICATES_SAME_CONTENTS.
@
text
@d60 1
a60 2
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
d133 3
a135 4
  /* Note that we set the SEC_IN_MEMORY flag for all of these
     sections.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
	   | SEC_IN_MEMORY | SEC_LINKER_CREATED);
a156 2
  bed = get_elf_backend_data (abfd);

d252 1
a252 3

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
@


1.97
log
@	PR 338
	* elflink.c (bfd_elf_record_link_assignment): Add comment about
	changing bfd_link_hash_undefined to bfd_link_hash_new.
	* ldexp.c (fold_name): Don't call bfd_link_add_undef if the symbol
	was already on the undefs list.
@
text
@d9369 30
@


1.96
log
@	* elflink.h (elf_gc_sweep): Keep non-alloc, non-load sections.
@
text
@d437 6
a442 1
     may depend on this.  */
@


1.95
log
@	* elflink.c (elf_section_complain_discarded): Ignore .fixup.
@
text
@d8507 3
a8509 3
	  /* Keep special sections.  Keep .debug sections.  */
	  if ((o->flags & SEC_LINKER_CREATED)
	      || (o->flags & SEC_DEBUGGING))
@


1.94
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d6340 3
@


1.93
log
@	* elf-bfd.h (struct elf_backend_data): Add
	elf_backend_archive_symbol_lookup.
	(_bfd_elf_archive_symbol_lookup): Declare.
	* elflink.c (_bfd_elf_archive_symbol_lookup): New function..
	(elf_link_add_archive_symbols): ..extracted from here.  Call the
	backend version.
	* elfxx-target.h (elf_backend_archive_symbol_lookup): Provide default.
	(elfNN_bed): Init new field.
	* elf64-ppc.c (elf_backend_check_directives): Define.
	(elf_backend_archive_symbol_lookup): Define.
	(struct ppc_link_hash_table): Add tls_get_add_fd.  Make tls_get_add
	a ppc_link_hash_entry pointer.
	(get_fdh): Move.
	(ppc64_elf_archive_symbol_lookup, opd_entry_value): New functions.
	(add_symbol_adjust, ppc64_elf_check_directives): New functions.
	(ppc64_elf_check_relocs, ppc64_elf_gc_mark_hook, func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_tls_setup,
	ppc64_elf_tls_optimize, allocate_dynrelocs, ppc_type_of_stub,
	ppc_build_one_stub, ppc64_elf_size_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_symbol): Handle branch relocs to function
	descriptor symbols.
@
text
@d1395 2
a1396 2
	  (_("%s: warning: unexpected redefinition of indirect versioned symbol `%s'"),
	   bfd_archive_filename (abfd), shortname);
d1714 2
a1715 2
	    (_("%s: undefined versioned symbol name %s"),
	     bfd_get_filename (sinfo->output_bfd), h->root.root.string);
a1861 1
	  char *sec_name = bfd_get_section_ident (sec);
d1863 4
a1866 6
	    (_("%s: bad reloc symbol index (0x%lx >= 0x%lx) for offset 0x%lx in section `%s'"),
	     bfd_archive_filename (abfd), (unsigned long) r_symndx,
	     (unsigned long) nsyms, irela->r_offset,
	     sec_name ? sec_name : sec->name);
	  if (sec_name)
	    free (sec_name);
a2051 1
      char *sec_name = bfd_get_section_ident (input_section);
d2053 2
a2054 6
	(_("%s: relocation size mismatch in %s section %s"),
	 bfd_get_filename (output_bfd),
	 bfd_archive_filename (input_section->owner),
	 sec_name ? sec_name : input_section->name);
      if (sec_name)
	free (sec_name);
d3462 2
a3463 2
			    (_("%s: %s: invalid version %u (max %d)"),
			     bfd_archive_filename (abfd), name, vernum,
d3503 2
a3504 2
			    (_("%s: %s: invalid needed version %d"),
			     bfd_archive_filename (abfd), name, vernum);
d3678 4
a3681 6
		  (_("Warning: alignment %u of symbol `%s' in %s is smaller than %u in %s"),
		   1 << normal_align,
		   name,
		   bfd_archive_filename (normal_bfd),
		   1 << common_align,
		   bfd_archive_filename (common_bfd));
d3690 3
a3692 1
		  (_("Warning: size of symbol `%s' changed from %lu in %s to %lu in %s"),
d3694 1
a3694 3
		   bfd_archive_filename (old_bfd),
		   (unsigned long) isym->st_size,
		   bfd_archive_filename (abfd));
d3714 3
a3716 3
		  (_("Warning: type of symbol `%s' changed from %d to %d in %s"),
		   name, h->type, ELF_ST_TYPE (isym->st_info),
		   bfd_archive_filename (abfd));
d3854 1
a3854 1
		     bfd_archive_filename (abfd), name);
d4960 2
a4961 2
			(_("%s: .preinit_array section is not allowed in DSO"),
			 bfd_archive_filename (sub));
d6033 2
a6034 2
	(_("%s: %s symbol `%s' in %s is referenced by DSO"),
	 bfd_get_filename (finfo->output_bfd),
d6038 2
a6039 3
	   ? "hidden" : "local",
	 h->root.root.string,
	 bfd_archive_filename (h->root.u.def.section->owner));
a6111 1
		char *sec_name = bfd_get_section_ident (input_sec);
d6113 2
a6114 6
		  (_("%s: could not find output section %s for input section %s"),
		   bfd_get_filename (finfo->output_bfd),
		   input_sec->output_section->name,
		   sec_name ? sec_name : input_sec->name);
		if (sec_name)
		  free (sec_name);
d6210 7
a6216 7
	(_("%s: %s symbol `%s' isn't defined"),
	  bfd_get_filename (finfo->output_bfd),
	  ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED
	  ? "protected"
	  : ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL
	    ? "internal" : "hidden",
	  h->root.root.string);
d6712 4
a6715 14
			  char *r_sec = bfd_get_section_ident (o);
			  char *d_sec = bfd_get_section_ident (sec);

			  finfo->info->callbacks->error_handler
			    (LD_DEFINITION_IN_DISCARDED_SECTION,
			     _("`%T' referenced in section `%s' of %B: "
			       "defined in discarded section `%s' of %B\n"),
			     sym_name, sym_name,
			     r_sec ? r_sec : o->name, input_bfd,
			     d_sec ? d_sec : sec->name, sec->owner);
			  if (r_sec)
			    free (r_sec);
			  if (d_sec)
			    free (d_sec);
d7221 2
a7222 9
	{
	  char *name = bfd_get_section_ident (s);
	  bed->link_order_error_handler
	    (_("%s: warning: sh_link not set for section `%s'"),
	     bfd_archive_filename (s->owner),
	     name ? name : s->name);
	  if (name)
	    free (name);
	}
d7295 2
a7296 2
      (*_bfd_error_handler) (_("%s: has both ordered and unordered sections"),
			     o->name);
d8125 1
a8125 2
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
d8166 1
a8166 2
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
a8773 1
  char *sec_name;
d8797 2
a8798 5
  sec_name = bfd_get_section_ident (sec);
  (*_bfd_error_handler) ("%s: %s+%lu: No symbol found for INHERIT",
			 bfd_archive_filename (abfd),
			 sec_name ? sec_name : sec->name,
			 (unsigned long) offset);
d9351 2
a9352 2
		(_("%s: %s: warning: ignoring duplicate section `%s'\n"),
		 bfd_archive_filename (abfd), name);
d9358 2
a9359 2
		  (_("%s: %s: warning: duplicate section `%s' has different size\n"),
		   bfd_archive_filename (abfd), name);
@


1.92
log
@bfd/
	* elf-bfd.h (_bfd_elf_gc_mark): Declare.
	* elflink.c (elf_link_input_bfd): Formatting.
	(_bfd_elf_gc_mark): Rename from elf_gc_mark and make global.  Adjust
	all callers.
	* elf64-ppc.c (struct ppc_link_hash_entry): Remove is_entry.
	(link_hash_newfunc): Don't set it.
	(ppc64_elf_copy_indirect_symbol): Nor copy it.
	(ppc64_elf_mark_entry_syms): Delete.
	(ppc64_elf_gc_mark_hook): Mark entry syms here.  Also mark opd
	sections.  Use get_opd_info.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Delete.
ld/
	* emultempl/ppc64elf.em (ppc_after_open): Delete.
	(LDEMUL_AFTER_OPEN): Don't define.
@
text
@d4197 49
d4280 3
d4307 2
d4337 3
a4339 42
	  h = elf_link_hash_lookup (elf_hash_table (info), symdef->name,
				    FALSE, FALSE, FALSE);

	  if (h == NULL)
	    {
	      char *p, *copy;
	      size_t len, first;

	      /* If this is a default version (the name contains @@@@),
		 look up the symbol again with only one `@@' as well
		 as without the version.  The effect is that references
		 to the symbol with and without the version will be
		 matched by the default symbol in the archive.  */

	      p = strchr (symdef->name, ELF_VER_CHR);
	      if (p == NULL || p[1] != ELF_VER_CHR)
		continue;

	      /* First check with only one `@@'.  */
	      len = strlen (symdef->name);
	      copy = bfd_alloc (abfd, len);
	      if (copy == NULL)
		goto error_return;
	      first = p - symdef->name + 1;
	      memcpy (copy, symdef->name, first);
	      memcpy (copy + first, symdef->name + first + 1, len - first);

	      h = elf_link_hash_lookup (elf_hash_table (info), copy,
					FALSE, FALSE, FALSE);

	      if (h == NULL)
		{
		  /* We also need to check references to the symbol
		     without the version.  */

		  copy[first - 1] = '\0';
		  h = elf_link_hash_lookup (elf_hash_table (info),
					    copy, FALSE, FALSE, FALSE);
		}

	      bfd_release (abfd, copy);
	    }
@


1.91
log
@2004-07-30  H.J. Lu  <hongjiu.lu@@intel.com>
	    Nick Clifton  <nickc@@redhat.com>

	PR 290
	* bfd.c (_bfd_default_error_handler): Make it global.

	* elf-bfd.h (elf_backend_data): Add link_order_error_handler.

	* elf.c (assign_section_numbers): Cope gracefully with sections
	which have SHF_LINK_ORDER set but no sh_link set up.
	* elflink.c (elf_get_linked_section_vma): Likewise.

	* elfxx-ia64.c (elf_backend_link_order_error_handler): New. Set
	it to NULL.

	* elfxx-target.h (elf_backend_link_order_error_handler): New.
	Set it to _bfd_default_error_handler.
	(elfNN_bed): Add elf_backend_link_order_error_handler.

	* libbfd-in.h (_bfd_default_error_handler): New.

	* libbfd.h: Regenerated.
@
text
@d6713 3
a6715 4
			  char *r_sec
			    = bfd_get_section_ident (o);
			  char *d_sec
			    = bfd_get_section_ident (sec);
d8368 4
a8371 4
static bfd_boolean
elf_gc_mark (struct bfd_link_info *info,
	     asection *sec,
	     gc_mark_hook_fn gc_mark_hook)
d8381 1
a8381 1
    if (!elf_gc_mark (info, group_sec, gc_mark_hook))
d8462 1
a8462 1
	      else if (!elf_gc_mark (info, rsec, gc_mark_hook))
d8769 1
a8769 1
	      else if (!elf_gc_mark (info, o, gc_mark_hook))
@


1.90
log
@2004-07-27  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 161/251
	* elf-bfd.h (bfd_elf_section_data): Add sec_group.
	(elf_sec_group): Defined.
	(bfd_elf_match_symbols_in_sections): New prototype.
	(_bfd_elf_setup_group_pointers): Likewise.

	* elf.c (bfd_elf_discard_group): Abort.
	(bfd_elf_set_group_contents): Also include relocation sections.
	Remove zero-fill for ld -r.
	(_bfd_elf_setup_group_pointers): New function.
	(elf_sort_elf_symbol): Likewise.
	(elf_sym_name_compare): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.

	* elfcode.h (elf_object_p): Call _bfd_elf_setup_group_pointers.

	* elflink.c (match_group_member): New.
	(elf_link_input_bfd): Check group member for discarded section.
	(try_match_symbols_in_sections): New function.
	(already_linked): Likewise.
	(_bfd_elf_section_already_linked): Support mixing comdat group
	and linkonce section.

	* libbfd-in.h (bfd_section_already_linked_table_traverse): New.
	* linker.c (bfd_section_already_linked_table_traverse): New.

	* libbfd.h: Regenerated.
@
text
@d7223 26
a7248 2
  s = elf_shdrp[elfsec]->bfd_section;
  return s->output_section->vma + s->output_offset;
@


1.89
log
@2004-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_fixup_link_order): Add _() to error message.
@
text
@d6344 20
d6690 1
a6690 2
			  if (sec->kept_section != NULL
			      && sec->size == sec->kept_section->size)
d6692 17
a6708 2
			      *ps = sec->kept_section;
			      continue;
d9197 77
d9281 6
d9289 7
a9295 1
  if ((flags & SEC_LINK_ONCE) == 0)
d9298 11
d9337 1
a9337 1
      if ((sec->flags & SEC_GROUP) == (l->sec->flags & SEC_GROUP)
d9373 15
a9387 1
	    bfd_elf_discard_group (abfd, sec);
d9393 16
@


1.88
log
@bfd/

2004-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_fixup_link_order): Issue a warning and flag
	an error if failed.

ld/

2004-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-scripts/crossref.exp: XFAIL ia64-*-* on the first test.
@
text
@d7256 1
a7256 1
      (*_bfd_error_handler) ("%s: has both ordered and unordered sections",
@


1.87
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d7255 6
a7260 1
    return FALSE;
@


1.86
log
@	* elflink.c (elf_get_linked_section_vma, compare_link_order,
	elf_fixup_link_order): New functions.
	(bfd_elf_final_link): Call elf_fixup_link_order.
@
text
@d9157 86
@


1.85
log
@* elf-bfd.h (ELF_COMMON_DEF_P): New.
* elflink.c (_bfd_elf_symbol_refs_local_p): Use it to handle
common definitions.
* elf-m10300.c: Use SYMBOL_REFERENCES_LOCAL instead of
_bfd_elf_symbol_refs_local_p.
* elf32-frv.c (FRVFDPIC_SYM_LOCAL): Remove hack for common
symbols.
@
text
@d7175 109
d7743 7
@


1.84
log
@bfd/

2004-07-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd-in.h (dynamic_lib_link_class): Add DYN_NO_ADD_NEEDED and
	DYN_NO_NEEDED.
	(bfd_elf_get_dyn_lib_class): New prototype.
	* elf.c (bfd_elf_get_dyn_lib_class): New function.

	* elflink.c (elf_link_add_object_symbols): Check DYN_AS_NEEDED,
	DYN_DT_NEEDED and DYN_NO_NEEDED bits to see if a DT_NEEDED
	entry is needed. Issue an error if a DT_NEEDED entry is needed
	for a file marked DYN_NO_NEEDED.
	(elf_link_check_versioned_symbol): Check the DYN_DT_NEEDED bit
	for DT_NEEDED tags.

	* bfd-in2.h: Regenerated.

ld/

2004-07-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols): Also
	check the add_needed field.
	(dt_needed): New struct.
	(gld${EMULATION_NAME}_try_needed): Change the first argument
	to a pointer to struct dt_needed. Check the DYN_NO_ADD_NEEDED
	bit in the file where the DT_NEEDED entry comes from.
	(gld${EMULATION_NAME}_search_needed): Change the second
	argument to a pointer to struct dt_needed.
	(gld${EMULATION_NAME}_check_ld_so_conf): Updated.
	(gld${EMULATION_NAME}_after_open): Likewise.

	* ld.texinfo: Add --add-needed document.
	* ldlang.c (new_afile): Set p->add_needed.
	* ldlang.h (lang_input_statement_type): Add add_needed field.
	* ldmain.h (add_needed): Declare.
	* ldmain.c (add_needed): New global var.
	* lexsup.c (option_values): Add OPTION_ADD_NEEDED and
	OPTION_NO_ADD_NEEDED.
	(ld_options): Likewise.
	(parse_args): Handle them.
@
text
@d2459 4
d2465 1
a2465 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
@


1.83
log
@	* elflink.c (elf_section_complain_discarded): Don't complain in
	.PARISC.unwind.
@
text
@d3067 7
a3073 2
	 in by another lib's DT_NEEDED.  */
      add_needed = elf_dyn_lib_class (abfd) == DYN_NORMAL;
d3854 11
a3864 1
		 Add a DT_NEEDED entry for it.  */
d5836 1
a5836 1
	  || elf_dyn_lib_class (abfd) != DYN_DT_NEEDED)
@


1.82
log
@Revert previous delta - the bug had already been fixed.
@
text
@d6319 3
@


1.81
log
@(elf_sort_symbol): Restructure code to avoid bug in Solairs hosted versions of
gcc.
@
text
@a2735 1

d2741 1
d2745 9
a2753 11

  /* Coded this way to avoid bugs in various versions of gcc.  */
  if (h1->root.u.def.value < h2->root.u.def.value)
     return -1;
  if (h1->root.u.def.value > h2->root.u.def.value)
     return 1;
  if (h1->root.u.def.section < h2->root.u.def.section)
     return -1;
  if (h1->root.u.def.section > h2->root.u.def.section)
     return 1;

@


1.80
log
@Add support for sh-symbian-elf target
@
text
@d2736 1
a2741 1
  bfd_signed_vma vdiff;
d2745 11
a2755 9
  vdiff = h1->root.u.def.value - h2->root.u.def.value;
  if (vdiff != 0)
    return vdiff > 0 ? 1 : -1;
  else
    {
      long sdiff = h1->root.u.def.section->id - h2->root.u.def.section->id;
      if (sdiff != 0)
	return sdiff > 0 ? 1 : -1;
    }
@


1.79
log
@bfd/

2004-07-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_get_section_ident): New.

	* elflink.c (elf_link_read_relocs_from_section): Call
	bfd_get_section_ident to identify the section when reporting
	error.
	(_bfd_elf_link_output_relocs): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_link_input_bfd): Likewise.
	(bfd_elf_gc_record_vtinherit): Likewise.

	* bfd-in2.h: Regenerated.
ld/

2004-07-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldmisc.c (vfinfo): Call bfd_get_section_ident to identify
	the section.
@
text
@d2907 2
d4058 4
@


1.78
log
@bfd/
	* elflink.c (elf_section_ignore_discarded_relocs): Revert last
	change.  Comment.
	(elf_section_complain_discarded): New function.  Handle
	.gcc_except_table too.
	(elf_link_input_bfd): Rewrite handling of relocs against symbols
	in discarded sections.
	* elf-bfd.h (elf_discarded_section): Protect macro arg.
ld/testsuite/
	* ld-discard/extern.d: Update.
	* ld-discard/start.d: Update.
	* ld-discard/static.d: Update.
@
text
@d1862 1
d1866 4
a1869 1
	     (unsigned long) nsyms, irela->r_offset, sec->name);
d2055 1
d2060 3
a2062 1
	 input_section->name);
d6083 1
d6088 3
a6090 1
		   input_sec->name);
d6651 4
d6659 7
a6665 3
			     sym_name,
			     sym_name, o->name, input_bfd,
			     sec->name, sec->owner);
d8588 1
d8612 1
d8614 2
a8615 1
			 bfd_archive_filename (abfd), sec->name,
@


1.77
log
@bfd/

2004-06-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 233
	* elflink.c (elf_link_input_bfd): Issue an error for non-debug
	local references to discarded sections and report their
	locations.

ld/testsuite/

2004-06-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 233
	* ld-discard/extern.d: Updated.
	* ld-discard/start.d: Likewise.
	* ld-discard/static.d: Likewise.
@
text
@d6261 3
d6269 23
d6295 1
a6295 1
    return TRUE;
d6298 1
a6298 1
    return TRUE;
d6300 2
a6301 4
  bed = get_elf_backend_data (sec->owner);
  if (bed->elf_backend_ignore_discarded_relocs != NULL
      && (*bed->elf_backend_ignore_discarded_relocs) (sec))
    return TRUE;
d6303 1
a6303 1
  return FALSE;
d6578 1
d6585 3
a6587 1
		  asection *sec;
a6592 2
		      struct elf_link_hash_entry *h;

d6598 6
a6603 34
		      /* Complain if the definition comes from a
			 discarded section.  */
		      sec = h->root.u.def.section;
		      if ((h->root.type == bfd_link_hash_defined
			   || h->root.type == bfd_link_hash_defweak)
			  && elf_discarded_section (sec))
			{
			  if ((o->flags & SEC_DEBUGGING) != 0)
			    {
			      BFD_ASSERT (r_symndx != 0);
			      /* Try to preserve debug information.  */
			      if (sec->kept_section != NULL
				  && sec->size == sec->kept_section->size)
				h->root.u.def.section
				  = sec->kept_section;
			      else
				memset (rel, 0, sizeof (*rel));
			    }
			  else
			    {
			      char *r_name
				= xstrdup (bfd_archive_filename (o->owner));
			      finfo->info->callbacks->error_handler
				(LD_DEFINITION_IN_DISCARDED_SECTION,
				 _("`%T' referenced in section `%s' from %s: discarded in section `%s' from %s\n"),
				 h->root.root.string,
				 h->root.root.string,
				 o->name, r_name,
				 h->root.u.def.section->name,
				 bfd_archive_filename (h->root.u.def.section->owner));
			      if (r_name)
				free (r_name);
			    }
			}
d6607 4
a6610 1
		      sec = finfo->sections[r_symndx];
d6612 5
a6616 1
		      if (sec != NULL && elf_discarded_section (sec))
d6618 16
a6633 15
			  if ((o->flags & SEC_DEBUGGING) != 0)
			    {
			      BFD_ASSERT (r_symndx != 0);
			      /* Try to preserve debug information.  */
			      if (sec->kept_section != NULL
				  && sec->size == sec->kept_section->size)
				finfo->sections[r_symndx]
				  = sec->kept_section;
			      else
				{
				  rel->r_info &= r_type_mask;
				  rel->r_addend = 0;
				}
			    }
			  else
d6635 2
a6636 15
			      static int count;
			      int ok;
			      char *buf;

			      ok = asprintf (&buf, "local symbol %d",
					     count++);
			      if (ok <= 0)
				buf = (char *) "local symbol";
			      finfo->info->callbacks->error_handler
				(LD_DEFINITION_IN_DISCARDED_SECTION,
				 _("`%T' referenced in section `%s': discarded in section `%s' from %s\n"),
				 buf, buf, o->name, sec->name,
				 bfd_archive_filename (input_bfd));
			      if (ok != -1)
				free (buf);
d6639 20
@


1.76
log
@	* elflink.c (elf_section_ignore_discarded_relocs): Don't test
	sec_info_type, test section name instead.
@
text
@d6584 1
a6584 2
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
d6592 14
a6605 7
			    finfo->info->callbacks->error_handler
			      (LD_DEFINITION_IN_DISCARDED_SECTION,
			       _("%T: discarded in section `%s' from %s\n"),
			       h->root.root.string,
			       h->root.root.string,
			       h->root.u.def.section->name,
			       bfd_archive_filename (h->root.u.def.section->owner));
d6614 1
a6614 2
			  if ((o->flags & SEC_DEBUGGING) != 0
			      || (sec->flags & SEC_LINK_ONCE) != 0)
d6618 1
a6618 2
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
d6640 2
a6641 2
				 _("%T: discarded in section `%s' from %s\n"),
				 buf, buf, sec->name,
@


1.75
log
@	* bfd-in.h (struct stab_info): Move from stabs.c.
	* stabs.c (struct stab_link_includes_table): Delete.
	(stab_link_includes_lookup): Delete.
	(_bfd_write_section_stabs, _bfd_write_stab_strings): Remove one
	level of indirection from sinfo parm.
	(_bfd_link_section_stabs): Likewise.  Set SEC_LINKER_CREATED on
	stabstr section.  Adjust hash table accesses.
	* coff-ppc.c (ppc_bfd_coff_final_link): Do include rawsize in contents
	alloc.  Adjust stab_info test.
	* cofflink.c (_bfd_coff_link_hash_table_init): Clear stab_info.
	(_bfd_coff_final_link): Adjust stab_info test.
	(_bfd_coff_link_input_bfd): Ignore SEC_LINKER_CREATED sections.
	* elf-bfd.h (struct elf_link_hash_table): Include struct stab_info
	in place.
	* libcoff-in.h (struct coff_link_hash_table): Likewise.
	* elf.c (_bfd_elf_link_hash_table_init): Clear stab_info.
	* elflink.c (bfd_elf_final_link): Don't attempt to link linker created
	stabstr section.  Adjust stab_info test.
	* libbfd-in.h (_bfd_link_section_stabs, _bfd_write_section_stabs)
	(_bfd_write_stab_strings): Adjust prototypes.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d6266 7
a6272 8
  switch (sec->sec_info_type)
    {
    case ELF_INFO_TYPE_STABS:
    case ELF_INFO_TYPE_EH_FRAME:
      return TRUE;
    default:
      break;
    }
@


1.74
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d4127 1
a4127 1
					       & hash_table->stab_info,
d8004 2
d8041 1
a8041 1
  if (elf_hash_table (info)->stab_info != NULL)
@


1.73
log
@bfd/ChangeLog:
* elf-bfd.h (struct elf_backend_data): Added
elf_backend_omit_section_dynsym.
(_bfd_elf_link_omit_section_dynsym): Declare.
* elf32-frv.c (_frvfdpic_link_omit_section_dynsym): New.
(elf_backend_omit_section_dynsym): Use it for frvfdpic.
* elflink.c (_bfd_elf_link_omit_section_dynsym): Split out of...
(_bfd_elf_link_renumber_dynsyms): ... this function.
* elfxx-target.h (elf_backend_omit_section_dynsym): Default to
_bfd_elf_link_omit_section_dynsym).
(elfNN_bed): Added elf_backend_omit_section_dynsym.
ld/ChangeLog:
* emulparams/elf32frvfd.sh (GENERATE_PIE_SCRIPT): Set to yes.
ld/testsuite/ChangeLog:
* ld-frv/fdpic-pie-1.d: Adjust for pie-specific link script.
* ld-frv/fdpic-pie-2.d: Likewise.
* ld-frv/fdpic-pie-6.d: Likewise.
* ld-frv/fdpic-pie-7.d: Likewise.
* ld-frv/fdpic-pie-8.d: Likewise.
* ld-frv/fdpic-shared-1.d: Likewise.
* ld-frv/fdpic-shared-2.d: Likewise.
* ld-frv/fdpic-shared-3.d: Likewise.
* ld-frv/fdpic-shared-4.d: Likewise.
* ld-frv/fdpic-shared-5.d: Likewise.
* ld-frv/fdpic-shared-6.d: Likewise.
* ld-frv/fdpic-shared-7.d: Likewise.
* ld-frv/fdpic-shared-8.d: Likewise.
* ld-frv/fdpic-shared-local-2.d: Likewise.
* ld-frv/fdpic-shared-local-8.d: Likewise.
@
text
@d101 1
a101 1
  s->_raw_size += bed->got_header_size + bed->got_symbol_offset;
d2656 1
a2656 1
  newsize = s->_raw_size + bed->s->sizeof_dyn;
d2663 1
a2663 1
  bed->s->swap_dyn_out (hash_table->dynobj, &dyn, newcontents + s->_raw_size);
d2665 1
a2665 1
  s->_raw_size = newsize;
d2701 1
a2701 1
	   extdyn < sdyn->contents + sdyn->_raw_size;
d2790 1
a2790 1
       extdyn < sdyn->contents + sdyn->_raw_size;
d2990 1
a2990 1
		      s->_raw_size = 0;
d2995 1
a2995 1
	      sz = bfd_section_size (abfd, s);
d3016 1
a3016 1
		  s->_raw_size = 0;
d3069 1
a3069 5
	  dynbuf = bfd_malloc (s->_raw_size);
	  if (dynbuf == NULL)
	    goto error_return;

	  if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
d3078 1
a3078 1
	       extdyn < dynbuf + s->_raw_size;
d5026 3
a5028 3
	  s->_raw_size = size;
	  s->contents = bfd_alloc (output_bfd, s->_raw_size);
	  if (s->contents == NULL && s->_raw_size != 0)
d5225 2
a5226 2
	    s->_raw_size = size;
	    s->contents = bfd_alloc (output_bfd, s->_raw_size);
d5311 2
a5312 2
	  s->_raw_size = dynsymcount * sizeof (Elf_External_Versym);
	  s->contents = bfd_zalloc (output_bfd, s->_raw_size);
d5328 3
a5330 3
      s->_raw_size = dynsymcount * bed->s->sizeof_sym;
      s->contents = bfd_alloc (output_bfd, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d5354 2
a5355 2
      s->_raw_size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
      s->contents = bfd_zalloc (output_bfd, s->_raw_size);
d5370 1
a5370 1
      s->_raw_size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
d5580 1
a5580 1
  if (reldyn == NULL || reldyn->_raw_size == 0)
d5583 1
a5583 1
      if (reldyn == NULL || reldyn->_raw_size == 0)
d5595 1
a5595 1
  count = reldyn->_raw_size / ext_size;
d5602 1
a5602 1
	size += o->_raw_size;
d5605 1
a5605 1
  if (size != reldyn->_raw_size)
d5630 1
a5630 1
	erelend = o->contents + o->_raw_size;
d5672 1
a5672 1
	erelend = o->contents + o->_raw_size;
d6496 1
a6496 1
	  || (o->_raw_size == 0 && (o->flags & SEC_RELOC) == 0))
d6514 2
d6517 1
a6517 2
	  if (! bfd_get_section_contents (input_bfd, o, contents, 0,
					  o->_raw_size))
d6587 1
a6587 1
				  && sec->_raw_size == sec->kept_section->_raw_size)
d6616 1
a6616 1
				  && sec->_raw_size == sec->kept_section->_raw_size)
a6933 3
	    bfd_size_type sec_size;

	    sec_size = (o->_cooked_size != 0 ? o->_cooked_size : o->_raw_size);
d6938 1
a6938 1
					       sec_size))
d7245 4
a7248 4
	      if (sec->_raw_size > max_contents_size)
		max_contents_size = sec->_raw_size;
	      if (sec->_cooked_size > max_contents_size)
		max_contents_size = sec->_cooked_size;
d7556 1
a7556 1
	  bfd_vma size = sec->_raw_size;
d7832 1
a7832 1
      dynconend = o->contents + o->_raw_size;
d7908 1
a7908 1
	      if (o->_raw_size == 0)
d7911 1
a7911 1
	      dyn.d_un.d_val = o->_raw_size;
d7995 1
a7995 1
	      || o->_raw_size == 0
d8004 2
d8013 1
a8013 1
					      o->_raw_size))
d8864 1
a8864 1
	      && (eh->_raw_size == 0
d8870 1
a8870 1
	  && (stab->_raw_size == 0
@


1.72
log
@* elflink.c (elf_sort_symbol): Compare section id, not pointers.
(elf_link_add_object_symbols): Likewise.
@
text
@d611 37
d660 1
d664 3
a666 29
	    && (p->flags & SEC_ALLOC) != 0)
	  switch (elf_section_data (p)->this_hdr.sh_type)
	    {
	    case SHT_PROGBITS:
	    case SHT_NOBITS:
	      /* If sh_type is yet undecided, assume it could be
		 SHT_PROGBITS/SHT_NOBITS.  */
	    case SHT_NULL:
	      if (strcmp (p->name, ".got") == 0
		  || strcmp (p->name, ".got.plt") == 0
		  || strcmp (p->name, ".plt") == 0)
		{
		  asection *ip;
		  bfd *dynobj = elf_hash_table (info)->dynobj;

		  if (dynobj != NULL
		      && (ip = bfd_get_section_by_name (dynobj, p->name))
			 != NULL
		      && (ip->flags & SEC_LINKER_CREATED)
		      && ip->output_section == p)
		    continue;
		}
	      elf_section_data (p)->dynindx = ++dynsymcount;
	      break;
	      /* There shouldn't be section relative relocations
		 against any other section.  */
	    default:
	      break;
	    }
@


1.71
log
@bfd/
	* elflink.c (elf_link_add_object_symbols): Don't set up merge
	section data here..
	* elf.c (_bfd_elf_merge_sections): .. Do it here instead.
	* merge.c: Formatting.  Remove unnecessary casts.  Expand
	bfd_get_section_alignment macro.
	(struct sec_merge_sec_info): Rename "first" to "first_str".  Update
	use throughout file.
	(_bfd_add_merge_section): Rename from _bfd_merge_section.  Update
	comment.  Abort on dynamic or non-SEC_MERGE input.  Don't test
	section name to determine sinfo group, instead test output section
	and alignment.
	(_bfd_merge_sections): Add struct bfd_link_info param.  Call
	_bfd_strip_section_from_output rather than just twiddling flags.
	* libbfd-in.h (_bfd_add_merge_section): Rename, update comment.
	(_bfd_merge_sections): Update prototype.
	* libbfd.h: Regenerate.
ld/
	* ldlang.c (lang_process): Call bfd_merge_sections later, and
	only when not a relocatable link.
	(print_input_section): Handle SEC_EXCLUDE sections.
	(size_input_section): Don't update dot on SEC_EXCLUDE sections.
	(lang_do_assignments_1): Likewise.
	* ldwrite.c (build_link_order): Ignore SEC_EXCLUDE input sections.
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Likewise.
	* emultempl/hppaelf.em (build_section_lists): Likewise.
	* emultempl/ppc64elf.em (build_toc_list): Likewise.
	(build_section_lists): Likewise.
@
text
@d2731 1
a2731 1
      long sdiff = h1->root.u.def.section - h2->root.u.def.section;
d3985 1
a3985 1
		  long sdiff = slook - h->root.u.def.section;
@


1.70
log
@	* merge.c (_bfd_merged_section_offset): Remove "addend" param.
	* libbfd-in.h (_bfd_merged_section_offset): Adjust prototype.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_rela_local_sym): Adjust call.
	(_bfd_elf_rel_local_sym): Likewise.
	* elflink.c (_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_relocate_section): Likewise.
@
text
@a4129 22
  if (! info->relocatable
      && ! dynamic
      && is_elf_hash_table (hash_table))
    {
      asection *s;

      for (s = abfd->sections; s != NULL; s = s->next)
	if ((s->flags & SEC_MERGE) != 0
	    && !bfd_is_abs_section (s->output_section))
	  {
	    struct bfd_elf_section_data *secdata;

	    secdata = elf_section_data (s);
	    if (! _bfd_merge_section (abfd,
				      & hash_table->merge_info,
				      s, &secdata->sec_info))
	      goto error_return;
	    else if (secdata->sec_info)
	      s->sec_info_type = ELF_INFO_TYPE_MERGE;
	  }
    }

@


1.69
log
@bfd/
	* elflink.c (elf_bfd_final_link): Don't output STT_SECTION symbol
	into .dynsym if elf_section_data (sec)->dynindx <= 0.
	Adjust counting of last_local.
	(_bfd_elf_link_renumber_dynsyms): Don't assign dynindx to sections
	other than SHT_PROGBITS/SHT_NOBITS and neither for .got/.got.plt/.plt
	created by the linker nor !SHF_ALLOC.

	* elf32-i386.c (elf_i386_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.  Set sh_entsize for .got section in addition
	to .got.plt.
	(elf_i386_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.
	(elf64_x86_64_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.  Set sh_entsize for .got section
	in addition to .got.plt.
	* elf.c (_bfd_elf_print_private_bfd_data): Handle PT_GNU_RELRO.
	(bfd_section_from_phdr): Likewise.
	(map_sections_to_segments): Likewise.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Likewise.
	* elflink.c (bfd_elf_size_dynamic_sections): Set
	elf_tdata (output_bfd)->relro from info->relro.
	* elf-bfd.h (struct elf_obj_tdata): Add relro field.
include/
	* bfdlink.h (struct bfd_link_info): Add relro, relro_start and
	relro_end fields.
	* elf/common.h (PT_GNU_EH_FRAME, PT_GNU_STACK): Add comments.
	(PT_GNU_RELRO): Define.
binutils/
	* readelf.c (get_segment_type): Handle PT_GNU_RELRO.
ld/
	* genscripts.sh: Generate -z combreloc -z now -z relro scripts
	for binaries, -shared and -pie.
	* emulparams/elf_i386.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf_x86_64.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf32ppc.sh (OTHER_READWRITE_SECTIONS): Rename to...
	(OTHER_RELRO_SECTIONS): ... this.
	* ldlex.l (DATA_SEGMENT_RELRO_END): Add.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Handle
	-z relro and -z norelro.
	(gld${EMULATION_NAME}_list_options): Add it to usage.
	(gld${EMULATION_NAME}_get_script): Return -z combreloc -z now
	-z relro scripts when appropriate.
	* scripttempl/elf.sc: Unset SEPARATE_GOTPLT if RELRO_NOW is set.
	Create separate .got.plt section if SEPARATE_GOTPLT.
	Move sections which are only written during relocation handling
	to the beginning of RW segment.  If NO_SMALL_DATA, move .got
	before .data.  Add DATA_SEGMENT_RELRO_END directive.
	Include OTHER_RELRO_SECTIONS.
	* ldgram.y (DATA_SEGMENT_RELRO_END): Add.
	* ldexp.c (exp_print_token): Handle DATA_SEGMENT_RELRO_END.
	(fold_unary): Likewise.
	(fold_binary): Handle -z relro.
	* ldexp.h (struct exp_data_seg): Add exp_dataseg_relro_seen and
	exp_dataseg_relro_adjust phases.  Add relro_end field.
	* ldmain.c (main): Initialize link_info.relro to FALSE.
	* ldlang.c (lang_size_sections): Handle -z relro.
ld/testsuite/
	* ld-i386/tlspic.rd: Adjust for section reordering changes
	and removal of unneeded STT_SECTION symbols from .dynsym.
	* ld-i386/tlspic.dd: Likewise.
	* ld-i386/tlspic.sd: Likewise.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsbinpic.s: Likewise.
	* ld-i386/tlsbin.dd: Likewise.
	* ld-i386/tlsbin.sd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlsnopic1.s: Likewise.
	* ld-i386/combreloc.d: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlsnopic.sd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/tlspic.td: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-s390/tlspic1.s: Likewise.
	* ld-s390/tlsbinpic.s: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlspic.dd: Likewise.
	* ld-s390/tlsbin.dd: Likewise.
	* ld-s390/tlsbin.sd: Likewise.
	* ld-s390/tlsbin.td: Likewise.
	* ld-s390/tlspic.sd: Likewise.
	* ld-s390/tlspic.td: Likewise.
	* ld-s390/tlspic1_64.s: Likewise.
	* ld-s390/tlsbinpic_64.s: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic_64.dd: Likewise.
	* ld-s390/tlsbin_64.dd: Likewise.
	* ld-s390/tlspic_64.sd: Likewise.
	* ld-s390/tlspic_64.td: Likewise.
	* ld-s390/tlsbin_64.td: Likewise.
	* ld-s390/tlsbin_64.sd: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.g: Likewise.
	* ld-powerpc/tlsso32.t: Likewise.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlsso.g: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
	* ld-powerpc/tlstocso.g: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-ia64/tlspic.dd: Likewise.
	* ld-ia64/tlspic.sd: Likewise.
	* ld-ia64/tlspic.td: Likewise.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlsbin.sd: Likewise.
	* ld-ia64/tlsbin.td: Likewise.
	* ld-elfvsb/elfvsb.exp: XFAIL non-PIC load offset tests on s390x.
	* ld-shared/shared.exp: Likewise.
@
text
@d2365 1
a2365 1
				    h->root.u.def.value, 0);
d6395 1
a6395 1
					  isym->st_value, 0);
@


1.68
log
@	* elf.c (_bfd_elf_rela_local_sym): Set kept_section for excluded
	SEC_MERGE sections.
	* elflink.c (elf_link_input_bfd): Adjust output reloc index for
	those against discarded link-once and SEC_MERGE section symbols.
@
text
@d625 30
a654 2
	if ((p->flags & SEC_EXCLUDE) == 0)
	  elf_section_data (p)->dynindx = ++dynsymcount;
d4652 1
d7686 3
a7689 1
	      dynindx = elf_section_data (s)->dynindx;
d7694 2
a7697 2

	  last_local = bfd_count_sections (abfd);
@


1.67
log
@	* elflink.c (elf_gc_mark): Follow indirect and warning syms.
@
text
@d6766 4
a6769 7
			 processor specific section.  If we have
			 discarded a section, the output_section will
			 be the absolute section.  */
		      if (bfd_is_abs_section (sec)
			  || (sec != NULL
			      && bfd_is_abs_section (sec->output_section)))
			r_symndx = 0;
d6777 19
a6795 2
			  r_symndx = sec->output_section->target_index;
			  BFD_ASSERT (r_symndx != 0);
@


1.66
log
@	* elflink.c (elf_gc_mark_dynamic_ref_symbol): New function.
	(bfd_elf_gc_sections): Fail if a shared object is being created.
	Do not fail if dynamic sections have been created.  Instead call
	elf_gc_mark_dynamic_ref_symbol to mark sections that contain
	dynamically referenced symbols.  Do not mark the whole graph
	rooted at .eh_frame, only the section proper.
@
text
@d8176 3
@


1.65
log
@	* elflink.c (_bfd_elf_merge_symbol): Treat weak as strong only
	when it is a definition.
@
text
@d8415 18
d8447 2
a8448 2
      || !is_elf_hash_table (info->hash)
      || elf_hash_table (info)->dynamic_sections_created)
d8468 8
a8476 1

d8488 9
a8496 2
	    if (!elf_gc_mark (info, o, gc_mark_hook))
	      return FALSE;
@


1.64
log
@	* elflink.c: Include libiberty.h.
	* Makefile.am (elflink.lo): Depend on libiberty.h.
	* Makefile.in: Regenerate.
@
text
@d890 12
a901 8
  /* If a new weak symbol comes from a regular file and the old symbol
     comes from a dynamic library, we treat the new one as strong.
     Similarly, an old weak symbol from a regular file is treated as
     strong when the new symbol comes from a dynamic library.  Further,
     an old weak symbol from a dynamic library is treated as strong if
     the new symbol is from a dynamic library.  This reflects the way
     glibc's ld.so works.  */
  if (!newdyn && olddyn)
d903 1
a903 1
  if (newdyn)
@


1.63
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d28 1
@


1.62
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d93 1
a93 1
	  && ! _bfd_elf_link_record_dynamic_symbol (info, h))
d223 1
a223 1
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
d288 1
a288 1
	  && ! _bfd_elf_link_record_dynamic_symbol (info, h))
d350 2
a351 2
_bfd_elf_link_record_dynamic_symbol (struct bfd_link_info *info,
				     struct elf_link_hash_entry *h)
d469 1
a469 1
      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
d478 1
a478 1
	  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
d491 3
a493 3
elf_link_record_local_dynamic_symbol (struct bfd_link_info *info,
				      bfd *input_bfd,
				      long input_indx)
d839 1
a839 1
	return _bfd_elf_link_record_dynamic_symbol (info, h);
d1278 1
a1278 1
	      if (! _bfd_elf_link_record_dynamic_symbol (info, hi))
d1436 1
a1436 1
	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
d2080 1
a2080 1
	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
d3765 1
a3765 1
	      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
d3771 1
a3771 1
		  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
d3986 1
a3986 2
		      if (! _bfd_elf_link_record_dynamic_symbol (info,
								 h))
d3997 1
a3997 2
		      if (! _bfd_elf_link_record_dynamic_symbol (info,
								 hlook))
d5076 1
a5076 1
	      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
d5358 3545
@


1.61
log
@	* elfxx-target.h (bfd_elfNN_bfd_link_add_symbols): Define.
	* elf-bfd.h (_bfd_elf_link_add_archive_symbols): Delete.
	(_bfd_elf_sort_symbol, _bfd_elf_add_dt_needed_tag): Delete.
	(_bfd_elf_finalize_dynstr, bfd_elf32_bfd_link_add_symbols): Delete.
	(bfd_elf64_bfd_link_add_symbols): Delete.
	(bfd_elf_link_add_symbols): Declare.
	* elfcode.h (elf_bfd_link_add_symbols): Delete.
	* elflink.c: Include safe-ctype.h.
	(elf_add_dt_needed_tag): Rename from _bfd_elf_add_dt_needed_tag,
	make static.
	(elf_sort_symbol): Rename from _bfd_elf_sort_symbol, make static.
	(elf_finalize_dynstr): Rename from _bfd_elf_finalize_dynstr, make
	static.
	(elf_link_add_archive_symbols): Rename from
	_bfd_elf_link_add_archive_symbols, make static.
	(elf_link_add_object_symbols): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(bfd_elf_link_add_symbols): Likewise.
	(bfd_elf_size_dynamic_sections): Adjust.
	* elflink.h (elf_bfd_link_add_symbols): Delete.
	(elf_link_add_object_symbols): Delete.
	* elf32-gen.c (elf32_generic_link_add_symbols): Call
	bfd_elf_link_add_symbols.
	* elf64-gen.c (elf64_generic_link_add_symbols): Likewise.
@
text
@d2851 1
a2851 1
    (bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
@


1.60
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d27 1
d2630 4
a2633 4
int
_bfd_elf_add_dt_needed_tag (struct bfd_link_info *info,
			    const char *soname,
			    bfd_boolean do_it)
d2684 2
a2685 2
int
_bfd_elf_sort_symbol (const void *arg1, const void *arg2)
d2704 1
a2704 1

d2724 2
a2725 2
bfd_boolean
_bfd_elf_finalize_dynstr (bfd *output_bfd, struct bfd_link_info *info)
d2845 1303
d4173 2
a4174 3
bfd_boolean
_bfd_elf_link_add_archive_symbols (bfd *abfd,
				   struct bfd_link_info *info)
d4371 18
d5350 1
a5350 1
      _bfd_elf_finalize_dynstr (output_bfd, info);
@


1.59
log
@	* elflink.c (_bfd_elf_merge_symbol): Revert last change.  Move
	type and size change code to where it was previously.  Remove
	dt_needed param.  Treat old weak syms as strong if new sym is
	from a shared lib, even when old sym is from another shared
	lib.  Remove unnecessary tests of oldweak and newweak.  Correct
	comments.
	(_bfd_elf_add_default_symbol): Remove dt_needed param.  Update
	_bfd_elf_merge_symbol calls.
	* elflink.h (elf_link_add_object_symbols): Update calls.  Remove
	dt_needed local var.  Update comments.
	* elf-bfd.h (_bfd_elf_merge_symbol): Update prototype.
	(_bfd_elf_add_default_symbol): Likewise.
@
text
@d2588 256
d3067 972
@


1.58
log
@	* elflink.c (_bfd_elf_merge_symbol): Reinstate code to handle
	strong syms in one shared object overriding weak syms in another.
@
text
@d656 1
a656 2
   change.  DT_NEEDED indicates if it comes from a DT_NEEDED entry of
   a shared object.  */
d669 1
a669 2
		       bfd_boolean *size_change_ok,
		       bfd_boolean dt_needed)
d888 12
a916 11
  /* If a new weak symbol comes from a regular file and the old symbol
     comes from a dynamic library, we treat the new one as strong.
     Similarly, an old weak symbol from a regular file is treated as
     strong when the new symbol comes from a dynamic library.  Further,
     an old weak symbol from a dynamic library is treated as strong if
     the new symbol is from a DT_NEEDED dynamic library.  */
  if (!newdyn && olddyn)
    newweak = FALSE;
  if ((!olddyn || dt_needed) && newdyn)
    oldweak = FALSE;

d1007 1
a1007 2
		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC)))
      && (!oldweak || newweak))
d1051 1
a1051 4
     symbol is a function or is weak.

     As above, we permit a non-weak definition in a shared object to
     override a weak definition in a regular object.  */
d1061 1
a1061 2
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (!newweak || oldweak))
a1149 24
  /* Handle the special case of a weak definition in one shared object
     followed by a non-weak definition in another.  We are covering for
     a deficiency of _bfd_generic_link_add_one_symbol here.  A new
     strong definition of an indirect symbol is treated as a multiple
     definition even when the indirect symbol points to a weak sym.  */
  if (olddef
      && oldweak
      && olddyn
      && newdef
      && !newweak
      && newdyn)
    {
      /* To make this work we have to frob the flags so that the rest
	 of the code does not think we are using the old definition.  */
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;

      /* If H is the target of an indirection, we want the caller to
	 use H rather than the indirect symbol.  Otherwise if we are
	 defining a new indirect symbol we will wind up attaching it
	 to the entry we are overriding.  */
      *sym_hash = h;
    }

d1156 1
a1156 2
   set DYNSYM if the new indirect symbol is dynamic. DT_NEEDED
   indicates if it comes from a DT_NEEDED entry of a shared object.  */
d1167 1
a1167 2
			     bfd_boolean override,
			     bfd_boolean dt_needed)
d1228 1
a1228 1
			      &size_change_ok, dt_needed))
d1335 1
a1335 1
			      &size_change_ok, dt_needed))
@


1.57
log
@	* elflink.c (_bfd_elf_merge_symbol): Rewrite weak symbol handling.
	(_bfd_elf_add_default_symbol): Remove indirect BFD_ASSERTs.
	* elflink.h (elf_link_add_object_symbols): Don't clear dt_needed in
	symbol loop.  Instead use add_needed to flag tag as written.
@
text
@d1156 24
@


1.56
log
@copyright date.
@
text
@d656 1
a656 1
   change. DT_NEEDED indicates if it comes from a DT_NEEDED entry of
d679 1
a679 1
  bfd_boolean newweakdef, oldweakdef, newweakundef, oldweakundef;
d817 1
a817 1
	    { 
d885 14
a898 17
  /* We need to treat weak definition right, depending on if there is a
     definition from a dynamic object.  */
  if (bind == STB_WEAK)
    {
      if (olddef)
	{
	   newweakdef = TRUE;
	   newweakundef = FALSE;
	}
      else
	{
	   newweakdef = FALSE;
	   newweakundef = TRUE;
	}
    }
  else
    newweakdef = newweakundef = FALSE;
d900 2
a901 5
  /* If the new weak definition comes from a relocatable file and the
     old symbol comes from a dynamic object, we treat the new one as
     strong.  */
  if (newweakdef && !newdyn && olddyn)
    newweakdef = FALSE;
d903 3
a905 12
  if (h->root.type == bfd_link_hash_defweak)
    {
      oldweakdef = TRUE;
      oldweakundef = FALSE;
    }
  else if (h->root.type == bfd_link_hash_undefweak)
    {
      oldweakdef = FALSE;
      oldweakundef = TRUE;
    }
  else
    oldweakdef = oldweakundef = FALSE;
d907 10
a916 5
  /* If the old weak definition comes from a relocatable file and the
     new symbol comes from a dynamic object, we treat the old one as
     strong.  */
  if (oldweakdef && !olddyn && newdyn)
    oldweakdef = FALSE;
d943 1
a946 2
      && !newweakdef
      && !newweakundef
a963 22
  /* It's OK to change the type if either the existing symbol or the
     new symbol is weak unless it comes from a DT_NEEDED entry of
     a shared object, in which case, the DT_NEEDED entry may not be
     required at the run time. The type change is also OK if the
     old symbol is undefined and the new symbol is defined.  */

  if ((! dt_needed && oldweakdef)
      || oldweakundef
      || newweakdef
      || newweakundef
      || (newdef
	  && (h->root.type == bfd_link_hash_undefined
	      || h->root.type == bfd_link_hash_undefweak)))
    *type_change_ok = TRUE;

  /* It's OK to change the size if either the existing symbol or the
     new symbol is weak, or if the old symbol is undefined.  */

  if (*type_change_ok
      || h->root.type == bfd_link_hash_undefined)
    *size_change_ok = TRUE;

d1001 1
a1001 6
     object to override a weak symbol in a shared object.

     We prefer a non-weak definition in a shared library to a weak
     definition in the executable unless it comes from a DT_NEEDED
     entry of a shared object, in which case, the DT_NEEDED entry
     may not be required at the run time.  */
d1007 1
a1007 2
	      && (newweakdef
		  || newweakundef
d1009 1
a1009 4
      && (!oldweakdef
	  || dt_needed
	  || newweakdef
	  || newweakundef))
d1062 2
a1063 1
	      && (oldweakdef || h->type == STT_FUNC)))
d1067 1
a1067 1
      && ((!newweakdef && !newweakundef) || oldweakdef))
a1155 43
  /* Handle the special case of a weak definition in a regular object
     followed by a non-weak definition in a shared object.  In this
     case, we prefer the definition in the shared object unless it
     comes from a DT_NEEDED entry of a shared object, in which case,
     the DT_NEEDED entry may not be required at the run time.  */
  if (olddef
      && ! dt_needed
      && oldweakdef
      && newdef
      && newdyn
      && !newweakdef
      && !newweakundef)
    {
      /* To make this work we have to frob the flags so that the rest
	 of the code does not think we are using the regular
	 definition.  */
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
      else if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      h->elf_link_hash_flags &= ~ (ELF_LINK_HASH_DEF_REGULAR
				   | ELF_LINK_HASH_DEF_DYNAMIC);

      /* If H is the target of an indirection, we want the caller to
	 use H rather than the indirect symbol.  Otherwise if we are
	 defining a new indirect symbol we will wind up attaching it
	 to the entry we are overriding.  */
      *sym_hash = h;
    }

  /* Handle the special case of a non-weak definition in a shared
     object followed by a weak definition in a regular object.  In
     this case we prefer the definition in the shared object.  To make
     this work we have to tell the caller to not treat the new symbol
     as a definition.  */
  if (olddef
      && olddyn
      && !oldweakdef
      && newdef
      && ! newdyn
      && (newweakdef || newweakundef))
    *override = TRUE;

a1302 6
      /* If the symbol became indirect, then we assume that we have
	 not seen a definition before.  */
      BFD_ASSERT ((hi->elf_link_hash_flags
		   & (ELF_LINK_HASH_DEF_DYNAMIC
		      | ELF_LINK_HASH_DEF_REGULAR)) == 0);

a1374 6
	  /* If the symbol became indirect, then we assume that we have
	     not seen a definition before.  */
	  BFD_ASSERT ((hi->elf_link_hash_flags
		       & (ELF_LINK_HASH_DEF_DYNAMIC
			  | ELF_LINK_HASH_DEF_REGULAR)) == 0);

@


1.55
log
@	* elflink.c (elf_link_read_relocs_from_section): Don't use
	NUM_SHDR_ENTRIES in end of reloc calc.  Move NULL shdr check..
	(_bfd_elf_link_read_relocs): ..to here.
	* elf32-ppc.c (ppc_elf_relax_section): Formatting.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@


1.54
log
@* elflink.c (bfd_elf_record_link_assignment): Mark undefweak and
undefined symbols as hash_new.
@
text
@a1882 4
  /* If there aren't any relocations, that's OK.  */
  if (!shdr)
    return TRUE;

d1908 1
a1908 1
  erelaend = erela + NUM_SHDR_ENTRIES (shdr) * shdr->sh_entsize;
d1994 7
a2000 6
  if (!elf_link_read_relocs_from_section
      (abfd, o,
       elf_section_data (o)->rel_hdr2,
       ((bfd_byte *) external_relocs) + rel_hdr->sh_size,
       internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
			  * bed->s->int_rels_per_ext_rel)))
@


1.54.2.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d656 2
a657 1
   change.  */
d670 2
a671 1
		       bfd_boolean *size_change_ok)
d679 1
a679 1
  bfd_boolean newweak, oldweak;
d817 1
a817 1
	    {
d885 17
a901 16
  /* Differentiate strong and weak symbols.  */
  newweak = bind == STB_WEAK;
  oldweak = (h->root.type == bfd_link_hash_defweak
	     || h->root.type == bfd_link_hash_undefweak);

  /* If a new weak symbol comes from a regular file and the old symbol
     comes from a dynamic library, we treat the new one as strong.
     Similarly, an old weak symbol from a regular file is treated as
     strong when the new symbol comes from a dynamic library.  Further,
     an old weak symbol from a dynamic library is treated as strong if
     the new symbol is from a dynamic library.  This reflects the way
     glibc's ld.so works.  */
  if (!newdyn && olddyn)
    newweak = FALSE;
  if (newdyn)
    oldweak = FALSE;
d903 5
a907 3
  /* It's OK to change the type if either the existing symbol or the
     new symbol is weak.  A type change is also OK if the old symbol
     is undefined and the new symbol is defined.  */
d909 12
a920 5
  if (oldweak
      || newweak
      || (newdef
	  && h->root.type == bfd_link_hash_undefined))
    *type_change_ok = TRUE;
d922 5
a926 6
  /* It's OK to change the size if either the existing symbol or the
     new symbol is weak, or if the old symbol is undefined.  */

  if (*type_change_ok
      || h->root.type == bfd_link_hash_undefined)
    *size_change_ok = TRUE;
a952 1
      && !newweak
d956 2
d975 22
d1034 6
a1039 1
     object to override a weak symbol in a shared object.  */
d1045 7
a1051 2
	      && (newweak
		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC))))
d1095 4
a1098 1
     symbol is a function or is weak.  */
d1104 1
a1104 2
	      && (oldweak
		  || h->type == STT_FUNC)))
d1107 2
a1108 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
d1197 43
d1246 2
a1247 1
   set DYNSYM if the new indirect symbol is dynamic.  */
d1258 2
a1259 1
			     bfd_boolean override)
d1320 1
a1320 1
			      &size_change_ok))
d1387 6
d1433 1
a1433 1
			      &size_change_ok))
d1465 6
d1883 4
d1912 1
a1912 1
  erelaend = erela + shdr->sh_size;
d1998 6
a2003 7
  if (elf_section_data (o)->rel_hdr2
      && (!elf_link_read_relocs_from_section
	  (abfd, o,
	   elf_section_data (o)->rel_hdr2,
	   ((bfd_byte *) external_relocs) + rel_hdr->sh_size,
	   internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
			      * bed->s->int_rels_per_ext_rel))))
@


1.53
log
@2004-02-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_link_add_archive_symbols): New prototype.

	* elflink.h (is_global_data_symbol_definition): Moved to
	elflink.c.
	(elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_archive_symbols): Likewise. Renamed to
	_bfd_elf_link_add_archive_symbols.

	* elflink.c (elf_link_is_defined_archive_symbol): Get the size
	of ELF symbol table entry from backend.
	(_bfd_elf_link_add_archive_symbols): Call bfd_link_add_symbols
	instead of elf_link_add_object_symbols.
@
text
@d433 7
@


1.52
log
@2004-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_merge_symbol): Properly handle undefined
	symbols with non-default visibility.
@
text
@d2567 345
@


1.51
log
@	* elf-bfd.h (is_elf_hash_table): Take hash tab rather than info arg.
	* elf.c (_bfd_elf_merge_sections): Adjust to suit.
	(_bfd_elf_link_just_syms): Likewise.
	(bfd_elf_get_needed_list): Likewise.
	(bfd_elf_get_runpath_list): Likewise.
	(_bfd_elf_link_hash_copy_indirect): Remove unneeded parens.
	* elf32-hppa.c (elf32_hppa_setup_section_lists): Don't check hash tab
	creator flavour.
	(elf32_hppa_set_gp): Look up output sections rather than using htab.
	* elf32-i960.c: Comment fix.  Formatting.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Use is_elf_hash_table
	rather than testing creator flavour.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Adjust for
	is_elf_hash_table change.  Remove redundant test.
	(bfd_elf_record_link_assignment): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_link_record_local_dynamic_symbol): Adjust for is_elf_hash_table.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Likewise.  Remove redundant
	checks.  Use is_elf_hash_table rather than testing creator flavour.
	Use hash_table throughout in place of info->hash.
	(elf_add_dynamic_entry): Adjust for is_elf_hash_table change.
	(NAME(bfd_elf,size_dynamic_sections)): Likewise.  Remove redundant
	check.
	(elf_bfd_final_link): Adjust for is_elf_hash_table change.
	(elf_link_check_versioned_symbol): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_gc_sections): Add is_elf_hash_table check.
	(elf_gc_common_finalize_got_offsets): Likewise.
	(elf_bfd_discard_info): Adjust for is_elf_hash_table change.  Remove
	redundant check.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use is_elf_hash_table
	rather than testing creator flavour.
@
text
@d846 20
a865 2
      h->root.type = bfd_link_hash_new;
      h->root.u.undef.abfd = NULL;
@


1.51.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a26 1
#include "safe-ctype.h"
a432 7
  /* Since we're defining the symbol, don't let it seem to have not
     been defined.  record_dynamic_symbol and size_dynamic_sections
     may depend on this.  */
  if (h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_undefined)
    h->root.type = bfd_link_hash_new;

d649 2
a650 1
   change.  */
d663 2
a664 1
		       bfd_boolean *size_change_ok)
d672 1
a672 1
  bfd_boolean newweak, oldweak;
d810 1
a810 1
	    {
d846 2
a847 20

      if ((h->root.und_next || info->hash->undefs_tail == &h->root)
	  && bfd_is_und_section (sec))
	{
	  /* If the new symbol is undefined and the old symbol was
	     also undefined before, we need to make sure
	     _bfd_generic_link_add_one_symbol doesn't mess
	     up the linker hash table undefs list. Since the old
	     definition came from a dynamic object, it is still on the
	     undefs list.  */
	  h->root.type = bfd_link_hash_undefined;
	  /* FIXME: What if the new symbol is weak undefined?  */
	  h->root.u.undef.abfd = abfd;
	}
      else
	{
	  h->root.type = bfd_link_hash_new;
	  h->root.u.undef.abfd = NULL;
	}

d860 17
a876 16
  /* Differentiate strong and weak symbols.  */
  newweak = bind == STB_WEAK;
  oldweak = (h->root.type == bfd_link_hash_defweak
	     || h->root.type == bfd_link_hash_undefweak);

  /* If a new weak symbol comes from a regular file and the old symbol
     comes from a dynamic library, we treat the new one as strong.
     Similarly, an old weak symbol from a regular file is treated as
     strong when the new symbol comes from a dynamic library.  Further,
     an old weak symbol from a dynamic library is treated as strong if
     the new symbol is from a dynamic library.  This reflects the way
     glibc's ld.so works.  */
  if (!newdyn && olddyn)
    newweak = FALSE;
  if (newdyn)
    oldweak = FALSE;
d878 5
a882 3
  /* It's OK to change the type if either the existing symbol or the
     new symbol is weak.  A type change is also OK if the old symbol
     is undefined and the new symbol is defined.  */
d884 12
a895 8
  if (oldweak
      || newweak
      || (newdef
	  && h->root.type == bfd_link_hash_undefined))
    *type_change_ok = TRUE;

  /* It's OK to change the size if either the existing symbol or the
     new symbol is weak, or if the old symbol is undefined.  */
d897 5
a901 3
  if (*type_change_ok
      || h->root.type == bfd_link_hash_undefined)
    *size_change_ok = TRUE;
a927 1
      && !newweak
d931 2
d950 22
d1009 6
a1014 1
     object to override a weak symbol in a shared object.  */
d1020 7
a1026 2
	      && (newweak
		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC))))
d1070 4
a1073 1
     symbol is a function or is weak.  */
d1079 1
a1079 2
	      && (oldweak
		  || h->type == STT_FUNC)))
d1082 2
a1083 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
d1172 43
d1221 2
a1222 1
   set DYNSYM if the new indirect symbol is dynamic.  */
d1233 2
a1234 1
			     bfd_boolean override)
d1295 1
a1295 1
			      &size_change_ok))
d1362 6
d1408 1
a1408 1
			      &size_change_ok))
d1440 6
d1858 4
d1887 1
a1887 1
  erelaend = erela + shdr->sh_size;
d1973 6
a1978 7
  if (elf_section_data (o)->rel_hdr2
      && (!elf_link_read_relocs_from_section
	  (abfd, o,
	   elf_section_data (o)->rel_hdr2,
	   ((bfd_byte *) external_relocs) + rel_hdr->sh_size,
	   internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
			      * bed->s->int_rels_per_ext_rel))))
a2547 2893
}

/* Return TRUE iff this is a non-common, definition of a non-function symbol.  */
static bfd_boolean
is_global_data_symbol_definition (bfd *abfd ATTRIBUTE_UNUSED,
				  Elf_Internal_Sym *sym)
{
  /* Local symbols do not count, but target specific ones might.  */
  if (ELF_ST_BIND (sym->st_info) != STB_GLOBAL
      && ELF_ST_BIND (sym->st_info) < STB_LOOS)
    return FALSE;

  /* Function symbols do not count.  */
  if (ELF_ST_TYPE (sym->st_info) == STT_FUNC)
    return FALSE;

  /* If the section is undefined, then so is the symbol.  */
  if (sym->st_shndx == SHN_UNDEF)
    return FALSE;

  /* If the symbol is defined in the common section, then
     it is a common definition and so does not count.  */
  if (sym->st_shndx == SHN_COMMON)
    return FALSE;

  /* If the symbol is in a target specific section then we
     must rely upon the backend to tell us what it is.  */
  if (sym->st_shndx >= SHN_LORESERVE && sym->st_shndx < SHN_ABS)
    /* FIXME - this function is not coded yet:

       return _bfd_is_global_symbol_definition (abfd, sym);

       Instead for now assume that the definition is not global,
       Even if this is wrong, at least the linker will behave
       in the same way that it used to do.  */
    return FALSE;

  return TRUE;
}

/* Search the symbol table of the archive element of the archive ABFD
   whose archive map contains a mention of SYMDEF, and determine if
   the symbol is defined in this element.  */
static bfd_boolean
elf_link_is_defined_archive_symbol (bfd * abfd, carsym * symdef)
{
  Elf_Internal_Shdr * hdr;
  bfd_size_type symcount;
  bfd_size_type extsymcount;
  bfd_size_type extsymoff;
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  bfd_boolean result;

  abfd = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
  if (abfd == NULL)
    return FALSE;

  if (! bfd_check_format (abfd, bfd_object))
    return FALSE;

  /* If we have already included the element containing this symbol in the
     link then we do not need to include it again.  Just claim that any symbol
     it contains is not a definition, so that our caller will not decide to
     (re)include this element.  */
  if (abfd->archive_pass)
    return FALSE;

  /* Select the appropriate symbol table.  */
  if ((abfd->flags & DYNAMIC) == 0 || elf_dynsymtab (abfd) == 0)
    hdr = &elf_tdata (abfd)->symtab_hdr;
  else
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;

  symcount = hdr->sh_size / get_elf_backend_data (abfd)->s->sizeof_sym;

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols.  */
  if (elf_bad_symtab (abfd))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }

  if (extsymcount == 0)
    return FALSE;

  /* Read in the symbol table.  */
  isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
				  NULL, NULL, NULL);
  if (isymbuf == NULL)
    return FALSE;

  /* Scan the symbol table looking for SYMDEF.  */
  result = FALSE;
  for (isym = isymbuf, isymend = isymbuf + extsymcount; isym < isymend; isym++)
    {
      const char *name;

      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	break;

      if (strcmp (name, symdef->name) == 0)
	{
	  result = is_global_data_symbol_definition (abfd, isym);
	  break;
	}
    }

  free (isymbuf);

  return result;
}

/* Add an entry to the .dynamic table.  */

bfd_boolean
_bfd_elf_add_dynamic_entry (struct bfd_link_info *info,
			    bfd_vma tag,
			    bfd_vma val)
{
  struct elf_link_hash_table *hash_table;
  const struct elf_backend_data *bed;
  asection *s;
  bfd_size_type newsize;
  bfd_byte *newcontents;
  Elf_Internal_Dyn dyn;

  hash_table = elf_hash_table (info);
  if (! is_elf_hash_table (hash_table))
    return FALSE;

  bed = get_elf_backend_data (hash_table->dynobj);
  s = bfd_get_section_by_name (hash_table->dynobj, ".dynamic");
  BFD_ASSERT (s != NULL);

  newsize = s->_raw_size + bed->s->sizeof_dyn;
  newcontents = bfd_realloc (s->contents, newsize);
  if (newcontents == NULL)
    return FALSE;

  dyn.d_tag = tag;
  dyn.d_un.d_val = val;
  bed->s->swap_dyn_out (hash_table->dynobj, &dyn, newcontents + s->_raw_size);

  s->_raw_size = newsize;
  s->contents = newcontents;

  return TRUE;
}

/* Add a DT_NEEDED entry for this dynamic object if DO_IT is true,
   otherwise just check whether one already exists.  Returns -1 on error,
   1 if a DT_NEEDED tag already exists, and 0 on success.  */

static int
elf_add_dt_needed_tag (struct bfd_link_info *info,
		       const char *soname,
		       bfd_boolean do_it)
{
  struct elf_link_hash_table *hash_table;
  bfd_size_type oldsize;
  bfd_size_type strindex;

  hash_table = elf_hash_table (info);
  oldsize = _bfd_elf_strtab_size (hash_table->dynstr);
  strindex = _bfd_elf_strtab_add (hash_table->dynstr, soname, FALSE);
  if (strindex == (bfd_size_type) -1)
    return -1;

  if (oldsize == _bfd_elf_strtab_size (hash_table->dynstr))
    {
      asection *sdyn;
      const struct elf_backend_data *bed;
      bfd_byte *extdyn;

      bed = get_elf_backend_data (hash_table->dynobj);
      sdyn = bfd_get_section_by_name (hash_table->dynobj, ".dynamic");
      BFD_ASSERT (sdyn != NULL);

      for (extdyn = sdyn->contents;
	   extdyn < sdyn->contents + sdyn->_raw_size;
	   extdyn += bed->s->sizeof_dyn)
	{
	  Elf_Internal_Dyn dyn;

	  bed->s->swap_dyn_in (hash_table->dynobj, extdyn, &dyn);
	  if (dyn.d_tag == DT_NEEDED
	      && dyn.d_un.d_val == strindex)
	    {
	      _bfd_elf_strtab_delref (hash_table->dynstr, strindex);
	      return 1;
	    }
	}
    }

  if (do_it)
    {
      if (!_bfd_elf_add_dynamic_entry (info, DT_NEEDED, strindex))
	return -1;
    }
  else
    /* We were just checking for existence of the tag.  */
    _bfd_elf_strtab_delref (hash_table->dynstr, strindex);

  return 0;
}

/* Sort symbol by value and section.  */
static int
elf_sort_symbol (const void *arg1, const void *arg2)
{
  const struct elf_link_hash_entry *h1;
  const struct elf_link_hash_entry *h2;
  bfd_signed_vma vdiff;

  h1 = *(const struct elf_link_hash_entry **) arg1;
  h2 = *(const struct elf_link_hash_entry **) arg2;
  vdiff = h1->root.u.def.value - h2->root.u.def.value;
  if (vdiff != 0)
    return vdiff > 0 ? 1 : -1;
  else
    {
      long sdiff = h1->root.u.def.section - h2->root.u.def.section;
      if (sdiff != 0)
	return sdiff > 0 ? 1 : -1;
    }
  return 0;
}

/* This function is used to adjust offsets into .dynstr for
   dynamic symbols.  This is called via elf_link_hash_traverse.  */

static bfd_boolean
elf_adjust_dynstr_offsets (struct elf_link_hash_entry *h, void *data)
{
  struct elf_strtab_hash *dynstr = data;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx != -1)
    h->dynstr_index = _bfd_elf_strtab_offset (dynstr, h->dynstr_index);
  return TRUE;
}

/* Assign string offsets in .dynstr, update all structures referencing
   them.  */

static bfd_boolean
elf_finalize_dynstr (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_link_hash_table *hash_table = elf_hash_table (info);
  struct elf_link_local_dynamic_entry *entry;
  struct elf_strtab_hash *dynstr = hash_table->dynstr;
  bfd *dynobj = hash_table->dynobj;
  asection *sdyn;
  bfd_size_type size;
  const struct elf_backend_data *bed;
  bfd_byte *extdyn;

  _bfd_elf_strtab_finalize (dynstr);
  size = _bfd_elf_strtab_size (dynstr);

  bed = get_elf_backend_data (dynobj);
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (sdyn != NULL);

  /* Update all .dynamic entries referencing .dynstr strings.  */
  for (extdyn = sdyn->contents;
       extdyn < sdyn->contents + sdyn->_raw_size;
       extdyn += bed->s->sizeof_dyn)
    {
      Elf_Internal_Dyn dyn;

      bed->s->swap_dyn_in (dynobj, extdyn, &dyn);
      switch (dyn.d_tag)
	{
	case DT_STRSZ:
	  dyn.d_un.d_val = size;
	  break;
	case DT_NEEDED:
	case DT_SONAME:
	case DT_RPATH:
	case DT_RUNPATH:
	case DT_FILTER:
	case DT_AUXILIARY:
	  dyn.d_un.d_val = _bfd_elf_strtab_offset (dynstr, dyn.d_un.d_val);
	  break;
	default:
	  continue;
	}
      bed->s->swap_dyn_out (dynobj, &dyn, extdyn);
    }

  /* Now update local dynamic symbols.  */
  for (entry = hash_table->dynlocal; entry ; entry = entry->next)
    entry->isym.st_name = _bfd_elf_strtab_offset (dynstr,
						  entry->isym.st_name);

  /* And the rest of dynamic symbols.  */
  elf_link_hash_traverse (hash_table, elf_adjust_dynstr_offsets, dynstr);

  /* Adjust version definitions.  */
  if (elf_tdata (output_bfd)->cverdefs)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verdef def;
      Elf_Internal_Verdaux defaux;

      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
      p = s->contents;
      do
	{
	  _bfd_elf_swap_verdef_in (output_bfd, (Elf_External_Verdef *) p,
				   &def);
	  p += sizeof (Elf_External_Verdef);
	  for (i = 0; i < def.vd_cnt; ++i)
	    {
	      _bfd_elf_swap_verdaux_in (output_bfd,
					(Elf_External_Verdaux *) p, &defaux);
	      defaux.vda_name = _bfd_elf_strtab_offset (dynstr,
							defaux.vda_name);
	      _bfd_elf_swap_verdaux_out (output_bfd,
					 &defaux, (Elf_External_Verdaux *) p);
	      p += sizeof (Elf_External_Verdaux);
	    }
	}
      while (def.vd_next);
    }

  /* Adjust version references.  */
  if (elf_tdata (output_bfd)->verref)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verneed need;
      Elf_Internal_Vernaux needaux;

      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
      p = s->contents;
      do
	{
	  _bfd_elf_swap_verneed_in (output_bfd, (Elf_External_Verneed *) p,
				    &need);
	  need.vn_file = _bfd_elf_strtab_offset (dynstr, need.vn_file);
	  _bfd_elf_swap_verneed_out (output_bfd, &need,
				     (Elf_External_Verneed *) p);
	  p += sizeof (Elf_External_Verneed);
	  for (i = 0; i < need.vn_cnt; ++i)
	    {
	      _bfd_elf_swap_vernaux_in (output_bfd,
					(Elf_External_Vernaux *) p, &needaux);
	      needaux.vna_name = _bfd_elf_strtab_offset (dynstr,
							 needaux.vna_name);
	      _bfd_elf_swap_vernaux_out (output_bfd,
					 &needaux,
					 (Elf_External_Vernaux *) p);
	      p += sizeof (Elf_External_Vernaux);
	    }
	}
      while (need.vn_next);
    }

  return TRUE;
}

/* Add symbols from an ELF object file to the linker hash table.  */

static bfd_boolean
elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean (*add_symbol_hook)
    (bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
     const char **, flagword *, asection **, bfd_vma *);
  bfd_boolean (*check_relocs)
    (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
  bfd_boolean collect;
  Elf_Internal_Shdr *hdr;
  bfd_size_type symcount;
  bfd_size_type extsymcount;
  bfd_size_type extsymoff;
  struct elf_link_hash_entry **sym_hash;
  bfd_boolean dynamic;
  Elf_External_Versym *extversym = NULL;
  Elf_External_Versym *ever;
  struct elf_link_hash_entry *weaks;
  struct elf_link_hash_entry **nondeflt_vers = NULL;
  bfd_size_type nondeflt_vers_cnt = 0;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  const struct elf_backend_data *bed;
  bfd_boolean add_needed;
  struct elf_link_hash_table * hash_table;
  bfd_size_type amt;

  hash_table = elf_hash_table (info);

  bed = get_elf_backend_data (abfd);
  add_symbol_hook = bed->elf_add_symbol_hook;
  collect = bed->collect;

  if ((abfd->flags & DYNAMIC) == 0)
    dynamic = FALSE;
  else
    {
      dynamic = TRUE;

      /* You can't use -r against a dynamic object.  Also, there's no
	 hope of using a dynamic object which does not exactly match
	 the format of the output file.  */
      if (info->relocatable
	  || !is_elf_hash_table (hash_table)
	  || hash_table->root.creator != abfd->xvec)
	{
	  bfd_set_error (bfd_error_invalid_operation);
	  goto error_return;
	}
    }

  /* As a GNU extension, any input sections which are named
     .gnu.warning.SYMBOL are treated as warning symbols for the given
     symbol.  This differs from .gnu.warning sections, which generate
     warnings when they are included in an output file.  */
  if (info->executable)
    {
      asection *s;

      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  const char *name;

	  name = bfd_get_section_name (abfd, s);
	  if (strncmp (name, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0)
	    {
	      char *msg;
	      bfd_size_type sz;
	      bfd_size_type prefix_len;
	      const char * gnu_warning_prefix = _("warning: ");

	      name += sizeof ".gnu.warning." - 1;

	      /* If this is a shared object, then look up the symbol
		 in the hash table.  If it is there, and it is already
		 been defined, then we will not be using the entry
		 from this shared object, so we don't need to warn.
		 FIXME: If we see the definition in a regular object
		 later on, we will warn, but we shouldn't.  The only
		 fix is to keep track of what warnings we are supposed
		 to emit, and then handle them all at the end of the
		 link.  */
	      if (dynamic)
		{
		  struct elf_link_hash_entry *h;

		  h = elf_link_hash_lookup (hash_table, name,
					    FALSE, FALSE, TRUE);

		  /* FIXME: What about bfd_link_hash_common?  */
		  if (h != NULL
		      && (h->root.type == bfd_link_hash_defined
			  || h->root.type == bfd_link_hash_defweak))
		    {
		      /* We don't want to issue this warning.  Clobber
			 the section size so that the warning does not
			 get copied into the output file.  */
		      s->_raw_size = 0;
		      continue;
		    }
		}

	      sz = bfd_section_size (abfd, s);
	      prefix_len = strlen (gnu_warning_prefix);
	      msg = bfd_alloc (abfd, prefix_len + sz + 1);
	      if (msg == NULL)
		goto error_return;

	      strcpy (msg, gnu_warning_prefix);
	      if (! bfd_get_section_contents (abfd, s, msg + prefix_len, 0, sz))
		goto error_return;

	      msg[prefix_len + sz] = '\0';

	      if (! (_bfd_generic_link_add_one_symbol
		     (info, abfd, name, BSF_WARNING, s, 0, msg,
		      FALSE, collect, NULL)))
		goto error_return;

	      if (! info->relocatable)
		{
		  /* Clobber the section size so that the warning does
		     not get copied into the output file.  */
		  s->_raw_size = 0;
		}
	    }
	}
    }

  add_needed = TRUE;
  if (! dynamic)
    {
      /* If we are creating a shared library, create all the dynamic
	 sections immediately.  We need to attach them to something,
	 so we attach them to this BFD, provided it is the right
	 format.  FIXME: If there are no input BFD's of the same
	 format as the output, we can't make a shared library.  */
      if (info->shared
	  && is_elf_hash_table (hash_table)
	  && hash_table->root.creator == abfd->xvec
	  && ! hash_table->dynamic_sections_created)
	{
	  if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	    goto error_return;
	}
    }
  else if (!is_elf_hash_table (hash_table))
    goto error_return;
  else
    {
      asection *s;
      const char *soname = NULL;
      struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;
      int ret;

      /* ld --just-symbols and dynamic objects don't mix very well.
	 Test for --just-symbols by looking at info set up by
	 _bfd_elf_link_just_syms.  */
      if ((s = abfd->sections) != NULL
	  && s->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
	goto error_return;

      /* If this dynamic lib was specified on the command line with
	 --as-needed in effect, then we don't want to add a DT_NEEDED
	 tag unless the lib is actually used.  Similary for libs brought
	 in by another lib's DT_NEEDED.  */
      add_needed = elf_dyn_lib_class (abfd) == DYN_NORMAL;

      s = bfd_get_section_by_name (abfd, ".dynamic");
      if (s != NULL)
	{
	  bfd_byte *dynbuf;
	  bfd_byte *extdyn;
	  int elfsec;
	  unsigned long shlink;

	  dynbuf = bfd_malloc (s->_raw_size);
	  if (dynbuf == NULL)
	    goto error_return;

	  if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
	    goto error_free_dyn;

	  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
	  if (elfsec == -1)
	    goto error_free_dyn;
	  shlink = elf_elfsections (abfd)[elfsec]->sh_link;

	  for (extdyn = dynbuf;
	       extdyn < dynbuf + s->_raw_size;
	       extdyn += bed->s->sizeof_dyn)
	    {
	      Elf_Internal_Dyn dyn;

	      bed->s->swap_dyn_in (abfd, extdyn, &dyn);
	      if (dyn.d_tag == DT_SONAME)
		{
		  unsigned int tagv = dyn.d_un.d_val;
		  soname = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (soname == NULL)
		    goto error_free_dyn;
		}
	      if (dyn.d_tag == DT_NEEDED)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    goto error_free_dyn;
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = & hash_table->needed;
		       *pn != NULL;
		       pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	      if (dyn.d_tag == DT_RUNPATH)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    goto error_free_dyn;
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = & runpath;
		       *pn != NULL;
		       pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	      /* Ignore DT_RPATH if we have seen DT_RUNPATH.  */
	      if (!runpath && dyn.d_tag == DT_RPATH)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    {
		    error_free_dyn:
		      free (dynbuf);
		      goto error_return;
		    }
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = & rpath;
		       *pn != NULL;
		       pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	    }

	  free (dynbuf);
	}

      /* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that
	 frees all more recently bfd_alloc'd blocks as well.  */
      if (runpath)
	rpath = runpath;

      if (rpath)
	{
	  struct bfd_link_needed_list **pn;
	  for (pn = & hash_table->runpath;
	       *pn != NULL;
	       pn = &(*pn)->next)
	    ;
	  *pn = rpath;
	}

      /* We do not want to include any of the sections in a dynamic
	 object in the output file.  We hack by simply clobbering the
	 list of sections in the BFD.  This could be handled more
	 cleanly by, say, a new section flag; the existing
	 SEC_NEVER_LOAD flag is not the one we want, because that one
	 still implies that the section takes up space in the output
	 file.  */
      bfd_section_list_clear (abfd);

      /* If this is the first dynamic object found in the link, create
	 the special sections required for dynamic linking.  */
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	goto error_return;

      /* Find the name to use in a DT_NEEDED entry that refers to this
	 object.  If the object has a DT_SONAME entry, we use it.
	 Otherwise, if the generic linker stuck something in
	 elf_dt_name, we use that.  Otherwise, we just use the file
	 name.  */
      if (soname == NULL || *soname == '\0')
	{
	  soname = elf_dt_name (abfd);
	  if (soname == NULL || *soname == '\0')
	    soname = bfd_get_filename (abfd);
	}

      /* Save the SONAME because sometimes the linker emulation code
	 will need to know it.  */
      elf_dt_name (abfd) = soname;

      ret = elf_add_dt_needed_tag (info, soname, add_needed);
      if (ret < 0)
	goto error_return;

      /* If we have already included this dynamic object in the
	 link, just ignore it.  There is no reason to include a
	 particular dynamic object more than once.  */
      if (ret > 0)
	return TRUE;
    }

  /* If this is a dynamic object, we always link against the .dynsym
     symbol table, not the .symtab symbol table.  The dynamic linker
     will only see the .dynsym symbol table, so there is no reason to
     look at .symtab for a dynamic object.  */

  if (! dynamic || elf_dynsymtab (abfd) == 0)
    hdr = &elf_tdata (abfd)->symtab_hdr;
  else
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;

  symcount = hdr->sh_size / bed->s->sizeof_sym;

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols at
     this point.  */
  if (elf_bad_symtab (abfd))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }

  sym_hash = NULL;
  if (extsymcount != 0)
    {
      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	goto error_return;

      /* We store a pointer to the hash table entry for each external
	 symbol.  */
      amt = extsymcount * sizeof (struct elf_link_hash_entry *);
      sym_hash = bfd_alloc (abfd, amt);
      if (sym_hash == NULL)
	goto error_free_sym;
      elf_sym_hashes (abfd) = sym_hash;
    }

  if (dynamic)
    {
      /* Read in any version definitions.  */
      if (! _bfd_elf_slurp_version_tables (abfd))
	goto error_free_sym;

      /* Read in the symbol versions, but don't bother to convert them
	 to internal format.  */
      if (elf_dynversym (abfd) != 0)
	{
	  Elf_Internal_Shdr *versymhdr;

	  versymhdr = &elf_tdata (abfd)->dynversym_hdr;
	  extversym = bfd_malloc (versymhdr->sh_size);
	  if (extversym == NULL)
	    goto error_free_sym;
	  amt = versymhdr->sh_size;
	  if (bfd_seek (abfd, versymhdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread (extversym, amt, abfd) != amt)
	    goto error_free_vers;
	}
    }

  weaks = NULL;

  ever = extversym != NULL ? extversym + extsymoff : NULL;
  for (isym = isymbuf, isymend = isymbuf + extsymcount;
       isym < isymend;
       isym++, sym_hash++, ever = (ever != NULL ? ever + 1 : NULL))
    {
      int bind;
      bfd_vma value;
      asection *sec;
      flagword flags;
      const char *name;
      struct elf_link_hash_entry *h;
      bfd_boolean definition;
      bfd_boolean size_change_ok;
      bfd_boolean type_change_ok;
      bfd_boolean new_weakdef;
      bfd_boolean override;
      unsigned int old_alignment;
      bfd *old_bfd;

      override = FALSE;

      flags = BSF_NO_FLAGS;
      sec = NULL;
      value = isym->st_value;
      *sym_hash = NULL;

      bind = ELF_ST_BIND (isym->st_info);
      if (bind == STB_LOCAL)
	{
	  /* This should be impossible, since ELF requires that all
	     global symbols follow all local symbols, and that sh_info
	     point to the first global symbol.  Unfortunately, Irix 5
	     screws this up.  */
	  continue;
	}
      else if (bind == STB_GLOBAL)
	{
	  if (isym->st_shndx != SHN_UNDEF
	      && isym->st_shndx != SHN_COMMON)
	    flags = BSF_GLOBAL;
	}
      else if (bind == STB_WEAK)
	flags = BSF_WEAK;
      else
	{
	  /* Leave it up to the processor backend.  */
	}

      if (isym->st_shndx == SHN_UNDEF)
	sec = bfd_und_section_ptr;
      else if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
	{
	  sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  if (sec == NULL)
	    sec = bfd_abs_section_ptr;
	  else if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
	    value -= sec->vma;
	}
      else if (isym->st_shndx == SHN_ABS)
	sec = bfd_abs_section_ptr;
      else if (isym->st_shndx == SHN_COMMON)
	{
	  sec = bfd_com_section_ptr;
	  /* What ELF calls the size we call the value.  What ELF
	     calls the value we call the alignment.  */
	  value = isym->st_size;
	}
      else
	{
	  /* Leave it up to the processor backend.  */
	}

      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	goto error_free_vers;

      if (isym->st_shndx == SHN_COMMON
	  && ELF_ST_TYPE (isym->st_info) == STT_TLS)
	{
	  asection *tcomm = bfd_get_section_by_name (abfd, ".tcommon");

	  if (tcomm == NULL)
	    {
	      tcomm = bfd_make_section (abfd, ".tcommon");
	      if (tcomm == NULL
		  || !bfd_set_section_flags (abfd, tcomm, (SEC_ALLOC
							   | SEC_IS_COMMON
							   | SEC_LINKER_CREATED
							   | SEC_THREAD_LOCAL)))
		goto error_free_vers;
	    }
	  sec = tcomm;
	}
      else if (add_symbol_hook)
	{
	  if (! (*add_symbol_hook) (abfd, info, isym, &name, &flags, &sec,
				    &value))
	    goto error_free_vers;

	  /* The hook function sets the name to NULL if this symbol
	     should be skipped for some reason.  */
	  if (name == NULL)
	    continue;
	}

      /* Sanity check that all possibilities were handled.  */
      if (sec == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  goto error_free_vers;
	}

      if (bfd_is_und_section (sec)
	  || bfd_is_com_section (sec))
	definition = FALSE;
      else
	definition = TRUE;

      size_change_ok = FALSE;
      type_change_ok = get_elf_backend_data (abfd)->type_change_ok;
      old_alignment = 0;
      old_bfd = NULL;

      if (is_elf_hash_table (hash_table))
	{
	  Elf_Internal_Versym iver;
	  unsigned int vernum = 0;
	  bfd_boolean skip;

	  if (ever != NULL)
	    {
	      _bfd_elf_swap_versym_in (abfd, ever, &iver);
	      vernum = iver.vs_vers & VERSYM_VERSION;

	      /* If this is a hidden symbol, or if it is not version
		 1, we append the version name to the symbol name.
		 However, we do not modify a non-hidden absolute
		 symbol, because it might be the version symbol
		 itself.  FIXME: What if it isn't?  */
	      if ((iver.vs_vers & VERSYM_HIDDEN) != 0
		  || (vernum > 1 && ! bfd_is_abs_section (sec)))
		{
		  const char *verstr;
		  size_t namelen, verlen, newlen;
		  char *newname, *p;

		  if (isym->st_shndx != SHN_UNDEF)
		    {
		      if (vernum > elf_tdata (abfd)->dynverdef_hdr.sh_info)
			{
			  (*_bfd_error_handler)
			    (_("%s: %s: invalid version %u (max %d)"),
			     bfd_archive_filename (abfd), name, vernum,
			     elf_tdata (abfd)->dynverdef_hdr.sh_info);
			  bfd_set_error (bfd_error_bad_value);
			  goto error_free_vers;
			}
		      else if (vernum > 1)
			verstr =
			  elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;
		      else
			verstr = "";
		    }
		  else
		    {
		      /* We cannot simply test for the number of
			 entries in the VERNEED section since the
			 numbers for the needed versions do not start
			 at 0.  */
		      Elf_Internal_Verneed *t;

		      verstr = NULL;
		      for (t = elf_tdata (abfd)->verref;
			   t != NULL;
			   t = t->vn_nextref)
			{
			  Elf_Internal_Vernaux *a;

			  for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
			    {
			      if (a->vna_other == vernum)
				{
				  verstr = a->vna_nodename;
				  break;
				}
			    }
			  if (a != NULL)
			    break;
			}
		      if (verstr == NULL)
			{
			  (*_bfd_error_handler)
			    (_("%s: %s: invalid needed version %d"),
			     bfd_archive_filename (abfd), name, vernum);
			  bfd_set_error (bfd_error_bad_value);
			  goto error_free_vers;
			}
		    }

		  namelen = strlen (name);
		  verlen = strlen (verstr);
		  newlen = namelen + verlen + 2;
		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
		      && isym->st_shndx != SHN_UNDEF)
		    ++newlen;

		  newname = bfd_alloc (abfd, newlen);
		  if (newname == NULL)
		    goto error_free_vers;
		  memcpy (newname, name, namelen);
		  p = newname + namelen;
		  *p++ = ELF_VER_CHR;
		  /* If this is a defined non-hidden version symbol,
		     we add another @@ to the name.  This indicates the
		     default version of the symbol.  */
		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
		      && isym->st_shndx != SHN_UNDEF)
		    *p++ = ELF_VER_CHR;
		  memcpy (p, verstr, verlen + 1);

		  name = newname;
		}
	    }

	  if (!_bfd_elf_merge_symbol (abfd, info, name, isym, &sec, &value,
				      sym_hash, &skip, &override,
				      &type_change_ok, &size_change_ok))
	    goto error_free_vers;

	  if (skip)
	    continue;

	  if (override)
	    definition = FALSE;

	  h = *sym_hash;
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* Remember the old alignment if this is a common symbol, so
	     that we don't reduce the alignment later on.  We can't
	     check later, because _bfd_generic_link_add_one_symbol
	     will set a default for the alignment which we want to
	     override. We also remember the old bfd where the existing
	     definition comes from.  */
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      old_bfd = h->root.u.def.section->owner;
	      break;

	    case bfd_link_hash_common:
	      old_bfd = h->root.u.c.p->section->owner;
	      old_alignment = h->root.u.c.p->alignment_power;
	      break;
	    }

	  if (elf_tdata (abfd)->verdef != NULL
	      && ! override
	      && vernum > 1
	      && definition)
	    h->verinfo.verdef = &elf_tdata (abfd)->verdef[vernum - 1];
	}

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, name, flags, sec, value, NULL, FALSE, collect,
	      (struct bfd_link_hash_entry **) sym_hash)))
	goto error_free_vers;

      h = *sym_hash;
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
      *sym_hash = h;

      new_weakdef = FALSE;
      if (dynamic
	  && definition
	  && (flags & BSF_WEAK) != 0
	  && ELF_ST_TYPE (isym->st_info) != STT_FUNC
	  && is_elf_hash_table (hash_table)
	  && h->weakdef == NULL)
	{
	  /* Keep a list of all weak defined non function symbols from
	     a dynamic object, using the weakdef field.  Later in this
	     function we will set the weakdef field to the correct
	     value.  We only put non-function symbols from dynamic
	     objects on this list, because that happens to be the only
	     time we need to know the normal symbol corresponding to a
	     weak symbol, and the information is time consuming to
	     figure out.  If the weakdef field is not already NULL,
	     then this symbol was already defined by some previous
	     dynamic object, and we will be using that previous
	     definition anyhow.  */

	  h->weakdef = weaks;
	  weaks = h;
	  new_weakdef = TRUE;
	}

      /* Set the alignment of a common symbol.  */
      if (isym->st_shndx == SHN_COMMON
	  && h->root.type == bfd_link_hash_common)
	{
	  unsigned int align;

	  align = bfd_log2 (isym->st_value);
	  if (align > old_alignment
	      /* Permit an alignment power of zero if an alignment of one
		 is specified and no other alignments have been specified.  */
	      || (isym->st_value == 1 && old_alignment == 0))
	    h->root.u.c.p->alignment_power = align;
	  else
	    h->root.u.c.p->alignment_power = old_alignment;
	}

      if (is_elf_hash_table (hash_table))
	{
	  int old_flags;
	  bfd_boolean dynsym;
	  int new_flag;

	  /* Check the alignment when a common symbol is involved. This
	     can change when a common symbol is overridden by a normal
	     definition or a common symbol is ignored due to the old
	     normal definition. We need to make sure the maximum
	     alignment is maintained.  */
	  if ((old_alignment || isym->st_shndx == SHN_COMMON)
	      && h->root.type != bfd_link_hash_common)
	    {
	      unsigned int common_align;
	      unsigned int normal_align;
	      unsigned int symbol_align;
	      bfd *normal_bfd;
	      bfd *common_bfd;

	      symbol_align = ffs (h->root.u.def.value) - 1;
	      if (h->root.u.def.section->owner != NULL
		  && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
		{
		  normal_align = h->root.u.def.section->alignment_power;
		  if (normal_align > symbol_align)
		    normal_align = symbol_align;
		}
	      else
		normal_align = symbol_align;

	      if (old_alignment)
		{
		  common_align = old_alignment;
		  common_bfd = old_bfd;
		  normal_bfd = abfd;
		}
	      else
		{
		  common_align = bfd_log2 (isym->st_value);
		  common_bfd = abfd;
		  normal_bfd = old_bfd;
		}

	      if (normal_align < common_align)
		(*_bfd_error_handler)
		  (_("Warning: alignment %u of symbol `%s' in %s is smaller than %u in %s"),
		   1 << normal_align,
		   name,
		   bfd_archive_filename (normal_bfd),
		   1 << common_align,
		   bfd_archive_filename (common_bfd));
	    }

	  /* Remember the symbol size and type.  */
	  if (isym->st_size != 0
	      && (definition || h->size == 0))
	    {
	      if (h->size != 0 && h->size != isym->st_size && ! size_change_ok)
		(*_bfd_error_handler)
		  (_("Warning: size of symbol `%s' changed from %lu in %s to %lu in %s"),
		   name, (unsigned long) h->size,
		   bfd_archive_filename (old_bfd),
		   (unsigned long) isym->st_size,
		   bfd_archive_filename (abfd));

	      h->size = isym->st_size;
	    }

	  /* If this is a common symbol, then we always want H->SIZE
	     to be the size of the common symbol.  The code just above
	     won't fix the size if a common symbol becomes larger.  We
	     don't warn about a size change here, because that is
	     covered by --warn-common.  */
	  if (h->root.type == bfd_link_hash_common)
	    h->size = h->root.u.c.size;

	  if (ELF_ST_TYPE (isym->st_info) != STT_NOTYPE
	      && (definition || h->type == STT_NOTYPE))
	    {
	      if (h->type != STT_NOTYPE
		  && h->type != ELF_ST_TYPE (isym->st_info)
		  && ! type_change_ok)
		(*_bfd_error_handler)
		  (_("Warning: type of symbol `%s' changed from %d to %d in %s"),
		   name, h->type, ELF_ST_TYPE (isym->st_info),
		   bfd_archive_filename (abfd));

	      h->type = ELF_ST_TYPE (isym->st_info);
	    }

	  /* If st_other has a processor-specific meaning, specific
	     code might be needed here. We never merge the visibility
	     attribute with the one from a dynamic object.  */
	  if (bed->elf_backend_merge_symbol_attribute)
	    (*bed->elf_backend_merge_symbol_attribute) (h, isym, definition,
							dynamic);

	  if (isym->st_other != 0 && !dynamic)
	    {
	      unsigned char hvis, symvis, other, nvis;

	      /* Take the balance of OTHER from the definition.  */
	      other = (definition ? isym->st_other : h->other);
	      other &= ~ ELF_ST_VISIBILITY (-1);

	      /* Combine visibilities, using the most constraining one.  */
	      hvis   = ELF_ST_VISIBILITY (h->other);
	      symvis = ELF_ST_VISIBILITY (isym->st_other);
	      if (! hvis)
		nvis = symvis;
	      else if (! symvis)
		nvis = hvis;
	      else
		nvis = hvis < symvis ? hvis : symvis;

	      h->other = other | nvis;
	    }

	  /* Set a flag in the hash table entry indicating the type of
	     reference or definition we just found.  Keep a count of
	     the number of dynamic symbols we find.  A dynamic symbol
	     is one which is referenced or defined by both a regular
	     object and a shared object.  */
	  old_flags = h->elf_link_hash_flags;
	  dynsym = FALSE;
	  if (! dynamic)
	    {
	      if (! definition)
		{
		  new_flag = ELF_LINK_HASH_REF_REGULAR;
		  if (bind != STB_WEAK)
		    new_flag |= ELF_LINK_HASH_REF_REGULAR_NONWEAK;
		}
	      else
		new_flag = ELF_LINK_HASH_DEF_REGULAR;
	      if (! info->executable
		  || (old_flags & (ELF_LINK_HASH_DEF_DYNAMIC
				   | ELF_LINK_HASH_REF_DYNAMIC)) != 0)
		dynsym = TRUE;
	    }
	  else
	    {
	      if (! definition)
		new_flag = ELF_LINK_HASH_REF_DYNAMIC;
	      else
		new_flag = ELF_LINK_HASH_DEF_DYNAMIC;
	      if ((old_flags & (ELF_LINK_HASH_DEF_REGULAR
				| ELF_LINK_HASH_REF_REGULAR)) != 0
		  || (h->weakdef != NULL
		      && ! new_weakdef
		      && h->weakdef->dynindx != -1))
		dynsym = TRUE;
	    }

	  h->elf_link_hash_flags |= new_flag;

	  /* Check to see if we need to add an indirect symbol for
	     the default name.  */
	  if (definition || h->root.type == bfd_link_hash_common)
	    if (!_bfd_elf_add_default_symbol (abfd, info, h, name, isym,
					      &sec, &value, &dynsym,
					      override))
	      goto error_free_vers;

	  if (definition && !dynamic)
	    {
	      char *p = strchr (name, ELF_VER_CHR);
	      if (p != NULL && p[1] != ELF_VER_CHR)
		{
		  /* Queue non-default versions so that .symver x, x@@FOO
		     aliases can be checked.  */
		  if (! nondeflt_vers)
		    {
		      amt = (isymend - isym + 1)
			    * sizeof (struct elf_link_hash_entry *);
		      nondeflt_vers = bfd_malloc (amt);
		    }
		  nondeflt_vers [nondeflt_vers_cnt++] = h;
		}
	    }

	  if (dynsym && h->dynindx == -1)
	    {
	      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
		goto error_free_vers;
	      if (h->weakdef != NULL
		  && ! new_weakdef
		  && h->weakdef->dynindx == -1)
		{
		  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
		    goto error_free_vers;
		}
	    }
	  else if (dynsym && h->dynindx != -1)
	    /* If the symbol already has a dynamic index, but
	       visibility says it should not be visible, turn it into
	       a local symbol.  */
	    switch (ELF_ST_VISIBILITY (h->other))
	      {
	      case STV_INTERNAL:
	      case STV_HIDDEN:
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
		dynsym = FALSE;
		break;
	      }

	  if (!add_needed
	      && definition
	      && dynsym
	      && (h->elf_link_hash_flags
		  & ELF_LINK_HASH_REF_REGULAR) != 0)
	    {
	      int ret;
	      const char *soname = elf_dt_name (abfd);

	      /* A symbol from a library loaded via DT_NEEDED of some
		 other library is referenced by a regular object.
		 Add a DT_NEEDED entry for it.  */
	      add_needed = TRUE;
	      ret = elf_add_dt_needed_tag (info, soname, add_needed);
	      if (ret < 0)
		goto error_free_vers;

	      BFD_ASSERT (ret == 0);
	    }
	}
    }

  /* Now that all the symbols from this input file are created, handle
     .symver foo, foo@@BAR such that any relocs against foo become foo@@BAR.  */
  if (nondeflt_vers != NULL)
    {
      bfd_size_type cnt, symidx;

      for (cnt = 0; cnt < nondeflt_vers_cnt; ++cnt)
	{
	  struct elf_link_hash_entry *h = nondeflt_vers[cnt], *hi;
	  char *shortname, *p;

	  p = strchr (h->root.root.string, ELF_VER_CHR);
	  if (p == NULL
	      || (h->root.type != bfd_link_hash_defined
		  && h->root.type != bfd_link_hash_defweak))
	    continue;

	  amt = p - h->root.root.string;
	  shortname = bfd_malloc (amt + 1);
	  memcpy (shortname, h->root.root.string, amt);
	  shortname[amt] = '\0';

	  hi = (struct elf_link_hash_entry *)
	       bfd_link_hash_lookup (&hash_table->root, shortname,
				     FALSE, FALSE, FALSE);
	  if (hi != NULL
	      && hi->root.type == h->root.type
	      && hi->root.u.def.value == h->root.u.def.value
	      && hi->root.u.def.section == h->root.u.def.section)
	    {
	      (*bed->elf_backend_hide_symbol) (info, hi, TRUE);
	      hi->root.type = bfd_link_hash_indirect;
	      hi->root.u.i.link = (struct bfd_link_hash_entry *) h;
	      (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
	      sym_hash = elf_sym_hashes (abfd);
	      if (sym_hash)
		for (symidx = 0; symidx < extsymcount; ++symidx)
		  if (sym_hash[symidx] == hi)
		    {
		      sym_hash[symidx] = h;
		      break;
		    }
	    }
	  free (shortname);
	}
      free (nondeflt_vers);
      nondeflt_vers = NULL;
    }

  if (extversym != NULL)
    {
      free (extversym);
      extversym = NULL;
    }

  if (isymbuf != NULL)
    free (isymbuf);
  isymbuf = NULL;

  /* Now set the weakdefs field correctly for all the weak defined
     symbols we found.  The only way to do this is to search all the
     symbols.  Since we only need the information for non functions in
     dynamic objects, that's the only time we actually put anything on
     the list WEAKS.  We need this information so that if a regular
     object refers to a symbol defined weakly in a dynamic object, the
     real symbol in the dynamic object is also put in the dynamic
     symbols; we also must arrange for both symbols to point to the
     same memory location.  We could handle the general case of symbol
     aliasing, but a general symbol alias can only be generated in
     assembler code, handling it correctly would be very time
     consuming, and other ELF linkers don't handle general aliasing
     either.  */
  if (weaks != NULL)
    {
      struct elf_link_hash_entry **hpp;
      struct elf_link_hash_entry **hppend;
      struct elf_link_hash_entry **sorted_sym_hash;
      struct elf_link_hash_entry *h;
      size_t sym_count;

      /* Since we have to search the whole symbol list for each weak
	 defined symbol, search time for N weak defined symbols will be
	 O(N^2). Binary search will cut it down to O(NlogN).  */
      amt = extsymcount * sizeof (struct elf_link_hash_entry *);
      sorted_sym_hash = bfd_malloc (amt);
      if (sorted_sym_hash == NULL)
	goto error_return;
      sym_hash = sorted_sym_hash;
      hpp = elf_sym_hashes (abfd);
      hppend = hpp + extsymcount;
      sym_count = 0;
      for (; hpp < hppend; hpp++)
	{
	  h = *hpp;
	  if (h != NULL
	      && h->root.type == bfd_link_hash_defined
	      && h->type != STT_FUNC)
	    {
	      *sym_hash = h;
	      sym_hash++;
	      sym_count++;
	    }
	}

      qsort (sorted_sym_hash, sym_count,
	     sizeof (struct elf_link_hash_entry *),
	     elf_sort_symbol);

      while (weaks != NULL)
	{
	  struct elf_link_hash_entry *hlook;
	  asection *slook;
	  bfd_vma vlook;
	  long ilook;
	  size_t i, j, idx;

	  hlook = weaks;
	  weaks = hlook->weakdef;
	  hlook->weakdef = NULL;

	  BFD_ASSERT (hlook->root.type == bfd_link_hash_defined
		      || hlook->root.type == bfd_link_hash_defweak
		      || hlook->root.type == bfd_link_hash_common
		      || hlook->root.type == bfd_link_hash_indirect);
	  slook = hlook->root.u.def.section;
	  vlook = hlook->root.u.def.value;

	  ilook = -1;
	  i = 0;
	  j = sym_count;
	  while (i < j)
	    {
	      bfd_signed_vma vdiff;
	      idx = (i + j) / 2;
	      h = sorted_sym_hash [idx];
	      vdiff = vlook - h->root.u.def.value;
	      if (vdiff < 0)
		j = idx;
	      else if (vdiff > 0)
		i = idx + 1;
	      else
		{
		  long sdiff = slook - h->root.u.def.section;
		  if (sdiff < 0)
		    j = idx;
		  else if (sdiff > 0)
		    i = idx + 1;
		  else
		    {
		      ilook = idx;
		      break;
		    }
		}
	    }

	  /* We didn't find a value/section match.  */
	  if (ilook == -1)
	    continue;

	  for (i = ilook; i < sym_count; i++)
	    {
	      h = sorted_sym_hash [i];

	      /* Stop if value or section doesn't match.  */
	      if (h->root.u.def.value != vlook
		  || h->root.u.def.section != slook)
		break;
	      else if (h != hlook)
		{
		  hlook->weakdef = h;

		  /* If the weak definition is in the list of dynamic
		     symbols, make sure the real definition is put
		     there as well.  */
		  if (hlook->dynindx != -1 && h->dynindx == -1)
		    {
		      if (! _bfd_elf_link_record_dynamic_symbol (info,
								 h))
			goto error_return;
		    }

		  /* If the real definition is in the list of dynamic
		     symbols, make sure the weak definition is put
		     there as well.  If we don't do this, then the
		     dynamic loader might not merge the entries for the
		     real definition and the weak definition.  */
		  if (h->dynindx != -1 && hlook->dynindx == -1)
		    {
		      if (! _bfd_elf_link_record_dynamic_symbol (info,
								 hlook))
			goto error_return;
		    }
		  break;
		}
	    }
	}

      free (sorted_sym_hash);
    }

  /* If this object is the same format as the output object, and it is
     not a shared library, then let the backend look through the
     relocs.

     This is required to build global offset table entries and to
     arrange for dynamic relocs.  It is not required for the
     particular common case of linking non PIC code, even when linking
     against shared libraries, but unfortunately there is no way of
     knowing whether an object file has been compiled PIC or not.
     Looking through the relocs is not particularly time consuming.
     The problem is that we must either (1) keep the relocs in memory,
     which causes the linker to require additional runtime memory or
     (2) read the relocs twice from the input file, which wastes time.
     This would be a good case for using mmap.

     I have no idea how to handle linking PIC code into a file of a
     different format.  It probably can't be done.  */
  check_relocs = get_elf_backend_data (abfd)->check_relocs;
  if (! dynamic
      && is_elf_hash_table (hash_table)
      && hash_table->root.creator == abfd->xvec
      && check_relocs != NULL)
    {
      asection *o;

      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  Elf_Internal_Rela *internal_relocs;
	  bfd_boolean ok;

	  if ((o->flags & SEC_RELOC) == 0
	      || o->reloc_count == 0
	      || ((info->strip == strip_all || info->strip == strip_debugger)
		  && (o->flags & SEC_DEBUGGING) != 0)
	      || bfd_is_abs_section (o->output_section))
	    continue;

	  internal_relocs = _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
						       info->keep_memory);
	  if (internal_relocs == NULL)
	    goto error_return;

	  ok = (*check_relocs) (abfd, info, o, internal_relocs);

	  if (elf_section_data (o)->relocs != internal_relocs)
	    free (internal_relocs);

	  if (! ok)
	    goto error_return;
	}
    }

  /* If this is a non-traditional link, try to optimize the handling
     of the .stab/.stabstr sections.  */
  if (! dynamic
      && ! info->traditional_format
      && is_elf_hash_table (hash_table)
      && (info->strip != strip_all && info->strip != strip_debugger))
    {
      asection *stabstr;

      stabstr = bfd_get_section_by_name (abfd, ".stabstr");
      if (stabstr != NULL)
	{
	  bfd_size_type string_offset = 0;
	  asection *stab;

	  for (stab = abfd->sections; stab; stab = stab->next)
	    if (strncmp (".stab", stab->name, 5) == 0
		&& (!stab->name[5] ||
		    (stab->name[5] == '.' && ISDIGIT (stab->name[6])))
		&& (stab->flags & SEC_MERGE) == 0
		&& !bfd_is_abs_section (stab->output_section))
	      {
		struct bfd_elf_section_data *secdata;

		secdata = elf_section_data (stab);
		if (! _bfd_link_section_stabs (abfd,
					       & hash_table->stab_info,
					       stab, stabstr,
					       &secdata->sec_info,
					       &string_offset))
		  goto error_return;
		if (secdata->sec_info)
		  stab->sec_info_type = ELF_INFO_TYPE_STABS;
	    }
	}
    }

  if (! info->relocatable
      && ! dynamic
      && is_elf_hash_table (hash_table))
    {
      asection *s;

      for (s = abfd->sections; s != NULL; s = s->next)
	if ((s->flags & SEC_MERGE) != 0
	    && !bfd_is_abs_section (s->output_section))
	  {
	    struct bfd_elf_section_data *secdata;

	    secdata = elf_section_data (s);
	    if (! _bfd_merge_section (abfd,
				      & hash_table->merge_info,
				      s, &secdata->sec_info))
	      goto error_return;
	    else if (secdata->sec_info)
	      s->sec_info_type = ELF_INFO_TYPE_MERGE;
	  }
    }

  if (is_elf_hash_table (hash_table))
    {
      /* Add this bfd to the loaded list.  */
      struct elf_link_loaded_list *n;

      n = bfd_alloc (abfd, sizeof (struct elf_link_loaded_list));
      if (n == NULL)
	goto error_return;
      n->abfd = abfd;
      n->next = hash_table->loaded;
      hash_table->loaded = n;
    }

  return TRUE;

 error_free_vers:
  if (nondeflt_vers != NULL)
    free (nondeflt_vers);
  if (extversym != NULL)
    free (extversym);
 error_free_sym:
  if (isymbuf != NULL)
    free (isymbuf);
 error_return:
  return FALSE;
}

/* Add symbols from an ELF archive file to the linker hash table.  We
   don't use _bfd_generic_link_add_archive_symbols because of a
   problem which arises on UnixWare.  The UnixWare libc.so is an
   archive which includes an entry libc.so.1 which defines a bunch of
   symbols.  The libc.so archive also includes a number of other
   object files, which also define symbols, some of which are the same
   as those defined in libc.so.1.  Correct linking requires that we
   consider each object file in turn, and include it if it defines any
   symbols we need.  _bfd_generic_link_add_archive_symbols does not do
   this; it looks through the list of undefined symbols, and includes
   any object file which defines them.  When this algorithm is used on
   UnixWare, it winds up pulling in libc.so.1 early and defining a
   bunch of symbols.  This means that some of the other objects in the
   archive are not included in the link, which is incorrect since they
   precede libc.so.1 in the archive.

   Fortunately, ELF archive handling is simpler than that done by
   _bfd_generic_link_add_archive_symbols, which has to allow for a.out
   oddities.  In ELF, if we find a symbol in the archive map, and the
   symbol is currently undefined, we know that we must pull in that
   object file.

   Unfortunately, we do have to make multiple passes over the symbol
   table until nothing further is resolved.  */

static bfd_boolean
elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
{
  symindex c;
  bfd_boolean *defined = NULL;
  bfd_boolean *included = NULL;
  carsym *symdefs;
  bfd_boolean loop;
  bfd_size_type amt;

  if (! bfd_has_map (abfd))
    {
      /* An empty archive is a special case.  */
      if (bfd_openr_next_archived_file (abfd, NULL) == NULL)
	return TRUE;
      bfd_set_error (bfd_error_no_armap);
      return FALSE;
    }

  /* Keep track of all symbols we know to be already defined, and all
     files we know to be already included.  This is to speed up the
     second and subsequent passes.  */
  c = bfd_ardata (abfd)->symdef_count;
  if (c == 0)
    return TRUE;
  amt = c;
  amt *= sizeof (bfd_boolean);
  defined = bfd_zmalloc (amt);
  included = bfd_zmalloc (amt);
  if (defined == NULL || included == NULL)
    goto error_return;

  symdefs = bfd_ardata (abfd)->symdefs;

  do
    {
      file_ptr last;
      symindex i;
      carsym *symdef;
      carsym *symdefend;

      loop = FALSE;
      last = -1;

      symdef = symdefs;
      symdefend = symdef + c;
      for (i = 0; symdef < symdefend; symdef++, i++)
	{
	  struct elf_link_hash_entry *h;
	  bfd *element;
	  struct bfd_link_hash_entry *undefs_tail;
	  symindex mark;

	  if (defined[i] || included[i])
	    continue;
	  if (symdef->file_offset == last)
	    {
	      included[i] = TRUE;
	      continue;
	    }

	  h = elf_link_hash_lookup (elf_hash_table (info), symdef->name,
				    FALSE, FALSE, FALSE);

	  if (h == NULL)
	    {
	      char *p, *copy;
	      size_t len, first;

	      /* If this is a default version (the name contains @@@@),
		 look up the symbol again with only one `@@' as well
		 as without the version.  The effect is that references
		 to the symbol with and without the version will be
		 matched by the default symbol in the archive.  */

	      p = strchr (symdef->name, ELF_VER_CHR);
	      if (p == NULL || p[1] != ELF_VER_CHR)
		continue;

	      /* First check with only one `@@'.  */
	      len = strlen (symdef->name);
	      copy = bfd_alloc (abfd, len);
	      if (copy == NULL)
		goto error_return;
	      first = p - symdef->name + 1;
	      memcpy (copy, symdef->name, first);
	      memcpy (copy + first, symdef->name + first + 1, len - first);

	      h = elf_link_hash_lookup (elf_hash_table (info), copy,
					FALSE, FALSE, FALSE);

	      if (h == NULL)
		{
		  /* We also need to check references to the symbol
		     without the version.  */

		  copy[first - 1] = '\0';
		  h = elf_link_hash_lookup (elf_hash_table (info),
					    copy, FALSE, FALSE, FALSE);
		}

	      bfd_release (abfd, copy);
	    }

	  if (h == NULL)
	    continue;

	  if (h->root.type == bfd_link_hash_common)
	    {
	      /* We currently have a common symbol.  The archive map contains
		 a reference to this symbol, so we may want to include it.  We
		 only want to include it however, if this archive element
		 contains a definition of the symbol, not just another common
		 declaration of it.

		 Unfortunately some archivers (including GNU ar) will put
		 declarations of common symbols into their archive maps, as
		 well as real definitions, so we cannot just go by the archive
		 map alone.  Instead we must read in the element's symbol
		 table and check that to see what kind of symbol definition
		 this is.  */
	      if (! elf_link_is_defined_archive_symbol (abfd, symdef))
		continue;
	    }
	  else if (h->root.type != bfd_link_hash_undefined)
	    {
	      if (h->root.type != bfd_link_hash_undefweak)
		defined[i] = TRUE;
	      continue;
	    }

	  /* We need to include this archive member.  */
	  element = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
	  if (element == NULL)
	    goto error_return;

	  if (! bfd_check_format (element, bfd_object))
	    goto error_return;

	  /* Doublecheck that we have not included this object
	     already--it should be impossible, but there may be
	     something wrong with the archive.  */
	  if (element->archive_pass != 0)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }
	  element->archive_pass = 1;

	  undefs_tail = info->hash->undefs_tail;

	  if (! (*info->callbacks->add_archive_element) (info, element,
							 symdef->name))
	    goto error_return;
	  if (! bfd_link_add_symbols (element, info))
	    goto error_return;

	  /* If there are any new undefined symbols, we need to make
	     another pass through the archive in order to see whether
	     they can be defined.  FIXME: This isn't perfect, because
	     common symbols wind up on undefs_tail and because an
	     undefined symbol which is defined later on in this pass
	     does not require another pass.  This isn't a bug, but it
	     does make the code less efficient than it could be.  */
	  if (undefs_tail != info->hash->undefs_tail)
	    loop = TRUE;

	  /* Look backward to mark all symbols from this object file
	     which we have already seen in this pass.  */
	  mark = i;
	  do
	    {
	      included[mark] = TRUE;
	      if (mark == 0)
		break;
	      --mark;
	    }
	  while (symdefs[mark].file_offset == symdef->file_offset);

	  /* We mark subsequent symbols from this object file as we go
	     on through the loop.  */
	  last = symdef->file_offset;
	}
    }
  while (loop);

  free (defined);
  free (included);

  return TRUE;

 error_return:
  if (defined != NULL)
    free (defined);
  if (included != NULL)
    free (included);
  return FALSE;
}

/* Given an ELF BFD, add symbols to the global hash table as
   appropriate.  */

bfd_boolean
bfd_elf_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return elf_link_add_object_symbols (abfd, info);
    case bfd_archive:
      return elf_link_add_archive_symbols (abfd, info);
    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}

/* This function will be called though elf_link_hash_traverse to store
   all hash value of the exported symbols in an array.  */

static bfd_boolean
elf_collect_hash_codes (struct elf_link_hash_entry *h, void *data)
{
  unsigned long **valuep = data;
  const char *name;
  char *p;
  unsigned long ha;
  char *alc = NULL;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->dynindx == -1)
    return TRUE;

  name = h->root.root.string;
  p = strchr (name, ELF_VER_CHR);
  if (p != NULL)
    {
      alc = bfd_malloc (p - name + 1);
      memcpy (alc, name, p - name);
      alc[p - name] = '\0';
      name = alc;
    }

  /* Compute the hash value.  */
  ha = bfd_elf_hash (name);

  /* Store the found hash value in the array given as the argument.  */
  *(*valuep)++ = ha;

  /* And store it in the struct so that we can put it in the hash table
     later.  */
  h->elf_hash_value = ha;

  if (alc != NULL)
    free (alc);

  return TRUE;
}

/* Array used to determine the number of hash table buckets to use
   based on the number of symbols there are.  If there are fewer than
   3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,
   fewer than 37 we use 17 buckets, and so forth.  We never use more
   than 32771 buckets.  */

static const size_t elf_buckets[] =
{
  1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209,
  16411, 32771, 0
};

/* Compute bucket count for hashing table.  We do not use a static set
   of possible tables sizes anymore.  Instead we determine for all
   possible reasonable sizes of the table the outcome (i.e., the
   number of collisions etc) and choose the best solution.  The
   weighting functions are not too simple to allow the table to grow
   without bounds.  Instead one of the weighting factors is the size.
   Therefore the result is always a good payoff between few collisions
   (= short chain lengths) and table size.  */
static size_t
compute_bucket_count (struct bfd_link_info *info)
{
  size_t dynsymcount = elf_hash_table (info)->dynsymcount;
  size_t best_size = 0;
  unsigned long int *hashcodes;
  unsigned long int *hashcodesp;
  unsigned long int i;
  bfd_size_type amt;

  /* Compute the hash values for all exported symbols.  At the same
     time store the values in an array so that we could use them for
     optimizations.  */
  amt = dynsymcount;
  amt *= sizeof (unsigned long int);
  hashcodes = bfd_malloc (amt);
  if (hashcodes == NULL)
    return 0;
  hashcodesp = hashcodes;

  /* Put all hash values in HASHCODES.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_collect_hash_codes, &hashcodesp);

  /* We have a problem here.  The following code to optimize the table
     size requires an integer type with more the 32 bits.  If
     BFD_HOST_U_64_BIT is set we know about such a type.  */
#ifdef BFD_HOST_U_64_BIT
  if (info->optimize)
    {
      unsigned long int nsyms = hashcodesp - hashcodes;
      size_t minsize;
      size_t maxsize;
      BFD_HOST_U_64_BIT best_chlen = ~((BFD_HOST_U_64_BIT) 0);
      unsigned long int *counts ;
      bfd *dynobj = elf_hash_table (info)->dynobj;
      const struct elf_backend_data *bed = get_elf_backend_data (dynobj);

      /* Possible optimization parameters: if we have NSYMS symbols we say
	 that the hashing table must at least have NSYMS/4 and at most
	 2*NSYMS buckets.  */
      minsize = nsyms / 4;
      if (minsize == 0)
	minsize = 1;
      best_size = maxsize = nsyms * 2;

      /* Create array where we count the collisions in.  We must use bfd_malloc
	 since the size could be large.  */
      amt = maxsize;
      amt *= sizeof (unsigned long int);
      counts = bfd_malloc (amt);
      if (counts == NULL)
	{
	  free (hashcodes);
	  return 0;
	}

      /* Compute the "optimal" size for the hash table.  The criteria is a
	 minimal chain length.  The minor criteria is (of course) the size
	 of the table.  */
      for (i = minsize; i < maxsize; ++i)
	{
	  /* Walk through the array of hashcodes and count the collisions.  */
	  BFD_HOST_U_64_BIT max;
	  unsigned long int j;
	  unsigned long int fact;

	  memset (counts, '\0', i * sizeof (unsigned long int));

	  /* Determine how often each hash bucket is used.  */
	  for (j = 0; j < nsyms; ++j)
	    ++counts[hashcodes[j] % i];

	  /* For the weight function we need some information about the
	     pagesize on the target.  This is information need not be 100%
	     accurate.  Since this information is not available (so far) we
	     define it here to a reasonable default value.  If it is crucial
	     to have a better value some day simply define this value.  */
# ifndef BFD_TARGET_PAGESIZE
#  define BFD_TARGET_PAGESIZE	(4096)
# endif

	  /* We in any case need 2 + NSYMS entries for the size values and
	     the chains.  */
	  max = (2 + nsyms) * (bed->s->arch_size / 8);

# if 1
	  /* Variant 1: optimize for short chains.  We add the squares
	     of all the chain lengths (which favors many small chain
	     over a few long chains).  */
	  for (j = 0; j < i; ++j)
	    max += counts[j] * counts[j];

	  /* This adds penalties for the overall size of the table.  */
	  fact = i / (BFD_TARGET_PAGESIZE / (bed->s->arch_size / 8)) + 1;
	  max *= fact * fact;
# else
	  /* Variant 2: Optimize a lot more for small table.  Here we
	     also add squares of the size but we also add penalties for
	     empty slots (the +1 term).  */
	  for (j = 0; j < i; ++j)
	    max += (1 + counts[j]) * (1 + counts[j]);

	  /* The overall size of the table is considered, but not as
	     strong as in variant 1, where it is squared.  */
	  fact = i / (BFD_TARGET_PAGESIZE / (bed->s->arch_size / 8)) + 1;
	  max *= fact;
# endif

	  /* Compare with current best results.  */
	  if (max < best_chlen)
	    {
	      best_chlen = max;
	      best_size = i;
	    }
	}

      free (counts);
    }
  else
#endif /* defined (BFD_HOST_U_64_BIT) */
    {
      /* This is the fallback solution if no 64bit type is available or if we
	 are not supposed to spend much time on optimizations.  We select the
	 bucket count using a fixed set of numbers.  */
      for (i = 0; elf_buckets[i] != 0; i++)
	{
	  best_size = elf_buckets[i];
	  if (dynsymcount < elf_buckets[i + 1])
	    break;
	}
    }

  /* Free the arrays we needed.  */
  free (hashcodes);

  return best_size;
}

/* Set up the sizes and contents of the ELF dynamic sections.  This is
   called by the ELF linker emulation before_allocation routine.  We
   must set the sizes of the sections before the linker sets the
   addresses of the various sections.  */

bfd_boolean
bfd_elf_size_dynamic_sections (bfd *output_bfd,
			       const char *soname,
			       const char *rpath,
			       const char *filter_shlib,
			       const char * const *auxiliary_filters,
			       struct bfd_link_info *info,
			       asection **sinterpptr,
			       struct bfd_elf_version_tree *verdefs)
{
  bfd_size_type soname_indx;
  bfd *dynobj;
  const struct elf_backend_data *bed;
  struct elf_assign_sym_version_info asvinfo;

  *sinterpptr = NULL;

  soname_indx = (bfd_size_type) -1;

  if (!is_elf_hash_table (info->hash))
    return TRUE;

  if (info->execstack)
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;
  else if (info->noexecstack)
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W;
  else
    {
      bfd *inputobj;
      asection *notesec = NULL;
      int exec = 0;

      for (inputobj = info->input_bfds;
	   inputobj;
	   inputobj = inputobj->link_next)
	{
	  asection *s;

	  if (inputobj->flags & DYNAMIC)
	    continue;
	  s = bfd_get_section_by_name (inputobj, ".note.GNU-stack");
	  if (s)
	    {
	      if (s->flags & SEC_CODE)
		exec = PF_X;
	      notesec = s;
	    }
	  else
	    exec = PF_X;
	}
      if (notesec)
	{
	  elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | exec;
	  if (exec && info->relocatable
	      && notesec->output_section != bfd_abs_section_ptr)
	    notesec->output_section->flags |= SEC_CODE;
	}
    }

  /* Any syms created from now on start with -1 in
     got.refcount/offset and plt.refcount/offset.  */
  elf_hash_table (info)->init_refcount = elf_hash_table (info)->init_offset;

  /* The backend may have to create some sections regardless of whether
     we're dynamic or not.  */
  bed = get_elf_backend_data (output_bfd);
  if (bed->elf_backend_always_size_sections
      && ! (*bed->elf_backend_always_size_sections) (output_bfd, info))
    return FALSE;

  dynobj = elf_hash_table (info)->dynobj;

  /* If there were no dynamic objects in the link, there is nothing to
     do here.  */
  if (dynobj == NULL)
    return TRUE;

  if (! _bfd_elf_maybe_strip_eh_frame_hdr (info))
    return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      struct elf_info_failed eif;
      struct elf_link_hash_entry *h;
      asection *dynstr;
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;
      bfd_boolean all_defined;

      *sinterpptr = bfd_get_section_by_name (dynobj, ".interp");
      BFD_ASSERT (*sinterpptr != NULL || !info->executable);

      if (soname != NULL)
	{
	  soname_indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					     soname, TRUE);
	  if (soname_indx == (bfd_size_type) -1
	      || !_bfd_elf_add_dynamic_entry (info, DT_SONAME, soname_indx))
	    return FALSE;
	}

      if (info->symbolic)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_SYMBOLIC, 0))
	    return FALSE;
	  info->flags |= DF_SYMBOLIC;
	}

      if (rpath != NULL)
	{
	  bfd_size_type indx;

	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, rpath,
				      TRUE);
	  if (indx == (bfd_size_type) -1
	      || !_bfd_elf_add_dynamic_entry (info, DT_RPATH, indx))
	    return FALSE;

	  if  (info->new_dtags)
	    {
	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr, indx);
	      if (!_bfd_elf_add_dynamic_entry (info, DT_RUNPATH, indx))
		return FALSE;
	    }
	}

      if (filter_shlib != NULL)
	{
	  bfd_size_type indx;

	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
				      filter_shlib, TRUE);
	  if (indx == (bfd_size_type) -1
	      || !_bfd_elf_add_dynamic_entry (info, DT_FILTER, indx))
	    return FALSE;
	}

      if (auxiliary_filters != NULL)
	{
	  const char * const *p;

	  for (p = auxiliary_filters; *p != NULL; p++)
	    {
	      bfd_size_type indx;

	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					  *p, TRUE);
	      if (indx == (bfd_size_type) -1
		  || !_bfd_elf_add_dynamic_entry (info, DT_AUXILIARY, indx))
		return FALSE;
	    }
	}

      eif.info = info;
      eif.verdefs = verdefs;
      eif.failed = FALSE;

      /* If we are supposed to export all symbols into the dynamic symbol
	 table (this is not the normal case), then do so.  */
      if (info->export_dynamic)
	{
	  elf_link_hash_traverse (elf_hash_table (info),
				  _bfd_elf_export_symbol,
				  &eif);
	  if (eif.failed)
	    return FALSE;
	}

      /* Make all global versions with definition.  */
      for (t = verdefs; t != NULL; t = t->next)
	for (d = t->globals.list; d != NULL; d = d->next)
	  if (!d->symver && d->symbol)
	    {
	      const char *verstr, *name;
	      size_t namelen, verlen, newlen;
	      char *newname, *p;
	      struct elf_link_hash_entry *newh;

	      name = d->symbol;
	      namelen = strlen (name);
	      verstr = t->name;
	      verlen = strlen (verstr);
	      newlen = namelen + verlen + 3;

	      newname = bfd_malloc (newlen);
	      if (newname == NULL)
		return FALSE;
	      memcpy (newname, name, namelen);

	      /* Check the hidden versioned definition.  */
	      p = newname + namelen;
	      *p++ = ELF_VER_CHR;
	      memcpy (p, verstr, verlen + 1);
	      newh = elf_link_hash_lookup (elf_hash_table (info),
					   newname, FALSE, FALSE,
					   FALSE);
	      if (newh == NULL
		  || (newh->root.type != bfd_link_hash_defined
		      && newh->root.type != bfd_link_hash_defweak))
		{
		  /* Check the default versioned definition.  */
		  *p++ = ELF_VER_CHR;
		  memcpy (p, verstr, verlen + 1);
		  newh = elf_link_hash_lookup (elf_hash_table (info),
					       newname, FALSE, FALSE,
					       FALSE);
		}
	      free (newname);

	      /* Mark this version if there is a definition and it is
		 not defined in a shared object.  */
	      if (newh != NULL
		  && ((newh->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
		  && (newh->root.type == bfd_link_hash_defined
		      || newh->root.type == bfd_link_hash_defweak))
		d->symver = 1;
	    }

      /* Attach all the symbols to their version information.  */
      asvinfo.output_bfd = output_bfd;
      asvinfo.info = info;
      asvinfo.verdefs = verdefs;
      asvinfo.failed = FALSE;

      elf_link_hash_traverse (elf_hash_table (info),
			      _bfd_elf_link_assign_sym_version,
			      &asvinfo);
      if (asvinfo.failed)
	return FALSE;

      if (!info->allow_undefined_version)
	{
	  /* Check if all global versions have a definition.  */
	  all_defined = TRUE;
	  for (t = verdefs; t != NULL; t = t->next)
	    for (d = t->globals.list; d != NULL; d = d->next)
	      if (!d->symver && !d->script)
		{
		  (*_bfd_error_handler)
		    (_("%s: undefined version: %s"),
		     d->pattern, t->name);
		  all_defined = FALSE;
		}

	  if (!all_defined)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}

      /* Find all symbols which were defined in a dynamic object and make
	 the backend pick a reasonable value for them.  */
      elf_link_hash_traverse (elf_hash_table (info),
			      _bfd_elf_adjust_dynamic_symbol,
			      &eif);
      if (eif.failed)
	return FALSE;

      /* Add some entries to the .dynamic section.  We fill in some of the
	 values later, in elf_bfd_final_link, but we must add the entries
	 now so that we know the final size of the .dynamic section.  */

      /* If there are initialization and/or finalization functions to
	 call then add the corresponding DT_INIT/DT_FINI entries.  */
      h = (info->init_function
	   ? elf_link_hash_lookup (elf_hash_table (info),
				   info->init_function, FALSE,
				   FALSE, FALSE)
	   : NULL);
      if (h != NULL
	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_INIT, 0))
	    return FALSE;
	}
      h = (info->fini_function
	   ? elf_link_hash_lookup (elf_hash_table (info),
				   info->fini_function, FALSE,
				   FALSE, FALSE)
	   : NULL);
      if (h != NULL
	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FINI, 0))
	    return FALSE;
	}

      if (bfd_get_section_by_name (output_bfd, ".preinit_array") != NULL)
	{
	  /* DT_PREINIT_ARRAY is not allowed in shared library.  */
	  if (! info->executable)
	    {
	      bfd *sub;
	      asection *o;

	      for (sub = info->input_bfds; sub != NULL;
		   sub = sub->link_next)
		for (o = sub->sections; o != NULL; o = o->next)
		  if (elf_section_data (o)->this_hdr.sh_type
		      == SHT_PREINIT_ARRAY)
		    {
		      (*_bfd_error_handler)
			(_("%s: .preinit_array section is not allowed in DSO"),
			 bfd_archive_filename (sub));
		      break;
		    }

	      bfd_set_error (bfd_error_nonrepresentable_section);
	      return FALSE;
	    }

	  if (!_bfd_elf_add_dynamic_entry (info, DT_PREINIT_ARRAY, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_PREINIT_ARRAYSZ, 0))
	    return FALSE;
	}
      if (bfd_get_section_by_name (output_bfd, ".init_array") != NULL)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_INIT_ARRAY, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_INIT_ARRAYSZ, 0))
	    return FALSE;
	}
      if (bfd_get_section_by_name (output_bfd, ".fini_array") != NULL)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FINI_ARRAY, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_FINI_ARRAYSZ, 0))
	    return FALSE;
	}

      dynstr = bfd_get_section_by_name (dynobj, ".dynstr");
      /* If .dynstr is excluded from the link, we don't want any of
	 these tags.  Strictly, we should be checking each section
	 individually;  This quick check covers for the case where
	 someone does a /DISCARD/ : { *(*) }.  */
      if (dynstr != NULL && dynstr->output_section != bfd_abs_section_ptr)
	{
	  bfd_size_type strsize;

	  strsize = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
	  if (!_bfd_elf_add_dynamic_entry (info, DT_HASH, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_STRTAB, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_SYMTAB, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_STRSZ, strsize)
	      || !_bfd_elf_add_dynamic_entry (info, DT_SYMENT,
					      bed->s->sizeof_sym))
	    return FALSE;
	}
    }

  /* The backend must work out the sizes of all the other dynamic
     sections.  */
  if (bed->elf_backend_size_dynamic_sections
      && ! (*bed->elf_backend_size_dynamic_sections) (output_bfd, info))
    return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd_size_type dynsymcount;
      asection *s;
      size_t bucketcount = 0;
      size_t hash_entry_size;
      unsigned int dtagcount;

      /* Set up the version definition section.  */
      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
      BFD_ASSERT (s != NULL);

      /* We may have created additional version definitions if we are
	 just linking a regular application.  */
      verdefs = asvinfo.verdefs;

      /* Skip anonymous version tag.  */
      if (verdefs != NULL && verdefs->vernum == 0)
	verdefs = verdefs->next;

      if (verdefs == NULL)
	_bfd_strip_section_from_output (info, s);
      else
	{
	  unsigned int cdefs;
	  bfd_size_type size;
	  struct bfd_elf_version_tree *t;
	  bfd_byte *p;
	  Elf_Internal_Verdef def;
	  Elf_Internal_Verdaux defaux;

	  cdefs = 0;
	  size = 0;

	  /* Make space for the base version.  */
	  size += sizeof (Elf_External_Verdef);
	  size += sizeof (Elf_External_Verdaux);
	  ++cdefs;

	  for (t = verdefs; t != NULL; t = t->next)
	    {
	      struct bfd_elf_version_deps *n;

	      size += sizeof (Elf_External_Verdef);
	      size += sizeof (Elf_External_Verdaux);
	      ++cdefs;

	      for (n = t->deps; n != NULL; n = n->next)
		size += sizeof (Elf_External_Verdaux);
	    }

	  s->_raw_size = size;
	  s->contents = bfd_alloc (output_bfd, s->_raw_size);
	  if (s->contents == NULL && s->_raw_size != 0)
	    return FALSE;

	  /* Fill in the version definition section.  */

	  p = s->contents;

	  def.vd_version = VER_DEF_CURRENT;
	  def.vd_flags = VER_FLG_BASE;
	  def.vd_ndx = 1;
	  def.vd_cnt = 1;
	  def.vd_aux = sizeof (Elf_External_Verdef);
	  def.vd_next = (sizeof (Elf_External_Verdef)
			 + sizeof (Elf_External_Verdaux));

	  if (soname_indx != (bfd_size_type) -1)
	    {
	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
				      soname_indx);
	      def.vd_hash = bfd_elf_hash (soname);
	      defaux.vda_name = soname_indx;
	    }
	  else
	    {
	      const char *name;
	      bfd_size_type indx;

	      name = basename (output_bfd->filename);
	      def.vd_hash = bfd_elf_hash (name);
	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					  name, FALSE);
	      if (indx == (bfd_size_type) -1)
		return FALSE;
	      defaux.vda_name = indx;
	    }
	  defaux.vda_next = 0;

	  _bfd_elf_swap_verdef_out (output_bfd, &def,
				    (Elf_External_Verdef *) p);
	  p += sizeof (Elf_External_Verdef);
	  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
				     (Elf_External_Verdaux *) p);
	  p += sizeof (Elf_External_Verdaux);

	  for (t = verdefs; t != NULL; t = t->next)
	    {
	      unsigned int cdeps;
	      struct bfd_elf_version_deps *n;
	      struct elf_link_hash_entry *h;
	      struct bfd_link_hash_entry *bh;

	      cdeps = 0;
	      for (n = t->deps; n != NULL; n = n->next)
		++cdeps;

	      /* Add a symbol representing this version.  */
	      bh = NULL;
	      if (! (_bfd_generic_link_add_one_symbol
		     (info, dynobj, t->name, BSF_GLOBAL, bfd_abs_section_ptr,
		      0, NULL, FALSE,
		      get_elf_backend_data (dynobj)->collect, &bh)))
		return FALSE;
	      h = (struct elf_link_hash_entry *) bh;
	      h->elf_link_hash_flags &= ~ ELF_LINK_NON_ELF;
	      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	      h->type = STT_OBJECT;
	      h->verinfo.vertree = t;

	      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;

	      def.vd_version = VER_DEF_CURRENT;
	      def.vd_flags = 0;
	      if (t->globals.list == NULL
		  && t->locals.list == NULL
		  && ! t->used)
		def.vd_flags |= VER_FLG_WEAK;
	      def.vd_ndx = t->vernum + 1;
	      def.vd_cnt = cdeps + 1;
	      def.vd_hash = bfd_elf_hash (t->name);
	      def.vd_aux = sizeof (Elf_External_Verdef);
	      def.vd_next = 0;
	      if (t->next != NULL)
		def.vd_next = (sizeof (Elf_External_Verdef)
			       + (cdeps + 1) * sizeof (Elf_External_Verdaux));

	      _bfd_elf_swap_verdef_out (output_bfd, &def,
					(Elf_External_Verdef *) p);
	      p += sizeof (Elf_External_Verdef);

	      defaux.vda_name = h->dynstr_index;
	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
				      h->dynstr_index);
	      defaux.vda_next = 0;
	      if (t->deps != NULL)
		defaux.vda_next = sizeof (Elf_External_Verdaux);
	      t->name_indx = defaux.vda_name;

	      _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
					 (Elf_External_Verdaux *) p);
	      p += sizeof (Elf_External_Verdaux);

	      for (n = t->deps; n != NULL; n = n->next)
		{
		  if (n->version_needed == NULL)
		    {
		      /* This can happen if there was an error in the
			 version script.  */
		      defaux.vda_name = 0;
		    }
		  else
		    {
		      defaux.vda_name = n->version_needed->name_indx;
		      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
					      defaux.vda_name);
		    }
		  if (n->next == NULL)
		    defaux.vda_next = 0;
		  else
		    defaux.vda_next = sizeof (Elf_External_Verdaux);

		  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
					     (Elf_External_Verdaux *) p);
		  p += sizeof (Elf_External_Verdaux);
		}
	    }

	  if (!_bfd_elf_add_dynamic_entry (info, DT_VERDEF, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_VERDEFNUM, cdefs))
	    return FALSE;

	  elf_tdata (output_bfd)->cverdefs = cdefs;
	}

      if ((info->new_dtags && info->flags) || (info->flags & DF_STATIC_TLS))
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FLAGS, info->flags))
	    return FALSE;
	}
      else if (info->flags & DF_BIND_NOW)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_BIND_NOW, 0))
	    return FALSE;
	}

      if (info->flags_1)
	{
	  if (info->executable)
	    info->flags_1 &= ~ (DF_1_INITFIRST
				| DF_1_NODELETE
				| DF_1_NOOPEN);
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FLAGS_1, info->flags_1))
	    return FALSE;
	}

      /* Work out the size of the version reference section.  */

      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
      BFD_ASSERT (s != NULL);
      {
	struct elf_find_verdep_info sinfo;

	sinfo.output_bfd = output_bfd;
	sinfo.info = info;
	sinfo.vers = elf_tdata (output_bfd)->cverdefs;
	if (sinfo.vers == 0)
	  sinfo.vers = 1;
	sinfo.failed = FALSE;

	elf_link_hash_traverse (elf_hash_table (info),
				_bfd_elf_link_find_version_dependencies,
				&sinfo);

	if (elf_tdata (output_bfd)->verref == NULL)
	  _bfd_strip_section_from_output (info, s);
	else
	  {
	    Elf_Internal_Verneed *t;
	    unsigned int size;
	    unsigned int crefs;
	    bfd_byte *p;

	    /* Build the version definition section.  */
	    size = 0;
	    crefs = 0;
	    for (t = elf_tdata (output_bfd)->verref;
		 t != NULL;
		 t = t->vn_nextref)
	      {
		Elf_Internal_Vernaux *a;

		size += sizeof (Elf_External_Verneed);
		++crefs;
		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  size += sizeof (Elf_External_Vernaux);
	      }

	    s->_raw_size = size;
	    s->contents = bfd_alloc (output_bfd, s->_raw_size);
	    if (s->contents == NULL)
	      return FALSE;

	    p = s->contents;
	    for (t = elf_tdata (output_bfd)->verref;
		 t != NULL;
		 t = t->vn_nextref)
	      {
		unsigned int caux;
		Elf_Internal_Vernaux *a;
		bfd_size_type indx;

		caux = 0;
		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  ++caux;

		t->vn_version = VER_NEED_CURRENT;
		t->vn_cnt = caux;
		indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					    elf_dt_name (t->vn_bfd) != NULL
					    ? elf_dt_name (t->vn_bfd)
					    : basename (t->vn_bfd->filename),
					    FALSE);
		if (indx == (bfd_size_type) -1)
		  return FALSE;
		t->vn_file = indx;
		t->vn_aux = sizeof (Elf_External_Verneed);
		if (t->vn_nextref == NULL)
		  t->vn_next = 0;
		else
		  t->vn_next = (sizeof (Elf_External_Verneed)
				+ caux * sizeof (Elf_External_Vernaux));

		_bfd_elf_swap_verneed_out (output_bfd, t,
					   (Elf_External_Verneed *) p);
		p += sizeof (Elf_External_Verneed);

		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  {
		    a->vna_hash = bfd_elf_hash (a->vna_nodename);
		    indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
						a->vna_nodename, FALSE);
		    if (indx == (bfd_size_type) -1)
		      return FALSE;
		    a->vna_name = indx;
		    if (a->vna_nextptr == NULL)
		      a->vna_next = 0;
		    else
		      a->vna_next = sizeof (Elf_External_Vernaux);

		    _bfd_elf_swap_vernaux_out (output_bfd, a,
					       (Elf_External_Vernaux *) p);
		    p += sizeof (Elf_External_Vernaux);
		  }
	      }

	    if (!_bfd_elf_add_dynamic_entry (info, DT_VERNEED, 0)
		|| !_bfd_elf_add_dynamic_entry (info, DT_VERNEEDNUM, crefs))
	      return FALSE;

	    elf_tdata (output_bfd)->cverrefs = crefs;
	  }
      }

      /* Assign dynsym indicies.  In a shared library we generate a
	 section symbol for each output section, which come first.
	 Next come all of the back-end allocated local dynamic syms,
	 followed by the rest of the global symbols.  */

      dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);

      /* Work out the size of the symbol version section.  */
      s = bfd_get_section_by_name (dynobj, ".gnu.version");
      BFD_ASSERT (s != NULL);
      if (dynsymcount == 0
	  || (verdefs == NULL && elf_tdata (output_bfd)->verref == NULL))
	{
	  _bfd_strip_section_from_output (info, s);
	  /* The DYNSYMCOUNT might have changed if we were going to
	     output a dynamic symbol table entry for S.  */
	  dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);
	}
      else
	{
	  s->_raw_size = dynsymcount * sizeof (Elf_External_Versym);
	  s->contents = bfd_zalloc (output_bfd, s->_raw_size);
	  if (s->contents == NULL)
	    return FALSE;

	  if (!_bfd_elf_add_dynamic_entry (info, DT_VERSYM, 0))
	    return FALSE;
	}

      /* Set the size of the .dynsym and .hash sections.  We counted
	 the number of dynamic symbols in elf_link_add_object_symbols.
	 We will build the contents of .dynsym and .hash when we build
	 the final symbol table, because until then we do not know the
	 correct value to give the symbols.  We built the .dynstr
	 section as we went along in elf_link_add_object_symbols.  */
      s = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (s != NULL);
      s->_raw_size = dynsymcount * bed->s->sizeof_sym;
      s->contents = bfd_alloc (output_bfd, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	return FALSE;

      if (dynsymcount != 0)
	{
	  Elf_Internal_Sym isym;

	  /* The first entry in .dynsym is a dummy symbol.  */
	  isym.st_value = 0;
	  isym.st_size = 0;
	  isym.st_name = 0;
	  isym.st_info = 0;
	  isym.st_other = 0;
	  isym.st_shndx = 0;
	  bed->s->swap_symbol_out (output_bfd, &isym, s->contents, 0);
	}

      /* Compute the size of the hashing table.  As a side effect this
	 computes the hash values for all the names we export.  */
      bucketcount = compute_bucket_count (info);

      s = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (s != NULL);
      hash_entry_size = elf_section_data (s)->this_hdr.sh_entsize;
      s->_raw_size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
      s->contents = bfd_zalloc (output_bfd, s->_raw_size);
      if (s->contents == NULL)
	return FALSE;

      bfd_put (8 * hash_entry_size, output_bfd, bucketcount, s->contents);
      bfd_put (8 * hash_entry_size, output_bfd, dynsymcount,
	       s->contents + hash_entry_size);

      elf_hash_table (info)->bucketcount = bucketcount;

      s = bfd_get_section_by_name (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);

      elf_finalize_dynstr (output_bfd, info);

      s->_raw_size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);

      for (dtagcount = 0; dtagcount <= info->spare_dynamic_tags; ++dtagcount)
	if (!_bfd_elf_add_dynamic_entry (info, DT_NULL, 0))
	  return FALSE;
    }

  return TRUE;
@


1.51.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d93 1
a93 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d223 1
a223 1
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d288 1
a288 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d350 2
a351 2
bfd_elf_link_record_dynamic_symbol (struct bfd_link_info *info,
				    struct elf_link_hash_entry *h)
d469 1
a469 1
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d478 1
a478 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
d491 3
a493 3
bfd_elf_link_record_local_dynamic_symbol (struct bfd_link_info *info,
					  bfd *input_bfd,
					  long input_indx)
d839 1
a839 1
	return bfd_elf_link_record_dynamic_symbol (info, h);
d1278 1
a1278 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, hi))
d1436 1
a1436 1
	  if (! bfd_elf_link_record_dynamic_symbol (eif->info, h))
d2080 1
a2080 1
	  if (! bfd_elf_link_record_dynamic_symbol (eif->info, h))
d3765 1
a3765 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3771 1
a3771 1
		  if (! bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
d3986 2
a3987 1
		      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3998 2
a3999 1
		      if (! bfd_elf_link_record_dynamic_symbol (info, hlook))
d5078 1
a5078 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
a5359 3545
}

/* Final phase of ELF linker.  */

/* A structure we use to avoid passing large numbers of arguments.  */

struct elf_final_link_info
{
  /* General link information.  */
  struct bfd_link_info *info;
  /* Output BFD.  */
  bfd *output_bfd;
  /* Symbol string table.  */
  struct bfd_strtab_hash *symstrtab;
  /* .dynsym section.  */
  asection *dynsym_sec;
  /* .hash section.  */
  asection *hash_sec;
  /* symbol version section (.gnu.version).  */
  asection *symver_sec;
  /* Buffer large enough to hold contents of any section.  */
  bfd_byte *contents;
  /* Buffer large enough to hold external relocs of any section.  */
  void *external_relocs;
  /* Buffer large enough to hold internal relocs of any section.  */
  Elf_Internal_Rela *internal_relocs;
  /* Buffer large enough to hold external local symbols of any input
     BFD.  */
  bfd_byte *external_syms;
  /* And a buffer for symbol section indices.  */
  Elf_External_Sym_Shndx *locsym_shndx;
  /* Buffer large enough to hold internal local symbols of any input
     BFD.  */
  Elf_Internal_Sym *internal_syms;
  /* Array large enough to hold a symbol index for each local symbol
     of any input BFD.  */
  long *indices;
  /* Array large enough to hold a section pointer for each local
     symbol of any input BFD.  */
  asection **sections;
  /* Buffer to hold swapped out symbols.  */
  bfd_byte *symbuf;
  /* And one for symbol section indices.  */
  Elf_External_Sym_Shndx *symshndxbuf;
  /* Number of swapped out symbols in buffer.  */
  size_t symbuf_count;
  /* Number of symbols which fit in symbuf.  */
  size_t symbuf_size;
  /* And same for symshndxbuf.  */
  size_t shndxbuf_size;
};

/* This struct is used to pass information to elf_link_output_extsym.  */

struct elf_outext_info
{
  bfd_boolean failed;
  bfd_boolean localsyms;
  struct elf_final_link_info *finfo;
};

/* When performing a relocatable link, the input relocations are
   preserved.  But, if they reference global symbols, the indices
   referenced must be updated.  Update all the relocations in
   REL_HDR (there are COUNT of them), using the data in REL_HASH.  */

static void
elf_link_adjust_relocs (bfd *abfd,
			Elf_Internal_Shdr *rel_hdr,
			unsigned int count,
			struct elf_link_hash_entry **rel_hash)
{
  unsigned int i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_byte *erela;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  bfd_vma r_type_mask;
  int r_sym_shift;

  if (rel_hdr->sh_entsize == bed->s->sizeof_rel)
    {
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
    }
  else if (rel_hdr->sh_entsize == bed->s->sizeof_rela)
    {
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  else
    abort ();

  if (bed->s->int_rels_per_ext_rel > MAX_INT_RELS_PER_EXT_REL)
    abort ();

  if (bed->s->arch_size == 32)
    {
      r_type_mask = 0xff;
      r_sym_shift = 8;
    }
  else
    {
      r_type_mask = 0xffffffff;
      r_sym_shift = 32;
    }

  erela = rel_hdr->contents;
  for (i = 0; i < count; i++, rel_hash++, erela += rel_hdr->sh_entsize)
    {
      Elf_Internal_Rela irela[MAX_INT_RELS_PER_EXT_REL];
      unsigned int j;

      if (*rel_hash == NULL)
	continue;

      BFD_ASSERT ((*rel_hash)->indx >= 0);

      (*swap_in) (abfd, erela, irela);
      for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
	irela[j].r_info = ((bfd_vma) (*rel_hash)->indx << r_sym_shift
			   | (irela[j].r_info & r_type_mask));
      (*swap_out) (abfd, irela, erela);
    }
}

struct elf_link_sort_rela
{
  union {
    bfd_vma offset;
    bfd_vma sym_mask;
  } u;
  enum elf_reloc_type_class type;
  /* We use this as an array of size int_rels_per_ext_rel.  */
  Elf_Internal_Rela rela[1];
};

static int
elf_link_sort_cmp1 (const void *A, const void *B)
{
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
  int relativea, relativeb;

  relativea = a->type == reloc_class_relative;
  relativeb = b->type == reloc_class_relative;

  if (relativea < relativeb)
    return 1;
  if (relativea > relativeb)
    return -1;
  if ((a->rela->r_info & a->u.sym_mask) < (b->rela->r_info & b->u.sym_mask))
    return -1;
  if ((a->rela->r_info & a->u.sym_mask) > (b->rela->r_info & b->u.sym_mask))
    return 1;
  if (a->rela->r_offset < b->rela->r_offset)
    return -1;
  if (a->rela->r_offset > b->rela->r_offset)
    return 1;
  return 0;
}

static int
elf_link_sort_cmp2 (const void *A, const void *B)
{
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
  int copya, copyb;

  if (a->u.offset < b->u.offset)
    return -1;
  if (a->u.offset > b->u.offset)
    return 1;
  copya = (a->type == reloc_class_copy) * 2 + (a->type == reloc_class_plt);
  copyb = (b->type == reloc_class_copy) * 2 + (b->type == reloc_class_plt);
  if (copya < copyb)
    return -1;
  if (copya > copyb)
    return 1;
  if (a->rela->r_offset < b->rela->r_offset)
    return -1;
  if (a->rela->r_offset > b->rela->r_offset)
    return 1;
  return 0;
}

static size_t
elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
{
  asection *reldyn;
  bfd_size_type count, size;
  size_t i, ret, sort_elt, ext_size;
  bfd_byte *sort, *s_non_relative, *p;
  struct elf_link_sort_rela *sq;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int i2e = bed->s->int_rels_per_ext_rel;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  struct bfd_link_order *lo;
  bfd_vma r_sym_mask;

  reldyn = bfd_get_section_by_name (abfd, ".rela.dyn");
  if (reldyn == NULL || reldyn->_raw_size == 0)
    {
      reldyn = bfd_get_section_by_name (abfd, ".rel.dyn");
      if (reldyn == NULL || reldyn->_raw_size == 0)
	return 0;
      ext_size = bed->s->sizeof_rel;
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
    }
  else
    {
      ext_size = bed->s->sizeof_rela;
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  count = reldyn->_raw_size / ext_size;

  size = 0;
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	asection *o = lo->u.indirect.section;
	size += o->_raw_size;
      }

  if (size != reldyn->_raw_size)
    return 0;

  sort_elt = (sizeof (struct elf_link_sort_rela)
	      + (i2e - 1) * sizeof (Elf_Internal_Rela));
  sort = bfd_zmalloc (sort_elt * count);
  if (sort == NULL)
    {
      (*info->callbacks->warning)
	(info, _("Not enough memory to sort relocations"), 0, abfd, 0, 0);
      return 0;
    }

  if (bed->s->arch_size == 32)
    r_sym_mask = ~(bfd_vma) 0xff;
  else
    r_sym_mask = ~(bfd_vma) 0xffffffff;

  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	bfd_byte *erel, *erelend;
	asection *o = lo->u.indirect.section;

	erel = o->contents;
	erelend = o->contents + o->_raw_size;
	p = sort + o->output_offset / ext_size * sort_elt;
	while (erel < erelend)
	  {
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
	    (*swap_in) (abfd, erel, s->rela);
	    s->type = (*bed->elf_backend_reloc_type_class) (s->rela);
	    s->u.sym_mask = r_sym_mask;
	    p += sort_elt;
	    erel += ext_size;
	  }
      }

  qsort (sort, count, sort_elt, elf_link_sort_cmp1);

  for (i = 0, p = sort; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
      if (s->type != reloc_class_relative)
	break;
    }
  ret = i;
  s_non_relative = p;

  sq = (struct elf_link_sort_rela *) s_non_relative;
  for (; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *sp = (struct elf_link_sort_rela *) p;
      if (((sp->rela->r_info ^ sq->rela->r_info) & r_sym_mask) != 0)
	sq = sp;
      sp->u.offset = sq->rela->r_offset;
    }

  qsort (s_non_relative, count - ret, sort_elt, elf_link_sort_cmp2);

  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	bfd_byte *erel, *erelend;
	asection *o = lo->u.indirect.section;

	erel = o->contents;
	erelend = o->contents + o->_raw_size;
	p = sort + o->output_offset / ext_size * sort_elt;
	while (erel < erelend)
	  {
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
	    (*swap_out) (abfd, s->rela, erel);
	    p += sort_elt;
	    erel += ext_size;
	  }
      }

  free (sort);
  *psec = reldyn;
  return ret;
}

/* Flush the output symbols to the file.  */

static bfd_boolean
elf_link_flush_output_syms (struct elf_final_link_info *finfo,
			    const struct elf_backend_data *bed)
{
  if (finfo->symbuf_count > 0)
    {
      Elf_Internal_Shdr *hdr;
      file_ptr pos;
      bfd_size_type amt;

      hdr = &elf_tdata (finfo->output_bfd)->symtab_hdr;
      pos = hdr->sh_offset + hdr->sh_size;
      amt = finfo->symbuf_count * bed->s->sizeof_sym;
      if (bfd_seek (finfo->output_bfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo->symbuf, amt, finfo->output_bfd) != amt)
	return FALSE;

      hdr->sh_size += amt;
      finfo->symbuf_count = 0;
    }

  return TRUE;
}

/* Add a symbol to the output symbol table.  */

static bfd_boolean
elf_link_output_sym (struct elf_final_link_info *finfo,
		     const char *name,
		     Elf_Internal_Sym *elfsym,
		     asection *input_sec,
		     struct elf_link_hash_entry *h)
{
  bfd_byte *dest;
  Elf_External_Sym_Shndx *destshndx;
  bfd_boolean (*output_symbol_hook)
    (struct bfd_link_info *, const char *, Elf_Internal_Sym *, asection *,
     struct elf_link_hash_entry *);
  const struct elf_backend_data *bed;

  bed = get_elf_backend_data (finfo->output_bfd);
  output_symbol_hook = bed->elf_backend_link_output_symbol_hook;
  if (output_symbol_hook != NULL)
    {
      if (! (*output_symbol_hook) (finfo->info, name, elfsym, input_sec, h))
	return FALSE;
    }

  if (name == NULL || *name == '\0')
    elfsym->st_name = 0;
  else if (input_sec->flags & SEC_EXCLUDE)
    elfsym->st_name = 0;
  else
    {
      elfsym->st_name = (unsigned long) _bfd_stringtab_add (finfo->symstrtab,
							    name, TRUE, FALSE);
      if (elfsym->st_name == (unsigned long) -1)
	return FALSE;
    }

  if (finfo->symbuf_count >= finfo->symbuf_size)
    {
      if (! elf_link_flush_output_syms (finfo, bed))
	return FALSE;
    }

  dest = finfo->symbuf + finfo->symbuf_count * bed->s->sizeof_sym;
  destshndx = finfo->symshndxbuf;
  if (destshndx != NULL)
    {
      if (bfd_get_symcount (finfo->output_bfd) >= finfo->shndxbuf_size)
	{
	  bfd_size_type amt;

	  amt = finfo->shndxbuf_size * sizeof (Elf_External_Sym_Shndx);
	  finfo->symshndxbuf = destshndx = bfd_realloc (destshndx, amt * 2);
	  if (destshndx == NULL)
	    return FALSE;
	  memset ((char *) destshndx + amt, 0, amt);
	  finfo->shndxbuf_size *= 2;
	}
      destshndx += bfd_get_symcount (finfo->output_bfd);
    }

  bed->s->swap_symbol_out (finfo->output_bfd, elfsym, dest, destshndx);
  finfo->symbuf_count += 1;
  bfd_get_symcount (finfo->output_bfd) += 1;

  return TRUE;
}

/* For DSOs loaded in via a DT_NEEDED entry, emulate ld.so in
   allowing an unsatisfied unversioned symbol in the DSO to match a
   versioned symbol that would normally require an explicit version.
   We also handle the case that a DSO references a hidden symbol
   which may be satisfied by a versioned symbol in another DSO.  */

static bfd_boolean
elf_link_check_versioned_symbol (struct bfd_link_info *info,
				 const struct elf_backend_data *bed,
				 struct elf_link_hash_entry *h)
{
  bfd *abfd;
  struct elf_link_loaded_list *loaded;

  if (!is_elf_hash_table (info->hash))
    return FALSE;

  switch (h->root.type)
    {
    default:
      abfd = NULL;
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      abfd = h->root.u.undef.abfd;
      if ((abfd->flags & DYNAMIC) == 0
	  || elf_dyn_lib_class (abfd) != DYN_DT_NEEDED)
	return FALSE;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      abfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      abfd = h->root.u.c.p->section->owner;
      break;
    }
  BFD_ASSERT (abfd != NULL);

  for (loaded = elf_hash_table (info)->loaded;
       loaded != NULL;
       loaded = loaded->next)
    {
      bfd *input;
      Elf_Internal_Shdr *hdr;
      bfd_size_type symcount;
      bfd_size_type extsymcount;
      bfd_size_type extsymoff;
      Elf_Internal_Shdr *versymhdr;
      Elf_Internal_Sym *isym;
      Elf_Internal_Sym *isymend;
      Elf_Internal_Sym *isymbuf;
      Elf_External_Versym *ever;
      Elf_External_Versym *extversym;

      input = loaded->abfd;

      /* We check each DSO for a possible hidden versioned definition.  */
      if (input == abfd
	  || (input->flags & DYNAMIC) == 0
	  || elf_dynversym (input) == 0)
	continue;

      hdr = &elf_tdata (input)->dynsymtab_hdr;

      symcount = hdr->sh_size / bed->s->sizeof_sym;
      if (elf_bad_symtab (input))
	{
	  extsymcount = symcount;
	  extsymoff = 0;
	}
      else
	{
	  extsymcount = symcount - hdr->sh_info;
	  extsymoff = hdr->sh_info;
	}

      if (extsymcount == 0)
	continue;

      isymbuf = bfd_elf_get_elf_syms (input, hdr, extsymcount, extsymoff,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	return FALSE;

      /* Read in any version definitions.  */
      versymhdr = &elf_tdata (input)->dynversym_hdr;
      extversym = bfd_malloc (versymhdr->sh_size);
      if (extversym == NULL)
	goto error_ret;

      if (bfd_seek (input, versymhdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bread (extversym, versymhdr->sh_size, input)
	      != versymhdr->sh_size))
	{
	  free (extversym);
	error_ret:
	  free (isymbuf);
	  return FALSE;
	}

      ever = extversym + extsymoff;
      isymend = isymbuf + extsymcount;
      for (isym = isymbuf; isym < isymend; isym++, ever++)
	{
	  const char *name;
	  Elf_Internal_Versym iver;
	  unsigned short version_index;

	  if (ELF_ST_BIND (isym->st_info) == STB_LOCAL
	      || isym->st_shndx == SHN_UNDEF)
	    continue;

	  name = bfd_elf_string_from_elf_section (input,
						  hdr->sh_link,
						  isym->st_name);
	  if (strcmp (name, h->root.root.string) != 0)
	    continue;

	  _bfd_elf_swap_versym_in (input, ever, &iver);

	  if ((iver.vs_vers & VERSYM_HIDDEN) == 0)
	    {
	      /* If we have a non-hidden versioned sym, then it should
		 have provided a definition for the undefined sym.  */
	      abort ();
	    }

	  version_index = iver.vs_vers & VERSYM_VERSION;
	  if (version_index == 1 || version_index == 2)
	    {
	      /* This is the base or first version.  We can use it.  */
	      free (extversym);
	      free (isymbuf);
	      return TRUE;
	    }
	}

      free (extversym);
      free (isymbuf);
    }

  return FALSE;
}

/* Add an external symbol to the symbol table.  This is called from
   the hash table traversal routine.  When generating a shared object,
   we go through the symbol table twice.  The first time we output
   anything that might have been forced to local scope in a version
   script.  The second time we output the symbols that are still
   global symbols.  */

static bfd_boolean
elf_link_output_extsym (struct elf_link_hash_entry *h, void *data)
{
  struct elf_outext_info *eoinfo = data;
  struct elf_final_link_info *finfo = eoinfo->finfo;
  bfd_boolean strip;
  Elf_Internal_Sym sym;
  asection *input_sec;
  const struct elf_backend_data *bed;

  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
    }

  /* Decide whether to output this symbol in this pass.  */
  if (eoinfo->localsyms)
    {
      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	return TRUE;
    }
  else
    {
      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
	return TRUE;
    }

  bed = get_elf_backend_data (finfo->output_bfd);

  /* If we have an undefined symbol reference here then it must have
     come from a shared library that is being linked in.  (Undefined
     references in regular files have already been handled).  If we
     are reporting errors for this situation then do so now.  */
  if (h->root.type == bfd_link_hash_undefined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
      && ! elf_link_check_versioned_symbol (finfo->info, bed, h)
      && finfo->info->unresolved_syms_in_shared_libs != RM_IGNORE)
    {
      if (! ((*finfo->info->callbacks->undefined_symbol)
	     (finfo->info, h->root.root.string, h->root.u.undef.abfd,
	      NULL, 0, finfo->info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)))
	{
	  eoinfo->failed = TRUE;
	  return FALSE;
	}
    }

  /* We should also warn if a forced local symbol is referenced from
     shared libraries.  */
  if (! finfo->info->relocatable
      && (! finfo->info->shared)
      && (h->elf_link_hash_flags
	  & (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC | ELF_LINK_DYNAMIC_DEF | ELF_LINK_DYNAMIC_WEAK))
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC)
      && ! elf_link_check_versioned_symbol (finfo->info, bed, h))
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' in %s is referenced by DSO"),
	 bfd_get_filename (finfo->output_bfd),
	 ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	 ? "internal"
	 : ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	   ? "hidden" : "local",
	 h->root.root.string,
	 bfd_archive_filename (h->root.u.def.section->owner));
      eoinfo->failed = TRUE;
      return FALSE;
    }

  /* We don't want to output symbols that have never been mentioned by
     a regular file, or that we have been told to strip.  However, if
     h->indx is set to -2, the symbol is used by a reloc and we must
     output it.  */
  if (h->indx == -2)
    strip = FALSE;
  else if (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	    || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
    strip = TRUE;
  else if (finfo->info->strip == strip_all)
    strip = TRUE;
  else if (finfo->info->strip == strip_some
	   && bfd_hash_lookup (finfo->info->keep_hash,
			       h->root.root.string, FALSE, FALSE) == NULL)
    strip = TRUE;
  else if (finfo->info->strip_discarded
	   && (h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	   && elf_discarded_section (h->root.u.def.section))
    strip = TRUE;
  else
    strip = FALSE;

  /* If we're stripping it, and it's not a dynamic symbol, there's
     nothing else to do unless it is a forced local symbol.  */
  if (strip
      && h->dynindx == -1
      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
    return TRUE;

  sym.st_value = 0;
  sym.st_size = h->size;
  sym.st_other = h->other;
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    sym.st_info = ELF_ST_INFO (STB_LOCAL, h->type);
  else if (h->root.type == bfd_link_hash_undefweak
	   || h->root.type == bfd_link_hash_defweak)
    sym.st_info = ELF_ST_INFO (STB_WEAK, h->type);
  else
    sym.st_info = ELF_ST_INFO (STB_GLOBAL, h->type);

  switch (h->root.type)
    {
    default:
    case bfd_link_hash_new:
    case bfd_link_hash_warning:
      abort ();
      return FALSE;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      input_sec = bfd_und_section_ptr;
      sym.st_shndx = SHN_UNDEF;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
	input_sec = h->root.u.def.section;
	if (input_sec->output_section != NULL)
	  {
	    sym.st_shndx =
	      _bfd_elf_section_from_bfd_section (finfo->output_bfd,
						 input_sec->output_section);
	    if (sym.st_shndx == SHN_BAD)
	      {
		(*_bfd_error_handler)
		  (_("%s: could not find output section %s for input section %s"),
		   bfd_get_filename (finfo->output_bfd),
		   input_sec->output_section->name,
		   input_sec->name);
		eoinfo->failed = TRUE;
		return FALSE;
	      }

	    /* ELF symbols in relocatable files are section relative,
	       but in nonrelocatable files they are virtual
	       addresses.  */
	    sym.st_value = h->root.u.def.value + input_sec->output_offset;
	    if (! finfo->info->relocatable)
	      {
		sym.st_value += input_sec->output_section->vma;
		if (h->type == STT_TLS)
		  {
		    /* STT_TLS symbols are relative to PT_TLS segment
		       base.  */
		    BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
		    sym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
		  }
	      }
	  }
	else
	  {
	    BFD_ASSERT (input_sec->owner == NULL
			|| (input_sec->owner->flags & DYNAMIC) != 0);
	    sym.st_shndx = SHN_UNDEF;
	    input_sec = bfd_und_section_ptr;
	  }
      }
      break;

    case bfd_link_hash_common:
      input_sec = h->root.u.c.p->section;
      sym.st_shndx = SHN_COMMON;
      sym.st_value = 1 << h->root.u.c.p->alignment_power;
      break;

    case bfd_link_hash_indirect:
      /* These symbols are created by symbol versioning.  They point
	 to the decorated version of the name.  For example, if the
	 symbol foo@@@@GNU_1.2 is the default, which should be used when
	 foo is used with no version, then we add an indirect symbol
	 foo which points to foo@@@@GNU_1.2.  We ignore these symbols,
	 since the indirected symbol is already in the hash table.  */
      return TRUE;
    }

  /* Give the processor backend a chance to tweak the symbol value,
     and also to finish up anything that needs to be done for this
     symbol.  FIXME: Not calling elf_backend_finish_dynamic_symbol for
     forced local syms when non-shared is due to a historical quirk.  */
  if ((h->dynindx != -1
       || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
      && ((finfo->info->shared
	   && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak))
	  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
      && elf_hash_table (finfo->info)->dynamic_sections_created)
    {
      if (! ((*bed->elf_backend_finish_dynamic_symbol)
	     (finfo->output_bfd, finfo->info, h, &sym)))
	{
	  eoinfo->failed = TRUE;
	  return FALSE;
	}
    }

  /* If we are marking the symbol as undefined, and there are no
     non-weak references to this symbol from a regular object, then
     mark the symbol as weak undefined; if there are non-weak
     references, mark the symbol as strong.  We can't do this earlier,
     because it might not be marked as undefined until the
     finish_dynamic_symbol routine gets through with it.  */
  if (sym.st_shndx == SHN_UNDEF
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
      && (ELF_ST_BIND (sym.st_info) == STB_GLOBAL
	  || ELF_ST_BIND (sym.st_info) == STB_WEAK))
    {
      int bindtype;

      if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK) != 0)
	bindtype = STB_GLOBAL;
      else
	bindtype = STB_WEAK;
      sym.st_info = ELF_ST_INFO (bindtype, ELF_ST_TYPE (sym.st_info));
    }

  /* If a non-weak symbol with non-default visibility is not defined
     locally, it is a fatal error.  */
  if (! finfo->info->relocatable
      && ELF_ST_VISIBILITY (sym.st_other) != STV_DEFAULT
      && ELF_ST_BIND (sym.st_info) != STB_WEAK
      && h->root.type == bfd_link_hash_undefined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' isn't defined"),
	  bfd_get_filename (finfo->output_bfd),
	  ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED
	  ? "protected"
	  : ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL
	    ? "internal" : "hidden",
	  h->root.root.string);
      eoinfo->failed = TRUE;
      return FALSE;
    }

  /* If this symbol should be put in the .dynsym section, then put it
     there now.  We already know the symbol index.  We also fill in
     the entry in the .hash section.  */
  if (h->dynindx != -1
      && elf_hash_table (finfo->info)->dynamic_sections_created)
    {
      size_t bucketcount;
      size_t bucket;
      size_t hash_entry_size;
      bfd_byte *bucketpos;
      bfd_vma chain;
      bfd_byte *esym;

      sym.st_name = h->dynstr_index;
      esym = finfo->dynsym_sec->contents + h->dynindx * bed->s->sizeof_sym;
      bed->s->swap_symbol_out (finfo->output_bfd, &sym, esym, 0);

      bucketcount = elf_hash_table (finfo->info)->bucketcount;
      bucket = h->elf_hash_value % bucketcount;
      hash_entry_size
	= elf_section_data (finfo->hash_sec)->this_hdr.sh_entsize;
      bucketpos = ((bfd_byte *) finfo->hash_sec->contents
		   + (bucket + 2) * hash_entry_size);
      chain = bfd_get (8 * hash_entry_size, finfo->output_bfd, bucketpos);
      bfd_put (8 * hash_entry_size, finfo->output_bfd, h->dynindx, bucketpos);
      bfd_put (8 * hash_entry_size, finfo->output_bfd, chain,
	       ((bfd_byte *) finfo->hash_sec->contents
		+ (bucketcount + 2 + h->dynindx) * hash_entry_size));

      if (finfo->symver_sec != NULL && finfo->symver_sec->contents != NULL)
	{
	  Elf_Internal_Versym iversym;
	  Elf_External_Versym *eversym;

	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      if (h->verinfo.verdef == NULL)
		iversym.vs_vers = 0;
	      else
		iversym.vs_vers = h->verinfo.verdef->vd_exp_refno + 1;
	    }
	  else
	    {
	      if (h->verinfo.vertree == NULL)
		iversym.vs_vers = 1;
	      else
		iversym.vs_vers = h->verinfo.vertree->vernum + 1;
	    }

	  if ((h->elf_link_hash_flags & ELF_LINK_HIDDEN) != 0)
	    iversym.vs_vers |= VERSYM_HIDDEN;

	  eversym = (Elf_External_Versym *) finfo->symver_sec->contents;
	  eversym += h->dynindx;
	  _bfd_elf_swap_versym_out (finfo->output_bfd, &iversym, eversym);
	}
    }

  /* If we're stripping it, then it was just a dynamic symbol, and
     there's nothing else to do.  */
  if (strip || (input_sec->flags & SEC_EXCLUDE) != 0)
    return TRUE;

  h->indx = bfd_get_symcount (finfo->output_bfd);

  if (! elf_link_output_sym (finfo, h->root.root.string, &sym, input_sec, h))
    {
      eoinfo->failed = TRUE;
      return FALSE;
    }

  return TRUE;
}

static bfd_boolean
elf_section_ignore_discarded_relocs (asection *sec)
{
  const struct elf_backend_data *bed;

  switch (sec->sec_info_type)
    {
    case ELF_INFO_TYPE_STABS:
    case ELF_INFO_TYPE_EH_FRAME:
      return TRUE;
    default:
      break;
    }

  bed = get_elf_backend_data (sec->owner);
  if (bed->elf_backend_ignore_discarded_relocs != NULL
      && (*bed->elf_backend_ignore_discarded_relocs) (sec))
    return TRUE;

  return FALSE;
}

/* Link an input file into the linker output file.  This function
   handles all the sections and relocations of the input file at once.
   This is so that we only have to read the local symbols once, and
   don't have to keep them in memory.  */

static bfd_boolean
elf_link_input_bfd (struct elf_final_link_info *finfo, bfd *input_bfd)
{
  bfd_boolean (*relocate_section)
    (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
     Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
  bfd *output_bfd;
  Elf_Internal_Shdr *symtab_hdr;
  size_t locsymcount;
  size_t extsymoff;
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  long *pindex;
  asection **ppsection;
  asection *o;
  const struct elf_backend_data *bed;
  bfd_boolean emit_relocs;
  struct elf_link_hash_entry **sym_hashes;

  output_bfd = finfo->output_bfd;
  bed = get_elf_backend_data (output_bfd);
  relocate_section = bed->elf_backend_relocate_section;

  /* If this is a dynamic object, we don't want to do anything here:
     we don't want the local symbols, and we don't want the section
     contents.  */
  if ((input_bfd->flags & DYNAMIC) != 0)
    return TRUE;

  emit_relocs = (finfo->info->relocatable
		 || finfo->info->emitrelocations
		 || bed->elf_backend_emit_relocs);

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  if (elf_bad_symtab (input_bfd))
    {
      locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      extsymoff = 0;
    }
  else
    {
      locsymcount = symtab_hdr->sh_info;
      extsymoff = symtab_hdr->sh_info;
    }

  /* Read the local symbols.  */
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
  if (isymbuf == NULL && locsymcount != 0)
    {
      isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
				      finfo->internal_syms,
				      finfo->external_syms,
				      finfo->locsym_shndx);
      if (isymbuf == NULL)
	return FALSE;
    }

  /* Find local symbol sections and adjust values of symbols in
     SEC_MERGE sections.  Write out those local symbols we know are
     going into the output file.  */
  isymend = isymbuf + locsymcount;
  for (isym = isymbuf, pindex = finfo->indices, ppsection = finfo->sections;
       isym < isymend;
       isym++, pindex++, ppsection++)
    {
      asection *isec;
      const char *name;
      Elf_Internal_Sym osym;

      *pindex = -1;

      if (elf_bad_symtab (input_bfd))
	{
	  if (ELF_ST_BIND (isym->st_info) != STB_LOCAL)
	    {
	      *ppsection = NULL;
	      continue;
	    }
	}

      if (isym->st_shndx == SHN_UNDEF)
	isec = bfd_und_section_ptr;
      else if (isym->st_shndx < SHN_LORESERVE
	       || isym->st_shndx > SHN_HIRESERVE)
	{
	  isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);
	  if (isec
	      && isec->sec_info_type == ELF_INFO_TYPE_MERGE
	      && ELF_ST_TYPE (isym->st_info) != STT_SECTION)
	    isym->st_value =
	      _bfd_merged_section_offset (output_bfd, &isec,
					  elf_section_data (isec)->sec_info,
					  isym->st_value, 0);
	}
      else if (isym->st_shndx == SHN_ABS)
	isec = bfd_abs_section_ptr;
      else if (isym->st_shndx == SHN_COMMON)
	isec = bfd_com_section_ptr;
      else
	{
	  /* Who knows?  */
	  isec = NULL;
	}

      *ppsection = isec;

      /* Don't output the first, undefined, symbol.  */
      if (ppsection == finfo->sections)
	continue;

      if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
	{
	  /* We never output section symbols.  Instead, we use the
	     section symbol of the corresponding section in the output
	     file.  */
	  continue;
	}

      /* If we are stripping all symbols, we don't want to output this
	 one.  */
      if (finfo->info->strip == strip_all)
	continue;

      /* If we are discarding all local symbols, we don't want to
	 output this one.  If we are generating a relocatable output
	 file, then some of the local symbols may be required by
	 relocs; we output them below as we discover that they are
	 needed.  */
      if (finfo->info->discard == discard_all)
	continue;

      /* If this symbol is defined in a section which we are
	 discarding, we don't need to keep it, but note that
	 linker_mark is only reliable for sections that have contents.
	 For the benefit of the MIPS ELF linker, we check SEC_EXCLUDE
	 as well as linker_mark.  */
      if ((isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
	  && isec != NULL
	  && ((! isec->linker_mark && (isec->flags & SEC_HAS_CONTENTS) != 0)
	      || (! finfo->info->relocatable
		  && (isec->flags & SEC_EXCLUDE) != 0)))
	continue;

      /* Get the name of the symbol.  */
      name = bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	return FALSE;

      /* See if we are discarding symbols with this name.  */
      if ((finfo->info->strip == strip_some
	   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE, FALSE)
	       == NULL))
	  || (((finfo->info->discard == discard_sec_merge
		&& (isec->flags & SEC_MERGE) && ! finfo->info->relocatable)
	       || finfo->info->discard == discard_l)
	      && bfd_is_local_label_name (input_bfd, name)))
	continue;

      /* If we get here, we are going to output this symbol.  */

      osym = *isym;

      /* Adjust the section index for the output file.  */
      osym.st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
							 isec->output_section);
      if (osym.st_shndx == SHN_BAD)
	return FALSE;

      *pindex = bfd_get_symcount (output_bfd);

      /* ELF symbols in relocatable files are section relative, but
	 in executable files they are virtual addresses.  Note that
	 this code assumes that all ELF sections have an associated
	 BFD section with a reasonable value for output_offset; below
	 we assume that they also have a reasonable value for
	 output_section.  Any special sections must be set up to meet
	 these requirements.  */
      osym.st_value += isec->output_offset;
      if (! finfo->info->relocatable)
	{
	  osym.st_value += isec->output_section->vma;
	  if (ELF_ST_TYPE (osym.st_info) == STT_TLS)
	    {
	      /* STT_TLS symbols are relative to PT_TLS segment base.  */
	      BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
	      osym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
	    }
	}

      if (! elf_link_output_sym (finfo, name, &osym, isec, NULL))
	return FALSE;
    }

  /* Relocate the contents of each section.  */
  sym_hashes = elf_sym_hashes (input_bfd);
  for (o = input_bfd->sections; o != NULL; o = o->next)
    {
      bfd_byte *contents;

      if (! o->linker_mark)
	{
	  /* This section was omitted from the link.  */
	  continue;
	}

      if ((o->flags & SEC_HAS_CONTENTS) == 0
	  || (o->_raw_size == 0 && (o->flags & SEC_RELOC) == 0))
	continue;

      if ((o->flags & SEC_LINKER_CREATED) != 0)
	{
	  /* Section was created by _bfd_elf_link_create_dynamic_sections
	     or somesuch.  */
	  continue;
	}

      /* Get the contents of the section.  They have been cached by a
	 relaxation routine.  Note that o is a section in an input
	 file, so the contents field will not have been set by any of
	 the routines which work on output files.  */
      if (elf_section_data (o)->this_hdr.contents != NULL)
	contents = elf_section_data (o)->this_hdr.contents;
      else
	{
	  contents = finfo->contents;
	  if (! bfd_get_section_contents (input_bfd, o, contents, 0,
					  o->_raw_size))
	    return FALSE;
	}

      if ((o->flags & SEC_RELOC) != 0)
	{
	  Elf_Internal_Rela *internal_relocs;
	  bfd_vma r_type_mask;
	  int r_sym_shift;

	  /* Get the swapped relocs.  */
	  internal_relocs
	    = _bfd_elf_link_read_relocs (input_bfd, o, finfo->external_relocs,
					 finfo->internal_relocs, FALSE);
	  if (internal_relocs == NULL
	      && o->reloc_count > 0)
	    return FALSE;

	  if (bed->s->arch_size == 32)
	    {
	      r_type_mask = 0xff;
	      r_sym_shift = 8;
	    }
	  else
	    {
	      r_type_mask = 0xffffffff;
	      r_sym_shift = 32;
	    }

	  /* Run through the relocs looking for any against symbols
	     from discarded sections and section symbols from
	     removed link-once sections.  Complain about relocs
	     against discarded sections.  Zero relocs against removed
	     link-once sections.  Preserve debug information as much
	     as we can.  */
	  if (!elf_section_ignore_discarded_relocs (o))
	    {
	      Elf_Internal_Rela *rel, *relend;

	      rel = internal_relocs;
	      relend = rel + o->reloc_count * bed->s->int_rels_per_ext_rel;
	      for ( ; rel < relend; rel++)
		{
		  unsigned long r_symndx = rel->r_info >> r_sym_shift;
		  asection *sec;

		  if (r_symndx >= locsymcount
		      || (elf_bad_symtab (input_bfd)
			  && finfo->sections[r_symndx] == NULL))
		    {
		      struct elf_link_hash_entry *h;

		      h = sym_hashes[r_symndx - extsymoff];
		      while (h->root.type == bfd_link_hash_indirect
			     || h->root.type == bfd_link_hash_warning)
			h = (struct elf_link_hash_entry *) h->root.u.i.link;

		      /* Complain if the definition comes from a
			 discarded section.  */
		      sec = h->root.u.def.section;
		      if ((h->root.type == bfd_link_hash_defined
			   || h->root.type == bfd_link_hash_defweak)
			  && elf_discarded_section (sec))
			{
			  if ((o->flags & SEC_DEBUGGING) != 0)
			    {
			      BFD_ASSERT (r_symndx != 0);
			      /* Try to preserve debug information.  */
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
				  && sec->_raw_size == sec->kept_section->_raw_size)
				h->root.u.def.section
				  = sec->kept_section;
			      else
				memset (rel, 0, sizeof (*rel));
			    }
			  else
			    finfo->info->callbacks->error_handler
			      (LD_DEFINITION_IN_DISCARDED_SECTION,
			       _("%T: discarded in section `%s' from %s\n"),
			       h->root.root.string,
			       h->root.root.string,
			       h->root.u.def.section->name,
			       bfd_archive_filename (h->root.u.def.section->owner));
			}
		    }
		  else
		    {
		      sec = finfo->sections[r_symndx];

		      if (sec != NULL && elf_discarded_section (sec))
			{
			  if ((o->flags & SEC_DEBUGGING) != 0
			      || (sec->flags & SEC_LINK_ONCE) != 0)
			    {
			      BFD_ASSERT (r_symndx != 0);
			      /* Try to preserve debug information.  */
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
				  && sec->_raw_size == sec->kept_section->_raw_size)
				finfo->sections[r_symndx]
				  = sec->kept_section;
			      else
				{
				  rel->r_info &= r_type_mask;
				  rel->r_addend = 0;
				}
			    }
			  else
			    {
			      static int count;
			      int ok;
			      char *buf;

			      ok = asprintf (&buf, "local symbol %d",
					     count++);
			      if (ok <= 0)
				buf = (char *) "local symbol";
			      finfo->info->callbacks->error_handler
				(LD_DEFINITION_IN_DISCARDED_SECTION,
				 _("%T: discarded in section `%s' from %s\n"),
				 buf, buf, sec->name,
				 bfd_archive_filename (input_bfd));
			      if (ok != -1)
				free (buf);
			    }
			}
		    }
		}
	    }

	  /* Relocate the section by invoking a back end routine.

	     The back end routine is responsible for adjusting the
	     section contents as necessary, and (if using Rela relocs
	     and generating a relocatable output file) adjusting the
	     reloc addend as necessary.

	     The back end routine does not have to worry about setting
	     the reloc address or the reloc symbol index.

	     The back end routine is given a pointer to the swapped in
	     internal symbols, and can access the hash table entries
	     for the external symbols via elf_sym_hashes (input_bfd).

	     When generating relocatable output, the back end routine
	     must handle STB_LOCAL/STT_SECTION symbols specially.  The
	     output symbol is going to be a section symbol
	     corresponding to the output section, which will require
	     the addend to be adjusted.  */

	  if (! (*relocate_section) (output_bfd, finfo->info,
				     input_bfd, o, contents,
				     internal_relocs,
				     isymbuf,
				     finfo->sections))
	    return FALSE;

	  if (emit_relocs)
	    {
	      Elf_Internal_Rela *irela;
	      Elf_Internal_Rela *irelaend;
	      bfd_vma last_offset;
	      struct elf_link_hash_entry **rel_hash;
	      Elf_Internal_Shdr *input_rel_hdr, *input_rel_hdr2;
	      unsigned int next_erel;
	      bfd_boolean (*reloc_emitter)
		(bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *);
	      bfd_boolean rela_normal;

	      input_rel_hdr = &elf_section_data (o)->rel_hdr;
	      rela_normal = (bed->rela_normal
			     && (input_rel_hdr->sh_entsize
				 == bed->s->sizeof_rela));

	      /* Adjust the reloc addresses and symbol indices.  */

	      irela = internal_relocs;
	      irelaend = irela + o->reloc_count * bed->s->int_rels_per_ext_rel;
	      rel_hash = (elf_section_data (o->output_section)->rel_hashes
			  + elf_section_data (o->output_section)->rel_count
			  + elf_section_data (o->output_section)->rel_count2);
	      last_offset = o->output_offset;
	      if (!finfo->info->relocatable)
		last_offset += o->output_section->vma;
	      for (next_erel = 0; irela < irelaend; irela++, next_erel++)
		{
		  unsigned long r_symndx;
		  asection *sec;
		  Elf_Internal_Sym sym;

		  if (next_erel == bed->s->int_rels_per_ext_rel)
		    {
		      rel_hash++;
		      next_erel = 0;
		    }

		  irela->r_offset = _bfd_elf_section_offset (output_bfd,
							     finfo->info, o,
							     irela->r_offset);
		  if (irela->r_offset >= (bfd_vma) -2)
		    {
		      /* This is a reloc for a deleted entry or somesuch.
			 Turn it into an R_*_NONE reloc, at the same
			 offset as the last reloc.  elf_eh_frame.c and
			 elf_bfd_discard_info rely on reloc offsets
			 being ordered.  */
		      irela->r_offset = last_offset;
		      irela->r_info = 0;
		      irela->r_addend = 0;
		      continue;
		    }

		  irela->r_offset += o->output_offset;

		  /* Relocs in an executable have to be virtual addresses.  */
		  if (!finfo->info->relocatable)
		    irela->r_offset += o->output_section->vma;

		  last_offset = irela->r_offset;

		  r_symndx = irela->r_info >> r_sym_shift;
		  if (r_symndx == STN_UNDEF)
		    continue;

		  if (r_symndx >= locsymcount
		      || (elf_bad_symtab (input_bfd)
			  && finfo->sections[r_symndx] == NULL))
		    {
		      struct elf_link_hash_entry *rh;
		      unsigned long indx;

		      /* This is a reloc against a global symbol.  We
			 have not yet output all the local symbols, so
			 we do not know the symbol index of any global
			 symbol.  We set the rel_hash entry for this
			 reloc to point to the global hash table entry
			 for this symbol.  The symbol index is then
			 set at the end of elf_bfd_final_link.  */
		      indx = r_symndx - extsymoff;
		      rh = elf_sym_hashes (input_bfd)[indx];
		      while (rh->root.type == bfd_link_hash_indirect
			     || rh->root.type == bfd_link_hash_warning)
			rh = (struct elf_link_hash_entry *) rh->root.u.i.link;

		      /* Setting the index to -2 tells
			 elf_link_output_extsym that this symbol is
			 used by a reloc.  */
		      BFD_ASSERT (rh->indx < 0);
		      rh->indx = -2;

		      *rel_hash = rh;

		      continue;
		    }

		  /* This is a reloc against a local symbol.  */

		  *rel_hash = NULL;
		  sym = isymbuf[r_symndx];
		  sec = finfo->sections[r_symndx];
		  if (ELF_ST_TYPE (sym.st_info) == STT_SECTION)
		    {
		      /* I suppose the backend ought to fill in the
			 section of any STT_SECTION symbol against a
			 processor specific section.  If we have
			 discarded a section, the output_section will
			 be the absolute section.  */
		      if (bfd_is_abs_section (sec)
			  || (sec != NULL
			      && bfd_is_abs_section (sec->output_section)))
			r_symndx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  r_symndx = sec->output_section->target_index;
			  BFD_ASSERT (r_symndx != 0);
			}

		      /* Adjust the addend according to where the
			 section winds up in the output section.  */
		      if (rela_normal)
			irela->r_addend += sec->output_offset;
		    }
		  else
		    {
		      if (finfo->indices[r_symndx] == -1)
			{
			  unsigned long shlink;
			  const char *name;
			  asection *osec;

			  if (finfo->info->strip == strip_all)
			    {
			      /* You can't do ld -r -s.  */
			      bfd_set_error (bfd_error_invalid_operation);
			      return FALSE;
			    }

			  /* This symbol was skipped earlier, but
			     since it is needed by a reloc, we
			     must output it now.  */
			  shlink = symtab_hdr->sh_link;
			  name = (bfd_elf_string_from_elf_section
				  (input_bfd, shlink, sym.st_name));
			  if (name == NULL)
			    return FALSE;

			  osec = sec->output_section;
			  sym.st_shndx =
			    _bfd_elf_section_from_bfd_section (output_bfd,
							       osec);
			  if (sym.st_shndx == SHN_BAD)
			    return FALSE;

			  sym.st_value += sec->output_offset;
			  if (! finfo->info->relocatable)
			    {
			      sym.st_value += osec->vma;
			      if (ELF_ST_TYPE (sym.st_info) == STT_TLS)
				{
				  /* STT_TLS symbols are relative to PT_TLS
				     segment base.  */
				  BFD_ASSERT (elf_hash_table (finfo->info)
					      ->tls_sec != NULL);
				  sym.st_value -= (elf_hash_table (finfo->info)
						   ->tls_sec->vma);
				}
			    }

			  finfo->indices[r_symndx]
			    = bfd_get_symcount (output_bfd);

			  if (! elf_link_output_sym (finfo, name, &sym, sec,
						     NULL))
			    return FALSE;
			}

		      r_symndx = finfo->indices[r_symndx];
		    }

		  irela->r_info = ((bfd_vma) r_symndx << r_sym_shift
				   | (irela->r_info & r_type_mask));
		}

	      /* Swap out the relocs.  */
	      if (bed->elf_backend_emit_relocs
		  && !(finfo->info->relocatable
		       || finfo->info->emitrelocations))
		reloc_emitter = bed->elf_backend_emit_relocs;
	      else
		reloc_emitter = _bfd_elf_link_output_relocs;

	      if (input_rel_hdr->sh_size != 0
		  && ! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
					 internal_relocs))
		return FALSE;

	      input_rel_hdr2 = elf_section_data (o)->rel_hdr2;
	      if (input_rel_hdr2 && input_rel_hdr2->sh_size != 0)
		{
		  internal_relocs += (NUM_SHDR_ENTRIES (input_rel_hdr)
				      * bed->s->int_rels_per_ext_rel);
		  if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr2,
					  internal_relocs))
		    return FALSE;
		}
	    }
	}

      /* Write out the modified section contents.  */
      if (bed->elf_backend_write_section
	  && (*bed->elf_backend_write_section) (output_bfd, o, contents))
	{
	  /* Section written out.  */
	}
      else switch (o->sec_info_type)
	{
	case ELF_INFO_TYPE_STABS:
	  if (! (_bfd_write_section_stabs
		 (output_bfd,
		  &elf_hash_table (finfo->info)->stab_info,
		  o, &elf_section_data (o)->sec_info, contents)))
	    return FALSE;
	  break;
	case ELF_INFO_TYPE_MERGE:
	  if (! _bfd_write_merged_section (output_bfd, o,
					   elf_section_data (o)->sec_info))
	    return FALSE;
	  break;
	case ELF_INFO_TYPE_EH_FRAME:
	  {
	    if (! _bfd_elf_write_section_eh_frame (output_bfd, finfo->info,
						   o, contents))
	      return FALSE;
	  }
	  break;
	default:
	  {
	    bfd_size_type sec_size;

	    sec_size = (o->_cooked_size != 0 ? o->_cooked_size : o->_raw_size);
	    if (! (o->flags & SEC_EXCLUDE)
		&& ! bfd_set_section_contents (output_bfd, o->output_section,
					       contents,
					       (file_ptr) o->output_offset,
					       sec_size))
	      return FALSE;
	  }
	  break;
	}
    }

  return TRUE;
}

/* Generate a reloc when linking an ELF file.  This is a reloc
   requested by the linker, and does come from any input file.  This
   is used to build constructor and destructor tables when linking
   with -Ur.  */

static bfd_boolean
elf_reloc_link_order (bfd *output_bfd,
		      struct bfd_link_info *info,
		      asection *output_section,
		      struct bfd_link_order *link_order)
{
  reloc_howto_type *howto;
  long indx;
  bfd_vma offset;
  bfd_vma addend;
  struct elf_link_hash_entry **rel_hash_ptr;
  Elf_Internal_Shdr *rel_hdr;
  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
  Elf_Internal_Rela irel[MAX_INT_RELS_PER_EXT_REL];
  bfd_byte *erel;
  unsigned int i;

  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
  if (howto == NULL)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  addend = link_order->u.reloc.p->addend;

  /* Figure out the symbol index.  */
  rel_hash_ptr = (elf_section_data (output_section)->rel_hashes
		  + elf_section_data (output_section)->rel_count
		  + elf_section_data (output_section)->rel_count2);
  if (link_order->type == bfd_section_reloc_link_order)
    {
      indx = link_order->u.reloc.p->u.section->target_index;
      BFD_ASSERT (indx != 0);
      *rel_hash_ptr = NULL;
    }
  else
    {
      struct elf_link_hash_entry *h;

      /* Treat a reloc against a defined symbol as though it were
	 actually against the section.  */
      h = ((struct elf_link_hash_entry *)
	   bfd_wrapped_link_hash_lookup (output_bfd, info,
					 link_order->u.reloc.p->u.name,
					 FALSE, FALSE, TRUE));
      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak))
	{
	  asection *section;

	  section = h->root.u.def.section;
	  indx = section->output_section->target_index;
	  *rel_hash_ptr = NULL;
	  /* It seems that we ought to add the symbol value to the
	     addend here, but in practice it has already been added
	     because it was passed to constructor_callback.  */
	  addend += section->output_section->vma + section->output_offset;
	}
      else if (h != NULL)
	{
	  /* Setting the index to -2 tells elf_link_output_extsym that
	     this symbol is used by a reloc.  */
	  h->indx = -2;
	  *rel_hash_ptr = h;
	  indx = 0;
	}
      else
	{
	  if (! ((*info->callbacks->unattached_reloc)
		 (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))
	    return FALSE;
	  indx = 0;
	}
    }

  /* If this is an inplace reloc, we must write the addend into the
     object file.  */
  if (howto->partial_inplace && addend != 0)
    {
      bfd_size_type size;
      bfd_reloc_status_type rstat;
      bfd_byte *buf;
      bfd_boolean ok;
      const char *sym_name;

      size = bfd_get_reloc_size (howto);
      buf = bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;
      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);
      switch (rstat)
	{
	case bfd_reloc_ok:
	  break;

	default:
	case bfd_reloc_outofrange:
	  abort ();

	case bfd_reloc_overflow:
	  if (link_order->type == bfd_section_reloc_link_order)
	    sym_name = bfd_section_name (output_bfd,
					 link_order->u.reloc.p->u.section);
	  else
	    sym_name = link_order->u.reloc.p->u.name;
	  if (! ((*info->callbacks->reloc_overflow)
		 (info, sym_name, howto->name, addend, NULL, NULL, 0)))
	    {
	      free (buf);
	      return FALSE;
	    }
	  break;
	}
      ok = bfd_set_section_contents (output_bfd, output_section, buf,
				     link_order->offset, size);
      free (buf);
      if (! ok)
	return FALSE;
    }

  /* The address of a reloc is relative to the section in a
     relocatable file, and is a virtual address in an executable
     file.  */
  offset = link_order->offset;
  if (! info->relocatable)
    offset += output_section->vma;

  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
    {
      irel[i].r_offset = offset;
      irel[i].r_info = 0;
      irel[i].r_addend = 0;
    }
  if (bed->s->arch_size == 32)
    irel[0].r_info = ELF32_R_INFO (indx, howto->type);
  else
    irel[0].r_info = ELF64_R_INFO (indx, howto->type);

  rel_hdr = &elf_section_data (output_section)->rel_hdr;
  erel = rel_hdr->contents;
  if (rel_hdr->sh_type == SHT_REL)
    {
      erel += (elf_section_data (output_section)->rel_count
	       * bed->s->sizeof_rel);
      (*bed->s->swap_reloc_out) (output_bfd, irel, erel);
    }
  else
    {
      irel[0].r_addend = addend;
      erel += (elf_section_data (output_section)->rel_count
	       * bed->s->sizeof_rela);
      (*bed->s->swap_reloca_out) (output_bfd, irel, erel);
    }

  ++elf_section_data (output_section)->rel_count;

  return TRUE;
}

/* Do the final step of an ELF link.  */

bfd_boolean
bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean dynamic;
  bfd_boolean emit_relocs;
  bfd *dynobj;
  struct elf_final_link_info finfo;
  register asection *o;
  register struct bfd_link_order *p;
  register bfd *sub;
  bfd_size_type max_contents_size;
  bfd_size_type max_external_reloc_size;
  bfd_size_type max_internal_reloc_count;
  bfd_size_type max_sym_count;
  bfd_size_type max_sym_shndx_count;
  file_ptr off;
  Elf_Internal_Sym elfsym;
  unsigned int i;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *symtab_shndx_hdr;
  Elf_Internal_Shdr *symstrtab_hdr;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct elf_outext_info eoinfo;
  bfd_boolean merged;
  size_t relativecount = 0;
  asection *reldyn = 0;
  bfd_size_type amt;

  if (! is_elf_hash_table (info->hash))
    return FALSE;

  if (info->shared)
    abfd->flags |= DYNAMIC;

  dynamic = elf_hash_table (info)->dynamic_sections_created;
  dynobj = elf_hash_table (info)->dynobj;

  emit_relocs = (info->relocatable
		 || info->emitrelocations
		 || bed->elf_backend_emit_relocs);

  finfo.info = info;
  finfo.output_bfd = abfd;
  finfo.symstrtab = _bfd_elf_stringtab_init ();
  if (finfo.symstrtab == NULL)
    return FALSE;

  if (! dynamic)
    {
      finfo.dynsym_sec = NULL;
      finfo.hash_sec = NULL;
      finfo.symver_sec = NULL;
    }
  else
    {
      finfo.dynsym_sec = bfd_get_section_by_name (dynobj, ".dynsym");
      finfo.hash_sec = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (finfo.dynsym_sec != NULL && finfo.hash_sec != NULL);
      finfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
      /* Note that it is OK if symver_sec is NULL.  */
    }

  finfo.contents = NULL;
  finfo.external_relocs = NULL;
  finfo.internal_relocs = NULL;
  finfo.external_syms = NULL;
  finfo.locsym_shndx = NULL;
  finfo.internal_syms = NULL;
  finfo.indices = NULL;
  finfo.sections = NULL;
  finfo.symbuf = NULL;
  finfo.symshndxbuf = NULL;
  finfo.symbuf_count = 0;
  finfo.shndxbuf_size = 0;

  /* Count up the number of relocations we will output for each output
     section, so that we know the sizes of the reloc sections.  We
     also figure out some maximum sizes.  */
  max_contents_size = 0;
  max_external_reloc_size = 0;
  max_internal_reloc_count = 0;
  max_sym_count = 0;
  max_sym_shndx_count = 0;
  merged = FALSE;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct bfd_elf_section_data *esdo = elf_section_data (o);
      o->reloc_count = 0;

      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  unsigned int reloc_count = 0;
	  struct bfd_elf_section_data *esdi = NULL;
	  unsigned int *rel_count1;

	  if (p->type == bfd_section_reloc_link_order
	      || p->type == bfd_symbol_reloc_link_order)
	    reloc_count = 1;
	  else if (p->type == bfd_indirect_link_order)
	    {
	      asection *sec;

	      sec = p->u.indirect.section;
	      esdi = elf_section_data (sec);

	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = TRUE;

	      if (sec->flags & SEC_MERGE)
		merged = TRUE;

	      if (info->relocatable || info->emitrelocations)
		reloc_count = sec->reloc_count;
	      else if (bed->elf_backend_count_relocs)
		{
		  Elf_Internal_Rela * relocs;

		  relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
						      info->keep_memory);

		  reloc_count = (*bed->elf_backend_count_relocs) (sec, relocs);

		  if (elf_section_data (o)->relocs != relocs)
		    free (relocs);
		}

	      if (sec->_raw_size > max_contents_size)
		max_contents_size = sec->_raw_size;
	      if (sec->_cooked_size > max_contents_size)
		max_contents_size = sec->_cooked_size;

	      /* We are interested in just local symbols, not all
		 symbols.  */
	      if (bfd_get_flavour (sec->owner) == bfd_target_elf_flavour
		  && (sec->owner->flags & DYNAMIC) == 0)
		{
		  size_t sym_count;

		  if (elf_bad_symtab (sec->owner))
		    sym_count = (elf_tdata (sec->owner)->symtab_hdr.sh_size
				 / bed->s->sizeof_sym);
		  else
		    sym_count = elf_tdata (sec->owner)->symtab_hdr.sh_info;

		  if (sym_count > max_sym_count)
		    max_sym_count = sym_count;

		  if (sym_count > max_sym_shndx_count
		      && elf_symtab_shndx (sec->owner) != 0)
		    max_sym_shndx_count = sym_count;

		  if ((sec->flags & SEC_RELOC) != 0)
		    {
		      size_t ext_size;

		      ext_size = elf_section_data (sec)->rel_hdr.sh_size;
		      if (ext_size > max_external_reloc_size)
			max_external_reloc_size = ext_size;
		      if (sec->reloc_count > max_internal_reloc_count)
			max_internal_reloc_count = sec->reloc_count;
		    }
		}
	    }

	  if (reloc_count == 0)
	    continue;

	  o->reloc_count += reloc_count;

	  /* MIPS may have a mix of REL and RELA relocs on sections.
	     To support this curious ABI we keep reloc counts in
	     elf_section_data too.  We must be careful to add the
	     relocations from the input section to the right output
	     count.  FIXME: Get rid of one count.  We have
	     o->reloc_count == esdo->rel_count + esdo->rel_count2.  */
	  rel_count1 = &esdo->rel_count;
	  if (esdi != NULL)
	    {
	      bfd_boolean same_size;
	      bfd_size_type entsize1;

	      entsize1 = esdi->rel_hdr.sh_entsize;
	      BFD_ASSERT (entsize1 == bed->s->sizeof_rel
			  || entsize1 == bed->s->sizeof_rela);
	      same_size = !o->use_rela_p == (entsize1 == bed->s->sizeof_rel);

	      if (!same_size)
		rel_count1 = &esdo->rel_count2;

	      if (esdi->rel_hdr2 != NULL)
		{
		  bfd_size_type entsize2 = esdi->rel_hdr2->sh_entsize;
		  unsigned int alt_count;
		  unsigned int *rel_count2;

		  BFD_ASSERT (entsize2 != entsize1
			      && (entsize2 == bed->s->sizeof_rel
				  || entsize2 == bed->s->sizeof_rela));

		  rel_count2 = &esdo->rel_count2;
		  if (!same_size)
		    rel_count2 = &esdo->rel_count;

		  /* The following is probably too simplistic if the
		     backend counts output relocs unusually.  */
		  BFD_ASSERT (bed->elf_backend_count_relocs == NULL);
		  alt_count = NUM_SHDR_ENTRIES (esdi->rel_hdr2);
		  *rel_count2 += alt_count;
		  reloc_count -= alt_count;
		}
	    }
	  *rel_count1 += reloc_count;
	}

      if (o->reloc_count > 0)
	o->flags |= SEC_RELOC;
      else
	{
	  /* Explicitly clear the SEC_RELOC flag.  The linker tends to
	     set it (this is probably a bug) and if it is set
	     assign_section_numbers will create a reloc section.  */
	  o->flags &=~ SEC_RELOC;
	}

      /* If the SEC_ALLOC flag is not set, force the section VMA to
	 zero.  This is done in elf_fake_sections as well, but forcing
	 the VMA to 0 here will ensure that relocs against these
	 sections are handled correctly.  */
      if ((o->flags & SEC_ALLOC) == 0
	  && ! o->user_set_vma)
	o->vma = 0;
    }

  if (! info->relocatable && merged)
    elf_link_hash_traverse (elf_hash_table (info),
			    _bfd_elf_link_sec_merge_syms, abfd);

  /* Figure out the file positions for everything but the symbol table
     and the relocs.  We set symcount to force assign_section_numbers
     to create a symbol table.  */
  bfd_get_symcount (abfd) = info->strip == strip_all ? 0 : 1;
  BFD_ASSERT (! abfd->output_has_begun);
  if (! _bfd_elf_compute_section_file_positions (abfd, info))
    goto error_return;

  /* That created the reloc sections.  Set their sizes, and assign
     them file positions, and allocate some buffers.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) != 0)
	{
	  if (!(_bfd_elf_link_size_reloc_section
		(abfd, &elf_section_data (o)->rel_hdr, o)))
	    goto error_return;

	  if (elf_section_data (o)->rel_hdr2
	      && !(_bfd_elf_link_size_reloc_section
		   (abfd, elf_section_data (o)->rel_hdr2, o)))
	    goto error_return;
	}

      /* Now, reset REL_COUNT and REL_COUNT2 so that we can use them
	 to count upwards while actually outputting the relocations.  */
      elf_section_data (o)->rel_count = 0;
      elf_section_data (o)->rel_count2 = 0;
    }

  _bfd_elf_assign_file_positions_for_relocs (abfd);

  /* We have now assigned file positions for all the sections except
     .symtab and .strtab.  We start the .symtab section at the current
     file position, and write directly to it.  We build the .strtab
     section in memory.  */
  bfd_get_symcount (abfd) = 0;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  /* sh_name is set in prep_headers.  */
  symtab_hdr->sh_type = SHT_SYMTAB;
  /* sh_flags, sh_addr and sh_size all start off zero.  */
  symtab_hdr->sh_entsize = bed->s->sizeof_sym;
  /* sh_link is set in assign_section_numbers.  */
  /* sh_info is set below.  */
  /* sh_offset is set just below.  */
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;

  off = elf_tdata (abfd)->next_file_pos;
  off = _bfd_elf_assign_file_position_for_section (symtab_hdr, off, TRUE);

  /* Note that at this point elf_tdata (abfd)->next_file_pos is
     incorrect.  We do not yet know the size of the .symtab section.
     We correct next_file_pos below, after we do know the size.  */

  /* Allocate a buffer to hold swapped out symbols.  This is to avoid
     continuously seeking to the right position in the file.  */
  if (! info->keep_memory || max_sym_count < 20)
    finfo.symbuf_size = 20;
  else
    finfo.symbuf_size = max_sym_count;
  amt = finfo.symbuf_size;
  amt *= bed->s->sizeof_sym;
  finfo.symbuf = bfd_malloc (amt);
  if (finfo.symbuf == NULL)
    goto error_return;
  if (elf_numsections (abfd) > SHN_LORESERVE)
    {
      /* Wild guess at number of output symbols.  realloc'd as needed.  */
      amt = 2 * max_sym_count + elf_numsections (abfd) + 1000;
      finfo.shndxbuf_size = amt;
      amt *= sizeof (Elf_External_Sym_Shndx);
      finfo.symshndxbuf = bfd_zmalloc (amt);
      if (finfo.symshndxbuf == NULL)
	goto error_return;
    }

  /* Start writing out the symbol table.  The first symbol is always a
     dummy symbol.  */
  if (info->strip != strip_all
      || emit_relocs)
    {
      elfsym.st_value = 0;
      elfsym.st_size = 0;
      elfsym.st_info = 0;
      elfsym.st_other = 0;
      elfsym.st_shndx = SHN_UNDEF;
      if (! elf_link_output_sym (&finfo, NULL, &elfsym, bfd_und_section_ptr,
				 NULL))
	goto error_return;
    }

#if 0
  /* Some standard ELF linkers do this, but we don't because it causes
     bootstrap comparison failures.  */
  /* Output a file symbol for the output file as the second symbol.
     We output this even if we are discarding local symbols, although
     I'm not sure if this is correct.  */
  elfsym.st_value = 0;
  elfsym.st_size = 0;
  elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
  elfsym.st_other = 0;
  elfsym.st_shndx = SHN_ABS;
  if (! elf_link_output_sym (&finfo, bfd_get_filename (abfd),
			     &elfsym, bfd_abs_section_ptr, NULL))
    goto error_return;
#endif

  /* Output a symbol for each section.  We output these even if we are
     discarding local symbols, since they are used for relocs.  These
     symbols have no names.  We store the index of each one in the
     index field of the section, so that we can find it again when
     outputting relocs.  */
  if (info->strip != strip_all
      || emit_relocs)
    {
      elfsym.st_size = 0;
      elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
      elfsym.st_other = 0;
      for (i = 1; i < elf_numsections (abfd); i++)
	{
	  o = bfd_section_from_elf_index (abfd, i);
	  if (o != NULL)
	    o->target_index = bfd_get_symcount (abfd);
	  elfsym.st_shndx = i;
	  if (info->relocatable || o == NULL)
	    elfsym.st_value = 0;
	  else
	    elfsym.st_value = o->vma;
	  if (! elf_link_output_sym (&finfo, NULL, &elfsym, o, NULL))
	    goto error_return;
	  if (i == SHN_LORESERVE - 1)
	    i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	}
    }

  /* Allocate some memory to hold information read in from the input
     files.  */
  if (max_contents_size != 0)
    {
      finfo.contents = bfd_malloc (max_contents_size);
      if (finfo.contents == NULL)
	goto error_return;
    }

  if (max_external_reloc_size != 0)
    {
      finfo.external_relocs = bfd_malloc (max_external_reloc_size);
      if (finfo.external_relocs == NULL)
	goto error_return;
    }

  if (max_internal_reloc_count != 0)
    {
      amt = max_internal_reloc_count * bed->s->int_rels_per_ext_rel;
      amt *= sizeof (Elf_Internal_Rela);
      finfo.internal_relocs = bfd_malloc (amt);
      if (finfo.internal_relocs == NULL)
	goto error_return;
    }

  if (max_sym_count != 0)
    {
      amt = max_sym_count * bed->s->sizeof_sym;
      finfo.external_syms = bfd_malloc (amt);
      if (finfo.external_syms == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (Elf_Internal_Sym);
      finfo.internal_syms = bfd_malloc (amt);
      if (finfo.internal_syms == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (long);
      finfo.indices = bfd_malloc (amt);
      if (finfo.indices == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (asection *);
      finfo.sections = bfd_malloc (amt);
      if (finfo.sections == NULL)
	goto error_return;
    }

  if (max_sym_shndx_count != 0)
    {
      amt = max_sym_shndx_count * sizeof (Elf_External_Sym_Shndx);
      finfo.locsym_shndx = bfd_malloc (amt);
      if (finfo.locsym_shndx == NULL)
	goto error_return;
    }

  if (elf_hash_table (info)->tls_sec)
    {
      bfd_vma base, end = 0;
      asection *sec;

      for (sec = elf_hash_table (info)->tls_sec;
	   sec && (sec->flags & SEC_THREAD_LOCAL);
	   sec = sec->next)
	{
	  bfd_vma size = sec->_raw_size;

	  if (size == 0 && (sec->flags & SEC_HAS_CONTENTS) == 0)
	    {
	      struct bfd_link_order *o;

	      for (o = sec->link_order_head; o != NULL; o = o->next)
		if (size < o->offset + o->size)
		  size = o->offset + o->size;
	    }
	  end = sec->vma + size;
	}
      base = elf_hash_table (info)->tls_sec->vma;
      end = align_power (end, elf_hash_table (info)->tls_sec->alignment_power);
      elf_hash_table (info)->tls_size = end - base;
    }

  /* Since ELF permits relocations to be against local symbols, we
     must have the local symbols available when we do the relocations.
     Since we would rather only read the local symbols once, and we
     would rather not keep them in memory, we handle all the
     relocations for a single input file at the same time.

     Unfortunately, there is no way to know the total number of local
     symbols until we have seen all of them, and the local symbol
     indices precede the global symbol indices.  This means that when
     we are generating relocatable output, and we see a reloc against
     a global symbol, we can not know the symbol index until we have
     finished examining all the local symbols to see which ones we are
     going to output.  To deal with this, we keep the relocations in
     memory, and don't output them until the end of the link.  This is
     an unfortunate waste of memory, but I don't see a good way around
     it.  Fortunately, it only happens when performing a relocatable
     link, which is not the common case.  FIXME: If keep_memory is set
     we could write the relocs out and then read them again; I don't
     know how bad the memory loss will be.  */

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    sub->output_has_begun = FALSE;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && (bfd_get_flavour ((sub = p->u.indirect.section->owner))
		  == bfd_target_elf_flavour)
	      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass)
	    {
	      if (! sub->output_has_begun)
		{
		  if (! elf_link_input_bfd (&finfo, sub))
		    goto error_return;
		  sub->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! elf_reloc_link_order (abfd, info, o, p))
		goto error_return;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
	    }
	}
    }

  /* Output any global symbols that got converted to local in a
     version script or due to symbol visibility.  We do this in a
     separate step since ELF requires all local symbols to appear
     prior to any global symbols.  FIXME: We should only do this if
     some global symbols were, in fact, converted to become local.
     FIXME: Will this work correctly with the Irix 5 linker?  */
  eoinfo.failed = FALSE;
  eoinfo.finfo = &finfo;
  eoinfo.localsyms = TRUE;
  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
			  &eoinfo);
  if (eoinfo.failed)
    return FALSE;

  /* That wrote out all the local symbols.  Finish up the symbol table
     with the global symbols. Even if we want to strip everything we
     can, we still need to deal with those global symbols that got
     converted to local in a version script.  */

  /* The sh_info field records the index of the first non local symbol.  */
  symtab_hdr->sh_info = bfd_get_symcount (abfd);

  if (dynamic
      && finfo.dynsym_sec->output_section != bfd_abs_section_ptr)
    {
      Elf_Internal_Sym sym;
      bfd_byte *dynsym = finfo.dynsym_sec->contents;
      long last_local = 0;

      /* Write out the section symbols for the output sections.  */
      if (info->shared)
	{
	  asection *s;

	  sym.st_size = 0;
	  sym.st_name = 0;
	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	  sym.st_other = 0;

	  for (s = abfd->sections; s != NULL; s = s->next)
	    {
	      int indx;
	      bfd_byte *dest;
	      long dynindx;

	      indx = elf_section_data (s)->this_idx;
	      dynindx = elf_section_data (s)->dynindx;
	      BFD_ASSERT (indx > 0);
	      sym.st_shndx = indx;
	      sym.st_value = s->vma;
	      dest = dynsym + dynindx * bed->s->sizeof_sym;
	      bed->s->swap_symbol_out (abfd, &sym, dest, 0);
	    }

	  last_local = bfd_count_sections (abfd);
	}

      /* Write out the local dynsyms.  */
      if (elf_hash_table (info)->dynlocal)
	{
	  struct elf_link_local_dynamic_entry *e;
	  for (e = elf_hash_table (info)->dynlocal; e ; e = e->next)
	    {
	      asection *s;
	      bfd_byte *dest;

	      sym.st_size = e->isym.st_size;
	      sym.st_other = e->isym.st_other;

	      /* Copy the internal symbol as is.
		 Note that we saved a word of storage and overwrote
		 the original st_name with the dynstr_index.  */
	      sym = e->isym;

	      if (e->isym.st_shndx != SHN_UNDEF
		  && (e->isym.st_shndx < SHN_LORESERVE
		      || e->isym.st_shndx > SHN_HIRESERVE))
		{
		  s = bfd_section_from_elf_index (e->input_bfd,
						  e->isym.st_shndx);

		  sym.st_shndx =
		    elf_section_data (s->output_section)->this_idx;
		  sym.st_value = (s->output_section->vma
				  + s->output_offset
				  + e->isym.st_value);
		}

	      if (last_local < e->dynindx)
		last_local = e->dynindx;

	      dest = dynsym + e->dynindx * bed->s->sizeof_sym;
	      bed->s->swap_symbol_out (abfd, &sym, dest, 0);
	    }
	}

      elf_section_data (finfo.dynsym_sec->output_section)->this_hdr.sh_info =
	last_local + 1;
    }

  /* We get the global symbols from the hash table.  */
  eoinfo.failed = FALSE;
  eoinfo.localsyms = FALSE;
  eoinfo.finfo = &finfo;
  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
			  &eoinfo);
  if (eoinfo.failed)
    return FALSE;

  /* If backend needs to output some symbols not present in the hash
     table, do it now.  */
  if (bed->elf_backend_output_arch_syms)
    {
      typedef bfd_boolean (*out_sym_func)
	(void *, const char *, Elf_Internal_Sym *, asection *,
	 struct elf_link_hash_entry *);

      if (! ((*bed->elf_backend_output_arch_syms)
	     (abfd, info, &finfo, (out_sym_func) elf_link_output_sym)))
	return FALSE;
    }

  /* Flush all symbols to the file.  */
  if (! elf_link_flush_output_syms (&finfo, bed))
    return FALSE;

  /* Now we know the size of the symtab section.  */
  off += symtab_hdr->sh_size;

  symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (symtab_shndx_hdr->sh_name != 0)
    {
      symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
      symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
      amt = bfd_get_symcount (abfd) * sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_size = amt;

      off = _bfd_elf_assign_file_position_for_section (symtab_shndx_hdr,
						       off, TRUE);

      if (bfd_seek (abfd, symtab_shndx_hdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bwrite (finfo.symshndxbuf, amt, abfd) != amt))
	return FALSE;
    }


  /* Finish up and write out the symbol string table (.strtab)
     section.  */
  symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;
  /* sh_name was set in prep_headers.  */
  symstrtab_hdr->sh_type = SHT_STRTAB;
  symstrtab_hdr->sh_flags = 0;
  symstrtab_hdr->sh_addr = 0;
  symstrtab_hdr->sh_size = _bfd_stringtab_size (finfo.symstrtab);
  symstrtab_hdr->sh_entsize = 0;
  symstrtab_hdr->sh_link = 0;
  symstrtab_hdr->sh_info = 0;
  /* sh_offset is set just below.  */
  symstrtab_hdr->sh_addralign = 1;

  off = _bfd_elf_assign_file_position_for_section (symstrtab_hdr, off, TRUE);
  elf_tdata (abfd)->next_file_pos = off;

  if (bfd_get_symcount (abfd) > 0)
    {
      if (bfd_seek (abfd, symstrtab_hdr->sh_offset, SEEK_SET) != 0
	  || ! _bfd_stringtab_emit (abfd, finfo.symstrtab))
	return FALSE;
    }

  /* Adjust the relocs to have the correct symbol indices.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) == 0)
	continue;

      elf_link_adjust_relocs (abfd, &elf_section_data (o)->rel_hdr,
			      elf_section_data (o)->rel_count,
			      elf_section_data (o)->rel_hashes);
      if (elf_section_data (o)->rel_hdr2 != NULL)
	elf_link_adjust_relocs (abfd, elf_section_data (o)->rel_hdr2,
				elf_section_data (o)->rel_count2,
				(elf_section_data (o)->rel_hashes
				 + elf_section_data (o)->rel_count));

      /* Set the reloc_count field to 0 to prevent write_relocs from
	 trying to swap the relocs out itself.  */
      o->reloc_count = 0;
    }

  if (dynamic && info->combreloc && dynobj != NULL)
    relativecount = elf_link_sort_relocs (abfd, info, &reldyn);

  /* If we are linking against a dynamic object, or generating a
     shared library, finish up the dynamic linking information.  */
  if (dynamic)
    {
      bfd_byte *dyncon, *dynconend;

      /* Fix up .dynamic entries.  */
      o = bfd_get_section_by_name (dynobj, ".dynamic");
      BFD_ASSERT (o != NULL);

      dyncon = o->contents;
      dynconend = o->contents + o->_raw_size;
      for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  unsigned int type;

	  bed->s->swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      continue;
	    case DT_NULL:
	      if (relativecount > 0 && dyncon + bed->s->sizeof_dyn < dynconend)
		{
		  switch (elf_section_data (reldyn)->this_hdr.sh_type)
		    {
		    case SHT_REL: dyn.d_tag = DT_RELCOUNT; break;
		    case SHT_RELA: dyn.d_tag = DT_RELACOUNT; break;
		    default: continue;
		    }
		  dyn.d_un.d_val = relativecount;
		  relativecount = 0;
		  break;
		}
	      continue;

	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;
	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      {
		struct elf_link_hash_entry *h;

		h = elf_link_hash_lookup (elf_hash_table (info), name,
					  FALSE, FALSE, TRUE);
		if (h != NULL
		    && (h->root.type == bfd_link_hash_defined
			|| h->root.type == bfd_link_hash_defweak))
		  {
		    dyn.d_un.d_val = h->root.u.def.value;
		    o = h->root.u.def.section;
		    if (o->output_section != NULL)
		      dyn.d_un.d_val += (o->output_section->vma
					 + o->output_offset);
		    else
		      {
			/* The symbol is imported from another shared
			   library and does not apply to this one.  */
			dyn.d_un.d_val = 0;
		      }
		    break;
		  }
	      }
	      continue;

	    case DT_PREINIT_ARRAYSZ:
	      name = ".preinit_array";
	      goto get_size;
	    case DT_INIT_ARRAYSZ:
	      name = ".init_array";
	      goto get_size;
	    case DT_FINI_ARRAYSZ:
	      name = ".fini_array";
	    get_size:
	      o = bfd_get_section_by_name (abfd, name);
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
		  goto error_return;
		}
	      if (o->_raw_size == 0)
		(*_bfd_error_handler)
		  (_("warning: %s section has zero size"), name);
	      dyn.d_un.d_val = o->_raw_size;
	      break;

	    case DT_PREINIT_ARRAY:
	      name = ".preinit_array";
	      goto get_vma;
	    case DT_INIT_ARRAY:
	      name = ".init_array";
	      goto get_vma;
	    case DT_FINI_ARRAY:
	      name = ".fini_array";
	      goto get_vma;

	    case DT_HASH:
	      name = ".hash";
	      goto get_vma;
	    case DT_STRTAB:
	      name = ".dynstr";
	      goto get_vma;
	    case DT_SYMTAB:
	      name = ".dynsym";
	      goto get_vma;
	    case DT_VERDEF:
	      name = ".gnu.version_d";
	      goto get_vma;
	    case DT_VERNEED:
	      name = ".gnu.version_r";
	      goto get_vma;
	    case DT_VERSYM:
	      name = ".gnu.version";
	    get_vma:
	      o = bfd_get_section_by_name (abfd, name);
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
		  goto error_return;
		}
	      dyn.d_un.d_ptr = o->vma;
	      break;

	    case DT_REL:
	    case DT_RELA:
	    case DT_RELSZ:
	    case DT_RELASZ:
	      if (dyn.d_tag == DT_REL || dyn.d_tag == DT_RELSZ)
		type = SHT_REL;
	      else
		type = SHT_RELA;
	      dyn.d_un.d_val = 0;
	      for (i = 1; i < elf_numsections (abfd); i++)
		{
		  Elf_Internal_Shdr *hdr;

		  hdr = elf_elfsections (abfd)[i];
		  if (hdr->sh_type == type
		      && (hdr->sh_flags & SHF_ALLOC) != 0)
		    {
		      if (dyn.d_tag == DT_RELSZ || dyn.d_tag == DT_RELASZ)
			dyn.d_un.d_val += hdr->sh_size;
		      else
			{
			  if (dyn.d_un.d_val == 0
			      || hdr->sh_addr < dyn.d_un.d_val)
			    dyn.d_un.d_val = hdr->sh_addr;
			}
		    }
		}
	      break;
	    }
	  bed->s->swap_dyn_out (dynobj, &dyn, dyncon);
	}
    }

  /* If we have created any dynamic sections, then output them.  */
  if (dynobj != NULL)
    {
      if (! (*bed->elf_backend_finish_dynamic_sections) (abfd, info))
	goto error_return;

      for (o = dynobj->sections; o != NULL; o = o->next)
	{
	  if ((o->flags & SEC_HAS_CONTENTS) == 0
	      || o->_raw_size == 0
	      || o->output_section == bfd_abs_section_ptr)
	    continue;
	  if ((o->flags & SEC_LINKER_CREATED) == 0)
	    {
	      /* At this point, we are only interested in sections
		 created by _bfd_elf_link_create_dynamic_sections.  */
	      continue;
	    }
	  if ((elf_section_data (o->output_section)->this_hdr.sh_type
	       != SHT_STRTAB)
	      || strcmp (bfd_get_section_name (abfd, o), ".dynstr") != 0)
	    {
	      if (! bfd_set_section_contents (abfd, o->output_section,
					      o->contents,
					      (file_ptr) o->output_offset,
					      o->_raw_size))
		goto error_return;
	    }
	  else
	    {
	      /* The contents of the .dynstr section are actually in a
		 stringtab.  */
	      off = elf_section_data (o->output_section)->this_hdr.sh_offset;
	      if (bfd_seek (abfd, off, SEEK_SET) != 0
		  || ! _bfd_elf_strtab_emit (abfd,
					     elf_hash_table (info)->dynstr))
		goto error_return;
	    }
	}
    }

  if (info->relocatable)
    {
      bfd_boolean failed = FALSE;

      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
      if (failed)
	goto error_return;
    }

  /* If we have optimized stabs strings, output them.  */
  if (elf_hash_table (info)->stab_info != NULL)
    {
      if (! _bfd_write_stab_strings (abfd, &elf_hash_table (info)->stab_info))
	goto error_return;
    }

  if (info->eh_frame_hdr)
    {
      if (! _bfd_elf_write_section_eh_frame_hdr (abfd, info))
	goto error_return;
    }

  if (finfo.symstrtab != NULL)
    _bfd_stringtab_free (finfo.symstrtab);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
  if (finfo.external_syms != NULL)
    free (finfo.external_syms);
  if (finfo.locsym_shndx != NULL)
    free (finfo.locsym_shndx);
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.indices != NULL)
    free (finfo.indices);
  if (finfo.sections != NULL)
    free (finfo.sections);
  if (finfo.symbuf != NULL)
    free (finfo.symbuf);
  if (finfo.symshndxbuf != NULL)
    free (finfo.symshndxbuf);
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) != 0
	  && elf_section_data (o)->rel_hashes != NULL)
	free (elf_section_data (o)->rel_hashes);
    }

  elf_tdata (abfd)->linker = TRUE;

  return TRUE;

 error_return:
  if (finfo.symstrtab != NULL)
    _bfd_stringtab_free (finfo.symstrtab);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
  if (finfo.external_syms != NULL)
    free (finfo.external_syms);
  if (finfo.locsym_shndx != NULL)
    free (finfo.locsym_shndx);
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.indices != NULL)
    free (finfo.indices);
  if (finfo.sections != NULL)
    free (finfo.sections);
  if (finfo.symbuf != NULL)
    free (finfo.symbuf);
  if (finfo.symshndxbuf != NULL)
    free (finfo.symshndxbuf);
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) != 0
	  && elf_section_data (o)->rel_hashes != NULL)
	free (elf_section_data (o)->rel_hashes);
    }

  return FALSE;
}

/* Garbage collect unused sections.  */

/* The mark phase of garbage collection.  For a given section, mark
   it and any sections in this section's group, and all the sections
   which define symbols to which it refers.  */

typedef asection * (*gc_mark_hook_fn)
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

static bfd_boolean
elf_gc_mark (struct bfd_link_info *info,
	     asection *sec,
	     gc_mark_hook_fn gc_mark_hook)
{
  bfd_boolean ret;
  asection *group_sec;

  sec->gc_mark = 1;

  /* Mark all the sections in the group.  */
  group_sec = elf_section_data (sec)->next_in_group;
  if (group_sec && !group_sec->gc_mark)
    if (!elf_gc_mark (info, group_sec, gc_mark_hook))
      return FALSE;

  /* Look through the section relocs.  */
  ret = TRUE;
  if ((sec->flags & SEC_RELOC) != 0 && sec->reloc_count > 0)
    {
      Elf_Internal_Rela *relstart, *rel, *relend;
      Elf_Internal_Shdr *symtab_hdr;
      struct elf_link_hash_entry **sym_hashes;
      size_t nlocsyms;
      size_t extsymoff;
      bfd *input_bfd = sec->owner;
      const struct elf_backend_data *bed = get_elf_backend_data (input_bfd);
      Elf_Internal_Sym *isym = NULL;
      int r_sym_shift;

      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      sym_hashes = elf_sym_hashes (input_bfd);

      /* Read the local symbols.  */
      if (elf_bad_symtab (input_bfd))
	{
	  nlocsyms = symtab_hdr->sh_size / bed->s->sizeof_sym;
	  extsymoff = 0;
	}
      else
	extsymoff = nlocsyms = symtab_hdr->sh_info;

      isym = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isym == NULL && nlocsyms != 0)
	{
	  isym = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, nlocsyms, 0,
				       NULL, NULL, NULL);
	  if (isym == NULL)
	    return FALSE;
	}

      /* Read the relocations.  */
      relstart = _bfd_elf_link_read_relocs (input_bfd, sec, NULL, NULL,
					    info->keep_memory);
      if (relstart == NULL)
	{
	  ret = FALSE;
	  goto out1;
	}
      relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;

      if (bed->s->arch_size == 32)
	r_sym_shift = 8;
      else
	r_sym_shift = 32;

      for (rel = relstart; rel < relend; rel++)
	{
	  unsigned long r_symndx;
	  asection *rsec;
	  struct elf_link_hash_entry *h;

	  r_symndx = rel->r_info >> r_sym_shift;
	  if (r_symndx == 0)
	    continue;

	  if (r_symndx >= nlocsyms
	      || ELF_ST_BIND (isym[r_symndx].st_info) != STB_LOCAL)
	    {
	      h = sym_hashes[r_symndx - extsymoff];
	      rsec = (*gc_mark_hook) (sec, info, rel, h, NULL);
	    }
	  else
	    {
	      rsec = (*gc_mark_hook) (sec, info, rel, NULL, &isym[r_symndx]);
	    }

	  if (rsec && !rsec->gc_mark)
	    {
	      if (bfd_get_flavour (rsec->owner) != bfd_target_elf_flavour)
		rsec->gc_mark = 1;
	      else if (!elf_gc_mark (info, rsec, gc_mark_hook))
		{
		  ret = FALSE;
		  goto out2;
		}
	    }
	}

    out2:
      if (elf_section_data (sec)->relocs != relstart)
	free (relstart);
    out1:
      if (isym != NULL && symtab_hdr->contents != (unsigned char *) isym)
	{
	  if (! info->keep_memory)
	    free (isym);
	  else
	    symtab_hdr->contents = (unsigned char *) isym;
	}
    }

  return ret;
}

/* Sweep symbols in swept sections.  Called via elf_link_hash_traverse.  */

static bfd_boolean
elf_gc_sweep_symbol (struct elf_link_hash_entry *h, void *idxptr)
{
  int *idx = idxptr;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx != -1
      && ((h->root.type != bfd_link_hash_defined
	   && h->root.type != bfd_link_hash_defweak)
	  || h->root.u.def.section->gc_mark))
    h->dynindx = (*idx)++;

  return TRUE;
}

/* The sweep phase of garbage collection.  Remove all garbage sections.  */

typedef bfd_boolean (*gc_sweep_hook_fn)
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);

static bfd_boolean
elf_gc_sweep (struct bfd_link_info *info, gc_sweep_hook_fn gc_sweep_hook)
{
  bfd *sub;

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *o;

      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
	continue;

      for (o = sub->sections; o != NULL; o = o->next)
	{
	  /* Keep special sections.  Keep .debug sections.  */
	  if ((o->flags & SEC_LINKER_CREATED)
	      || (o->flags & SEC_DEBUGGING))
	    o->gc_mark = 1;

	  if (o->gc_mark)
	    continue;

	  /* Skip sweeping sections already excluded.  */
	  if (o->flags & SEC_EXCLUDE)
	    continue;

	  /* Since this is early in the link process, it is simple
	     to remove a section from the output.  */
	  o->flags |= SEC_EXCLUDE;

	  /* But we also have to update some of the relocation
	     info we collected before.  */
	  if (gc_sweep_hook
	      && (o->flags & SEC_RELOC) && o->reloc_count > 0)
	    {
	      Elf_Internal_Rela *internal_relocs;
	      bfd_boolean r;

	      internal_relocs
		= _bfd_elf_link_read_relocs (o->owner, o, NULL, NULL,
					     info->keep_memory);
	      if (internal_relocs == NULL)
		return FALSE;

	      r = (*gc_sweep_hook) (o->owner, info, o, internal_relocs);

	      if (elf_section_data (o)->relocs != internal_relocs)
		free (internal_relocs);

	      if (!r)
		return FALSE;
	    }
	}
    }

  /* Remove the symbols that were in the swept sections from the dynamic
     symbol table.  GCFIXME: Anyone know how to get them out of the
     static symbol table as well?  */
  {
    int i = 0;

    elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol, &i);

    elf_hash_table (info)->dynsymcount = i;
  }

  return TRUE;
}

/* Propagate collected vtable information.  This is called through
   elf_link_hash_traverse.  */

static bfd_boolean
elf_gc_propagate_vtable_entries_used (struct elf_link_hash_entry *h, void *okp)
{
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Those that are not vtables.  */
  if (h->vtable_parent == NULL)
    return TRUE;

  /* Those vtables that do not have parents, we cannot merge.  */
  if (h->vtable_parent == (struct elf_link_hash_entry *) -1)
    return TRUE;

  /* If we've already been done, exit.  */
  if (h->vtable_entries_used && h->vtable_entries_used[-1])
    return TRUE;

  /* Make sure the parent's table is up to date.  */
  elf_gc_propagate_vtable_entries_used (h->vtable_parent, okp);

  if (h->vtable_entries_used == NULL)
    {
      /* None of this table's entries were referenced.  Re-use the
	 parent's table.  */
      h->vtable_entries_used = h->vtable_parent->vtable_entries_used;
      h->vtable_entries_size = h->vtable_parent->vtable_entries_size;
    }
  else
    {
      size_t n;
      bfd_boolean *cu, *pu;

      /* Or the parent's entries into ours.  */
      cu = h->vtable_entries_used;
      cu[-1] = TRUE;
      pu = h->vtable_parent->vtable_entries_used;
      if (pu != NULL)
	{
	  const struct elf_backend_data *bed;
	  unsigned int log_file_align;

	  bed = get_elf_backend_data (h->root.u.def.section->owner);
	  log_file_align = bed->s->log_file_align;
	  n = h->vtable_parent->vtable_entries_size >> log_file_align;
	  while (n--)
	    {
	      if (*pu)
		*cu = TRUE;
	      pu++;
	      cu++;
	    }
	}
    }

  return TRUE;
}

static bfd_boolean
elf_gc_smash_unused_vtentry_relocs (struct elf_link_hash_entry *h, void *okp)
{
  asection *sec;
  bfd_vma hstart, hend;
  Elf_Internal_Rela *relstart, *relend, *rel;
  const struct elf_backend_data *bed;
  unsigned int log_file_align;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Take care of both those symbols that do not describe vtables as
     well as those that are not loaded.  */
  if (h->vtable_parent == NULL)
    return TRUE;

  BFD_ASSERT (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak);

  sec = h->root.u.def.section;
  hstart = h->root.u.def.value;
  hend = hstart + h->size;

  relstart = _bfd_elf_link_read_relocs (sec->owner, sec, NULL, NULL, TRUE);
  if (!relstart)
    return *(bfd_boolean *) okp = FALSE;
  bed = get_elf_backend_data (sec->owner);
  log_file_align = bed->s->log_file_align;

  relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;

  for (rel = relstart; rel < relend; ++rel)
    if (rel->r_offset >= hstart && rel->r_offset < hend)
      {
	/* If the entry is in use, do nothing.  */
	if (h->vtable_entries_used
	    && (rel->r_offset - hstart) < h->vtable_entries_size)
	  {
	    bfd_vma entry = (rel->r_offset - hstart) >> log_file_align;
	    if (h->vtable_entries_used[entry])
	      continue;
	  }
	/* Otherwise, kill it.  */
	rel->r_offset = rel->r_info = rel->r_addend = 0;
      }

  return TRUE;
}

/* Do mark and sweep of unused sections.  */

bfd_boolean
bfd_elf_gc_sections (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean ok = TRUE;
  bfd *sub;
  asection * (*gc_mark_hook)
    (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *);

  if (!get_elf_backend_data (abfd)->can_gc_sections
      || info->relocatable
      || info->emitrelocations
      || !is_elf_hash_table (info->hash)
      || elf_hash_table (info)->dynamic_sections_created)
    {
      (*_bfd_error_handler)(_("Warning: gc-sections option ignored"));
      return TRUE;
    }

  /* Apply transitive closure to the vtable entry usage info.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_propagate_vtable_entries_used,
			  &ok);
  if (!ok)
    return FALSE;

  /* Kill the vtable relocations that were not used.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_smash_unused_vtentry_relocs,
			  &ok);
  if (!ok)
    return FALSE;

  /* Grovel through relocs to find out who stays ...  */

  gc_mark_hook = get_elf_backend_data (abfd)->gc_mark_hook;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *o;

      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
	continue;

      for (o = sub->sections; o != NULL; o = o->next)
	{
	  if (o->flags & SEC_KEEP)
	    if (!elf_gc_mark (info, o, gc_mark_hook))
	      return FALSE;
	}
    }

  /* ... and mark SEC_EXCLUDE for those that go.  */
  if (!elf_gc_sweep (info, get_elf_backend_data (abfd)->gc_sweep_hook))
    return FALSE;

  return TRUE;
}

/* Called from check_relocs to record the existence of a VTINHERIT reloc.  */

bfd_boolean
bfd_elf_gc_record_vtinherit (bfd *abfd,
			     asection *sec,
			     struct elf_link_hash_entry *h,
			     bfd_vma offset)
{
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
  struct elf_link_hash_entry **search, *child;
  bfd_size_type extsymcount;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols at
     this point.  */
  extsymcount = elf_tdata (abfd)->symtab_hdr.sh_size / bed->s->sizeof_sym;
  if (!elf_bad_symtab (abfd))
    extsymcount -= elf_tdata (abfd)->symtab_hdr.sh_info;

  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes + extsymcount;

  /* Hunt down the child symbol, which is in this section at the same
     offset as the relocation.  */
  for (search = sym_hashes; search != sym_hashes_end; ++search)
    {
      if ((child = *search) != NULL
	  && (child->root.type == bfd_link_hash_defined
	      || child->root.type == bfd_link_hash_defweak)
	  && child->root.u.def.section == sec
	  && child->root.u.def.value == offset)
	goto win;
    }

  (*_bfd_error_handler) ("%s: %s+%lu: No symbol found for INHERIT",
			 bfd_archive_filename (abfd), sec->name,
			 (unsigned long) offset);
  bfd_set_error (bfd_error_invalid_operation);
  return FALSE;

 win:
  if (!h)
    {
      /* This *should* only be the absolute section.  It could potentially
	 be that someone has defined a non-global vtable though, which
	 would be bad.  It isn't worth paging in the local symbols to be
	 sure though; that case should simply be handled by the assembler.  */

      child->vtable_parent = (struct elf_link_hash_entry *) -1;
    }
  else
    child->vtable_parent = h;

  return TRUE;
}

/* Called from check_relocs to record the existence of a VTENTRY reloc.  */

bfd_boolean
bfd_elf_gc_record_vtentry (bfd *abfd ATTRIBUTE_UNUSED,
			   asection *sec ATTRIBUTE_UNUSED,
			   struct elf_link_hash_entry *h,
			   bfd_vma addend)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  unsigned int log_file_align = bed->s->log_file_align;

  if (addend >= h->vtable_entries_size)
    {
      size_t size, bytes, file_align;
      bfd_boolean *ptr = h->vtable_entries_used;

      /* While the symbol is undefined, we have to be prepared to handle
	 a zero size.  */
      file_align = 1 << log_file_align;
      if (h->root.type == bfd_link_hash_undefined)
	size = addend + file_align;
      else
	{
	  size = h->size;
	  if (addend >= size)
	    {
	      /* Oops!  We've got a reference past the defined end of
		 the table.  This is probably a bug -- shall we warn?  */
	      size = addend + file_align;
	    }
	}
      size = (size + file_align - 1) & -file_align;

      /* Allocate one extra entry for use as a "done" flag for the
	 consolidation pass.  */
      bytes = ((size >> log_file_align) + 1) * sizeof (bfd_boolean);

      if (ptr)
	{
	  ptr = bfd_realloc (ptr - 1, bytes);

	  if (ptr != NULL)
	    {
	      size_t oldbytes;

	      oldbytes = (((h->vtable_entries_size >> log_file_align) + 1)
			  * sizeof (bfd_boolean));
	      memset (((char *) ptr) + oldbytes, 0, bytes - oldbytes);
	    }
	}
      else
	ptr = bfd_zmalloc (bytes);

      if (ptr == NULL)
	return FALSE;

      /* And arrange for that done flag to be at index -1.  */
      h->vtable_entries_used = ptr + 1;
      h->vtable_entries_size = size;
    }

  h->vtable_entries_used[addend >> log_file_align] = TRUE;

  return TRUE;
}

struct alloc_got_off_arg {
  bfd_vma gotoff;
  unsigned int got_elt_size;
};

/* We need a special top-level link routine to convert got reference counts
   to real got offsets.  */

static bfd_boolean
elf_gc_allocate_got_offsets (struct elf_link_hash_entry *h, void *arg)
{
  struct alloc_got_off_arg *gofarg = arg;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->got.refcount > 0)
    {
      h->got.offset = gofarg->gotoff;
      gofarg->gotoff += gofarg->got_elt_size;
    }
  else
    h->got.offset = (bfd_vma) -1;

  return TRUE;
}

/* And an accompanying bit to work out final got entry offsets once
   we're done.  Should be called from final_link.  */

bfd_boolean
bfd_elf_gc_common_finalize_got_offsets (bfd *abfd,
					struct bfd_link_info *info)
{
  bfd *i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_vma gotoff;
  unsigned int got_elt_size = bed->s->arch_size / 8;
  struct alloc_got_off_arg gofarg;

  if (! is_elf_hash_table (info->hash))
    return FALSE;

  /* The GOT offset is relative to the .got section, but the GOT header is
     put into the .got.plt section, if the backend uses it.  */
  if (bed->want_got_plt)
    gotoff = 0;
  else
    gotoff = bed->got_header_size;

  /* Do the local .got entries first.  */
  for (i = info->input_bfds; i; i = i->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_size_type j, locsymcount;
      Elf_Internal_Shdr *symtab_hdr;

      if (bfd_get_flavour (i) != bfd_target_elf_flavour)
	continue;

      local_got = elf_local_got_refcounts (i);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (i)->symtab_hdr;
      if (elf_bad_symtab (i))
	locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      else
	locsymcount = symtab_hdr->sh_info;

      for (j = 0; j < locsymcount; ++j)
	{
	  if (local_got[j] > 0)
	    {
	      local_got[j] = gotoff;
	      gotoff += got_elt_size;
	    }
	  else
	    local_got[j] = (bfd_vma) -1;
	}
    }

  /* Then the global .got entries.  .plt refcounts are handled by
     adjust_dynamic_symbol  */
  gofarg.gotoff = gotoff;
  gofarg.got_elt_size = got_elt_size;
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_allocate_got_offsets,
			  &gofarg);
  return TRUE;
}

/* Many folk need no more in the way of final link than this, once
   got entry reference counting is enabled.  */

bfd_boolean
bfd_elf_gc_common_final_link (bfd *abfd, struct bfd_link_info *info)
{
  if (!bfd_elf_gc_common_finalize_got_offsets (abfd, info))
    return FALSE;

  /* Invoke the regular ELF backend linker to do all the work.  */
  return bfd_elf_final_link (abfd, info);
}

bfd_boolean
bfd_elf_reloc_symbol_deleted_p (bfd_vma offset, void *cookie)
{
  struct elf_reloc_cookie *rcookie = cookie;

  if (rcookie->bad_symtab)
    rcookie->rel = rcookie->rels;

  for (; rcookie->rel < rcookie->relend; rcookie->rel++)
    {
      unsigned long r_symndx;

      if (! rcookie->bad_symtab)
	if (rcookie->rel->r_offset > offset)
	  return FALSE;
      if (rcookie->rel->r_offset != offset)
	continue;

      r_symndx = rcookie->rel->r_info >> rcookie->r_sym_shift;
      if (r_symndx == SHN_UNDEF)
	return TRUE;

      if (r_symndx >= rcookie->locsymcount
	  || ELF_ST_BIND (rcookie->locsyms[r_symndx].st_info) != STB_LOCAL)
	{
	  struct elf_link_hash_entry *h;

	  h = rcookie->sym_hashes[r_symndx - rcookie->extsymoff];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && elf_discarded_section (h->root.u.def.section))
	    return TRUE;
	  else
	    return FALSE;
	}
      else
	{
	  /* It's not a relocation against a global symbol,
	     but it could be a relocation against a local
	     symbol for a discarded section.  */
	  asection *isec;
	  Elf_Internal_Sym *isym;

	  /* Need to: get the symbol; get the section.  */
	  isym = &rcookie->locsyms[r_symndx];
	  if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
	    {
	      isec = bfd_section_from_elf_index (rcookie->abfd, isym->st_shndx);
	      if (isec != NULL && elf_discarded_section (isec))
		return TRUE;
	    }
	}
      return FALSE;
    }
  return FALSE;
}

/* Discard unneeded references to discarded sections.
   Returns TRUE if any section's size was changed.  */
/* This function assumes that the relocations are in sorted order,
   which is true for all known assemblers.  */

bfd_boolean
bfd_elf_discard_info (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_reloc_cookie cookie;
  asection *stab, *eh;
  Elf_Internal_Shdr *symtab_hdr;
  const struct elf_backend_data *bed;
  bfd *abfd;
  unsigned int count;
  bfd_boolean ret = FALSE;

  if (info->traditional_format
      || !is_elf_hash_table (info->hash))
    return FALSE;

  for (abfd = info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    {
      if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
	continue;

      bed = get_elf_backend_data (abfd);

      if ((abfd->flags & DYNAMIC) != 0)
	continue;

      eh = bfd_get_section_by_name (abfd, ".eh_frame");
      if (info->relocatable
	  || (eh != NULL
	      && (eh->_raw_size == 0
		  || bfd_is_abs_section (eh->output_section))))
	eh = NULL;

      stab = bfd_get_section_by_name (abfd, ".stab");
      if (stab != NULL
	  && (stab->_raw_size == 0
	      || bfd_is_abs_section (stab->output_section)
	      || stab->sec_info_type != ELF_INFO_TYPE_STABS))
	stab = NULL;

      if (stab == NULL
	  && eh == NULL
	  && bed->elf_backend_discard_info == NULL)
	continue;

      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
      cookie.abfd = abfd;
      cookie.sym_hashes = elf_sym_hashes (abfd);
      cookie.bad_symtab = elf_bad_symtab (abfd);
      if (cookie.bad_symtab)
	{
	  cookie.locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
	  cookie.extsymoff = 0;
	}
      else
	{
	  cookie.locsymcount = symtab_hdr->sh_info;
	  cookie.extsymoff = symtab_hdr->sh_info;
	}

      if (bed->s->arch_size == 32)
	cookie.r_sym_shift = 8;
      else
	cookie.r_sym_shift = 32;

      cookie.locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (cookie.locsyms == NULL && cookie.locsymcount != 0)
	{
	  cookie.locsyms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						 cookie.locsymcount, 0,
						 NULL, NULL, NULL);
	  if (cookie.locsyms == NULL)
	    return FALSE;
	}

      if (stab != NULL)
	{
	  cookie.rels = NULL;
	  count = stab->reloc_count;
	  if (count != 0)
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, stab, NULL, NULL,
						     info->keep_memory);
	  if (cookie.rels != NULL)
	    {
	      cookie.rel = cookie.rels;
	      cookie.relend = cookie.rels;
	      cookie.relend += count * bed->s->int_rels_per_ext_rel;
	      if (_bfd_discard_section_stabs (abfd, stab,
					      elf_section_data (stab)->sec_info,
					      bfd_elf_reloc_symbol_deleted_p,
					      &cookie))
		ret = TRUE;
	      if (elf_section_data (stab)->relocs != cookie.rels)
		free (cookie.rels);
	    }
	}

      if (eh != NULL)
	{
	  cookie.rels = NULL;
	  count = eh->reloc_count;
	  if (count != 0)
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, eh, NULL, NULL,
						     info->keep_memory);
	  cookie.rel = cookie.rels;
	  cookie.relend = cookie.rels;
	  if (cookie.rels != NULL)
	    cookie.relend += count * bed->s->int_rels_per_ext_rel;

	  if (_bfd_elf_discard_section_eh_frame (abfd, info, eh,
						 bfd_elf_reloc_symbol_deleted_p,
						 &cookie))
	    ret = TRUE;

	  if (cookie.rels != NULL
	      && elf_section_data (eh)->relocs != cookie.rels)
	    free (cookie.rels);
	}

      if (bed->elf_backend_discard_info != NULL
	  && (*bed->elf_backend_discard_info) (abfd, &cookie, info))
	ret = TRUE;

      if (cookie.locsyms != NULL
	  && symtab_hdr->contents != (unsigned char *) cookie.locsyms)
	{
	  if (! info->keep_memory)
	    free (cookie.locsyms);
	  else
	    symtab_hdr->contents = (unsigned char *) cookie.locsyms;
	}
    }

  if (info->eh_frame_hdr
      && !info->relocatable
      && _bfd_elf_discard_section_eh_frame_hdr (output_bfd, info))
    ret = TRUE;

  return ret;
@


1.51.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a27 1
#include "libiberty.h"
d59 2
a60 1
  flags = bed->dynamic_sec_flags;
d100 1
a100 1
  s->size += bed->got_header_size + bed->got_symbol_offset;
d133 4
a136 3
  bed = get_elf_backend_data (abfd);

  flags = bed->dynamic_sec_flags;
d158 2
d255 3
a257 1
  flags = bed->dynamic_sec_flags;
d436 1
a436 6
     may depend on this.
     ??? Changing bfd_link_hash_undefined to bfd_link_hash_new (or
     to bfd_link_hash_undefweak, see linker.c:link_action) runs the risk
     of some later symbol manipulation setting the symbol back to
     bfd_link_hash_undefined, and the linker trying to add the symbol to
     the undefs list twice.  */
a609 37
/* Return true if the dynamic symbol for a given section should be
   omitted when creating a shared library.  */
bfd_boolean
_bfd_elf_link_omit_section_dynsym (bfd *output_bfd ATTRIBUTE_UNUSED,
				   struct bfd_link_info *info,
				   asection *p)
{
  switch (elf_section_data (p)->this_hdr.sh_type)
    {
    case SHT_PROGBITS:
    case SHT_NOBITS:
      /* If sh_type is yet undecided, assume it could be
	 SHT_PROGBITS/SHT_NOBITS.  */
    case SHT_NULL:
      if (strcmp (p->name, ".got") == 0
	  || strcmp (p->name, ".got.plt") == 0
	  || strcmp (p->name, ".plt") == 0)
	{
	  asection *ip;
	  bfd *dynobj = elf_hash_table (info)->dynobj;

	  if (dynobj != NULL
	      && (ip = bfd_get_section_by_name (dynobj, p->name))
	      != NULL
	      && (ip->flags & SEC_LINKER_CREATED)
	      && ip->output_section == p)
	    return TRUE;
	}
      return FALSE;

      /* There shouldn't be section relative relocations
	 against any other section.  */
    default:
      return TRUE;
    }
}

a621 1
      const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
d624 1
a624 3
	if ((p->flags & SEC_EXCLUDE) == 0
	    && (p->flags & SEC_ALLOC) != 0
	    && !(*bed->elf_backend_omit_section_dynsym) (output_bfd, info, p))
d889 8
a896 12
  /* If a new weak symbol definition comes from a regular file and the
     old symbol comes from a dynamic library, we treat the new one as
     strong.  Similarly, an old weak symbol definition from a regular
     file is treated as strong when the new symbol comes from a dynamic
     library.  Further, an old weak symbol from a dynamic library is
     treated as strong if the new symbol is from a dynamic library.
     This reflects the way glibc's ld.so works.

     Do this before setting *type_change_ok or *size_change_ok so that
     we warn properly when dynamic library symbols are overridden.  */

  if (newdef && !newdyn && olddyn)
d898 1
a898 1
  if (olddef && newdyn)
d1350 2
a1351 2
	  (_("%B: unexpected redefinition of indirect versioned symbol `%s'"),
	   abfd, shortname);
d1669 2
a1670 2
	    (_("%B: undefined versioned symbol name %s"),
	     sinfo->output_bfd, h->root.root.string);
d1818 3
a1820 4
	    (_("%B: bad reloc symbol index (0x%lx >= 0x%lx)"
	       " for offset 0x%lx in section `%A'"),
	     abfd, sec,
	     (unsigned long) r_symndx, (unsigned long) nsyms, irela->r_offset);
d2007 4
a2010 2
	(_("%B: relocation size mismatch in %B section %A"),
	 output_bfd, input_section->owner, input_section);
d2332 1
a2332 1
				    h->root.u.def.value);
a2406 4
  /* Common symbols that become definitions don't get the DEF_REGULAR
     flag set, so test it first, and don't bail out.  */
  if (ELF_COMMON_DEF_P (h))
    /* Do nothing.  */;
d2409 1
a2409 1
  else if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2611 1
a2611 1
  newsize = s->size + bed->s->sizeof_dyn;
d2618 1
a2618 1
  bed->s->swap_dyn_out (hash_table->dynobj, &dyn, newcontents + s->size);
d2620 1
a2620 1
  s->size = newsize;
d2656 1
a2656 1
	   extdyn < sdyn->contents + sdyn->size;
d2698 1
a2698 1
      long sdiff = h1->root.u.def.section->id - h2->root.u.def.section->id;
d2745 1
a2745 1
       extdyn < sdyn->contents + sdyn->size;
a2854 2
  bfd_boolean (*check_directives)
    (bfd *, struct bfd_link_info *);
d2894 1
a2894 4
	  if (info->relocatable)
	    bfd_set_error (bfd_error_invalid_operation);
	  else
	    bfd_set_error (bfd_error_wrong_format);
d2945 1
a2945 1
		      s->size = 0;
d2950 1
a2950 1
	      sz = s->size;
d2971 1
a2971 1
		  s->size = 0;
d3013 2
a3014 7
	 in by another lib's DT_NEEDED.  When --no-add-needed is used
	 on a dynamic lib, we don't want to add a DT_NEEDED entry for
	 any dynamic library in DT_NEEDED tags in the dynamic lib at
	 all.  */
      add_needed = (elf_dyn_lib_class (abfd)
		    & (DYN_AS_NEEDED | DYN_DT_NEEDED
		       | DYN_NO_NEEDED)) == 0;
d3024 5
a3028 1
	  if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
d3037 1
a3037 1
	       extdyn < dynbuf + s->size;
d3411 2
a3412 2
			    (_("%B: %s: invalid version %u (max %d)"),
			     abfd, name, vernum,
d3452 2
a3453 2
			    (_("%B: %s: invalid needed version %d"),
			     abfd, name, vernum);
d3627 6
a3632 4
		  (_("Warning: alignment %u of symbol `%s' in %B"
		     " is smaller than %u in %B"),
		   normal_bfd, common_bfd,
		   1 << normal_align, name, 1 << common_align);
d3641 1
a3641 3
		  (_("Warning: size of symbol `%s' changed"
		     " from %lu in %B to %lu in %B"),
		   old_bfd, abfd,
d3643 3
a3645 1
		   (unsigned long) isym->st_size);
d3665 3
a3667 3
		  (_("Warning: type of symbol `%s' changed"
		     " from %d to %d in %B"),
		   abfd, name, h->type, ELF_ST_TYPE (isym->st_info));
d3799 1
a3799 11
		 Add a DT_NEEDED entry for it.  Issue an error if
		 --no-add-needed is used.  */
	      if ((elf_dyn_lib_class (abfd) & DYN_NO_NEEDED) != 0)
		{
		  (*_bfd_error_handler)
		    (_("%s: invalid DSO for symbol `%s' definition"),
		     abfd, name);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_free_vers;
		}

d3952 1
a3952 1
		  long sdiff = slook->id - h->root.u.def.section->id;
a4007 4
  check_directives = get_elf_backend_data (abfd)->check_directives;
  if (check_directives)
    check_directives (abfd, info);

d4086 1
a4086 1
					       &hash_table->stab_info,
d4097 22
a4145 49
/* Return the linker hash table entry of a symbol that might be
   satisfied by an archive symbol.  Return -1 on error.  */

struct elf_link_hash_entry *
_bfd_elf_archive_symbol_lookup (bfd *abfd,
				struct bfd_link_info *info,
				const char *name)
{
  struct elf_link_hash_entry *h;
  char *p, *copy;
  size_t len, first;

  h = elf_link_hash_lookup (elf_hash_table (info), name, FALSE, FALSE, FALSE);
  if (h != NULL)
    return h;

  /* If this is a default version (the name contains @@@@), look up the
     symbol again with only one `@@' as well as without the version.
     The effect is that references to the symbol with and without the
     version will be matched by the default symbol in the archive.  */

  p = strchr (name, ELF_VER_CHR);
  if (p == NULL || p[1] != ELF_VER_CHR)
    return h;

  /* First check with only one `@@'.  */
  len = strlen (name);
  copy = bfd_alloc (abfd, len);
  if (copy == NULL)
    return (struct elf_link_hash_entry *) 0 - 1;

  first = p - name + 1;
  memcpy (copy, name, first);
  memcpy (copy + first, name + first + 1, len - first);

  h = elf_link_hash_lookup (elf_hash_table (info), copy, FALSE, FALSE, FALSE);
  if (h == NULL)
    {
      /* We also need to check references to the symbol without the
	 version.  */
      copy[first - 1] = '\0';
      h = elf_link_hash_lookup (elf_hash_table (info), copy,
				FALSE, FALSE, FALSE);
    }

  bfd_release (abfd, copy);
  return h;
}

a4179 3
  const struct elf_backend_data *bed;
  struct elf_link_hash_entry * (*archive_symbol_lookup)
    (bfd *, struct bfd_link_info *, const char *);
a4203 2
  bed = get_elf_backend_data (abfd);
  archive_symbol_lookup = bed->elf_backend_archive_symbol_lookup;
d4232 42
a4273 3
	  h = archive_symbol_lookup (abfd, info, symdef->name);
	  if (h == (struct elf_link_hash_entry *) 0 - 1)
	    goto error_return;
a4618 1
  elf_tdata (output_bfd)->relro = info->relro;
d4858 1
a4858 1
	 values later, in bfd_elf_final_link, but we must add the entries
d4903 2
a4904 2
			(_("%B: .preinit_array section is not allowed in DSO"),
			 sub);
d5006 3
a5008 3
	  s->size = size;
	  s->contents = bfd_alloc (output_bfd, s->size);
	  if (s->contents == NULL && s->size != 0)
d5205 2
a5206 2
	    s->size = size;
	    s->contents = bfd_alloc (output_bfd, s->size);
d5291 2
a5292 2
	  s->size = dynsymcount * sizeof (Elf_External_Versym);
	  s->contents = bfd_zalloc (output_bfd, s->size);
d5308 3
a5310 3
      s->size = dynsymcount * bed->s->sizeof_sym;
      s->contents = bfd_alloc (output_bfd, s->size);
      if (s->contents == NULL && s->size != 0)
d5334 2
a5335 2
      s->size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
      s->contents = bfd_zalloc (output_bfd, s->size);
d5350 1
a5350 1
      s->size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
d5560 1
a5560 1
  if (reldyn == NULL || reldyn->size == 0)
d5563 1
a5563 1
      if (reldyn == NULL || reldyn->size == 0)
d5575 1
a5575 1
  count = reldyn->size / ext_size;
d5582 1
a5582 1
	size += o->size;
d5585 1
a5585 1
  if (size != reldyn->size)
d5610 1
a5610 1
	erelend = o->contents + o->size;
d5652 1
a5652 1
	erelend = o->contents + o->size;
d5788 1
a5788 1
	  || (elf_dyn_lib_class (abfd) & DYN_DT_NEEDED) == 0)
d5976 2
a5977 2
	(_("%B: %s symbol `%s' in %B is referenced by DSO"),
	 finfo->output_bfd, h->root.u.def.section->owner,
d5981 3
a5983 2
	 ? "hidden" : "local",
	 h->root.root.string);
d6057 4
a6060 2
		  (_("%B: could not find output section %A for input section %A"),
		   finfo->output_bfd, input_sec->output_section, input_sec);
d6156 7
a6162 7
	(_("%B: %s symbol `%s' isn't defined"),
	 finfo->output_bfd,
	 ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED
	 ? "protected"
	 : ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL
	 ? "internal" : "hidden",
	 h->root.root.string);
a6240 3
/* Return TRUE if special handling is done for relocs in SEC against
   symbols defined in discarded sections.  */

a6262 46
/* Return TRUE if we should complain about a reloc in SEC against a
   symbol defined in a discarded section.  */

static bfd_boolean
elf_section_complain_discarded (asection *sec)
{
  if (strncmp (".stab", sec->name, 5) == 0
      && (!sec->name[5] ||
	  (sec->name[5] == '.' && ISDIGIT (sec->name[6]))))
    return FALSE;

  if (strcmp (".eh_frame", sec->name) == 0)
    return FALSE;

  if (strcmp (".gcc_except_table", sec->name) == 0)
    return FALSE;

  if (strcmp (".PARISC.unwind", sec->name) == 0)
    return FALSE;

  if (strcmp (".fixup", sec->name) == 0)
    return FALSE;

  return TRUE;
}

/* Find a match between a section and a member of a section group.  */

static asection *
match_group_member (asection *sec, asection *group)
{
  asection *first = elf_next_in_group (group);
  asection *s = first;

  while (s != NULL)
    {
      if (bfd_elf_match_symbols_in_sections (s, sec))
	return s;

      if (s == first)
	break;
    }

  return NULL;
}

d6361 1
a6361 1
					  isym->st_value);
d6476 1
a6476 1
	  || (o->size == 0 && (o->flags & SEC_RELOC) == 0))
a6493 2
	  bfd_size_type amt = o->rawsize ? o->rawsize : o->size;

d6495 2
a6496 1
	  if (! bfd_get_section_contents (input_bfd, o, contents, 0, amt))
a6533 1
	      bfd_boolean complain = elf_section_complain_discarded (o);
d6540 1
a6540 6
		  asection **ps, *sec;
		  struct elf_link_hash_entry *h = NULL;
		  const char *sym_name;

		  if (r_symndx == STN_UNDEF)
		    continue;
d6546 2
d6553 28
a6580 6
		      if (h->root.type != bfd_link_hash_defined
			  && h->root.type != bfd_link_hash_defweak)
			continue;

		      ps = &h->root.u.def.section;
		      sym_name = h->root.root.string;
d6584 1
a6584 4
		      Elf_Internal_Sym *sym = isymbuf + r_symndx;
		      ps = &finfo->sections[r_symndx];
		      sym_name = bfd_elf_local_sym_name (input_bfd, sym);
		    }
d6586 1
a6586 5
		  /* Complain if the definition comes from a
		     discarded section.  */
		  if ((sec = *ps) != NULL && elf_discarded_section (sec))
		    {
		      if ((o->flags & SEC_DEBUGGING) != 0)
d6588 2
a6589 15
			  BFD_ASSERT (r_symndx != 0);

			  /* Try to preserve debug information.
			     FIXME: This is quite broken.  Modifying
			     the symbol here means we will be changing
			     all uses of the symbol, not just those in
			     debug sections.  The only thing that makes
			     this half reasonable is that debug sections
			     tend to come after other sections.  Of
			     course, that doesn't help with globals.
			     ??? All link-once sections of the same name
			     ought to define the same set of symbols, so
			     it would seem that globals ought to always
			     be defined in the kept section.  */
			  if (sec->kept_section != NULL)
d6591 8
a6598 6
			      asection *member;

			      /* Check if it is a linkonce section or
				 member of a comdat group.  */
			      if (elf_sec_group (sec) == NULL
				  && sec->size == sec->kept_section->size)
d6600 2
a6601 9
				  *ps = sec->kept_section;
				  continue;
				}
			      else if (elf_sec_group (sec) != NULL
				       && (member = match_group_member (sec, sec->kept_section))
				       && sec->size == member->size)
				{
				  *ps = member;
				  continue;
d6603 18
a6622 17
		      else if (complain)
			{
			  (*_bfd_error_handler)
			    (_("`%s' referenced in section `%A' of %B: "
			       "defined in discarded section `%A' of %B\n"),
			     o, input_bfd, sec, sec->owner, sym_name);
			}

		      /* Remove the symbol reference from the reloc, but
			 don't kill the reloc completely.  This is so that
			 a zero value will be written into the section,
			 which may have non-zero contents put there by the
			 assembler.  Zero in things like an eh_frame fde
			 pc_begin allows stack unwinders to recognize the
			 fde as bogus.  */
		      rel->r_info &= r_type_mask;
		      rel->r_addend = 0;
d6734 1
a6734 1
			 set at the end of bfd_elf_final_link.  */
d6761 7
a6767 4
			 processor specific section.  */
		      r_symndx = 0;
		      if (bfd_is_abs_section (sec))
			;
d6775 2
a6776 19
			  asection *osec = sec->output_section;

			  /* If we have discarded a section, the output
			     section will be the absolute section.  In
			     case of discarded link-once and discarded
			     SEC_MERGE sections, use the kept section.  */
			  if (bfd_is_abs_section (osec)
			      && sec->kept_section != NULL
			      && sec->kept_section->output_section != NULL)
			    {
			      osec = sec->kept_section->output_section;
			      irela->r_addend -= osec->vma;
			    }

			  if (!bfd_is_abs_section (osec))
			    {
			      r_symndx = osec->target_index;
			      BFD_ASSERT (r_symndx != 0);
			    }
d6899 3
d6906 1
a6906 1
					       o->size))
a7081 131

/* Get the output vma of the section pointed to by the sh_link field.  */

static bfd_vma
elf_get_linked_section_vma (struct bfd_link_order *p)
{
  Elf_Internal_Shdr **elf_shdrp;
  asection *s;
  int elfsec;

  s = p->u.indirect.section;
  elf_shdrp = elf_elfsections (s->owner);
  elfsec = _bfd_elf_section_from_bfd_section (s->owner, s);
  elfsec = elf_shdrp[elfsec]->sh_link;
  /* PR 290:
     The Intel C compiler generates SHT_IA_64_UNWIND with
     SHF_LINK_ORDER.  But it doesn't set theh sh_link or
     sh_info fields.  Hence we could get the situation
     where elfsec is 0.  */
  if (elfsec == 0)
    {
      const struct elf_backend_data *bed
	= get_elf_backend_data (s->owner);
      if (bed->link_order_error_handler)
	bed->link_order_error_handler
	  (_("%B: warning: sh_link not set for section `%A'"), s->owner, s);
      return 0;
    }
  else
    {
      s = elf_shdrp[elfsec]->bfd_section;
      return s->output_section->vma + s->output_offset;
    }
}


/* Compare two sections based on the locations of the sections they are
   linked to.  Used by elf_fixup_link_order.  */

static int
compare_link_order (const void * a, const void * b)
{
  bfd_vma apos;
  bfd_vma bpos;

  apos = elf_get_linked_section_vma (*(struct bfd_link_order **)a);
  bpos = elf_get_linked_section_vma (*(struct bfd_link_order **)b);
  if (apos < bpos)
    return -1;
  return apos > bpos;
}


/* Looks for sections with SHF_LINK_ORDER set.  Rearranges them into the same
   order as their linked sections.  Returns false if this could not be done
   because an output section includes both ordered and unordered
   sections.  Ideally we'd do this in the linker proper.  */

static bfd_boolean
elf_fixup_link_order (bfd *abfd, asection *o)
{
  int seen_linkorder;
  int seen_other;
  int n;
  struct bfd_link_order *p;
  bfd *sub;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int elfsec;
  struct bfd_link_order **sections;
  asection *s;
  bfd_vma offset;
  
  seen_other = 0;
  seen_linkorder = 0;
  for (p = o->link_order_head; p != NULL; p = p->next)
    {
      if (p->type == bfd_indirect_link_order
	  && (bfd_get_flavour ((sub = p->u.indirect.section->owner))
	      == bfd_target_elf_flavour)
	  && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass)
	{
	  s = p->u.indirect.section;
	  elfsec = _bfd_elf_section_from_bfd_section (sub, s);
	  if (elfsec != -1
	      && elf_elfsections (sub)[elfsec]->sh_flags & SHF_LINK_ORDER)
	    seen_linkorder++;
	  else
	    seen_other++;
	}
      else
	seen_other++;
    }

  if (!seen_linkorder)
    return TRUE;

  if (seen_other && seen_linkorder)
    {
      (*_bfd_error_handler) (_("%A has both ordered and unordered sections"),
			     o);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }
  
  sections = (struct bfd_link_order **)
    xmalloc (seen_linkorder * sizeof (struct bfd_link_order *));
  seen_linkorder = 0;
  
  for (p = o->link_order_head; p != NULL; p = p->next)
    {
      sections[seen_linkorder++] = p;
    }
  /* Sort the input sections in the order of their linked section.  */
  qsort (sections, seen_linkorder, sizeof (struct bfd_link_order *),
	 compare_link_order);

  /* Change the offsets of the sections.  */
  offset = 0;
  for (n = 0; n < seen_linkorder; n++)
    {
      s = sections[n]->u.indirect.section;
      offset &= ~(bfd_vma)((1 << s->alignment_power) - 1);
      s->output_offset = offset;
      sections[n]->offset = offset;
      offset += sections[n]->size;
    }

  return TRUE;
}


d7213 4
a7216 4
	      if (sec->rawsize > max_contents_size)
		max_contents_size = sec->rawsize;
	      if (sec->size > max_contents_size)
		max_contents_size = sec->size;
d7332 2
a7333 1
  /* Set sizes, and assign file positions for reloc sections.  */
d7524 1
a7524 1
	  bfd_vma size = sec->size;
a7540 7
  /* Reorder SHF_LINK_ORDER sections.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (!elf_fixup_link_order (abfd, o))
	return FALSE;
    }

d7638 1
a7639 3
	      if (dynindx <= 0)
		continue;
	      indx = elf_section_data (s)->this_idx;
a7643 2
	      if (last_local < dynindx)
		last_local = dynindx;
d7646 2
d7798 1
a7798 1
      dynconend = o->contents + o->size;
d7870 2
a7871 1
		    (_("%B: could not find output section %s"), abfd, name);
d7874 1
a7874 1
	      if (o->size == 0)
d7877 1
a7877 1
	      dyn.d_un.d_val = o->size;
d7912 2
a7913 1
		    (_("%B: could not find output section %s"), abfd, name);
d7961 1
a7961 1
	      || o->size == 0
a7969 4
	  if (elf_hash_table (info)->stab_info.stabstr == o)
	    continue;
	  if (elf_hash_table (info)->eh_info.hdr_sec == o)
	    continue;
d7977 1
a7977 1
					      o->size))
d8003 1
a8003 1
  if (elf_hash_table (info)->stab_info.stabstr != NULL)
d8091 4
a8094 4
bfd_boolean
_bfd_elf_gc_mark (struct bfd_link_info *info,
		  asection *sec,
		  gc_mark_hook_fn gc_mark_hook)
d8104 1
a8104 1
    if (!_bfd_elf_gc_mark (info, group_sec, gc_mark_hook))
a8170 3
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
d8182 1
a8182 1
	      else if (!_bfd_elf_gc_mark (info, rsec, gc_mark_hook))
d8244 3
a8246 3
	  /* Keep debug and special sections.  */
	  if ((o->flags & (SEC_DEBUGGING | SEC_LINKER_CREATED)) != 0
	      || (o->flags & (SEC_ALLOC | SEC_LOAD)) == 0)
a8409 18
/* Mark sections containing dynamically referenced symbols.  This is called
   through elf_link_hash_traverse.  */

static bfd_boolean
elf_gc_mark_dynamic_ref_symbol (struct elf_link_hash_entry *h,
				void *okp ATTRIBUTE_UNUSED)
{
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC))
    h->root.u.def.section->flags |= SEC_KEEP;

  return TRUE;
}

d8424 2
a8425 2
      || info->shared
      || !is_elf_hash_table (info->hash))
d8445 1
a8445 7
  /* Mark dynamically referenced symbols.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    elf_link_hash_traverse (elf_hash_table (info),
			    elf_gc_mark_dynamic_ref_symbol,
			    &ok);
  if (!ok)
    return FALSE;
a8446 1
  /* Grovel through relocs to find out who stays ...  */
d8458 2
a8459 9
	    {
	      /* _bfd_elf_discard_section_eh_frame knows how to discard
		 orphaned FDEs so don't mark sections referenced by the
		 EH frame section.  */  
	      if (strcmp (o->name, ".eh_frame") == 0)
		o->gc_mark = 1;
	      else if (!_bfd_elf_gc_mark (info, o, gc_mark_hook))
		return FALSE;
	    }
d8505 3
a8507 2
  (*_bfd_error_handler) ("%B: %A+%lu: No symbol found for INHERIT",
			 abfd, sec, (unsigned long) offset);
d8793 1
a8793 1
	      && (eh->size == 0
d8799 1
a8799 1
	  && (stab->size == 0
a8903 246

struct already_linked_section
{
  asection *sec;
  asection *linked;
};

/* Check if the member of a single member comdat group matches a
   linkonce section and vice versa.  */
static bfd_boolean
try_match_symbols_in_sections
  (struct bfd_section_already_linked_hash_entry *h, void *info)
{
  struct bfd_section_already_linked *l;
  struct already_linked_section *s
    = (struct already_linked_section *) info;

  if (elf_sec_group (s->sec) == NULL)
    {
      /* It is a linkonce section. Try to match it with the member of a
	 single member comdat group. */
      for (l = h->entry; l != NULL; l = l->next)
	if ((l->sec->flags & SEC_GROUP))
	  {
	    asection *first = elf_next_in_group (l->sec);

	    if (first != NULL
		&& elf_next_in_group (first) == first
		&& bfd_elf_match_symbols_in_sections (first, s->sec))
	      {
		s->linked = first;
		return FALSE;
	      }
	  }
    }
  else
    {
      /* It is the member of a single member comdat group. Try to match
	 it with a linkonce section.  */
      for (l = h->entry; l != NULL; l = l->next)
	if ((l->sec->flags & SEC_GROUP) == 0
	    && bfd_coff_get_comdat_section (l->sec->owner, l->sec) == NULL
	    && bfd_elf_match_symbols_in_sections (l->sec, s->sec))
	  {
	    s->linked = l->sec;
	    return FALSE;
	  }
    }

  return TRUE;
}

static bfd_boolean
already_linked (asection *sec, asection *group)
{
  struct already_linked_section result;

  result.sec = sec;
  result.linked = NULL;

  bfd_section_already_linked_table_traverse
    (try_match_symbols_in_sections, &result);

  if (result.linked)
    {
      sec->output_section = bfd_abs_section_ptr;
      sec->kept_section = result.linked;

      /* Also discard the group section.  */
      if (group)
	group->output_section = bfd_abs_section_ptr;

      return TRUE;
    }

  return FALSE;
}

void
_bfd_elf_section_already_linked (bfd *abfd, struct bfd_section * sec)
{
  flagword flags;
  const char *name;
  struct bfd_section_already_linked *l;
  struct bfd_section_already_linked_hash_entry *already_linked_list;
  asection *group;

  /* A single member comdat group section may be discarded by a
     linkonce section. See below.  */
  if (sec->output_section == bfd_abs_section_ptr)
    return;

  flags = sec->flags;

  /* Check if it belongs to a section group.  */
  group = elf_sec_group (sec);

  /* Return if it isn't a linkonce section nor a member of a group.  A
     comdat group section also has SEC_LINK_ONCE set.  */
  if ((flags & SEC_LINK_ONCE) == 0 && group == NULL)
    return;

  if (group)
    {
      /* If this is the member of a single member comdat group, check if
	 the group should be discarded.  */
      if (elf_next_in_group (sec) == sec
	  && (group->flags & SEC_LINK_ONCE) != 0)
	sec = group;
      else
	return;
    }

  /* FIXME: When doing a relocatable link, we may have trouble
     copying relocations in other sections that refer to local symbols
     in the section being discarded.  Those relocations will have to
     be converted somehow; as of this writing I'm not sure that any of
     the backends handle that correctly.

     It is tempting to instead not discard link once sections when
     doing a relocatable link (technically, they should be discarded
     whenever we are building constructors).  However, that fails,
     because the linker winds up combining all the link once sections
     into a single large link once section, which defeats the purpose
     of having link once sections in the first place.

     Also, not merging link once sections in a relocatable link
     causes trouble for MIPS ELF, which relies on link once semantics
     to handle the .reginfo section correctly.  */

  name = bfd_get_section_name (abfd, sec);

  already_linked_list = bfd_section_already_linked_table_lookup (name);

  for (l = already_linked_list->entry; l != NULL; l = l->next)
    {
      /* We may have 3 different sections on the list: group section,
	 comdat section and linkonce section. SEC may be a linkonce or
	 group section. We match a group section with a group section,
	 a linkonce section with a linkonce section, and ignore comdat
	 section.  */
      if ((flags & SEC_GROUP) == (l->sec->flags & SEC_GROUP)
	  && bfd_coff_get_comdat_section (l->sec->owner, l->sec) == NULL)
	{
	  /* The section has already been linked.  See if we should
             issue a warning.  */
	  switch (flags & SEC_LINK_DUPLICATES)
	    {
	    default:
	      abort ();

	    case SEC_LINK_DUPLICATES_DISCARD:
	      break;

	    case SEC_LINK_DUPLICATES_ONE_ONLY:
	      (*_bfd_error_handler)
		(_("%B: ignoring duplicate section `%A'\n"),
		 abfd, sec);
	      break;

	    case SEC_LINK_DUPLICATES_SAME_SIZE:
	      if (sec->size != l->sec->size)
		(*_bfd_error_handler)
		  (_("%B: duplicate section `%A' has different size\n"),
		   abfd, sec);
	      break;

	    case SEC_LINK_DUPLICATES_SAME_CONTENTS:
	      if (sec->size != l->sec->size)
		(*_bfd_error_handler)
		  (_("%B: duplicate section `%A' has different size\n"),
		   abfd, sec);
	      else if (sec->size != 0)
		{
		  bfd_byte *sec_contents, *l_sec_contents;

		  if (!bfd_malloc_and_get_section (abfd, sec, &sec_contents))
		    (*_bfd_error_handler)
		      (_("%B: warning: could not read contents of section `%A'\n"),
		       abfd, sec);
		  else if (!bfd_malloc_and_get_section (l->sec->owner, l->sec,
							&l_sec_contents))
		    (*_bfd_error_handler)
		      (_("%B: warning: could not read contents of section `%A'\n"),
		       l->sec->owner, l->sec);
		  else if (memcmp (sec_contents, l_sec_contents, sec->size) != 0)
		    (*_bfd_error_handler)
		      (_("%B: warning: duplicate section `%A' has different contents\n"),
		       abfd, sec);

		  if (sec_contents)
		    free (sec_contents);
		  if (l_sec_contents)
		    free (l_sec_contents);
		}
	      break;
	    }

	  /* Set the output_section field so that lang_add_section
	     does not create a lang_input_section structure for this
	     section.  Since there might be a symbol in the section
	     being discarded, we must retain a pointer to the section
	     which we are really going to use.  */
	  sec->output_section = bfd_abs_section_ptr;
	  sec->kept_section = l->sec;
	  
	  if (flags & SEC_GROUP)
	    {
	      asection *first = elf_next_in_group (sec);
	      asection *s = first;

	      while (s != NULL)
		{
		  s->output_section = bfd_abs_section_ptr;
		  /* Record which group discards it.  */
		  s->kept_section = l->sec;
		  s = elf_next_in_group (s);
		  /* These lists are circular.  */
		  if (s == first)
		    break;
		}
	    }

	  return;
	}
    }

  if (group)
    {
      /* If this is the member of a single member comdat group and the
	 group hasn't be discarded, we check if it matches a linkonce
	 section. We only record the discarded comdat group. Otherwise
	 the undiscarded group will be discarded incorrectly later since
	 itself has been recorded.  */
      if (! already_linked (elf_next_in_group (sec), group))
	return;
    }
  else
    /* There is no direct match. But for linkonce section, we should
       check if there is a match with comdat group member. We always
       record the linkonce section, discarded or not.  */
    already_linked (sec, group);
  
  /* This is the first section with this name.  Record it.  */
  bfd_section_already_linked_table_insert (already_linked_list, sec);
}
@


1.51.8.4
log
@Merge from mainline.
@
text
@d89 1
a89 1
      h->def_regular = 1;
d216 1
a216 1
  h->def_regular = 1;
d279 1
a279 1
      h->def_regular = 1;
d366 1
a366 1
	      h->forced_local = 1;
d442 1
a442 1
    h->non_elf = 0;
d449 2
a450 2
      && h->def_dynamic
      && !h->def_regular)
d458 2
a459 2
      && h->def_dynamic
      && !h->def_regular)
d462 1
a462 1
  h->def_regular = 1;
d464 2
a465 2
  if ((h->def_dynamic
       || h->ref_dynamic
d475 2
a476 2
      if (h->u.weakdef != NULL
	  && h->u.weakdef->dynindx == -1)
d478 1
a478 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h->u.weakdef))
d752 1
a752 1
      h->non_elf = 0;
d787 1
a787 1
	  || !h->def_regular))
d846 1
a846 1
  if (newdyn && !h->dynamic_def)
d849 1
a849 1
	h->dynamic_def = 1;
d855 1
a855 1
	  if (!h->ref_dynamic)
d858 1
a858 1
		h->dynamic_weak = 1;
d861 1
a861 1
	    h->dynamic_weak = 0;
d873 1
a873 1
      h->ref_dynamic = 1;
d885 1
a885 1
	   && h->def_dynamic)
d893 1
a893 1
      if ((h->root.u.undef.next || info->hash->undefs_tail == &h->root)
d899 1
a899 1
	     up the linker hash table undefs list.  Since the old
d903 1
d912 1
a912 1
      if (h->def_dynamic)
d914 3
a916 3
	  h->def_dynamic = 0;
	  h->ref_dynamic = 1;
	  h->dynamic_def = 1;
d999 1
a999 1
      && h->def_dynamic
d1106 1
a1106 1
      && h->def_dynamic)
d1188 1
a1188 1
      if (h->def_dynamic)
d1190 2
a1191 2
	  h->def_dynamic = 0;
	  flip->ref_dynamic = 1;
d1314 1
a1314 1
      if (h->def_dynamic)
d1316 5
a1320 4
	  h->def_dynamic = 0;
	  hi->ref_dynamic = 1;
	  if (hi->ref_regular
	      || hi->def_regular)
d1350 2
a1351 1
		  || hi->ref_dynamic)
d1356 2
a1357 1
	      if (hi->ref_regular)
d1421 2
a1422 1
		      || hi->ref_dynamic)
d1427 2
a1428 1
		  if (hi->ref_regular)
d1454 2
a1455 2
      && (h->def_regular
	  || h->ref_regular))
d1510 2
a1511 2
  if (!h->def_dynamic
      || h->def_regular
d1601 1
a1601 1
  if (!h->def_regular)
d1626 1
a1626 1
	    h->hidden = 1;
d1721 1
a1721 1
	h->hidden = 1;
d2099 1
a2099 1
  if (h->non_elf)
d2106 2
a2107 4
	{
	  h->ref_regular = 1;
	  h->ref_regular_nonweak = 1;
	}
d2113 2
a2114 4
	    {
	      h->ref_regular = 1;
	      h->ref_regular_nonweak = 1;
	    }
d2116 1
a2116 1
	    h->def_regular = 1;
d2120 2
a2121 2
	  && (h->def_dynamic
	      || h->ref_dynamic))
d2132 1
a2132 1
      /* Unfortunately, NON_ELF is only correct if the symbol
d2140 1
a2140 1
	  && !h->def_regular
d2145 3
a2147 2
		 && !h->def_dynamic)))
	h->def_regular = 1;
d2153 1
a2153 1
     the symbol in a common section but the DEF_REGULAR
d2156 3
a2158 3
      && !h->def_regular
      && h->ref_regular
      && !h->def_dynamic
d2160 1
a2160 1
    h->def_regular = 1;
d2168 1
a2168 1
  if (h->needs_plt
d2173 1
a2173 1
      && h->def_regular)
d2198 1
a2198 1
  if (h->u.weakdef != NULL)
d2202 1
a2202 1
      weakdef = h->u.weakdef;
d2210 1
a2210 1
      BFD_ASSERT (weakdef->def_dynamic);
d2215 2
a2216 2
      if (weakdef->def_regular)
	h->u.weakdef = NULL;
d2269 5
a2273 5
  if (!h->needs_plt
      && (h->def_regular
	  || !h->def_dynamic
	  || (!h->ref_regular
	      && (h->u.weakdef == NULL || h->u.weakdef->dynindx == -1))))
d2281 1
a2281 1
  if (h->dynamic_adjusted)
d2288 1
a2288 1
  h->dynamic_adjusted = 1;
d2318 1
a2318 1
  if (h->u.weakdef != NULL)
d2323 2
a2324 2
	 H->U.WEAKDEF before it finds H?  */
      h->u.weakdef->ref_regular = 1;
d2326 1
a2326 1
      if (! _bfd_elf_adjust_dynamic_symbol (h->u.weakdef, eif))
d2337 1
a2337 1
      && !h->needs_plt)
d2402 1
a2402 1
  if (h->forced_local)
d2428 1
a2428 1
  if (!h->def_regular)
d2456 1
a2456 1
  else if (!h->def_regular)
d2460 1
a2460 1
  if (h->forced_local)
d3599 1
a3599 1
	  && h->u.weakdef == NULL)
d3613 1
a3613 1
	  h->u.weakdef = weaks;
d3636 1
d3638 1
d3756 1
d3762 1
a3762 1
		  h->ref_regular = 1;
d3764 1
a3764 1
		    h->ref_regular_nonweak = 1;
d3767 1
a3767 1
		h->def_regular = 1;
d3769 2
a3770 2
		  || h->def_dynamic
		  || h->ref_dynamic)
d3776 1
a3776 1
		h->ref_dynamic = 1;
d3778 4
a3781 4
		h->def_dynamic = 1;
	      if (h->def_regular
		  || h->ref_regular
		  || (h->u.weakdef != NULL
d3783 1
a3783 1
		      && h->u.weakdef->dynindx != -1))
d3787 2
d3818 1
a3818 1
	      if (h->u.weakdef != NULL
d3820 1
a3820 1
		  && h->u.weakdef->dynindx == -1)
d3822 1
a3822 1
		  if (! bfd_elf_link_record_dynamic_symbol (info, h->u.weakdef))
d3842 2
a3843 1
	      && h->ref_regular)
d3988 2
a3989 2
	  weaks = hlook->u.weakdef;
	  hlook->u.weakdef = NULL;
d4040 1
a4040 1
		  hlook->u.weakdef = h;
d4483 1
a4483 1
  h->u.elf_hash_value = ha;
d4868 2
a4869 1
		  && !newh->def_dynamic
d4928 2
a4929 2
	  && (h->ref_regular
	      || h->def_regular))
d4940 2
a4941 2
	  && (h->ref_regular
	      || h->def_regular))
d5130 2
a5131 2
	      h->non_elf = 0;
	      h->def_regular = 1;
d5995 1
a5995 1
      if (!h->forced_local)
d6000 1
a6000 1
      if (h->forced_local)
d6011 2
a6012 2
      && h->ref_dynamic
      && !h->ref_regular
d6029 3
a6031 4
      && h->forced_local
      && h->ref_dynamic
      && !h->dynamic_def
      && !h->dynamic_weak
d6052 4
a6055 4
  else if ((h->def_dynamic
	    || h->ref_dynamic)
	   && !h->def_regular
	   && !h->ref_regular)
d6075 1
a6075 1
      && !h->forced_local)
d6081 1
a6081 1
  if (h->forced_local)
d6168 1
a6168 1
       || h->forced_local)
d6172 1
a6172 1
	  || !h->forced_local)
d6190 1
a6190 1
      && h->ref_regular
d6196 1
a6196 1
      if (h->ref_regular_nonweak)
d6209 1
a6209 1
      && !h->def_regular)
d6241 1
a6241 1
      bucket = h->u.elf_hash_value % bucketcount;
d6257 1
a6257 1
	  if (!h->def_regular)
d6272 1
a6272 1
	  if (h->hidden)
d8576 1
a8576 1
  if (h->vtable == NULL || h->vtable->parent == NULL)
d8580 1
a8580 1
  if (h->vtable->parent == (struct elf_link_hash_entry *) -1)
d8584 1
a8584 1
  if (h->vtable->used && h->vtable->used[-1])
d8588 1
a8588 1
  elf_gc_propagate_vtable_entries_used (h->vtable->parent, okp);
d8590 1
a8590 1
  if (h->vtable->used == NULL)
d8594 2
a8595 2
      h->vtable->used = h->vtable->parent->vtable->used;
      h->vtable->size = h->vtable->parent->vtable->size;
d8603 1
a8603 1
      cu = h->vtable->used;
d8605 1
a8605 1
      pu = h->vtable->parent->vtable->used;
d8613 1
a8613 1
	  n = h->vtable->parent->vtable->size >> log_file_align;
d8641 1
a8641 1
  if (h->vtable == NULL || h->vtable->parent == NULL)
d8663 2
a8664 2
	if (h->vtable->used
	    && (rel->r_offset - hstart) < h->vtable->size)
d8667 1
a8667 1
	    if (h->vtable->used[entry])
d8689 1
a8689 1
      && h->ref_dynamic)
a8809 6
  if (!child->vtable)
    {
      child->vtable = bfd_zalloc (abfd, sizeof (*child->vtable));
      if (!child->vtable)
	return FALSE;
    }
d8817 1
a8817 1
      child->vtable->parent = (struct elf_link_hash_entry *) -1;
d8820 1
a8820 1
    child->vtable->parent = h;
d8836 1
a8836 8
  if (!h->vtable)
    {
      h->vtable = bfd_zalloc (abfd, sizeof (*h->vtable));
      if (!h->vtable)
	return FALSE;
    }

  if (addend >= h->vtable->size)
d8839 1
a8839 1
      bfd_boolean *ptr = h->vtable->used;
d8870 1
a8870 1
	      oldbytes = (((h->vtable->size >> log_file_align) + 1)
d8882 2
a8883 2
      h->vtable->used = ptr + 1;
      h->vtable->size = size;
d8886 1
a8886 1
  h->vtable->used[addend >> log_file_align] = TRUE;
@


1.51.6.1
log
@	* elflink.c (elf_link_read_relocs_from_section): Don't use
	NUM_SHDR_ENTRIES in end of reloc calc.  Move NULL shdr check..
	(_bfd_elf_link_read_relocs): ..to here.
	* elf32-ppc.c (ppc_elf_relax_section): Formatting.

	Merge from mainline.
	2004-02-20  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (allocate_dynrelocs): Create dynsym for undef weak
	symbols used in PIE relocs.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d1858 4
d1887 1
a1887 1
  erelaend = erela + shdr->sh_size;
d1973 6
a1978 7
  if (elf_section_data (o)->rel_hdr2
      && (!elf_link_read_relocs_from_section
	  (abfd, o,
	   elf_section_data (o)->rel_hdr2,
	   ((bfd_byte *) external_relocs) + rel_hdr->sh_size,
	   internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
			      * bed->s->int_rels_per_ext_rel))))
@


1.51.6.2
log
@Merge from mainline
@
text
@a26 1
#include "safe-ctype.h"
d92 1
a92 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d222 1
a222 1
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d287 1
a287 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d349 2
a350 2
bfd_elf_link_record_dynamic_symbol (struct bfd_link_info *info,
				    struct elf_link_hash_entry *h)
a432 7
  /* Since we're defining the symbol, don't let it seem to have not
     been defined.  record_dynamic_symbol and size_dynamic_sections
     may depend on this.  */
  if (h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_undefined)
    h->root.type = bfd_link_hash_new;

d461 1
a461 1
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d470 1
a470 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
d483 3
a485 3
bfd_elf_link_record_local_dynamic_symbol (struct bfd_link_info *info,
					  bfd *input_bfd,
					  long input_indx)
d649 2
a650 1
   change.  */
d663 2
a664 1
		       bfd_boolean *size_change_ok)
d672 1
a672 1
  bfd_boolean newweak, oldweak;
d810 1
a810 1
	    {
d833 1
a833 1
	return bfd_elf_link_record_dynamic_symbol (info, h);
d846 2
a847 20

      if ((h->root.und_next || info->hash->undefs_tail == &h->root)
	  && bfd_is_und_section (sec))
	{
	  /* If the new symbol is undefined and the old symbol was
	     also undefined before, we need to make sure
	     _bfd_generic_link_add_one_symbol doesn't mess
	     up the linker hash table undefs list. Since the old
	     definition came from a dynamic object, it is still on the
	     undefs list.  */
	  h->root.type = bfd_link_hash_undefined;
	  /* FIXME: What if the new symbol is weak undefined?  */
	  h->root.u.undef.abfd = abfd;
	}
      else
	{
	  h->root.type = bfd_link_hash_new;
	  h->root.u.undef.abfd = NULL;
	}

d860 17
a876 16
  /* Differentiate strong and weak symbols.  */
  newweak = bind == STB_WEAK;
  oldweak = (h->root.type == bfd_link_hash_defweak
	     || h->root.type == bfd_link_hash_undefweak);

  /* If a new weak symbol comes from a regular file and the old symbol
     comes from a dynamic library, we treat the new one as strong.
     Similarly, an old weak symbol from a regular file is treated as
     strong when the new symbol comes from a dynamic library.  Further,
     an old weak symbol from a dynamic library is treated as strong if
     the new symbol is from a dynamic library.  This reflects the way
     glibc's ld.so works.  */
  if (!newdyn && olddyn)
    newweak = FALSE;
  if (newdyn)
    oldweak = FALSE;
d878 5
a882 3
  /* It's OK to change the type if either the existing symbol or the
     new symbol is weak.  A type change is also OK if the old symbol
     is undefined and the new symbol is defined.  */
d884 12
a895 8
  if (oldweak
      || newweak
      || (newdef
	  && h->root.type == bfd_link_hash_undefined))
    *type_change_ok = TRUE;

  /* It's OK to change the size if either the existing symbol or the
     new symbol is weak, or if the old symbol is undefined.  */
d897 5
a901 3
  if (*type_change_ok
      || h->root.type == bfd_link_hash_undefined)
    *size_change_ok = TRUE;
a927 1
      && !newweak
d931 2
d950 22
d1009 6
a1014 1
     object to override a weak symbol in a shared object.  */
d1020 7
a1026 2
	      && (newweak
		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC))))
d1070 4
a1073 1
     symbol is a function or is weak.  */
d1079 1
a1079 2
	      && (oldweak
		  || h->type == STT_FUNC)))
d1082 2
a1083 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
d1172 43
d1221 2
a1222 1
   set DYNSYM if the new indirect symbol is dynamic.  */
d1233 2
a1234 1
			     bfd_boolean override)
d1295 1
a1295 1
			      &size_change_ok))
d1344 1
a1344 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, hi))
d1362 6
d1408 1
a1408 1
			      &size_change_ok))
d1440 6
d1514 1
a1514 1
	  if (! bfd_elf_link_record_dynamic_symbol (eif->info, h))
d2158 1
a2158 1
	  if (! bfd_elf_link_record_dynamic_symbol (eif->info, h))
a2544 6436
}

/* Return TRUE iff this is a non-common, definition of a non-function symbol.  */
static bfd_boolean
is_global_data_symbol_definition (bfd *abfd ATTRIBUTE_UNUSED,
				  Elf_Internal_Sym *sym)
{
  /* Local symbols do not count, but target specific ones might.  */
  if (ELF_ST_BIND (sym->st_info) != STB_GLOBAL
      && ELF_ST_BIND (sym->st_info) < STB_LOOS)
    return FALSE;

  /* Function symbols do not count.  */
  if (ELF_ST_TYPE (sym->st_info) == STT_FUNC)
    return FALSE;

  /* If the section is undefined, then so is the symbol.  */
  if (sym->st_shndx == SHN_UNDEF)
    return FALSE;

  /* If the symbol is defined in the common section, then
     it is a common definition and so does not count.  */
  if (sym->st_shndx == SHN_COMMON)
    return FALSE;

  /* If the symbol is in a target specific section then we
     must rely upon the backend to tell us what it is.  */
  if (sym->st_shndx >= SHN_LORESERVE && sym->st_shndx < SHN_ABS)
    /* FIXME - this function is not coded yet:

       return _bfd_is_global_symbol_definition (abfd, sym);

       Instead for now assume that the definition is not global,
       Even if this is wrong, at least the linker will behave
       in the same way that it used to do.  */
    return FALSE;

  return TRUE;
}

/* Search the symbol table of the archive element of the archive ABFD
   whose archive map contains a mention of SYMDEF, and determine if
   the symbol is defined in this element.  */
static bfd_boolean
elf_link_is_defined_archive_symbol (bfd * abfd, carsym * symdef)
{
  Elf_Internal_Shdr * hdr;
  bfd_size_type symcount;
  bfd_size_type extsymcount;
  bfd_size_type extsymoff;
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  bfd_boolean result;

  abfd = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
  if (abfd == NULL)
    return FALSE;

  if (! bfd_check_format (abfd, bfd_object))
    return FALSE;

  /* If we have already included the element containing this symbol in the
     link then we do not need to include it again.  Just claim that any symbol
     it contains is not a definition, so that our caller will not decide to
     (re)include this element.  */
  if (abfd->archive_pass)
    return FALSE;

  /* Select the appropriate symbol table.  */
  if ((abfd->flags & DYNAMIC) == 0 || elf_dynsymtab (abfd) == 0)
    hdr = &elf_tdata (abfd)->symtab_hdr;
  else
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;

  symcount = hdr->sh_size / get_elf_backend_data (abfd)->s->sizeof_sym;

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols.  */
  if (elf_bad_symtab (abfd))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }

  if (extsymcount == 0)
    return FALSE;

  /* Read in the symbol table.  */
  isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
				  NULL, NULL, NULL);
  if (isymbuf == NULL)
    return FALSE;

  /* Scan the symbol table looking for SYMDEF.  */
  result = FALSE;
  for (isym = isymbuf, isymend = isymbuf + extsymcount; isym < isymend; isym++)
    {
      const char *name;

      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	break;

      if (strcmp (name, symdef->name) == 0)
	{
	  result = is_global_data_symbol_definition (abfd, isym);
	  break;
	}
    }

  free (isymbuf);

  return result;
}

/* Add an entry to the .dynamic table.  */

bfd_boolean
_bfd_elf_add_dynamic_entry (struct bfd_link_info *info,
			    bfd_vma tag,
			    bfd_vma val)
{
  struct elf_link_hash_table *hash_table;
  const struct elf_backend_data *bed;
  asection *s;
  bfd_size_type newsize;
  bfd_byte *newcontents;
  Elf_Internal_Dyn dyn;

  hash_table = elf_hash_table (info);
  if (! is_elf_hash_table (hash_table))
    return FALSE;

  bed = get_elf_backend_data (hash_table->dynobj);
  s = bfd_get_section_by_name (hash_table->dynobj, ".dynamic");
  BFD_ASSERT (s != NULL);

  newsize = s->_raw_size + bed->s->sizeof_dyn;
  newcontents = bfd_realloc (s->contents, newsize);
  if (newcontents == NULL)
    return FALSE;

  dyn.d_tag = tag;
  dyn.d_un.d_val = val;
  bed->s->swap_dyn_out (hash_table->dynobj, &dyn, newcontents + s->_raw_size);

  s->_raw_size = newsize;
  s->contents = newcontents;

  return TRUE;
}

/* Add a DT_NEEDED entry for this dynamic object if DO_IT is true,
   otherwise just check whether one already exists.  Returns -1 on error,
   1 if a DT_NEEDED tag already exists, and 0 on success.  */

static int
elf_add_dt_needed_tag (struct bfd_link_info *info,
		       const char *soname,
		       bfd_boolean do_it)
{
  struct elf_link_hash_table *hash_table;
  bfd_size_type oldsize;
  bfd_size_type strindex;

  hash_table = elf_hash_table (info);
  oldsize = _bfd_elf_strtab_size (hash_table->dynstr);
  strindex = _bfd_elf_strtab_add (hash_table->dynstr, soname, FALSE);
  if (strindex == (bfd_size_type) -1)
    return -1;

  if (oldsize == _bfd_elf_strtab_size (hash_table->dynstr))
    {
      asection *sdyn;
      const struct elf_backend_data *bed;
      bfd_byte *extdyn;

      bed = get_elf_backend_data (hash_table->dynobj);
      sdyn = bfd_get_section_by_name (hash_table->dynobj, ".dynamic");
      BFD_ASSERT (sdyn != NULL);

      for (extdyn = sdyn->contents;
	   extdyn < sdyn->contents + sdyn->_raw_size;
	   extdyn += bed->s->sizeof_dyn)
	{
	  Elf_Internal_Dyn dyn;

	  bed->s->swap_dyn_in (hash_table->dynobj, extdyn, &dyn);
	  if (dyn.d_tag == DT_NEEDED
	      && dyn.d_un.d_val == strindex)
	    {
	      _bfd_elf_strtab_delref (hash_table->dynstr, strindex);
	      return 1;
	    }
	}
    }

  if (do_it)
    {
      if (!_bfd_elf_add_dynamic_entry (info, DT_NEEDED, strindex))
	return -1;
    }
  else
    /* We were just checking for existence of the tag.  */
    _bfd_elf_strtab_delref (hash_table->dynstr, strindex);

  return 0;
}

/* Sort symbol by value and section.  */
static int
elf_sort_symbol (const void *arg1, const void *arg2)
{
  const struct elf_link_hash_entry *h1;
  const struct elf_link_hash_entry *h2;
  bfd_signed_vma vdiff;

  h1 = *(const struct elf_link_hash_entry **) arg1;
  h2 = *(const struct elf_link_hash_entry **) arg2;
  vdiff = h1->root.u.def.value - h2->root.u.def.value;
  if (vdiff != 0)
    return vdiff > 0 ? 1 : -1;
  else
    {
      long sdiff = h1->root.u.def.section - h2->root.u.def.section;
      if (sdiff != 0)
	return sdiff > 0 ? 1 : -1;
    }
  return 0;
}

/* This function is used to adjust offsets into .dynstr for
   dynamic symbols.  This is called via elf_link_hash_traverse.  */

static bfd_boolean
elf_adjust_dynstr_offsets (struct elf_link_hash_entry *h, void *data)
{
  struct elf_strtab_hash *dynstr = data;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx != -1)
    h->dynstr_index = _bfd_elf_strtab_offset (dynstr, h->dynstr_index);
  return TRUE;
}

/* Assign string offsets in .dynstr, update all structures referencing
   them.  */

static bfd_boolean
elf_finalize_dynstr (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_link_hash_table *hash_table = elf_hash_table (info);
  struct elf_link_local_dynamic_entry *entry;
  struct elf_strtab_hash *dynstr = hash_table->dynstr;
  bfd *dynobj = hash_table->dynobj;
  asection *sdyn;
  bfd_size_type size;
  const struct elf_backend_data *bed;
  bfd_byte *extdyn;

  _bfd_elf_strtab_finalize (dynstr);
  size = _bfd_elf_strtab_size (dynstr);

  bed = get_elf_backend_data (dynobj);
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
  BFD_ASSERT (sdyn != NULL);

  /* Update all .dynamic entries referencing .dynstr strings.  */
  for (extdyn = sdyn->contents;
       extdyn < sdyn->contents + sdyn->_raw_size;
       extdyn += bed->s->sizeof_dyn)
    {
      Elf_Internal_Dyn dyn;

      bed->s->swap_dyn_in (dynobj, extdyn, &dyn);
      switch (dyn.d_tag)
	{
	case DT_STRSZ:
	  dyn.d_un.d_val = size;
	  break;
	case DT_NEEDED:
	case DT_SONAME:
	case DT_RPATH:
	case DT_RUNPATH:
	case DT_FILTER:
	case DT_AUXILIARY:
	  dyn.d_un.d_val = _bfd_elf_strtab_offset (dynstr, dyn.d_un.d_val);
	  break;
	default:
	  continue;
	}
      bed->s->swap_dyn_out (dynobj, &dyn, extdyn);
    }

  /* Now update local dynamic symbols.  */
  for (entry = hash_table->dynlocal; entry ; entry = entry->next)
    entry->isym.st_name = _bfd_elf_strtab_offset (dynstr,
						  entry->isym.st_name);

  /* And the rest of dynamic symbols.  */
  elf_link_hash_traverse (hash_table, elf_adjust_dynstr_offsets, dynstr);

  /* Adjust version definitions.  */
  if (elf_tdata (output_bfd)->cverdefs)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verdef def;
      Elf_Internal_Verdaux defaux;

      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
      p = s->contents;
      do
	{
	  _bfd_elf_swap_verdef_in (output_bfd, (Elf_External_Verdef *) p,
				   &def);
	  p += sizeof (Elf_External_Verdef);
	  for (i = 0; i < def.vd_cnt; ++i)
	    {
	      _bfd_elf_swap_verdaux_in (output_bfd,
					(Elf_External_Verdaux *) p, &defaux);
	      defaux.vda_name = _bfd_elf_strtab_offset (dynstr,
							defaux.vda_name);
	      _bfd_elf_swap_verdaux_out (output_bfd,
					 &defaux, (Elf_External_Verdaux *) p);
	      p += sizeof (Elf_External_Verdaux);
	    }
	}
      while (def.vd_next);
    }

  /* Adjust version references.  */
  if (elf_tdata (output_bfd)->verref)
    {
      asection *s;
      bfd_byte *p;
      bfd_size_type i;
      Elf_Internal_Verneed need;
      Elf_Internal_Vernaux needaux;

      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
      p = s->contents;
      do
	{
	  _bfd_elf_swap_verneed_in (output_bfd, (Elf_External_Verneed *) p,
				    &need);
	  need.vn_file = _bfd_elf_strtab_offset (dynstr, need.vn_file);
	  _bfd_elf_swap_verneed_out (output_bfd, &need,
				     (Elf_External_Verneed *) p);
	  p += sizeof (Elf_External_Verneed);
	  for (i = 0; i < need.vn_cnt; ++i)
	    {
	      _bfd_elf_swap_vernaux_in (output_bfd,
					(Elf_External_Vernaux *) p, &needaux);
	      needaux.vna_name = _bfd_elf_strtab_offset (dynstr,
							 needaux.vna_name);
	      _bfd_elf_swap_vernaux_out (output_bfd,
					 &needaux,
					 (Elf_External_Vernaux *) p);
	      p += sizeof (Elf_External_Vernaux);
	    }
	}
      while (need.vn_next);
    }

  return TRUE;
}

/* Add symbols from an ELF object file to the linker hash table.  */

static bfd_boolean
elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean (*add_symbol_hook)
    (bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
     const char **, flagword *, asection **, bfd_vma *);
  bfd_boolean (*check_relocs)
    (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
  bfd_boolean collect;
  Elf_Internal_Shdr *hdr;
  bfd_size_type symcount;
  bfd_size_type extsymcount;
  bfd_size_type extsymoff;
  struct elf_link_hash_entry **sym_hash;
  bfd_boolean dynamic;
  Elf_External_Versym *extversym = NULL;
  Elf_External_Versym *ever;
  struct elf_link_hash_entry *weaks;
  struct elf_link_hash_entry **nondeflt_vers = NULL;
  bfd_size_type nondeflt_vers_cnt = 0;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  const struct elf_backend_data *bed;
  bfd_boolean add_needed;
  struct elf_link_hash_table * hash_table;
  bfd_size_type amt;

  hash_table = elf_hash_table (info);

  bed = get_elf_backend_data (abfd);
  add_symbol_hook = bed->elf_add_symbol_hook;
  collect = bed->collect;

  if ((abfd->flags & DYNAMIC) == 0)
    dynamic = FALSE;
  else
    {
      dynamic = TRUE;

      /* You can't use -r against a dynamic object.  Also, there's no
	 hope of using a dynamic object which does not exactly match
	 the format of the output file.  */
      if (info->relocatable
	  || !is_elf_hash_table (hash_table)
	  || hash_table->root.creator != abfd->xvec)
	{
	  bfd_set_error (bfd_error_invalid_operation);
	  goto error_return;
	}
    }

  /* As a GNU extension, any input sections which are named
     .gnu.warning.SYMBOL are treated as warning symbols for the given
     symbol.  This differs from .gnu.warning sections, which generate
     warnings when they are included in an output file.  */
  if (info->executable)
    {
      asection *s;

      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  const char *name;

	  name = bfd_get_section_name (abfd, s);
	  if (strncmp (name, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0)
	    {
	      char *msg;
	      bfd_size_type sz;
	      bfd_size_type prefix_len;
	      const char * gnu_warning_prefix = _("warning: ");

	      name += sizeof ".gnu.warning." - 1;

	      /* If this is a shared object, then look up the symbol
		 in the hash table.  If it is there, and it is already
		 been defined, then we will not be using the entry
		 from this shared object, so we don't need to warn.
		 FIXME: If we see the definition in a regular object
		 later on, we will warn, but we shouldn't.  The only
		 fix is to keep track of what warnings we are supposed
		 to emit, and then handle them all at the end of the
		 link.  */
	      if (dynamic)
		{
		  struct elf_link_hash_entry *h;

		  h = elf_link_hash_lookup (hash_table, name,
					    FALSE, FALSE, TRUE);

		  /* FIXME: What about bfd_link_hash_common?  */
		  if (h != NULL
		      && (h->root.type == bfd_link_hash_defined
			  || h->root.type == bfd_link_hash_defweak))
		    {
		      /* We don't want to issue this warning.  Clobber
			 the section size so that the warning does not
			 get copied into the output file.  */
		      s->_raw_size = 0;
		      continue;
		    }
		}

	      sz = bfd_section_size (abfd, s);
	      prefix_len = strlen (gnu_warning_prefix);
	      msg = bfd_alloc (abfd, prefix_len + sz + 1);
	      if (msg == NULL)
		goto error_return;

	      strcpy (msg, gnu_warning_prefix);
	      if (! bfd_get_section_contents (abfd, s, msg + prefix_len, 0, sz))
		goto error_return;

	      msg[prefix_len + sz] = '\0';

	      if (! (_bfd_generic_link_add_one_symbol
		     (info, abfd, name, BSF_WARNING, s, 0, msg,
		      FALSE, collect, NULL)))
		goto error_return;

	      if (! info->relocatable)
		{
		  /* Clobber the section size so that the warning does
		     not get copied into the output file.  */
		  s->_raw_size = 0;
		}
	    }
	}
    }

  add_needed = TRUE;
  if (! dynamic)
    {
      /* If we are creating a shared library, create all the dynamic
	 sections immediately.  We need to attach them to something,
	 so we attach them to this BFD, provided it is the right
	 format.  FIXME: If there are no input BFD's of the same
	 format as the output, we can't make a shared library.  */
      if (info->shared
	  && is_elf_hash_table (hash_table)
	  && hash_table->root.creator == abfd->xvec
	  && ! hash_table->dynamic_sections_created)
	{
	  if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	    goto error_return;
	}
    }
  else if (!is_elf_hash_table (hash_table))
    goto error_return;
  else
    {
      asection *s;
      const char *soname = NULL;
      struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;
      int ret;

      /* ld --just-symbols and dynamic objects don't mix very well.
	 Test for --just-symbols by looking at info set up by
	 _bfd_elf_link_just_syms.  */
      if ((s = abfd->sections) != NULL
	  && s->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
	goto error_return;

      /* If this dynamic lib was specified on the command line with
	 --as-needed in effect, then we don't want to add a DT_NEEDED
	 tag unless the lib is actually used.  Similary for libs brought
	 in by another lib's DT_NEEDED.  */
      add_needed = elf_dyn_lib_class (abfd) == DYN_NORMAL;

      s = bfd_get_section_by_name (abfd, ".dynamic");
      if (s != NULL)
	{
	  bfd_byte *dynbuf;
	  bfd_byte *extdyn;
	  int elfsec;
	  unsigned long shlink;

	  dynbuf = bfd_malloc (s->_raw_size);
	  if (dynbuf == NULL)
	    goto error_return;

	  if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
	    goto error_free_dyn;

	  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
	  if (elfsec == -1)
	    goto error_free_dyn;
	  shlink = elf_elfsections (abfd)[elfsec]->sh_link;

	  for (extdyn = dynbuf;
	       extdyn < dynbuf + s->_raw_size;
	       extdyn += bed->s->sizeof_dyn)
	    {
	      Elf_Internal_Dyn dyn;

	      bed->s->swap_dyn_in (abfd, extdyn, &dyn);
	      if (dyn.d_tag == DT_SONAME)
		{
		  unsigned int tagv = dyn.d_un.d_val;
		  soname = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (soname == NULL)
		    goto error_free_dyn;
		}
	      if (dyn.d_tag == DT_NEEDED)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    goto error_free_dyn;
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = & hash_table->needed;
		       *pn != NULL;
		       pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	      if (dyn.d_tag == DT_RUNPATH)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    goto error_free_dyn;
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = & runpath;
		       *pn != NULL;
		       pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	      /* Ignore DT_RPATH if we have seen DT_RUNPATH.  */
	      if (!runpath && dyn.d_tag == DT_RPATH)
		{
		  struct bfd_link_needed_list *n, **pn;
		  char *fnm, *anm;
		  unsigned int tagv = dyn.d_un.d_val;

		  amt = sizeof (struct bfd_link_needed_list);
		  n = bfd_alloc (abfd, amt);
		  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
		  if (n == NULL || fnm == NULL)
		    goto error_free_dyn;
		  amt = strlen (fnm) + 1;
		  anm = bfd_alloc (abfd, amt);
		  if (anm == NULL)
		    {
		    error_free_dyn:
		      free (dynbuf);
		      goto error_return;
		    }
		  memcpy (anm, fnm, amt);
		  n->name = anm;
		  n->by = abfd;
		  n->next = NULL;
		  for (pn = & rpath;
		       *pn != NULL;
		       pn = &(*pn)->next)
		    ;
		  *pn = n;
		}
	    }

	  free (dynbuf);
	}

      /* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that
	 frees all more recently bfd_alloc'd blocks as well.  */
      if (runpath)
	rpath = runpath;

      if (rpath)
	{
	  struct bfd_link_needed_list **pn;
	  for (pn = & hash_table->runpath;
	       *pn != NULL;
	       pn = &(*pn)->next)
	    ;
	  *pn = rpath;
	}

      /* We do not want to include any of the sections in a dynamic
	 object in the output file.  We hack by simply clobbering the
	 list of sections in the BFD.  This could be handled more
	 cleanly by, say, a new section flag; the existing
	 SEC_NEVER_LOAD flag is not the one we want, because that one
	 still implies that the section takes up space in the output
	 file.  */
      bfd_section_list_clear (abfd);

      /* If this is the first dynamic object found in the link, create
	 the special sections required for dynamic linking.  */
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	goto error_return;

      /* Find the name to use in a DT_NEEDED entry that refers to this
	 object.  If the object has a DT_SONAME entry, we use it.
	 Otherwise, if the generic linker stuck something in
	 elf_dt_name, we use that.  Otherwise, we just use the file
	 name.  */
      if (soname == NULL || *soname == '\0')
	{
	  soname = elf_dt_name (abfd);
	  if (soname == NULL || *soname == '\0')
	    soname = bfd_get_filename (abfd);
	}

      /* Save the SONAME because sometimes the linker emulation code
	 will need to know it.  */
      elf_dt_name (abfd) = soname;

      ret = elf_add_dt_needed_tag (info, soname, add_needed);
      if (ret < 0)
	goto error_return;

      /* If we have already included this dynamic object in the
	 link, just ignore it.  There is no reason to include a
	 particular dynamic object more than once.  */
      if (ret > 0)
	return TRUE;
    }

  /* If this is a dynamic object, we always link against the .dynsym
     symbol table, not the .symtab symbol table.  The dynamic linker
     will only see the .dynsym symbol table, so there is no reason to
     look at .symtab for a dynamic object.  */

  if (! dynamic || elf_dynsymtab (abfd) == 0)
    hdr = &elf_tdata (abfd)->symtab_hdr;
  else
    hdr = &elf_tdata (abfd)->dynsymtab_hdr;

  symcount = hdr->sh_size / bed->s->sizeof_sym;

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols at
     this point.  */
  if (elf_bad_symtab (abfd))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }

  sym_hash = NULL;
  if (extsymcount != 0)
    {
      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	goto error_return;

      /* We store a pointer to the hash table entry for each external
	 symbol.  */
      amt = extsymcount * sizeof (struct elf_link_hash_entry *);
      sym_hash = bfd_alloc (abfd, amt);
      if (sym_hash == NULL)
	goto error_free_sym;
      elf_sym_hashes (abfd) = sym_hash;
    }

  if (dynamic)
    {
      /* Read in any version definitions.  */
      if (! _bfd_elf_slurp_version_tables (abfd))
	goto error_free_sym;

      /* Read in the symbol versions, but don't bother to convert them
	 to internal format.  */
      if (elf_dynversym (abfd) != 0)
	{
	  Elf_Internal_Shdr *versymhdr;

	  versymhdr = &elf_tdata (abfd)->dynversym_hdr;
	  extversym = bfd_malloc (versymhdr->sh_size);
	  if (extversym == NULL)
	    goto error_free_sym;
	  amt = versymhdr->sh_size;
	  if (bfd_seek (abfd, versymhdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread (extversym, amt, abfd) != amt)
	    goto error_free_vers;
	}
    }

  weaks = NULL;

  ever = extversym != NULL ? extversym + extsymoff : NULL;
  for (isym = isymbuf, isymend = isymbuf + extsymcount;
       isym < isymend;
       isym++, sym_hash++, ever = (ever != NULL ? ever + 1 : NULL))
    {
      int bind;
      bfd_vma value;
      asection *sec;
      flagword flags;
      const char *name;
      struct elf_link_hash_entry *h;
      bfd_boolean definition;
      bfd_boolean size_change_ok;
      bfd_boolean type_change_ok;
      bfd_boolean new_weakdef;
      bfd_boolean override;
      unsigned int old_alignment;
      bfd *old_bfd;

      override = FALSE;

      flags = BSF_NO_FLAGS;
      sec = NULL;
      value = isym->st_value;
      *sym_hash = NULL;

      bind = ELF_ST_BIND (isym->st_info);
      if (bind == STB_LOCAL)
	{
	  /* This should be impossible, since ELF requires that all
	     global symbols follow all local symbols, and that sh_info
	     point to the first global symbol.  Unfortunately, Irix 5
	     screws this up.  */
	  continue;
	}
      else if (bind == STB_GLOBAL)
	{
	  if (isym->st_shndx != SHN_UNDEF
	      && isym->st_shndx != SHN_COMMON)
	    flags = BSF_GLOBAL;
	}
      else if (bind == STB_WEAK)
	flags = BSF_WEAK;
      else
	{
	  /* Leave it up to the processor backend.  */
	}

      if (isym->st_shndx == SHN_UNDEF)
	sec = bfd_und_section_ptr;
      else if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
	{
	  sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  if (sec == NULL)
	    sec = bfd_abs_section_ptr;
	  else if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
	    value -= sec->vma;
	}
      else if (isym->st_shndx == SHN_ABS)
	sec = bfd_abs_section_ptr;
      else if (isym->st_shndx == SHN_COMMON)
	{
	  sec = bfd_com_section_ptr;
	  /* What ELF calls the size we call the value.  What ELF
	     calls the value we call the alignment.  */
	  value = isym->st_size;
	}
      else
	{
	  /* Leave it up to the processor backend.  */
	}

      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	goto error_free_vers;

      if (isym->st_shndx == SHN_COMMON
	  && ELF_ST_TYPE (isym->st_info) == STT_TLS)
	{
	  asection *tcomm = bfd_get_section_by_name (abfd, ".tcommon");

	  if (tcomm == NULL)
	    {
	      tcomm = bfd_make_section (abfd, ".tcommon");
	      if (tcomm == NULL
		  || !bfd_set_section_flags (abfd, tcomm, (SEC_ALLOC
							   | SEC_IS_COMMON
							   | SEC_LINKER_CREATED
							   | SEC_THREAD_LOCAL)))
		goto error_free_vers;
	    }
	  sec = tcomm;
	}
      else if (add_symbol_hook)
	{
	  if (! (*add_symbol_hook) (abfd, info, isym, &name, &flags, &sec,
				    &value))
	    goto error_free_vers;

	  /* The hook function sets the name to NULL if this symbol
	     should be skipped for some reason.  */
	  if (name == NULL)
	    continue;
	}

      /* Sanity check that all possibilities were handled.  */
      if (sec == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  goto error_free_vers;
	}

      if (bfd_is_und_section (sec)
	  || bfd_is_com_section (sec))
	definition = FALSE;
      else
	definition = TRUE;

      size_change_ok = FALSE;
      type_change_ok = get_elf_backend_data (abfd)->type_change_ok;
      old_alignment = 0;
      old_bfd = NULL;

      if (is_elf_hash_table (hash_table))
	{
	  Elf_Internal_Versym iver;
	  unsigned int vernum = 0;
	  bfd_boolean skip;

	  if (ever != NULL)
	    {
	      _bfd_elf_swap_versym_in (abfd, ever, &iver);
	      vernum = iver.vs_vers & VERSYM_VERSION;

	      /* If this is a hidden symbol, or if it is not version
		 1, we append the version name to the symbol name.
		 However, we do not modify a non-hidden absolute
		 symbol, because it might be the version symbol
		 itself.  FIXME: What if it isn't?  */
	      if ((iver.vs_vers & VERSYM_HIDDEN) != 0
		  || (vernum > 1 && ! bfd_is_abs_section (sec)))
		{
		  const char *verstr;
		  size_t namelen, verlen, newlen;
		  char *newname, *p;

		  if (isym->st_shndx != SHN_UNDEF)
		    {
		      if (vernum > elf_tdata (abfd)->dynverdef_hdr.sh_info)
			{
			  (*_bfd_error_handler)
			    (_("%s: %s: invalid version %u (max %d)"),
			     bfd_archive_filename (abfd), name, vernum,
			     elf_tdata (abfd)->dynverdef_hdr.sh_info);
			  bfd_set_error (bfd_error_bad_value);
			  goto error_free_vers;
			}
		      else if (vernum > 1)
			verstr =
			  elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;
		      else
			verstr = "";
		    }
		  else
		    {
		      /* We cannot simply test for the number of
			 entries in the VERNEED section since the
			 numbers for the needed versions do not start
			 at 0.  */
		      Elf_Internal_Verneed *t;

		      verstr = NULL;
		      for (t = elf_tdata (abfd)->verref;
			   t != NULL;
			   t = t->vn_nextref)
			{
			  Elf_Internal_Vernaux *a;

			  for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
			    {
			      if (a->vna_other == vernum)
				{
				  verstr = a->vna_nodename;
				  break;
				}
			    }
			  if (a != NULL)
			    break;
			}
		      if (verstr == NULL)
			{
			  (*_bfd_error_handler)
			    (_("%s: %s: invalid needed version %d"),
			     bfd_archive_filename (abfd), name, vernum);
			  bfd_set_error (bfd_error_bad_value);
			  goto error_free_vers;
			}
		    }

		  namelen = strlen (name);
		  verlen = strlen (verstr);
		  newlen = namelen + verlen + 2;
		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
		      && isym->st_shndx != SHN_UNDEF)
		    ++newlen;

		  newname = bfd_alloc (abfd, newlen);
		  if (newname == NULL)
		    goto error_free_vers;
		  memcpy (newname, name, namelen);
		  p = newname + namelen;
		  *p++ = ELF_VER_CHR;
		  /* If this is a defined non-hidden version symbol,
		     we add another @@ to the name.  This indicates the
		     default version of the symbol.  */
		  if ((iver.vs_vers & VERSYM_HIDDEN) == 0
		      && isym->st_shndx != SHN_UNDEF)
		    *p++ = ELF_VER_CHR;
		  memcpy (p, verstr, verlen + 1);

		  name = newname;
		}
	    }

	  if (!_bfd_elf_merge_symbol (abfd, info, name, isym, &sec, &value,
				      sym_hash, &skip, &override,
				      &type_change_ok, &size_change_ok))
	    goto error_free_vers;

	  if (skip)
	    continue;

	  if (override)
	    definition = FALSE;

	  h = *sym_hash;
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* Remember the old alignment if this is a common symbol, so
	     that we don't reduce the alignment later on.  We can't
	     check later, because _bfd_generic_link_add_one_symbol
	     will set a default for the alignment which we want to
	     override. We also remember the old bfd where the existing
	     definition comes from.  */
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      old_bfd = h->root.u.def.section->owner;
	      break;

	    case bfd_link_hash_common:
	      old_bfd = h->root.u.c.p->section->owner;
	      old_alignment = h->root.u.c.p->alignment_power;
	      break;
	    }

	  if (elf_tdata (abfd)->verdef != NULL
	      && ! override
	      && vernum > 1
	      && definition)
	    h->verinfo.verdef = &elf_tdata (abfd)->verdef[vernum - 1];
	}

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, name, flags, sec, value, NULL, FALSE, collect,
	      (struct bfd_link_hash_entry **) sym_hash)))
	goto error_free_vers;

      h = *sym_hash;
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
      *sym_hash = h;

      new_weakdef = FALSE;
      if (dynamic
	  && definition
	  && (flags & BSF_WEAK) != 0
	  && ELF_ST_TYPE (isym->st_info) != STT_FUNC
	  && is_elf_hash_table (hash_table)
	  && h->weakdef == NULL)
	{
	  /* Keep a list of all weak defined non function symbols from
	     a dynamic object, using the weakdef field.  Later in this
	     function we will set the weakdef field to the correct
	     value.  We only put non-function symbols from dynamic
	     objects on this list, because that happens to be the only
	     time we need to know the normal symbol corresponding to a
	     weak symbol, and the information is time consuming to
	     figure out.  If the weakdef field is not already NULL,
	     then this symbol was already defined by some previous
	     dynamic object, and we will be using that previous
	     definition anyhow.  */

	  h->weakdef = weaks;
	  weaks = h;
	  new_weakdef = TRUE;
	}

      /* Set the alignment of a common symbol.  */
      if (isym->st_shndx == SHN_COMMON
	  && h->root.type == bfd_link_hash_common)
	{
	  unsigned int align;

	  align = bfd_log2 (isym->st_value);
	  if (align > old_alignment
	      /* Permit an alignment power of zero if an alignment of one
		 is specified and no other alignments have been specified.  */
	      || (isym->st_value == 1 && old_alignment == 0))
	    h->root.u.c.p->alignment_power = align;
	  else
	    h->root.u.c.p->alignment_power = old_alignment;
	}

      if (is_elf_hash_table (hash_table))
	{
	  int old_flags;
	  bfd_boolean dynsym;
	  int new_flag;

	  /* Check the alignment when a common symbol is involved. This
	     can change when a common symbol is overridden by a normal
	     definition or a common symbol is ignored due to the old
	     normal definition. We need to make sure the maximum
	     alignment is maintained.  */
	  if ((old_alignment || isym->st_shndx == SHN_COMMON)
	      && h->root.type != bfd_link_hash_common)
	    {
	      unsigned int common_align;
	      unsigned int normal_align;
	      unsigned int symbol_align;
	      bfd *normal_bfd;
	      bfd *common_bfd;

	      symbol_align = ffs (h->root.u.def.value) - 1;
	      if (h->root.u.def.section->owner != NULL
		  && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
		{
		  normal_align = h->root.u.def.section->alignment_power;
		  if (normal_align > symbol_align)
		    normal_align = symbol_align;
		}
	      else
		normal_align = symbol_align;

	      if (old_alignment)
		{
		  common_align = old_alignment;
		  common_bfd = old_bfd;
		  normal_bfd = abfd;
		}
	      else
		{
		  common_align = bfd_log2 (isym->st_value);
		  common_bfd = abfd;
		  normal_bfd = old_bfd;
		}

	      if (normal_align < common_align)
		(*_bfd_error_handler)
		  (_("Warning: alignment %u of symbol `%s' in %s is smaller than %u in %s"),
		   1 << normal_align,
		   name,
		   bfd_archive_filename (normal_bfd),
		   1 << common_align,
		   bfd_archive_filename (common_bfd));
	    }

	  /* Remember the symbol size and type.  */
	  if (isym->st_size != 0
	      && (definition || h->size == 0))
	    {
	      if (h->size != 0 && h->size != isym->st_size && ! size_change_ok)
		(*_bfd_error_handler)
		  (_("Warning: size of symbol `%s' changed from %lu in %s to %lu in %s"),
		   name, (unsigned long) h->size,
		   bfd_archive_filename (old_bfd),
		   (unsigned long) isym->st_size,
		   bfd_archive_filename (abfd));

	      h->size = isym->st_size;
	    }

	  /* If this is a common symbol, then we always want H->SIZE
	     to be the size of the common symbol.  The code just above
	     won't fix the size if a common symbol becomes larger.  We
	     don't warn about a size change here, because that is
	     covered by --warn-common.  */
	  if (h->root.type == bfd_link_hash_common)
	    h->size = h->root.u.c.size;

	  if (ELF_ST_TYPE (isym->st_info) != STT_NOTYPE
	      && (definition || h->type == STT_NOTYPE))
	    {
	      if (h->type != STT_NOTYPE
		  && h->type != ELF_ST_TYPE (isym->st_info)
		  && ! type_change_ok)
		(*_bfd_error_handler)
		  (_("Warning: type of symbol `%s' changed from %d to %d in %s"),
		   name, h->type, ELF_ST_TYPE (isym->st_info),
		   bfd_archive_filename (abfd));

	      h->type = ELF_ST_TYPE (isym->st_info);
	    }

	  /* If st_other has a processor-specific meaning, specific
	     code might be needed here. We never merge the visibility
	     attribute with the one from a dynamic object.  */
	  if (bed->elf_backend_merge_symbol_attribute)
	    (*bed->elf_backend_merge_symbol_attribute) (h, isym, definition,
							dynamic);

	  if (isym->st_other != 0 && !dynamic)
	    {
	      unsigned char hvis, symvis, other, nvis;

	      /* Take the balance of OTHER from the definition.  */
	      other = (definition ? isym->st_other : h->other);
	      other &= ~ ELF_ST_VISIBILITY (-1);

	      /* Combine visibilities, using the most constraining one.  */
	      hvis   = ELF_ST_VISIBILITY (h->other);
	      symvis = ELF_ST_VISIBILITY (isym->st_other);
	      if (! hvis)
		nvis = symvis;
	      else if (! symvis)
		nvis = hvis;
	      else
		nvis = hvis < symvis ? hvis : symvis;

	      h->other = other | nvis;
	    }

	  /* Set a flag in the hash table entry indicating the type of
	     reference or definition we just found.  Keep a count of
	     the number of dynamic symbols we find.  A dynamic symbol
	     is one which is referenced or defined by both a regular
	     object and a shared object.  */
	  old_flags = h->elf_link_hash_flags;
	  dynsym = FALSE;
	  if (! dynamic)
	    {
	      if (! definition)
		{
		  new_flag = ELF_LINK_HASH_REF_REGULAR;
		  if (bind != STB_WEAK)
		    new_flag |= ELF_LINK_HASH_REF_REGULAR_NONWEAK;
		}
	      else
		new_flag = ELF_LINK_HASH_DEF_REGULAR;
	      if (! info->executable
		  || (old_flags & (ELF_LINK_HASH_DEF_DYNAMIC
				   | ELF_LINK_HASH_REF_DYNAMIC)) != 0)
		dynsym = TRUE;
	    }
	  else
	    {
	      if (! definition)
		new_flag = ELF_LINK_HASH_REF_DYNAMIC;
	      else
		new_flag = ELF_LINK_HASH_DEF_DYNAMIC;
	      if ((old_flags & (ELF_LINK_HASH_DEF_REGULAR
				| ELF_LINK_HASH_REF_REGULAR)) != 0
		  || (h->weakdef != NULL
		      && ! new_weakdef
		      && h->weakdef->dynindx != -1))
		dynsym = TRUE;
	    }

	  h->elf_link_hash_flags |= new_flag;

	  /* Check to see if we need to add an indirect symbol for
	     the default name.  */
	  if (definition || h->root.type == bfd_link_hash_common)
	    if (!_bfd_elf_add_default_symbol (abfd, info, h, name, isym,
					      &sec, &value, &dynsym,
					      override))
	      goto error_free_vers;

	  if (definition && !dynamic)
	    {
	      char *p = strchr (name, ELF_VER_CHR);
	      if (p != NULL && p[1] != ELF_VER_CHR)
		{
		  /* Queue non-default versions so that .symver x, x@@FOO
		     aliases can be checked.  */
		  if (! nondeflt_vers)
		    {
		      amt = (isymend - isym + 1)
			    * sizeof (struct elf_link_hash_entry *);
		      nondeflt_vers = bfd_malloc (amt);
		    }
		  nondeflt_vers [nondeflt_vers_cnt++] = h;
		}
	    }

	  if (dynsym && h->dynindx == -1)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		goto error_free_vers;
	      if (h->weakdef != NULL
		  && ! new_weakdef
		  && h->weakdef->dynindx == -1)
		{
		  if (! bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
		    goto error_free_vers;
		}
	    }
	  else if (dynsym && h->dynindx != -1)
	    /* If the symbol already has a dynamic index, but
	       visibility says it should not be visible, turn it into
	       a local symbol.  */
	    switch (ELF_ST_VISIBILITY (h->other))
	      {
	      case STV_INTERNAL:
	      case STV_HIDDEN:
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
		dynsym = FALSE;
		break;
	      }

	  if (!add_needed
	      && definition
	      && dynsym
	      && (h->elf_link_hash_flags
		  & ELF_LINK_HASH_REF_REGULAR) != 0)
	    {
	      int ret;
	      const char *soname = elf_dt_name (abfd);

	      /* A symbol from a library loaded via DT_NEEDED of some
		 other library is referenced by a regular object.
		 Add a DT_NEEDED entry for it.  */
	      add_needed = TRUE;
	      ret = elf_add_dt_needed_tag (info, soname, add_needed);
	      if (ret < 0)
		goto error_free_vers;

	      BFD_ASSERT (ret == 0);
	    }
	}
    }

  /* Now that all the symbols from this input file are created, handle
     .symver foo, foo@@BAR such that any relocs against foo become foo@@BAR.  */
  if (nondeflt_vers != NULL)
    {
      bfd_size_type cnt, symidx;

      for (cnt = 0; cnt < nondeflt_vers_cnt; ++cnt)
	{
	  struct elf_link_hash_entry *h = nondeflt_vers[cnt], *hi;
	  char *shortname, *p;

	  p = strchr (h->root.root.string, ELF_VER_CHR);
	  if (p == NULL
	      || (h->root.type != bfd_link_hash_defined
		  && h->root.type != bfd_link_hash_defweak))
	    continue;

	  amt = p - h->root.root.string;
	  shortname = bfd_malloc (amt + 1);
	  memcpy (shortname, h->root.root.string, amt);
	  shortname[amt] = '\0';

	  hi = (struct elf_link_hash_entry *)
	       bfd_link_hash_lookup (&hash_table->root, shortname,
				     FALSE, FALSE, FALSE);
	  if (hi != NULL
	      && hi->root.type == h->root.type
	      && hi->root.u.def.value == h->root.u.def.value
	      && hi->root.u.def.section == h->root.u.def.section)
	    {
	      (*bed->elf_backend_hide_symbol) (info, hi, TRUE);
	      hi->root.type = bfd_link_hash_indirect;
	      hi->root.u.i.link = (struct bfd_link_hash_entry *) h;
	      (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);
	      sym_hash = elf_sym_hashes (abfd);
	      if (sym_hash)
		for (symidx = 0; symidx < extsymcount; ++symidx)
		  if (sym_hash[symidx] == hi)
		    {
		      sym_hash[symidx] = h;
		      break;
		    }
	    }
	  free (shortname);
	}
      free (nondeflt_vers);
      nondeflt_vers = NULL;
    }

  if (extversym != NULL)
    {
      free (extversym);
      extversym = NULL;
    }

  if (isymbuf != NULL)
    free (isymbuf);
  isymbuf = NULL;

  /* Now set the weakdefs field correctly for all the weak defined
     symbols we found.  The only way to do this is to search all the
     symbols.  Since we only need the information for non functions in
     dynamic objects, that's the only time we actually put anything on
     the list WEAKS.  We need this information so that if a regular
     object refers to a symbol defined weakly in a dynamic object, the
     real symbol in the dynamic object is also put in the dynamic
     symbols; we also must arrange for both symbols to point to the
     same memory location.  We could handle the general case of symbol
     aliasing, but a general symbol alias can only be generated in
     assembler code, handling it correctly would be very time
     consuming, and other ELF linkers don't handle general aliasing
     either.  */
  if (weaks != NULL)
    {
      struct elf_link_hash_entry **hpp;
      struct elf_link_hash_entry **hppend;
      struct elf_link_hash_entry **sorted_sym_hash;
      struct elf_link_hash_entry *h;
      size_t sym_count;

      /* Since we have to search the whole symbol list for each weak
	 defined symbol, search time for N weak defined symbols will be
	 O(N^2). Binary search will cut it down to O(NlogN).  */
      amt = extsymcount * sizeof (struct elf_link_hash_entry *);
      sorted_sym_hash = bfd_malloc (amt);
      if (sorted_sym_hash == NULL)
	goto error_return;
      sym_hash = sorted_sym_hash;
      hpp = elf_sym_hashes (abfd);
      hppend = hpp + extsymcount;
      sym_count = 0;
      for (; hpp < hppend; hpp++)
	{
	  h = *hpp;
	  if (h != NULL
	      && h->root.type == bfd_link_hash_defined
	      && h->type != STT_FUNC)
	    {
	      *sym_hash = h;
	      sym_hash++;
	      sym_count++;
	    }
	}

      qsort (sorted_sym_hash, sym_count,
	     sizeof (struct elf_link_hash_entry *),
	     elf_sort_symbol);

      while (weaks != NULL)
	{
	  struct elf_link_hash_entry *hlook;
	  asection *slook;
	  bfd_vma vlook;
	  long ilook;
	  size_t i, j, idx;

	  hlook = weaks;
	  weaks = hlook->weakdef;
	  hlook->weakdef = NULL;

	  BFD_ASSERT (hlook->root.type == bfd_link_hash_defined
		      || hlook->root.type == bfd_link_hash_defweak
		      || hlook->root.type == bfd_link_hash_common
		      || hlook->root.type == bfd_link_hash_indirect);
	  slook = hlook->root.u.def.section;
	  vlook = hlook->root.u.def.value;

	  ilook = -1;
	  i = 0;
	  j = sym_count;
	  while (i < j)
	    {
	      bfd_signed_vma vdiff;
	      idx = (i + j) / 2;
	      h = sorted_sym_hash [idx];
	      vdiff = vlook - h->root.u.def.value;
	      if (vdiff < 0)
		j = idx;
	      else if (vdiff > 0)
		i = idx + 1;
	      else
		{
		  long sdiff = slook - h->root.u.def.section;
		  if (sdiff < 0)
		    j = idx;
		  else if (sdiff > 0)
		    i = idx + 1;
		  else
		    {
		      ilook = idx;
		      break;
		    }
		}
	    }

	  /* We didn't find a value/section match.  */
	  if (ilook == -1)
	    continue;

	  for (i = ilook; i < sym_count; i++)
	    {
	      h = sorted_sym_hash [i];

	      /* Stop if value or section doesn't match.  */
	      if (h->root.u.def.value != vlook
		  || h->root.u.def.section != slook)
		break;
	      else if (h != hlook)
		{
		  hlook->weakdef = h;

		  /* If the weak definition is in the list of dynamic
		     symbols, make sure the real definition is put
		     there as well.  */
		  if (hlook->dynindx != -1 && h->dynindx == -1)
		    {
		      if (! bfd_elf_link_record_dynamic_symbol (info, h))
			goto error_return;
		    }

		  /* If the real definition is in the list of dynamic
		     symbols, make sure the weak definition is put
		     there as well.  If we don't do this, then the
		     dynamic loader might not merge the entries for the
		     real definition and the weak definition.  */
		  if (h->dynindx != -1 && hlook->dynindx == -1)
		    {
		      if (! bfd_elf_link_record_dynamic_symbol (info, hlook))
			goto error_return;
		    }
		  break;
		}
	    }
	}

      free (sorted_sym_hash);
    }

  /* If this object is the same format as the output object, and it is
     not a shared library, then let the backend look through the
     relocs.

     This is required to build global offset table entries and to
     arrange for dynamic relocs.  It is not required for the
     particular common case of linking non PIC code, even when linking
     against shared libraries, but unfortunately there is no way of
     knowing whether an object file has been compiled PIC or not.
     Looking through the relocs is not particularly time consuming.
     The problem is that we must either (1) keep the relocs in memory,
     which causes the linker to require additional runtime memory or
     (2) read the relocs twice from the input file, which wastes time.
     This would be a good case for using mmap.

     I have no idea how to handle linking PIC code into a file of a
     different format.  It probably can't be done.  */
  check_relocs = get_elf_backend_data (abfd)->check_relocs;
  if (! dynamic
      && is_elf_hash_table (hash_table)
      && hash_table->root.creator == abfd->xvec
      && check_relocs != NULL)
    {
      asection *o;

      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  Elf_Internal_Rela *internal_relocs;
	  bfd_boolean ok;

	  if ((o->flags & SEC_RELOC) == 0
	      || o->reloc_count == 0
	      || ((info->strip == strip_all || info->strip == strip_debugger)
		  && (o->flags & SEC_DEBUGGING) != 0)
	      || bfd_is_abs_section (o->output_section))
	    continue;

	  internal_relocs = _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
						       info->keep_memory);
	  if (internal_relocs == NULL)
	    goto error_return;

	  ok = (*check_relocs) (abfd, info, o, internal_relocs);

	  if (elf_section_data (o)->relocs != internal_relocs)
	    free (internal_relocs);

	  if (! ok)
	    goto error_return;
	}
    }

  /* If this is a non-traditional link, try to optimize the handling
     of the .stab/.stabstr sections.  */
  if (! dynamic
      && ! info->traditional_format
      && is_elf_hash_table (hash_table)
      && (info->strip != strip_all && info->strip != strip_debugger))
    {
      asection *stabstr;

      stabstr = bfd_get_section_by_name (abfd, ".stabstr");
      if (stabstr != NULL)
	{
	  bfd_size_type string_offset = 0;
	  asection *stab;

	  for (stab = abfd->sections; stab; stab = stab->next)
	    if (strncmp (".stab", stab->name, 5) == 0
		&& (!stab->name[5] ||
		    (stab->name[5] == '.' && ISDIGIT (stab->name[6])))
		&& (stab->flags & SEC_MERGE) == 0
		&& !bfd_is_abs_section (stab->output_section))
	      {
		struct bfd_elf_section_data *secdata;

		secdata = elf_section_data (stab);
		if (! _bfd_link_section_stabs (abfd,
					       & hash_table->stab_info,
					       stab, stabstr,
					       &secdata->sec_info,
					       &string_offset))
		  goto error_return;
		if (secdata->sec_info)
		  stab->sec_info_type = ELF_INFO_TYPE_STABS;
	    }
	}
    }

  if (! info->relocatable
      && ! dynamic
      && is_elf_hash_table (hash_table))
    {
      asection *s;

      for (s = abfd->sections; s != NULL; s = s->next)
	if ((s->flags & SEC_MERGE) != 0
	    && !bfd_is_abs_section (s->output_section))
	  {
	    struct bfd_elf_section_data *secdata;

	    secdata = elf_section_data (s);
	    if (! _bfd_merge_section (abfd,
				      & hash_table->merge_info,
				      s, &secdata->sec_info))
	      goto error_return;
	    else if (secdata->sec_info)
	      s->sec_info_type = ELF_INFO_TYPE_MERGE;
	  }
    }

  if (is_elf_hash_table (hash_table))
    {
      /* Add this bfd to the loaded list.  */
      struct elf_link_loaded_list *n;

      n = bfd_alloc (abfd, sizeof (struct elf_link_loaded_list));
      if (n == NULL)
	goto error_return;
      n->abfd = abfd;
      n->next = hash_table->loaded;
      hash_table->loaded = n;
    }

  return TRUE;

 error_free_vers:
  if (nondeflt_vers != NULL)
    free (nondeflt_vers);
  if (extversym != NULL)
    free (extversym);
 error_free_sym:
  if (isymbuf != NULL)
    free (isymbuf);
 error_return:
  return FALSE;
}

/* Add symbols from an ELF archive file to the linker hash table.  We
   don't use _bfd_generic_link_add_archive_symbols because of a
   problem which arises on UnixWare.  The UnixWare libc.so is an
   archive which includes an entry libc.so.1 which defines a bunch of
   symbols.  The libc.so archive also includes a number of other
   object files, which also define symbols, some of which are the same
   as those defined in libc.so.1.  Correct linking requires that we
   consider each object file in turn, and include it if it defines any
   symbols we need.  _bfd_generic_link_add_archive_symbols does not do
   this; it looks through the list of undefined symbols, and includes
   any object file which defines them.  When this algorithm is used on
   UnixWare, it winds up pulling in libc.so.1 early and defining a
   bunch of symbols.  This means that some of the other objects in the
   archive are not included in the link, which is incorrect since they
   precede libc.so.1 in the archive.

   Fortunately, ELF archive handling is simpler than that done by
   _bfd_generic_link_add_archive_symbols, which has to allow for a.out
   oddities.  In ELF, if we find a symbol in the archive map, and the
   symbol is currently undefined, we know that we must pull in that
   object file.

   Unfortunately, we do have to make multiple passes over the symbol
   table until nothing further is resolved.  */

static bfd_boolean
elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
{
  symindex c;
  bfd_boolean *defined = NULL;
  bfd_boolean *included = NULL;
  carsym *symdefs;
  bfd_boolean loop;
  bfd_size_type amt;

  if (! bfd_has_map (abfd))
    {
      /* An empty archive is a special case.  */
      if (bfd_openr_next_archived_file (abfd, NULL) == NULL)
	return TRUE;
      bfd_set_error (bfd_error_no_armap);
      return FALSE;
    }

  /* Keep track of all symbols we know to be already defined, and all
     files we know to be already included.  This is to speed up the
     second and subsequent passes.  */
  c = bfd_ardata (abfd)->symdef_count;
  if (c == 0)
    return TRUE;
  amt = c;
  amt *= sizeof (bfd_boolean);
  defined = bfd_zmalloc (amt);
  included = bfd_zmalloc (amt);
  if (defined == NULL || included == NULL)
    goto error_return;

  symdefs = bfd_ardata (abfd)->symdefs;

  do
    {
      file_ptr last;
      symindex i;
      carsym *symdef;
      carsym *symdefend;

      loop = FALSE;
      last = -1;

      symdef = symdefs;
      symdefend = symdef + c;
      for (i = 0; symdef < symdefend; symdef++, i++)
	{
	  struct elf_link_hash_entry *h;
	  bfd *element;
	  struct bfd_link_hash_entry *undefs_tail;
	  symindex mark;

	  if (defined[i] || included[i])
	    continue;
	  if (symdef->file_offset == last)
	    {
	      included[i] = TRUE;
	      continue;
	    }

	  h = elf_link_hash_lookup (elf_hash_table (info), symdef->name,
				    FALSE, FALSE, FALSE);

	  if (h == NULL)
	    {
	      char *p, *copy;
	      size_t len, first;

	      /* If this is a default version (the name contains @@@@),
		 look up the symbol again with only one `@@' as well
		 as without the version.  The effect is that references
		 to the symbol with and without the version will be
		 matched by the default symbol in the archive.  */

	      p = strchr (symdef->name, ELF_VER_CHR);
	      if (p == NULL || p[1] != ELF_VER_CHR)
		continue;

	      /* First check with only one `@@'.  */
	      len = strlen (symdef->name);
	      copy = bfd_alloc (abfd, len);
	      if (copy == NULL)
		goto error_return;
	      first = p - symdef->name + 1;
	      memcpy (copy, symdef->name, first);
	      memcpy (copy + first, symdef->name + first + 1, len - first);

	      h = elf_link_hash_lookup (elf_hash_table (info), copy,
					FALSE, FALSE, FALSE);

	      if (h == NULL)
		{
		  /* We also need to check references to the symbol
		     without the version.  */

		  copy[first - 1] = '\0';
		  h = elf_link_hash_lookup (elf_hash_table (info),
					    copy, FALSE, FALSE, FALSE);
		}

	      bfd_release (abfd, copy);
	    }

	  if (h == NULL)
	    continue;

	  if (h->root.type == bfd_link_hash_common)
	    {
	      /* We currently have a common symbol.  The archive map contains
		 a reference to this symbol, so we may want to include it.  We
		 only want to include it however, if this archive element
		 contains a definition of the symbol, not just another common
		 declaration of it.

		 Unfortunately some archivers (including GNU ar) will put
		 declarations of common symbols into their archive maps, as
		 well as real definitions, so we cannot just go by the archive
		 map alone.  Instead we must read in the element's symbol
		 table and check that to see what kind of symbol definition
		 this is.  */
	      if (! elf_link_is_defined_archive_symbol (abfd, symdef))
		continue;
	    }
	  else if (h->root.type != bfd_link_hash_undefined)
	    {
	      if (h->root.type != bfd_link_hash_undefweak)
		defined[i] = TRUE;
	      continue;
	    }

	  /* We need to include this archive member.  */
	  element = _bfd_get_elt_at_filepos (abfd, symdef->file_offset);
	  if (element == NULL)
	    goto error_return;

	  if (! bfd_check_format (element, bfd_object))
	    goto error_return;

	  /* Doublecheck that we have not included this object
	     already--it should be impossible, but there may be
	     something wrong with the archive.  */
	  if (element->archive_pass != 0)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }
	  element->archive_pass = 1;

	  undefs_tail = info->hash->undefs_tail;

	  if (! (*info->callbacks->add_archive_element) (info, element,
							 symdef->name))
	    goto error_return;
	  if (! bfd_link_add_symbols (element, info))
	    goto error_return;

	  /* If there are any new undefined symbols, we need to make
	     another pass through the archive in order to see whether
	     they can be defined.  FIXME: This isn't perfect, because
	     common symbols wind up on undefs_tail and because an
	     undefined symbol which is defined later on in this pass
	     does not require another pass.  This isn't a bug, but it
	     does make the code less efficient than it could be.  */
	  if (undefs_tail != info->hash->undefs_tail)
	    loop = TRUE;

	  /* Look backward to mark all symbols from this object file
	     which we have already seen in this pass.  */
	  mark = i;
	  do
	    {
	      included[mark] = TRUE;
	      if (mark == 0)
		break;
	      --mark;
	    }
	  while (symdefs[mark].file_offset == symdef->file_offset);

	  /* We mark subsequent symbols from this object file as we go
	     on through the loop.  */
	  last = symdef->file_offset;
	}
    }
  while (loop);

  free (defined);
  free (included);

  return TRUE;

 error_return:
  if (defined != NULL)
    free (defined);
  if (included != NULL)
    free (included);
  return FALSE;
}

/* Given an ELF BFD, add symbols to the global hash table as
   appropriate.  */

bfd_boolean
bfd_elf_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return elf_link_add_object_symbols (abfd, info);
    case bfd_archive:
      return elf_link_add_archive_symbols (abfd, info);
    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}

/* This function will be called though elf_link_hash_traverse to store
   all hash value of the exported symbols in an array.  */

static bfd_boolean
elf_collect_hash_codes (struct elf_link_hash_entry *h, void *data)
{
  unsigned long **valuep = data;
  const char *name;
  char *p;
  unsigned long ha;
  char *alc = NULL;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->dynindx == -1)
    return TRUE;

  name = h->root.root.string;
  p = strchr (name, ELF_VER_CHR);
  if (p != NULL)
    {
      alc = bfd_malloc (p - name + 1);
      memcpy (alc, name, p - name);
      alc[p - name] = '\0';
      name = alc;
    }

  /* Compute the hash value.  */
  ha = bfd_elf_hash (name);

  /* Store the found hash value in the array given as the argument.  */
  *(*valuep)++ = ha;

  /* And store it in the struct so that we can put it in the hash table
     later.  */
  h->elf_hash_value = ha;

  if (alc != NULL)
    free (alc);

  return TRUE;
}

/* Array used to determine the number of hash table buckets to use
   based on the number of symbols there are.  If there are fewer than
   3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,
   fewer than 37 we use 17 buckets, and so forth.  We never use more
   than 32771 buckets.  */

static const size_t elf_buckets[] =
{
  1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209,
  16411, 32771, 0
};

/* Compute bucket count for hashing table.  We do not use a static set
   of possible tables sizes anymore.  Instead we determine for all
   possible reasonable sizes of the table the outcome (i.e., the
   number of collisions etc) and choose the best solution.  The
   weighting functions are not too simple to allow the table to grow
   without bounds.  Instead one of the weighting factors is the size.
   Therefore the result is always a good payoff between few collisions
   (= short chain lengths) and table size.  */
static size_t
compute_bucket_count (struct bfd_link_info *info)
{
  size_t dynsymcount = elf_hash_table (info)->dynsymcount;
  size_t best_size = 0;
  unsigned long int *hashcodes;
  unsigned long int *hashcodesp;
  unsigned long int i;
  bfd_size_type amt;

  /* Compute the hash values for all exported symbols.  At the same
     time store the values in an array so that we could use them for
     optimizations.  */
  amt = dynsymcount;
  amt *= sizeof (unsigned long int);
  hashcodes = bfd_malloc (amt);
  if (hashcodes == NULL)
    return 0;
  hashcodesp = hashcodes;

  /* Put all hash values in HASHCODES.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_collect_hash_codes, &hashcodesp);

  /* We have a problem here.  The following code to optimize the table
     size requires an integer type with more the 32 bits.  If
     BFD_HOST_U_64_BIT is set we know about such a type.  */
#ifdef BFD_HOST_U_64_BIT
  if (info->optimize)
    {
      unsigned long int nsyms = hashcodesp - hashcodes;
      size_t minsize;
      size_t maxsize;
      BFD_HOST_U_64_BIT best_chlen = ~((BFD_HOST_U_64_BIT) 0);
      unsigned long int *counts ;
      bfd *dynobj = elf_hash_table (info)->dynobj;
      const struct elf_backend_data *bed = get_elf_backend_data (dynobj);

      /* Possible optimization parameters: if we have NSYMS symbols we say
	 that the hashing table must at least have NSYMS/4 and at most
	 2*NSYMS buckets.  */
      minsize = nsyms / 4;
      if (minsize == 0)
	minsize = 1;
      best_size = maxsize = nsyms * 2;

      /* Create array where we count the collisions in.  We must use bfd_malloc
	 since the size could be large.  */
      amt = maxsize;
      amt *= sizeof (unsigned long int);
      counts = bfd_malloc (amt);
      if (counts == NULL)
	{
	  free (hashcodes);
	  return 0;
	}

      /* Compute the "optimal" size for the hash table.  The criteria is a
	 minimal chain length.  The minor criteria is (of course) the size
	 of the table.  */
      for (i = minsize; i < maxsize; ++i)
	{
	  /* Walk through the array of hashcodes and count the collisions.  */
	  BFD_HOST_U_64_BIT max;
	  unsigned long int j;
	  unsigned long int fact;

	  memset (counts, '\0', i * sizeof (unsigned long int));

	  /* Determine how often each hash bucket is used.  */
	  for (j = 0; j < nsyms; ++j)
	    ++counts[hashcodes[j] % i];

	  /* For the weight function we need some information about the
	     pagesize on the target.  This is information need not be 100%
	     accurate.  Since this information is not available (so far) we
	     define it here to a reasonable default value.  If it is crucial
	     to have a better value some day simply define this value.  */
# ifndef BFD_TARGET_PAGESIZE
#  define BFD_TARGET_PAGESIZE	(4096)
# endif

	  /* We in any case need 2 + NSYMS entries for the size values and
	     the chains.  */
	  max = (2 + nsyms) * (bed->s->arch_size / 8);

# if 1
	  /* Variant 1: optimize for short chains.  We add the squares
	     of all the chain lengths (which favors many small chain
	     over a few long chains).  */
	  for (j = 0; j < i; ++j)
	    max += counts[j] * counts[j];

	  /* This adds penalties for the overall size of the table.  */
	  fact = i / (BFD_TARGET_PAGESIZE / (bed->s->arch_size / 8)) + 1;
	  max *= fact * fact;
# else
	  /* Variant 2: Optimize a lot more for small table.  Here we
	     also add squares of the size but we also add penalties for
	     empty slots (the +1 term).  */
	  for (j = 0; j < i; ++j)
	    max += (1 + counts[j]) * (1 + counts[j]);

	  /* The overall size of the table is considered, but not as
	     strong as in variant 1, where it is squared.  */
	  fact = i / (BFD_TARGET_PAGESIZE / (bed->s->arch_size / 8)) + 1;
	  max *= fact;
# endif

	  /* Compare with current best results.  */
	  if (max < best_chlen)
	    {
	      best_chlen = max;
	      best_size = i;
	    }
	}

      free (counts);
    }
  else
#endif /* defined (BFD_HOST_U_64_BIT) */
    {
      /* This is the fallback solution if no 64bit type is available or if we
	 are not supposed to spend much time on optimizations.  We select the
	 bucket count using a fixed set of numbers.  */
      for (i = 0; elf_buckets[i] != 0; i++)
	{
	  best_size = elf_buckets[i];
	  if (dynsymcount < elf_buckets[i + 1])
	    break;
	}
    }

  /* Free the arrays we needed.  */
  free (hashcodes);

  return best_size;
}

/* Set up the sizes and contents of the ELF dynamic sections.  This is
   called by the ELF linker emulation before_allocation routine.  We
   must set the sizes of the sections before the linker sets the
   addresses of the various sections.  */

bfd_boolean
bfd_elf_size_dynamic_sections (bfd *output_bfd,
			       const char *soname,
			       const char *rpath,
			       const char *filter_shlib,
			       const char * const *auxiliary_filters,
			       struct bfd_link_info *info,
			       asection **sinterpptr,
			       struct bfd_elf_version_tree *verdefs)
{
  bfd_size_type soname_indx;
  bfd *dynobj;
  const struct elf_backend_data *bed;
  struct elf_assign_sym_version_info asvinfo;

  *sinterpptr = NULL;

  soname_indx = (bfd_size_type) -1;

  if (!is_elf_hash_table (info->hash))
    return TRUE;

  if (info->execstack)
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;
  else if (info->noexecstack)
    elf_tdata (output_bfd)->stack_flags = PF_R | PF_W;
  else
    {
      bfd *inputobj;
      asection *notesec = NULL;
      int exec = 0;

      for (inputobj = info->input_bfds;
	   inputobj;
	   inputobj = inputobj->link_next)
	{
	  asection *s;

	  if (inputobj->flags & DYNAMIC)
	    continue;
	  s = bfd_get_section_by_name (inputobj, ".note.GNU-stack");
	  if (s)
	    {
	      if (s->flags & SEC_CODE)
		exec = PF_X;
	      notesec = s;
	    }
	  else
	    exec = PF_X;
	}
      if (notesec)
	{
	  elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | exec;
	  if (exec && info->relocatable
	      && notesec->output_section != bfd_abs_section_ptr)
	    notesec->output_section->flags |= SEC_CODE;
	}
    }

  /* Any syms created from now on start with -1 in
     got.refcount/offset and plt.refcount/offset.  */
  elf_hash_table (info)->init_refcount = elf_hash_table (info)->init_offset;

  /* The backend may have to create some sections regardless of whether
     we're dynamic or not.  */
  bed = get_elf_backend_data (output_bfd);
  if (bed->elf_backend_always_size_sections
      && ! (*bed->elf_backend_always_size_sections) (output_bfd, info))
    return FALSE;

  dynobj = elf_hash_table (info)->dynobj;

  /* If there were no dynamic objects in the link, there is nothing to
     do here.  */
  if (dynobj == NULL)
    return TRUE;

  if (! _bfd_elf_maybe_strip_eh_frame_hdr (info))
    return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      struct elf_info_failed eif;
      struct elf_link_hash_entry *h;
      asection *dynstr;
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;
      bfd_boolean all_defined;

      *sinterpptr = bfd_get_section_by_name (dynobj, ".interp");
      BFD_ASSERT (*sinterpptr != NULL || !info->executable);

      if (soname != NULL)
	{
	  soname_indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					     soname, TRUE);
	  if (soname_indx == (bfd_size_type) -1
	      || !_bfd_elf_add_dynamic_entry (info, DT_SONAME, soname_indx))
	    return FALSE;
	}

      if (info->symbolic)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_SYMBOLIC, 0))
	    return FALSE;
	  info->flags |= DF_SYMBOLIC;
	}

      if (rpath != NULL)
	{
	  bfd_size_type indx;

	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, rpath,
				      TRUE);
	  if (indx == (bfd_size_type) -1
	      || !_bfd_elf_add_dynamic_entry (info, DT_RPATH, indx))
	    return FALSE;

	  if  (info->new_dtags)
	    {
	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr, indx);
	      if (!_bfd_elf_add_dynamic_entry (info, DT_RUNPATH, indx))
		return FALSE;
	    }
	}

      if (filter_shlib != NULL)
	{
	  bfd_size_type indx;

	  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
				      filter_shlib, TRUE);
	  if (indx == (bfd_size_type) -1
	      || !_bfd_elf_add_dynamic_entry (info, DT_FILTER, indx))
	    return FALSE;
	}

      if (auxiliary_filters != NULL)
	{
	  const char * const *p;

	  for (p = auxiliary_filters; *p != NULL; p++)
	    {
	      bfd_size_type indx;

	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					  *p, TRUE);
	      if (indx == (bfd_size_type) -1
		  || !_bfd_elf_add_dynamic_entry (info, DT_AUXILIARY, indx))
		return FALSE;
	    }
	}

      eif.info = info;
      eif.verdefs = verdefs;
      eif.failed = FALSE;

      /* If we are supposed to export all symbols into the dynamic symbol
	 table (this is not the normal case), then do so.  */
      if (info->export_dynamic)
	{
	  elf_link_hash_traverse (elf_hash_table (info),
				  _bfd_elf_export_symbol,
				  &eif);
	  if (eif.failed)
	    return FALSE;
	}

      /* Make all global versions with definition.  */
      for (t = verdefs; t != NULL; t = t->next)
	for (d = t->globals.list; d != NULL; d = d->next)
	  if (!d->symver && d->symbol)
	    {
	      const char *verstr, *name;
	      size_t namelen, verlen, newlen;
	      char *newname, *p;
	      struct elf_link_hash_entry *newh;

	      name = d->symbol;
	      namelen = strlen (name);
	      verstr = t->name;
	      verlen = strlen (verstr);
	      newlen = namelen + verlen + 3;

	      newname = bfd_malloc (newlen);
	      if (newname == NULL)
		return FALSE;
	      memcpy (newname, name, namelen);

	      /* Check the hidden versioned definition.  */
	      p = newname + namelen;
	      *p++ = ELF_VER_CHR;
	      memcpy (p, verstr, verlen + 1);
	      newh = elf_link_hash_lookup (elf_hash_table (info),
					   newname, FALSE, FALSE,
					   FALSE);
	      if (newh == NULL
		  || (newh->root.type != bfd_link_hash_defined
		      && newh->root.type != bfd_link_hash_defweak))
		{
		  /* Check the default versioned definition.  */
		  *p++ = ELF_VER_CHR;
		  memcpy (p, verstr, verlen + 1);
		  newh = elf_link_hash_lookup (elf_hash_table (info),
					       newname, FALSE, FALSE,
					       FALSE);
		}
	      free (newname);

	      /* Mark this version if there is a definition and it is
		 not defined in a shared object.  */
	      if (newh != NULL
		  && ((newh->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) == 0)
		  && (newh->root.type == bfd_link_hash_defined
		      || newh->root.type == bfd_link_hash_defweak))
		d->symver = 1;
	    }

      /* Attach all the symbols to their version information.  */
      asvinfo.output_bfd = output_bfd;
      asvinfo.info = info;
      asvinfo.verdefs = verdefs;
      asvinfo.failed = FALSE;

      elf_link_hash_traverse (elf_hash_table (info),
			      _bfd_elf_link_assign_sym_version,
			      &asvinfo);
      if (asvinfo.failed)
	return FALSE;

      if (!info->allow_undefined_version)
	{
	  /* Check if all global versions have a definition.  */
	  all_defined = TRUE;
	  for (t = verdefs; t != NULL; t = t->next)
	    for (d = t->globals.list; d != NULL; d = d->next)
	      if (!d->symver && !d->script)
		{
		  (*_bfd_error_handler)
		    (_("%s: undefined version: %s"),
		     d->pattern, t->name);
		  all_defined = FALSE;
		}

	  if (!all_defined)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}

      /* Find all symbols which were defined in a dynamic object and make
	 the backend pick a reasonable value for them.  */
      elf_link_hash_traverse (elf_hash_table (info),
			      _bfd_elf_adjust_dynamic_symbol,
			      &eif);
      if (eif.failed)
	return FALSE;

      /* Add some entries to the .dynamic section.  We fill in some of the
	 values later, in elf_bfd_final_link, but we must add the entries
	 now so that we know the final size of the .dynamic section.  */

      /* If there are initialization and/or finalization functions to
	 call then add the corresponding DT_INIT/DT_FINI entries.  */
      h = (info->init_function
	   ? elf_link_hash_lookup (elf_hash_table (info),
				   info->init_function, FALSE,
				   FALSE, FALSE)
	   : NULL);
      if (h != NULL
	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_INIT, 0))
	    return FALSE;
	}
      h = (info->fini_function
	   ? elf_link_hash_lookup (elf_hash_table (info),
				   info->fini_function, FALSE,
				   FALSE, FALSE)
	   : NULL);
      if (h != NULL
	  && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
					| ELF_LINK_HASH_DEF_REGULAR)) != 0)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FINI, 0))
	    return FALSE;
	}

      if (bfd_get_section_by_name (output_bfd, ".preinit_array") != NULL)
	{
	  /* DT_PREINIT_ARRAY is not allowed in shared library.  */
	  if (! info->executable)
	    {
	      bfd *sub;
	      asection *o;

	      for (sub = info->input_bfds; sub != NULL;
		   sub = sub->link_next)
		for (o = sub->sections; o != NULL; o = o->next)
		  if (elf_section_data (o)->this_hdr.sh_type
		      == SHT_PREINIT_ARRAY)
		    {
		      (*_bfd_error_handler)
			(_("%s: .preinit_array section is not allowed in DSO"),
			 bfd_archive_filename (sub));
		      break;
		    }

	      bfd_set_error (bfd_error_nonrepresentable_section);
	      return FALSE;
	    }

	  if (!_bfd_elf_add_dynamic_entry (info, DT_PREINIT_ARRAY, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_PREINIT_ARRAYSZ, 0))
	    return FALSE;
	}
      if (bfd_get_section_by_name (output_bfd, ".init_array") != NULL)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_INIT_ARRAY, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_INIT_ARRAYSZ, 0))
	    return FALSE;
	}
      if (bfd_get_section_by_name (output_bfd, ".fini_array") != NULL)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FINI_ARRAY, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_FINI_ARRAYSZ, 0))
	    return FALSE;
	}

      dynstr = bfd_get_section_by_name (dynobj, ".dynstr");
      /* If .dynstr is excluded from the link, we don't want any of
	 these tags.  Strictly, we should be checking each section
	 individually;  This quick check covers for the case where
	 someone does a /DISCARD/ : { *(*) }.  */
      if (dynstr != NULL && dynstr->output_section != bfd_abs_section_ptr)
	{
	  bfd_size_type strsize;

	  strsize = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
	  if (!_bfd_elf_add_dynamic_entry (info, DT_HASH, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_STRTAB, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_SYMTAB, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_STRSZ, strsize)
	      || !_bfd_elf_add_dynamic_entry (info, DT_SYMENT,
					      bed->s->sizeof_sym))
	    return FALSE;
	}
    }

  /* The backend must work out the sizes of all the other dynamic
     sections.  */
  if (bed->elf_backend_size_dynamic_sections
      && ! (*bed->elf_backend_size_dynamic_sections) (output_bfd, info))
    return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd_size_type dynsymcount;
      asection *s;
      size_t bucketcount = 0;
      size_t hash_entry_size;
      unsigned int dtagcount;

      /* Set up the version definition section.  */
      s = bfd_get_section_by_name (dynobj, ".gnu.version_d");
      BFD_ASSERT (s != NULL);

      /* We may have created additional version definitions if we are
	 just linking a regular application.  */
      verdefs = asvinfo.verdefs;

      /* Skip anonymous version tag.  */
      if (verdefs != NULL && verdefs->vernum == 0)
	verdefs = verdefs->next;

      if (verdefs == NULL)
	_bfd_strip_section_from_output (info, s);
      else
	{
	  unsigned int cdefs;
	  bfd_size_type size;
	  struct bfd_elf_version_tree *t;
	  bfd_byte *p;
	  Elf_Internal_Verdef def;
	  Elf_Internal_Verdaux defaux;

	  cdefs = 0;
	  size = 0;

	  /* Make space for the base version.  */
	  size += sizeof (Elf_External_Verdef);
	  size += sizeof (Elf_External_Verdaux);
	  ++cdefs;

	  for (t = verdefs; t != NULL; t = t->next)
	    {
	      struct bfd_elf_version_deps *n;

	      size += sizeof (Elf_External_Verdef);
	      size += sizeof (Elf_External_Verdaux);
	      ++cdefs;

	      for (n = t->deps; n != NULL; n = n->next)
		size += sizeof (Elf_External_Verdaux);
	    }

	  s->_raw_size = size;
	  s->contents = bfd_alloc (output_bfd, s->_raw_size);
	  if (s->contents == NULL && s->_raw_size != 0)
	    return FALSE;

	  /* Fill in the version definition section.  */

	  p = s->contents;

	  def.vd_version = VER_DEF_CURRENT;
	  def.vd_flags = VER_FLG_BASE;
	  def.vd_ndx = 1;
	  def.vd_cnt = 1;
	  def.vd_aux = sizeof (Elf_External_Verdef);
	  def.vd_next = (sizeof (Elf_External_Verdef)
			 + sizeof (Elf_External_Verdaux));

	  if (soname_indx != (bfd_size_type) -1)
	    {
	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
				      soname_indx);
	      def.vd_hash = bfd_elf_hash (soname);
	      defaux.vda_name = soname_indx;
	    }
	  else
	    {
	      const char *name;
	      bfd_size_type indx;

	      name = basename (output_bfd->filename);
	      def.vd_hash = bfd_elf_hash (name);
	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					  name, FALSE);
	      if (indx == (bfd_size_type) -1)
		return FALSE;
	      defaux.vda_name = indx;
	    }
	  defaux.vda_next = 0;

	  _bfd_elf_swap_verdef_out (output_bfd, &def,
				    (Elf_External_Verdef *) p);
	  p += sizeof (Elf_External_Verdef);
	  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
				     (Elf_External_Verdaux *) p);
	  p += sizeof (Elf_External_Verdaux);

	  for (t = verdefs; t != NULL; t = t->next)
	    {
	      unsigned int cdeps;
	      struct bfd_elf_version_deps *n;
	      struct elf_link_hash_entry *h;
	      struct bfd_link_hash_entry *bh;

	      cdeps = 0;
	      for (n = t->deps; n != NULL; n = n->next)
		++cdeps;

	      /* Add a symbol representing this version.  */
	      bh = NULL;
	      if (! (_bfd_generic_link_add_one_symbol
		     (info, dynobj, t->name, BSF_GLOBAL, bfd_abs_section_ptr,
		      0, NULL, FALSE,
		      get_elf_backend_data (dynobj)->collect, &bh)))
		return FALSE;
	      h = (struct elf_link_hash_entry *) bh;
	      h->elf_link_hash_flags &= ~ ELF_LINK_NON_ELF;
	      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	      h->type = STT_OBJECT;
	      h->verinfo.vertree = t;

	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;

	      def.vd_version = VER_DEF_CURRENT;
	      def.vd_flags = 0;
	      if (t->globals.list == NULL
		  && t->locals.list == NULL
		  && ! t->used)
		def.vd_flags |= VER_FLG_WEAK;
	      def.vd_ndx = t->vernum + 1;
	      def.vd_cnt = cdeps + 1;
	      def.vd_hash = bfd_elf_hash (t->name);
	      def.vd_aux = sizeof (Elf_External_Verdef);
	      def.vd_next = 0;
	      if (t->next != NULL)
		def.vd_next = (sizeof (Elf_External_Verdef)
			       + (cdeps + 1) * sizeof (Elf_External_Verdaux));

	      _bfd_elf_swap_verdef_out (output_bfd, &def,
					(Elf_External_Verdef *) p);
	      p += sizeof (Elf_External_Verdef);

	      defaux.vda_name = h->dynstr_index;
	      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
				      h->dynstr_index);
	      defaux.vda_next = 0;
	      if (t->deps != NULL)
		defaux.vda_next = sizeof (Elf_External_Verdaux);
	      t->name_indx = defaux.vda_name;

	      _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
					 (Elf_External_Verdaux *) p);
	      p += sizeof (Elf_External_Verdaux);

	      for (n = t->deps; n != NULL; n = n->next)
		{
		  if (n->version_needed == NULL)
		    {
		      /* This can happen if there was an error in the
			 version script.  */
		      defaux.vda_name = 0;
		    }
		  else
		    {
		      defaux.vda_name = n->version_needed->name_indx;
		      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
					      defaux.vda_name);
		    }
		  if (n->next == NULL)
		    defaux.vda_next = 0;
		  else
		    defaux.vda_next = sizeof (Elf_External_Verdaux);

		  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
					     (Elf_External_Verdaux *) p);
		  p += sizeof (Elf_External_Verdaux);
		}
	    }

	  if (!_bfd_elf_add_dynamic_entry (info, DT_VERDEF, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_VERDEFNUM, cdefs))
	    return FALSE;

	  elf_tdata (output_bfd)->cverdefs = cdefs;
	}

      if ((info->new_dtags && info->flags) || (info->flags & DF_STATIC_TLS))
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FLAGS, info->flags))
	    return FALSE;
	}
      else if (info->flags & DF_BIND_NOW)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_BIND_NOW, 0))
	    return FALSE;
	}

      if (info->flags_1)
	{
	  if (info->executable)
	    info->flags_1 &= ~ (DF_1_INITFIRST
				| DF_1_NODELETE
				| DF_1_NOOPEN);
	  if (!_bfd_elf_add_dynamic_entry (info, DT_FLAGS_1, info->flags_1))
	    return FALSE;
	}

      /* Work out the size of the version reference section.  */

      s = bfd_get_section_by_name (dynobj, ".gnu.version_r");
      BFD_ASSERT (s != NULL);
      {
	struct elf_find_verdep_info sinfo;

	sinfo.output_bfd = output_bfd;
	sinfo.info = info;
	sinfo.vers = elf_tdata (output_bfd)->cverdefs;
	if (sinfo.vers == 0)
	  sinfo.vers = 1;
	sinfo.failed = FALSE;

	elf_link_hash_traverse (elf_hash_table (info),
				_bfd_elf_link_find_version_dependencies,
				&sinfo);

	if (elf_tdata (output_bfd)->verref == NULL)
	  _bfd_strip_section_from_output (info, s);
	else
	  {
	    Elf_Internal_Verneed *t;
	    unsigned int size;
	    unsigned int crefs;
	    bfd_byte *p;

	    /* Build the version definition section.  */
	    size = 0;
	    crefs = 0;
	    for (t = elf_tdata (output_bfd)->verref;
		 t != NULL;
		 t = t->vn_nextref)
	      {
		Elf_Internal_Vernaux *a;

		size += sizeof (Elf_External_Verneed);
		++crefs;
		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  size += sizeof (Elf_External_Vernaux);
	      }

	    s->_raw_size = size;
	    s->contents = bfd_alloc (output_bfd, s->_raw_size);
	    if (s->contents == NULL)
	      return FALSE;

	    p = s->contents;
	    for (t = elf_tdata (output_bfd)->verref;
		 t != NULL;
		 t = t->vn_nextref)
	      {
		unsigned int caux;
		Elf_Internal_Vernaux *a;
		bfd_size_type indx;

		caux = 0;
		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  ++caux;

		t->vn_version = VER_NEED_CURRENT;
		t->vn_cnt = caux;
		indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
					    elf_dt_name (t->vn_bfd) != NULL
					    ? elf_dt_name (t->vn_bfd)
					    : basename (t->vn_bfd->filename),
					    FALSE);
		if (indx == (bfd_size_type) -1)
		  return FALSE;
		t->vn_file = indx;
		t->vn_aux = sizeof (Elf_External_Verneed);
		if (t->vn_nextref == NULL)
		  t->vn_next = 0;
		else
		  t->vn_next = (sizeof (Elf_External_Verneed)
				+ caux * sizeof (Elf_External_Vernaux));

		_bfd_elf_swap_verneed_out (output_bfd, t,
					   (Elf_External_Verneed *) p);
		p += sizeof (Elf_External_Verneed);

		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		  {
		    a->vna_hash = bfd_elf_hash (a->vna_nodename);
		    indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
						a->vna_nodename, FALSE);
		    if (indx == (bfd_size_type) -1)
		      return FALSE;
		    a->vna_name = indx;
		    if (a->vna_nextptr == NULL)
		      a->vna_next = 0;
		    else
		      a->vna_next = sizeof (Elf_External_Vernaux);

		    _bfd_elf_swap_vernaux_out (output_bfd, a,
					       (Elf_External_Vernaux *) p);
		    p += sizeof (Elf_External_Vernaux);
		  }
	      }

	    if (!_bfd_elf_add_dynamic_entry (info, DT_VERNEED, 0)
		|| !_bfd_elf_add_dynamic_entry (info, DT_VERNEEDNUM, crefs))
	      return FALSE;

	    elf_tdata (output_bfd)->cverrefs = crefs;
	  }
      }

      /* Assign dynsym indicies.  In a shared library we generate a
	 section symbol for each output section, which come first.
	 Next come all of the back-end allocated local dynamic syms,
	 followed by the rest of the global symbols.  */

      dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);

      /* Work out the size of the symbol version section.  */
      s = bfd_get_section_by_name (dynobj, ".gnu.version");
      BFD_ASSERT (s != NULL);
      if (dynsymcount == 0
	  || (verdefs == NULL && elf_tdata (output_bfd)->verref == NULL))
	{
	  _bfd_strip_section_from_output (info, s);
	  /* The DYNSYMCOUNT might have changed if we were going to
	     output a dynamic symbol table entry for S.  */
	  dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info);
	}
      else
	{
	  s->_raw_size = dynsymcount * sizeof (Elf_External_Versym);
	  s->contents = bfd_zalloc (output_bfd, s->_raw_size);
	  if (s->contents == NULL)
	    return FALSE;

	  if (!_bfd_elf_add_dynamic_entry (info, DT_VERSYM, 0))
	    return FALSE;
	}

      /* Set the size of the .dynsym and .hash sections.  We counted
	 the number of dynamic symbols in elf_link_add_object_symbols.
	 We will build the contents of .dynsym and .hash when we build
	 the final symbol table, because until then we do not know the
	 correct value to give the symbols.  We built the .dynstr
	 section as we went along in elf_link_add_object_symbols.  */
      s = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (s != NULL);
      s->_raw_size = dynsymcount * bed->s->sizeof_sym;
      s->contents = bfd_alloc (output_bfd, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	return FALSE;

      if (dynsymcount != 0)
	{
	  Elf_Internal_Sym isym;

	  /* The first entry in .dynsym is a dummy symbol.  */
	  isym.st_value = 0;
	  isym.st_size = 0;
	  isym.st_name = 0;
	  isym.st_info = 0;
	  isym.st_other = 0;
	  isym.st_shndx = 0;
	  bed->s->swap_symbol_out (output_bfd, &isym, s->contents, 0);
	}

      /* Compute the size of the hashing table.  As a side effect this
	 computes the hash values for all the names we export.  */
      bucketcount = compute_bucket_count (info);

      s = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (s != NULL);
      hash_entry_size = elf_section_data (s)->this_hdr.sh_entsize;
      s->_raw_size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
      s->contents = bfd_zalloc (output_bfd, s->_raw_size);
      if (s->contents == NULL)
	return FALSE;

      bfd_put (8 * hash_entry_size, output_bfd, bucketcount, s->contents);
      bfd_put (8 * hash_entry_size, output_bfd, dynsymcount,
	       s->contents + hash_entry_size);

      elf_hash_table (info)->bucketcount = bucketcount;

      s = bfd_get_section_by_name (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);

      elf_finalize_dynstr (output_bfd, info);

      s->_raw_size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);

      for (dtagcount = 0; dtagcount <= info->spare_dynamic_tags; ++dtagcount)
	if (!_bfd_elf_add_dynamic_entry (info, DT_NULL, 0))
	  return FALSE;
    }

  return TRUE;
}

/* Final phase of ELF linker.  */

/* A structure we use to avoid passing large numbers of arguments.  */

struct elf_final_link_info
{
  /* General link information.  */
  struct bfd_link_info *info;
  /* Output BFD.  */
  bfd *output_bfd;
  /* Symbol string table.  */
  struct bfd_strtab_hash *symstrtab;
  /* .dynsym section.  */
  asection *dynsym_sec;
  /* .hash section.  */
  asection *hash_sec;
  /* symbol version section (.gnu.version).  */
  asection *symver_sec;
  /* Buffer large enough to hold contents of any section.  */
  bfd_byte *contents;
  /* Buffer large enough to hold external relocs of any section.  */
  void *external_relocs;
  /* Buffer large enough to hold internal relocs of any section.  */
  Elf_Internal_Rela *internal_relocs;
  /* Buffer large enough to hold external local symbols of any input
     BFD.  */
  bfd_byte *external_syms;
  /* And a buffer for symbol section indices.  */
  Elf_External_Sym_Shndx *locsym_shndx;
  /* Buffer large enough to hold internal local symbols of any input
     BFD.  */
  Elf_Internal_Sym *internal_syms;
  /* Array large enough to hold a symbol index for each local symbol
     of any input BFD.  */
  long *indices;
  /* Array large enough to hold a section pointer for each local
     symbol of any input BFD.  */
  asection **sections;
  /* Buffer to hold swapped out symbols.  */
  bfd_byte *symbuf;
  /* And one for symbol section indices.  */
  Elf_External_Sym_Shndx *symshndxbuf;
  /* Number of swapped out symbols in buffer.  */
  size_t symbuf_count;
  /* Number of symbols which fit in symbuf.  */
  size_t symbuf_size;
  /* And same for symshndxbuf.  */
  size_t shndxbuf_size;
};

/* This struct is used to pass information to elf_link_output_extsym.  */

struct elf_outext_info
{
  bfd_boolean failed;
  bfd_boolean localsyms;
  struct elf_final_link_info *finfo;
};

/* When performing a relocatable link, the input relocations are
   preserved.  But, if they reference global symbols, the indices
   referenced must be updated.  Update all the relocations in
   REL_HDR (there are COUNT of them), using the data in REL_HASH.  */

static void
elf_link_adjust_relocs (bfd *abfd,
			Elf_Internal_Shdr *rel_hdr,
			unsigned int count,
			struct elf_link_hash_entry **rel_hash)
{
  unsigned int i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_byte *erela;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  bfd_vma r_type_mask;
  int r_sym_shift;

  if (rel_hdr->sh_entsize == bed->s->sizeof_rel)
    {
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
    }
  else if (rel_hdr->sh_entsize == bed->s->sizeof_rela)
    {
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  else
    abort ();

  if (bed->s->int_rels_per_ext_rel > MAX_INT_RELS_PER_EXT_REL)
    abort ();

  if (bed->s->arch_size == 32)
    {
      r_type_mask = 0xff;
      r_sym_shift = 8;
    }
  else
    {
      r_type_mask = 0xffffffff;
      r_sym_shift = 32;
    }

  erela = rel_hdr->contents;
  for (i = 0; i < count; i++, rel_hash++, erela += rel_hdr->sh_entsize)
    {
      Elf_Internal_Rela irela[MAX_INT_RELS_PER_EXT_REL];
      unsigned int j;

      if (*rel_hash == NULL)
	continue;

      BFD_ASSERT ((*rel_hash)->indx >= 0);

      (*swap_in) (abfd, erela, irela);
      for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
	irela[j].r_info = ((bfd_vma) (*rel_hash)->indx << r_sym_shift
			   | (irela[j].r_info & r_type_mask));
      (*swap_out) (abfd, irela, erela);
    }
}

struct elf_link_sort_rela
{
  union {
    bfd_vma offset;
    bfd_vma sym_mask;
  } u;
  enum elf_reloc_type_class type;
  /* We use this as an array of size int_rels_per_ext_rel.  */
  Elf_Internal_Rela rela[1];
};

static int
elf_link_sort_cmp1 (const void *A, const void *B)
{
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
  int relativea, relativeb;

  relativea = a->type == reloc_class_relative;
  relativeb = b->type == reloc_class_relative;

  if (relativea < relativeb)
    return 1;
  if (relativea > relativeb)
    return -1;
  if ((a->rela->r_info & a->u.sym_mask) < (b->rela->r_info & b->u.sym_mask))
    return -1;
  if ((a->rela->r_info & a->u.sym_mask) > (b->rela->r_info & b->u.sym_mask))
    return 1;
  if (a->rela->r_offset < b->rela->r_offset)
    return -1;
  if (a->rela->r_offset > b->rela->r_offset)
    return 1;
  return 0;
}

static int
elf_link_sort_cmp2 (const void *A, const void *B)
{
  const struct elf_link_sort_rela *a = A;
  const struct elf_link_sort_rela *b = B;
  int copya, copyb;

  if (a->u.offset < b->u.offset)
    return -1;
  if (a->u.offset > b->u.offset)
    return 1;
  copya = (a->type == reloc_class_copy) * 2 + (a->type == reloc_class_plt);
  copyb = (b->type == reloc_class_copy) * 2 + (b->type == reloc_class_plt);
  if (copya < copyb)
    return -1;
  if (copya > copyb)
    return 1;
  if (a->rela->r_offset < b->rela->r_offset)
    return -1;
  if (a->rela->r_offset > b->rela->r_offset)
    return 1;
  return 0;
}

static size_t
elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
{
  asection *reldyn;
  bfd_size_type count, size;
  size_t i, ret, sort_elt, ext_size;
  bfd_byte *sort, *s_non_relative, *p;
  struct elf_link_sort_rela *sq;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int i2e = bed->s->int_rels_per_ext_rel;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  struct bfd_link_order *lo;
  bfd_vma r_sym_mask;

  reldyn = bfd_get_section_by_name (abfd, ".rela.dyn");
  if (reldyn == NULL || reldyn->_raw_size == 0)
    {
      reldyn = bfd_get_section_by_name (abfd, ".rel.dyn");
      if (reldyn == NULL || reldyn->_raw_size == 0)
	return 0;
      ext_size = bed->s->sizeof_rel;
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
    }
  else
    {
      ext_size = bed->s->sizeof_rela;
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  count = reldyn->_raw_size / ext_size;

  size = 0;
  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	asection *o = lo->u.indirect.section;
	size += o->_raw_size;
      }

  if (size != reldyn->_raw_size)
    return 0;

  sort_elt = (sizeof (struct elf_link_sort_rela)
	      + (i2e - 1) * sizeof (Elf_Internal_Rela));
  sort = bfd_zmalloc (sort_elt * count);
  if (sort == NULL)
    {
      (*info->callbacks->warning)
	(info, _("Not enough memory to sort relocations"), 0, abfd, 0, 0);
      return 0;
    }

  if (bed->s->arch_size == 32)
    r_sym_mask = ~(bfd_vma) 0xff;
  else
    r_sym_mask = ~(bfd_vma) 0xffffffff;

  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	bfd_byte *erel, *erelend;
	asection *o = lo->u.indirect.section;

	erel = o->contents;
	erelend = o->contents + o->_raw_size;
	p = sort + o->output_offset / ext_size * sort_elt;
	while (erel < erelend)
	  {
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
	    (*swap_in) (abfd, erel, s->rela);
	    s->type = (*bed->elf_backend_reloc_type_class) (s->rela);
	    s->u.sym_mask = r_sym_mask;
	    p += sort_elt;
	    erel += ext_size;
	  }
      }

  qsort (sort, count, sort_elt, elf_link_sort_cmp1);

  for (i = 0, p = sort; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
      if (s->type != reloc_class_relative)
	break;
    }
  ret = i;
  s_non_relative = p;

  sq = (struct elf_link_sort_rela *) s_non_relative;
  for (; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *sp = (struct elf_link_sort_rela *) p;
      if (((sp->rela->r_info ^ sq->rela->r_info) & r_sym_mask) != 0)
	sq = sp;
      sp->u.offset = sq->rela->r_offset;
    }

  qsort (s_non_relative, count - ret, sort_elt, elf_link_sort_cmp2);

  for (lo = reldyn->link_order_head; lo != NULL; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
	bfd_byte *erel, *erelend;
	asection *o = lo->u.indirect.section;

	erel = o->contents;
	erelend = o->contents + o->_raw_size;
	p = sort + o->output_offset / ext_size * sort_elt;
	while (erel < erelend)
	  {
	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
	    (*swap_out) (abfd, s->rela, erel);
	    p += sort_elt;
	    erel += ext_size;
	  }
      }

  free (sort);
  *psec = reldyn;
  return ret;
}

/* Flush the output symbols to the file.  */

static bfd_boolean
elf_link_flush_output_syms (struct elf_final_link_info *finfo,
			    const struct elf_backend_data *bed)
{
  if (finfo->symbuf_count > 0)
    {
      Elf_Internal_Shdr *hdr;
      file_ptr pos;
      bfd_size_type amt;

      hdr = &elf_tdata (finfo->output_bfd)->symtab_hdr;
      pos = hdr->sh_offset + hdr->sh_size;
      amt = finfo->symbuf_count * bed->s->sizeof_sym;
      if (bfd_seek (finfo->output_bfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo->symbuf, amt, finfo->output_bfd) != amt)
	return FALSE;

      hdr->sh_size += amt;
      finfo->symbuf_count = 0;
    }

  return TRUE;
}

/* Add a symbol to the output symbol table.  */

static bfd_boolean
elf_link_output_sym (struct elf_final_link_info *finfo,
		     const char *name,
		     Elf_Internal_Sym *elfsym,
		     asection *input_sec,
		     struct elf_link_hash_entry *h)
{
  bfd_byte *dest;
  Elf_External_Sym_Shndx *destshndx;
  bfd_boolean (*output_symbol_hook)
    (struct bfd_link_info *, const char *, Elf_Internal_Sym *, asection *,
     struct elf_link_hash_entry *);
  const struct elf_backend_data *bed;

  bed = get_elf_backend_data (finfo->output_bfd);
  output_symbol_hook = bed->elf_backend_link_output_symbol_hook;
  if (output_symbol_hook != NULL)
    {
      if (! (*output_symbol_hook) (finfo->info, name, elfsym, input_sec, h))
	return FALSE;
    }

  if (name == NULL || *name == '\0')
    elfsym->st_name = 0;
  else if (input_sec->flags & SEC_EXCLUDE)
    elfsym->st_name = 0;
  else
    {
      elfsym->st_name = (unsigned long) _bfd_stringtab_add (finfo->symstrtab,
							    name, TRUE, FALSE);
      if (elfsym->st_name == (unsigned long) -1)
	return FALSE;
    }

  if (finfo->symbuf_count >= finfo->symbuf_size)
    {
      if (! elf_link_flush_output_syms (finfo, bed))
	return FALSE;
    }

  dest = finfo->symbuf + finfo->symbuf_count * bed->s->sizeof_sym;
  destshndx = finfo->symshndxbuf;
  if (destshndx != NULL)
    {
      if (bfd_get_symcount (finfo->output_bfd) >= finfo->shndxbuf_size)
	{
	  bfd_size_type amt;

	  amt = finfo->shndxbuf_size * sizeof (Elf_External_Sym_Shndx);
	  finfo->symshndxbuf = destshndx = bfd_realloc (destshndx, amt * 2);
	  if (destshndx == NULL)
	    return FALSE;
	  memset ((char *) destshndx + amt, 0, amt);
	  finfo->shndxbuf_size *= 2;
	}
      destshndx += bfd_get_symcount (finfo->output_bfd);
    }

  bed->s->swap_symbol_out (finfo->output_bfd, elfsym, dest, destshndx);
  finfo->symbuf_count += 1;
  bfd_get_symcount (finfo->output_bfd) += 1;

  return TRUE;
}

/* For DSOs loaded in via a DT_NEEDED entry, emulate ld.so in
   allowing an unsatisfied unversioned symbol in the DSO to match a
   versioned symbol that would normally require an explicit version.
   We also handle the case that a DSO references a hidden symbol
   which may be satisfied by a versioned symbol in another DSO.  */

static bfd_boolean
elf_link_check_versioned_symbol (struct bfd_link_info *info,
				 const struct elf_backend_data *bed,
				 struct elf_link_hash_entry *h)
{
  bfd *abfd;
  struct elf_link_loaded_list *loaded;

  if (!is_elf_hash_table (info->hash))
    return FALSE;

  switch (h->root.type)
    {
    default:
      abfd = NULL;
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      abfd = h->root.u.undef.abfd;
      if ((abfd->flags & DYNAMIC) == 0
	  || elf_dyn_lib_class (abfd) != DYN_DT_NEEDED)
	return FALSE;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      abfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      abfd = h->root.u.c.p->section->owner;
      break;
    }
  BFD_ASSERT (abfd != NULL);

  for (loaded = elf_hash_table (info)->loaded;
       loaded != NULL;
       loaded = loaded->next)
    {
      bfd *input;
      Elf_Internal_Shdr *hdr;
      bfd_size_type symcount;
      bfd_size_type extsymcount;
      bfd_size_type extsymoff;
      Elf_Internal_Shdr *versymhdr;
      Elf_Internal_Sym *isym;
      Elf_Internal_Sym *isymend;
      Elf_Internal_Sym *isymbuf;
      Elf_External_Versym *ever;
      Elf_External_Versym *extversym;

      input = loaded->abfd;

      /* We check each DSO for a possible hidden versioned definition.  */
      if (input == abfd
	  || (input->flags & DYNAMIC) == 0
	  || elf_dynversym (input) == 0)
	continue;

      hdr = &elf_tdata (input)->dynsymtab_hdr;

      symcount = hdr->sh_size / bed->s->sizeof_sym;
      if (elf_bad_symtab (input))
	{
	  extsymcount = symcount;
	  extsymoff = 0;
	}
      else
	{
	  extsymcount = symcount - hdr->sh_info;
	  extsymoff = hdr->sh_info;
	}

      if (extsymcount == 0)
	continue;

      isymbuf = bfd_elf_get_elf_syms (input, hdr, extsymcount, extsymoff,
				      NULL, NULL, NULL);
      if (isymbuf == NULL)
	return FALSE;

      /* Read in any version definitions.  */
      versymhdr = &elf_tdata (input)->dynversym_hdr;
      extversym = bfd_malloc (versymhdr->sh_size);
      if (extversym == NULL)
	goto error_ret;

      if (bfd_seek (input, versymhdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bread (extversym, versymhdr->sh_size, input)
	      != versymhdr->sh_size))
	{
	  free (extversym);
	error_ret:
	  free (isymbuf);
	  return FALSE;
	}

      ever = extversym + extsymoff;
      isymend = isymbuf + extsymcount;
      for (isym = isymbuf; isym < isymend; isym++, ever++)
	{
	  const char *name;
	  Elf_Internal_Versym iver;
	  unsigned short version_index;

	  if (ELF_ST_BIND (isym->st_info) == STB_LOCAL
	      || isym->st_shndx == SHN_UNDEF)
	    continue;

	  name = bfd_elf_string_from_elf_section (input,
						  hdr->sh_link,
						  isym->st_name);
	  if (strcmp (name, h->root.root.string) != 0)
	    continue;

	  _bfd_elf_swap_versym_in (input, ever, &iver);

	  if ((iver.vs_vers & VERSYM_HIDDEN) == 0)
	    {
	      /* If we have a non-hidden versioned sym, then it should
		 have provided a definition for the undefined sym.  */
	      abort ();
	    }

	  version_index = iver.vs_vers & VERSYM_VERSION;
	  if (version_index == 1 || version_index == 2)
	    {
	      /* This is the base or first version.  We can use it.  */
	      free (extversym);
	      free (isymbuf);
	      return TRUE;
	    }
	}

      free (extversym);
      free (isymbuf);
    }

  return FALSE;
}

/* Add an external symbol to the symbol table.  This is called from
   the hash table traversal routine.  When generating a shared object,
   we go through the symbol table twice.  The first time we output
   anything that might have been forced to local scope in a version
   script.  The second time we output the symbols that are still
   global symbols.  */

static bfd_boolean
elf_link_output_extsym (struct elf_link_hash_entry *h, void *data)
{
  struct elf_outext_info *eoinfo = data;
  struct elf_final_link_info *finfo = eoinfo->finfo;
  bfd_boolean strip;
  Elf_Internal_Sym sym;
  asection *input_sec;
  const struct elf_backend_data *bed;

  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
    }

  /* Decide whether to output this symbol in this pass.  */
  if (eoinfo->localsyms)
    {
      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	return TRUE;
    }
  else
    {
      if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
	return TRUE;
    }

  bed = get_elf_backend_data (finfo->output_bfd);

  /* If we have an undefined symbol reference here then it must have
     come from a shared library that is being linked in.  (Undefined
     references in regular files have already been handled).  If we
     are reporting errors for this situation then do so now.  */
  if (h->root.type == bfd_link_hash_undefined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
      && ! elf_link_check_versioned_symbol (finfo->info, bed, h)
      && finfo->info->unresolved_syms_in_shared_libs != RM_IGNORE)
    {
      if (! ((*finfo->info->callbacks->undefined_symbol)
	     (finfo->info, h->root.root.string, h->root.u.undef.abfd,
	      NULL, 0, finfo->info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)))
	{
	  eoinfo->failed = TRUE;
	  return FALSE;
	}
    }

  /* We should also warn if a forced local symbol is referenced from
     shared libraries.  */
  if (! finfo->info->relocatable
      && (! finfo->info->shared)
      && (h->elf_link_hash_flags
	  & (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC | ELF_LINK_DYNAMIC_DEF | ELF_LINK_DYNAMIC_WEAK))
	 == (ELF_LINK_FORCED_LOCAL | ELF_LINK_HASH_REF_DYNAMIC)
      && ! elf_link_check_versioned_symbol (finfo->info, bed, h))
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' in %s is referenced by DSO"),
	 bfd_get_filename (finfo->output_bfd),
	 ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	 ? "internal"
	 : ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	   ? "hidden" : "local",
	 h->root.root.string,
	 bfd_archive_filename (h->root.u.def.section->owner));
      eoinfo->failed = TRUE;
      return FALSE;
    }

  /* We don't want to output symbols that have never been mentioned by
     a regular file, or that we have been told to strip.  However, if
     h->indx is set to -2, the symbol is used by a reloc and we must
     output it.  */
  if (h->indx == -2)
    strip = FALSE;
  else if (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	    || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
    strip = TRUE;
  else if (finfo->info->strip == strip_all)
    strip = TRUE;
  else if (finfo->info->strip == strip_some
	   && bfd_hash_lookup (finfo->info->keep_hash,
			       h->root.root.string, FALSE, FALSE) == NULL)
    strip = TRUE;
  else if (finfo->info->strip_discarded
	   && (h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	   && elf_discarded_section (h->root.u.def.section))
    strip = TRUE;
  else
    strip = FALSE;

  /* If we're stripping it, and it's not a dynamic symbol, there's
     nothing else to do unless it is a forced local symbol.  */
  if (strip
      && h->dynindx == -1
      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
    return TRUE;

  sym.st_value = 0;
  sym.st_size = h->size;
  sym.st_other = h->other;
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    sym.st_info = ELF_ST_INFO (STB_LOCAL, h->type);
  else if (h->root.type == bfd_link_hash_undefweak
	   || h->root.type == bfd_link_hash_defweak)
    sym.st_info = ELF_ST_INFO (STB_WEAK, h->type);
  else
    sym.st_info = ELF_ST_INFO (STB_GLOBAL, h->type);

  switch (h->root.type)
    {
    default:
    case bfd_link_hash_new:
    case bfd_link_hash_warning:
      abort ();
      return FALSE;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      input_sec = bfd_und_section_ptr;
      sym.st_shndx = SHN_UNDEF;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
	input_sec = h->root.u.def.section;
	if (input_sec->output_section != NULL)
	  {
	    sym.st_shndx =
	      _bfd_elf_section_from_bfd_section (finfo->output_bfd,
						 input_sec->output_section);
	    if (sym.st_shndx == SHN_BAD)
	      {
		(*_bfd_error_handler)
		  (_("%s: could not find output section %s for input section %s"),
		   bfd_get_filename (finfo->output_bfd),
		   input_sec->output_section->name,
		   input_sec->name);
		eoinfo->failed = TRUE;
		return FALSE;
	      }

	    /* ELF symbols in relocatable files are section relative,
	       but in nonrelocatable files they are virtual
	       addresses.  */
	    sym.st_value = h->root.u.def.value + input_sec->output_offset;
	    if (! finfo->info->relocatable)
	      {
		sym.st_value += input_sec->output_section->vma;
		if (h->type == STT_TLS)
		  {
		    /* STT_TLS symbols are relative to PT_TLS segment
		       base.  */
		    BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
		    sym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
		  }
	      }
	  }
	else
	  {
	    BFD_ASSERT (input_sec->owner == NULL
			|| (input_sec->owner->flags & DYNAMIC) != 0);
	    sym.st_shndx = SHN_UNDEF;
	    input_sec = bfd_und_section_ptr;
	  }
      }
      break;

    case bfd_link_hash_common:
      input_sec = h->root.u.c.p->section;
      sym.st_shndx = SHN_COMMON;
      sym.st_value = 1 << h->root.u.c.p->alignment_power;
      break;

    case bfd_link_hash_indirect:
      /* These symbols are created by symbol versioning.  They point
	 to the decorated version of the name.  For example, if the
	 symbol foo@@@@GNU_1.2 is the default, which should be used when
	 foo is used with no version, then we add an indirect symbol
	 foo which points to foo@@@@GNU_1.2.  We ignore these symbols,
	 since the indirected symbol is already in the hash table.  */
      return TRUE;
    }

  /* Give the processor backend a chance to tweak the symbol value,
     and also to finish up anything that needs to be done for this
     symbol.  FIXME: Not calling elf_backend_finish_dynamic_symbol for
     forced local syms when non-shared is due to a historical quirk.  */
  if ((h->dynindx != -1
       || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
      && ((finfo->info->shared
	   && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak))
	  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
      && elf_hash_table (finfo->info)->dynamic_sections_created)
    {
      if (! ((*bed->elf_backend_finish_dynamic_symbol)
	     (finfo->output_bfd, finfo->info, h, &sym)))
	{
	  eoinfo->failed = TRUE;
	  return FALSE;
	}
    }

  /* If we are marking the symbol as undefined, and there are no
     non-weak references to this symbol from a regular object, then
     mark the symbol as weak undefined; if there are non-weak
     references, mark the symbol as strong.  We can't do this earlier,
     because it might not be marked as undefined until the
     finish_dynamic_symbol routine gets through with it.  */
  if (sym.st_shndx == SHN_UNDEF
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
      && (ELF_ST_BIND (sym.st_info) == STB_GLOBAL
	  || ELF_ST_BIND (sym.st_info) == STB_WEAK))
    {
      int bindtype;

      if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK) != 0)
	bindtype = STB_GLOBAL;
      else
	bindtype = STB_WEAK;
      sym.st_info = ELF_ST_INFO (bindtype, ELF_ST_TYPE (sym.st_info));
    }

  /* If a non-weak symbol with non-default visibility is not defined
     locally, it is a fatal error.  */
  if (! finfo->info->relocatable
      && ELF_ST_VISIBILITY (sym.st_other) != STV_DEFAULT
      && ELF_ST_BIND (sym.st_info) != STB_WEAK
      && h->root.type == bfd_link_hash_undefined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    {
      (*_bfd_error_handler)
	(_("%s: %s symbol `%s' isn't defined"),
	  bfd_get_filename (finfo->output_bfd),
	  ELF_ST_VISIBILITY (sym.st_other) == STV_PROTECTED
	  ? "protected"
	  : ELF_ST_VISIBILITY (sym.st_other) == STV_INTERNAL
	    ? "internal" : "hidden",
	  h->root.root.string);
      eoinfo->failed = TRUE;
      return FALSE;
    }

  /* If this symbol should be put in the .dynsym section, then put it
     there now.  We already know the symbol index.  We also fill in
     the entry in the .hash section.  */
  if (h->dynindx != -1
      && elf_hash_table (finfo->info)->dynamic_sections_created)
    {
      size_t bucketcount;
      size_t bucket;
      size_t hash_entry_size;
      bfd_byte *bucketpos;
      bfd_vma chain;
      bfd_byte *esym;

      sym.st_name = h->dynstr_index;
      esym = finfo->dynsym_sec->contents + h->dynindx * bed->s->sizeof_sym;
      bed->s->swap_symbol_out (finfo->output_bfd, &sym, esym, 0);

      bucketcount = elf_hash_table (finfo->info)->bucketcount;
      bucket = h->elf_hash_value % bucketcount;
      hash_entry_size
	= elf_section_data (finfo->hash_sec)->this_hdr.sh_entsize;
      bucketpos = ((bfd_byte *) finfo->hash_sec->contents
		   + (bucket + 2) * hash_entry_size);
      chain = bfd_get (8 * hash_entry_size, finfo->output_bfd, bucketpos);
      bfd_put (8 * hash_entry_size, finfo->output_bfd, h->dynindx, bucketpos);
      bfd_put (8 * hash_entry_size, finfo->output_bfd, chain,
	       ((bfd_byte *) finfo->hash_sec->contents
		+ (bucketcount + 2 + h->dynindx) * hash_entry_size));

      if (finfo->symver_sec != NULL && finfo->symver_sec->contents != NULL)
	{
	  Elf_Internal_Versym iversym;
	  Elf_External_Versym *eversym;

	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      if (h->verinfo.verdef == NULL)
		iversym.vs_vers = 0;
	      else
		iversym.vs_vers = h->verinfo.verdef->vd_exp_refno + 1;
	    }
	  else
	    {
	      if (h->verinfo.vertree == NULL)
		iversym.vs_vers = 1;
	      else
		iversym.vs_vers = h->verinfo.vertree->vernum + 1;
	    }

	  if ((h->elf_link_hash_flags & ELF_LINK_HIDDEN) != 0)
	    iversym.vs_vers |= VERSYM_HIDDEN;

	  eversym = (Elf_External_Versym *) finfo->symver_sec->contents;
	  eversym += h->dynindx;
	  _bfd_elf_swap_versym_out (finfo->output_bfd, &iversym, eversym);
	}
    }

  /* If we're stripping it, then it was just a dynamic symbol, and
     there's nothing else to do.  */
  if (strip || (input_sec->flags & SEC_EXCLUDE) != 0)
    return TRUE;

  h->indx = bfd_get_symcount (finfo->output_bfd);

  if (! elf_link_output_sym (finfo, h->root.root.string, &sym, input_sec, h))
    {
      eoinfo->failed = TRUE;
      return FALSE;
    }

  return TRUE;
}

static bfd_boolean
elf_section_ignore_discarded_relocs (asection *sec)
{
  const struct elf_backend_data *bed;

  switch (sec->sec_info_type)
    {
    case ELF_INFO_TYPE_STABS:
    case ELF_INFO_TYPE_EH_FRAME:
      return TRUE;
    default:
      break;
    }

  bed = get_elf_backend_data (sec->owner);
  if (bed->elf_backend_ignore_discarded_relocs != NULL
      && (*bed->elf_backend_ignore_discarded_relocs) (sec))
    return TRUE;

  return FALSE;
}

/* Link an input file into the linker output file.  This function
   handles all the sections and relocations of the input file at once.
   This is so that we only have to read the local symbols once, and
   don't have to keep them in memory.  */

static bfd_boolean
elf_link_input_bfd (struct elf_final_link_info *finfo, bfd *input_bfd)
{
  bfd_boolean (*relocate_section)
    (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
     Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
  bfd *output_bfd;
  Elf_Internal_Shdr *symtab_hdr;
  size_t locsymcount;
  size_t extsymoff;
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  long *pindex;
  asection **ppsection;
  asection *o;
  const struct elf_backend_data *bed;
  bfd_boolean emit_relocs;
  struct elf_link_hash_entry **sym_hashes;

  output_bfd = finfo->output_bfd;
  bed = get_elf_backend_data (output_bfd);
  relocate_section = bed->elf_backend_relocate_section;

  /* If this is a dynamic object, we don't want to do anything here:
     we don't want the local symbols, and we don't want the section
     contents.  */
  if ((input_bfd->flags & DYNAMIC) != 0)
    return TRUE;

  emit_relocs = (finfo->info->relocatable
		 || finfo->info->emitrelocations
		 || bed->elf_backend_emit_relocs);

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  if (elf_bad_symtab (input_bfd))
    {
      locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      extsymoff = 0;
    }
  else
    {
      locsymcount = symtab_hdr->sh_info;
      extsymoff = symtab_hdr->sh_info;
    }

  /* Read the local symbols.  */
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
  if (isymbuf == NULL && locsymcount != 0)
    {
      isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
				      finfo->internal_syms,
				      finfo->external_syms,
				      finfo->locsym_shndx);
      if (isymbuf == NULL)
	return FALSE;
    }

  /* Find local symbol sections and adjust values of symbols in
     SEC_MERGE sections.  Write out those local symbols we know are
     going into the output file.  */
  isymend = isymbuf + locsymcount;
  for (isym = isymbuf, pindex = finfo->indices, ppsection = finfo->sections;
       isym < isymend;
       isym++, pindex++, ppsection++)
    {
      asection *isec;
      const char *name;
      Elf_Internal_Sym osym;

      *pindex = -1;

      if (elf_bad_symtab (input_bfd))
	{
	  if (ELF_ST_BIND (isym->st_info) != STB_LOCAL)
	    {
	      *ppsection = NULL;
	      continue;
	    }
	}

      if (isym->st_shndx == SHN_UNDEF)
	isec = bfd_und_section_ptr;
      else if (isym->st_shndx < SHN_LORESERVE
	       || isym->st_shndx > SHN_HIRESERVE)
	{
	  isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);
	  if (isec
	      && isec->sec_info_type == ELF_INFO_TYPE_MERGE
	      && ELF_ST_TYPE (isym->st_info) != STT_SECTION)
	    isym->st_value =
	      _bfd_merged_section_offset (output_bfd, &isec,
					  elf_section_data (isec)->sec_info,
					  isym->st_value, 0);
	}
      else if (isym->st_shndx == SHN_ABS)
	isec = bfd_abs_section_ptr;
      else if (isym->st_shndx == SHN_COMMON)
	isec = bfd_com_section_ptr;
      else
	{
	  /* Who knows?  */
	  isec = NULL;
	}

      *ppsection = isec;

      /* Don't output the first, undefined, symbol.  */
      if (ppsection == finfo->sections)
	continue;

      if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
	{
	  /* We never output section symbols.  Instead, we use the
	     section symbol of the corresponding section in the output
	     file.  */
	  continue;
	}

      /* If we are stripping all symbols, we don't want to output this
	 one.  */
      if (finfo->info->strip == strip_all)
	continue;

      /* If we are discarding all local symbols, we don't want to
	 output this one.  If we are generating a relocatable output
	 file, then some of the local symbols may be required by
	 relocs; we output them below as we discover that they are
	 needed.  */
      if (finfo->info->discard == discard_all)
	continue;

      /* If this symbol is defined in a section which we are
	 discarding, we don't need to keep it, but note that
	 linker_mark is only reliable for sections that have contents.
	 For the benefit of the MIPS ELF linker, we check SEC_EXCLUDE
	 as well as linker_mark.  */
      if ((isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
	  && isec != NULL
	  && ((! isec->linker_mark && (isec->flags & SEC_HAS_CONTENTS) != 0)
	      || (! finfo->info->relocatable
		  && (isec->flags & SEC_EXCLUDE) != 0)))
	continue;

      /* Get the name of the symbol.  */
      name = bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link,
					      isym->st_name);
      if (name == NULL)
	return FALSE;

      /* See if we are discarding symbols with this name.  */
      if ((finfo->info->strip == strip_some
	   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE, FALSE)
	       == NULL))
	  || (((finfo->info->discard == discard_sec_merge
		&& (isec->flags & SEC_MERGE) && ! finfo->info->relocatable)
	       || finfo->info->discard == discard_l)
	      && bfd_is_local_label_name (input_bfd, name)))
	continue;

      /* If we get here, we are going to output this symbol.  */

      osym = *isym;

      /* Adjust the section index for the output file.  */
      osym.st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
							 isec->output_section);
      if (osym.st_shndx == SHN_BAD)
	return FALSE;

      *pindex = bfd_get_symcount (output_bfd);

      /* ELF symbols in relocatable files are section relative, but
	 in executable files they are virtual addresses.  Note that
	 this code assumes that all ELF sections have an associated
	 BFD section with a reasonable value for output_offset; below
	 we assume that they also have a reasonable value for
	 output_section.  Any special sections must be set up to meet
	 these requirements.  */
      osym.st_value += isec->output_offset;
      if (! finfo->info->relocatable)
	{
	  osym.st_value += isec->output_section->vma;
	  if (ELF_ST_TYPE (osym.st_info) == STT_TLS)
	    {
	      /* STT_TLS symbols are relative to PT_TLS segment base.  */
	      BFD_ASSERT (elf_hash_table (finfo->info)->tls_sec != NULL);
	      osym.st_value -= elf_hash_table (finfo->info)->tls_sec->vma;
	    }
	}

      if (! elf_link_output_sym (finfo, name, &osym, isec, NULL))
	return FALSE;
    }

  /* Relocate the contents of each section.  */
  sym_hashes = elf_sym_hashes (input_bfd);
  for (o = input_bfd->sections; o != NULL; o = o->next)
    {
      bfd_byte *contents;

      if (! o->linker_mark)
	{
	  /* This section was omitted from the link.  */
	  continue;
	}

      if ((o->flags & SEC_HAS_CONTENTS) == 0
	  || (o->_raw_size == 0 && (o->flags & SEC_RELOC) == 0))
	continue;

      if ((o->flags & SEC_LINKER_CREATED) != 0)
	{
	  /* Section was created by _bfd_elf_link_create_dynamic_sections
	     or somesuch.  */
	  continue;
	}

      /* Get the contents of the section.  They have been cached by a
	 relaxation routine.  Note that o is a section in an input
	 file, so the contents field will not have been set by any of
	 the routines which work on output files.  */
      if (elf_section_data (o)->this_hdr.contents != NULL)
	contents = elf_section_data (o)->this_hdr.contents;
      else
	{
	  contents = finfo->contents;
	  if (! bfd_get_section_contents (input_bfd, o, contents, 0,
					  o->_raw_size))
	    return FALSE;
	}

      if ((o->flags & SEC_RELOC) != 0)
	{
	  Elf_Internal_Rela *internal_relocs;
	  bfd_vma r_type_mask;
	  int r_sym_shift;

	  /* Get the swapped relocs.  */
	  internal_relocs
	    = _bfd_elf_link_read_relocs (input_bfd, o, finfo->external_relocs,
					 finfo->internal_relocs, FALSE);
	  if (internal_relocs == NULL
	      && o->reloc_count > 0)
	    return FALSE;

	  if (bed->s->arch_size == 32)
	    {
	      r_type_mask = 0xff;
	      r_sym_shift = 8;
	    }
	  else
	    {
	      r_type_mask = 0xffffffff;
	      r_sym_shift = 32;
	    }

	  /* Run through the relocs looking for any against symbols
	     from discarded sections and section symbols from
	     removed link-once sections.  Complain about relocs
	     against discarded sections.  Zero relocs against removed
	     link-once sections.  Preserve debug information as much
	     as we can.  */
	  if (!elf_section_ignore_discarded_relocs (o))
	    {
	      Elf_Internal_Rela *rel, *relend;

	      rel = internal_relocs;
	      relend = rel + o->reloc_count * bed->s->int_rels_per_ext_rel;
	      for ( ; rel < relend; rel++)
		{
		  unsigned long r_symndx = rel->r_info >> r_sym_shift;
		  asection *sec;

		  if (r_symndx >= locsymcount
		      || (elf_bad_symtab (input_bfd)
			  && finfo->sections[r_symndx] == NULL))
		    {
		      struct elf_link_hash_entry *h;

		      h = sym_hashes[r_symndx - extsymoff];
		      while (h->root.type == bfd_link_hash_indirect
			     || h->root.type == bfd_link_hash_warning)
			h = (struct elf_link_hash_entry *) h->root.u.i.link;

		      /* Complain if the definition comes from a
			 discarded section.  */
		      sec = h->root.u.def.section;
		      if ((h->root.type == bfd_link_hash_defined
			   || h->root.type == bfd_link_hash_defweak)
			  && elf_discarded_section (sec))
			{
			  if ((o->flags & SEC_DEBUGGING) != 0)
			    {
			      BFD_ASSERT (r_symndx != 0);
			      /* Try to preserve debug information.  */
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
				  && sec->_raw_size == sec->kept_section->_raw_size)
				h->root.u.def.section
				  = sec->kept_section;
			      else
				memset (rel, 0, sizeof (*rel));
			    }
			  else
			    finfo->info->callbacks->error_handler
			      (LD_DEFINITION_IN_DISCARDED_SECTION,
			       _("%T: discarded in section `%s' from %s\n"),
			       h->root.root.string,
			       h->root.root.string,
			       h->root.u.def.section->name,
			       bfd_archive_filename (h->root.u.def.section->owner));
			}
		    }
		  else
		    {
		      sec = finfo->sections[r_symndx];

		      if (sec != NULL && elf_discarded_section (sec))
			{
			  if ((o->flags & SEC_DEBUGGING) != 0
			      || (sec->flags & SEC_LINK_ONCE) != 0)
			    {
			      BFD_ASSERT (r_symndx != 0);
			      /* Try to preserve debug information.  */
			      if ((o->flags & SEC_DEBUGGING) != 0
				  && sec->kept_section != NULL
				  && sec->_raw_size == sec->kept_section->_raw_size)
				finfo->sections[r_symndx]
				  = sec->kept_section;
			      else
				{
				  rel->r_info &= r_type_mask;
				  rel->r_addend = 0;
				}
			    }
			  else
			    {
			      static int count;
			      int ok;
			      char *buf;

			      ok = asprintf (&buf, "local symbol %d",
					     count++);
			      if (ok <= 0)
				buf = (char *) "local symbol";
			      finfo->info->callbacks->error_handler
				(LD_DEFINITION_IN_DISCARDED_SECTION,
				 _("%T: discarded in section `%s' from %s\n"),
				 buf, buf, sec->name,
				 bfd_archive_filename (input_bfd));
			      if (ok != -1)
				free (buf);
			    }
			}
		    }
		}
	    }

	  /* Relocate the section by invoking a back end routine.

	     The back end routine is responsible for adjusting the
	     section contents as necessary, and (if using Rela relocs
	     and generating a relocatable output file) adjusting the
	     reloc addend as necessary.

	     The back end routine does not have to worry about setting
	     the reloc address or the reloc symbol index.

	     The back end routine is given a pointer to the swapped in
	     internal symbols, and can access the hash table entries
	     for the external symbols via elf_sym_hashes (input_bfd).

	     When generating relocatable output, the back end routine
	     must handle STB_LOCAL/STT_SECTION symbols specially.  The
	     output symbol is going to be a section symbol
	     corresponding to the output section, which will require
	     the addend to be adjusted.  */

	  if (! (*relocate_section) (output_bfd, finfo->info,
				     input_bfd, o, contents,
				     internal_relocs,
				     isymbuf,
				     finfo->sections))
	    return FALSE;

	  if (emit_relocs)
	    {
	      Elf_Internal_Rela *irela;
	      Elf_Internal_Rela *irelaend;
	      bfd_vma last_offset;
	      struct elf_link_hash_entry **rel_hash;
	      Elf_Internal_Shdr *input_rel_hdr, *input_rel_hdr2;
	      unsigned int next_erel;
	      bfd_boolean (*reloc_emitter)
		(bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *);
	      bfd_boolean rela_normal;

	      input_rel_hdr = &elf_section_data (o)->rel_hdr;
	      rela_normal = (bed->rela_normal
			     && (input_rel_hdr->sh_entsize
				 == bed->s->sizeof_rela));

	      /* Adjust the reloc addresses and symbol indices.  */

	      irela = internal_relocs;
	      irelaend = irela + o->reloc_count * bed->s->int_rels_per_ext_rel;
	      rel_hash = (elf_section_data (o->output_section)->rel_hashes
			  + elf_section_data (o->output_section)->rel_count
			  + elf_section_data (o->output_section)->rel_count2);
	      last_offset = o->output_offset;
	      if (!finfo->info->relocatable)
		last_offset += o->output_section->vma;
	      for (next_erel = 0; irela < irelaend; irela++, next_erel++)
		{
		  unsigned long r_symndx;
		  asection *sec;
		  Elf_Internal_Sym sym;

		  if (next_erel == bed->s->int_rels_per_ext_rel)
		    {
		      rel_hash++;
		      next_erel = 0;
		    }

		  irela->r_offset = _bfd_elf_section_offset (output_bfd,
							     finfo->info, o,
							     irela->r_offset);
		  if (irela->r_offset >= (bfd_vma) -2)
		    {
		      /* This is a reloc for a deleted entry or somesuch.
			 Turn it into an R_*_NONE reloc, at the same
			 offset as the last reloc.  elf_eh_frame.c and
			 elf_bfd_discard_info rely on reloc offsets
			 being ordered.  */
		      irela->r_offset = last_offset;
		      irela->r_info = 0;
		      irela->r_addend = 0;
		      continue;
		    }

		  irela->r_offset += o->output_offset;

		  /* Relocs in an executable have to be virtual addresses.  */
		  if (!finfo->info->relocatable)
		    irela->r_offset += o->output_section->vma;

		  last_offset = irela->r_offset;

		  r_symndx = irela->r_info >> r_sym_shift;
		  if (r_symndx == STN_UNDEF)
		    continue;

		  if (r_symndx >= locsymcount
		      || (elf_bad_symtab (input_bfd)
			  && finfo->sections[r_symndx] == NULL))
		    {
		      struct elf_link_hash_entry *rh;
		      unsigned long indx;

		      /* This is a reloc against a global symbol.  We
			 have not yet output all the local symbols, so
			 we do not know the symbol index of any global
			 symbol.  We set the rel_hash entry for this
			 reloc to point to the global hash table entry
			 for this symbol.  The symbol index is then
			 set at the end of elf_bfd_final_link.  */
		      indx = r_symndx - extsymoff;
		      rh = elf_sym_hashes (input_bfd)[indx];
		      while (rh->root.type == bfd_link_hash_indirect
			     || rh->root.type == bfd_link_hash_warning)
			rh = (struct elf_link_hash_entry *) rh->root.u.i.link;

		      /* Setting the index to -2 tells
			 elf_link_output_extsym that this symbol is
			 used by a reloc.  */
		      BFD_ASSERT (rh->indx < 0);
		      rh->indx = -2;

		      *rel_hash = rh;

		      continue;
		    }

		  /* This is a reloc against a local symbol.  */

		  *rel_hash = NULL;
		  sym = isymbuf[r_symndx];
		  sec = finfo->sections[r_symndx];
		  if (ELF_ST_TYPE (sym.st_info) == STT_SECTION)
		    {
		      /* I suppose the backend ought to fill in the
			 section of any STT_SECTION symbol against a
			 processor specific section.  If we have
			 discarded a section, the output_section will
			 be the absolute section.  */
		      if (bfd_is_abs_section (sec)
			  || (sec != NULL
			      && bfd_is_abs_section (sec->output_section)))
			r_symndx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  r_symndx = sec->output_section->target_index;
			  BFD_ASSERT (r_symndx != 0);
			}

		      /* Adjust the addend according to where the
			 section winds up in the output section.  */
		      if (rela_normal)
			irela->r_addend += sec->output_offset;
		    }
		  else
		    {
		      if (finfo->indices[r_symndx] == -1)
			{
			  unsigned long shlink;
			  const char *name;
			  asection *osec;

			  if (finfo->info->strip == strip_all)
			    {
			      /* You can't do ld -r -s.  */
			      bfd_set_error (bfd_error_invalid_operation);
			      return FALSE;
			    }

			  /* This symbol was skipped earlier, but
			     since it is needed by a reloc, we
			     must output it now.  */
			  shlink = symtab_hdr->sh_link;
			  name = (bfd_elf_string_from_elf_section
				  (input_bfd, shlink, sym.st_name));
			  if (name == NULL)
			    return FALSE;

			  osec = sec->output_section;
			  sym.st_shndx =
			    _bfd_elf_section_from_bfd_section (output_bfd,
							       osec);
			  if (sym.st_shndx == SHN_BAD)
			    return FALSE;

			  sym.st_value += sec->output_offset;
			  if (! finfo->info->relocatable)
			    {
			      sym.st_value += osec->vma;
			      if (ELF_ST_TYPE (sym.st_info) == STT_TLS)
				{
				  /* STT_TLS symbols are relative to PT_TLS
				     segment base.  */
				  BFD_ASSERT (elf_hash_table (finfo->info)
					      ->tls_sec != NULL);
				  sym.st_value -= (elf_hash_table (finfo->info)
						   ->tls_sec->vma);
				}
			    }

			  finfo->indices[r_symndx]
			    = bfd_get_symcount (output_bfd);

			  if (! elf_link_output_sym (finfo, name, &sym, sec,
						     NULL))
			    return FALSE;
			}

		      r_symndx = finfo->indices[r_symndx];
		    }

		  irela->r_info = ((bfd_vma) r_symndx << r_sym_shift
				   | (irela->r_info & r_type_mask));
		}

	      /* Swap out the relocs.  */
	      if (bed->elf_backend_emit_relocs
		  && !(finfo->info->relocatable
		       || finfo->info->emitrelocations))
		reloc_emitter = bed->elf_backend_emit_relocs;
	      else
		reloc_emitter = _bfd_elf_link_output_relocs;

	      if (input_rel_hdr->sh_size != 0
		  && ! (*reloc_emitter) (output_bfd, o, input_rel_hdr,
					 internal_relocs))
		return FALSE;

	      input_rel_hdr2 = elf_section_data (o)->rel_hdr2;
	      if (input_rel_hdr2 && input_rel_hdr2->sh_size != 0)
		{
		  internal_relocs += (NUM_SHDR_ENTRIES (input_rel_hdr)
				      * bed->s->int_rels_per_ext_rel);
		  if (! (*reloc_emitter) (output_bfd, o, input_rel_hdr2,
					  internal_relocs))
		    return FALSE;
		}
	    }
	}

      /* Write out the modified section contents.  */
      if (bed->elf_backend_write_section
	  && (*bed->elf_backend_write_section) (output_bfd, o, contents))
	{
	  /* Section written out.  */
	}
      else switch (o->sec_info_type)
	{
	case ELF_INFO_TYPE_STABS:
	  if (! (_bfd_write_section_stabs
		 (output_bfd,
		  &elf_hash_table (finfo->info)->stab_info,
		  o, &elf_section_data (o)->sec_info, contents)))
	    return FALSE;
	  break;
	case ELF_INFO_TYPE_MERGE:
	  if (! _bfd_write_merged_section (output_bfd, o,
					   elf_section_data (o)->sec_info))
	    return FALSE;
	  break;
	case ELF_INFO_TYPE_EH_FRAME:
	  {
	    if (! _bfd_elf_write_section_eh_frame (output_bfd, finfo->info,
						   o, contents))
	      return FALSE;
	  }
	  break;
	default:
	  {
	    bfd_size_type sec_size;

	    sec_size = (o->_cooked_size != 0 ? o->_cooked_size : o->_raw_size);
	    if (! (o->flags & SEC_EXCLUDE)
		&& ! bfd_set_section_contents (output_bfd, o->output_section,
					       contents,
					       (file_ptr) o->output_offset,
					       sec_size))
	      return FALSE;
	  }
	  break;
	}
    }

  return TRUE;
}

/* Generate a reloc when linking an ELF file.  This is a reloc
   requested by the linker, and does come from any input file.  This
   is used to build constructor and destructor tables when linking
   with -Ur.  */

static bfd_boolean
elf_reloc_link_order (bfd *output_bfd,
		      struct bfd_link_info *info,
		      asection *output_section,
		      struct bfd_link_order *link_order)
{
  reloc_howto_type *howto;
  long indx;
  bfd_vma offset;
  bfd_vma addend;
  struct elf_link_hash_entry **rel_hash_ptr;
  Elf_Internal_Shdr *rel_hdr;
  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
  Elf_Internal_Rela irel[MAX_INT_RELS_PER_EXT_REL];
  bfd_byte *erel;
  unsigned int i;

  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
  if (howto == NULL)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  addend = link_order->u.reloc.p->addend;

  /* Figure out the symbol index.  */
  rel_hash_ptr = (elf_section_data (output_section)->rel_hashes
		  + elf_section_data (output_section)->rel_count
		  + elf_section_data (output_section)->rel_count2);
  if (link_order->type == bfd_section_reloc_link_order)
    {
      indx = link_order->u.reloc.p->u.section->target_index;
      BFD_ASSERT (indx != 0);
      *rel_hash_ptr = NULL;
    }
  else
    {
      struct elf_link_hash_entry *h;

      /* Treat a reloc against a defined symbol as though it were
	 actually against the section.  */
      h = ((struct elf_link_hash_entry *)
	   bfd_wrapped_link_hash_lookup (output_bfd, info,
					 link_order->u.reloc.p->u.name,
					 FALSE, FALSE, TRUE));
      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak))
	{
	  asection *section;

	  section = h->root.u.def.section;
	  indx = section->output_section->target_index;
	  *rel_hash_ptr = NULL;
	  /* It seems that we ought to add the symbol value to the
	     addend here, but in practice it has already been added
	     because it was passed to constructor_callback.  */
	  addend += section->output_section->vma + section->output_offset;
	}
      else if (h != NULL)
	{
	  /* Setting the index to -2 tells elf_link_output_extsym that
	     this symbol is used by a reloc.  */
	  h->indx = -2;
	  *rel_hash_ptr = h;
	  indx = 0;
	}
      else
	{
	  if (! ((*info->callbacks->unattached_reloc)
		 (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))
	    return FALSE;
	  indx = 0;
	}
    }

  /* If this is an inplace reloc, we must write the addend into the
     object file.  */
  if (howto->partial_inplace && addend != 0)
    {
      bfd_size_type size;
      bfd_reloc_status_type rstat;
      bfd_byte *buf;
      bfd_boolean ok;
      const char *sym_name;

      size = bfd_get_reloc_size (howto);
      buf = bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;
      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);
      switch (rstat)
	{
	case bfd_reloc_ok:
	  break;

	default:
	case bfd_reloc_outofrange:
	  abort ();

	case bfd_reloc_overflow:
	  if (link_order->type == bfd_section_reloc_link_order)
	    sym_name = bfd_section_name (output_bfd,
					 link_order->u.reloc.p->u.section);
	  else
	    sym_name = link_order->u.reloc.p->u.name;
	  if (! ((*info->callbacks->reloc_overflow)
		 (info, sym_name, howto->name, addend, NULL, NULL, 0)))
	    {
	      free (buf);
	      return FALSE;
	    }
	  break;
	}
      ok = bfd_set_section_contents (output_bfd, output_section, buf,
				     link_order->offset, size);
      free (buf);
      if (! ok)
	return FALSE;
    }

  /* The address of a reloc is relative to the section in a
     relocatable file, and is a virtual address in an executable
     file.  */
  offset = link_order->offset;
  if (! info->relocatable)
    offset += output_section->vma;

  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
    {
      irel[i].r_offset = offset;
      irel[i].r_info = 0;
      irel[i].r_addend = 0;
    }
  if (bed->s->arch_size == 32)
    irel[0].r_info = ELF32_R_INFO (indx, howto->type);
  else
    irel[0].r_info = ELF64_R_INFO (indx, howto->type);

  rel_hdr = &elf_section_data (output_section)->rel_hdr;
  erel = rel_hdr->contents;
  if (rel_hdr->sh_type == SHT_REL)
    {
      erel += (elf_section_data (output_section)->rel_count
	       * bed->s->sizeof_rel);
      (*bed->s->swap_reloc_out) (output_bfd, irel, erel);
    }
  else
    {
      irel[0].r_addend = addend;
      erel += (elf_section_data (output_section)->rel_count
	       * bed->s->sizeof_rela);
      (*bed->s->swap_reloca_out) (output_bfd, irel, erel);
    }

  ++elf_section_data (output_section)->rel_count;

  return TRUE;
}

/* Do the final step of an ELF link.  */

bfd_boolean
bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean dynamic;
  bfd_boolean emit_relocs;
  bfd *dynobj;
  struct elf_final_link_info finfo;
  register asection *o;
  register struct bfd_link_order *p;
  register bfd *sub;
  bfd_size_type max_contents_size;
  bfd_size_type max_external_reloc_size;
  bfd_size_type max_internal_reloc_count;
  bfd_size_type max_sym_count;
  bfd_size_type max_sym_shndx_count;
  file_ptr off;
  Elf_Internal_Sym elfsym;
  unsigned int i;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *symtab_shndx_hdr;
  Elf_Internal_Shdr *symstrtab_hdr;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct elf_outext_info eoinfo;
  bfd_boolean merged;
  size_t relativecount = 0;
  asection *reldyn = 0;
  bfd_size_type amt;

  if (! is_elf_hash_table (info->hash))
    return FALSE;

  if (info->shared)
    abfd->flags |= DYNAMIC;

  dynamic = elf_hash_table (info)->dynamic_sections_created;
  dynobj = elf_hash_table (info)->dynobj;

  emit_relocs = (info->relocatable
		 || info->emitrelocations
		 || bed->elf_backend_emit_relocs);

  finfo.info = info;
  finfo.output_bfd = abfd;
  finfo.symstrtab = _bfd_elf_stringtab_init ();
  if (finfo.symstrtab == NULL)
    return FALSE;

  if (! dynamic)
    {
      finfo.dynsym_sec = NULL;
      finfo.hash_sec = NULL;
      finfo.symver_sec = NULL;
    }
  else
    {
      finfo.dynsym_sec = bfd_get_section_by_name (dynobj, ".dynsym");
      finfo.hash_sec = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (finfo.dynsym_sec != NULL && finfo.hash_sec != NULL);
      finfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
      /* Note that it is OK if symver_sec is NULL.  */
    }

  finfo.contents = NULL;
  finfo.external_relocs = NULL;
  finfo.internal_relocs = NULL;
  finfo.external_syms = NULL;
  finfo.locsym_shndx = NULL;
  finfo.internal_syms = NULL;
  finfo.indices = NULL;
  finfo.sections = NULL;
  finfo.symbuf = NULL;
  finfo.symshndxbuf = NULL;
  finfo.symbuf_count = 0;
  finfo.shndxbuf_size = 0;

  /* Count up the number of relocations we will output for each output
     section, so that we know the sizes of the reloc sections.  We
     also figure out some maximum sizes.  */
  max_contents_size = 0;
  max_external_reloc_size = 0;
  max_internal_reloc_count = 0;
  max_sym_count = 0;
  max_sym_shndx_count = 0;
  merged = FALSE;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct bfd_elf_section_data *esdo = elf_section_data (o);
      o->reloc_count = 0;

      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  unsigned int reloc_count = 0;
	  struct bfd_elf_section_data *esdi = NULL;
	  unsigned int *rel_count1;

	  if (p->type == bfd_section_reloc_link_order
	      || p->type == bfd_symbol_reloc_link_order)
	    reloc_count = 1;
	  else if (p->type == bfd_indirect_link_order)
	    {
	      asection *sec;

	      sec = p->u.indirect.section;
	      esdi = elf_section_data (sec);

	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = TRUE;

	      if (sec->flags & SEC_MERGE)
		merged = TRUE;

	      if (info->relocatable || info->emitrelocations)
		reloc_count = sec->reloc_count;
	      else if (bed->elf_backend_count_relocs)
		{
		  Elf_Internal_Rela * relocs;

		  relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
						      info->keep_memory);

		  reloc_count = (*bed->elf_backend_count_relocs) (sec, relocs);

		  if (elf_section_data (o)->relocs != relocs)
		    free (relocs);
		}

	      if (sec->_raw_size > max_contents_size)
		max_contents_size = sec->_raw_size;
	      if (sec->_cooked_size > max_contents_size)
		max_contents_size = sec->_cooked_size;

	      /* We are interested in just local symbols, not all
		 symbols.  */
	      if (bfd_get_flavour (sec->owner) == bfd_target_elf_flavour
		  && (sec->owner->flags & DYNAMIC) == 0)
		{
		  size_t sym_count;

		  if (elf_bad_symtab (sec->owner))
		    sym_count = (elf_tdata (sec->owner)->symtab_hdr.sh_size
				 / bed->s->sizeof_sym);
		  else
		    sym_count = elf_tdata (sec->owner)->symtab_hdr.sh_info;

		  if (sym_count > max_sym_count)
		    max_sym_count = sym_count;

		  if (sym_count > max_sym_shndx_count
		      && elf_symtab_shndx (sec->owner) != 0)
		    max_sym_shndx_count = sym_count;

		  if ((sec->flags & SEC_RELOC) != 0)
		    {
		      size_t ext_size;

		      ext_size = elf_section_data (sec)->rel_hdr.sh_size;
		      if (ext_size > max_external_reloc_size)
			max_external_reloc_size = ext_size;
		      if (sec->reloc_count > max_internal_reloc_count)
			max_internal_reloc_count = sec->reloc_count;
		    }
		}
	    }

	  if (reloc_count == 0)
	    continue;

	  o->reloc_count += reloc_count;

	  /* MIPS may have a mix of REL and RELA relocs on sections.
	     To support this curious ABI we keep reloc counts in
	     elf_section_data too.  We must be careful to add the
	     relocations from the input section to the right output
	     count.  FIXME: Get rid of one count.  We have
	     o->reloc_count == esdo->rel_count + esdo->rel_count2.  */
	  rel_count1 = &esdo->rel_count;
	  if (esdi != NULL)
	    {
	      bfd_boolean same_size;
	      bfd_size_type entsize1;

	      entsize1 = esdi->rel_hdr.sh_entsize;
	      BFD_ASSERT (entsize1 == bed->s->sizeof_rel
			  || entsize1 == bed->s->sizeof_rela);
	      same_size = !o->use_rela_p == (entsize1 == bed->s->sizeof_rel);

	      if (!same_size)
		rel_count1 = &esdo->rel_count2;

	      if (esdi->rel_hdr2 != NULL)
		{
		  bfd_size_type entsize2 = esdi->rel_hdr2->sh_entsize;
		  unsigned int alt_count;
		  unsigned int *rel_count2;

		  BFD_ASSERT (entsize2 != entsize1
			      && (entsize2 == bed->s->sizeof_rel
				  || entsize2 == bed->s->sizeof_rela));

		  rel_count2 = &esdo->rel_count2;
		  if (!same_size)
		    rel_count2 = &esdo->rel_count;

		  /* The following is probably too simplistic if the
		     backend counts output relocs unusually.  */
		  BFD_ASSERT (bed->elf_backend_count_relocs == NULL);
		  alt_count = NUM_SHDR_ENTRIES (esdi->rel_hdr2);
		  *rel_count2 += alt_count;
		  reloc_count -= alt_count;
		}
	    }
	  *rel_count1 += reloc_count;
	}

      if (o->reloc_count > 0)
	o->flags |= SEC_RELOC;
      else
	{
	  /* Explicitly clear the SEC_RELOC flag.  The linker tends to
	     set it (this is probably a bug) and if it is set
	     assign_section_numbers will create a reloc section.  */
	  o->flags &=~ SEC_RELOC;
	}

      /* If the SEC_ALLOC flag is not set, force the section VMA to
	 zero.  This is done in elf_fake_sections as well, but forcing
	 the VMA to 0 here will ensure that relocs against these
	 sections are handled correctly.  */
      if ((o->flags & SEC_ALLOC) == 0
	  && ! o->user_set_vma)
	o->vma = 0;
    }

  if (! info->relocatable && merged)
    elf_link_hash_traverse (elf_hash_table (info),
			    _bfd_elf_link_sec_merge_syms, abfd);

  /* Figure out the file positions for everything but the symbol table
     and the relocs.  We set symcount to force assign_section_numbers
     to create a symbol table.  */
  bfd_get_symcount (abfd) = info->strip == strip_all ? 0 : 1;
  BFD_ASSERT (! abfd->output_has_begun);
  if (! _bfd_elf_compute_section_file_positions (abfd, info))
    goto error_return;

  /* That created the reloc sections.  Set their sizes, and assign
     them file positions, and allocate some buffers.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) != 0)
	{
	  if (!(_bfd_elf_link_size_reloc_section
		(abfd, &elf_section_data (o)->rel_hdr, o)))
	    goto error_return;

	  if (elf_section_data (o)->rel_hdr2
	      && !(_bfd_elf_link_size_reloc_section
		   (abfd, elf_section_data (o)->rel_hdr2, o)))
	    goto error_return;
	}

      /* Now, reset REL_COUNT and REL_COUNT2 so that we can use them
	 to count upwards while actually outputting the relocations.  */
      elf_section_data (o)->rel_count = 0;
      elf_section_data (o)->rel_count2 = 0;
    }

  _bfd_elf_assign_file_positions_for_relocs (abfd);

  /* We have now assigned file positions for all the sections except
     .symtab and .strtab.  We start the .symtab section at the current
     file position, and write directly to it.  We build the .strtab
     section in memory.  */
  bfd_get_symcount (abfd) = 0;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  /* sh_name is set in prep_headers.  */
  symtab_hdr->sh_type = SHT_SYMTAB;
  /* sh_flags, sh_addr and sh_size all start off zero.  */
  symtab_hdr->sh_entsize = bed->s->sizeof_sym;
  /* sh_link is set in assign_section_numbers.  */
  /* sh_info is set below.  */
  /* sh_offset is set just below.  */
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;

  off = elf_tdata (abfd)->next_file_pos;
  off = _bfd_elf_assign_file_position_for_section (symtab_hdr, off, TRUE);

  /* Note that at this point elf_tdata (abfd)->next_file_pos is
     incorrect.  We do not yet know the size of the .symtab section.
     We correct next_file_pos below, after we do know the size.  */

  /* Allocate a buffer to hold swapped out symbols.  This is to avoid
     continuously seeking to the right position in the file.  */
  if (! info->keep_memory || max_sym_count < 20)
    finfo.symbuf_size = 20;
  else
    finfo.symbuf_size = max_sym_count;
  amt = finfo.symbuf_size;
  amt *= bed->s->sizeof_sym;
  finfo.symbuf = bfd_malloc (amt);
  if (finfo.symbuf == NULL)
    goto error_return;
  if (elf_numsections (abfd) > SHN_LORESERVE)
    {
      /* Wild guess at number of output symbols.  realloc'd as needed.  */
      amt = 2 * max_sym_count + elf_numsections (abfd) + 1000;
      finfo.shndxbuf_size = amt;
      amt *= sizeof (Elf_External_Sym_Shndx);
      finfo.symshndxbuf = bfd_zmalloc (amt);
      if (finfo.symshndxbuf == NULL)
	goto error_return;
    }

  /* Start writing out the symbol table.  The first symbol is always a
     dummy symbol.  */
  if (info->strip != strip_all
      || emit_relocs)
    {
      elfsym.st_value = 0;
      elfsym.st_size = 0;
      elfsym.st_info = 0;
      elfsym.st_other = 0;
      elfsym.st_shndx = SHN_UNDEF;
      if (! elf_link_output_sym (&finfo, NULL, &elfsym, bfd_und_section_ptr,
				 NULL))
	goto error_return;
    }

#if 0
  /* Some standard ELF linkers do this, but we don't because it causes
     bootstrap comparison failures.  */
  /* Output a file symbol for the output file as the second symbol.
     We output this even if we are discarding local symbols, although
     I'm not sure if this is correct.  */
  elfsym.st_value = 0;
  elfsym.st_size = 0;
  elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
  elfsym.st_other = 0;
  elfsym.st_shndx = SHN_ABS;
  if (! elf_link_output_sym (&finfo, bfd_get_filename (abfd),
			     &elfsym, bfd_abs_section_ptr, NULL))
    goto error_return;
#endif

  /* Output a symbol for each section.  We output these even if we are
     discarding local symbols, since they are used for relocs.  These
     symbols have no names.  We store the index of each one in the
     index field of the section, so that we can find it again when
     outputting relocs.  */
  if (info->strip != strip_all
      || emit_relocs)
    {
      elfsym.st_size = 0;
      elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
      elfsym.st_other = 0;
      for (i = 1; i < elf_numsections (abfd); i++)
	{
	  o = bfd_section_from_elf_index (abfd, i);
	  if (o != NULL)
	    o->target_index = bfd_get_symcount (abfd);
	  elfsym.st_shndx = i;
	  if (info->relocatable || o == NULL)
	    elfsym.st_value = 0;
	  else
	    elfsym.st_value = o->vma;
	  if (! elf_link_output_sym (&finfo, NULL, &elfsym, o, NULL))
	    goto error_return;
	  if (i == SHN_LORESERVE - 1)
	    i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	}
    }

  /* Allocate some memory to hold information read in from the input
     files.  */
  if (max_contents_size != 0)
    {
      finfo.contents = bfd_malloc (max_contents_size);
      if (finfo.contents == NULL)
	goto error_return;
    }

  if (max_external_reloc_size != 0)
    {
      finfo.external_relocs = bfd_malloc (max_external_reloc_size);
      if (finfo.external_relocs == NULL)
	goto error_return;
    }

  if (max_internal_reloc_count != 0)
    {
      amt = max_internal_reloc_count * bed->s->int_rels_per_ext_rel;
      amt *= sizeof (Elf_Internal_Rela);
      finfo.internal_relocs = bfd_malloc (amt);
      if (finfo.internal_relocs == NULL)
	goto error_return;
    }

  if (max_sym_count != 0)
    {
      amt = max_sym_count * bed->s->sizeof_sym;
      finfo.external_syms = bfd_malloc (amt);
      if (finfo.external_syms == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (Elf_Internal_Sym);
      finfo.internal_syms = bfd_malloc (amt);
      if (finfo.internal_syms == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (long);
      finfo.indices = bfd_malloc (amt);
      if (finfo.indices == NULL)
	goto error_return;

      amt = max_sym_count * sizeof (asection *);
      finfo.sections = bfd_malloc (amt);
      if (finfo.sections == NULL)
	goto error_return;
    }

  if (max_sym_shndx_count != 0)
    {
      amt = max_sym_shndx_count * sizeof (Elf_External_Sym_Shndx);
      finfo.locsym_shndx = bfd_malloc (amt);
      if (finfo.locsym_shndx == NULL)
	goto error_return;
    }

  if (elf_hash_table (info)->tls_sec)
    {
      bfd_vma base, end = 0;
      asection *sec;

      for (sec = elf_hash_table (info)->tls_sec;
	   sec && (sec->flags & SEC_THREAD_LOCAL);
	   sec = sec->next)
	{
	  bfd_vma size = sec->_raw_size;

	  if (size == 0 && (sec->flags & SEC_HAS_CONTENTS) == 0)
	    {
	      struct bfd_link_order *o;

	      for (o = sec->link_order_head; o != NULL; o = o->next)
		if (size < o->offset + o->size)
		  size = o->offset + o->size;
	    }
	  end = sec->vma + size;
	}
      base = elf_hash_table (info)->tls_sec->vma;
      end = align_power (end, elf_hash_table (info)->tls_sec->alignment_power);
      elf_hash_table (info)->tls_size = end - base;
    }

  /* Since ELF permits relocations to be against local symbols, we
     must have the local symbols available when we do the relocations.
     Since we would rather only read the local symbols once, and we
     would rather not keep them in memory, we handle all the
     relocations for a single input file at the same time.

     Unfortunately, there is no way to know the total number of local
     symbols until we have seen all of them, and the local symbol
     indices precede the global symbol indices.  This means that when
     we are generating relocatable output, and we see a reloc against
     a global symbol, we can not know the symbol index until we have
     finished examining all the local symbols to see which ones we are
     going to output.  To deal with this, we keep the relocations in
     memory, and don't output them until the end of the link.  This is
     an unfortunate waste of memory, but I don't see a good way around
     it.  Fortunately, it only happens when performing a relocatable
     link, which is not the common case.  FIXME: If keep_memory is set
     we could write the relocs out and then read them again; I don't
     know how bad the memory loss will be.  */

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    sub->output_has_begun = FALSE;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && (bfd_get_flavour ((sub = p->u.indirect.section->owner))
		  == bfd_target_elf_flavour)
	      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass)
	    {
	      if (! sub->output_has_begun)
		{
		  if (! elf_link_input_bfd (&finfo, sub))
		    goto error_return;
		  sub->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! elf_reloc_link_order (abfd, info, o, p))
		goto error_return;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
	    }
	}
    }

  /* Output any global symbols that got converted to local in a
     version script or due to symbol visibility.  We do this in a
     separate step since ELF requires all local symbols to appear
     prior to any global symbols.  FIXME: We should only do this if
     some global symbols were, in fact, converted to become local.
     FIXME: Will this work correctly with the Irix 5 linker?  */
  eoinfo.failed = FALSE;
  eoinfo.finfo = &finfo;
  eoinfo.localsyms = TRUE;
  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
			  &eoinfo);
  if (eoinfo.failed)
    return FALSE;

  /* That wrote out all the local symbols.  Finish up the symbol table
     with the global symbols. Even if we want to strip everything we
     can, we still need to deal with those global symbols that got
     converted to local in a version script.  */

  /* The sh_info field records the index of the first non local symbol.  */
  symtab_hdr->sh_info = bfd_get_symcount (abfd);

  if (dynamic
      && finfo.dynsym_sec->output_section != bfd_abs_section_ptr)
    {
      Elf_Internal_Sym sym;
      bfd_byte *dynsym = finfo.dynsym_sec->contents;
      long last_local = 0;

      /* Write out the section symbols for the output sections.  */
      if (info->shared)
	{
	  asection *s;

	  sym.st_size = 0;
	  sym.st_name = 0;
	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	  sym.st_other = 0;

	  for (s = abfd->sections; s != NULL; s = s->next)
	    {
	      int indx;
	      bfd_byte *dest;
	      long dynindx;

	      indx = elf_section_data (s)->this_idx;
	      dynindx = elf_section_data (s)->dynindx;
	      BFD_ASSERT (indx > 0);
	      sym.st_shndx = indx;
	      sym.st_value = s->vma;
	      dest = dynsym + dynindx * bed->s->sizeof_sym;
	      bed->s->swap_symbol_out (abfd, &sym, dest, 0);
	    }

	  last_local = bfd_count_sections (abfd);
	}

      /* Write out the local dynsyms.  */
      if (elf_hash_table (info)->dynlocal)
	{
	  struct elf_link_local_dynamic_entry *e;
	  for (e = elf_hash_table (info)->dynlocal; e ; e = e->next)
	    {
	      asection *s;
	      bfd_byte *dest;

	      sym.st_size = e->isym.st_size;
	      sym.st_other = e->isym.st_other;

	      /* Copy the internal symbol as is.
		 Note that we saved a word of storage and overwrote
		 the original st_name with the dynstr_index.  */
	      sym = e->isym;

	      if (e->isym.st_shndx != SHN_UNDEF
		  && (e->isym.st_shndx < SHN_LORESERVE
		      || e->isym.st_shndx > SHN_HIRESERVE))
		{
		  s = bfd_section_from_elf_index (e->input_bfd,
						  e->isym.st_shndx);

		  sym.st_shndx =
		    elf_section_data (s->output_section)->this_idx;
		  sym.st_value = (s->output_section->vma
				  + s->output_offset
				  + e->isym.st_value);
		}

	      if (last_local < e->dynindx)
		last_local = e->dynindx;

	      dest = dynsym + e->dynindx * bed->s->sizeof_sym;
	      bed->s->swap_symbol_out (abfd, &sym, dest, 0);
	    }
	}

      elf_section_data (finfo.dynsym_sec->output_section)->this_hdr.sh_info =
	last_local + 1;
    }

  /* We get the global symbols from the hash table.  */
  eoinfo.failed = FALSE;
  eoinfo.localsyms = FALSE;
  eoinfo.finfo = &finfo;
  elf_link_hash_traverse (elf_hash_table (info), elf_link_output_extsym,
			  &eoinfo);
  if (eoinfo.failed)
    return FALSE;

  /* If backend needs to output some symbols not present in the hash
     table, do it now.  */
  if (bed->elf_backend_output_arch_syms)
    {
      typedef bfd_boolean (*out_sym_func)
	(void *, const char *, Elf_Internal_Sym *, asection *,
	 struct elf_link_hash_entry *);

      if (! ((*bed->elf_backend_output_arch_syms)
	     (abfd, info, &finfo, (out_sym_func) elf_link_output_sym)))
	return FALSE;
    }

  /* Flush all symbols to the file.  */
  if (! elf_link_flush_output_syms (&finfo, bed))
    return FALSE;

  /* Now we know the size of the symtab section.  */
  off += symtab_hdr->sh_size;

  symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (symtab_shndx_hdr->sh_name != 0)
    {
      symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
      symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
      amt = bfd_get_symcount (abfd) * sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_size = amt;

      off = _bfd_elf_assign_file_position_for_section (symtab_shndx_hdr,
						       off, TRUE);

      if (bfd_seek (abfd, symtab_shndx_hdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bwrite (finfo.symshndxbuf, amt, abfd) != amt))
	return FALSE;
    }


  /* Finish up and write out the symbol string table (.strtab)
     section.  */
  symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;
  /* sh_name was set in prep_headers.  */
  symstrtab_hdr->sh_type = SHT_STRTAB;
  symstrtab_hdr->sh_flags = 0;
  symstrtab_hdr->sh_addr = 0;
  symstrtab_hdr->sh_size = _bfd_stringtab_size (finfo.symstrtab);
  symstrtab_hdr->sh_entsize = 0;
  symstrtab_hdr->sh_link = 0;
  symstrtab_hdr->sh_info = 0;
  /* sh_offset is set just below.  */
  symstrtab_hdr->sh_addralign = 1;

  off = _bfd_elf_assign_file_position_for_section (symstrtab_hdr, off, TRUE);
  elf_tdata (abfd)->next_file_pos = off;

  if (bfd_get_symcount (abfd) > 0)
    {
      if (bfd_seek (abfd, symstrtab_hdr->sh_offset, SEEK_SET) != 0
	  || ! _bfd_stringtab_emit (abfd, finfo.symstrtab))
	return FALSE;
    }

  /* Adjust the relocs to have the correct symbol indices.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) == 0)
	continue;

      elf_link_adjust_relocs (abfd, &elf_section_data (o)->rel_hdr,
			      elf_section_data (o)->rel_count,
			      elf_section_data (o)->rel_hashes);
      if (elf_section_data (o)->rel_hdr2 != NULL)
	elf_link_adjust_relocs (abfd, elf_section_data (o)->rel_hdr2,
				elf_section_data (o)->rel_count2,
				(elf_section_data (o)->rel_hashes
				 + elf_section_data (o)->rel_count));

      /* Set the reloc_count field to 0 to prevent write_relocs from
	 trying to swap the relocs out itself.  */
      o->reloc_count = 0;
    }

  if (dynamic && info->combreloc && dynobj != NULL)
    relativecount = elf_link_sort_relocs (abfd, info, &reldyn);

  /* If we are linking against a dynamic object, or generating a
     shared library, finish up the dynamic linking information.  */
  if (dynamic)
    {
      bfd_byte *dyncon, *dynconend;

      /* Fix up .dynamic entries.  */
      o = bfd_get_section_by_name (dynobj, ".dynamic");
      BFD_ASSERT (o != NULL);

      dyncon = o->contents;
      dynconend = o->contents + o->_raw_size;
      for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  unsigned int type;

	  bed->s->swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      continue;
	    case DT_NULL:
	      if (relativecount > 0 && dyncon + bed->s->sizeof_dyn < dynconend)
		{
		  switch (elf_section_data (reldyn)->this_hdr.sh_type)
		    {
		    case SHT_REL: dyn.d_tag = DT_RELCOUNT; break;
		    case SHT_RELA: dyn.d_tag = DT_RELACOUNT; break;
		    default: continue;
		    }
		  dyn.d_un.d_val = relativecount;
		  relativecount = 0;
		  break;
		}
	      continue;

	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;
	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      {
		struct elf_link_hash_entry *h;

		h = elf_link_hash_lookup (elf_hash_table (info), name,
					  FALSE, FALSE, TRUE);
		if (h != NULL
		    && (h->root.type == bfd_link_hash_defined
			|| h->root.type == bfd_link_hash_defweak))
		  {
		    dyn.d_un.d_val = h->root.u.def.value;
		    o = h->root.u.def.section;
		    if (o->output_section != NULL)
		      dyn.d_un.d_val += (o->output_section->vma
					 + o->output_offset);
		    else
		      {
			/* The symbol is imported from another shared
			   library and does not apply to this one.  */
			dyn.d_un.d_val = 0;
		      }
		    break;
		  }
	      }
	      continue;

	    case DT_PREINIT_ARRAYSZ:
	      name = ".preinit_array";
	      goto get_size;
	    case DT_INIT_ARRAYSZ:
	      name = ".init_array";
	      goto get_size;
	    case DT_FINI_ARRAYSZ:
	      name = ".fini_array";
	    get_size:
	      o = bfd_get_section_by_name (abfd, name);
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
		  goto error_return;
		}
	      if (o->_raw_size == 0)
		(*_bfd_error_handler)
		  (_("warning: %s section has zero size"), name);
	      dyn.d_un.d_val = o->_raw_size;
	      break;

	    case DT_PREINIT_ARRAY:
	      name = ".preinit_array";
	      goto get_vma;
	    case DT_INIT_ARRAY:
	      name = ".init_array";
	      goto get_vma;
	    case DT_FINI_ARRAY:
	      name = ".fini_array";
	      goto get_vma;

	    case DT_HASH:
	      name = ".hash";
	      goto get_vma;
	    case DT_STRTAB:
	      name = ".dynstr";
	      goto get_vma;
	    case DT_SYMTAB:
	      name = ".dynsym";
	      goto get_vma;
	    case DT_VERDEF:
	      name = ".gnu.version_d";
	      goto get_vma;
	    case DT_VERNEED:
	      name = ".gnu.version_r";
	      goto get_vma;
	    case DT_VERSYM:
	      name = ".gnu.version";
	    get_vma:
	      o = bfd_get_section_by_name (abfd, name);
	      if (o == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: could not find output section %s"),
		     bfd_get_filename (abfd), name);
		  goto error_return;
		}
	      dyn.d_un.d_ptr = o->vma;
	      break;

	    case DT_REL:
	    case DT_RELA:
	    case DT_RELSZ:
	    case DT_RELASZ:
	      if (dyn.d_tag == DT_REL || dyn.d_tag == DT_RELSZ)
		type = SHT_REL;
	      else
		type = SHT_RELA;
	      dyn.d_un.d_val = 0;
	      for (i = 1; i < elf_numsections (abfd); i++)
		{
		  Elf_Internal_Shdr *hdr;

		  hdr = elf_elfsections (abfd)[i];
		  if (hdr->sh_type == type
		      && (hdr->sh_flags & SHF_ALLOC) != 0)
		    {
		      if (dyn.d_tag == DT_RELSZ || dyn.d_tag == DT_RELASZ)
			dyn.d_un.d_val += hdr->sh_size;
		      else
			{
			  if (dyn.d_un.d_val == 0
			      || hdr->sh_addr < dyn.d_un.d_val)
			    dyn.d_un.d_val = hdr->sh_addr;
			}
		    }
		}
	      break;
	    }
	  bed->s->swap_dyn_out (dynobj, &dyn, dyncon);
	}
    }

  /* If we have created any dynamic sections, then output them.  */
  if (dynobj != NULL)
    {
      if (! (*bed->elf_backend_finish_dynamic_sections) (abfd, info))
	goto error_return;

      for (o = dynobj->sections; o != NULL; o = o->next)
	{
	  if ((o->flags & SEC_HAS_CONTENTS) == 0
	      || o->_raw_size == 0
	      || o->output_section == bfd_abs_section_ptr)
	    continue;
	  if ((o->flags & SEC_LINKER_CREATED) == 0)
	    {
	      /* At this point, we are only interested in sections
		 created by _bfd_elf_link_create_dynamic_sections.  */
	      continue;
	    }
	  if ((elf_section_data (o->output_section)->this_hdr.sh_type
	       != SHT_STRTAB)
	      || strcmp (bfd_get_section_name (abfd, o), ".dynstr") != 0)
	    {
	      if (! bfd_set_section_contents (abfd, o->output_section,
					      o->contents,
					      (file_ptr) o->output_offset,
					      o->_raw_size))
		goto error_return;
	    }
	  else
	    {
	      /* The contents of the .dynstr section are actually in a
		 stringtab.  */
	      off = elf_section_data (o->output_section)->this_hdr.sh_offset;
	      if (bfd_seek (abfd, off, SEEK_SET) != 0
		  || ! _bfd_elf_strtab_emit (abfd,
					     elf_hash_table (info)->dynstr))
		goto error_return;
	    }
	}
    }

  if (info->relocatable)
    {
      bfd_boolean failed = FALSE;

      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
      if (failed)
	goto error_return;
    }

  /* If we have optimized stabs strings, output them.  */
  if (elf_hash_table (info)->stab_info != NULL)
    {
      if (! _bfd_write_stab_strings (abfd, &elf_hash_table (info)->stab_info))
	goto error_return;
    }

  if (info->eh_frame_hdr)
    {
      if (! _bfd_elf_write_section_eh_frame_hdr (abfd, info))
	goto error_return;
    }

  if (finfo.symstrtab != NULL)
    _bfd_stringtab_free (finfo.symstrtab);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
  if (finfo.external_syms != NULL)
    free (finfo.external_syms);
  if (finfo.locsym_shndx != NULL)
    free (finfo.locsym_shndx);
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.indices != NULL)
    free (finfo.indices);
  if (finfo.sections != NULL)
    free (finfo.sections);
  if (finfo.symbuf != NULL)
    free (finfo.symbuf);
  if (finfo.symshndxbuf != NULL)
    free (finfo.symshndxbuf);
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) != 0
	  && elf_section_data (o)->rel_hashes != NULL)
	free (elf_section_data (o)->rel_hashes);
    }

  elf_tdata (abfd)->linker = TRUE;

  return TRUE;

 error_return:
  if (finfo.symstrtab != NULL)
    _bfd_stringtab_free (finfo.symstrtab);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
  if (finfo.external_syms != NULL)
    free (finfo.external_syms);
  if (finfo.locsym_shndx != NULL)
    free (finfo.locsym_shndx);
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.indices != NULL)
    free (finfo.indices);
  if (finfo.sections != NULL)
    free (finfo.sections);
  if (finfo.symbuf != NULL)
    free (finfo.symbuf);
  if (finfo.symshndxbuf != NULL)
    free (finfo.symshndxbuf);
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_RELOC) != 0
	  && elf_section_data (o)->rel_hashes != NULL)
	free (elf_section_data (o)->rel_hashes);
    }

  return FALSE;
}

/* Garbage collect unused sections.  */

/* The mark phase of garbage collection.  For a given section, mark
   it and any sections in this section's group, and all the sections
   which define symbols to which it refers.  */

typedef asection * (*gc_mark_hook_fn)
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

static bfd_boolean
elf_gc_mark (struct bfd_link_info *info,
	     asection *sec,
	     gc_mark_hook_fn gc_mark_hook)
{
  bfd_boolean ret;
  asection *group_sec;

  sec->gc_mark = 1;

  /* Mark all the sections in the group.  */
  group_sec = elf_section_data (sec)->next_in_group;
  if (group_sec && !group_sec->gc_mark)
    if (!elf_gc_mark (info, group_sec, gc_mark_hook))
      return FALSE;

  /* Look through the section relocs.  */
  ret = TRUE;
  if ((sec->flags & SEC_RELOC) != 0 && sec->reloc_count > 0)
    {
      Elf_Internal_Rela *relstart, *rel, *relend;
      Elf_Internal_Shdr *symtab_hdr;
      struct elf_link_hash_entry **sym_hashes;
      size_t nlocsyms;
      size_t extsymoff;
      bfd *input_bfd = sec->owner;
      const struct elf_backend_data *bed = get_elf_backend_data (input_bfd);
      Elf_Internal_Sym *isym = NULL;
      int r_sym_shift;

      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      sym_hashes = elf_sym_hashes (input_bfd);

      /* Read the local symbols.  */
      if (elf_bad_symtab (input_bfd))
	{
	  nlocsyms = symtab_hdr->sh_size / bed->s->sizeof_sym;
	  extsymoff = 0;
	}
      else
	extsymoff = nlocsyms = symtab_hdr->sh_info;

      isym = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isym == NULL && nlocsyms != 0)
	{
	  isym = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, nlocsyms, 0,
				       NULL, NULL, NULL);
	  if (isym == NULL)
	    return FALSE;
	}

      /* Read the relocations.  */
      relstart = _bfd_elf_link_read_relocs (input_bfd, sec, NULL, NULL,
					    info->keep_memory);
      if (relstart == NULL)
	{
	  ret = FALSE;
	  goto out1;
	}
      relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;

      if (bed->s->arch_size == 32)
	r_sym_shift = 8;
      else
	r_sym_shift = 32;

      for (rel = relstart; rel < relend; rel++)
	{
	  unsigned long r_symndx;
	  asection *rsec;
	  struct elf_link_hash_entry *h;

	  r_symndx = rel->r_info >> r_sym_shift;
	  if (r_symndx == 0)
	    continue;

	  if (r_symndx >= nlocsyms
	      || ELF_ST_BIND (isym[r_symndx].st_info) != STB_LOCAL)
	    {
	      h = sym_hashes[r_symndx - extsymoff];
	      rsec = (*gc_mark_hook) (sec, info, rel, h, NULL);
	    }
	  else
	    {
	      rsec = (*gc_mark_hook) (sec, info, rel, NULL, &isym[r_symndx]);
	    }

	  if (rsec && !rsec->gc_mark)
	    {
	      if (bfd_get_flavour (rsec->owner) != bfd_target_elf_flavour)
		rsec->gc_mark = 1;
	      else if (!elf_gc_mark (info, rsec, gc_mark_hook))
		{
		  ret = FALSE;
		  goto out2;
		}
	    }
	}

    out2:
      if (elf_section_data (sec)->relocs != relstart)
	free (relstart);
    out1:
      if (isym != NULL && symtab_hdr->contents != (unsigned char *) isym)
	{
	  if (! info->keep_memory)
	    free (isym);
	  else
	    symtab_hdr->contents = (unsigned char *) isym;
	}
    }

  return ret;
}

/* Sweep symbols in swept sections.  Called via elf_link_hash_traverse.  */

static bfd_boolean
elf_gc_sweep_symbol (struct elf_link_hash_entry *h, void *idxptr)
{
  int *idx = idxptr;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx != -1
      && ((h->root.type != bfd_link_hash_defined
	   && h->root.type != bfd_link_hash_defweak)
	  || h->root.u.def.section->gc_mark))
    h->dynindx = (*idx)++;

  return TRUE;
}

/* The sweep phase of garbage collection.  Remove all garbage sections.  */

typedef bfd_boolean (*gc_sweep_hook_fn)
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);

static bfd_boolean
elf_gc_sweep (struct bfd_link_info *info, gc_sweep_hook_fn gc_sweep_hook)
{
  bfd *sub;

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *o;

      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
	continue;

      for (o = sub->sections; o != NULL; o = o->next)
	{
	  /* Keep special sections.  Keep .debug sections.  */
	  if ((o->flags & SEC_LINKER_CREATED)
	      || (o->flags & SEC_DEBUGGING))
	    o->gc_mark = 1;

	  if (o->gc_mark)
	    continue;

	  /* Skip sweeping sections already excluded.  */
	  if (o->flags & SEC_EXCLUDE)
	    continue;

	  /* Since this is early in the link process, it is simple
	     to remove a section from the output.  */
	  o->flags |= SEC_EXCLUDE;

	  /* But we also have to update some of the relocation
	     info we collected before.  */
	  if (gc_sweep_hook
	      && (o->flags & SEC_RELOC) && o->reloc_count > 0)
	    {
	      Elf_Internal_Rela *internal_relocs;
	      bfd_boolean r;

	      internal_relocs
		= _bfd_elf_link_read_relocs (o->owner, o, NULL, NULL,
					     info->keep_memory);
	      if (internal_relocs == NULL)
		return FALSE;

	      r = (*gc_sweep_hook) (o->owner, info, o, internal_relocs);

	      if (elf_section_data (o)->relocs != internal_relocs)
		free (internal_relocs);

	      if (!r)
		return FALSE;
	    }
	}
    }

  /* Remove the symbols that were in the swept sections from the dynamic
     symbol table.  GCFIXME: Anyone know how to get them out of the
     static symbol table as well?  */
  {
    int i = 0;

    elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol, &i);

    elf_hash_table (info)->dynsymcount = i;
  }

  return TRUE;
}

/* Propagate collected vtable information.  This is called through
   elf_link_hash_traverse.  */

static bfd_boolean
elf_gc_propagate_vtable_entries_used (struct elf_link_hash_entry *h, void *okp)
{
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Those that are not vtables.  */
  if (h->vtable_parent == NULL)
    return TRUE;

  /* Those vtables that do not have parents, we cannot merge.  */
  if (h->vtable_parent == (struct elf_link_hash_entry *) -1)
    return TRUE;

  /* If we've already been done, exit.  */
  if (h->vtable_entries_used && h->vtable_entries_used[-1])
    return TRUE;

  /* Make sure the parent's table is up to date.  */
  elf_gc_propagate_vtable_entries_used (h->vtable_parent, okp);

  if (h->vtable_entries_used == NULL)
    {
      /* None of this table's entries were referenced.  Re-use the
	 parent's table.  */
      h->vtable_entries_used = h->vtable_parent->vtable_entries_used;
      h->vtable_entries_size = h->vtable_parent->vtable_entries_size;
    }
  else
    {
      size_t n;
      bfd_boolean *cu, *pu;

      /* Or the parent's entries into ours.  */
      cu = h->vtable_entries_used;
      cu[-1] = TRUE;
      pu = h->vtable_parent->vtable_entries_used;
      if (pu != NULL)
	{
	  const struct elf_backend_data *bed;
	  unsigned int log_file_align;

	  bed = get_elf_backend_data (h->root.u.def.section->owner);
	  log_file_align = bed->s->log_file_align;
	  n = h->vtable_parent->vtable_entries_size >> log_file_align;
	  while (n--)
	    {
	      if (*pu)
		*cu = TRUE;
	      pu++;
	      cu++;
	    }
	}
    }

  return TRUE;
}

static bfd_boolean
elf_gc_smash_unused_vtentry_relocs (struct elf_link_hash_entry *h, void *okp)
{
  asection *sec;
  bfd_vma hstart, hend;
  Elf_Internal_Rela *relstart, *relend, *rel;
  const struct elf_backend_data *bed;
  unsigned int log_file_align;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Take care of both those symbols that do not describe vtables as
     well as those that are not loaded.  */
  if (h->vtable_parent == NULL)
    return TRUE;

  BFD_ASSERT (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak);

  sec = h->root.u.def.section;
  hstart = h->root.u.def.value;
  hend = hstart + h->size;

  relstart = _bfd_elf_link_read_relocs (sec->owner, sec, NULL, NULL, TRUE);
  if (!relstart)
    return *(bfd_boolean *) okp = FALSE;
  bed = get_elf_backend_data (sec->owner);
  log_file_align = bed->s->log_file_align;

  relend = relstart + sec->reloc_count * bed->s->int_rels_per_ext_rel;

  for (rel = relstart; rel < relend; ++rel)
    if (rel->r_offset >= hstart && rel->r_offset < hend)
      {
	/* If the entry is in use, do nothing.  */
	if (h->vtable_entries_used
	    && (rel->r_offset - hstart) < h->vtable_entries_size)
	  {
	    bfd_vma entry = (rel->r_offset - hstart) >> log_file_align;
	    if (h->vtable_entries_used[entry])
	      continue;
	  }
	/* Otherwise, kill it.  */
	rel->r_offset = rel->r_info = rel->r_addend = 0;
      }

  return TRUE;
}

/* Do mark and sweep of unused sections.  */

bfd_boolean
bfd_elf_gc_sections (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean ok = TRUE;
  bfd *sub;
  asection * (*gc_mark_hook)
    (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *);

  if (!get_elf_backend_data (abfd)->can_gc_sections
      || info->relocatable
      || info->emitrelocations
      || !is_elf_hash_table (info->hash)
      || elf_hash_table (info)->dynamic_sections_created)
    {
      (*_bfd_error_handler)(_("Warning: gc-sections option ignored"));
      return TRUE;
    }

  /* Apply transitive closure to the vtable entry usage info.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_propagate_vtable_entries_used,
			  &ok);
  if (!ok)
    return FALSE;

  /* Kill the vtable relocations that were not used.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_smash_unused_vtentry_relocs,
			  &ok);
  if (!ok)
    return FALSE;

  /* Grovel through relocs to find out who stays ...  */

  gc_mark_hook = get_elf_backend_data (abfd)->gc_mark_hook;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *o;

      if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
	continue;

      for (o = sub->sections; o != NULL; o = o->next)
	{
	  if (o->flags & SEC_KEEP)
	    if (!elf_gc_mark (info, o, gc_mark_hook))
	      return FALSE;
	}
    }

  /* ... and mark SEC_EXCLUDE for those that go.  */
  if (!elf_gc_sweep (info, get_elf_backend_data (abfd)->gc_sweep_hook))
    return FALSE;

  return TRUE;
}

/* Called from check_relocs to record the existence of a VTINHERIT reloc.  */

bfd_boolean
bfd_elf_gc_record_vtinherit (bfd *abfd,
			     asection *sec,
			     struct elf_link_hash_entry *h,
			     bfd_vma offset)
{
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
  struct elf_link_hash_entry **search, *child;
  bfd_size_type extsymcount;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* The sh_info field of the symtab header tells us where the
     external symbols start.  We don't care about the local symbols at
     this point.  */
  extsymcount = elf_tdata (abfd)->symtab_hdr.sh_size / bed->s->sizeof_sym;
  if (!elf_bad_symtab (abfd))
    extsymcount -= elf_tdata (abfd)->symtab_hdr.sh_info;

  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes + extsymcount;

  /* Hunt down the child symbol, which is in this section at the same
     offset as the relocation.  */
  for (search = sym_hashes; search != sym_hashes_end; ++search)
    {
      if ((child = *search) != NULL
	  && (child->root.type == bfd_link_hash_defined
	      || child->root.type == bfd_link_hash_defweak)
	  && child->root.u.def.section == sec
	  && child->root.u.def.value == offset)
	goto win;
    }

  (*_bfd_error_handler) ("%s: %s+%lu: No symbol found for INHERIT",
			 bfd_archive_filename (abfd), sec->name,
			 (unsigned long) offset);
  bfd_set_error (bfd_error_invalid_operation);
  return FALSE;

 win:
  if (!h)
    {
      /* This *should* only be the absolute section.  It could potentially
	 be that someone has defined a non-global vtable though, which
	 would be bad.  It isn't worth paging in the local symbols to be
	 sure though; that case should simply be handled by the assembler.  */

      child->vtable_parent = (struct elf_link_hash_entry *) -1;
    }
  else
    child->vtable_parent = h;

  return TRUE;
}

/* Called from check_relocs to record the existence of a VTENTRY reloc.  */

bfd_boolean
bfd_elf_gc_record_vtentry (bfd *abfd ATTRIBUTE_UNUSED,
			   asection *sec ATTRIBUTE_UNUSED,
			   struct elf_link_hash_entry *h,
			   bfd_vma addend)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  unsigned int log_file_align = bed->s->log_file_align;

  if (addend >= h->vtable_entries_size)
    {
      size_t size, bytes, file_align;
      bfd_boolean *ptr = h->vtable_entries_used;

      /* While the symbol is undefined, we have to be prepared to handle
	 a zero size.  */
      file_align = 1 << log_file_align;
      if (h->root.type == bfd_link_hash_undefined)
	size = addend + file_align;
      else
	{
	  size = h->size;
	  if (addend >= size)
	    {
	      /* Oops!  We've got a reference past the defined end of
		 the table.  This is probably a bug -- shall we warn?  */
	      size = addend + file_align;
	    }
	}
      size = (size + file_align - 1) & -file_align;

      /* Allocate one extra entry for use as a "done" flag for the
	 consolidation pass.  */
      bytes = ((size >> log_file_align) + 1) * sizeof (bfd_boolean);

      if (ptr)
	{
	  ptr = bfd_realloc (ptr - 1, bytes);

	  if (ptr != NULL)
	    {
	      size_t oldbytes;

	      oldbytes = (((h->vtable_entries_size >> log_file_align) + 1)
			  * sizeof (bfd_boolean));
	      memset (((char *) ptr) + oldbytes, 0, bytes - oldbytes);
	    }
	}
      else
	ptr = bfd_zmalloc (bytes);

      if (ptr == NULL)
	return FALSE;

      /* And arrange for that done flag to be at index -1.  */
      h->vtable_entries_used = ptr + 1;
      h->vtable_entries_size = size;
    }

  h->vtable_entries_used[addend >> log_file_align] = TRUE;

  return TRUE;
}

struct alloc_got_off_arg {
  bfd_vma gotoff;
  unsigned int got_elt_size;
};

/* We need a special top-level link routine to convert got reference counts
   to real got offsets.  */

static bfd_boolean
elf_gc_allocate_got_offsets (struct elf_link_hash_entry *h, void *arg)
{
  struct alloc_got_off_arg *gofarg = arg;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->got.refcount > 0)
    {
      h->got.offset = gofarg->gotoff;
      gofarg->gotoff += gofarg->got_elt_size;
    }
  else
    h->got.offset = (bfd_vma) -1;

  return TRUE;
}

/* And an accompanying bit to work out final got entry offsets once
   we're done.  Should be called from final_link.  */

bfd_boolean
bfd_elf_gc_common_finalize_got_offsets (bfd *abfd,
					struct bfd_link_info *info)
{
  bfd *i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_vma gotoff;
  unsigned int got_elt_size = bed->s->arch_size / 8;
  struct alloc_got_off_arg gofarg;

  if (! is_elf_hash_table (info->hash))
    return FALSE;

  /* The GOT offset is relative to the .got section, but the GOT header is
     put into the .got.plt section, if the backend uses it.  */
  if (bed->want_got_plt)
    gotoff = 0;
  else
    gotoff = bed->got_header_size;

  /* Do the local .got entries first.  */
  for (i = info->input_bfds; i; i = i->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_size_type j, locsymcount;
      Elf_Internal_Shdr *symtab_hdr;

      if (bfd_get_flavour (i) != bfd_target_elf_flavour)
	continue;

      local_got = elf_local_got_refcounts (i);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (i)->symtab_hdr;
      if (elf_bad_symtab (i))
	locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      else
	locsymcount = symtab_hdr->sh_info;

      for (j = 0; j < locsymcount; ++j)
	{
	  if (local_got[j] > 0)
	    {
	      local_got[j] = gotoff;
	      gotoff += got_elt_size;
	    }
	  else
	    local_got[j] = (bfd_vma) -1;
	}
    }

  /* Then the global .got entries.  .plt refcounts are handled by
     adjust_dynamic_symbol  */
  gofarg.gotoff = gotoff;
  gofarg.got_elt_size = got_elt_size;
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_gc_allocate_got_offsets,
			  &gofarg);
  return TRUE;
}

/* Many folk need no more in the way of final link than this, once
   got entry reference counting is enabled.  */

bfd_boolean
bfd_elf_gc_common_final_link (bfd *abfd, struct bfd_link_info *info)
{
  if (!bfd_elf_gc_common_finalize_got_offsets (abfd, info))
    return FALSE;

  /* Invoke the regular ELF backend linker to do all the work.  */
  return bfd_elf_final_link (abfd, info);
}

bfd_boolean
bfd_elf_reloc_symbol_deleted_p (bfd_vma offset, void *cookie)
{
  struct elf_reloc_cookie *rcookie = cookie;

  if (rcookie->bad_symtab)
    rcookie->rel = rcookie->rels;

  for (; rcookie->rel < rcookie->relend; rcookie->rel++)
    {
      unsigned long r_symndx;

      if (! rcookie->bad_symtab)
	if (rcookie->rel->r_offset > offset)
	  return FALSE;
      if (rcookie->rel->r_offset != offset)
	continue;

      r_symndx = rcookie->rel->r_info >> rcookie->r_sym_shift;
      if (r_symndx == SHN_UNDEF)
	return TRUE;

      if (r_symndx >= rcookie->locsymcount
	  || ELF_ST_BIND (rcookie->locsyms[r_symndx].st_info) != STB_LOCAL)
	{
	  struct elf_link_hash_entry *h;

	  h = rcookie->sym_hashes[r_symndx - rcookie->extsymoff];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && elf_discarded_section (h->root.u.def.section))
	    return TRUE;
	  else
	    return FALSE;
	}
      else
	{
	  /* It's not a relocation against a global symbol,
	     but it could be a relocation against a local
	     symbol for a discarded section.  */
	  asection *isec;
	  Elf_Internal_Sym *isym;

	  /* Need to: get the symbol; get the section.  */
	  isym = &rcookie->locsyms[r_symndx];
	  if (isym->st_shndx < SHN_LORESERVE || isym->st_shndx > SHN_HIRESERVE)
	    {
	      isec = bfd_section_from_elf_index (rcookie->abfd, isym->st_shndx);
	      if (isec != NULL && elf_discarded_section (isec))
		return TRUE;
	    }
	}
      return FALSE;
    }
  return FALSE;
}

/* Discard unneeded references to discarded sections.
   Returns TRUE if any section's size was changed.  */
/* This function assumes that the relocations are in sorted order,
   which is true for all known assemblers.  */

bfd_boolean
bfd_elf_discard_info (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_reloc_cookie cookie;
  asection *stab, *eh;
  Elf_Internal_Shdr *symtab_hdr;
  const struct elf_backend_data *bed;
  bfd *abfd;
  unsigned int count;
  bfd_boolean ret = FALSE;

  if (info->traditional_format
      || !is_elf_hash_table (info->hash))
    return FALSE;

  for (abfd = info->input_bfds; abfd != NULL; abfd = abfd->link_next)
    {
      if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
	continue;

      bed = get_elf_backend_data (abfd);

      if ((abfd->flags & DYNAMIC) != 0)
	continue;

      eh = bfd_get_section_by_name (abfd, ".eh_frame");
      if (info->relocatable
	  || (eh != NULL
	      && (eh->_raw_size == 0
		  || bfd_is_abs_section (eh->output_section))))
	eh = NULL;

      stab = bfd_get_section_by_name (abfd, ".stab");
      if (stab != NULL
	  && (stab->_raw_size == 0
	      || bfd_is_abs_section (stab->output_section)
	      || stab->sec_info_type != ELF_INFO_TYPE_STABS))
	stab = NULL;

      if (stab == NULL
	  && eh == NULL
	  && bed->elf_backend_discard_info == NULL)
	continue;

      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
      cookie.abfd = abfd;
      cookie.sym_hashes = elf_sym_hashes (abfd);
      cookie.bad_symtab = elf_bad_symtab (abfd);
      if (cookie.bad_symtab)
	{
	  cookie.locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
	  cookie.extsymoff = 0;
	}
      else
	{
	  cookie.locsymcount = symtab_hdr->sh_info;
	  cookie.extsymoff = symtab_hdr->sh_info;
	}

      if (bed->s->arch_size == 32)
	cookie.r_sym_shift = 8;
      else
	cookie.r_sym_shift = 32;

      cookie.locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (cookie.locsyms == NULL && cookie.locsymcount != 0)
	{
	  cookie.locsyms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						 cookie.locsymcount, 0,
						 NULL, NULL, NULL);
	  if (cookie.locsyms == NULL)
	    return FALSE;
	}

      if (stab != NULL)
	{
	  cookie.rels = NULL;
	  count = stab->reloc_count;
	  if (count != 0)
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, stab, NULL, NULL,
						     info->keep_memory);
	  if (cookie.rels != NULL)
	    {
	      cookie.rel = cookie.rels;
	      cookie.relend = cookie.rels;
	      cookie.relend += count * bed->s->int_rels_per_ext_rel;
	      if (_bfd_discard_section_stabs (abfd, stab,
					      elf_section_data (stab)->sec_info,
					      bfd_elf_reloc_symbol_deleted_p,
					      &cookie))
		ret = TRUE;
	      if (elf_section_data (stab)->relocs != cookie.rels)
		free (cookie.rels);
	    }
	}

      if (eh != NULL)
	{
	  cookie.rels = NULL;
	  count = eh->reloc_count;
	  if (count != 0)
	    cookie.rels = _bfd_elf_link_read_relocs (abfd, eh, NULL, NULL,
						     info->keep_memory);
	  cookie.rel = cookie.rels;
	  cookie.relend = cookie.rels;
	  if (cookie.rels != NULL)
	    cookie.relend += count * bed->s->int_rels_per_ext_rel;

	  if (_bfd_elf_discard_section_eh_frame (abfd, info, eh,
						 bfd_elf_reloc_symbol_deleted_p,
						 &cookie))
	    ret = TRUE;

	  if (cookie.rels != NULL
	      && elf_section_data (eh)->relocs != cookie.rels)
	    free (cookie.rels);
	}

      if (bed->elf_backend_discard_info != NULL
	  && (*bed->elf_backend_discard_info) (abfd, &cookie, info))
	ret = TRUE;

      if (cookie.locsyms != NULL
	  && symtab_hdr->contents != (unsigned char *) cookie.locsyms)
	{
	  if (! info->keep_memory)
	    free (cookie.locsyms);
	  else
	    symtab_hdr->contents = (unsigned char *) cookie.locsyms;
	}
    }

  if (info->eh_frame_hdr
      && !info->relocatable
      && _bfd_elf_discard_section_eh_frame_hdr (output_bfd, info))
    ret = TRUE;

  return ret;
@


1.51.6.3
log
@	* elflink.c: Include libiberty.h.
	* Makefile.am (elflink.lo): Depend on libiberty.h.
	* Makefile.in: Regenerate.
@
text
@a27 1
#include "libiberty.h"
@


1.51.6.4
log
@	* elflink.c (_bfd_elf_merge_symbol): Treat weak as strong only
	when it is a definition.
@
text
@d890 8
a897 12
  /* If a new weak symbol definition comes from a regular file and the
     old symbol comes from a dynamic library, we treat the new one as
     strong.  Similarly, an old weak symbol definition from a regular
     file is treated as strong when the new symbol comes from a dynamic
     library.  Further, an old weak symbol from a dynamic library is
     treated as strong if the new symbol is from a dynamic library.
     This reflects the way glibc's ld.so works.

     Do this before setting *type_change_ok or *size_change_ok so that
     we warn properly when dynamic library symbols are overridden.  */

  if (newdef && !newdyn && olddyn)
d899 1
a899 1
  if (olddef && newdyn)
@


1.51.6.5
log
@	Merge from mainline:
	2004-08-31  Eric Botcazou  <ebotcazou@@libertysurf.fr>
	* elf.c (special_sections): Add .gnu.linkonce.b modelled on .bss.

	2004-06-09  Alexandre Oliva  <aoliva@@redhat.com>
	* elflink.c (elf_sort_symbol): Compare section id, not pointers.
	(elf_link_add_object_symbols): Likewise.
@
text
@d2703 1
a2703 1
      long sdiff = h1->root.u.def.section->id - h2->root.u.def.section->id;
d3957 1
a3957 1
		  long sdiff = slook->id - h->root.u.def.section->id;
@


1.51.6.6
log
@2004-10-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_link_add_object_symbols): Also clear
	_cooked_size for warning sections.
@
text
@a2950 1
		      s->_cooked_size = 0;
a2976 1
		  s->_cooked_size = 0;
@


1.50
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d120 1
a120 1
  if (! is_elf_hash_table (info))
d147 1
a147 2
  if (! info->traditional_format
      && info->hash->creator->flavour == bfd_target_elf_flavour)
d426 1
a426 1
  if (info->hash->creator->flavour != bfd_target_elf_flavour)
d496 1
a496 1
  if (! is_elf_hash_table (info))
d2208 1
a2208 1
      && is_elf_hash_table (eif->info)
d2278 1
a2278 1
  if (! is_elf_hash_table (eif->info))
@


1.49
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d798 1
a798 1
  /* We need to rememeber if a symbol has a definition in a dynamic
d861 1
a861 1
  /* We need to treat weak definiton right, depending on if there is a
d1130 1
a1130 1
      /* If the predumed common symbol in the dynamic object is
d1260 1
a1260 1
      /* We are overridden by an old defition. We need to check if we
d1419 1
a1419 1
	 overridden by a versioned definiton.  */
@


1.48
log
@	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Modify versioned
	symbol string in place.
@
text
@d2522 28
@


1.47
log
@bfd/
	* elflink.c (_bfd_elf_export_symbol): Adjust for globals and locals
	field changes.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elflink.h (size_dynamic_sections): Likewise.
include/
	* bfdlink.h (struct bfd_elf_version_expr): Remove match field.
	Add wildcard and mask fields.
	(BFD_ELF_VERSION_C_TYPE): Define.
	(BFD_ELF_VERSION_CXX_TYPE): Likewise.
	(BFD_ELF_VERSION_JAVA_TYPE): Likewise.
	(struct bfd_elf_version_expr_head): New.
	(struct bfd_elf_version_tree): Add match field.
	Change type of globals and locals fields
	to struct bfd_elf_version_expr_head.
ld/
	* ldlang.c: Include hashtab.h.
	(lang_vers_match_lang_c, lang_vers_match_lang_cplusplus,
	lang_vers_match_lang_java): Remove.
	(lang_vers_match): New function.
	(lang_new_vers_pattern): Initialize wildcard and mask
	fields, don't initialize match.
	(lang_new_vers_node): Use xcalloc.  Adjust for globals and
	locals field type changes.  Set match field.
	(version_expr_head_hash, version_expr_head_eq): New functions.
	(lang_finalize_version_expr_head): New function.
	(lang_register_vers_node): Call lang_finalize_version_expr_head.
	Search in hash table if not wildcard when looking for duplicates.
	* emultempl/ppc64elf.em (new_vers_pattern): Don't bother with
	duplicate checking.  Initialize all fields of dot_entry from entry
	with the exception of pattern and next.
@
text
@d356 1
a356 1
      char *p, *alc;
a357 1
      bfd_boolean copy;
d395 7
a401 17
      if (p == NULL)
	{
	  alc = NULL;
	  copy = FALSE;
	}
      else
	{
	  size_t len = p - name + 1;

	  alc = bfd_malloc (len);
	  if (alc == NULL)
	    return FALSE;
	  memcpy (alc, name, len - 1);
	  alc[len - 1] = '\0';
	  name = alc;
	  copy = TRUE;
	}
d403 1
a403 1
      indx = _bfd_elf_strtab_add (dynstr, name, copy);
d405 2
a406 2
      if (alc != NULL)
	free (alc);
@


1.46
log
@2003-09-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_link_read_relocs_from_section): Add an argument
	of a pointer to section. Check bad symbol index.
	(_bfd_elf_link_read_relocs): Modify calls to
	elf_link_read_relocs_from_section.
@
text
@d1508 1
a1508 1
	  if (t->globals != NULL)
d1510 3
a1512 5
	      for (d = t->globals; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    goto doit;
		}
d1515 1
a1515 1
	  if (t->locals != NULL)
d1517 3
a1519 5
	      for (d = t->locals ; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    return TRUE;
		}
d1698 2
a1699 6
	      if (t->globals != NULL)
		{
		  for (d = t->globals; d != NULL; d = d->next)
		    if ((*d->match) (d, alc))
		      break;
		}
d1703 1
a1703 1
	      if (d == NULL && t->locals != NULL)
d1705 6
a1710 14
		  for (d = t->locals; d != NULL; d = d->next)
		    {
		      if ((*d->match) (d, alc))
			{
			  if (h->dynindx != -1
			      && info->shared
			      && ! info->export_dynamic)
			    {
			      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
			    }

			  break;
			}
		    }
d1731 1
a1731 1
	  t = bfd_alloc (sinfo->output_bfd, amt);
a1737 1
	  t->next = NULL;
a1738 3
	  t->globals = NULL;
	  t->locals = NULL;
	  t->deps = NULL;
d1784 1
a1784 1
	  if (t->globals != NULL)
d1789 15
a1803 19
	      for (d = t->globals; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    {
		      if (d->symver)
			matched = TRUE;
		      else
			{
			  /* There is a version without definition.  Make
			     the symbol the default definition for this
			     version.  */
			  h->verinfo.vertree = t;
			  local_ver = NULL;
			  d->script = 1;
			  break;
			}
		    }
		}

d1812 1
a1812 1
	  if (t->locals != NULL)
d1814 3
a1816 1
	      for (d = t->locals; d != NULL; d = d->next)
d1818 1
d1820 4
a1823 8
		     explicit, perhaps even global, match.  */
		  if (d->pattern[0] == '*' && d->pattern[1] == '\0')
		    local_ver = t;
		  else if ((*d->match) (d, h->root.root.string))
		    {
		      local_ver = t;
		      break;
		    }
@


1.45
log
@2003-09-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_merge_symbol): Allow type change if
	the old symbol is undefined and the new symbol is defined.
@
text
@d1882 1
d1892 2
d1907 3
d1928 2
d1931 12
d2006 1
a2006 1
  if (!elf_link_read_relocs_from_section (abfd, rel_hdr,
d2011 1
a2011 1
      (abfd,
@


1.44
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d965 2
a966 1
     required at the run time.  */
d971 4
a974 1
      || newweakundef)
@


1.43
log
@	* elflink.c (_bfd_elf_create_dynamic_sections): Mark .dynbss with
	SEC_LINKER_CREATED.
@
text
@d35 1
a35 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d118 1
a118 1
  struct elf_backend_data *bed;
d251 1
a251 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1167 1
a1167 1
      struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1250 1
a1250 1
  struct elf_backend_data *bed;
d1624 1
a1624 1
  struct elf_backend_data *bed;
d1882 1
a1882 1
  struct elf_backend_data *bed;
d1946 1
a1946 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2079 1
a2079 1
  struct elf_backend_data *bed;
d2226 1
a2226 1
      struct elf_backend_data *bed;
d2241 1
a2241 1
      struct elf_backend_data *bed;
d2270 1
a2270 1
	  struct elf_backend_data *bed;
d2289 1
a2289 1
  struct elf_backend_data *bed;
@


1.42
log
@	* elfcode.h: Convert to C90, remove unneeded casts and prototypes.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf.c (sym_is_global): Remove INLINE.
	(align_file_position): Replace INLINE with inline.
	* elfcode.h (elf_swap_dyn_in, elf_swap_dyn_out): Remove INLINE.
	(elf_file_p): Replace INLINE with inline.
@
text
@d312 1
a312 1
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
@


1.41
log
@2003-07-22  H.J. Lu <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_dynamic_symbol_p): Don't return TRUE for
	weak symbols.
@
text
@a27 3
static bfd_boolean elf_link_read_relocs_from_section
  PARAMS ((bfd *, Elf_Internal_Shdr *, PTR, Elf_Internal_Rela *));

d29 1
a29 3
_bfd_elf_create_got_section (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d85 1
a85 2
	     bed->got_symbol_offset, (const char *) NULL, FALSE,
	     bed->collect, &bh)))
d112 1
a112 3
_bfd_elf_link_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d215 2
a216 2
	 (info, abfd, "_DYNAMIC", BSF_GLOBAL, s, (bfd_vma) 0,
	  (const char *) 0, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
d247 1
a247 3
_bfd_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d280 2
a281 3
	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s,
	      (bfd_vma) 0, (const char *) NULL, FALSE,
	      get_elf_backend_data (abfd)->collect, &bh)))
d350 2
a351 3
_bfd_elf_link_record_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d405 1
a405 1
	  alc = bfd_malloc ((bfd_size_type) len);
d431 4
a434 5
bfd_elf_record_link_assignment (output_bfd, info, name, provide)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     const char *name;
     bfd_boolean provide;
d495 3
a497 4
elf_link_record_local_dynamic_symbol (info, input_bfd, input_indx)
     struct bfd_link_info *info;
     bfd *input_bfd;
     long input_indx;
d517 1
a517 1
  entry = (struct elf_link_local_dynamic_entry *) bfd_alloc (input_bfd, amt);
d523 1
a523 2
			     (size_t) 1, (size_t) input_indx,
			     &entry->isym, esym, &eshndx))
d583 3
a585 4
_bfd_elf_link_lookup_local_dynindx (info, input_bfd, input_indx)
     struct bfd_link_info *info;
     bfd *input_bfd;
     long input_indx;
a598 3
static bfd_boolean elf_link_renumber_hash_table_dynsyms
  PARAMS ((struct elf_link_hash_entry *, PTR));

d600 2
a601 3
elf_link_renumber_hash_table_dynsyms (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
d603 1
a603 1
  size_t *count = (size_t *) data;
d620 1
a620 3
_bfd_elf_link_renumber_dynsyms (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d665 12
a676 14
_bfd_elf_merge_symbol (abfd, info, name, sym, psec, pvalue, sym_hash, skip,
		       override, type_change_ok, size_change_ok, dt_needed)
     bfd *abfd;
     struct bfd_link_info *info;
     const char *name;
     Elf_Internal_Sym *sym;
     asection **psec;
     bfd_vma *pvalue;
     struct elf_link_hash_entry **sym_hash;
     bfd_boolean *skip;
     bfd_boolean *override;
     bfd_boolean *type_change_ok;
     bfd_boolean *size_change_ok;
     bfd_boolean dt_needed;
d1233 10
a1242 12
_bfd_elf_add_default_symbol (abfd, info, h, name, sym, psec, value,
			     dynsym, override, dt_needed)
     bfd *abfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     const char *name;
     Elf_Internal_Sym *sym;
     asection **psec;
     bfd_vma *value;
     bfd_boolean *dynsym;
     bfd_boolean override;
     bfd_boolean dt_needed;
d1314 1
a1314 1
	      (bfd_vma) 0, name, FALSE, collect, &bh)))
d1438 1
a1438 1
	      bfd_ind_section_ptr, (bfd_vma) 0, name, FALSE, collect, &bh)))
d1484 1
a1484 3
_bfd_elf_export_symbol (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
d1486 1
a1486 1
  struct elf_info_failed *eif = (struct elf_info_failed *) data;
d1543 2
a1544 3
_bfd_elf_link_find_version_dependencies (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
d1546 1
a1546 1
  struct elf_find_verdep_info *rinfo = (struct elf_find_verdep_info *) data;
d1580 1
a1580 1
      t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->output_bfd, amt);
d1593 1
a1593 1
  a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->output_bfd, amt);
d1620 1
a1620 3
_bfd_elf_link_assign_sym_version (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
d1629 1
a1629 1
  sinfo = (struct elf_assign_sym_version_info *) data;
d1686 1
a1686 1
	      alc = bfd_malloc ((bfd_size_type) len);
d1743 1
a1743 2
	  t = ((struct bfd_elf_version_tree *)
	       bfd_alloc (sinfo->output_bfd, amt));
d1877 4
a1880 6
elf_link_read_relocs_from_section (abfd, shdr, external_relocs,
				   internal_relocs)
     bfd *abfd;
     Elf_Internal_Shdr *shdr;
     PTR external_relocs;
     Elf_Internal_Rela *internal_relocs;
d1883 1
a1883 1
  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d1937 5
a1941 7
_bfd_elf_link_read_relocs (abfd, o, external_relocs, internal_relocs,
			   keep_memory)
     bfd *abfd;
     asection *o;
     PTR external_relocs;
     Elf_Internal_Rela *internal_relocs;
     bfd_boolean keep_memory;
d1944 1
a1944 1
  PTR alloc1 = NULL;
d1963 1
a1963 1
	internal_relocs = (Elf_Internal_Rela *) bfd_alloc (abfd, size);
d1965 1
a1965 1
	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_malloc (size);
d1976 1
a1976 1
      alloc1 = (PTR) bfd_malloc (size);
d2018 3
a2020 4
_bfd_elf_link_size_reloc_section (abfd, rel_hdr, o)
     bfd *abfd;
     Elf_Internal_Shdr *rel_hdr;
     asection *o;
d2042 1
a2042 1
  rel_hdr->contents = (PTR) bfd_zalloc (abfd, rel_hdr->sh_size);
d2053 1
a2053 3
      p = ((struct elf_link_hash_entry **)
	   bfd_zmalloc (num_rel_hashes
			* sizeof (struct elf_link_hash_entry *)));
d2068 4
a2071 6
_bfd_elf_link_output_relocs (output_bfd, input_section, input_rel_hdr,
			     internal_relocs)
     bfd *output_bfd;
     asection *input_section;
     Elf_Internal_Shdr *input_rel_hdr;
     Elf_Internal_Rela *internal_relocs;
d2080 1
a2080 1
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d2143 2
a2144 3
_bfd_elf_fix_symbol_flags (h, eif)
     struct elf_link_hash_entry *h;
     struct elf_info_failed *eif;
d2285 1
a2285 3
_bfd_elf_adjust_dynamic_symbol (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
d2287 1
a2287 1
  struct elf_info_failed *eif = (struct elf_info_failed *) data;
d2377 1
a2377 1
      if (! _bfd_elf_adjust_dynamic_symbol (h->weakdef, (PTR) eif))
d2408 1
a2408 3
_bfd_elf_link_sec_merge_syms (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
d2420 1
a2420 1
      bfd *output_bfd = (bfd *) data;
d2426 1
a2426 1
				    h->root.u.def.value, (bfd_vma) 0);
d2437 3
a2439 4
_bfd_elf_dynamic_symbol_p (h, info, ignore_protected)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
     bfd_boolean ignore_protected;
d2493 3
a2495 4
_bfd_elf_symbol_refs_local_p (h, info, local_protected)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
     bfd_boolean local_protected;
@


1.40
log
@	* elf-bfd.h (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Use..
	(_bfd_elf_symbol_refs_local_p): ..this.  Declare.
	* elflink.c (_bfd_elf_symbol_refs_local_p): New function.
	* elf32-i386.c (elf_i386_relocate_section): Remove h NULL test
	now done in _bfd_elf_symbol_refs_local_p.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@a2521 4
      /* With STV_DEFAULT, weak symbols do not bind locally.  */
      if (h->root.type == bfd_link_hash_undefweak
          || h->root.type == bfd_link_hash_defweak)
	return TRUE;
@


1.39
log
@2003-07-18  H.J. Lu <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_dynamic_symbol_p): Undo the last change.
@
text
@d2537 49
@


1.38
log
@2003-07-18  H.J. Lu <hongjiu.lu@@intel.com>

	* elf-bfd.h (SYMBOL_REFERENCES_LOCAL): Fix a typo.
	(SYMBOL_CALLS_LOCAL): Likewise.

	* elflink.c (_bfd_elf_dynamic_symbol_p): Return TRUE
	immediately if symbol isn't defined locally.
@
text
@a2496 4
  /* If it isn't defined locally, then clearly it's dynamic.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return TRUE;

d2528 4
@


1.37
log
@        * elflink.c (_bfd_elf_dynamic_symbol_p): New.
        * elf-bfd.h (_bfd_elf_dynamic_symbol_p): Declare it.
        (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Use it.
        * elf32-xtensa.c (xtensa_elf_dynamic_symbol_p): Likewise.
        * elf64-alpha.c (alpha_elf_dynamic_symbol_p): Likewise.
        * elf64-hppa.c (elf64_hppa_dynamic_symbol_p): Likewise.
        * elfxx-ia64.c (elfNN_ia64_dynamic_symbol_p): Likewise.
        Update all callers to provide the relocation being resolved.
@
text
@d2497 4
a2531 4

  /* If it isn't defined locally, then clearly it's dynamic.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return TRUE;
@


1.36
log
@	* elf-bfd.h (_bfd_elf_create_linker_section) Don't declare.
	(_bfd_elf_find_pointer_linker_section): Likewise.
	(bfd_elf32_create_pointer_linker_section): Likewise.
	(bfd_elf32_finish_pointer_linker_section): Likewise.
	(bfd_elf64_create_pointer_linker_section): Likewise.
	(bfd_elf64_finish_pointer_linker_section): Likewise.
	(_bfd_elf_make_linker_section_rela): Likewise.
	* elfcode.h (elf_create_pointer_linker_section): Don't define.
	(elf_finish_pointer_linker_section): Likewise.
	* elflink.c (_bfd_elf_make_linker_section_rela): Delete.
	(_bfd_elf_create_linker_section): Move this function..
	(_bfd_elf_find_pointer_linker_section): ..and this..
	* elflink.h (elf_create_pointer_linker_section): ..and this..
	(elf_finish_pointer_linker_section): ..and this..
	* elf32-ppc.c: ..to here, renaming to the following, and adjusting
	calls.
	(elf_create_linker_section): Convert to C90, tidy.
	(elf_find_pointer_linker_section): Likewise.
	(elf_create_pointer_linker_section): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	* elf32-i370.c: Delete #if 0 code.
@
text
@d2477 60
@


1.35
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Use !info->executable
	instead of info->shared where appropriate.
	(bfd_elfNN_size_dynamic_sections, elf_link_output_extsym): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-ppc.c (ppc64_elf_size_dynamic_sections: Likewise.
	* elf64-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections: Likewise.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections: Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections: Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections: Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections: Likewise.
include/
	* bfdlink.h (struct bfd_link_info): Add pie and executable
	bits.
ld/
	* lexsup.c (OPTION_PIE): Define.
	(ld_options): Add -pie and --pic-executable options.
	(parse_args): Handle OPTION_PIE.
	* ldmain.c (main): Initialize link_info.pie and
	link_info.executable.
	* genscripts.sh: Generate PIE scripts.
	* ld.texinfo: Document -pie and --pic-executable options.
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open):
	(gld${EMULATION_NAME}_place_orphan): Likewise.
	(gld${EMULATION_NAME}_get_script): Include PIE scripts.
	* scripttempl/elf.sc: In PIE scripts set . the same way as in
	shared scripts.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Set to yes.
	* emulparams/elf64_ia64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_x86_64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64alpha.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Likewise.
@
text
@a1898 173
/* Create a special linker section, or return a pointer to a linker
   section already created */

elf_linker_section_t *
_bfd_elf_create_linker_section (abfd, info, which, defaults)
     bfd *abfd;
     struct bfd_link_info *info;
     enum elf_linker_section_enum which;
     elf_linker_section_t *defaults;
{
  bfd *dynobj = elf_hash_table (info)->dynobj;
  elf_linker_section_t *lsect;

  /* Record the first bfd section that needs the special section */
  if (!dynobj)
    dynobj = elf_hash_table (info)->dynobj = abfd;

  /* If this is the first time, create the section */
  lsect = elf_linker_section (dynobj, which);
  if (!lsect)
    {
      asection *s;
      bfd_size_type amt = sizeof (elf_linker_section_t);

      lsect = (elf_linker_section_t *) bfd_alloc (dynobj, amt);

      *lsect = *defaults;
      elf_linker_section (dynobj, which) = lsect;
      lsect->which = which;
      lsect->hole_written_p = FALSE;

      /* See if the sections already exist */
      lsect->section = s = bfd_get_section_by_name (dynobj, lsect->name);
      if (!s || (s->flags & defaults->flags) != defaults->flags)
	{
	  lsect->section = s = bfd_make_section_anyway (dynobj, lsect->name);

	  if (s == NULL)
	    return (elf_linker_section_t *)0;

	  bfd_set_section_flags (dynobj, s, defaults->flags);
	  bfd_set_section_alignment (dynobj, s, lsect->alignment);
	}
      else if (bfd_get_section_alignment (dynobj, s) < lsect->alignment)
	bfd_set_section_alignment (dynobj, s, lsect->alignment);

      s->_raw_size = align_power (s->_raw_size, lsect->alignment);

      /* Is there a hole we have to provide?  If so check whether the
	 segment is too big already */
      if (lsect->hole_size)
	{
	  lsect->hole_offset = s->_raw_size;
	  s->_raw_size += lsect->hole_size;
	  if (lsect->hole_offset > lsect->max_hole_offset)
	    {
	      (*_bfd_error_handler)
		(_("%s: Section %s is too large to add hole of %ld bytes"),
		 bfd_get_filename (abfd),
		 lsect->name,
		 (long) lsect->hole_size);

	      bfd_set_error (bfd_error_bad_value);
	      return (elf_linker_section_t *)0;
	    }
	}

#ifdef DEBUG
      fprintf (stderr, "Creating section %s, current size = %ld\n",
	       lsect->name, (long)s->_raw_size);
#endif

      if (lsect->sym_name)
	{
	  struct elf_link_hash_entry *h;
	  struct bfd_link_hash_entry *bh;

#ifdef DEBUG
	  fprintf (stderr, "Adding %s to section %s\n",
		   lsect->sym_name,
		   lsect->name);
#endif
	  bh = bfd_link_hash_lookup (info->hash, lsect->sym_name,
				     FALSE, FALSE, FALSE);

	  if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	      && !(_bfd_generic_link_add_one_symbol
		   (info, abfd, lsect->sym_name, BSF_GLOBAL, s,
		    (lsect->hole_size
		     ? s->_raw_size - lsect->hole_size + lsect->sym_offset
		     : lsect->sym_offset),
		    (const char *) NULL, FALSE,
		    get_elf_backend_data (abfd)->collect, &bh)))
	    return (elf_linker_section_t *) 0;
	  h = (struct elf_link_hash_entry *) bh;

	  if ((defaults->which != LINKER_SECTION_SDATA)
	      && (defaults->which != LINKER_SECTION_SDATA2))
	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_DYNAMIC;

	  h->type = STT_OBJECT;
	  lsect->sym_hash = h;

	  if (info->shared
	      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
	    return (elf_linker_section_t *) 0;
	}
    }

#if 0
  /* This does not make sense.  The sections which may exist in the
     object file have nothing to do with the sections we want to
     create.  */

  /* Find the related sections if they have been created */
  if (lsect->bss_name && !lsect->bss_section)
    lsect->bss_section = bfd_get_section_by_name (dynobj, lsect->bss_name);

  if (lsect->rel_name && !lsect->rel_section)
    lsect->rel_section = bfd_get_section_by_name (dynobj, lsect->rel_name);
#endif

  return lsect;
}

/* Find a linker generated pointer with a given addend and type.  */

elf_linker_section_pointers_t *
_bfd_elf_find_pointer_linker_section (linker_pointers, addend, which)
     elf_linker_section_pointers_t *linker_pointers;
     bfd_vma addend;
     elf_linker_section_enum_t which;
{
  for ( ; linker_pointers != NULL; linker_pointers = linker_pointers->next)
    {
      if (which == linker_pointers->which && addend == linker_pointers->addend)
	return linker_pointers;
    }

  return (elf_linker_section_pointers_t *)0;
}

/* Make the .rela section corresponding to the generated linker section.  */

bfd_boolean
_bfd_elf_make_linker_section_rela (dynobj, lsect, alignment)
     bfd *dynobj;
     elf_linker_section_t *lsect;
     int alignment;
{
  if (lsect->rel_section)
    return TRUE;

  lsect->rel_section = bfd_get_section_by_name (dynobj, lsect->rel_name);
  if (lsect->rel_section == NULL)
    {
      lsect->rel_section = bfd_make_section (dynobj, lsect->rel_name);
      if (lsect->rel_section == NULL
	  || ! bfd_set_section_flags (dynobj,
				      lsect->rel_section,
				      (SEC_ALLOC
				       | SEC_LOAD
				       | SEC_HAS_CONTENTS
				       | SEC_IN_MEMORY
				       | SEC_LINKER_CREATED
				       | SEC_READONLY))
	  || ! bfd_set_section_alignment (dynobj, lsect->rel_section, alignment))
	return FALSE;
    }

  return TRUE;
}

@


1.34
log
@bfd/

2003-05-20  Jakub Jelinek  <jakub@@redhat.com>

	* elflink.h (elf_link_output_extsym): Only issue error about !=
	STV_DEFAULT symbols if they are bfd_link_hash_undefined.

2003-05-20  H.J. Lu <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_merge_symbol): Check ELF_LINK_DYNAMIC_DEF
	when removing the old definition for symbols with non-default
	visibility.

ld/testsuite/

2003-05-20  Jakub Jelinek  <jakub@@redhat.com>

	* ld-elfvsb/common.c: New file.
	* ld-elfvsb/elfvsb.exp: Add common.

2003-05-20  H.J. Lu <hongjiu.lu@@intel.com>

	* ld-elfvsb/sh3.c: New file.
	* ld-elfvsb/test.c: Likewise.

	* ld-elfvsb/elfvsb.exp: Add new weak hidden symbol tests.
@
text
@d97 1
a97 1
      if (info->shared
d147 1
a147 1
  if (! info->shared)
d230 1
a230 1
  if (info->shared
d298 1
a298 1
      if (info->shared
d1763 1
a1763 1
      if (t == NULL && ! info->shared)
@


1.33
log
@	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Use SYMBOL_CALLS_LOCAL
	to trim plt entries.  Move undefweak non-default visibility test..
	(allocate_dynrelocs): ..from here.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Don't test
	dynamic_sections_created here.  Update comment.  Move undefweak
	non-default visibility test..
	(allocate_dynrelocs): ..from here.  Fix comment.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Use SYMBOL_CALLS_LOCAL
	to trim plt entries.  Move undefweak non-default visibility test..
	(allocate_dynrelocs): ..from here.  Fix comment.
	* elflink.h (elf_link_output_extsym): Compare ELF_ST_VISIBILITY with
	STV_DEFAULT rather than comparing with zero.
	* elflink.c (_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.  Format comment.
@
text
@d887 2
a888 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
@


1.32
log
@2003-05-15  H.J. Lu <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_fix_symbol_flags): Also hide protected
	symbol.
@
text
@d858 1
a858 1
      && ELF_ST_VISIBILITY (h->other)
d874 1
a874 1
	   && ELF_ST_VISIBILITY (sym->st_other)
d2430 2
a2431 2
     need a PLT entry. Likewise, if the symbol has non-default
     visibility. If the symbol has hidden or internal visibility, we
d2452 1
a2452 1
  if (ELF_ST_VISIBILITY (h->other)
@


1.31
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d2430 3
a2432 5
     need a PLT entry, and we can accomplish that by forcing it local.
     Likewise, if the symbol has hidden or internal visibility.
     FIXME: It might be that we also do not need a PLT for other
     non-hidden visibilities, but we would have to tell that to the
     backend specifically; we can't just clear PLT-related data here.  */
d2437 1
a2437 2
	  || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	  || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
@


1.30
log
@	* elflink.c (_bfd_elf_create_got_section): Check existing .got
	section flags before concluding that we've already been called.
	Don't use register keyword.
	(_bfd_elf_create_dynamic_sections): Don't use register keyword.
	(_bfd_elf_create_linker_section): Formatting.
@
text
@d28 3
d110 142
a261 16
  int ptralign;

  switch (bed->s->arch_size)
    {
    case 32:
      ptralign = 2;
      break;

    case 64:
      ptralign = 3;
      break;

    default:
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }
d307 1
a307 1
      || ! bfd_set_section_alignment (abfd, s, ptralign))
d344 1
a344 1
	      || ! bfd_set_section_alignment (abfd, s, ptralign))
d438 64
a672 3

/* Create a special linker section, or return a pointer to a linker
   section already created */
d674 15
a688 2
elf_linker_section_t *
_bfd_elf_create_linker_section (abfd, info, which, defaults)
d691 10
a700 2
     enum elf_linker_section_enum which;
     elf_linker_section_t *defaults;
d702 43
a744 2
  bfd *dynobj = elf_hash_table (info)->dynobj;
  elf_linker_section_t *lsect;
d746 1
a746 3
  /* Record the first bfd section that needs the special section */
  if (!dynobj)
    dynobj = elf_hash_table (info)->dynobj = abfd;
d748 1
a748 3
  /* If this is the first time, create the section */
  lsect = elf_linker_section (dynobj, which);
  if (!lsect)
d750 29
a778 2
      asection *s;
      bfd_size_type amt = sizeof (elf_linker_section_t);
d780 2
a781 1
      lsect = (elf_linker_section_t *) bfd_alloc (dynobj, amt);
d783 10
a792 4
      *lsect = *defaults;
      elf_linker_section (dynobj, which) = lsect;
      lsect->which = which;
      lsect->hole_written_p = FALSE;
d794 3
a796 3
      /* See if the sections already exist */
      lsect->section = s = bfd_get_section_by_name (dynobj, lsect->name);
      if (!s || (s->flags & defaults->flags) != defaults->flags)
d798 3
a800 1
	  lsect->section = s = bfd_make_section_anyway (dynobj, lsect->name);
d802 4
a805 2
	  if (s == NULL)
	    return (elf_linker_section_t *)0;
d807 3
a809 2
	  bfd_set_section_flags (dynobj, s, defaults->flags);
	  bfd_set_section_alignment (dynobj, s, lsect->alignment);
a810 2
      else if (bfd_get_section_alignment (dynobj, s) < lsect->alignment)
	bfd_set_section_alignment (dynobj, s, lsect->alignment);
d812 8
a819 1
      s->_raw_size = align_power (s->_raw_size, lsect->alignment);
d821 20
a840 3
      /* Is there a hole we have to provide?  If so check whether the
	 segment is too big already */
      if (lsect->hole_size)
d842 7
a848 12
	  lsect->hole_offset = s->_raw_size;
	  s->_raw_size += lsect->hole_size;
	  if (lsect->hole_offset > lsect->max_hole_offset)
	    {
	      (*_bfd_error_handler)
		(_("%s: Section %s is too large to add hole of %ld bytes"),
		 bfd_get_filename (abfd),
		 lsect->name,
		 (long) lsect->hole_size);

	      bfd_set_error (bfd_error_bad_value);
	      return (elf_linker_section_t *)0;
d850 2
d853 1
d855 39
a893 4
#ifdef DEBUG
      fprintf (stderr, "Creating section %s, current size = %ld\n",
	       lsect->name, (long)s->_raw_size);
#endif
d895 10
a904 1
      if (lsect->sym_name)
d906 25
a930 2
	  struct elf_link_hash_entry *h;
	  struct bfd_link_hash_entry *bh;
d932 89
a1020 7
#ifdef DEBUG
	  fprintf (stderr, "Adding %s to section %s\n",
		   lsect->sym_name,
		   lsect->name);
#endif
	  bh = bfd_link_hash_lookup (info->hash, lsect->sym_name,
				     FALSE, FALSE, FALSE);
d1022 2
a1023 10
	  if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	      && !(_bfd_generic_link_add_one_symbol
		   (info, abfd, lsect->sym_name, BSF_GLOBAL, s,
		    (lsect->hole_size
		     ? s->_raw_size - lsect->hole_size + lsect->sym_offset
		     : lsect->sym_offset),
		    (const char *) NULL, FALSE,
		    get_elf_backend_data (abfd)->collect, &bh)))
	    return (elf_linker_section_t *) 0;
	  h = (struct elf_link_hash_entry *) bh;
d1025 2
a1026 3
	  if ((defaults->which != LINKER_SECTION_SDATA)
	      && (defaults->which != LINKER_SECTION_SDATA2))
	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_DYNAMIC;
d1028 43
a1070 2
	  h->type = STT_OBJECT;
	  lsect->sym_hash = h;
d1072 2
a1073 4
	  if (info->shared
	      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
	    return (elf_linker_section_t *) 0;
	}
d1076 5
a1080 4
#if 0
  /* This does not make sense.  The sections which may exist in the
     object file have nothing to do with the sections we want to
     create.  */
d1082 10
a1091 3
  /* Find the related sections if they have been created */
  if (lsect->bss_name && !lsect->bss_section)
    lsect->bss_section = bfd_get_section_by_name (dynobj, lsect->bss_name);
d1093 926
a2018 3
  if (lsect->rel_name && !lsect->rel_section)
    lsect->rel_section = bfd_get_section_by_name (dynobj, lsect->rel_name);
#endif
d2066 582
@


1.30.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@a27 3
static bfd_boolean elf_link_read_relocs_from_section
  PARAMS ((bfd *, Elf_Internal_Shdr *, PTR, Elf_Internal_Rela *));

d107 1
a107 6
/* Create some sections which will be filled in with dynamic linking
   information.  ABFD is an input file which requires dynamic sections
   to be created.  The dynamic sections take up virtual memory space
   when the final executable is run, so we need to create them before
   addresses are assigned to the output sections.  We work out the
   actual contents and size of these sections later.  */
d110 1
a110 1
_bfd_elf_link_create_dynamic_sections (abfd, info)
d114 4
a117 5
  flagword flags;
  register asection *s;
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  struct elf_backend_data *bed;
d119 1
a119 20
  if (! is_elf_hash_table (info))
    return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    return TRUE;

  /* Make sure that all dynamic sections use the same input BFD.  */
  if (elf_hash_table (info)->dynobj == NULL)
    elf_hash_table (info)->dynobj = abfd;
  else
    abfd = elf_hash_table (info)->dynobj;

  /* Note that we set the SEC_IN_MEMORY flag for all of these
     sections.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
	   | SEC_IN_MEMORY | SEC_LINKER_CREATED);

  /* A dynamically linked executable has a .interp section, but a
     shared library does not.  */
  if (! info->shared)
d121 3
a123 5
      s = bfd_make_section (abfd, ".interp");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
	return FALSE;
    }
d125 3
a127 10
  if (! info->traditional_format
      && info->hash->creator->flavour == bfd_target_elf_flavour)
    {
      s = bfd_make_section (abfd, ".eh_frame_hdr");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;
      elf_hash_table (info)->eh_info.hdr_sec = s;
    }
d129 3
a131 39
  bed = get_elf_backend_data (abfd);

  /* Create sections to hold version informations.  These are removed
     if they are not needed.  */
  s = bfd_make_section (abfd, ".gnu.version_d");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section (abfd, ".gnu.version");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, 1))
    return FALSE;

  s = bfd_make_section (abfd, ".gnu.version_r");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section (abfd, ".dynsym");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section (abfd, ".dynstr");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
    return FALSE;

  /* Create a strtab to hold the dynamic symbol names.  */
  if (elf_hash_table (info)->dynstr == NULL)
    {
      elf_hash_table (info)->dynstr = _bfd_elf_strtab_init ();
      if (elf_hash_table (info)->dynstr == NULL)
	return FALSE;
a133 56
  s = bfd_make_section (abfd, ".dynamic");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  /* The special symbol _DYNAMIC is always set to the start of the
     .dynamic section.  This call occurs before we have processed the
     symbols for any dynamic object, so we don't have to worry about
     overriding a dynamic definition.  We could set _DYNAMIC in a
     linker script, but we only want to define it if we are, in fact,
     creating a .dynamic section.  We don't want to define it if there
     is no .dynamic section, since on some ELF platforms the start up
     code examines it to decide how to initialize the process.  */
  bh = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_DYNAMIC", BSF_GLOBAL, s, (bfd_vma) 0,
	  (const char *) 0, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  if (info->shared
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;

  s = bfd_make_section (abfd, ".hash");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  elf_section_data (s)->this_hdr.sh_entsize = bed->s->sizeof_hash_entry;

  /* Let the backend create the rest of the sections.  This lets the
     backend set the right flags.  The backend will normally create
     the .got and .plt sections.  */
  if (! (*bed->elf_backend_create_dynamic_sections) (abfd, info))
    return FALSE;

  elf_hash_table (info)->dynamic_sections_created = TRUE;

  return TRUE;
}

/* Create dynamic sections when linking against a dynamic object.  */

bfd_boolean
_bfd_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  flagword flags, pltflags;
  asection *s;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

d178 1
a178 1
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
d215 1
a215 1
	      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
a308 64

/* Record an assignment to a symbol made by a linker script.  We need
   this in case some dynamic object refers to this symbol.  */

bfd_boolean
bfd_elf_record_link_assignment (output_bfd, info, name, provide)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     const char *name;
     bfd_boolean provide;
{
  struct elf_link_hash_entry *h;

  if (info->hash->creator->flavour != bfd_target_elf_flavour)
    return TRUE;

  h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, TRUE, FALSE);
  if (h == NULL)
    return FALSE;

  if (h->root.type == bfd_link_hash_new)
    h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;

  /* If this symbol is being provided by the linker script, and it is
     currently defined by a dynamic object, but not by a regular
     object, then mark it as undefined so that the generic linker will
     force the correct value.  */
  if (provide
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    h->root.type = bfd_link_hash_undefined;

  /* If this symbol is not being provided by the linker script, and it is
     currently defined by a dynamic object, but not by a regular object,
     then clear out any version information because the symbol will not be
     associated with the dynamic object any more.  */
  if (!provide
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    h->verinfo.verdef = NULL;

  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;

  if (((h->elf_link_hash_flags & (ELF_LINK_HASH_DEF_DYNAMIC
				  | ELF_LINK_HASH_REF_DYNAMIC)) != 0
       || info->shared)
      && h->dynindx == -1)
    {
      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;

      /* If this is a weak defined symbol, and we know a corresponding
	 real symbol from the same dynamic object, make sure the real
	 symbol is also made into a dynamic symbol.  */
      if (h->weakdef != NULL
	  && h->weakdef->dynindx == -1)
	{
	  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
	    return FALSE;
	}
    }

  return TRUE;
}
d480 3
d484 2
a485 15
/* This function is called when we want to define a new symbol.  It
   handles the various cases which arise when we find a definition in
   a dynamic object, or when there is already a definition in a
   dynamic object.  The new symbol is described by NAME, SYM, PSEC,
   and PVALUE.  We set SYM_HASH to the hash table entry.  We set
   OVERRIDE if the old symbol is overriding a new definition.  We set
   TYPE_CHANGE_OK if it is OK for the type to change.  We set
   SIZE_CHANGE_OK if it is OK for the size to change.  By OK to
   change, we mean that we shouldn't warn if the type or size does
   change. DT_NEEDED indicates if it comes from a DT_NEEDED entry of
   a shared object.  */

bfd_boolean
_bfd_elf_merge_symbol (abfd, info, name, sym, psec, pvalue, sym_hash, skip,
		       override, type_change_ok, size_change_ok, dt_needed)
d488 2
a489 10
     const char *name;
     Elf_Internal_Sym *sym;
     asection **psec;
     bfd_vma *pvalue;
     struct elf_link_hash_entry **sym_hash;
     bfd_boolean *skip;
     bfd_boolean *override;
     bfd_boolean *type_change_ok;
     bfd_boolean *size_change_ok;
     bfd_boolean dt_needed;
d491 2
a492 22
  asection *sec;
  struct elf_link_hash_entry *h;
  struct elf_link_hash_entry *flip;
  int bind;
  bfd *oldbfd;
  bfd_boolean newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
  bfd_boolean newweakdef, oldweakdef, newweakundef, oldweakundef;

  *skip = FALSE;
  *override = FALSE;

  sec = *psec;
  bind = ELF_ST_BIND (sym->st_info);

  if (! bfd_is_und_section (sec))
    h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, FALSE, FALSE);
  else
    h = ((struct elf_link_hash_entry *)
	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, FALSE, FALSE));
  if (h == NULL)
    return FALSE;
  *sym_hash = h;
d494 3
a496 4
  /* This code is for coping with dynamic objects, and is only useful
     if we are doing an ELF link.  */
  if (info->hash->creator != abfd->xvec)
    return TRUE;
d498 3
a500 11
  /* For merging, we only care about real symbols.  */

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* If we just created the symbol, mark it as being an ELF symbol.
     Other than that, there is nothing to do--there is no merge issue
     with a newly defined symbol--so we just return.  */

  if (h->root.type == bfd_link_hash_new)
d502 2
a503 3
      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
      return TRUE;
    }
d505 1
a505 1
  /* OLDBFD is a BFD associated with the existing symbol.  */
d507 4
a510 5
  switch (h->root.type)
    {
    default:
      oldbfd = NULL;
      break;
d512 3
a514 43
    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      oldbfd = h->root.u.undef.abfd;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      oldbfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      oldbfd = h->root.u.c.p->section->owner;
      break;
    }

  /* In cases involving weak versioned symbols, we may wind up trying
     to merge a symbol with itself.  Catch that here, to avoid the
     confusion that results if we try to override a symbol with
     itself.  The additional tests catch cases like
     _GLOBAL_OFFSET_TABLE_, which are regular symbols defined in a
     dynamic object, which we do want to handle here.  */
  if (abfd == oldbfd
      && ((abfd->flags & DYNAMIC) == 0
	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
    return TRUE;

  /* NEWDYN and OLDDYN indicate whether the new or old symbol,
     respectively, is from a dynamic object.  */

  if ((abfd->flags & DYNAMIC) != 0)
    newdyn = TRUE;
  else
    newdyn = FALSE;

  if (oldbfd != NULL)
    olddyn = (oldbfd->flags & DYNAMIC) != 0;
  else
    {
      asection *hsec;

      /* This code handles the special SHN_MIPS_{TEXT,DATA} section
	 indices used by MIPS ELF.  */
      switch (h->root.type)
d516 1
a516 3
	default:
	  hsec = NULL;
	  break;
d518 2
a519 4
	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
	  hsec = h->root.u.def.section;
	  break;
d521 2
a522 3
	case bfd_link_hash_common:
	  hsec = h->root.u.c.p->section;
	  break;
d524 2
d527 1
a527 5
      if (hsec == NULL)
	olddyn = FALSE;
      else
	olddyn = (hsec->symbol->flags & BSF_DYNAMIC) != 0;
    }
d529 13
a541 2
  /* NEWDEF and OLDDEF indicate whether the new or old symbol,
     respectively, appear to be a definition rather than reference.  */
d543 2
a544 28
  if (bfd_is_und_section (sec) || bfd_is_com_section (sec))
    newdef = FALSE;
  else
    newdef = TRUE;

  if (h->root.type == bfd_link_hash_undefined
      || h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_common)
    olddef = FALSE;
  else
    olddef = TRUE;

  /* We need to rememeber if a symbol has a definition in a dynamic
     object or is weak in all dynamic objects. Internal and hidden
     visibility will make it unavailable to dynamic objects.  */
  if (newdyn && (h->elf_link_hash_flags & ELF_LINK_DYNAMIC_DEF) == 0)
    {
      if (!bfd_is_und_section (sec))
	h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_DEF;
      else
	{
	  /* Check if this symbol is weak in all dynamic objects. If it
	     is the first time we see it in a dynamic object, we mark
	     if it is weak. Otherwise, we clear it.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	    { 
	      if (bind == STB_WEAK)
		h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_WEAK;
a545 2
	  else if (bind != STB_WEAK)
	    h->elf_link_hash_flags &= ~ELF_LINK_DYNAMIC_WEAK;
a546 1
    }
d548 4
a551 39
  /* If the old symbol has non-default visibility, we ignore the new
     definition from a dynamic object.  */
  if (newdyn
      && ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
      && !bfd_is_und_section (sec))
    {
      *skip = TRUE;
      /* Make sure this symbol is dynamic.  */
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      /* A protected symbol has external availability. Make sure it is
	 recorded as dynamic.

	 FIXME: Should we check type and size for protected symbol?  */
      if (ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)
	return _bfd_elf_link_record_dynamic_symbol (info, h);
      else
	return TRUE;
    }
  else if (!newdyn
	   && ELF_ST_VISIBILITY (sym->st_other) != STV_DEFAULT
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
    {
      /* If the new symbol with non-default visibility comes from a
	 relocatable file and the old definition comes from a dynamic
	 object, we remove the old definition.  */
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	h = *sym_hash;
      h->root.type = bfd_link_hash_new;
      h->root.u.undef.abfd = NULL;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	}
      /* FIXME: Should we check type and size for protected symbol?  */
      h->size = 0;
      h->type = 0;
      return TRUE;
    }
d553 1
a553 5
  /* We need to treat weak definiton right, depending on if there is a
     definition from a dynamic object.  */
  if (bind == STB_WEAK)
    {
      if (olddef)
d555 2
a556 11
	   newweakdef = TRUE;
	   newweakundef = FALSE;
	}
      else
	{
	   newweakdef = FALSE;
	   newweakundef = TRUE;
	}
    }
  else
    newweakdef = newweakundef = FALSE;
d558 7
a564 5
  /* If the new weak definition comes from a relocatable file and the
     old symbol comes from a dynamic object, we treat the new one as
     strong.  */
  if (newweakdef && !newdyn && olddyn)
    newweakdef = FALSE;
d566 10
a575 12
  if (h->root.type == bfd_link_hash_defweak)
    {
      oldweakdef = TRUE;
      oldweakundef = FALSE;
    }
  else if (h->root.type == bfd_link_hash_undefweak)
    {
      oldweakdef = FALSE;
      oldweakundef = TRUE;
    }
  else
    oldweakdef = oldweakundef = FALSE;
d577 3
a579 89
  /* If the old weak definition comes from a relocatable file and the
     new symbol comes from a dynamic object, we treat the old one as
     strong.  */
  if (oldweakdef && !olddyn && newdyn)
    oldweakdef = FALSE;

  /* NEWDYNCOMMON and OLDDYNCOMMON indicate whether the new or old
     symbol, respectively, appears to be a common symbol in a dynamic
     object.  If a symbol appears in an uninitialized section, and is
     not weak, and is not a function, then it may be a common symbol
     which was resolved when the dynamic object was created.  We want
     to treat such symbols specially, because they raise special
     considerations when setting the symbol size: if the symbol
     appears as a common symbol in a regular object, and the size in
     the regular object is larger, we must make sure that we use the
     larger size.  This problematic case can always be avoided in C,
     but it must be handled correctly when using Fortran shared
     libraries.

     Note that if NEWDYNCOMMON is set, NEWDEF will be set, and
     likewise for OLDDYNCOMMON and OLDDEF.

     Note that this test is just a heuristic, and that it is quite
     possible to have an uninitialized symbol in a shared object which
     is really a definition, rather than a common symbol.  This could
     lead to some minor confusion when the symbol really is a common
     symbol in some regular object.  However, I think it will be
     harmless.  */

  if (newdyn
      && newdef
      && (sec->flags & SEC_ALLOC) != 0
      && (sec->flags & SEC_LOAD) == 0
      && sym->st_size > 0
      && !newweakdef
      && !newweakundef
      && ELF_ST_TYPE (sym->st_info) != STT_FUNC)
    newdyncommon = TRUE;
  else
    newdyncommon = FALSE;

  if (olddyn
      && olddef
      && h->root.type == bfd_link_hash_defined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->root.u.def.section->flags & SEC_ALLOC) != 0
      && (h->root.u.def.section->flags & SEC_LOAD) == 0
      && h->size > 0
      && h->type != STT_FUNC)
    olddyncommon = TRUE;
  else
    olddyncommon = FALSE;

  /* It's OK to change the type if either the existing symbol or the
     new symbol is weak unless it comes from a DT_NEEDED entry of
     a shared object, in which case, the DT_NEEDED entry may not be
     required at the run time.  */

  if ((! dt_needed && oldweakdef)
      || oldweakundef
      || newweakdef
      || newweakundef)
    *type_change_ok = TRUE;

  /* It's OK to change the size if either the existing symbol or the
     new symbol is weak, or if the old symbol is undefined.  */

  if (*type_change_ok
      || h->root.type == bfd_link_hash_undefined)
    *size_change_ok = TRUE;

  /* If both the old and the new symbols look like common symbols in a
     dynamic object, set the size of the symbol to the larger of the
     two.  */

  if (olddyncommon
      && newdyncommon
      && sym->st_size != h->size)
    {
      /* Since we think we have two common symbols, issue a multiple
	 common warning if desired.  Note that we only warn if the
	 size is different.  If the size is the same, we simply let
	 the old symbol override the new one as normally happens with
	 symbols defined in dynamic objects.  */

      if (! ((*info->callbacks->multiple_common)
	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
	return FALSE;
d581 2
a582 2
      if (sym->st_size > h->size)
	h->size = sym->st_size;
d584 4
a587 1
      *size_change_ok = TRUE;
d590 8
a597 43
  /* If we are looking at a dynamic object, and we have found a
     definition, we need to see if the symbol was already defined by
     some other object.  If so, we want to use the existing
     definition, and we do not want to report a multiple symbol
     definition error; we do this by clobbering *PSEC to be
     bfd_und_section_ptr.

     We treat a common symbol as a definition if the symbol in the
     shared library is a function, since common symbols always
     represent variables; this can cause confusion in principle, but
     any such confusion would seem to indicate an erroneous program or
     shared library.  We also permit a common symbol in a regular
     object to override a weak symbol in a shared object.

     We prefer a non-weak definition in a shared library to a weak
     definition in the executable unless it comes from a DT_NEEDED
     entry of a shared object, in which case, the DT_NEEDED entry
     may not be required at the run time.  */

  if (newdyn
      && newdef
      && (olddef
	  || (h->root.type == bfd_link_hash_common
	      && (newweakdef
		  || newweakundef
		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC)))
      && (!oldweakdef
	  || dt_needed
	  || newweakdef
	  || newweakundef))
    {
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;

      *psec = sec = bfd_und_section_ptr;
      *size_change_ok = TRUE;

      /* If we get here when the old symbol is a common symbol, then
	 we are explicitly letting it override a weak symbol or
	 function in a dynamic object, and we don't want to warn about
	 a type change.  If the old symbol is a defined symbol, a type
	 change warning may still be appropriate.  */
d599 3
a601 3
      if (h->root.type == bfd_link_hash_common)
	*type_change_ok = TRUE;
    }
d603 4
a606 948
  /* Handle the special case of an old common symbol merging with a
     new symbol which looks like a common symbol in a shared object.
     We change *PSEC and *PVALUE to make the new symbol look like a
     common symbol, and let _bfd_generic_link_add_one_symbol will do
     the right thing.  */

  if (newdyncommon
      && h->root.type == bfd_link_hash_common)
    {
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;
      *pvalue = sym->st_size;
      *psec = sec = bfd_com_section_ptr;
      *size_change_ok = TRUE;
    }

  /* If the old symbol is from a dynamic object, and the new symbol is
     a definition which is not from a dynamic object, then the new
     symbol overrides the old symbol.  Symbols from regular files
     always take precedence over symbols from dynamic objects, even if
     they are defined after the dynamic object in the link.

     As above, we again permit a common symbol in a regular object to
     override a definition in a shared object if the shared object
     symbol is a function or is weak.

     As above, we permit a non-weak definition in a shared object to
     override a weak definition in a regular object.  */

  flip = NULL;
  if (! newdyn
      && (newdef
	  || (bfd_is_com_section (sec)
	      && (oldweakdef || h->type == STT_FUNC)))
      && olddyn
      && olddef
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && ((!newweakdef && !newweakundef) || oldweakdef))
    {
      /* Change the hash table entry to undefined, and let
	 _bfd_generic_link_add_one_symbol do the right thing with the
	 new definition.  */

      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;
      *size_change_ok = TRUE;

      olddef = FALSE;
      olddyncommon = FALSE;

      /* We again permit a type change when a common symbol may be
	 overriding a function.  */

      if (bfd_is_com_section (sec))
	*type_change_ok = TRUE;

      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	/* This union may have been set to be non-NULL when this symbol
	   was seen in a dynamic object.  We must force the union to be
	   NULL, so that it is correct for a regular symbol.  */
	h->verinfo.vertree = NULL;
    }

  /* Handle the special case of a new common symbol merging with an
     old symbol that looks like it might be a common symbol defined in
     a shared object.  Note that we have already handled the case in
     which a new common symbol should simply override the definition
     in the shared library.  */

  if (! newdyn
      && bfd_is_com_section (sec)
      && olddyncommon)
    {
      /* It would be best if we could set the hash table entry to a
	 common symbol, but we don't know what to use for the section
	 or the alignment.  */
      if (! ((*info->callbacks->multiple_common)
	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
	return FALSE;

      /* If the predumed common symbol in the dynamic object is
	 larger, pretend that the new symbol has its size.  */

      if (h->size > *pvalue)
	*pvalue = h->size;

      /* FIXME: We no longer know the alignment required by the symbol
	 in the dynamic object, so we just wind up using the one from
	 the regular object.  */

      olddef = FALSE;
      olddyncommon = FALSE;

      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;

      *size_change_ok = TRUE;
      *type_change_ok = TRUE;

      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	h->verinfo.vertree = NULL;
    }

  if (flip != NULL)
    {
      /* Handle the case where we had a versioned symbol in a dynamic
	 library and now find a definition in a normal object.  In this
	 case, we make the versioned symbol point to the normal one.  */
      struct elf_backend_data *bed = get_elf_backend_data (abfd);
      flip->root.type = h->root.type;
      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) flip;
      (*bed->elf_backend_copy_indirect_symbol) (bed, flip, h);
      flip->root.u.undef.abfd = h->root.u.undef.abfd;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  flip->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	}
    }

  /* Handle the special case of a weak definition in a regular object
     followed by a non-weak definition in a shared object.  In this
     case, we prefer the definition in the shared object unless it
     comes from a DT_NEEDED entry of a shared object, in which case,
     the DT_NEEDED entry may not be required at the run time.  */
  if (olddef
      && ! dt_needed
      && oldweakdef
      && newdef
      && newdyn
      && !newweakdef
      && !newweakundef)
    {
      /* To make this work we have to frob the flags so that the rest
	 of the code does not think we are using the regular
	 definition.  */
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
      else if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      h->elf_link_hash_flags &= ~ (ELF_LINK_HASH_DEF_REGULAR
				   | ELF_LINK_HASH_DEF_DYNAMIC);

      /* If H is the target of an indirection, we want the caller to
	 use H rather than the indirect symbol.  Otherwise if we are
	 defining a new indirect symbol we will wind up attaching it
	 to the entry we are overriding.  */
      *sym_hash = h;
    }

  /* Handle the special case of a non-weak definition in a shared
     object followed by a weak definition in a regular object.  In
     this case we prefer the definition in the shared object.  To make
     this work we have to tell the caller to not treat the new symbol
     as a definition.  */
  if (olddef
      && olddyn
      && !oldweakdef
      && newdef
      && ! newdyn
      && (newweakdef || newweakundef))
    *override = TRUE;

  return TRUE;
}

/* This function is called to create an indirect symbol from the
   default for the symbol with the default version if needed. The
   symbol is described by H, NAME, SYM, PSEC, VALUE, and OVERRIDE.  We
   set DYNSYM if the new indirect symbol is dynamic. DT_NEEDED
   indicates if it comes from a DT_NEEDED entry of a shared object.  */

bfd_boolean
_bfd_elf_add_default_symbol (abfd, info, h, name, sym, psec, value,
			     dynsym, override, dt_needed)
     bfd *abfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     const char *name;
     Elf_Internal_Sym *sym;
     asection **psec;
     bfd_vma *value;
     bfd_boolean *dynsym;
     bfd_boolean override;
     bfd_boolean dt_needed;
{
  bfd_boolean type_change_ok;
  bfd_boolean size_change_ok;
  bfd_boolean skip;
  char *shortname;
  struct elf_link_hash_entry *hi;
  struct bfd_link_hash_entry *bh;
  struct elf_backend_data *bed;
  bfd_boolean collect;
  bfd_boolean dynamic;
  char *p;
  size_t len, shortlen;
  asection *sec;

  /* If this symbol has a version, and it is the default version, we
     create an indirect symbol from the default name to the fully
     decorated name.  This will cause external references which do not
     specify a version to be bound to this version of the symbol.  */
  p = strchr (name, ELF_VER_CHR);
  if (p == NULL || p[1] != ELF_VER_CHR)
    return TRUE;

  if (override)
    {
      /* We are overridden by an old defition. We need to check if we
	 need to create the indirect symbol from the default name.  */
      hi = elf_link_hash_lookup (elf_hash_table (info), name, TRUE,
				 FALSE, FALSE);
      BFD_ASSERT (hi != NULL);
      if (hi == h)
	return TRUE;
      while (hi->root.type == bfd_link_hash_indirect
	     || hi->root.type == bfd_link_hash_warning)
	{
	  hi = (struct elf_link_hash_entry *) hi->root.u.i.link;
	  if (hi == h)
	    return TRUE;
	}
    }

  bed = get_elf_backend_data (abfd);
  collect = bed->collect;
  dynamic = (abfd->flags & DYNAMIC) != 0;

  shortlen = p - name;
  shortname = bfd_hash_allocate (&info->hash->table, shortlen + 1);
  if (shortname == NULL)
    return FALSE;
  memcpy (shortname, name, shortlen);
  shortname[shortlen] = '\0';

  /* We are going to create a new symbol.  Merge it with any existing
     symbol with this name.  For the purposes of the merge, act as
     though we were defining the symbol we just defined, although we
     actually going to define an indirect symbol.  */
  type_change_ok = FALSE;
  size_change_ok = FALSE;
  sec = *psec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
			      &hi, &skip, &override, &type_change_ok,
			      &size_change_ok, dt_needed))
    return FALSE;

  if (skip)
    goto nondefault;

  if (! override)
    {
      bh = &hi->root;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, shortname, BSF_INDIRECT, bfd_ind_section_ptr,
	      (bfd_vma) 0, name, FALSE, collect, &bh)))
	return FALSE;
      hi = (struct elf_link_hash_entry *) bh;
    }
  else
    {
      /* In this case the symbol named SHORTNAME is overriding the
	 indirect symbol we want to add.  We were planning on making
	 SHORTNAME an indirect symbol referring to NAME.  SHORTNAME
	 is the name without a version.  NAME is the fully versioned
	 name, and it is the default version.

	 Overriding means that we already saw a definition for the
	 symbol SHORTNAME in a regular object, and it is overriding
	 the symbol defined in the dynamic object.

	 When this happens, we actually want to change NAME, the
	 symbol we just added, to refer to SHORTNAME.  This will cause
	 references to NAME in the shared object to become references
	 to SHORTNAME in the regular object.  This is what we expect
	 when we override a function in a shared object: that the
	 references in the shared object will be mapped to the
	 definition in the regular object.  */

      while (hi->root.type == bfd_link_hash_indirect
	     || hi->root.type == bfd_link_hash_warning)
	hi = (struct elf_link_hash_entry *) hi->root.u.i.link;

      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &=~ ELF_LINK_HASH_DEF_DYNAMIC;
	  hi->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	  if (hi->elf_link_hash_flags
	      & (ELF_LINK_HASH_REF_REGULAR
		 | ELF_LINK_HASH_DEF_REGULAR))
	    {
	      if (! _bfd_elf_link_record_dynamic_symbol (info, hi))
		return FALSE;
	    }
	}

      /* Now set HI to H, so that the following code will set the
	 other fields correctly.  */
      hi = h;
    }

  /* If there is a duplicate definition somewhere, then HI may not
     point to an indirect symbol.  We will have reported an error to
     the user in that case.  */

  if (hi->root.type == bfd_link_hash_indirect)
    {
      struct elf_link_hash_entry *ht;

      /* If the symbol became indirect, then we assume that we have
	 not seen a definition before.  */
      BFD_ASSERT ((hi->elf_link_hash_flags
		   & (ELF_LINK_HASH_DEF_DYNAMIC
		      | ELF_LINK_HASH_DEF_REGULAR)) == 0);

      ht = (struct elf_link_hash_entry *) hi->root.u.i.link;
      (*bed->elf_backend_copy_indirect_symbol) (bed, ht, hi);

      /* See if the new flags lead us to realize that the symbol must
	 be dynamic.  */
      if (! *dynsym)
	{
	  if (! dynamic)
	    {
	      if (info->shared
		  || ((hi->elf_link_hash_flags
		       & ELF_LINK_HASH_REF_DYNAMIC) != 0))
		*dynsym = TRUE;
	    }
	  else
	    {
	      if ((hi->elf_link_hash_flags
		   & ELF_LINK_HASH_REF_REGULAR) != 0)
		*dynsym = TRUE;
	    }
	}
    }

  /* We also need to define an indirection from the nondefault version
     of the symbol.  */

nondefault:
  len = strlen (name);
  shortname = bfd_hash_allocate (&info->hash->table, len);
  if (shortname == NULL)
    return FALSE;
  memcpy (shortname, name, shortlen);
  memcpy (shortname + shortlen, p + 1, len - shortlen);

  /* Once again, merge with any existing symbol.  */
  type_change_ok = FALSE;
  size_change_ok = FALSE;
  sec = *psec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
			      &hi, &skip, &override, &type_change_ok,
			      &size_change_ok, dt_needed))
    return FALSE;

  if (skip)
    return TRUE;

  if (override)
    {
      /* Here SHORTNAME is a versioned name, so we don't expect to see
	 the type of override we do in the case above unless it is
	 overridden by a versioned definiton.  */
      if (hi->root.type != bfd_link_hash_defined
	  && hi->root.type != bfd_link_hash_defweak)
	(*_bfd_error_handler)
	  (_("%s: warning: unexpected redefinition of indirect versioned symbol `%s'"),
	   bfd_archive_filename (abfd), shortname);
    }
  else
    {
      bh = &hi->root;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, shortname, BSF_INDIRECT,
	      bfd_ind_section_ptr, (bfd_vma) 0, name, FALSE, collect, &bh)))
	return FALSE;
      hi = (struct elf_link_hash_entry *) bh;

      /* If there is a duplicate definition somewhere, then HI may not
	 point to an indirect symbol.  We will have reported an error
	 to the user in that case.  */

      if (hi->root.type == bfd_link_hash_indirect)
	{
	  /* If the symbol became indirect, then we assume that we have
	     not seen a definition before.  */
	  BFD_ASSERT ((hi->elf_link_hash_flags
		       & (ELF_LINK_HASH_DEF_DYNAMIC
			  | ELF_LINK_HASH_DEF_REGULAR)) == 0);

	  (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);

	  /* See if the new flags lead us to realize that the symbol
	     must be dynamic.  */
	  if (! *dynsym)
	    {
	      if (! dynamic)
		{
		  if (info->shared
		      || ((hi->elf_link_hash_flags
			   & ELF_LINK_HASH_REF_DYNAMIC) != 0))
		    *dynsym = TRUE;
		}
	      else
		{
		  if ((hi->elf_link_hash_flags
		       & ELF_LINK_HASH_REF_REGULAR) != 0)
		    *dynsym = TRUE;
		}
	    }
	}
    }

  return TRUE;
}

/* This routine is used to export all defined symbols into the dynamic
   symbol table.  It is called via elf_link_hash_traverse.  */

bfd_boolean
_bfd_elf_export_symbol (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_info_failed *eif = (struct elf_info_failed *) data;

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx == -1
      && (h->elf_link_hash_flags
	  & (ELF_LINK_HASH_DEF_REGULAR | ELF_LINK_HASH_REF_REGULAR)) != 0)
    {
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;

      for (t = eif->verdefs; t != NULL; t = t->next)
	{
	  if (t->globals != NULL)
	    {
	      for (d = t->globals; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    goto doit;
		}
	    }

	  if (t->locals != NULL)
	    {
	      for (d = t->locals ; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    return TRUE;
		}
	    }
	}

      if (!eif->verdefs)
	{
	doit:
	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
	    {
	      eif->failed = TRUE;
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Look through the symbols which are defined in other shared
   libraries and referenced here.  Update the list of version
   dependencies.  This will be put into the .gnu.version_r section.
   This function is called via elf_link_hash_traverse.  */

bfd_boolean
_bfd_elf_link_find_version_dependencies (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_find_verdep_info *rinfo = (struct elf_find_verdep_info *) data;
  Elf_Internal_Verneed *t;
  Elf_Internal_Vernaux *a;
  bfd_size_type amt;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* We only care about symbols defined in shared objects with version
     information.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
      || h->dynindx == -1
      || h->verinfo.verdef == NULL)
    return TRUE;

  /* See if we already know about this version.  */
  for (t = elf_tdata (rinfo->output_bfd)->verref; t != NULL; t = t->vn_nextref)
    {
      if (t->vn_bfd != h->verinfo.verdef->vd_bfd)
	continue;

      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
	if (a->vna_nodename == h->verinfo.verdef->vd_nodename)
	  return TRUE;

      break;
    }

  /* This is a new version.  Add it to tree we are building.  */

  if (t == NULL)
    {
      amt = sizeof *t;
      t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->output_bfd, amt);
      if (t == NULL)
	{
	  rinfo->failed = TRUE;
	  return FALSE;
	}

      t->vn_bfd = h->verinfo.verdef->vd_bfd;
      t->vn_nextref = elf_tdata (rinfo->output_bfd)->verref;
      elf_tdata (rinfo->output_bfd)->verref = t;
    }

  amt = sizeof *a;
  a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->output_bfd, amt);

  /* Note that we are copying a string pointer here, and testing it
     above.  If bfd_elf_string_from_elf_section is ever changed to
     discard the string data when low in memory, this will have to be
     fixed.  */
  a->vna_nodename = h->verinfo.verdef->vd_nodename;

  a->vna_flags = h->verinfo.verdef->vd_flags;
  a->vna_nextptr = t->vn_auxptr;

  h->verinfo.verdef->vd_exp_refno = rinfo->vers;
  ++rinfo->vers;

  a->vna_other = h->verinfo.verdef->vd_exp_refno + 1;

  t->vn_auxptr = a;

  return TRUE;
}

/* Figure out appropriate versions for all the symbols.  We may not
   have the version number script until we have read all of the input
   files, so until that point we don't know which symbols should be
   local.  This function is called via elf_link_hash_traverse.  */

bfd_boolean
_bfd_elf_link_assign_sym_version (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_assign_sym_version_info *sinfo;
  struct bfd_link_info *info;
  struct elf_backend_data *bed;
  struct elf_info_failed eif;
  char *p;
  bfd_size_type amt;

  sinfo = (struct elf_assign_sym_version_info *) data;
  info = sinfo->info;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Fix the symbol flags.  */
  eif.failed = FALSE;
  eif.info = info;
  if (! _bfd_elf_fix_symbol_flags (h, &eif))
    {
      if (eif.failed)
	sinfo->failed = TRUE;
      return FALSE;
    }

  /* We only need version numbers for symbols defined in regular
     objects.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return TRUE;

  bed = get_elf_backend_data (sinfo->output_bfd);
  p = strchr (h->root.root.string, ELF_VER_CHR);
  if (p != NULL && h->verinfo.vertree == NULL)
    {
      struct bfd_elf_version_tree *t;
      bfd_boolean hidden;

      hidden = TRUE;

      /* There are two consecutive ELF_VER_CHR characters if this is
	 not a hidden symbol.  */
      ++p;
      if (*p == ELF_VER_CHR)
	{
	  hidden = FALSE;
	  ++p;
	}

      /* If there is no version string, we can just return out.  */
      if (*p == '\0')
	{
	  if (hidden)
	    h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
	  return TRUE;
	}

      /* Look for the version.  If we find it, it is no longer weak.  */
      for (t = sinfo->verdefs; t != NULL; t = t->next)
	{
	  if (strcmp (t->name, p) == 0)
	    {
	      size_t len;
	      char *alc;
	      struct bfd_elf_version_expr *d;

	      len = p - h->root.root.string;
	      alc = bfd_malloc ((bfd_size_type) len);
	      if (alc == NULL)
		return FALSE;
	      memcpy (alc, h->root.root.string, len - 1);
	      alc[len - 1] = '\0';
	      if (alc[len - 2] == ELF_VER_CHR)
		alc[len - 2] = '\0';

	      h->verinfo.vertree = t;
	      t->used = TRUE;
	      d = NULL;

	      if (t->globals != NULL)
		{
		  for (d = t->globals; d != NULL; d = d->next)
		    if ((*d->match) (d, alc))
		      break;
		}

	      /* See if there is anything to force this symbol to
		 local scope.  */
	      if (d == NULL && t->locals != NULL)
		{
		  for (d = t->locals; d != NULL; d = d->next)
		    {
		      if ((*d->match) (d, alc))
			{
			  if (h->dynindx != -1
			      && info->shared
			      && ! info->export_dynamic)
			    {
			      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
			    }

			  break;
			}
		    }
		}

	      free (alc);
	      break;
	    }
	}

      /* If we are building an application, we need to create a
	 version node for this version.  */
      if (t == NULL && ! info->shared)
	{
	  struct bfd_elf_version_tree **pp;
	  int version_index;

	  /* If we aren't going to export this symbol, we don't need
	     to worry about it.  */
	  if (h->dynindx == -1)
	    return TRUE;

	  amt = sizeof *t;
	  t = ((struct bfd_elf_version_tree *)
	       bfd_alloc (sinfo->output_bfd, amt));
	  if (t == NULL)
	    {
	      sinfo->failed = TRUE;
	      return FALSE;
	    }

	  t->next = NULL;
	  t->name = p;
	  t->globals = NULL;
	  t->locals = NULL;
	  t->deps = NULL;
	  t->name_indx = (unsigned int) -1;
	  t->used = TRUE;

	  version_index = 1;
	  /* Don't count anonymous version tag.  */
	  if (sinfo->verdefs != NULL && sinfo->verdefs->vernum == 0)
	    version_index = 0;
	  for (pp = &sinfo->verdefs; *pp != NULL; pp = &(*pp)->next)
	    ++version_index;
	  t->vernum = version_index;

	  *pp = t;

	  h->verinfo.vertree = t;
	}
      else if (t == NULL)
	{
	  /* We could not find the version for a symbol when
	     generating a shared archive.  Return an error.  */
	  (*_bfd_error_handler)
	    (_("%s: undefined versioned symbol name %s"),
	     bfd_get_filename (sinfo->output_bfd), h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  sinfo->failed = TRUE;
	  return FALSE;
	}

      if (hidden)
	h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
    }

  /* If we don't have a version for this symbol, see if we can find
     something.  */
  if (h->verinfo.vertree == NULL && sinfo->verdefs != NULL)
    {
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_tree *local_ver;
      struct bfd_elf_version_expr *d;

      /* See if can find what version this symbol is in.  If the
	 symbol is supposed to be local, then don't actually register
	 it.  */
      local_ver = NULL;
      for (t = sinfo->verdefs; t != NULL; t = t->next)
	{
	  if (t->globals != NULL)
	    {
	      bfd_boolean matched;

	      matched = FALSE;
	      for (d = t->globals; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    {
		      if (d->symver)
			matched = TRUE;
		      else
			{
			  /* There is a version without definition.  Make
			     the symbol the default definition for this
			     version.  */
			  h->verinfo.vertree = t;
			  local_ver = NULL;
			  d->script = 1;
			  break;
			}
		    }
		}

	      if (d != NULL)
		break;
	      else if (matched)
		/* There is no undefined version for this symbol. Hide the
		   default one.  */
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
	    }

	  if (t->locals != NULL)
	    {
	      for (d = t->locals; d != NULL; d = d->next)
		{
		  /* If the match is "*", keep looking for a more
		     explicit, perhaps even global, match.  */
		  if (d->pattern[0] == '*' && d->pattern[1] == '\0')
		    local_ver = t;
		  else if ((*d->match) (d, h->root.root.string))
		    {
		      local_ver = t;
		      break;
		    }
		}

	      if (d != NULL)
		break;
	    }
	}

      if (local_ver != NULL)
	{
	  h->verinfo.vertree = local_ver;
	  if (h->dynindx != -1
	      && info->shared
	      && ! info->export_dynamic)
	    {
	      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
	    }
	}
    }

  return TRUE;
}

/* Create a special linker section, or return a pointer to a linker
   section already created */

elf_linker_section_t *
_bfd_elf_create_linker_section (abfd, info, which, defaults)
     bfd *abfd;
     struct bfd_link_info *info;
     enum elf_linker_section_enum which;
     elf_linker_section_t *defaults;
{
  bfd *dynobj = elf_hash_table (info)->dynobj;
  elf_linker_section_t *lsect;

  /* Record the first bfd section that needs the special section */
  if (!dynobj)
    dynobj = elf_hash_table (info)->dynobj = abfd;

  /* If this is the first time, create the section */
  lsect = elf_linker_section (dynobj, which);
  if (!lsect)
    {
      asection *s;
      bfd_size_type amt = sizeof (elf_linker_section_t);

      lsect = (elf_linker_section_t *) bfd_alloc (dynobj, amt);

      *lsect = *defaults;
      elf_linker_section (dynobj, which) = lsect;
      lsect->which = which;
      lsect->hole_written_p = FALSE;

      /* See if the sections already exist */
      lsect->section = s = bfd_get_section_by_name (dynobj, lsect->name);
      if (!s || (s->flags & defaults->flags) != defaults->flags)
	{
	  lsect->section = s = bfd_make_section_anyway (dynobj, lsect->name);

	  if (s == NULL)
	    return (elf_linker_section_t *)0;

	  bfd_set_section_flags (dynobj, s, defaults->flags);
	  bfd_set_section_alignment (dynobj, s, lsect->alignment);
	}
      else if (bfd_get_section_alignment (dynobj, s) < lsect->alignment)
	bfd_set_section_alignment (dynobj, s, lsect->alignment);

      s->_raw_size = align_power (s->_raw_size, lsect->alignment);

      /* Is there a hole we have to provide?  If so check whether the
	 segment is too big already */
      if (lsect->hole_size)
	{
	  lsect->hole_offset = s->_raw_size;
	  s->_raw_size += lsect->hole_size;
	  if (lsect->hole_offset > lsect->max_hole_offset)
	    {
	      (*_bfd_error_handler)
		(_("%s: Section %s is too large to add hole of %ld bytes"),
		 bfd_get_filename (abfd),
		 lsect->name,
		 (long) lsect->hole_size);

	      bfd_set_error (bfd_error_bad_value);
	      return (elf_linker_section_t *)0;
	    }
	}

#ifdef DEBUG
      fprintf (stderr, "Creating section %s, current size = %ld\n",
	       lsect->name, (long)s->_raw_size);
#endif

      if (lsect->sym_name)
	{
	  struct elf_link_hash_entry *h;
	  struct bfd_link_hash_entry *bh;

#ifdef DEBUG
	  fprintf (stderr, "Adding %s to section %s\n",
		   lsect->sym_name,
		   lsect->name);
#endif
	  bh = bfd_link_hash_lookup (info->hash, lsect->sym_name,
				     FALSE, FALSE, FALSE);

	  if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	      && !(_bfd_generic_link_add_one_symbol
		   (info, abfd, lsect->sym_name, BSF_GLOBAL, s,
		    (lsect->hole_size
		     ? s->_raw_size - lsect->hole_size + lsect->sym_offset
		     : lsect->sym_offset),
		    (const char *) NULL, FALSE,
		    get_elf_backend_data (abfd)->collect, &bh)))
	    return (elf_linker_section_t *) 0;
	  h = (struct elf_link_hash_entry *) bh;

	  if ((defaults->which != LINKER_SECTION_SDATA)
	      && (defaults->which != LINKER_SECTION_SDATA2))
	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_DYNAMIC;

	  h->type = STT_OBJECT;
	  lsect->sym_hash = h;

	  if (info->shared
	      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
	    return (elf_linker_section_t *) 0;
	}
    }

#if 0
  /* This does not make sense.  The sections which may exist in the
     object file have nothing to do with the sections we want to
     create.  */

  /* Find the related sections if they have been created */
  if (lsect->bss_name && !lsect->bss_section)
    lsect->bss_section = bfd_get_section_by_name (dynobj, lsect->bss_name);

  if (lsect->rel_name && !lsect->rel_section)
    lsect->rel_section = bfd_get_section_by_name (dynobj, lsect->rel_name);
#endif

  return lsect;
}

/* Find a linker generated pointer with a given addend and type.  */
a648 579
    }

  return TRUE;
}

/* Read and swap the relocs from the section indicated by SHDR.  This
   may be either a REL or a RELA section.  The relocations are
   translated into RELA relocations and stored in INTERNAL_RELOCS,
   which should have already been allocated to contain enough space.
   The EXTERNAL_RELOCS are a buffer where the external form of the
   relocations should be stored.

   Returns FALSE if something goes wrong.  */

static bfd_boolean
elf_link_read_relocs_from_section (abfd, shdr, external_relocs,
				   internal_relocs)
     bfd *abfd;
     Elf_Internal_Shdr *shdr;
     PTR external_relocs;
     Elf_Internal_Rela *internal_relocs;
{
  struct elf_backend_data *bed;
  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
  const bfd_byte *erela;
  const bfd_byte *erelaend;
  Elf_Internal_Rela *irela;

  /* If there aren't any relocations, that's OK.  */
  if (!shdr)
    return TRUE;

  /* Position ourselves at the start of the section.  */
  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0)
    return FALSE;

  /* Read the relocations.  */
  if (bfd_bread (external_relocs, shdr->sh_size, abfd) != shdr->sh_size)
    return FALSE;

  bed = get_elf_backend_data (abfd);

  /* Convert the external relocations to the internal format.  */
  if (shdr->sh_entsize == bed->s->sizeof_rel)
    swap_in = bed->s->swap_reloc_in;
  else if (shdr->sh_entsize == bed->s->sizeof_rela)
    swap_in = bed->s->swap_reloca_in;
  else
    {
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  erela = external_relocs;
  erelaend = erela + NUM_SHDR_ENTRIES (shdr) * shdr->sh_entsize;
  irela = internal_relocs;
  while (erela < erelaend)
    {
      (*swap_in) (abfd, erela, irela);
      irela += bed->s->int_rels_per_ext_rel;
      erela += shdr->sh_entsize;
    }

  return TRUE;
}

/* Read and swap the relocs for a section O.  They may have been
   cached.  If the EXTERNAL_RELOCS and INTERNAL_RELOCS arguments are
   not NULL, they are used as buffers to read into.  They are known to
   be large enough.  If the INTERNAL_RELOCS relocs argument is NULL,
   the return value is allocated using either malloc or bfd_alloc,
   according to the KEEP_MEMORY argument.  If O has two relocation
   sections (both REL and RELA relocations), then the REL_HDR
   relocations will appear first in INTERNAL_RELOCS, followed by the
   REL_HDR2 relocations.  */

Elf_Internal_Rela *
_bfd_elf_link_read_relocs (abfd, o, external_relocs, internal_relocs,
			   keep_memory)
     bfd *abfd;
     asection *o;
     PTR external_relocs;
     Elf_Internal_Rela *internal_relocs;
     bfd_boolean keep_memory;
{
  Elf_Internal_Shdr *rel_hdr;
  PTR alloc1 = NULL;
  Elf_Internal_Rela *alloc2 = NULL;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (elf_section_data (o)->relocs != NULL)
    return elf_section_data (o)->relocs;

  if (o->reloc_count == 0)
    return NULL;

  rel_hdr = &elf_section_data (o)->rel_hdr;

  if (internal_relocs == NULL)
    {
      bfd_size_type size;

      size = o->reloc_count;
      size *= bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rela);
      if (keep_memory)
	internal_relocs = (Elf_Internal_Rela *) bfd_alloc (abfd, size);
      else
	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_malloc (size);
      if (internal_relocs == NULL)
	goto error_return;
    }

  if (external_relocs == NULL)
    {
      bfd_size_type size = rel_hdr->sh_size;

      if (elf_section_data (o)->rel_hdr2)
	size += elf_section_data (o)->rel_hdr2->sh_size;
      alloc1 = (PTR) bfd_malloc (size);
      if (alloc1 == NULL)
	goto error_return;
      external_relocs = alloc1;
    }

  if (!elf_link_read_relocs_from_section (abfd, rel_hdr,
					  external_relocs,
					  internal_relocs))
    goto error_return;
  if (!elf_link_read_relocs_from_section
      (abfd,
       elf_section_data (o)->rel_hdr2,
       ((bfd_byte *) external_relocs) + rel_hdr->sh_size,
       internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
			  * bed->s->int_rels_per_ext_rel)))
    goto error_return;

  /* Cache the results for next time, if we can.  */
  if (keep_memory)
    elf_section_data (o)->relocs = internal_relocs;

  if (alloc1 != NULL)
    free (alloc1);

  /* Don't free alloc2, since if it was allocated we are passing it
     back (under the name of internal_relocs).  */

  return internal_relocs;

 error_return:
  if (alloc1 != NULL)
    free (alloc1);
  if (alloc2 != NULL)
    free (alloc2);
  return NULL;
}

/* Compute the size of, and allocate space for, REL_HDR which is the
   section header for a section containing relocations for O.  */

bfd_boolean
_bfd_elf_link_size_reloc_section (abfd, rel_hdr, o)
     bfd *abfd;
     Elf_Internal_Shdr *rel_hdr;
     asection *o;
{
  bfd_size_type reloc_count;
  bfd_size_type num_rel_hashes;

  /* Figure out how many relocations there will be.  */
  if (rel_hdr == &elf_section_data (o)->rel_hdr)
    reloc_count = elf_section_data (o)->rel_count;
  else
    reloc_count = elf_section_data (o)->rel_count2;

  num_rel_hashes = o->reloc_count;
  if (num_rel_hashes < reloc_count)
    num_rel_hashes = reloc_count;

  /* That allows us to calculate the size of the section.  */
  rel_hdr->sh_size = rel_hdr->sh_entsize * reloc_count;

  /* The contents field must last into write_object_contents, so we
     allocate it with bfd_alloc rather than malloc.  Also since we
     cannot be sure that the contents will actually be filled in,
     we zero the allocated space.  */
  rel_hdr->contents = (PTR) bfd_zalloc (abfd, rel_hdr->sh_size);
  if (rel_hdr->contents == NULL && rel_hdr->sh_size != 0)
    return FALSE;

  /* We only allocate one set of hash entries, so we only do it the
     first time we are called.  */
  if (elf_section_data (o)->rel_hashes == NULL
      && num_rel_hashes)
    {
      struct elf_link_hash_entry **p;

      p = ((struct elf_link_hash_entry **)
	   bfd_zmalloc (num_rel_hashes
			* sizeof (struct elf_link_hash_entry *)));
      if (p == NULL)
	return FALSE;

      elf_section_data (o)->rel_hashes = p;
    }

  return TRUE;
}

/* Copy the relocations indicated by the INTERNAL_RELOCS (which
   originated from the section given by INPUT_REL_HDR) to the
   OUTPUT_BFD.  */

bfd_boolean
_bfd_elf_link_output_relocs (output_bfd, input_section, input_rel_hdr,
			     internal_relocs)
     bfd *output_bfd;
     asection *input_section;
     Elf_Internal_Shdr *input_rel_hdr;
     Elf_Internal_Rela *internal_relocs;
{
  Elf_Internal_Rela *irela;
  Elf_Internal_Rela *irelaend;
  bfd_byte *erel;
  Elf_Internal_Shdr *output_rel_hdr;
  asection *output_section;
  unsigned int *rel_countp = NULL;
  struct elf_backend_data *bed;
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));

  output_section = input_section->output_section;
  output_rel_hdr = NULL;

  if (elf_section_data (output_section)->rel_hdr.sh_entsize
      == input_rel_hdr->sh_entsize)
    {
      output_rel_hdr = &elf_section_data (output_section)->rel_hdr;
      rel_countp = &elf_section_data (output_section)->rel_count;
    }
  else if (elf_section_data (output_section)->rel_hdr2
	   && (elf_section_data (output_section)->rel_hdr2->sh_entsize
	       == input_rel_hdr->sh_entsize))
    {
      output_rel_hdr = elf_section_data (output_section)->rel_hdr2;
      rel_countp = &elf_section_data (output_section)->rel_count2;
    }
  else
    {
      (*_bfd_error_handler)
	(_("%s: relocation size mismatch in %s section %s"),
	 bfd_get_filename (output_bfd),
	 bfd_archive_filename (input_section->owner),
	 input_section->name);
      bfd_set_error (bfd_error_wrong_object_format);
      return FALSE;
    }

  bed = get_elf_backend_data (output_bfd);
  if (input_rel_hdr->sh_entsize == bed->s->sizeof_rel)
    swap_out = bed->s->swap_reloc_out;
  else if (input_rel_hdr->sh_entsize == bed->s->sizeof_rela)
    swap_out = bed->s->swap_reloca_out;
  else
    abort ();

  erel = output_rel_hdr->contents;
  erel += *rel_countp * input_rel_hdr->sh_entsize;
  irela = internal_relocs;
  irelaend = irela + (NUM_SHDR_ENTRIES (input_rel_hdr)
		      * bed->s->int_rels_per_ext_rel);
  while (irela < irelaend)
    {
      (*swap_out) (output_bfd, irela, erel);
      irela += bed->s->int_rels_per_ext_rel;
      erel += input_rel_hdr->sh_entsize;
    }

  /* Bump the counter, so that we know where to add the next set of
     relocations.  */
  *rel_countp += NUM_SHDR_ENTRIES (input_rel_hdr);

  return TRUE;
}

/* Fix up the flags for a symbol.  This handles various cases which
   can only be fixed after all the input files are seen.  This is
   currently called by both adjust_dynamic_symbol and
   assign_sym_version, which is unnecessary but perhaps more robust in
   the face of future changes.  */

bfd_boolean
_bfd_elf_fix_symbol_flags (h, eif)
     struct elf_link_hash_entry *h;
     struct elf_info_failed *eif;
{
  /* If this symbol was mentioned in a non-ELF file, try to set
     DEF_REGULAR and REF_REGULAR correctly.  This is the only way to
     permit a non-ELF file to correctly refer to a symbol defined in
     an ELF dynamic object.  */
  if ((h->elf_link_hash_flags & ELF_LINK_NON_ELF) != 0)
    {
      while (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      if (h->root.type != bfd_link_hash_defined
	  && h->root.type != bfd_link_hash_defweak)
	h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
      else
	{
	  if (h->root.u.def.section->owner != NULL
	      && (bfd_get_flavour (h->root.u.def.section->owner)
		  == bfd_target_elf_flavour))
	    h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
				       | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
	  else
	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	}

      if (h->dynindx == -1
	  && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	      || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0))
	{
	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
	    {
	      eif->failed = TRUE;
	      return FALSE;
	    }
	}
    }
  else
    {
      /* Unfortunately, ELF_LINK_NON_ELF is only correct if the symbol
	 was first seen in a non-ELF file.  Fortunately, if the symbol
	 was first seen in an ELF file, we're probably OK unless the
	 symbol was defined in a non-ELF file.  Catch that case here.
	 FIXME: We're still in trouble if the symbol was first seen in
	 a dynamic object, and then later in a non-ELF regular object.  */
      if ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	  && (h->root.u.def.section->owner != NULL
	      ? (bfd_get_flavour (h->root.u.def.section->owner)
		 != bfd_target_elf_flavour)
	      : (bfd_is_abs_section (h->root.u.def.section)
		 && (h->elf_link_hash_flags
		     & ELF_LINK_HASH_DEF_DYNAMIC) == 0)))
	h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
    }

  /* If this is a final link, and the symbol was defined as a common
     symbol in a regular object file, and there was no definition in
     any dynamic object, then the linker will have allocated space for
     the symbol in a common section but the ELF_LINK_HASH_DEF_REGULAR
     flag will not have been set.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
      && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;

  /* If -Bsymbolic was used (which means to bind references to global
     symbols to the definition within the shared object), and this
     symbol was defined in a regular object, then it actually doesn't
     need a PLT entry.  Likewise, if the symbol has non-default
     visibility.  If the symbol has hidden or internal visibility, we
     will force it local.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0
      && eif->info->shared
      && is_elf_hash_table (eif->info)
      && (eif->info->symbolic
	  || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
    {
      struct elf_backend_data *bed;
      bfd_boolean force_local;

      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);

      force_local = (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
		     || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN);
      (*bed->elf_backend_hide_symbol) (eif->info, h, force_local);
    }

  /* If a weak undefined symbol has non-default visibility, we also
     hide it from the dynamic linker.  */
  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
      && h->root.type == bfd_link_hash_undefweak)
    {
      struct elf_backend_data *bed;
      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
      (*bed->elf_backend_hide_symbol) (eif->info, h, TRUE);
    }

  /* If this is a weak defined symbol in a dynamic object, and we know
     the real definition in the dynamic object, copy interesting flags
     over to the real definition.  */
  if (h->weakdef != NULL)
    {
      struct elf_link_hash_entry *weakdef;

      weakdef = h->weakdef;
      if (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      BFD_ASSERT (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak);
      BFD_ASSERT (weakdef->root.type == bfd_link_hash_defined
		  || weakdef->root.type == bfd_link_hash_defweak);
      BFD_ASSERT (weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC);

      /* If the real definition is defined by a regular object file,
	 don't do anything special.  See the longer description in
	 _bfd_elf_adjust_dynamic_symbol, below.  */
      if ((weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
	h->weakdef = NULL;
      else
	{
	  struct elf_backend_data *bed;

	  bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
	  (*bed->elf_backend_copy_indirect_symbol) (bed, weakdef, h);
	}
    }

  return TRUE;
}

/* Make the backend pick a good value for a dynamic symbol.  This is
   called via elf_link_hash_traverse, and also calls itself
   recursively.  */

bfd_boolean
_bfd_elf_adjust_dynamic_symbol (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_info_failed *eif = (struct elf_info_failed *) data;
  bfd *dynobj;
  struct elf_backend_data *bed;

  if (! is_elf_hash_table (eif->info))
    return FALSE;

  if (h->root.type == bfd_link_hash_warning)
    {
      h->plt = elf_hash_table (eif->info)->init_offset;
      h->got = elf_hash_table (eif->info)->init_offset;

      /* When warning symbols are created, they **replace** the "real"
	 entry in the hash table, thus we never get to see the real
	 symbol in a hash traversal.  So look at it now.  */
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
    }

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  /* Fix the symbol flags.  */
  if (! _bfd_elf_fix_symbol_flags (h, eif))
    return FALSE;

  /* If this symbol does not require a PLT entry, and it is not
     defined by a dynamic object, or is not referenced by a regular
     object, ignore it.  We do have to handle a weak defined symbol,
     even if no regular object refers to it, if we decided to add it
     to the dynamic symbol table.  FIXME: Do we normally need to worry
     about symbols which are defined by one dynamic object and
     referenced by another one?  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0
      && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  || ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
	      && (h->weakdef == NULL || h->weakdef->dynindx == -1))))
    {
      h->plt = elf_hash_table (eif->info)->init_offset;
      return TRUE;
    }

  /* If we've already adjusted this symbol, don't do it again.  This
     can happen via a recursive call.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    return TRUE;

  /* Don't look at this symbol again.  Note that we must set this
     after checking the above conditions, because we may look at a
     symbol once, decide not to do anything, and then get called
     recursively later after REF_REGULAR is set below.  */
  h->elf_link_hash_flags |= ELF_LINK_HASH_DYNAMIC_ADJUSTED;

  /* If this is a weak definition, and we know a real definition, and
     the real symbol is not itself defined by a regular object file,
     then get a good value for the real definition.  We handle the
     real symbol first, for the convenience of the backend routine.

     Note that there is a confusing case here.  If the real definition
     is defined by a regular object file, we don't get the real symbol
     from the dynamic object, but we do get the weak symbol.  If the
     processor backend uses a COPY reloc, then if some routine in the
     dynamic object changes the real symbol, we will not see that
     change in the corresponding weak symbol.  This is the way other
     ELF linkers work as well, and seems to be a result of the shared
     library model.

     I will clarify this issue.  Most SVR4 shared libraries define the
     variable _timezone and define timezone as a weak synonym.  The
     tzset call changes _timezone.  If you write
       extern int timezone;
       int _timezone = 5;
       int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }
     you might expect that, since timezone is a synonym for _timezone,
     the same number will print both times.  However, if the processor
     backend uses a COPY reloc, then actually timezone will be copied
     into your process image, and, since you define _timezone
     yourself, _timezone will not.  Thus timezone and _timezone will
     wind up at different memory locations.  The tzset call will set
     _timezone, leaving timezone unchanged.  */

  if (h->weakdef != NULL)
    {
      /* If we get to this point, we know there is an implicit
	 reference by a regular object file via the weak symbol H.
	 FIXME: Is this really true?  What if the traversal finds
	 H->WEAKDEF before it finds H?  */
      h->weakdef->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;

      if (! _bfd_elf_adjust_dynamic_symbol (h->weakdef, (PTR) eif))
	return FALSE;
    }

  /* If a symbol has no type and no size and does not require a PLT
     entry, then we are probably about to do the wrong thing here: we
     are probably going to create a COPY reloc for an empty object.
     This case can arise when a shared object is built with assembly
     code, and the assembly code fails to set the symbol type.  */
  if (h->size == 0
      && h->type == STT_NOTYPE
      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
    (*_bfd_error_handler)
      (_("warning: type and size of dynamic symbol `%s' are not defined"),
       h->root.root.string);

  dynobj = elf_hash_table (eif->info)->dynobj;
  bed = get_elf_backend_data (dynobj);
  if (! (*bed->elf_backend_adjust_dynamic_symbol) (eif->info, h))
    {
      eif->failed = TRUE;
      return FALSE;
    }

  return TRUE;
}

/* Adjust all external symbols pointing into SEC_MERGE sections
   to reflect the object merging within the sections.  */

bfd_boolean
_bfd_elf_link_sec_merge_syms (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  asection *sec;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && ((sec = h->root.u.def.section)->flags & SEC_MERGE)
      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
    {
      bfd *output_bfd = (bfd *) data;

      h->root.u.def.value =
	_bfd_merged_section_offset (output_bfd,
				    &h->root.u.def.section,
				    elf_section_data (sec)->sec_info,
				    h->root.u.def.value, (bfd_vma) 0);
@


1.29
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d34 1
a34 1
  register asection *s;
d41 2
a42 1
  if (bfd_get_section_by_name (abfd, ".got") != NULL)
d115 1
a115 1
  register asection *s;
d276 1
a276 1
         table.  */
d529 2
a530 2
      /* Is there a hole we have to provide?  If so check whether the segment is
	 too big already */
d537 5
a541 4
	      (*_bfd_error_handler) (_("%s: Section %s is too large to add hole of %ld bytes"),
				     bfd_get_filename (abfd),
				     lsect->name,
				     (long) lsect->hole_size);
@


1.28
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d28 1
a28 1
boolean
d42 1
a42 1
    return true;
d56 1
a56 1
      return false;
d66 1
a66 1
    return false;
d74 1
a74 1
	return false;
d86 1
a86 1
	     bed->got_symbol_offset, (const char *) NULL, false,
d88 1
a88 1
	return false;
d95 1
a95 1
	return false;
d103 1
a103 1
  return true;
d108 1
a108 1
boolean
d130 1
a130 1
      return false;
d150 1
a150 1
    return false;
d161 1
a161 1
	      (bfd_vma) 0, (const char *) NULL, false,
d163 1
a163 1
	return false;
d170 1
a170 1
	return false;
d178 1
a178 1
    return false;
d181 1
a181 1
    return false;
d194 1
a194 1
	return false;
d215 1
a215 1
	    return false;
d219 1
a219 1
  return true;
d230 1
a230 1
boolean
d240 1
a240 1
      boolean copy;
d255 1
a255 1
	      return true;
d271 1
a271 1
	    return false;
d281 1
a281 1
	  copy = false;
d289 1
a289 1
	    return false;
d293 1
a293 1
	  copy = true;
d302 1
a302 1
	return false;
d306 1
a306 1
  return true;
d379 1
a379 1
  dynstr_index = _bfd_elf_strtab_add (dynstr, name, false);
d421 1
a421 1
static boolean elf_link_renumber_hash_table_dynsyms
d424 1
a424 1
static boolean
d437 1
a437 1
  return true;
d509 1
a509 1
      lsect->hole_written_p = false;
d562 1
a562 1
				     false, false, false);
d570 1
a570 1
		    (const char *) NULL, false,
d623 1
a623 1
boolean
d630 1
a630 1
    return true;
d646 1
a646 1
	return false;
d649 1
a649 1
  return true;
@


1.27
log
@	* elf-bfd.h (_bfd_elf32_link_record_local_dynamic_symbol): Define
	as elf_link_record_local_dynamic_symbol.
	(_bfd_elf64_link_record_local_dynamic_symbol): Likewise.
	(elf_link_record_local_dynamic_symbol): Declare.  Now returns int.
	* elflink.h (elf_link_record_local_dynamic_symbol): Move to..
	* elflink.c: .. here.  Use bfd_elf_get_elf_syms.  Check whether an
	attempt is made to record a symbol in a discarded section, and
	return `2' in that case.
@
text
@d36 1
d83 1
a83 1
      h = NULL;
d87 1
a87 1
	     bed->collect, (struct bfd_link_hash_entry **) &h)))
d89 1
d156 3
a158 1
      struct elf_link_hash_entry *h = NULL;
d162 1
a162 2
	      get_elf_backend_data (abfd)->collect,
	      (struct bfd_link_hash_entry **) &h)))
d164 1
d553 3
a555 1
	  struct elf_link_hash_entry *h = NULL;
d561 2
a562 2
	  h = (struct elf_link_hash_entry *)
	    bfd_link_hash_lookup (info->hash, lsect->sym_name, false, false, false);
d564 10
a573 14
	  if ((h == NULL || h->root.type == bfd_link_hash_undefined)
	      && !(_bfd_generic_link_add_one_symbol (info,
						     abfd,
						     lsect->sym_name,
						     BSF_GLOBAL,
						     s,
						     ((lsect->hole_size)
						      ? s->_raw_size - lsect->hole_size + lsect->sym_offset
						      : lsect->sym_offset),
						     (const char *) NULL,
						     false,
						     get_elf_backend_data (abfd)->collect,
						     (struct bfd_link_hash_entry **) &h)))
	    return (elf_linker_section_t *)0;
d584 1
a584 1
	    return (elf_linker_section_t *)0;
@


1.27.12.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a35 1
  struct bfd_link_hash_entry *bh;
d82 1
a82 1
      bh = NULL;
d86 1
a86 1
	     bed->collect, &bh)))
a87 1
      h = (struct elf_link_hash_entry *) bh;
d154 1
a154 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d158 2
a159 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a160 1
      h = (struct elf_link_hash_entry *) bh;
d549 1
a549 3
	  struct elf_link_hash_entry *h;
	  struct bfd_link_hash_entry *bh;

d555 2
a556 2
	  bh = bfd_link_hash_lookup (info->hash, lsect->sym_name,
				     false, false, false);
d558 14
a571 10
	  if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	      && !(_bfd_generic_link_add_one_symbol
		   (info, abfd, lsect->sym_name, BSF_GLOBAL, s,
		    (lsect->hole_size
		     ? s->_raw_size - lsect->hole_size + lsect->sym_offset
		     : lsect->sym_offset),
		    (const char *) NULL, false,
		    get_elf_backend_data (abfd)->collect, &bh)))
	    return (elf_linker_section_t *) 0;
	  h = (struct elf_link_hash_entry *) bh;
d582 1
a582 1
	    return (elf_linker_section_t *) 0;
@


1.27.12.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d28 4
a31 2
bfd_boolean
_bfd_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)
d34 1
a34 1
  asection *s;
d37 1
a37 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d41 2
a42 3
  s = bfd_get_section_by_name (abfd, ".got");
  if (s != NULL && (s->flags & SEC_LINKER_CREATED) != 0)
    return TRUE;
d56 1
a56 1
      return FALSE;
d66 1
a66 1
    return FALSE;
d74 1
a74 1
	return FALSE;
d86 3
a88 2
	     bed->got_symbol_offset, NULL, FALSE, bed->collect, &bh)))
	return FALSE;
d93 1
a93 1
      if (! info->executable
d95 1
a95 1
	return FALSE;
d103 1
a103 1
  return TRUE;
d106 1
a106 6
/* Create some sections which will be filled in with dynamic linking
   information.  ABFD is an input file which requires dynamic sections
   to be created.  The dynamic sections take up virtual memory space
   when the final executable is run, so we need to create them before
   addresses are assigned to the output sections.  We work out the
   actual contents and size of these sections later.  */
d108 4
a111 2
bfd_boolean
_bfd_elf_link_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d113 1
a113 1
  flagword flags;
d115 2
a116 3
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  const struct elf_backend_data *bed;
d118 1
a118 20
  if (! is_elf_hash_table (info->hash))
    return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    return TRUE;

  /* Make sure that all dynamic sections use the same input BFD.  */
  if (elf_hash_table (info)->dynobj == NULL)
    elf_hash_table (info)->dynobj = abfd;
  else
    abfd = elf_hash_table (info)->dynobj;

  /* Note that we set the SEC_IN_MEMORY flag for all of these
     sections.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
	   | SEC_IN_MEMORY | SEC_LINKER_CREATED);

  /* A dynamically linked executable has a .interp section, but a
     shared library does not.  */
  if (info->executable)
d120 3
a122 5
      s = bfd_make_section (abfd, ".interp");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
	return FALSE;
    }
d124 3
a126 9
  if (! info->traditional_format)
    {
      s = bfd_make_section (abfd, ".eh_frame_hdr");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;
      elf_hash_table (info)->eh_info.hdr_sec = s;
    }
d128 3
a130 39
  bed = get_elf_backend_data (abfd);

  /* Create sections to hold version informations.  These are removed
     if they are not needed.  */
  s = bfd_make_section (abfd, ".gnu.version_d");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section (abfd, ".gnu.version");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, 1))
    return FALSE;

  s = bfd_make_section (abfd, ".gnu.version_r");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section (abfd, ".dynsym");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section (abfd, ".dynstr");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
    return FALSE;

  /* Create a strtab to hold the dynamic symbol names.  */
  if (elf_hash_table (info)->dynstr == NULL)
    {
      elf_hash_table (info)->dynstr = _bfd_elf_strtab_init ();
      if (elf_hash_table (info)->dynstr == NULL)
	return FALSE;
a132 54
  s = bfd_make_section (abfd, ".dynamic");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  /* The special symbol _DYNAMIC is always set to the start of the
     .dynamic section.  This call occurs before we have processed the
     symbols for any dynamic object, so we don't have to worry about
     overriding a dynamic definition.  We could set _DYNAMIC in a
     linker script, but we only want to define it if we are, in fact,
     creating a .dynamic section.  We don't want to define it if there
     is no .dynamic section, since on some ELF platforms the start up
     code examines it to decide how to initialize the process.  */
  bh = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_DYNAMIC", BSF_GLOBAL, s, 0, NULL, FALSE,
	  get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  if (! info->executable
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;

  s = bfd_make_section (abfd, ".hash");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  elf_section_data (s)->this_hdr.sh_entsize = bed->s->sizeof_hash_entry;

  /* Let the backend create the rest of the sections.  This lets the
     backend set the right flags.  The backend will normally create
     the .got and .plt sections.  */
  if (! (*bed->elf_backend_create_dynamic_sections) (abfd, info))
    return FALSE;

  elf_hash_table (info)->dynamic_sections_created = TRUE;

  return TRUE;
}

/* Create dynamic sections when linking against a dynamic object.  */

bfd_boolean
_bfd_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags, pltflags;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

d150 1
a150 1
    return FALSE;
d160 4
a163 3
	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s, 0, NULL,
	      FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return FALSE;
d168 1
a168 1
      if (! info->executable
d170 1
a170 1
	return FALSE;
d177 2
a178 2
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
d181 1
a181 1
    return FALSE;
d193 2
a194 2
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC | SEC_LINKER_CREATED))
	return FALSE;
d214 2
a215 2
	      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
	    return FALSE;
d219 1
a219 1
  return TRUE;
d230 4
a233 3
bfd_boolean
_bfd_elf_link_record_dynamic_symbol (struct bfd_link_info *info,
				     struct elf_link_hash_entry *h)
d238 1
a238 1
      char *p;
d240 1
d255 1
a255 1
	      return TRUE;
d271 1
a271 1
	    return FALSE;
d275 1
a275 1
	 table.  */
d278 8
a285 7
      if (p != NULL)
	/* We know that the p points into writable memory.  In fact,
	   there are only a few symbols that have read-only names, being
	   those like _GLOBAL_OFFSET_TABLE_ that are created specially
	   by the backends.  Most symbols will have names pointing into
	   an ELF string table read from a file, or to objalloc memory.  */
	*p = 0;
d287 10
a296 1
      indx = _bfd_elf_strtab_add (dynstr, name, p != NULL);
d298 2
a299 2
      if (p != NULL)
	*p = ELF_VER_CHR;
d302 1
a302 1
	return FALSE;
d306 1
a306 64
  return TRUE;
}

/* Record an assignment to a symbol made by a linker script.  We need
   this in case some dynamic object refers to this symbol.  */

bfd_boolean
bfd_elf_record_link_assignment (bfd *output_bfd ATTRIBUTE_UNUSED,
				struct bfd_link_info *info,
				const char *name,
				bfd_boolean provide)
{
  struct elf_link_hash_entry *h;

  if (!is_elf_hash_table (info->hash))
    return TRUE;

  h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, TRUE, FALSE);
  if (h == NULL)
    return FALSE;

  if (h->root.type == bfd_link_hash_new)
    h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;

  /* If this symbol is being provided by the linker script, and it is
     currently defined by a dynamic object, but not by a regular
     object, then mark it as undefined so that the generic linker will
     force the correct value.  */
  if (provide
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    h->root.type = bfd_link_hash_undefined;

  /* If this symbol is not being provided by the linker script, and it is
     currently defined by a dynamic object, but not by a regular object,
     then clear out any version information because the symbol will not be
     associated with the dynamic object any more.  */
  if (!provide
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    h->verinfo.verdef = NULL;

  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;

  if (((h->elf_link_hash_flags & (ELF_LINK_HASH_DEF_DYNAMIC
				  | ELF_LINK_HASH_REF_DYNAMIC)) != 0
       || info->shared)
      && h->dynindx == -1)
    {
      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;

      /* If this is a weak defined symbol, and we know a corresponding
	 real symbol from the same dynamic object, make sure the real
	 symbol is also made into a dynamic symbol.  */
      if (h->weakdef != NULL
	  && h->weakdef->dynindx == -1)
	{
	  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
	    return FALSE;
	}
    }

  return TRUE;
d314 4
a317 3
elf_link_record_local_dynamic_symbol (struct bfd_link_info *info,
				      bfd *input_bfd,
				      long input_indx)
d328 1
a328 1
  if (! is_elf_hash_table (info->hash))
d337 1
a337 1
  entry = bfd_alloc (input_bfd, amt);
d343 2
a344 1
			     1, input_indx, &entry->isym, esym, &eshndx))
d379 1
a379 1
  dynstr_index = _bfd_elf_strtab_add (dynstr, name, FALSE);
d404 4
a407 3
_bfd_elf_link_lookup_local_dynindx (struct bfd_link_info *info,
				    bfd *input_bfd,
				    long input_indx)
d421 7
a427 3
static bfd_boolean
elf_link_renumber_hash_table_dynsyms (struct elf_link_hash_entry *h,
				      void *data)
d429 1
a429 1
  size_t *count = data;
d437 1
a437 1
  return TRUE;
d446 3
a448 1
_bfd_elf_link_renumber_dynsyms (bfd *output_bfd, struct bfd_link_info *info)
d479 3
d483 17
a499 65
/* This function is called when we want to define a new symbol.  It
   handles the various cases which arise when we find a definition in
   a dynamic object, or when there is already a definition in a
   dynamic object.  The new symbol is described by NAME, SYM, PSEC,
   and PVALUE.  We set SYM_HASH to the hash table entry.  We set
   OVERRIDE if the old symbol is overriding a new definition.  We set
   TYPE_CHANGE_OK if it is OK for the type to change.  We set
   SIZE_CHANGE_OK if it is OK for the size to change.  By OK to
   change, we mean that we shouldn't warn if the type or size does
   change. DT_NEEDED indicates if it comes from a DT_NEEDED entry of
   a shared object.  */

bfd_boolean
_bfd_elf_merge_symbol (bfd *abfd,
		       struct bfd_link_info *info,
		       const char *name,
		       Elf_Internal_Sym *sym,
		       asection **psec,
		       bfd_vma *pvalue,
		       struct elf_link_hash_entry **sym_hash,
		       bfd_boolean *skip,
		       bfd_boolean *override,
		       bfd_boolean *type_change_ok,
		       bfd_boolean *size_change_ok,
		       bfd_boolean dt_needed)
{
  asection *sec;
  struct elf_link_hash_entry *h;
  struct elf_link_hash_entry *flip;
  int bind;
  bfd *oldbfd;
  bfd_boolean newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
  bfd_boolean newweakdef, oldweakdef, newweakundef, oldweakundef;

  *skip = FALSE;
  *override = FALSE;

  sec = *psec;
  bind = ELF_ST_BIND (sym->st_info);

  if (! bfd_is_und_section (sec))
    h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, FALSE, FALSE);
  else
    h = ((struct elf_link_hash_entry *)
	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, FALSE, FALSE));
  if (h == NULL)
    return FALSE;
  *sym_hash = h;

  /* This code is for coping with dynamic objects, and is only useful
     if we are doing an ELF link.  */
  if (info->hash->creator != abfd->xvec)
    return TRUE;

  /* For merging, we only care about real symbols.  */

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* If we just created the symbol, mark it as being an ELF symbol.
     Other than that, there is nothing to do--there is no merge issue
     with a newly defined symbol--so we just return.  */

  if (h->root.type == bfd_link_hash_new)
d501 2
a502 112
      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
      return TRUE;
    }

  /* OLDBFD is a BFD associated with the existing symbol.  */

  switch (h->root.type)
    {
    default:
      oldbfd = NULL;
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      oldbfd = h->root.u.undef.abfd;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      oldbfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      oldbfd = h->root.u.c.p->section->owner;
      break;
    }

  /* In cases involving weak versioned symbols, we may wind up trying
     to merge a symbol with itself.  Catch that here, to avoid the
     confusion that results if we try to override a symbol with
     itself.  The additional tests catch cases like
     _GLOBAL_OFFSET_TABLE_, which are regular symbols defined in a
     dynamic object, which we do want to handle here.  */
  if (abfd == oldbfd
      && ((abfd->flags & DYNAMIC) == 0
	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
    return TRUE;

  /* NEWDYN and OLDDYN indicate whether the new or old symbol,
     respectively, is from a dynamic object.  */

  if ((abfd->flags & DYNAMIC) != 0)
    newdyn = TRUE;
  else
    newdyn = FALSE;

  if (oldbfd != NULL)
    olddyn = (oldbfd->flags & DYNAMIC) != 0;
  else
    {
      asection *hsec;

      /* This code handles the special SHN_MIPS_{TEXT,DATA} section
	 indices used by MIPS ELF.  */
      switch (h->root.type)
	{
	default:
	  hsec = NULL;
	  break;

	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
	  hsec = h->root.u.def.section;
	  break;

	case bfd_link_hash_common:
	  hsec = h->root.u.c.p->section;
	  break;
	}

      if (hsec == NULL)
	olddyn = FALSE;
      else
	olddyn = (hsec->symbol->flags & BSF_DYNAMIC) != 0;
    }

  /* NEWDEF and OLDDEF indicate whether the new or old symbol,
     respectively, appear to be a definition rather than reference.  */

  if (bfd_is_und_section (sec) || bfd_is_com_section (sec))
    newdef = FALSE;
  else
    newdef = TRUE;

  if (h->root.type == bfd_link_hash_undefined
      || h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_common)
    olddef = FALSE;
  else
    olddef = TRUE;

  /* We need to remember if a symbol has a definition in a dynamic
     object or is weak in all dynamic objects. Internal and hidden
     visibility will make it unavailable to dynamic objects.  */
  if (newdyn && (h->elf_link_hash_flags & ELF_LINK_DYNAMIC_DEF) == 0)
    {
      if (!bfd_is_und_section (sec))
	h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_DEF;
      else
	{
	  /* Check if this symbol is weak in all dynamic objects. If it
	     is the first time we see it in a dynamic object, we mark
	     if it is weak. Otherwise, we clear it.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	    { 
	      if (bind == STB_WEAK)
		h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_WEAK;
	    }
	  else if (bind != STB_WEAK)
	    h->elf_link_hash_flags &= ~ELF_LINK_DYNAMIC_WEAK;
	}
    }
d504 1
a504 40
  /* If the old symbol has non-default visibility, we ignore the new
     definition from a dynamic object.  */
  if (newdyn
      && ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
      && !bfd_is_und_section (sec))
    {
      *skip = TRUE;
      /* Make sure this symbol is dynamic.  */
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      /* A protected symbol has external availability. Make sure it is
	 recorded as dynamic.

	 FIXME: Should we check type and size for protected symbol?  */
      if (ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)
	return _bfd_elf_link_record_dynamic_symbol (info, h);
      else
	return TRUE;
    }
  else if (!newdyn
	   && ELF_ST_VISIBILITY (sym->st_other) != STV_DEFAULT
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
    {
      /* If the new symbol with non-default visibility comes from a
	 relocatable file and the old definition comes from a dynamic
	 object, we remove the old definition.  */
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	h = *sym_hash;
      h->root.type = bfd_link_hash_new;
      h->root.u.undef.abfd = NULL;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_DYNAMIC
				     | ELF_LINK_DYNAMIC_DEF);
	}
      /* FIXME: Should we check type and size for protected symbol?  */
      h->size = 0;
      h->type = 0;
      return TRUE;
    }
d506 4
a509 136
  /* We need to treat weak definition right, depending on if there is a
     definition from a dynamic object.  */
  if (bind == STB_WEAK)
    {
      if (olddef)
	{
	   newweakdef = TRUE;
	   newweakundef = FALSE;
	}
      else
	{
	   newweakdef = FALSE;
	   newweakundef = TRUE;
	}
    }
  else
    newweakdef = newweakundef = FALSE;

  /* If the new weak definition comes from a relocatable file and the
     old symbol comes from a dynamic object, we treat the new one as
     strong.  */
  if (newweakdef && !newdyn && olddyn)
    newweakdef = FALSE;

  if (h->root.type == bfd_link_hash_defweak)
    {
      oldweakdef = TRUE;
      oldweakundef = FALSE;
    }
  else if (h->root.type == bfd_link_hash_undefweak)
    {
      oldweakdef = FALSE;
      oldweakundef = TRUE;
    }
  else
    oldweakdef = oldweakundef = FALSE;

  /* If the old weak definition comes from a relocatable file and the
     new symbol comes from a dynamic object, we treat the old one as
     strong.  */
  if (oldweakdef && !olddyn && newdyn)
    oldweakdef = FALSE;

  /* NEWDYNCOMMON and OLDDYNCOMMON indicate whether the new or old
     symbol, respectively, appears to be a common symbol in a dynamic
     object.  If a symbol appears in an uninitialized section, and is
     not weak, and is not a function, then it may be a common symbol
     which was resolved when the dynamic object was created.  We want
     to treat such symbols specially, because they raise special
     considerations when setting the symbol size: if the symbol
     appears as a common symbol in a regular object, and the size in
     the regular object is larger, we must make sure that we use the
     larger size.  This problematic case can always be avoided in C,
     but it must be handled correctly when using Fortran shared
     libraries.

     Note that if NEWDYNCOMMON is set, NEWDEF will be set, and
     likewise for OLDDYNCOMMON and OLDDEF.

     Note that this test is just a heuristic, and that it is quite
     possible to have an uninitialized symbol in a shared object which
     is really a definition, rather than a common symbol.  This could
     lead to some minor confusion when the symbol really is a common
     symbol in some regular object.  However, I think it will be
     harmless.  */

  if (newdyn
      && newdef
      && (sec->flags & SEC_ALLOC) != 0
      && (sec->flags & SEC_LOAD) == 0
      && sym->st_size > 0
      && !newweakdef
      && !newweakundef
      && ELF_ST_TYPE (sym->st_info) != STT_FUNC)
    newdyncommon = TRUE;
  else
    newdyncommon = FALSE;

  if (olddyn
      && olddef
      && h->root.type == bfd_link_hash_defined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->root.u.def.section->flags & SEC_ALLOC) != 0
      && (h->root.u.def.section->flags & SEC_LOAD) == 0
      && h->size > 0
      && h->type != STT_FUNC)
    olddyncommon = TRUE;
  else
    olddyncommon = FALSE;

  /* It's OK to change the type if either the existing symbol or the
     new symbol is weak unless it comes from a DT_NEEDED entry of
     a shared object, in which case, the DT_NEEDED entry may not be
     required at the run time. The type change is also OK if the
     old symbol is undefined and the new symbol is defined.  */

  if ((! dt_needed && oldweakdef)
      || oldweakundef
      || newweakdef
      || newweakundef
      || (newdef
	  && (h->root.type == bfd_link_hash_undefined
	      || h->root.type == bfd_link_hash_undefweak)))
    *type_change_ok = TRUE;

  /* It's OK to change the size if either the existing symbol or the
     new symbol is weak, or if the old symbol is undefined.  */

  if (*type_change_ok
      || h->root.type == bfd_link_hash_undefined)
    *size_change_ok = TRUE;

  /* If both the old and the new symbols look like common symbols in a
     dynamic object, set the size of the symbol to the larger of the
     two.  */

  if (olddyncommon
      && newdyncommon
      && sym->st_size != h->size)
    {
      /* Since we think we have two common symbols, issue a multiple
	 common warning if desired.  Note that we only warn if the
	 size is different.  If the size is the same, we simply let
	 the old symbol override the new one as normally happens with
	 symbols defined in dynamic objects.  */

      if (! ((*info->callbacks->multiple_common)
	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
	return FALSE;

      if (sym->st_size > h->size)
	h->size = sym->st_size;

      *size_change_ok = TRUE;
    }
d511 3
a513 169
  /* If we are looking at a dynamic object, and we have found a
     definition, we need to see if the symbol was already defined by
     some other object.  If so, we want to use the existing
     definition, and we do not want to report a multiple symbol
     definition error; we do this by clobbering *PSEC to be
     bfd_und_section_ptr.

     We treat a common symbol as a definition if the symbol in the
     shared library is a function, since common symbols always
     represent variables; this can cause confusion in principle, but
     any such confusion would seem to indicate an erroneous program or
     shared library.  We also permit a common symbol in a regular
     object to override a weak symbol in a shared object.

     We prefer a non-weak definition in a shared library to a weak
     definition in the executable unless it comes from a DT_NEEDED
     entry of a shared object, in which case, the DT_NEEDED entry
     may not be required at the run time.  */

  if (newdyn
      && newdef
      && (olddef
	  || (h->root.type == bfd_link_hash_common
	      && (newweakdef
		  || newweakundef
		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC)))
      && (!oldweakdef
	  || dt_needed
	  || newweakdef
	  || newweakundef))
    {
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;

      *psec = sec = bfd_und_section_ptr;
      *size_change_ok = TRUE;

      /* If we get here when the old symbol is a common symbol, then
	 we are explicitly letting it override a weak symbol or
	 function in a dynamic object, and we don't want to warn about
	 a type change.  If the old symbol is a defined symbol, a type
	 change warning may still be appropriate.  */

      if (h->root.type == bfd_link_hash_common)
	*type_change_ok = TRUE;
    }

  /* Handle the special case of an old common symbol merging with a
     new symbol which looks like a common symbol in a shared object.
     We change *PSEC and *PVALUE to make the new symbol look like a
     common symbol, and let _bfd_generic_link_add_one_symbol will do
     the right thing.  */

  if (newdyncommon
      && h->root.type == bfd_link_hash_common)
    {
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;
      *pvalue = sym->st_size;
      *psec = sec = bfd_com_section_ptr;
      *size_change_ok = TRUE;
    }

  /* If the old symbol is from a dynamic object, and the new symbol is
     a definition which is not from a dynamic object, then the new
     symbol overrides the old symbol.  Symbols from regular files
     always take precedence over symbols from dynamic objects, even if
     they are defined after the dynamic object in the link.

     As above, we again permit a common symbol in a regular object to
     override a definition in a shared object if the shared object
     symbol is a function or is weak.

     As above, we permit a non-weak definition in a shared object to
     override a weak definition in a regular object.  */

  flip = NULL;
  if (! newdyn
      && (newdef
	  || (bfd_is_com_section (sec)
	      && (oldweakdef || h->type == STT_FUNC)))
      && olddyn
      && olddef
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && ((!newweakdef && !newweakundef) || oldweakdef))
    {
      /* Change the hash table entry to undefined, and let
	 _bfd_generic_link_add_one_symbol do the right thing with the
	 new definition.  */

      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;
      *size_change_ok = TRUE;

      olddef = FALSE;
      olddyncommon = FALSE;

      /* We again permit a type change when a common symbol may be
	 overriding a function.  */

      if (bfd_is_com_section (sec))
	*type_change_ok = TRUE;

      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	/* This union may have been set to be non-NULL when this symbol
	   was seen in a dynamic object.  We must force the union to be
	   NULL, so that it is correct for a regular symbol.  */
	h->verinfo.vertree = NULL;
    }

  /* Handle the special case of a new common symbol merging with an
     old symbol that looks like it might be a common symbol defined in
     a shared object.  Note that we have already handled the case in
     which a new common symbol should simply override the definition
     in the shared library.  */

  if (! newdyn
      && bfd_is_com_section (sec)
      && olddyncommon)
    {
      /* It would be best if we could set the hash table entry to a
	 common symbol, but we don't know what to use for the section
	 or the alignment.  */
      if (! ((*info->callbacks->multiple_common)
	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
	return FALSE;

      /* If the presumed common symbol in the dynamic object is
	 larger, pretend that the new symbol has its size.  */

      if (h->size > *pvalue)
	*pvalue = h->size;

      /* FIXME: We no longer know the alignment required by the symbol
	 in the dynamic object, so we just wind up using the one from
	 the regular object.  */

      olddef = FALSE;
      olddyncommon = FALSE;

      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;

      *size_change_ok = TRUE;
      *type_change_ok = TRUE;

      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	h->verinfo.vertree = NULL;
    }

  if (flip != NULL)
    {
      /* Handle the case where we had a versioned symbol in a dynamic
	 library and now find a definition in a normal object.  In this
	 case, we make the versioned symbol point to the normal one.  */
      const struct elf_backend_data *bed = get_elf_backend_data (abfd);
      flip->root.type = h->root.type;
      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) flip;
      (*bed->elf_backend_copy_indirect_symbol) (bed, flip, h);
      flip->root.u.undef.abfd = h->root.u.undef.abfd;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
d515 1
a515 4
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  flip->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	}
    }
d517 2
a518 84
  /* Handle the special case of a weak definition in a regular object
     followed by a non-weak definition in a shared object.  In this
     case, we prefer the definition in the shared object unless it
     comes from a DT_NEEDED entry of a shared object, in which case,
     the DT_NEEDED entry may not be required at the run time.  */
  if (olddef
      && ! dt_needed
      && oldweakdef
      && newdef
      && newdyn
      && !newweakdef
      && !newweakundef)
    {
      /* To make this work we have to frob the flags so that the rest
	 of the code does not think we are using the regular
	 definition.  */
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
      else if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      h->elf_link_hash_flags &= ~ (ELF_LINK_HASH_DEF_REGULAR
				   | ELF_LINK_HASH_DEF_DYNAMIC);

      /* If H is the target of an indirection, we want the caller to
	 use H rather than the indirect symbol.  Otherwise if we are
	 defining a new indirect symbol we will wind up attaching it
	 to the entry we are overriding.  */
      *sym_hash = h;
    }

  /* Handle the special case of a non-weak definition in a shared
     object followed by a weak definition in a regular object.  In
     this case we prefer the definition in the shared object.  To make
     this work we have to tell the caller to not treat the new symbol
     as a definition.  */
  if (olddef
      && olddyn
      && !oldweakdef
      && newdef
      && ! newdyn
      && (newweakdef || newweakundef))
    *override = TRUE;

  return TRUE;
}

/* This function is called to create an indirect symbol from the
   default for the symbol with the default version if needed. The
   symbol is described by H, NAME, SYM, PSEC, VALUE, and OVERRIDE.  We
   set DYNSYM if the new indirect symbol is dynamic. DT_NEEDED
   indicates if it comes from a DT_NEEDED entry of a shared object.  */

bfd_boolean
_bfd_elf_add_default_symbol (bfd *abfd,
			     struct bfd_link_info *info,
			     struct elf_link_hash_entry *h,
			     const char *name,
			     Elf_Internal_Sym *sym,
			     asection **psec,
			     bfd_vma *value,
			     bfd_boolean *dynsym,
			     bfd_boolean override,
			     bfd_boolean dt_needed)
{
  bfd_boolean type_change_ok;
  bfd_boolean size_change_ok;
  bfd_boolean skip;
  char *shortname;
  struct elf_link_hash_entry *hi;
  struct bfd_link_hash_entry *bh;
  const struct elf_backend_data *bed;
  bfd_boolean collect;
  bfd_boolean dynamic;
  char *p;
  size_t len, shortlen;
  asection *sec;

  /* If this symbol has a version, and it is the default version, we
     create an indirect symbol from the default name to the fully
     decorated name.  This will cause external references which do not
     specify a version to be bound to this version of the symbol.  */
  p = strchr (name, ELF_VER_CHR);
  if (p == NULL || p[1] != ELF_VER_CHR)
    return TRUE;
d520 2
a521 15
  if (override)
    {
      /* We are overridden by an old definition. We need to check if we
	 need to create the indirect symbol from the default name.  */
      hi = elf_link_hash_lookup (elf_hash_table (info), name, TRUE,
				 FALSE, FALSE);
      BFD_ASSERT (hi != NULL);
      if (hi == h)
	return TRUE;
      while (hi->root.type == bfd_link_hash_indirect
	     || hi->root.type == bfd_link_hash_warning)
	{
	  hi = (struct elf_link_hash_entry *) hi->root.u.i.link;
	  if (hi == h)
	    return TRUE;
d523 2
a524 24
    }

  bed = get_elf_backend_data (abfd);
  collect = bed->collect;
  dynamic = (abfd->flags & DYNAMIC) != 0;

  shortlen = p - name;
  shortname = bfd_hash_allocate (&info->hash->table, shortlen + 1);
  if (shortname == NULL)
    return FALSE;
  memcpy (shortname, name, shortlen);
  shortname[shortlen] = '\0';

  /* We are going to create a new symbol.  Merge it with any existing
     symbol with this name.  For the purposes of the merge, act as
     though we were defining the symbol we just defined, although we
     actually going to define an indirect symbol.  */
  type_change_ok = FALSE;
  size_change_ok = FALSE;
  sec = *psec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
			      &hi, &skip, &override, &type_change_ok,
			      &size_change_ok, dt_needed))
    return FALSE;
d526 1
a526 2
  if (skip)
    goto nondefault;
d528 3
a530 36
  if (! override)
    {
      bh = &hi->root;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, shortname, BSF_INDIRECT, bfd_ind_section_ptr,
	      0, name, FALSE, collect, &bh)))
	return FALSE;
      hi = (struct elf_link_hash_entry *) bh;
    }
  else
    {
      /* In this case the symbol named SHORTNAME is overriding the
	 indirect symbol we want to add.  We were planning on making
	 SHORTNAME an indirect symbol referring to NAME.  SHORTNAME
	 is the name without a version.  NAME is the fully versioned
	 name, and it is the default version.

	 Overriding means that we already saw a definition for the
	 symbol SHORTNAME in a regular object, and it is overriding
	 the symbol defined in the dynamic object.

	 When this happens, we actually want to change NAME, the
	 symbol we just added, to refer to SHORTNAME.  This will cause
	 references to NAME in the shared object to become references
	 to SHORTNAME in the regular object.  This is what we expect
	 when we override a function in a shared object: that the
	 references in the shared object will be mapped to the
	 definition in the regular object.  */

      while (hi->root.type == bfd_link_hash_indirect
	     || hi->root.type == bfd_link_hash_warning)
	hi = (struct elf_link_hash_entry *) hi->root.u.i.link;

      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
d532 3
a534 5
	  h->elf_link_hash_flags &=~ ELF_LINK_HASH_DEF_DYNAMIC;
	  hi->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	  if (hi->elf_link_hash_flags
	      & (ELF_LINK_HASH_REF_REGULAR
		 | ELF_LINK_HASH_DEF_REGULAR))
d536 4
a539 17
	      if (! _bfd_elf_link_record_dynamic_symbol (info, hi))
		return FALSE;
	    }
	}

      /* Now set HI to H, so that the following code will set the
	 other fields correctly.  */
      hi = h;
    }

  /* If there is a duplicate definition somewhere, then HI may not
     point to an indirect symbol.  We will have reported an error to
     the user in that case.  */

  if (hi->root.type == bfd_link_hash_indirect)
    {
      struct elf_link_hash_entry *ht;
d541 2
a542 25
      /* If the symbol became indirect, then we assume that we have
	 not seen a definition before.  */
      BFD_ASSERT ((hi->elf_link_hash_flags
		   & (ELF_LINK_HASH_DEF_DYNAMIC
		      | ELF_LINK_HASH_DEF_REGULAR)) == 0);

      ht = (struct elf_link_hash_entry *) hi->root.u.i.link;
      (*bed->elf_backend_copy_indirect_symbol) (bed, ht, hi);

      /* See if the new flags lead us to realize that the symbol must
	 be dynamic.  */
      if (! *dynsym)
	{
	  if (! dynamic)
	    {
	      if (info->shared
		  || ((hi->elf_link_hash_flags
		       & ELF_LINK_HASH_REF_DYNAMIC) != 0))
		*dynsym = TRUE;
	    }
	  else
	    {
	      if ((hi->elf_link_hash_flags
		   & ELF_LINK_HASH_REF_REGULAR) != 0)
		*dynsym = TRUE;
a544 4
    }

  /* We also need to define an indirection from the nondefault version
     of the symbol.  */
d546 4
a549 16
nondefault:
  len = strlen (name);
  shortname = bfd_hash_allocate (&info->hash->table, len);
  if (shortname == NULL)
    return FALSE;
  memcpy (shortname, name, shortlen);
  memcpy (shortname + shortlen, p + 1, len - shortlen);

  /* Once again, merge with any existing symbol.  */
  type_change_ok = FALSE;
  size_change_ok = FALSE;
  sec = *psec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
			      &hi, &skip, &override, &type_change_ok,
			      &size_change_ok, dt_needed))
    return FALSE;
d551 1
a551 28
  if (skip)
    return TRUE;

  if (override)
    {
      /* Here SHORTNAME is a versioned name, so we don't expect to see
	 the type of override we do in the case above unless it is
	 overridden by a versioned definition.  */
      if (hi->root.type != bfd_link_hash_defined
	  && hi->root.type != bfd_link_hash_defweak)
	(*_bfd_error_handler)
	  (_("%s: warning: unexpected redefinition of indirect versioned symbol `%s'"),
	   bfd_archive_filename (abfd), shortname);
    }
  else
    {
      bh = &hi->root;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, shortname, BSF_INDIRECT,
	      bfd_ind_section_ptr, 0, name, FALSE, collect, &bh)))
	return FALSE;
      hi = (struct elf_link_hash_entry *) bh;

      /* If there is a duplicate definition somewhere, then HI may not
	 point to an indirect symbol.  We will have reported an error
	 to the user in that case.  */

      if (hi->root.type == bfd_link_hash_indirect)
d553 2
a554 39
	  /* If the symbol became indirect, then we assume that we have
	     not seen a definition before.  */
	  BFD_ASSERT ((hi->elf_link_hash_flags
		       & (ELF_LINK_HASH_DEF_DYNAMIC
			  | ELF_LINK_HASH_DEF_REGULAR)) == 0);

	  (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);

	  /* See if the new flags lead us to realize that the symbol
	     must be dynamic.  */
	  if (! *dynsym)
	    {
	      if (! dynamic)
		{
		  if (info->shared
		      || ((hi->elf_link_hash_flags
			   & ELF_LINK_HASH_REF_DYNAMIC) != 0))
		    *dynsym = TRUE;
		}
	      else
		{
		  if ((hi->elf_link_hash_flags
		       & ELF_LINK_HASH_REF_REGULAR) != 0)
		    *dynsym = TRUE;
		}
	    }
	}
    }

  return TRUE;
}

/* This routine is used to export all defined symbols into the dynamic
   symbol table.  It is called via elf_link_hash_traverse.  */

bfd_boolean
_bfd_elf_export_symbol (struct elf_link_hash_entry *h, void *data)
{
  struct elf_info_failed *eif = data;
d556 7
a562 3
  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;
d564 10
a573 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d575 3
a577 15
  if (h->dynindx == -1
      && (h->elf_link_hash_flags
	  & (ELF_LINK_HASH_DEF_REGULAR | ELF_LINK_HASH_REF_REGULAR)) != 0)
    {
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;

      for (t = eif->verdefs; t != NULL; t = t->next)
	{
	  if (t->globals.list != NULL)
	    {
	      d = (*t->match) (&t->globals, NULL, h->root.root.string);
	      if (d != NULL)
		goto doit;
	    }
d579 2
a580 7
	  if (t->locals.list != NULL)
	    {
	      d = (*t->match) (&t->locals, NULL, h->root.root.string);
	      if (d != NULL)
		return TRUE;
	    }
	}
d582 3
a584 8
      if (!eif->verdefs)
	{
	doit:
	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
	    {
	      eif->failed = TRUE;
	      return FALSE;
	    }
d588 4
a591 16
  return TRUE;
}

/* Look through the symbols which are defined in other shared
   libraries and referenced here.  Update the list of version
   dependencies.  This will be put into the .gnu.version_r section.
   This function is called via elf_link_hash_traverse.  */

bfd_boolean
_bfd_elf_link_find_version_dependencies (struct elf_link_hash_entry *h,
					 void *data)
{
  struct elf_find_verdep_info *rinfo = data;
  Elf_Internal_Verneed *t;
  Elf_Internal_Vernaux *a;
  bfd_size_type amt;
d593 3
a595 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d597 3
a599 13
  /* We only care about symbols defined in shared objects with version
     information.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
      || h->dynindx == -1
      || h->verinfo.verdef == NULL)
    return TRUE;

  /* See if we already know about this version.  */
  for (t = elf_tdata (rinfo->output_bfd)->verref; t != NULL; t = t->vn_nextref)
    {
      if (t->vn_bfd != h->verinfo.verdef->vd_bfd)
	continue;
d601 1
a601 276
      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
	if (a->vna_nodename == h->verinfo.verdef->vd_nodename)
	  return TRUE;

      break;
    }

  /* This is a new version.  Add it to tree we are building.  */

  if (t == NULL)
    {
      amt = sizeof *t;
      t = bfd_zalloc (rinfo->output_bfd, amt);
      if (t == NULL)
	{
	  rinfo->failed = TRUE;
	  return FALSE;
	}

      t->vn_bfd = h->verinfo.verdef->vd_bfd;
      t->vn_nextref = elf_tdata (rinfo->output_bfd)->verref;
      elf_tdata (rinfo->output_bfd)->verref = t;
    }

  amt = sizeof *a;
  a = bfd_zalloc (rinfo->output_bfd, amt);

  /* Note that we are copying a string pointer here, and testing it
     above.  If bfd_elf_string_from_elf_section is ever changed to
     discard the string data when low in memory, this will have to be
     fixed.  */
  a->vna_nodename = h->verinfo.verdef->vd_nodename;

  a->vna_flags = h->verinfo.verdef->vd_flags;
  a->vna_nextptr = t->vn_auxptr;

  h->verinfo.verdef->vd_exp_refno = rinfo->vers;
  ++rinfo->vers;

  a->vna_other = h->verinfo.verdef->vd_exp_refno + 1;

  t->vn_auxptr = a;

  return TRUE;
}

/* Figure out appropriate versions for all the symbols.  We may not
   have the version number script until we have read all of the input
   files, so until that point we don't know which symbols should be
   local.  This function is called via elf_link_hash_traverse.  */

bfd_boolean
_bfd_elf_link_assign_sym_version (struct elf_link_hash_entry *h, void *data)
{
  struct elf_assign_sym_version_info *sinfo;
  struct bfd_link_info *info;
  const struct elf_backend_data *bed;
  struct elf_info_failed eif;
  char *p;
  bfd_size_type amt;

  sinfo = data;
  info = sinfo->info;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Fix the symbol flags.  */
  eif.failed = FALSE;
  eif.info = info;
  if (! _bfd_elf_fix_symbol_flags (h, &eif))
    {
      if (eif.failed)
	sinfo->failed = TRUE;
      return FALSE;
    }

  /* We only need version numbers for symbols defined in regular
     objects.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return TRUE;

  bed = get_elf_backend_data (sinfo->output_bfd);
  p = strchr (h->root.root.string, ELF_VER_CHR);
  if (p != NULL && h->verinfo.vertree == NULL)
    {
      struct bfd_elf_version_tree *t;
      bfd_boolean hidden;

      hidden = TRUE;

      /* There are two consecutive ELF_VER_CHR characters if this is
	 not a hidden symbol.  */
      ++p;
      if (*p == ELF_VER_CHR)
	{
	  hidden = FALSE;
	  ++p;
	}

      /* If there is no version string, we can just return out.  */
      if (*p == '\0')
	{
	  if (hidden)
	    h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
	  return TRUE;
	}

      /* Look for the version.  If we find it, it is no longer weak.  */
      for (t = sinfo->verdefs; t != NULL; t = t->next)
	{
	  if (strcmp (t->name, p) == 0)
	    {
	      size_t len;
	      char *alc;
	      struct bfd_elf_version_expr *d;

	      len = p - h->root.root.string;
	      alc = bfd_malloc (len);
	      if (alc == NULL)
		return FALSE;
	      memcpy (alc, h->root.root.string, len - 1);
	      alc[len - 1] = '\0';
	      if (alc[len - 2] == ELF_VER_CHR)
		alc[len - 2] = '\0';

	      h->verinfo.vertree = t;
	      t->used = TRUE;
	      d = NULL;

	      if (t->globals.list != NULL)
		d = (*t->match) (&t->globals, NULL, alc);

	      /* See if there is anything to force this symbol to
		 local scope.  */
	      if (d == NULL && t->locals.list != NULL)
		{
		  d = (*t->match) (&t->locals, NULL, alc);
		  if (d != NULL
		      && h->dynindx != -1
		      && info->shared
		      && ! info->export_dynamic)
		    (*bed->elf_backend_hide_symbol) (info, h, TRUE);
		}

	      free (alc);
	      break;
	    }
	}

      /* If we are building an application, we need to create a
	 version node for this version.  */
      if (t == NULL && info->executable)
	{
	  struct bfd_elf_version_tree **pp;
	  int version_index;

	  /* If we aren't going to export this symbol, we don't need
	     to worry about it.  */
	  if (h->dynindx == -1)
	    return TRUE;

	  amt = sizeof *t;
	  t = bfd_zalloc (sinfo->output_bfd, amt);
	  if (t == NULL)
	    {
	      sinfo->failed = TRUE;
	      return FALSE;
	    }

	  t->name = p;
	  t->name_indx = (unsigned int) -1;
	  t->used = TRUE;

	  version_index = 1;
	  /* Don't count anonymous version tag.  */
	  if (sinfo->verdefs != NULL && sinfo->verdefs->vernum == 0)
	    version_index = 0;
	  for (pp = &sinfo->verdefs; *pp != NULL; pp = &(*pp)->next)
	    ++version_index;
	  t->vernum = version_index;

	  *pp = t;

	  h->verinfo.vertree = t;
	}
      else if (t == NULL)
	{
	  /* We could not find the version for a symbol when
	     generating a shared archive.  Return an error.  */
	  (*_bfd_error_handler)
	    (_("%s: undefined versioned symbol name %s"),
	     bfd_get_filename (sinfo->output_bfd), h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  sinfo->failed = TRUE;
	  return FALSE;
	}

      if (hidden)
	h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
    }

  /* If we don't have a version for this symbol, see if we can find
     something.  */
  if (h->verinfo.vertree == NULL && sinfo->verdefs != NULL)
    {
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_tree *local_ver;
      struct bfd_elf_version_expr *d;

      /* See if can find what version this symbol is in.  If the
	 symbol is supposed to be local, then don't actually register
	 it.  */
      local_ver = NULL;
      for (t = sinfo->verdefs; t != NULL; t = t->next)
	{
	  if (t->globals.list != NULL)
	    {
	      bfd_boolean matched;

	      matched = FALSE;
	      d = NULL;
	      while ((d = (*t->match) (&t->globals, d,
				       h->root.root.string)) != NULL)
		if (d->symver)
		  matched = TRUE;
		else
		  {
		    /* There is a version without definition.  Make
		       the symbol the default definition for this
		       version.  */
		    h->verinfo.vertree = t;
		    local_ver = NULL;
		    d->script = 1;
		    break;
		  }
	      if (d != NULL)
		break;
	      else if (matched)
		/* There is no undefined version for this symbol. Hide the
		   default one.  */
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
	    }

	  if (t->locals.list != NULL)
	    {
	      d = NULL;
	      while ((d = (*t->match) (&t->locals, d,
				       h->root.root.string)) != NULL)
		{
		  local_ver = t;
		  /* If the match is "*", keep looking for a more
		     explicit, perhaps even global, match.
		     XXX: Shouldn't this be !d->wildcard instead?  */
		  if (d->pattern[0] != '*' || d->pattern[1] != '\0')
		    break;
		}

	      if (d != NULL)
		break;
	    }
	}

      if (local_ver != NULL)
	{
	  h->verinfo.vertree = local_ver;
	  if (h->dynindx != -1
	      && info->shared
	      && ! info->export_dynamic)
	    {
	      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
	    }
	}
    }

  return TRUE;
d604 1
a604 75
/* Read and swap the relocs from the section indicated by SHDR.  This
   may be either a REL or a RELA section.  The relocations are
   translated into RELA relocations and stored in INTERNAL_RELOCS,
   which should have already been allocated to contain enough space.
   The EXTERNAL_RELOCS are a buffer where the external form of the
   relocations should be stored.

   Returns FALSE if something goes wrong.  */

static bfd_boolean
elf_link_read_relocs_from_section (bfd *abfd,
				   asection *sec,
				   Elf_Internal_Shdr *shdr,
				   void *external_relocs,
				   Elf_Internal_Rela *internal_relocs)
{
  const struct elf_backend_data *bed;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  const bfd_byte *erela;
  const bfd_byte *erelaend;
  Elf_Internal_Rela *irela;
  Elf_Internal_Shdr *symtab_hdr;
  size_t nsyms;

  /* If there aren't any relocations, that's OK.  */
  if (!shdr)
    return TRUE;

  /* Position ourselves at the start of the section.  */
  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0)
    return FALSE;

  /* Read the relocations.  */
  if (bfd_bread (external_relocs, shdr->sh_size, abfd) != shdr->sh_size)
    return FALSE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  nsyms = symtab_hdr->sh_size / symtab_hdr->sh_entsize;

  bed = get_elf_backend_data (abfd);

  /* Convert the external relocations to the internal format.  */
  if (shdr->sh_entsize == bed->s->sizeof_rel)
    swap_in = bed->s->swap_reloc_in;
  else if (shdr->sh_entsize == bed->s->sizeof_rela)
    swap_in = bed->s->swap_reloca_in;
  else
    {
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  erela = external_relocs;
  erelaend = erela + NUM_SHDR_ENTRIES (shdr) * shdr->sh_entsize;
  irela = internal_relocs;
  while (erela < erelaend)
    {
      bfd_vma r_symndx;

      (*swap_in) (abfd, erela, irela);
      r_symndx = ELF32_R_SYM (irela->r_info);
      if (bed->s->arch_size == 64)
	r_symndx >>= 24;
      if ((size_t) r_symndx >= nsyms)
	{
	  (*_bfd_error_handler)
	    (_("%s: bad reloc symbol index (0x%lx >= 0x%lx) for offset 0x%lx in section `%s'"),
	     bfd_archive_filename (abfd), (unsigned long) r_symndx,
	     (unsigned long) nsyms, irela->r_offset, sec->name);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      irela += bed->s->int_rels_per_ext_rel;
      erela += shdr->sh_entsize;
    }
d606 5
a610 19
  return TRUE;
}

/* Read and swap the relocs for a section O.  They may have been
   cached.  If the EXTERNAL_RELOCS and INTERNAL_RELOCS arguments are
   not NULL, they are used as buffers to read into.  They are known to
   be large enough.  If the INTERNAL_RELOCS relocs argument is NULL,
   the return value is allocated using either malloc or bfd_alloc,
   according to the KEEP_MEMORY argument.  If O has two relocation
   sections (both REL and RELA relocations), then the REL_HDR
   relocations will appear first in INTERNAL_RELOCS, followed by the
   REL_HDR2 relocations.  */

Elf_Internal_Rela *
_bfd_elf_link_read_relocs (bfd *abfd,
			   asection *o,
			   void *external_relocs,
			   Elf_Internal_Rela *internal_relocs,
			   bfd_boolean keep_memory)
d612 1
a612 28
  Elf_Internal_Shdr *rel_hdr;
  void *alloc1 = NULL;
  Elf_Internal_Rela *alloc2 = NULL;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (elf_section_data (o)->relocs != NULL)
    return elf_section_data (o)->relocs;

  if (o->reloc_count == 0)
    return NULL;

  rel_hdr = &elf_section_data (o)->rel_hdr;

  if (internal_relocs == NULL)
    {
      bfd_size_type size;

      size = o->reloc_count;
      size *= bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rela);
      if (keep_memory)
	internal_relocs = bfd_alloc (abfd, size);
      else
	internal_relocs = alloc2 = bfd_malloc (size);
      if (internal_relocs == NULL)
	goto error_return;
    }

  if (external_relocs == NULL)
d614 2
a615 8
      bfd_size_type size = rel_hdr->sh_size;

      if (elf_section_data (o)->rel_hdr2)
	size += elf_section_data (o)->rel_hdr2->sh_size;
      alloc1 = bfd_malloc (size);
      if (alloc1 == NULL)
	goto error_return;
      external_relocs = alloc1;
d618 1
a618 152
  if (!elf_link_read_relocs_from_section (abfd, o, rel_hdr,
					  external_relocs,
					  internal_relocs))
    goto error_return;
  if (!elf_link_read_relocs_from_section
      (abfd, o,
       elf_section_data (o)->rel_hdr2,
       ((bfd_byte *) external_relocs) + rel_hdr->sh_size,
       internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
			  * bed->s->int_rels_per_ext_rel)))
    goto error_return;

  /* Cache the results for next time, if we can.  */
  if (keep_memory)
    elf_section_data (o)->relocs = internal_relocs;

  if (alloc1 != NULL)
    free (alloc1);

  /* Don't free alloc2, since if it was allocated we are passing it
     back (under the name of internal_relocs).  */

  return internal_relocs;

 error_return:
  if (alloc1 != NULL)
    free (alloc1);
  if (alloc2 != NULL)
    free (alloc2);
  return NULL;
}

/* Compute the size of, and allocate space for, REL_HDR which is the
   section header for a section containing relocations for O.  */

bfd_boolean
_bfd_elf_link_size_reloc_section (bfd *abfd,
				  Elf_Internal_Shdr *rel_hdr,
				  asection *o)
{
  bfd_size_type reloc_count;
  bfd_size_type num_rel_hashes;

  /* Figure out how many relocations there will be.  */
  if (rel_hdr == &elf_section_data (o)->rel_hdr)
    reloc_count = elf_section_data (o)->rel_count;
  else
    reloc_count = elf_section_data (o)->rel_count2;

  num_rel_hashes = o->reloc_count;
  if (num_rel_hashes < reloc_count)
    num_rel_hashes = reloc_count;

  /* That allows us to calculate the size of the section.  */
  rel_hdr->sh_size = rel_hdr->sh_entsize * reloc_count;

  /* The contents field must last into write_object_contents, so we
     allocate it with bfd_alloc rather than malloc.  Also since we
     cannot be sure that the contents will actually be filled in,
     we zero the allocated space.  */
  rel_hdr->contents = bfd_zalloc (abfd, rel_hdr->sh_size);
  if (rel_hdr->contents == NULL && rel_hdr->sh_size != 0)
    return FALSE;

  /* We only allocate one set of hash entries, so we only do it the
     first time we are called.  */
  if (elf_section_data (o)->rel_hashes == NULL
      && num_rel_hashes)
    {
      struct elf_link_hash_entry **p;

      p = bfd_zmalloc (num_rel_hashes * sizeof (struct elf_link_hash_entry *));
      if (p == NULL)
	return FALSE;

      elf_section_data (o)->rel_hashes = p;
    }

  return TRUE;
}

/* Copy the relocations indicated by the INTERNAL_RELOCS (which
   originated from the section given by INPUT_REL_HDR) to the
   OUTPUT_BFD.  */

bfd_boolean
_bfd_elf_link_output_relocs (bfd *output_bfd,
			     asection *input_section,
			     Elf_Internal_Shdr *input_rel_hdr,
			     Elf_Internal_Rela *internal_relocs)
{
  Elf_Internal_Rela *irela;
  Elf_Internal_Rela *irelaend;
  bfd_byte *erel;
  Elf_Internal_Shdr *output_rel_hdr;
  asection *output_section;
  unsigned int *rel_countp = NULL;
  const struct elf_backend_data *bed;
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);

  output_section = input_section->output_section;
  output_rel_hdr = NULL;

  if (elf_section_data (output_section)->rel_hdr.sh_entsize
      == input_rel_hdr->sh_entsize)
    {
      output_rel_hdr = &elf_section_data (output_section)->rel_hdr;
      rel_countp = &elf_section_data (output_section)->rel_count;
    }
  else if (elf_section_data (output_section)->rel_hdr2
	   && (elf_section_data (output_section)->rel_hdr2->sh_entsize
	       == input_rel_hdr->sh_entsize))
    {
      output_rel_hdr = elf_section_data (output_section)->rel_hdr2;
      rel_countp = &elf_section_data (output_section)->rel_count2;
    }
  else
    {
      (*_bfd_error_handler)
	(_("%s: relocation size mismatch in %s section %s"),
	 bfd_get_filename (output_bfd),
	 bfd_archive_filename (input_section->owner),
	 input_section->name);
      bfd_set_error (bfd_error_wrong_object_format);
      return FALSE;
    }

  bed = get_elf_backend_data (output_bfd);
  if (input_rel_hdr->sh_entsize == bed->s->sizeof_rel)
    swap_out = bed->s->swap_reloc_out;
  else if (input_rel_hdr->sh_entsize == bed->s->sizeof_rela)
    swap_out = bed->s->swap_reloca_out;
  else
    abort ();

  erel = output_rel_hdr->contents;
  erel += *rel_countp * input_rel_hdr->sh_entsize;
  irela = internal_relocs;
  irelaend = irela + (NUM_SHDR_ENTRIES (input_rel_hdr)
		      * bed->s->int_rels_per_ext_rel);
  while (irela < irelaend)
    {
      (*swap_out) (output_bfd, irela, erel);
      irela += bed->s->int_rels_per_ext_rel;
      erel += input_rel_hdr->sh_entsize;
    }

  /* Bump the counter, so that we know where to add the next set of
     relocations.  */
  *rel_countp += NUM_SHDR_ENTRIES (input_rel_hdr);

  return TRUE;
d621 1
a621 295
/* Fix up the flags for a symbol.  This handles various cases which
   can only be fixed after all the input files are seen.  This is
   currently called by both adjust_dynamic_symbol and
   assign_sym_version, which is unnecessary but perhaps more robust in
   the face of future changes.  */

bfd_boolean
_bfd_elf_fix_symbol_flags (struct elf_link_hash_entry *h,
			   struct elf_info_failed *eif)
{
  /* If this symbol was mentioned in a non-ELF file, try to set
     DEF_REGULAR and REF_REGULAR correctly.  This is the only way to
     permit a non-ELF file to correctly refer to a symbol defined in
     an ELF dynamic object.  */
  if ((h->elf_link_hash_flags & ELF_LINK_NON_ELF) != 0)
    {
      while (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      if (h->root.type != bfd_link_hash_defined
	  && h->root.type != bfd_link_hash_defweak)
	h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
      else
	{
	  if (h->root.u.def.section->owner != NULL
	      && (bfd_get_flavour (h->root.u.def.section->owner)
		  == bfd_target_elf_flavour))
	    h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
				       | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
	  else
	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	}

      if (h->dynindx == -1
	  && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	      || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0))
	{
	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
	    {
	      eif->failed = TRUE;
	      return FALSE;
	    }
	}
    }
  else
    {
      /* Unfortunately, ELF_LINK_NON_ELF is only correct if the symbol
	 was first seen in a non-ELF file.  Fortunately, if the symbol
	 was first seen in an ELF file, we're probably OK unless the
	 symbol was defined in a non-ELF file.  Catch that case here.
	 FIXME: We're still in trouble if the symbol was first seen in
	 a dynamic object, and then later in a non-ELF regular object.  */
      if ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	  && (h->root.u.def.section->owner != NULL
	      ? (bfd_get_flavour (h->root.u.def.section->owner)
		 != bfd_target_elf_flavour)
	      : (bfd_is_abs_section (h->root.u.def.section)
		 && (h->elf_link_hash_flags
		     & ELF_LINK_HASH_DEF_DYNAMIC) == 0)))
	h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
    }

  /* If this is a final link, and the symbol was defined as a common
     symbol in a regular object file, and there was no definition in
     any dynamic object, then the linker will have allocated space for
     the symbol in a common section but the ELF_LINK_HASH_DEF_REGULAR
     flag will not have been set.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
      && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;

  /* If -Bsymbolic was used (which means to bind references to global
     symbols to the definition within the shared object), and this
     symbol was defined in a regular object, then it actually doesn't
     need a PLT entry.  Likewise, if the symbol has non-default
     visibility.  If the symbol has hidden or internal visibility, we
     will force it local.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0
      && eif->info->shared
      && is_elf_hash_table (eif->info->hash)
      && (eif->info->symbolic
	  || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
    {
      const struct elf_backend_data *bed;
      bfd_boolean force_local;

      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);

      force_local = (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
		     || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN);
      (*bed->elf_backend_hide_symbol) (eif->info, h, force_local);
    }

  /* If a weak undefined symbol has non-default visibility, we also
     hide it from the dynamic linker.  */
  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
      && h->root.type == bfd_link_hash_undefweak)
    {
      const struct elf_backend_data *bed;
      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
      (*bed->elf_backend_hide_symbol) (eif->info, h, TRUE);
    }

  /* If this is a weak defined symbol in a dynamic object, and we know
     the real definition in the dynamic object, copy interesting flags
     over to the real definition.  */
  if (h->weakdef != NULL)
    {
      struct elf_link_hash_entry *weakdef;

      weakdef = h->weakdef;
      if (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      BFD_ASSERT (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak);
      BFD_ASSERT (weakdef->root.type == bfd_link_hash_defined
		  || weakdef->root.type == bfd_link_hash_defweak);
      BFD_ASSERT (weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC);

      /* If the real definition is defined by a regular object file,
	 don't do anything special.  See the longer description in
	 _bfd_elf_adjust_dynamic_symbol, below.  */
      if ((weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
	h->weakdef = NULL;
      else
	{
	  const struct elf_backend_data *bed;

	  bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
	  (*bed->elf_backend_copy_indirect_symbol) (bed, weakdef, h);
	}
    }

  return TRUE;
}

/* Make the backend pick a good value for a dynamic symbol.  This is
   called via elf_link_hash_traverse, and also calls itself
   recursively.  */

bfd_boolean
_bfd_elf_adjust_dynamic_symbol (struct elf_link_hash_entry *h, void *data)
{
  struct elf_info_failed *eif = data;
  bfd *dynobj;
  const struct elf_backend_data *bed;

  if (! is_elf_hash_table (eif->info->hash))
    return FALSE;

  if (h->root.type == bfd_link_hash_warning)
    {
      h->plt = elf_hash_table (eif->info)->init_offset;
      h->got = elf_hash_table (eif->info)->init_offset;

      /* When warning symbols are created, they **replace** the "real"
	 entry in the hash table, thus we never get to see the real
	 symbol in a hash traversal.  So look at it now.  */
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
    }

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  /* Fix the symbol flags.  */
  if (! _bfd_elf_fix_symbol_flags (h, eif))
    return FALSE;

  /* If this symbol does not require a PLT entry, and it is not
     defined by a dynamic object, or is not referenced by a regular
     object, ignore it.  We do have to handle a weak defined symbol,
     even if no regular object refers to it, if we decided to add it
     to the dynamic symbol table.  FIXME: Do we normally need to worry
     about symbols which are defined by one dynamic object and
     referenced by another one?  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0
      && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  || ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
	      && (h->weakdef == NULL || h->weakdef->dynindx == -1))))
    {
      h->plt = elf_hash_table (eif->info)->init_offset;
      return TRUE;
    }

  /* If we've already adjusted this symbol, don't do it again.  This
     can happen via a recursive call.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    return TRUE;

  /* Don't look at this symbol again.  Note that we must set this
     after checking the above conditions, because we may look at a
     symbol once, decide not to do anything, and then get called
     recursively later after REF_REGULAR is set below.  */
  h->elf_link_hash_flags |= ELF_LINK_HASH_DYNAMIC_ADJUSTED;

  /* If this is a weak definition, and we know a real definition, and
     the real symbol is not itself defined by a regular object file,
     then get a good value for the real definition.  We handle the
     real symbol first, for the convenience of the backend routine.

     Note that there is a confusing case here.  If the real definition
     is defined by a regular object file, we don't get the real symbol
     from the dynamic object, but we do get the weak symbol.  If the
     processor backend uses a COPY reloc, then if some routine in the
     dynamic object changes the real symbol, we will not see that
     change in the corresponding weak symbol.  This is the way other
     ELF linkers work as well, and seems to be a result of the shared
     library model.

     I will clarify this issue.  Most SVR4 shared libraries define the
     variable _timezone and define timezone as a weak synonym.  The
     tzset call changes _timezone.  If you write
       extern int timezone;
       int _timezone = 5;
       int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }
     you might expect that, since timezone is a synonym for _timezone,
     the same number will print both times.  However, if the processor
     backend uses a COPY reloc, then actually timezone will be copied
     into your process image, and, since you define _timezone
     yourself, _timezone will not.  Thus timezone and _timezone will
     wind up at different memory locations.  The tzset call will set
     _timezone, leaving timezone unchanged.  */

  if (h->weakdef != NULL)
    {
      /* If we get to this point, we know there is an implicit
	 reference by a regular object file via the weak symbol H.
	 FIXME: Is this really true?  What if the traversal finds
	 H->WEAKDEF before it finds H?  */
      h->weakdef->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;

      if (! _bfd_elf_adjust_dynamic_symbol (h->weakdef, eif))
	return FALSE;
    }

  /* If a symbol has no type and no size and does not require a PLT
     entry, then we are probably about to do the wrong thing here: we
     are probably going to create a COPY reloc for an empty object.
     This case can arise when a shared object is built with assembly
     code, and the assembly code fails to set the symbol type.  */
  if (h->size == 0
      && h->type == STT_NOTYPE
      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
    (*_bfd_error_handler)
      (_("warning: type and size of dynamic symbol `%s' are not defined"),
       h->root.root.string);

  dynobj = elf_hash_table (eif->info)->dynobj;
  bed = get_elf_backend_data (dynobj);
  if (! (*bed->elf_backend_adjust_dynamic_symbol) (eif->info, h))
    {
      eif->failed = TRUE;
      return FALSE;
    }

  return TRUE;
}

/* Adjust all external symbols pointing into SEC_MERGE sections
   to reflect the object merging within the sections.  */

bfd_boolean
_bfd_elf_link_sec_merge_syms (struct elf_link_hash_entry *h, void *data)
{
  asection *sec;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && ((sec = h->root.u.def.section)->flags & SEC_MERGE)
      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
    {
      bfd *output_bfd = data;

      h->root.u.def.value =
	_bfd_merged_section_offset (output_bfd,
				    &h->root.u.def.section,
				    elf_section_data (sec)->sec_info,
				    h->root.u.def.value, 0);
    }

  return TRUE;
}
d623 24
a646 44
/* Returns false if the symbol referred to by H should be considered
   to resolve local to the current module, and true if it should be
   considered to bind dynamically.  */

bfd_boolean
_bfd_elf_dynamic_symbol_p (struct elf_link_hash_entry *h,
			   struct bfd_link_info *info,
			   bfd_boolean ignore_protected)
{
  bfd_boolean binding_stays_local_p;

  if (h == NULL)
    return FALSE;

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* If it was forced local, then clearly it's not dynamic.  */
  if (h->dynindx == -1)
    return FALSE;
  if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
    return FALSE;

  /* Identify the cases where name binding rules say that a
     visible symbol resolves locally.  */
  binding_stays_local_p = info->executable || info->symbolic;

  switch (ELF_ST_VISIBILITY (h->other))
    {
    case STV_INTERNAL:
    case STV_HIDDEN:
      return FALSE;

    case STV_PROTECTED:
      /* Proper resolution for function pointer equality may require
	 that these symbols perhaps be resolved dynamically, even though
	 we should be resolving them to the current module.  */
      if (!ignore_protected)
	binding_stays_local_p = TRUE;
      break;

    default:
      break;
d649 1
a649 83
  /* If it isn't defined locally, then clearly it's dynamic.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return TRUE;

  /* Otherwise, the symbol is dynamic if binding rules don't tell
     us that it remains local.  */
  return !binding_stays_local_p;
}

/* Return true if the symbol referred to by H should be considered
   to resolve local to the current module, and false otherwise.  Differs
   from (the inverse of) _bfd_elf_dynamic_symbol_p in the treatment of
   undefined symbols and weak symbols.  */

bfd_boolean
_bfd_elf_symbol_refs_local_p (struct elf_link_hash_entry *h,
			      struct bfd_link_info *info,
			      bfd_boolean local_protected)
{
  /* If it's a local sym, of course we resolve locally.  */
  if (h == NULL)
    return TRUE;

  /* If we don't have a definition in a regular file, then we can't
     resolve locally.  The sym is either undefined or dynamic.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return FALSE;

  /* Forced local symbols resolve locally.  */
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    return TRUE;

  /* As do non-dynamic symbols.  */
  if (h->dynindx == -1)
    return TRUE;

  /* At this point, we know the symbol is defined and dynamic.  In an
     executable it must resolve locally, likewise when building symbolic
     shared libraries.  */
  if (info->executable || info->symbolic)
    return TRUE;

  /* Now deal with defined dynamic symbols in shared libraries.  Ones
     with default visibility might not resolve locally.  */
  if (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
    return FALSE;

  /* However, STV_HIDDEN or STV_INTERNAL ones must be local.  */
  if (ELF_ST_VISIBILITY (h->other) != STV_PROTECTED)
    return TRUE;

  /* Function pointer equality tests may require that STV_PROTECTED
     symbols be treated as dynamic symbols, even when we know that the
     dynamic linker will resolve them locally.  */
  return local_protected;
}

/* Caches some TLS segment info, and ensures that the TLS segment vma is
   aligned.  Returns the first TLS output section.  */

struct bfd_section *
_bfd_elf_tls_setup (bfd *obfd, struct bfd_link_info *info)
{
  struct bfd_section *sec, *tls;
  unsigned int align = 0;

  for (sec = obfd->sections; sec != NULL; sec = sec->next)
    if ((sec->flags & SEC_THREAD_LOCAL) != 0)
      break;
  tls = sec;

  for (; sec != NULL && (sec->flags & SEC_THREAD_LOCAL) != 0; sec = sec->next)
    if (sec->alignment_power > align)
      align = sec->alignment_power;

  elf_hash_table (info)->tls_sec = tls;

  /* Ensure the alignment of the first section is the largest alignment,
     so that the tls segment starts aligned.  */
  if (tls != NULL)
    tls->alignment_power = align;

  return tls;
@


1.27.10.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a35 1
  struct bfd_link_hash_entry *bh;
d82 1
a82 1
      bh = NULL;
d86 1
a86 1
	     bed->collect, &bh)))
a87 1
      h = (struct elf_link_hash_entry *) bh;
d154 1
a154 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d158 2
a159 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a160 1
      h = (struct elf_link_hash_entry *) bh;
d549 1
a549 3
	  struct elf_link_hash_entry *h;
	  struct bfd_link_hash_entry *bh;

d555 2
a556 2
	  bh = bfd_link_hash_lookup (info->hash, lsect->sym_name,
				     false, false, false);
d558 14
a571 10
	  if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	      && !(_bfd_generic_link_add_one_symbol
		   (info, abfd, lsect->sym_name, BSF_GLOBAL, s,
		    (lsect->hole_size
		     ? s->_raw_size - lsect->hole_size + lsect->sym_offset
		     : lsect->sym_offset),
		    (const char *) NULL, false,
		    get_elf_backend_data (abfd)->collect, &bh)))
	    return (elf_linker_section_t *) 0;
	  h = (struct elf_link_hash_entry *) bh;
d582 1
a582 1
	    return (elf_linker_section_t *) 0;
@


1.27.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d28 1
a28 1
bfd_boolean
d42 1
a42 1
    return TRUE;
d56 1
a56 1
      return FALSE;
d66 1
a66 1
    return FALSE;
d74 1
a74 1
	return FALSE;
d86 1
a86 1
	     bed->got_symbol_offset, (const char *) NULL, FALSE,
d88 1
a88 1
	return FALSE;
d95 1
a95 1
	return FALSE;
d103 1
a103 1
  return TRUE;
d108 1
a108 1
bfd_boolean
d130 1
a130 1
      return FALSE;
d150 1
a150 1
    return FALSE;
d161 1
a161 1
	      (bfd_vma) 0, (const char *) NULL, FALSE,
d163 1
a163 1
	return FALSE;
d170 1
a170 1
	return FALSE;
d178 1
a178 1
    return FALSE;
d181 1
a181 1
    return FALSE;
d194 1
a194 1
	return FALSE;
d215 1
a215 1
	    return FALSE;
d219 1
a219 1
  return TRUE;
d230 1
a230 1
bfd_boolean
d240 1
a240 1
      bfd_boolean copy;
d255 1
a255 1
	      return TRUE;
d271 1
a271 1
	    return FALSE;
d281 1
a281 1
	  copy = FALSE;
d289 1
a289 1
	    return FALSE;
d293 1
a293 1
	  copy = TRUE;
d302 1
a302 1
	return FALSE;
d306 1
a306 1
  return TRUE;
d379 1
a379 1
  dynstr_index = _bfd_elf_strtab_add (dynstr, name, FALSE);
d421 1
a421 1
static bfd_boolean elf_link_renumber_hash_table_dynsyms
d424 1
a424 1
static bfd_boolean
d437 1
a437 1
  return TRUE;
d509 1
a509 1
      lsect->hole_written_p = FALSE;
d562 1
a562 1
				     FALSE, FALSE, FALSE);
d570 1
a570 1
		    (const char *) NULL, FALSE,
d623 1
a623 1
bfd_boolean
d630 1
a630 1
    return TRUE;
d646 1
a646 1
	return FALSE;
d649 1
a649 1
  return TRUE;
@


1.27.10.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d34 1
a34 1
  asection *s;
d41 1
a41 2
  s = bfd_get_section_by_name (abfd, ".got");
  if (s != NULL && (s->flags & SEC_LINKER_CREATED) != 0)
d114 1
a114 1
  asection *s;
d275 1
a275 1
	 table.  */
d528 2
a529 2
      /* Is there a hole we have to provide?  If so check whether the
	 segment is too big already */
d536 4
a539 5
	      (*_bfd_error_handler)
		(_("%s: Section %s is too large to add hole of %ld bytes"),
		 bfd_get_filename (abfd),
		 lsect->name,
		 (long) lsect->hole_size);
@


1.27.10.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a27 3
static bfd_boolean elf_link_read_relocs_from_section
  PARAMS ((bfd *, Elf_Internal_Shdr *, PTR, Elf_Internal_Rela *));

d107 1
a107 6
/* Create some sections which will be filled in with dynamic linking
   information.  ABFD is an input file which requires dynamic sections
   to be created.  The dynamic sections take up virtual memory space
   when the final executable is run, so we need to create them before
   addresses are assigned to the output sections.  We work out the
   actual contents and size of these sections later.  */
d110 1
a110 1
_bfd_elf_link_create_dynamic_sections (abfd, info)
d114 4
a117 5
  flagword flags;
  register asection *s;
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  struct elf_backend_data *bed;
d119 1
a119 20
  if (! is_elf_hash_table (info))
    return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    return TRUE;

  /* Make sure that all dynamic sections use the same input BFD.  */
  if (elf_hash_table (info)->dynobj == NULL)
    elf_hash_table (info)->dynobj = abfd;
  else
    abfd = elf_hash_table (info)->dynobj;

  /* Note that we set the SEC_IN_MEMORY flag for all of these
     sections.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
	   | SEC_IN_MEMORY | SEC_LINKER_CREATED);

  /* A dynamically linked executable has a .interp section, but a
     shared library does not.  */
  if (! info->shared)
d121 3
a123 5
      s = bfd_make_section (abfd, ".interp");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
	return FALSE;
    }
d125 3
a127 10
  if (! info->traditional_format
      && info->hash->creator->flavour == bfd_target_elf_flavour)
    {
      s = bfd_make_section (abfd, ".eh_frame_hdr");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;
      elf_hash_table (info)->eh_info.hdr_sec = s;
    }
d129 3
a131 39
  bed = get_elf_backend_data (abfd);

  /* Create sections to hold version informations.  These are removed
     if they are not needed.  */
  s = bfd_make_section (abfd, ".gnu.version_d");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section (abfd, ".gnu.version");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, 1))
    return FALSE;

  s = bfd_make_section (abfd, ".gnu.version_r");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section (abfd, ".dynsym");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  s = bfd_make_section (abfd, ".dynstr");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
    return FALSE;

  /* Create a strtab to hold the dynamic symbol names.  */
  if (elf_hash_table (info)->dynstr == NULL)
    {
      elf_hash_table (info)->dynstr = _bfd_elf_strtab_init ();
      if (elf_hash_table (info)->dynstr == NULL)
	return FALSE;
a133 56
  s = bfd_make_section (abfd, ".dynamic");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;

  /* The special symbol _DYNAMIC is always set to the start of the
     .dynamic section.  This call occurs before we have processed the
     symbols for any dynamic object, so we don't have to worry about
     overriding a dynamic definition.  We could set _DYNAMIC in a
     linker script, but we only want to define it if we are, in fact,
     creating a .dynamic section.  We don't want to define it if there
     is no .dynamic section, since on some ELF platforms the start up
     code examines it to decide how to initialize the process.  */
  bh = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_DYNAMIC", BSF_GLOBAL, s, (bfd_vma) 0,
	  (const char *) 0, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  if (info->shared
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;

  s = bfd_make_section (abfd, ".hash");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  elf_section_data (s)->this_hdr.sh_entsize = bed->s->sizeof_hash_entry;

  /* Let the backend create the rest of the sections.  This lets the
     backend set the right flags.  The backend will normally create
     the .got and .plt sections.  */
  if (! (*bed->elf_backend_create_dynamic_sections) (abfd, info))
    return FALSE;

  elf_hash_table (info)->dynamic_sections_created = TRUE;

  return TRUE;
}

/* Create dynamic sections when linking against a dynamic object.  */

bfd_boolean
_bfd_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  flagword flags, pltflags;
  asection *s;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

d178 1
a178 1
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
d215 1
a215 1
	      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
a308 64

/* Record an assignment to a symbol made by a linker script.  We need
   this in case some dynamic object refers to this symbol.  */

bfd_boolean
bfd_elf_record_link_assignment (output_bfd, info, name, provide)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     const char *name;
     bfd_boolean provide;
{
  struct elf_link_hash_entry *h;

  if (info->hash->creator->flavour != bfd_target_elf_flavour)
    return TRUE;

  h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, TRUE, FALSE);
  if (h == NULL)
    return FALSE;

  if (h->root.type == bfd_link_hash_new)
    h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;

  /* If this symbol is being provided by the linker script, and it is
     currently defined by a dynamic object, but not by a regular
     object, then mark it as undefined so that the generic linker will
     force the correct value.  */
  if (provide
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    h->root.type = bfd_link_hash_undefined;

  /* If this symbol is not being provided by the linker script, and it is
     currently defined by a dynamic object, but not by a regular object,
     then clear out any version information because the symbol will not be
     associated with the dynamic object any more.  */
  if (!provide
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    h->verinfo.verdef = NULL;

  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;

  if (((h->elf_link_hash_flags & (ELF_LINK_HASH_DEF_DYNAMIC
				  | ELF_LINK_HASH_REF_DYNAMIC)) != 0
       || info->shared)
      && h->dynindx == -1)
    {
      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;

      /* If this is a weak defined symbol, and we know a corresponding
	 real symbol from the same dynamic object, make sure the real
	 symbol is also made into a dynamic symbol.  */
      if (h->weakdef != NULL
	  && h->weakdef->dynindx == -1)
	{
	  if (! _bfd_elf_link_record_dynamic_symbol (info, h->weakdef))
	    return FALSE;
	}
    }

  return TRUE;
}
d480 3
d484 2
a485 15
/* This function is called when we want to define a new symbol.  It
   handles the various cases which arise when we find a definition in
   a dynamic object, or when there is already a definition in a
   dynamic object.  The new symbol is described by NAME, SYM, PSEC,
   and PVALUE.  We set SYM_HASH to the hash table entry.  We set
   OVERRIDE if the old symbol is overriding a new definition.  We set
   TYPE_CHANGE_OK if it is OK for the type to change.  We set
   SIZE_CHANGE_OK if it is OK for the size to change.  By OK to
   change, we mean that we shouldn't warn if the type or size does
   change. DT_NEEDED indicates if it comes from a DT_NEEDED entry of
   a shared object.  */

bfd_boolean
_bfd_elf_merge_symbol (abfd, info, name, sym, psec, pvalue, sym_hash, skip,
		       override, type_change_ok, size_change_ok, dt_needed)
d488 2
a489 10
     const char *name;
     Elf_Internal_Sym *sym;
     asection **psec;
     bfd_vma *pvalue;
     struct elf_link_hash_entry **sym_hash;
     bfd_boolean *skip;
     bfd_boolean *override;
     bfd_boolean *type_change_ok;
     bfd_boolean *size_change_ok;
     bfd_boolean dt_needed;
d491 2
a492 22
  asection *sec;
  struct elf_link_hash_entry *h;
  struct elf_link_hash_entry *flip;
  int bind;
  bfd *oldbfd;
  bfd_boolean newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
  bfd_boolean newweakdef, oldweakdef, newweakundef, oldweakundef;

  *skip = FALSE;
  *override = FALSE;

  sec = *psec;
  bind = ELF_ST_BIND (sym->st_info);

  if (! bfd_is_und_section (sec))
    h = elf_link_hash_lookup (elf_hash_table (info), name, TRUE, FALSE, FALSE);
  else
    h = ((struct elf_link_hash_entry *)
	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, FALSE, FALSE));
  if (h == NULL)
    return FALSE;
  *sym_hash = h;
d494 3
a496 4
  /* This code is for coping with dynamic objects, and is only useful
     if we are doing an ELF link.  */
  if (info->hash->creator != abfd->xvec)
    return TRUE;
d498 3
a500 11
  /* For merging, we only care about real symbols.  */

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* If we just created the symbol, mark it as being an ELF symbol.
     Other than that, there is nothing to do--there is no merge issue
     with a newly defined symbol--so we just return.  */

  if (h->root.type == bfd_link_hash_new)
d502 2
a503 3
      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
      return TRUE;
    }
d505 1
a505 1
  /* OLDBFD is a BFD associated with the existing symbol.  */
d507 4
a510 5
  switch (h->root.type)
    {
    default:
      oldbfd = NULL;
      break;
d512 3
a514 43
    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      oldbfd = h->root.u.undef.abfd;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      oldbfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      oldbfd = h->root.u.c.p->section->owner;
      break;
    }

  /* In cases involving weak versioned symbols, we may wind up trying
     to merge a symbol with itself.  Catch that here, to avoid the
     confusion that results if we try to override a symbol with
     itself.  The additional tests catch cases like
     _GLOBAL_OFFSET_TABLE_, which are regular symbols defined in a
     dynamic object, which we do want to handle here.  */
  if (abfd == oldbfd
      && ((abfd->flags & DYNAMIC) == 0
	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
    return TRUE;

  /* NEWDYN and OLDDYN indicate whether the new or old symbol,
     respectively, is from a dynamic object.  */

  if ((abfd->flags & DYNAMIC) != 0)
    newdyn = TRUE;
  else
    newdyn = FALSE;

  if (oldbfd != NULL)
    olddyn = (oldbfd->flags & DYNAMIC) != 0;
  else
    {
      asection *hsec;

      /* This code handles the special SHN_MIPS_{TEXT,DATA} section
	 indices used by MIPS ELF.  */
      switch (h->root.type)
d516 1
a516 3
	default:
	  hsec = NULL;
	  break;
d518 2
a519 4
	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
	  hsec = h->root.u.def.section;
	  break;
d521 2
a522 3
	case bfd_link_hash_common:
	  hsec = h->root.u.c.p->section;
	  break;
d524 2
d527 1
a527 5
      if (hsec == NULL)
	olddyn = FALSE;
      else
	olddyn = (hsec->symbol->flags & BSF_DYNAMIC) != 0;
    }
d529 13
a541 2
  /* NEWDEF and OLDDEF indicate whether the new or old symbol,
     respectively, appear to be a definition rather than reference.  */
d543 2
a544 28
  if (bfd_is_und_section (sec) || bfd_is_com_section (sec))
    newdef = FALSE;
  else
    newdef = TRUE;

  if (h->root.type == bfd_link_hash_undefined
      || h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_common)
    olddef = FALSE;
  else
    olddef = TRUE;

  /* We need to rememeber if a symbol has a definition in a dynamic
     object or is weak in all dynamic objects. Internal and hidden
     visibility will make it unavailable to dynamic objects.  */
  if (newdyn && (h->elf_link_hash_flags & ELF_LINK_DYNAMIC_DEF) == 0)
    {
      if (!bfd_is_und_section (sec))
	h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_DEF;
      else
	{
	  /* Check if this symbol is weak in all dynamic objects. If it
	     is the first time we see it in a dynamic object, we mark
	     if it is weak. Otherwise, we clear it.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	    { 
	      if (bind == STB_WEAK)
		h->elf_link_hash_flags |= ELF_LINK_DYNAMIC_WEAK;
a545 2
	  else if (bind != STB_WEAK)
	    h->elf_link_hash_flags &= ~ELF_LINK_DYNAMIC_WEAK;
a546 1
    }
d548 4
a551 40
  /* If the old symbol has non-default visibility, we ignore the new
     definition from a dynamic object.  */
  if (newdyn
      && ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
      && !bfd_is_und_section (sec))
    {
      *skip = TRUE;
      /* Make sure this symbol is dynamic.  */
      h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      /* A protected symbol has external availability. Make sure it is
	 recorded as dynamic.

	 FIXME: Should we check type and size for protected symbol?  */
      if (ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)
	return _bfd_elf_link_record_dynamic_symbol (info, h);
      else
	return TRUE;
    }
  else if (!newdyn
	   && ELF_ST_VISIBILITY (sym->st_other) != STV_DEFAULT
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
    {
      /* If the new symbol with non-default visibility comes from a
	 relocatable file and the old definition comes from a dynamic
	 object, we remove the old definition.  */
      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	h = *sym_hash;
      h->root.type = bfd_link_hash_new;
      h->root.u.undef.abfd = NULL;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_DYNAMIC
				     | ELF_LINK_DYNAMIC_DEF);
	}
      /* FIXME: Should we check type and size for protected symbol?  */
      h->size = 0;
      h->type = 0;
      return TRUE;
    }
d553 1
a553 5
  /* We need to treat weak definiton right, depending on if there is a
     definition from a dynamic object.  */
  if (bind == STB_WEAK)
    {
      if (olddef)
d555 2
a556 11
	   newweakdef = TRUE;
	   newweakundef = FALSE;
	}
      else
	{
	   newweakdef = FALSE;
	   newweakundef = TRUE;
	}
    }
  else
    newweakdef = newweakundef = FALSE;
d558 7
a564 5
  /* If the new weak definition comes from a relocatable file and the
     old symbol comes from a dynamic object, we treat the new one as
     strong.  */
  if (newweakdef && !newdyn && olddyn)
    newweakdef = FALSE;
d566 10
a575 12
  if (h->root.type == bfd_link_hash_defweak)
    {
      oldweakdef = TRUE;
      oldweakundef = FALSE;
    }
  else if (h->root.type == bfd_link_hash_undefweak)
    {
      oldweakdef = FALSE;
      oldweakundef = TRUE;
    }
  else
    oldweakdef = oldweakundef = FALSE;
d577 3
a579 89
  /* If the old weak definition comes from a relocatable file and the
     new symbol comes from a dynamic object, we treat the old one as
     strong.  */
  if (oldweakdef && !olddyn && newdyn)
    oldweakdef = FALSE;

  /* NEWDYNCOMMON and OLDDYNCOMMON indicate whether the new or old
     symbol, respectively, appears to be a common symbol in a dynamic
     object.  If a symbol appears in an uninitialized section, and is
     not weak, and is not a function, then it may be a common symbol
     which was resolved when the dynamic object was created.  We want
     to treat such symbols specially, because they raise special
     considerations when setting the symbol size: if the symbol
     appears as a common symbol in a regular object, and the size in
     the regular object is larger, we must make sure that we use the
     larger size.  This problematic case can always be avoided in C,
     but it must be handled correctly when using Fortran shared
     libraries.

     Note that if NEWDYNCOMMON is set, NEWDEF will be set, and
     likewise for OLDDYNCOMMON and OLDDEF.

     Note that this test is just a heuristic, and that it is quite
     possible to have an uninitialized symbol in a shared object which
     is really a definition, rather than a common symbol.  This could
     lead to some minor confusion when the symbol really is a common
     symbol in some regular object.  However, I think it will be
     harmless.  */

  if (newdyn
      && newdef
      && (sec->flags & SEC_ALLOC) != 0
      && (sec->flags & SEC_LOAD) == 0
      && sym->st_size > 0
      && !newweakdef
      && !newweakundef
      && ELF_ST_TYPE (sym->st_info) != STT_FUNC)
    newdyncommon = TRUE;
  else
    newdyncommon = FALSE;

  if (olddyn
      && olddef
      && h->root.type == bfd_link_hash_defined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && (h->root.u.def.section->flags & SEC_ALLOC) != 0
      && (h->root.u.def.section->flags & SEC_LOAD) == 0
      && h->size > 0
      && h->type != STT_FUNC)
    olddyncommon = TRUE;
  else
    olddyncommon = FALSE;

  /* It's OK to change the type if either the existing symbol or the
     new symbol is weak unless it comes from a DT_NEEDED entry of
     a shared object, in which case, the DT_NEEDED entry may not be
     required at the run time.  */

  if ((! dt_needed && oldweakdef)
      || oldweakundef
      || newweakdef
      || newweakundef)
    *type_change_ok = TRUE;

  /* It's OK to change the size if either the existing symbol or the
     new symbol is weak, or if the old symbol is undefined.  */

  if (*type_change_ok
      || h->root.type == bfd_link_hash_undefined)
    *size_change_ok = TRUE;

  /* If both the old and the new symbols look like common symbols in a
     dynamic object, set the size of the symbol to the larger of the
     two.  */

  if (olddyncommon
      && newdyncommon
      && sym->st_size != h->size)
    {
      /* Since we think we have two common symbols, issue a multiple
	 common warning if desired.  Note that we only warn if the
	 size is different.  If the size is the same, we simply let
	 the old symbol override the new one as normally happens with
	 symbols defined in dynamic objects.  */

      if (! ((*info->callbacks->multiple_common)
	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
	return FALSE;
d581 2
a582 2
      if (sym->st_size > h->size)
	h->size = sym->st_size;
d584 4
a587 1
      *size_change_ok = TRUE;
d590 8
a597 43
  /* If we are looking at a dynamic object, and we have found a
     definition, we need to see if the symbol was already defined by
     some other object.  If so, we want to use the existing
     definition, and we do not want to report a multiple symbol
     definition error; we do this by clobbering *PSEC to be
     bfd_und_section_ptr.

     We treat a common symbol as a definition if the symbol in the
     shared library is a function, since common symbols always
     represent variables; this can cause confusion in principle, but
     any such confusion would seem to indicate an erroneous program or
     shared library.  We also permit a common symbol in a regular
     object to override a weak symbol in a shared object.

     We prefer a non-weak definition in a shared library to a weak
     definition in the executable unless it comes from a DT_NEEDED
     entry of a shared object, in which case, the DT_NEEDED entry
     may not be required at the run time.  */

  if (newdyn
      && newdef
      && (olddef
	  || (h->root.type == bfd_link_hash_common
	      && (newweakdef
		  || newweakundef
		  || ELF_ST_TYPE (sym->st_info) == STT_FUNC)))
      && (!oldweakdef
	  || dt_needed
	  || newweakdef
	  || newweakundef))
    {
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;

      *psec = sec = bfd_und_section_ptr;
      *size_change_ok = TRUE;

      /* If we get here when the old symbol is a common symbol, then
	 we are explicitly letting it override a weak symbol or
	 function in a dynamic object, and we don't want to warn about
	 a type change.  If the old symbol is a defined symbol, a type
	 change warning may still be appropriate.  */
d599 3
a601 3
      if (h->root.type == bfd_link_hash_common)
	*type_change_ok = TRUE;
    }
d603 4
a606 948
  /* Handle the special case of an old common symbol merging with a
     new symbol which looks like a common symbol in a shared object.
     We change *PSEC and *PVALUE to make the new symbol look like a
     common symbol, and let _bfd_generic_link_add_one_symbol will do
     the right thing.  */

  if (newdyncommon
      && h->root.type == bfd_link_hash_common)
    {
      *override = TRUE;
      newdef = FALSE;
      newdyncommon = FALSE;
      *pvalue = sym->st_size;
      *psec = sec = bfd_com_section_ptr;
      *size_change_ok = TRUE;
    }

  /* If the old symbol is from a dynamic object, and the new symbol is
     a definition which is not from a dynamic object, then the new
     symbol overrides the old symbol.  Symbols from regular files
     always take precedence over symbols from dynamic objects, even if
     they are defined after the dynamic object in the link.

     As above, we again permit a common symbol in a regular object to
     override a definition in a shared object if the shared object
     symbol is a function or is weak.

     As above, we permit a non-weak definition in a shared object to
     override a weak definition in a regular object.  */

  flip = NULL;
  if (! newdyn
      && (newdef
	  || (bfd_is_com_section (sec)
	      && (oldweakdef || h->type == STT_FUNC)))
      && olddyn
      && olddef
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
      && ((!newweakdef && !newweakundef) || oldweakdef))
    {
      /* Change the hash table entry to undefined, and let
	 _bfd_generic_link_add_one_symbol do the right thing with the
	 new definition.  */

      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;
      *size_change_ok = TRUE;

      olddef = FALSE;
      olddyncommon = FALSE;

      /* We again permit a type change when a common symbol may be
	 overriding a function.  */

      if (bfd_is_com_section (sec))
	*type_change_ok = TRUE;

      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	/* This union may have been set to be non-NULL when this symbol
	   was seen in a dynamic object.  We must force the union to be
	   NULL, so that it is correct for a regular symbol.  */
	h->verinfo.vertree = NULL;
    }

  /* Handle the special case of a new common symbol merging with an
     old symbol that looks like it might be a common symbol defined in
     a shared object.  Note that we have already handled the case in
     which a new common symbol should simply override the definition
     in the shared library.  */

  if (! newdyn
      && bfd_is_com_section (sec)
      && olddyncommon)
    {
      /* It would be best if we could set the hash table entry to a
	 common symbol, but we don't know what to use for the section
	 or the alignment.  */
      if (! ((*info->callbacks->multiple_common)
	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
	return FALSE;

      /* If the predumed common symbol in the dynamic object is
	 larger, pretend that the new symbol has its size.  */

      if (h->size > *pvalue)
	*pvalue = h->size;

      /* FIXME: We no longer know the alignment required by the symbol
	 in the dynamic object, so we just wind up using the one from
	 the regular object.  */

      olddef = FALSE;
      olddyncommon = FALSE;

      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;

      *size_change_ok = TRUE;
      *type_change_ok = TRUE;

      if ((*sym_hash)->root.type == bfd_link_hash_indirect)
	flip = *sym_hash;
      else
	h->verinfo.vertree = NULL;
    }

  if (flip != NULL)
    {
      /* Handle the case where we had a versioned symbol in a dynamic
	 library and now find a definition in a normal object.  In this
	 case, we make the versioned symbol point to the normal one.  */
      struct elf_backend_data *bed = get_elf_backend_data (abfd);
      flip->root.type = h->root.type;
      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) flip;
      (*bed->elf_backend_copy_indirect_symbol) (bed, flip, h);
      flip->root.u.undef.abfd = h->root.u.undef.abfd;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_DEF_DYNAMIC;
	  flip->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	}
    }

  /* Handle the special case of a weak definition in a regular object
     followed by a non-weak definition in a shared object.  In this
     case, we prefer the definition in the shared object unless it
     comes from a DT_NEEDED entry of a shared object, in which case,
     the DT_NEEDED entry may not be required at the run time.  */
  if (olddef
      && ! dt_needed
      && oldweakdef
      && newdef
      && newdyn
      && !newweakdef
      && !newweakundef)
    {
      /* To make this work we have to frob the flags so that the rest
	 of the code does not think we are using the regular
	 definition.  */
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
      else if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
	h->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
      h->elf_link_hash_flags &= ~ (ELF_LINK_HASH_DEF_REGULAR
				   | ELF_LINK_HASH_DEF_DYNAMIC);

      /* If H is the target of an indirection, we want the caller to
	 use H rather than the indirect symbol.  Otherwise if we are
	 defining a new indirect symbol we will wind up attaching it
	 to the entry we are overriding.  */
      *sym_hash = h;
    }

  /* Handle the special case of a non-weak definition in a shared
     object followed by a weak definition in a regular object.  In
     this case we prefer the definition in the shared object.  To make
     this work we have to tell the caller to not treat the new symbol
     as a definition.  */
  if (olddef
      && olddyn
      && !oldweakdef
      && newdef
      && ! newdyn
      && (newweakdef || newweakundef))
    *override = TRUE;

  return TRUE;
}

/* This function is called to create an indirect symbol from the
   default for the symbol with the default version if needed. The
   symbol is described by H, NAME, SYM, PSEC, VALUE, and OVERRIDE.  We
   set DYNSYM if the new indirect symbol is dynamic. DT_NEEDED
   indicates if it comes from a DT_NEEDED entry of a shared object.  */

bfd_boolean
_bfd_elf_add_default_symbol (abfd, info, h, name, sym, psec, value,
			     dynsym, override, dt_needed)
     bfd *abfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     const char *name;
     Elf_Internal_Sym *sym;
     asection **psec;
     bfd_vma *value;
     bfd_boolean *dynsym;
     bfd_boolean override;
     bfd_boolean dt_needed;
{
  bfd_boolean type_change_ok;
  bfd_boolean size_change_ok;
  bfd_boolean skip;
  char *shortname;
  struct elf_link_hash_entry *hi;
  struct bfd_link_hash_entry *bh;
  struct elf_backend_data *bed;
  bfd_boolean collect;
  bfd_boolean dynamic;
  char *p;
  size_t len, shortlen;
  asection *sec;

  /* If this symbol has a version, and it is the default version, we
     create an indirect symbol from the default name to the fully
     decorated name.  This will cause external references which do not
     specify a version to be bound to this version of the symbol.  */
  p = strchr (name, ELF_VER_CHR);
  if (p == NULL || p[1] != ELF_VER_CHR)
    return TRUE;

  if (override)
    {
      /* We are overridden by an old defition. We need to check if we
	 need to create the indirect symbol from the default name.  */
      hi = elf_link_hash_lookup (elf_hash_table (info), name, TRUE,
				 FALSE, FALSE);
      BFD_ASSERT (hi != NULL);
      if (hi == h)
	return TRUE;
      while (hi->root.type == bfd_link_hash_indirect
	     || hi->root.type == bfd_link_hash_warning)
	{
	  hi = (struct elf_link_hash_entry *) hi->root.u.i.link;
	  if (hi == h)
	    return TRUE;
	}
    }

  bed = get_elf_backend_data (abfd);
  collect = bed->collect;
  dynamic = (abfd->flags & DYNAMIC) != 0;

  shortlen = p - name;
  shortname = bfd_hash_allocate (&info->hash->table, shortlen + 1);
  if (shortname == NULL)
    return FALSE;
  memcpy (shortname, name, shortlen);
  shortname[shortlen] = '\0';

  /* We are going to create a new symbol.  Merge it with any existing
     symbol with this name.  For the purposes of the merge, act as
     though we were defining the symbol we just defined, although we
     actually going to define an indirect symbol.  */
  type_change_ok = FALSE;
  size_change_ok = FALSE;
  sec = *psec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
			      &hi, &skip, &override, &type_change_ok,
			      &size_change_ok, dt_needed))
    return FALSE;

  if (skip)
    goto nondefault;

  if (! override)
    {
      bh = &hi->root;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, shortname, BSF_INDIRECT, bfd_ind_section_ptr,
	      (bfd_vma) 0, name, FALSE, collect, &bh)))
	return FALSE;
      hi = (struct elf_link_hash_entry *) bh;
    }
  else
    {
      /* In this case the symbol named SHORTNAME is overriding the
	 indirect symbol we want to add.  We were planning on making
	 SHORTNAME an indirect symbol referring to NAME.  SHORTNAME
	 is the name without a version.  NAME is the fully versioned
	 name, and it is the default version.

	 Overriding means that we already saw a definition for the
	 symbol SHORTNAME in a regular object, and it is overriding
	 the symbol defined in the dynamic object.

	 When this happens, we actually want to change NAME, the
	 symbol we just added, to refer to SHORTNAME.  This will cause
	 references to NAME in the shared object to become references
	 to SHORTNAME in the regular object.  This is what we expect
	 when we override a function in a shared object: that the
	 references in the shared object will be mapped to the
	 definition in the regular object.  */

      while (hi->root.type == bfd_link_hash_indirect
	     || hi->root.type == bfd_link_hash_warning)
	hi = (struct elf_link_hash_entry *) hi->root.u.i.link;

      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
      if (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
	{
	  h->elf_link_hash_flags &=~ ELF_LINK_HASH_DEF_DYNAMIC;
	  hi->elf_link_hash_flags |= ELF_LINK_HASH_REF_DYNAMIC;
	  if (hi->elf_link_hash_flags
	      & (ELF_LINK_HASH_REF_REGULAR
		 | ELF_LINK_HASH_DEF_REGULAR))
	    {
	      if (! _bfd_elf_link_record_dynamic_symbol (info, hi))
		return FALSE;
	    }
	}

      /* Now set HI to H, so that the following code will set the
	 other fields correctly.  */
      hi = h;
    }

  /* If there is a duplicate definition somewhere, then HI may not
     point to an indirect symbol.  We will have reported an error to
     the user in that case.  */

  if (hi->root.type == bfd_link_hash_indirect)
    {
      struct elf_link_hash_entry *ht;

      /* If the symbol became indirect, then we assume that we have
	 not seen a definition before.  */
      BFD_ASSERT ((hi->elf_link_hash_flags
		   & (ELF_LINK_HASH_DEF_DYNAMIC
		      | ELF_LINK_HASH_DEF_REGULAR)) == 0);

      ht = (struct elf_link_hash_entry *) hi->root.u.i.link;
      (*bed->elf_backend_copy_indirect_symbol) (bed, ht, hi);

      /* See if the new flags lead us to realize that the symbol must
	 be dynamic.  */
      if (! *dynsym)
	{
	  if (! dynamic)
	    {
	      if (info->shared
		  || ((hi->elf_link_hash_flags
		       & ELF_LINK_HASH_REF_DYNAMIC) != 0))
		*dynsym = TRUE;
	    }
	  else
	    {
	      if ((hi->elf_link_hash_flags
		   & ELF_LINK_HASH_REF_REGULAR) != 0)
		*dynsym = TRUE;
	    }
	}
    }

  /* We also need to define an indirection from the nondefault version
     of the symbol.  */

nondefault:
  len = strlen (name);
  shortname = bfd_hash_allocate (&info->hash->table, len);
  if (shortname == NULL)
    return FALSE;
  memcpy (shortname, name, shortlen);
  memcpy (shortname + shortlen, p + 1, len - shortlen);

  /* Once again, merge with any existing symbol.  */
  type_change_ok = FALSE;
  size_change_ok = FALSE;
  sec = *psec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &sec, value,
			      &hi, &skip, &override, &type_change_ok,
			      &size_change_ok, dt_needed))
    return FALSE;

  if (skip)
    return TRUE;

  if (override)
    {
      /* Here SHORTNAME is a versioned name, so we don't expect to see
	 the type of override we do in the case above unless it is
	 overridden by a versioned definiton.  */
      if (hi->root.type != bfd_link_hash_defined
	  && hi->root.type != bfd_link_hash_defweak)
	(*_bfd_error_handler)
	  (_("%s: warning: unexpected redefinition of indirect versioned symbol `%s'"),
	   bfd_archive_filename (abfd), shortname);
    }
  else
    {
      bh = &hi->root;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, shortname, BSF_INDIRECT,
	      bfd_ind_section_ptr, (bfd_vma) 0, name, FALSE, collect, &bh)))
	return FALSE;
      hi = (struct elf_link_hash_entry *) bh;

      /* If there is a duplicate definition somewhere, then HI may not
	 point to an indirect symbol.  We will have reported an error
	 to the user in that case.  */

      if (hi->root.type == bfd_link_hash_indirect)
	{
	  /* If the symbol became indirect, then we assume that we have
	     not seen a definition before.  */
	  BFD_ASSERT ((hi->elf_link_hash_flags
		       & (ELF_LINK_HASH_DEF_DYNAMIC
			  | ELF_LINK_HASH_DEF_REGULAR)) == 0);

	  (*bed->elf_backend_copy_indirect_symbol) (bed, h, hi);

	  /* See if the new flags lead us to realize that the symbol
	     must be dynamic.  */
	  if (! *dynsym)
	    {
	      if (! dynamic)
		{
		  if (info->shared
		      || ((hi->elf_link_hash_flags
			   & ELF_LINK_HASH_REF_DYNAMIC) != 0))
		    *dynsym = TRUE;
		}
	      else
		{
		  if ((hi->elf_link_hash_flags
		       & ELF_LINK_HASH_REF_REGULAR) != 0)
		    *dynsym = TRUE;
		}
	    }
	}
    }

  return TRUE;
}

/* This routine is used to export all defined symbols into the dynamic
   symbol table.  It is called via elf_link_hash_traverse.  */

bfd_boolean
_bfd_elf_export_symbol (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_info_failed *eif = (struct elf_info_failed *) data;

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx == -1
      && (h->elf_link_hash_flags
	  & (ELF_LINK_HASH_DEF_REGULAR | ELF_LINK_HASH_REF_REGULAR)) != 0)
    {
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;

      for (t = eif->verdefs; t != NULL; t = t->next)
	{
	  if (t->globals != NULL)
	    {
	      for (d = t->globals; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    goto doit;
		}
	    }

	  if (t->locals != NULL)
	    {
	      for (d = t->locals ; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    return TRUE;
		}
	    }
	}

      if (!eif->verdefs)
	{
	doit:
	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
	    {
	      eif->failed = TRUE;
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Look through the symbols which are defined in other shared
   libraries and referenced here.  Update the list of version
   dependencies.  This will be put into the .gnu.version_r section.
   This function is called via elf_link_hash_traverse.  */

bfd_boolean
_bfd_elf_link_find_version_dependencies (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_find_verdep_info *rinfo = (struct elf_find_verdep_info *) data;
  Elf_Internal_Verneed *t;
  Elf_Internal_Vernaux *a;
  bfd_size_type amt;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* We only care about symbols defined in shared objects with version
     information.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
      || h->dynindx == -1
      || h->verinfo.verdef == NULL)
    return TRUE;

  /* See if we already know about this version.  */
  for (t = elf_tdata (rinfo->output_bfd)->verref; t != NULL; t = t->vn_nextref)
    {
      if (t->vn_bfd != h->verinfo.verdef->vd_bfd)
	continue;

      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
	if (a->vna_nodename == h->verinfo.verdef->vd_nodename)
	  return TRUE;

      break;
    }

  /* This is a new version.  Add it to tree we are building.  */

  if (t == NULL)
    {
      amt = sizeof *t;
      t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->output_bfd, amt);
      if (t == NULL)
	{
	  rinfo->failed = TRUE;
	  return FALSE;
	}

      t->vn_bfd = h->verinfo.verdef->vd_bfd;
      t->vn_nextref = elf_tdata (rinfo->output_bfd)->verref;
      elf_tdata (rinfo->output_bfd)->verref = t;
    }

  amt = sizeof *a;
  a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->output_bfd, amt);

  /* Note that we are copying a string pointer here, and testing it
     above.  If bfd_elf_string_from_elf_section is ever changed to
     discard the string data when low in memory, this will have to be
     fixed.  */
  a->vna_nodename = h->verinfo.verdef->vd_nodename;

  a->vna_flags = h->verinfo.verdef->vd_flags;
  a->vna_nextptr = t->vn_auxptr;

  h->verinfo.verdef->vd_exp_refno = rinfo->vers;
  ++rinfo->vers;

  a->vna_other = h->verinfo.verdef->vd_exp_refno + 1;

  t->vn_auxptr = a;

  return TRUE;
}

/* Figure out appropriate versions for all the symbols.  We may not
   have the version number script until we have read all of the input
   files, so until that point we don't know which symbols should be
   local.  This function is called via elf_link_hash_traverse.  */

bfd_boolean
_bfd_elf_link_assign_sym_version (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_assign_sym_version_info *sinfo;
  struct bfd_link_info *info;
  struct elf_backend_data *bed;
  struct elf_info_failed eif;
  char *p;
  bfd_size_type amt;

  sinfo = (struct elf_assign_sym_version_info *) data;
  info = sinfo->info;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* Fix the symbol flags.  */
  eif.failed = FALSE;
  eif.info = info;
  if (! _bfd_elf_fix_symbol_flags (h, &eif))
    {
      if (eif.failed)
	sinfo->failed = TRUE;
      return FALSE;
    }

  /* We only need version numbers for symbols defined in regular
     objects.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return TRUE;

  bed = get_elf_backend_data (sinfo->output_bfd);
  p = strchr (h->root.root.string, ELF_VER_CHR);
  if (p != NULL && h->verinfo.vertree == NULL)
    {
      struct bfd_elf_version_tree *t;
      bfd_boolean hidden;

      hidden = TRUE;

      /* There are two consecutive ELF_VER_CHR characters if this is
	 not a hidden symbol.  */
      ++p;
      if (*p == ELF_VER_CHR)
	{
	  hidden = FALSE;
	  ++p;
	}

      /* If there is no version string, we can just return out.  */
      if (*p == '\0')
	{
	  if (hidden)
	    h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
	  return TRUE;
	}

      /* Look for the version.  If we find it, it is no longer weak.  */
      for (t = sinfo->verdefs; t != NULL; t = t->next)
	{
	  if (strcmp (t->name, p) == 0)
	    {
	      size_t len;
	      char *alc;
	      struct bfd_elf_version_expr *d;

	      len = p - h->root.root.string;
	      alc = bfd_malloc ((bfd_size_type) len);
	      if (alc == NULL)
		return FALSE;
	      memcpy (alc, h->root.root.string, len - 1);
	      alc[len - 1] = '\0';
	      if (alc[len - 2] == ELF_VER_CHR)
		alc[len - 2] = '\0';

	      h->verinfo.vertree = t;
	      t->used = TRUE;
	      d = NULL;

	      if (t->globals != NULL)
		{
		  for (d = t->globals; d != NULL; d = d->next)
		    if ((*d->match) (d, alc))
		      break;
		}

	      /* See if there is anything to force this symbol to
		 local scope.  */
	      if (d == NULL && t->locals != NULL)
		{
		  for (d = t->locals; d != NULL; d = d->next)
		    {
		      if ((*d->match) (d, alc))
			{
			  if (h->dynindx != -1
			      && info->shared
			      && ! info->export_dynamic)
			    {
			      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
			    }

			  break;
			}
		    }
		}

	      free (alc);
	      break;
	    }
	}

      /* If we are building an application, we need to create a
	 version node for this version.  */
      if (t == NULL && ! info->shared)
	{
	  struct bfd_elf_version_tree **pp;
	  int version_index;

	  /* If we aren't going to export this symbol, we don't need
	     to worry about it.  */
	  if (h->dynindx == -1)
	    return TRUE;

	  amt = sizeof *t;
	  t = ((struct bfd_elf_version_tree *)
	       bfd_alloc (sinfo->output_bfd, amt));
	  if (t == NULL)
	    {
	      sinfo->failed = TRUE;
	      return FALSE;
	    }

	  t->next = NULL;
	  t->name = p;
	  t->globals = NULL;
	  t->locals = NULL;
	  t->deps = NULL;
	  t->name_indx = (unsigned int) -1;
	  t->used = TRUE;

	  version_index = 1;
	  /* Don't count anonymous version tag.  */
	  if (sinfo->verdefs != NULL && sinfo->verdefs->vernum == 0)
	    version_index = 0;
	  for (pp = &sinfo->verdefs; *pp != NULL; pp = &(*pp)->next)
	    ++version_index;
	  t->vernum = version_index;

	  *pp = t;

	  h->verinfo.vertree = t;
	}
      else if (t == NULL)
	{
	  /* We could not find the version for a symbol when
	     generating a shared archive.  Return an error.  */
	  (*_bfd_error_handler)
	    (_("%s: undefined versioned symbol name %s"),
	     bfd_get_filename (sinfo->output_bfd), h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  sinfo->failed = TRUE;
	  return FALSE;
	}

      if (hidden)
	h->elf_link_hash_flags |= ELF_LINK_HIDDEN;
    }

  /* If we don't have a version for this symbol, see if we can find
     something.  */
  if (h->verinfo.vertree == NULL && sinfo->verdefs != NULL)
    {
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_tree *local_ver;
      struct bfd_elf_version_expr *d;

      /* See if can find what version this symbol is in.  If the
	 symbol is supposed to be local, then don't actually register
	 it.  */
      local_ver = NULL;
      for (t = sinfo->verdefs; t != NULL; t = t->next)
	{
	  if (t->globals != NULL)
	    {
	      bfd_boolean matched;

	      matched = FALSE;
	      for (d = t->globals; d != NULL; d = d->next)
		{
		  if ((*d->match) (d, h->root.root.string))
		    {
		      if (d->symver)
			matched = TRUE;
		      else
			{
			  /* There is a version without definition.  Make
			     the symbol the default definition for this
			     version.  */
			  h->verinfo.vertree = t;
			  local_ver = NULL;
			  d->script = 1;
			  break;
			}
		    }
		}

	      if (d != NULL)
		break;
	      else if (matched)
		/* There is no undefined version for this symbol. Hide the
		   default one.  */
		(*bed->elf_backend_hide_symbol) (info, h, TRUE);
	    }

	  if (t->locals != NULL)
	    {
	      for (d = t->locals; d != NULL; d = d->next)
		{
		  /* If the match is "*", keep looking for a more
		     explicit, perhaps even global, match.  */
		  if (d->pattern[0] == '*' && d->pattern[1] == '\0')
		    local_ver = t;
		  else if ((*d->match) (d, h->root.root.string))
		    {
		      local_ver = t;
		      break;
		    }
		}

	      if (d != NULL)
		break;
	    }
	}

      if (local_ver != NULL)
	{
	  h->verinfo.vertree = local_ver;
	  if (h->dynindx != -1
	      && info->shared
	      && ! info->export_dynamic)
	    {
	      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
	    }
	}
    }

  return TRUE;
}

/* Create a special linker section, or return a pointer to a linker
   section already created */

elf_linker_section_t *
_bfd_elf_create_linker_section (abfd, info, which, defaults)
     bfd *abfd;
     struct bfd_link_info *info;
     enum elf_linker_section_enum which;
     elf_linker_section_t *defaults;
{
  bfd *dynobj = elf_hash_table (info)->dynobj;
  elf_linker_section_t *lsect;

  /* Record the first bfd section that needs the special section */
  if (!dynobj)
    dynobj = elf_hash_table (info)->dynobj = abfd;

  /* If this is the first time, create the section */
  lsect = elf_linker_section (dynobj, which);
  if (!lsect)
    {
      asection *s;
      bfd_size_type amt = sizeof (elf_linker_section_t);

      lsect = (elf_linker_section_t *) bfd_alloc (dynobj, amt);

      *lsect = *defaults;
      elf_linker_section (dynobj, which) = lsect;
      lsect->which = which;
      lsect->hole_written_p = FALSE;

      /* See if the sections already exist */
      lsect->section = s = bfd_get_section_by_name (dynobj, lsect->name);
      if (!s || (s->flags & defaults->flags) != defaults->flags)
	{
	  lsect->section = s = bfd_make_section_anyway (dynobj, lsect->name);

	  if (s == NULL)
	    return (elf_linker_section_t *)0;

	  bfd_set_section_flags (dynobj, s, defaults->flags);
	  bfd_set_section_alignment (dynobj, s, lsect->alignment);
	}
      else if (bfd_get_section_alignment (dynobj, s) < lsect->alignment)
	bfd_set_section_alignment (dynobj, s, lsect->alignment);

      s->_raw_size = align_power (s->_raw_size, lsect->alignment);

      /* Is there a hole we have to provide?  If so check whether the
	 segment is too big already */
      if (lsect->hole_size)
	{
	  lsect->hole_offset = s->_raw_size;
	  s->_raw_size += lsect->hole_size;
	  if (lsect->hole_offset > lsect->max_hole_offset)
	    {
	      (*_bfd_error_handler)
		(_("%s: Section %s is too large to add hole of %ld bytes"),
		 bfd_get_filename (abfd),
		 lsect->name,
		 (long) lsect->hole_size);

	      bfd_set_error (bfd_error_bad_value);
	      return (elf_linker_section_t *)0;
	    }
	}

#ifdef DEBUG
      fprintf (stderr, "Creating section %s, current size = %ld\n",
	       lsect->name, (long)s->_raw_size);
#endif

      if (lsect->sym_name)
	{
	  struct elf_link_hash_entry *h;
	  struct bfd_link_hash_entry *bh;

#ifdef DEBUG
	  fprintf (stderr, "Adding %s to section %s\n",
		   lsect->sym_name,
		   lsect->name);
#endif
	  bh = bfd_link_hash_lookup (info->hash, lsect->sym_name,
				     FALSE, FALSE, FALSE);

	  if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	      && !(_bfd_generic_link_add_one_symbol
		   (info, abfd, lsect->sym_name, BSF_GLOBAL, s,
		    (lsect->hole_size
		     ? s->_raw_size - lsect->hole_size + lsect->sym_offset
		     : lsect->sym_offset),
		    (const char *) NULL, FALSE,
		    get_elf_backend_data (abfd)->collect, &bh)))
	    return (elf_linker_section_t *) 0;
	  h = (struct elf_link_hash_entry *) bh;

	  if ((defaults->which != LINKER_SECTION_SDATA)
	      && (defaults->which != LINKER_SECTION_SDATA2))
	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_DYNAMIC;

	  h->type = STT_OBJECT;
	  lsect->sym_hash = h;

	  if (info->shared
	      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
	    return (elf_linker_section_t *) 0;
	}
    }

#if 0
  /* This does not make sense.  The sections which may exist in the
     object file have nothing to do with the sections we want to
     create.  */

  /* Find the related sections if they have been created */
  if (lsect->bss_name && !lsect->bss_section)
    lsect->bss_section = bfd_get_section_by_name (dynobj, lsect->bss_name);

  if (lsect->rel_name && !lsect->rel_section)
    lsect->rel_section = bfd_get_section_by_name (dynobj, lsect->rel_name);
#endif

  return lsect;
}

/* Find a linker generated pointer with a given addend and type.  */
a648 579
    }

  return TRUE;
}

/* Read and swap the relocs from the section indicated by SHDR.  This
   may be either a REL or a RELA section.  The relocations are
   translated into RELA relocations and stored in INTERNAL_RELOCS,
   which should have already been allocated to contain enough space.
   The EXTERNAL_RELOCS are a buffer where the external form of the
   relocations should be stored.

   Returns FALSE if something goes wrong.  */

static bfd_boolean
elf_link_read_relocs_from_section (abfd, shdr, external_relocs,
				   internal_relocs)
     bfd *abfd;
     Elf_Internal_Shdr *shdr;
     PTR external_relocs;
     Elf_Internal_Rela *internal_relocs;
{
  struct elf_backend_data *bed;
  void (*swap_in) PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
  const bfd_byte *erela;
  const bfd_byte *erelaend;
  Elf_Internal_Rela *irela;

  /* If there aren't any relocations, that's OK.  */
  if (!shdr)
    return TRUE;

  /* Position ourselves at the start of the section.  */
  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0)
    return FALSE;

  /* Read the relocations.  */
  if (bfd_bread (external_relocs, shdr->sh_size, abfd) != shdr->sh_size)
    return FALSE;

  bed = get_elf_backend_data (abfd);

  /* Convert the external relocations to the internal format.  */
  if (shdr->sh_entsize == bed->s->sizeof_rel)
    swap_in = bed->s->swap_reloc_in;
  else if (shdr->sh_entsize == bed->s->sizeof_rela)
    swap_in = bed->s->swap_reloca_in;
  else
    {
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  erela = external_relocs;
  erelaend = erela + NUM_SHDR_ENTRIES (shdr) * shdr->sh_entsize;
  irela = internal_relocs;
  while (erela < erelaend)
    {
      (*swap_in) (abfd, erela, irela);
      irela += bed->s->int_rels_per_ext_rel;
      erela += shdr->sh_entsize;
    }

  return TRUE;
}

/* Read and swap the relocs for a section O.  They may have been
   cached.  If the EXTERNAL_RELOCS and INTERNAL_RELOCS arguments are
   not NULL, they are used as buffers to read into.  They are known to
   be large enough.  If the INTERNAL_RELOCS relocs argument is NULL,
   the return value is allocated using either malloc or bfd_alloc,
   according to the KEEP_MEMORY argument.  If O has two relocation
   sections (both REL and RELA relocations), then the REL_HDR
   relocations will appear first in INTERNAL_RELOCS, followed by the
   REL_HDR2 relocations.  */

Elf_Internal_Rela *
_bfd_elf_link_read_relocs (abfd, o, external_relocs, internal_relocs,
			   keep_memory)
     bfd *abfd;
     asection *o;
     PTR external_relocs;
     Elf_Internal_Rela *internal_relocs;
     bfd_boolean keep_memory;
{
  Elf_Internal_Shdr *rel_hdr;
  PTR alloc1 = NULL;
  Elf_Internal_Rela *alloc2 = NULL;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (elf_section_data (o)->relocs != NULL)
    return elf_section_data (o)->relocs;

  if (o->reloc_count == 0)
    return NULL;

  rel_hdr = &elf_section_data (o)->rel_hdr;

  if (internal_relocs == NULL)
    {
      bfd_size_type size;

      size = o->reloc_count;
      size *= bed->s->int_rels_per_ext_rel * sizeof (Elf_Internal_Rela);
      if (keep_memory)
	internal_relocs = (Elf_Internal_Rela *) bfd_alloc (abfd, size);
      else
	internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_malloc (size);
      if (internal_relocs == NULL)
	goto error_return;
    }

  if (external_relocs == NULL)
    {
      bfd_size_type size = rel_hdr->sh_size;

      if (elf_section_data (o)->rel_hdr2)
	size += elf_section_data (o)->rel_hdr2->sh_size;
      alloc1 = (PTR) bfd_malloc (size);
      if (alloc1 == NULL)
	goto error_return;
      external_relocs = alloc1;
    }

  if (!elf_link_read_relocs_from_section (abfd, rel_hdr,
					  external_relocs,
					  internal_relocs))
    goto error_return;
  if (!elf_link_read_relocs_from_section
      (abfd,
       elf_section_data (o)->rel_hdr2,
       ((bfd_byte *) external_relocs) + rel_hdr->sh_size,
       internal_relocs + (NUM_SHDR_ENTRIES (rel_hdr)
			  * bed->s->int_rels_per_ext_rel)))
    goto error_return;

  /* Cache the results for next time, if we can.  */
  if (keep_memory)
    elf_section_data (o)->relocs = internal_relocs;

  if (alloc1 != NULL)
    free (alloc1);

  /* Don't free alloc2, since if it was allocated we are passing it
     back (under the name of internal_relocs).  */

  return internal_relocs;

 error_return:
  if (alloc1 != NULL)
    free (alloc1);
  if (alloc2 != NULL)
    free (alloc2);
  return NULL;
}

/* Compute the size of, and allocate space for, REL_HDR which is the
   section header for a section containing relocations for O.  */

bfd_boolean
_bfd_elf_link_size_reloc_section (abfd, rel_hdr, o)
     bfd *abfd;
     Elf_Internal_Shdr *rel_hdr;
     asection *o;
{
  bfd_size_type reloc_count;
  bfd_size_type num_rel_hashes;

  /* Figure out how many relocations there will be.  */
  if (rel_hdr == &elf_section_data (o)->rel_hdr)
    reloc_count = elf_section_data (o)->rel_count;
  else
    reloc_count = elf_section_data (o)->rel_count2;

  num_rel_hashes = o->reloc_count;
  if (num_rel_hashes < reloc_count)
    num_rel_hashes = reloc_count;

  /* That allows us to calculate the size of the section.  */
  rel_hdr->sh_size = rel_hdr->sh_entsize * reloc_count;

  /* The contents field must last into write_object_contents, so we
     allocate it with bfd_alloc rather than malloc.  Also since we
     cannot be sure that the contents will actually be filled in,
     we zero the allocated space.  */
  rel_hdr->contents = (PTR) bfd_zalloc (abfd, rel_hdr->sh_size);
  if (rel_hdr->contents == NULL && rel_hdr->sh_size != 0)
    return FALSE;

  /* We only allocate one set of hash entries, so we only do it the
     first time we are called.  */
  if (elf_section_data (o)->rel_hashes == NULL
      && num_rel_hashes)
    {
      struct elf_link_hash_entry **p;

      p = ((struct elf_link_hash_entry **)
	   bfd_zmalloc (num_rel_hashes
			* sizeof (struct elf_link_hash_entry *)));
      if (p == NULL)
	return FALSE;

      elf_section_data (o)->rel_hashes = p;
    }

  return TRUE;
}

/* Copy the relocations indicated by the INTERNAL_RELOCS (which
   originated from the section given by INPUT_REL_HDR) to the
   OUTPUT_BFD.  */

bfd_boolean
_bfd_elf_link_output_relocs (output_bfd, input_section, input_rel_hdr,
			     internal_relocs)
     bfd *output_bfd;
     asection *input_section;
     Elf_Internal_Shdr *input_rel_hdr;
     Elf_Internal_Rela *internal_relocs;
{
  Elf_Internal_Rela *irela;
  Elf_Internal_Rela *irelaend;
  bfd_byte *erel;
  Elf_Internal_Shdr *output_rel_hdr;
  asection *output_section;
  unsigned int *rel_countp = NULL;
  struct elf_backend_data *bed;
  void (*swap_out) PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));

  output_section = input_section->output_section;
  output_rel_hdr = NULL;

  if (elf_section_data (output_section)->rel_hdr.sh_entsize
      == input_rel_hdr->sh_entsize)
    {
      output_rel_hdr = &elf_section_data (output_section)->rel_hdr;
      rel_countp = &elf_section_data (output_section)->rel_count;
    }
  else if (elf_section_data (output_section)->rel_hdr2
	   && (elf_section_data (output_section)->rel_hdr2->sh_entsize
	       == input_rel_hdr->sh_entsize))
    {
      output_rel_hdr = elf_section_data (output_section)->rel_hdr2;
      rel_countp = &elf_section_data (output_section)->rel_count2;
    }
  else
    {
      (*_bfd_error_handler)
	(_("%s: relocation size mismatch in %s section %s"),
	 bfd_get_filename (output_bfd),
	 bfd_archive_filename (input_section->owner),
	 input_section->name);
      bfd_set_error (bfd_error_wrong_object_format);
      return FALSE;
    }

  bed = get_elf_backend_data (output_bfd);
  if (input_rel_hdr->sh_entsize == bed->s->sizeof_rel)
    swap_out = bed->s->swap_reloc_out;
  else if (input_rel_hdr->sh_entsize == bed->s->sizeof_rela)
    swap_out = bed->s->swap_reloca_out;
  else
    abort ();

  erel = output_rel_hdr->contents;
  erel += *rel_countp * input_rel_hdr->sh_entsize;
  irela = internal_relocs;
  irelaend = irela + (NUM_SHDR_ENTRIES (input_rel_hdr)
		      * bed->s->int_rels_per_ext_rel);
  while (irela < irelaend)
    {
      (*swap_out) (output_bfd, irela, erel);
      irela += bed->s->int_rels_per_ext_rel;
      erel += input_rel_hdr->sh_entsize;
    }

  /* Bump the counter, so that we know where to add the next set of
     relocations.  */
  *rel_countp += NUM_SHDR_ENTRIES (input_rel_hdr);

  return TRUE;
}

/* Fix up the flags for a symbol.  This handles various cases which
   can only be fixed after all the input files are seen.  This is
   currently called by both adjust_dynamic_symbol and
   assign_sym_version, which is unnecessary but perhaps more robust in
   the face of future changes.  */

bfd_boolean
_bfd_elf_fix_symbol_flags (h, eif)
     struct elf_link_hash_entry *h;
     struct elf_info_failed *eif;
{
  /* If this symbol was mentioned in a non-ELF file, try to set
     DEF_REGULAR and REF_REGULAR correctly.  This is the only way to
     permit a non-ELF file to correctly refer to a symbol defined in
     an ELF dynamic object.  */
  if ((h->elf_link_hash_flags & ELF_LINK_NON_ELF) != 0)
    {
      while (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      if (h->root.type != bfd_link_hash_defined
	  && h->root.type != bfd_link_hash_defweak)
	h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
      else
	{
	  if (h->root.u.def.section->owner != NULL
	      && (bfd_get_flavour (h->root.u.def.section->owner)
		  == bfd_target_elf_flavour))
	    h->elf_link_hash_flags |= (ELF_LINK_HASH_REF_REGULAR
				       | ELF_LINK_HASH_REF_REGULAR_NONWEAK);
	  else
	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	}

      if (h->dynindx == -1
	  && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	      || (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0))
	{
	  if (! _bfd_elf_link_record_dynamic_symbol (eif->info, h))
	    {
	      eif->failed = TRUE;
	      return FALSE;
	    }
	}
    }
  else
    {
      /* Unfortunately, ELF_LINK_NON_ELF is only correct if the symbol
	 was first seen in a non-ELF file.  Fortunately, if the symbol
	 was first seen in an ELF file, we're probably OK unless the
	 symbol was defined in a non-ELF file.  Catch that case here.
	 FIXME: We're still in trouble if the symbol was first seen in
	 a dynamic object, and then later in a non-ELF regular object.  */
      if ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	  && (h->root.u.def.section->owner != NULL
	      ? (bfd_get_flavour (h->root.u.def.section->owner)
		 != bfd_target_elf_flavour)
	      : (bfd_is_abs_section (h->root.u.def.section)
		 && (h->elf_link_hash_flags
		     & ELF_LINK_HASH_DEF_DYNAMIC) == 0)))
	h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
    }

  /* If this is a final link, and the symbol was defined as a common
     symbol in a regular object file, and there was no definition in
     any dynamic object, then the linker will have allocated space for
     the symbol in a common section but the ELF_LINK_HASH_DEF_REGULAR
     flag will not have been set.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) != 0
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
      && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;

  /* If -Bsymbolic was used (which means to bind references to global
     symbols to the definition within the shared object), and this
     symbol was defined in a regular object, then it actually doesn't
     need a PLT entry.  Likewise, if the symbol has non-default
     visibility.  If the symbol has hidden or internal visibility, we
     will force it local.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0
      && eif->info->shared
      && is_elf_hash_table (eif->info)
      && (eif->info->symbolic
	  || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
    {
      struct elf_backend_data *bed;
      bfd_boolean force_local;

      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);

      force_local = (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
		     || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN);
      (*bed->elf_backend_hide_symbol) (eif->info, h, force_local);
    }

  /* If a weak undefined symbol has non-default visibility, we also
     hide it from the dynamic linker.  */
  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
      && h->root.type == bfd_link_hash_undefweak)
    {
      struct elf_backend_data *bed;
      bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
      (*bed->elf_backend_hide_symbol) (eif->info, h, TRUE);
    }

  /* If this is a weak defined symbol in a dynamic object, and we know
     the real definition in the dynamic object, copy interesting flags
     over to the real definition.  */
  if (h->weakdef != NULL)
    {
      struct elf_link_hash_entry *weakdef;

      weakdef = h->weakdef;
      if (h->root.type == bfd_link_hash_indirect)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      BFD_ASSERT (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak);
      BFD_ASSERT (weakdef->root.type == bfd_link_hash_defined
		  || weakdef->root.type == bfd_link_hash_defweak);
      BFD_ASSERT (weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC);

      /* If the real definition is defined by a regular object file,
	 don't do anything special.  See the longer description in
	 _bfd_elf_adjust_dynamic_symbol, below.  */
      if ((weakdef->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
	h->weakdef = NULL;
      else
	{
	  struct elf_backend_data *bed;

	  bed = get_elf_backend_data (elf_hash_table (eif->info)->dynobj);
	  (*bed->elf_backend_copy_indirect_symbol) (bed, weakdef, h);
	}
    }

  return TRUE;
}

/* Make the backend pick a good value for a dynamic symbol.  This is
   called via elf_link_hash_traverse, and also calls itself
   recursively.  */

bfd_boolean
_bfd_elf_adjust_dynamic_symbol (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct elf_info_failed *eif = (struct elf_info_failed *) data;
  bfd *dynobj;
  struct elf_backend_data *bed;

  if (! is_elf_hash_table (eif->info))
    return FALSE;

  if (h->root.type == bfd_link_hash_warning)
    {
      h->plt = elf_hash_table (eif->info)->init_offset;
      h->got = elf_hash_table (eif->info)->init_offset;

      /* When warning symbols are created, they **replace** the "real"
	 entry in the hash table, thus we never get to see the real
	 symbol in a hash traversal.  So look at it now.  */
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
    }

  /* Ignore indirect symbols.  These are added by the versioning code.  */
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  /* Fix the symbol flags.  */
  if (! _bfd_elf_fix_symbol_flags (h, eif))
    return FALSE;

  /* If this symbol does not require a PLT entry, and it is not
     defined by a dynamic object, or is not referenced by a regular
     object, ignore it.  We do have to handle a weak defined symbol,
     even if no regular object refers to it, if we decided to add it
     to the dynamic symbol table.  FIXME: Do we normally need to worry
     about symbols which are defined by one dynamic object and
     referenced by another one?  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0
      && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  || ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0
	      && (h->weakdef == NULL || h->weakdef->dynindx == -1))))
    {
      h->plt = elf_hash_table (eif->info)->init_offset;
      return TRUE;
    }

  /* If we've already adjusted this symbol, don't do it again.  This
     can happen via a recursive call.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    return TRUE;

  /* Don't look at this symbol again.  Note that we must set this
     after checking the above conditions, because we may look at a
     symbol once, decide not to do anything, and then get called
     recursively later after REF_REGULAR is set below.  */
  h->elf_link_hash_flags |= ELF_LINK_HASH_DYNAMIC_ADJUSTED;

  /* If this is a weak definition, and we know a real definition, and
     the real symbol is not itself defined by a regular object file,
     then get a good value for the real definition.  We handle the
     real symbol first, for the convenience of the backend routine.

     Note that there is a confusing case here.  If the real definition
     is defined by a regular object file, we don't get the real symbol
     from the dynamic object, but we do get the weak symbol.  If the
     processor backend uses a COPY reloc, then if some routine in the
     dynamic object changes the real symbol, we will not see that
     change in the corresponding weak symbol.  This is the way other
     ELF linkers work as well, and seems to be a result of the shared
     library model.

     I will clarify this issue.  Most SVR4 shared libraries define the
     variable _timezone and define timezone as a weak synonym.  The
     tzset call changes _timezone.  If you write
       extern int timezone;
       int _timezone = 5;
       int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }
     you might expect that, since timezone is a synonym for _timezone,
     the same number will print both times.  However, if the processor
     backend uses a COPY reloc, then actually timezone will be copied
     into your process image, and, since you define _timezone
     yourself, _timezone will not.  Thus timezone and _timezone will
     wind up at different memory locations.  The tzset call will set
     _timezone, leaving timezone unchanged.  */

  if (h->weakdef != NULL)
    {
      /* If we get to this point, we know there is an implicit
	 reference by a regular object file via the weak symbol H.
	 FIXME: Is this really true?  What if the traversal finds
	 H->WEAKDEF before it finds H?  */
      h->weakdef->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;

      if (! _bfd_elf_adjust_dynamic_symbol (h->weakdef, (PTR) eif))
	return FALSE;
    }

  /* If a symbol has no type and no size and does not require a PLT
     entry, then we are probably about to do the wrong thing here: we
     are probably going to create a COPY reloc for an empty object.
     This case can arise when a shared object is built with assembly
     code, and the assembly code fails to set the symbol type.  */
  if (h->size == 0
      && h->type == STT_NOTYPE
      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
    (*_bfd_error_handler)
      (_("warning: type and size of dynamic symbol `%s' are not defined"),
       h->root.root.string);

  dynobj = elf_hash_table (eif->info)->dynobj;
  bed = get_elf_backend_data (dynobj);
  if (! (*bed->elf_backend_adjust_dynamic_symbol) (eif->info, h))
    {
      eif->failed = TRUE;
      return FALSE;
    }

  return TRUE;
}

/* Adjust all external symbols pointing into SEC_MERGE sections
   to reflect the object merging within the sections.  */

bfd_boolean
_bfd_elf_link_sec_merge_syms (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  asection *sec;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && ((sec = h->root.u.def.section)->flags & SEC_MERGE)
      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
    {
      bfd *output_bfd = (bfd *) data;

      h->root.u.def.value =
	_bfd_merged_section_offset (output_bfd,
				    &h->root.u.def.section,
				    elf_section_data (sec)->sec_info,
				    h->root.u.def.value, (bfd_vma) 0);
@


1.27.10.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d97 1
a97 1
      if (! info->executable
d147 1
a147 1
  if (info->executable)
d230 1
a230 1
  if (! info->executable
d298 1
a298 1
      if (! info->executable
d1763 1
a1763 1
      if (t == NULL && info->executable)
@


1.27.10.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d28 3
d32 3
a34 1
_bfd_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)
d90 2
a91 1
	     bed->got_symbol_offset, NULL, FALSE, bed->collect, &bh)))
d118 3
a120 1
_bfd_elf_link_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d223 2
a224 2
	 (info, abfd, "_DYNAMIC", BSF_GLOBAL, s, 0, NULL, FALSE,
	  get_elf_backend_data (abfd)->collect, &bh)))
d255 3
a257 1
_bfd_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d290 3
a292 2
	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s, 0, NULL,
	      FALSE, get_elf_backend_data (abfd)->collect, &bh)))
d361 3
a363 2
_bfd_elf_link_record_dynamic_symbol (struct bfd_link_info *info,
				     struct elf_link_hash_entry *h)
d417 1
a417 1
	  alc = bfd_malloc (len);
d443 5
a447 4
bfd_elf_record_link_assignment (bfd *output_bfd ATTRIBUTE_UNUSED,
				struct bfd_link_info *info,
				const char *name,
				bfd_boolean provide)
d508 4
a511 3
elf_link_record_local_dynamic_symbol (struct bfd_link_info *info,
				      bfd *input_bfd,
				      long input_indx)
d531 1
a531 1
  entry = bfd_alloc (input_bfd, amt);
d537 2
a538 1
			     1, input_indx, &entry->isym, esym, &eshndx))
d598 4
a601 3
_bfd_elf_link_lookup_local_dynindx (struct bfd_link_info *info,
				    bfd *input_bfd,
				    long input_indx)
d615 3
d619 3
a621 2
elf_link_renumber_hash_table_dynsyms (struct elf_link_hash_entry *h,
				      void *data)
d623 1
a623 1
  size_t *count = data;
d640 3
a642 1
_bfd_elf_link_renumber_dynsyms (bfd *output_bfd, struct bfd_link_info *info)
d687 14
a700 12
_bfd_elf_merge_symbol (bfd *abfd,
		       struct bfd_link_info *info,
		       const char *name,
		       Elf_Internal_Sym *sym,
		       asection **psec,
		       bfd_vma *pvalue,
		       struct elf_link_hash_entry **sym_hash,
		       bfd_boolean *skip,
		       bfd_boolean *override,
		       bfd_boolean *type_change_ok,
		       bfd_boolean *size_change_ok,
		       bfd_boolean dt_needed)
d1257 12
a1268 10
_bfd_elf_add_default_symbol (bfd *abfd,
			     struct bfd_link_info *info,
			     struct elf_link_hash_entry *h,
			     const char *name,
			     Elf_Internal_Sym *sym,
			     asection **psec,
			     bfd_vma *value,
			     bfd_boolean *dynsym,
			     bfd_boolean override,
			     bfd_boolean dt_needed)
d1340 1
a1340 1
	      0, name, FALSE, collect, &bh)))
d1464 1
a1464 1
	      bfd_ind_section_ptr, 0, name, FALSE, collect, &bh)))
d1510 3
a1512 1
_bfd_elf_export_symbol (struct elf_link_hash_entry *h, void *data)
d1514 1
a1514 1
  struct elf_info_failed *eif = data;
d1571 3
a1573 2
_bfd_elf_link_find_version_dependencies (struct elf_link_hash_entry *h,
					 void *data)
d1575 1
a1575 1
  struct elf_find_verdep_info *rinfo = data;
d1609 1
a1609 1
      t = bfd_zalloc (rinfo->output_bfd, amt);
d1622 1
a1622 1
  a = bfd_zalloc (rinfo->output_bfd, amt);
d1649 3
a1651 1
_bfd_elf_link_assign_sym_version (struct elf_link_hash_entry *h, void *data)
d1660 1
a1660 1
  sinfo = data;
d1717 1
a1717 1
	      alc = bfd_malloc (len);
d1774 2
a1775 1
	  t = bfd_alloc (sinfo->output_bfd, amt);
d1899 173
d2082 6
a2087 4
elf_link_read_relocs_from_section (bfd *abfd,
				   Elf_Internal_Shdr *shdr,
				   void *external_relocs,
				   Elf_Internal_Rela *internal_relocs)
d2090 1
a2090 1
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d2144 7
a2150 5
_bfd_elf_link_read_relocs (bfd *abfd,
			   asection *o,
			   void *external_relocs,
			   Elf_Internal_Rela *internal_relocs,
			   bfd_boolean keep_memory)
d2153 1
a2153 1
  void *alloc1 = NULL;
d2172 1
a2172 1
	internal_relocs = bfd_alloc (abfd, size);
d2174 1
a2174 1
	internal_relocs = alloc2 = bfd_malloc (size);
d2185 1
a2185 1
      alloc1 = bfd_malloc (size);
d2227 4
a2230 3
_bfd_elf_link_size_reloc_section (bfd *abfd,
				  Elf_Internal_Shdr *rel_hdr,
				  asection *o)
d2252 1
a2252 1
  rel_hdr->contents = bfd_zalloc (abfd, rel_hdr->sh_size);
d2263 3
a2265 1
      p = bfd_zmalloc (num_rel_hashes * sizeof (struct elf_link_hash_entry *));
d2280 6
a2285 4
_bfd_elf_link_output_relocs (bfd *output_bfd,
			     asection *input_section,
			     Elf_Internal_Shdr *input_rel_hdr,
			     Elf_Internal_Rela *internal_relocs)
d2294 1
a2294 1
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d2357 3
a2359 2
_bfd_elf_fix_symbol_flags (struct elf_link_hash_entry *h,
			   struct elf_info_failed *eif)
d2500 3
a2502 1
_bfd_elf_adjust_dynamic_symbol (struct elf_link_hash_entry *h, void *data)
d2504 1
a2504 1
  struct elf_info_failed *eif = data;
d2594 1
a2594 1
      if (! _bfd_elf_adjust_dynamic_symbol (h->weakdef, eif))
d2625 3
a2627 1
_bfd_elf_link_sec_merge_syms (struct elf_link_hash_entry *h, void *data)
d2639 1
a2639 1
      bfd *output_bfd = data;
d2645 1
a2645 1
				    h->root.u.def.value, 0);
a2648 103
}

/* Returns false if the symbol referred to by H should be considered
   to resolve local to the current module, and true if it should be
   considered to bind dynamically.  */

bfd_boolean
_bfd_elf_dynamic_symbol_p (struct elf_link_hash_entry *h,
			   struct bfd_link_info *info,
			   bfd_boolean ignore_protected)
{
  bfd_boolean binding_stays_local_p;

  if (h == NULL)
    return FALSE;

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  /* If it was forced local, then clearly it's not dynamic.  */
  if (h->dynindx == -1)
    return FALSE;
  if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
    return FALSE;

  /* Identify the cases where name binding rules say that a
     visible symbol resolves locally.  */
  binding_stays_local_p = info->executable || info->symbolic;

  switch (ELF_ST_VISIBILITY (h->other))
    {
    case STV_INTERNAL:
    case STV_HIDDEN:
      return FALSE;

    case STV_PROTECTED:
      /* Proper resolution for function pointer equality may require
	 that these symbols perhaps be resolved dynamically, even though
	 we should be resolving them to the current module.  */
      if (!ignore_protected)
	binding_stays_local_p = TRUE;
      break;

    default:
      break;
    }

  /* If it isn't defined locally, then clearly it's dynamic.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return TRUE;

  /* Otherwise, the symbol is dynamic if binding rules don't tell
     us that it remains local.  */
  return !binding_stays_local_p;
}

/* Return true if the symbol referred to by H should be considered
   to resolve local to the current module, and false otherwise.  Differs
   from (the inverse of) _bfd_elf_dynamic_symbol_p in the treatment of
   undefined symbols and weak symbols.  */

bfd_boolean
_bfd_elf_symbol_refs_local_p (struct elf_link_hash_entry *h,
			      struct bfd_link_info *info,
			      bfd_boolean local_protected)
{
  /* If it's a local sym, of course we resolve locally.  */
  if (h == NULL)
    return TRUE;

  /* If we don't have a definition in a regular file, then we can't
     resolve locally.  The sym is either undefined or dynamic.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return FALSE;

  /* Forced local symbols resolve locally.  */
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    return TRUE;

  /* As do non-dynamic symbols.  */
  if (h->dynindx == -1)
    return TRUE;

  /* At this point, we know the symbol is defined and dynamic.  In an
     executable it must resolve locally, likewise when building symbolic
     shared libraries.  */
  if (info->executable || info->symbolic)
    return TRUE;

  /* Now deal with defined dynamic symbols in shared libraries.  Ones
     with default visibility might not resolve locally.  */
  if (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
    return FALSE;

  /* However, STV_HIDDEN or STV_INTERNAL ones must be local.  */
  if (ELF_ST_VISIBILITY (h->other) != STV_PROTECTED)
    return TRUE;

  /* Function pointer equality tests may require that STV_PROTECTED
     symbols be treated as dynamic symbols, even when we know that the
     dynamic linker will resolve them locally.  */
  return local_protected;
@


1.27.10.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d35 1
a35 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d118 1
a118 1
  const struct elf_backend_data *bed;
d251 1
a251 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d312 1
a312 1
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC | SEC_LINKER_CREATED))
d1167 1
a1167 1
      const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1250 1
a1250 1
  const struct elf_backend_data *bed;
d1624 1
a1624 1
  const struct elf_backend_data *bed;
d1882 1
a1882 1
  const struct elf_backend_data *bed;
d1946 1
a1946 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2079 1
a2079 1
  const struct elf_backend_data *bed;
d2226 1
a2226 1
      const struct elf_backend_data *bed;
d2241 1
a2241 1
      const struct elf_backend_data *bed;
d2270 1
a2270 1
	  const struct elf_backend_data *bed;
d2289 1
a2289 1
  const struct elf_backend_data *bed;
@


1.27.10.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d356 1
a356 1
      char *p;
d358 1
d396 8
a403 7
      if (p != NULL)
	/* We know that the p points into writable memory.  In fact,
	   there are only a few symbols that have read-only names, being
	   those like _GLOBAL_OFFSET_TABLE_ that are created specially
	   by the backends.  Most symbols will have names pointing into
	   an ELF string table read from a file, or to objalloc memory.  */
	*p = 0;
d405 10
a414 1
      indx = _bfd_elf_strtab_add (dynstr, name, p != NULL);
d416 2
a417 2
      if (p != NULL)
	*p = ELF_VER_CHR;
d965 1
a965 2
     required at the run time. The type change is also OK if the
     old symbol is undefined and the new symbol is defined.  */
d970 1
a970 4
      || newweakundef
      || (newdef
	  && (h->root.type == bfd_link_hash_undefined
	      || h->root.type == bfd_link_hash_undefweak)))
d1504 1
a1504 1
	  if (t->globals.list != NULL)
d1506 5
a1510 3
	      d = (*t->match) (&t->globals, NULL, h->root.root.string);
	      if (d != NULL)
		goto doit;
d1513 1
a1513 1
	  if (t->locals.list != NULL)
d1515 5
a1519 3
	      d = (*t->match) (&t->locals, NULL, h->root.root.string);
	      if (d != NULL)
		return TRUE;
d1698 6
a1703 2
	      if (t->globals.list != NULL)
		d = (*t->match) (&t->globals, NULL, alc);
d1707 1
a1707 1
	      if (d == NULL && t->locals.list != NULL)
d1709 14
a1722 6
		  d = (*t->match) (&t->locals, NULL, alc);
		  if (d != NULL
		      && h->dynindx != -1
		      && info->shared
		      && ! info->export_dynamic)
		    (*bed->elf_backend_hide_symbol) (info, h, TRUE);
d1743 1
a1743 1
	  t = bfd_zalloc (sinfo->output_bfd, amt);
d1750 1
d1752 3
d1800 1
a1800 1
	  if (t->globals.list != NULL)
d1805 19
a1823 15
	      d = NULL;
	      while ((d = (*t->match) (&t->globals, d,
				       h->root.root.string)) != NULL)
		if (d->symver)
		  matched = TRUE;
		else
		  {
		    /* There is a version without definition.  Make
		       the symbol the default definition for this
		       version.  */
		    h->verinfo.vertree = t;
		    local_ver = NULL;
		    d->script = 1;
		    break;
		  }
d1832 1
a1832 1
	  if (t->locals.list != NULL)
d1834 1
a1834 3
	      d = NULL;
	      while ((d = (*t->match) (&t->locals, d,
				       h->root.root.string)) != NULL)
a1835 1
		  local_ver = t;
d1837 8
a1844 4
		     explicit, perhaps even global, match.
		     XXX: Shouldn't this be !d->wildcard instead?  */
		  if (d->pattern[0] != '*' || d->pattern[1] != '\0')
		    break;
a1877 1
				   asection *sec,
a1886 2
  Elf_Internal_Shdr *symtab_hdr;
  size_t nsyms;
a1899 3
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  nsyms = symtab_hdr->sh_size / symtab_hdr->sh_entsize;

a1917 2
      bfd_vma r_symndx;

a1918 12
      r_symndx = ELF32_R_SYM (irela->r_info);
      if (bed->s->arch_size == 64)
	r_symndx >>= 24;
      if ((size_t) r_symndx >= nsyms)
	{
	  (*_bfd_error_handler)
	    (_("%s: bad reloc symbol index (0x%lx >= 0x%lx) for offset 0x%lx in section `%s'"),
	     bfd_archive_filename (abfd), (unsigned long) r_symndx,
	     (unsigned long) nsyms, irela->r_offset, sec->name);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
d1982 1
a1982 1
  if (!elf_link_read_relocs_from_section (abfd, o, rel_hdr,
d1987 1
a1987 1
      (abfd, o,
a2532 28
}

/* Caches some TLS segment info, and ensures that the TLS segment vma is
   aligned.  Returns the first TLS output section.  */

struct bfd_section *
_bfd_elf_tls_setup (bfd *obfd, struct bfd_link_info *info)
{
  struct bfd_section *sec, *tls;
  unsigned int align = 0;

  for (sec = obfd->sections; sec != NULL; sec = sec->next)
    if ((sec->flags & SEC_THREAD_LOCAL) != 0)
      break;
  tls = sec;

  for (; sec != NULL && (sec->flags & SEC_THREAD_LOCAL) != 0; sec = sec->next)
    if (sec->alignment_power > align)
      align = sec->alignment_power;

  elf_hash_table (info)->tls_sec = tls;

  /* Ensure the alignment of the first section is the largest alignment,
     so that the tls segment starts aligned.  */
  if (tls != NULL)
    tls->alignment_power = align;

  return tls;
@


1.27.10.9
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d120 1
a120 1
  if (! is_elf_hash_table (info->hash))
d147 2
a148 1
  if (! info->traditional_format)
d427 1
a427 1
  if (!is_elf_hash_table (info->hash))
d497 1
a497 1
  if (! is_elf_hash_table (info->hash))
d798 1
a798 1
  /* We need to remember if a symbol has a definition in a dynamic
d861 1
a861 1
  /* We need to treat weak definition right, depending on if there is a
d1130 1
a1130 1
      /* If the presumed common symbol in the dynamic object is
d1260 1
a1260 1
      /* We are overridden by an old definition. We need to check if we
d1419 1
a1419 1
	 overridden by a versioned definition.  */
d2209 1
a2209 1
      && is_elf_hash_table (eif->info->hash)
d2279 1
a2279 1
  if (! is_elf_hash_table (eif->info->hash))
@


1.26
log
@	* section.c (_bfd_strip_section_from_output):  Remove unnecessary
	link order code.  Don't actually remove the output section here;
	Just set a flag for the linker to do so.
	* elflink.c (_bfd_elf_link_renumber_dynsyms): Test for removed
	sections when setting up output section dynsyms.
@
text
@d305 92
@


1.26.2.1
log
@        Merge from mainline:
        2002-07-30  Nick Clifton  <nickc@@redhat.com>
        * po/sv.po: Updated Swedish translation.

        2002-07-30  Jakub Jelinek  <jakub@@redhat.com>
        * elf.c (elf_fake_sections): Fix up .tbss sh_size and sh_type.

        2002-07-26  Chris Demetriou  <cgd@@broadcom.com>
        * elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Merge ASE
        flags into resulting BFD.

        2002-07-25  Alan Modra  <amodra@@bigpond.net.au>
        * elf-bfd.h (_bfd_elf32_link_record_local_dynamic_symbol): Define
        as elf_link_record_local_dynamic_symbol.
        (_bfd_elf64_link_record_local_dynamic_symbol): Likewise.
        (elf_link_record_local_dynamic_symbol): Declare.  Now returns int.
        * elflink.h (elf_link_record_local_dynamic_symbol): Move to..
        * elflink.c: .. here.  Use bfd_elf_get_elf_syms.  Check whether an
        attempt is made to record a symbol in a discarded section, and
        return `2' in that case.
@
text
@a304 92
/* Record a new local dynamic symbol.  Returns 0 on failure, 1 on
   success, and 2 on a failure caused by attempting to record a symbol
   in a discarded section, eg. a discarded link-once section symbol.  */

int
elf_link_record_local_dynamic_symbol (info, input_bfd, input_indx)
     struct bfd_link_info *info;
     bfd *input_bfd;
     long input_indx;
{
  bfd_size_type amt;
  struct elf_link_local_dynamic_entry *entry;
  struct elf_link_hash_table *eht;
  struct elf_strtab_hash *dynstr;
  unsigned long dynstr_index;
  char *name;
  Elf_External_Sym_Shndx eshndx;
  char esym[sizeof (Elf64_External_Sym)];

  if (! is_elf_hash_table (info))
    return 0;

  /* See if the entry exists already.  */
  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)
    if (entry->input_bfd == input_bfd && entry->input_indx == input_indx)
      return 1;

  amt = sizeof (*entry);
  entry = (struct elf_link_local_dynamic_entry *) bfd_alloc (input_bfd, amt);
  if (entry == NULL)
    return 0;

  /* Go find the symbol, so that we can find it's name.  */
  if (!bfd_elf_get_elf_syms (input_bfd, &elf_tdata (input_bfd)->symtab_hdr,
			     (size_t) 1, (size_t) input_indx,
			     &entry->isym, esym, &eshndx))
    {
      bfd_release (input_bfd, entry);
      return 0;
    }

  if (entry->isym.st_shndx != SHN_UNDEF
      && (entry->isym.st_shndx < SHN_LORESERVE
	  || entry->isym.st_shndx > SHN_HIRESERVE))
    {
      asection *s;

      s = bfd_section_from_elf_index (input_bfd, entry->isym.st_shndx);
      if (s == NULL || bfd_is_abs_section (s->output_section))
	{
	  /* We can still bfd_release here as nothing has done another
	     bfd_alloc.  We can't do this later in this function.  */
	  bfd_release (input_bfd, entry);
	  return 2;
	}
    }

  name = (bfd_elf_string_from_elf_section
	  (input_bfd, elf_tdata (input_bfd)->symtab_hdr.sh_link,
	   entry->isym.st_name));

  dynstr = elf_hash_table (info)->dynstr;
  if (dynstr == NULL)
    {
      /* Create a strtab to hold the dynamic symbol names.  */
      elf_hash_table (info)->dynstr = dynstr = _bfd_elf_strtab_init ();
      if (dynstr == NULL)
	return 0;
    }

  dynstr_index = _bfd_elf_strtab_add (dynstr, name, false);
  if (dynstr_index == (unsigned long) -1)
    return 0;
  entry->isym.st_name = dynstr_index;

  eht = elf_hash_table (info);

  entry->next = eht->dynlocal;
  eht->dynlocal = entry;
  entry->input_bfd = input_bfd;
  entry->input_indx = input_indx;
  eht->dynsymcount++;

  /* Whatever binding the symbol had before, it's now local.  */
  entry->isym.st_info
    = ELF_ST_INFO (STB_LOCAL, ELF_ST_TYPE (entry->isym.st_info));

  /* The dynindx will be set at the end of size_dynamic_sections.  */

  return 1;
}

@


1.26.2.2
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a35 1
  struct bfd_link_hash_entry *bh;
d82 1
a82 1
      bh = NULL;
d86 1
a86 1
	     bed->collect, &bh)))
a87 1
      h = (struct elf_link_hash_entry *) bh;
d154 1
a154 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d158 2
a159 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a160 1
      h = (struct elf_link_hash_entry *) bh;
d549 1
a549 3
	  struct elf_link_hash_entry *h;
	  struct bfd_link_hash_entry *bh;

d555 2
a556 2
	  bh = bfd_link_hash_lookup (info->hash, lsect->sym_name,
				     false, false, false);
d558 14
a571 10
	  if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	      && !(_bfd_generic_link_add_one_symbol
		   (info, abfd, lsect->sym_name, BSF_GLOBAL, s,
		    (lsect->hole_size
		     ? s->_raw_size - lsect->hole_size + lsect->sym_offset
		     : lsect->sym_offset),
		    (const char *) NULL, false,
		    get_elf_backend_data (abfd)->collect, &bh)))
	    return (elf_linker_section_t *) 0;
	  h = (struct elf_link_hash_entry *) bh;
d582 1
a582 1
	    return (elf_linker_section_t *) 0;
@


1.25
log
@	* elf64-ppc.c (ppc_add_stub): Replace strcpy/strncpy with memcpy.
	* elf32-hppa.c (hppa_add_stub): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_add_default_symbol): Fix comment typo.
	(elf_add_default_symbol): Replace strcpy and strncpy with memcpy.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_assign_sym_version): Likewise.
	* hash.c (bfd_hash_lookup): Likewise.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
	* section.c (bfd_get_unique_section_name): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* elf.c (_bfd_elf_make_section_from_phdr): Likewise.
	(assign_section_numbers): Likewise.
	(_bfd_elfcore_make_pseudosection): Likewise.
	(elfcore_grok_lwpstatus): Likewise.
	(elfcore_grok_win32pstatus): Likewise.
	(elfcore_write_note): Constify input params.  Use PTR instead of
	void *.  Include terminating NUL in namesz.  Correct padding.
	Support NULL "name" param.  Use memcpy instead of strcpy.
	(elfcore_write_prpsinfo): Constify input params.
	(elfcore_write_prstatus): Likewise.  Use PTR instead of void *.
	(elfcore_write_lwpstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	* elf-bfd.h (elfcore_write_note): Update declaration.
	(elfcore_write_prpsinfo): Likewise.
	(elfcore_write_prstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	(elfcore_write_lwpstatus): Likewise.
@
text
@d360 2
a361 1
	elf_section_data (p)->dynindx = ++dynsymcount;
@


1.24
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d281 3
a283 1
	  alc = bfd_malloc ((bfd_size_type) (p - name + 1));
d286 2
a287 2
	  strncpy (alc, name, (size_t) (p - name));
	  alc[p - name] = '\0';
@


1.24.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d281 1
a281 3
	  size_t len = p - name + 1;

	  alc = bfd_malloc ((bfd_size_type) len);
d284 2
a285 2
	  memcpy (alc, name, len - 1);
	  alc[len - 1] = '\0';
d358 1
a358 2
	if ((p->flags & SEC_EXCLUDE) == 0)
	  elf_section_data (p)->dynindx = ++dynsymcount;
@


1.24.6.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a304 92
/* Record a new local dynamic symbol.  Returns 0 on failure, 1 on
   success, and 2 on a failure caused by attempting to record a symbol
   in a discarded section, eg. a discarded link-once section symbol.  */

int
elf_link_record_local_dynamic_symbol (info, input_bfd, input_indx)
     struct bfd_link_info *info;
     bfd *input_bfd;
     long input_indx;
{
  bfd_size_type amt;
  struct elf_link_local_dynamic_entry *entry;
  struct elf_link_hash_table *eht;
  struct elf_strtab_hash *dynstr;
  unsigned long dynstr_index;
  char *name;
  Elf_External_Sym_Shndx eshndx;
  char esym[sizeof (Elf64_External_Sym)];

  if (! is_elf_hash_table (info))
    return 0;

  /* See if the entry exists already.  */
  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)
    if (entry->input_bfd == input_bfd && entry->input_indx == input_indx)
      return 1;

  amt = sizeof (*entry);
  entry = (struct elf_link_local_dynamic_entry *) bfd_alloc (input_bfd, amt);
  if (entry == NULL)
    return 0;

  /* Go find the symbol, so that we can find it's name.  */
  if (!bfd_elf_get_elf_syms (input_bfd, &elf_tdata (input_bfd)->symtab_hdr,
			     (size_t) 1, (size_t) input_indx,
			     &entry->isym, esym, &eshndx))
    {
      bfd_release (input_bfd, entry);
      return 0;
    }

  if (entry->isym.st_shndx != SHN_UNDEF
      && (entry->isym.st_shndx < SHN_LORESERVE
	  || entry->isym.st_shndx > SHN_HIRESERVE))
    {
      asection *s;

      s = bfd_section_from_elf_index (input_bfd, entry->isym.st_shndx);
      if (s == NULL || bfd_is_abs_section (s->output_section))
	{
	  /* We can still bfd_release here as nothing has done another
	     bfd_alloc.  We can't do this later in this function.  */
	  bfd_release (input_bfd, entry);
	  return 2;
	}
    }

  name = (bfd_elf_string_from_elf_section
	  (input_bfd, elf_tdata (input_bfd)->symtab_hdr.sh_link,
	   entry->isym.st_name));

  dynstr = elf_hash_table (info)->dynstr;
  if (dynstr == NULL)
    {
      /* Create a strtab to hold the dynamic symbol names.  */
      elf_hash_table (info)->dynstr = dynstr = _bfd_elf_strtab_init ();
      if (dynstr == NULL)
	return 0;
    }

  dynstr_index = _bfd_elf_strtab_add (dynstr, name, false);
  if (dynstr_index == (unsigned long) -1)
    return 0;
  entry->isym.st_name = dynstr_index;

  eht = elf_hash_table (info);

  entry->next = eht->dynlocal;
  eht->dynlocal = entry;
  entry->input_bfd = input_bfd;
  entry->input_indx = input_indx;
  eht->dynsymcount++;

  /* Whatever binding the symbol had before, it's now local.  */
  entry->isym.st_info
    = ELF_ST_INFO (STB_LOCAL, ELF_ST_TYPE (entry->isym.st_info));

  /* The dynindx will be set at the end of size_dynamic_sections.  */

  return 1;
}

@


1.24.6.3
log
@merge from mainline
@
text
@a35 1
  struct bfd_link_hash_entry *bh;
d82 1
a82 1
      bh = NULL;
d86 1
a86 1
	     bed->collect, &bh)))
a87 1
      h = (struct elf_link_hash_entry *) bh;
d154 1
a154 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d158 2
a159 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a160 1
      h = (struct elf_link_hash_entry *) bh;
d549 1
a549 3
	  struct elf_link_hash_entry *h;
	  struct bfd_link_hash_entry *bh;

d555 2
a556 2
	  bh = bfd_link_hash_lookup (info->hash, lsect->sym_name,
				     false, false, false);
d558 14
a571 10
	  if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	      && !(_bfd_generic_link_add_one_symbol
		   (info, abfd, lsect->sym_name, BSF_GLOBAL, s,
		    (lsect->hole_size
		     ? s->_raw_size - lsect->hole_size + lsect->sym_offset
		     : lsect->sym_offset),
		    (const char *) NULL, false,
		    get_elf_backend_data (abfd)->collect, &bh)))
	    return (elf_linker_section_t *) 0;
	  h = (struct elf_link_hash_entry *) bh;
d582 1
a582 1
	    return (elf_linker_section_t *) 0;
@


1.23
log
@	* elflink.c (_bfd_elf_create_dynamic_sections): Don't set SEC_CODE
	when plt_not_loaded.
	* elf64-ppc.c (ppc64_elf_create_dynamic_sections): No need to
	clear .plt SEC_CODE here.  Create .stub and correct .glink flags.
	(PLT_INITIAL_ENTRY_SIZE): Set to 24.
	(ppc64_elf_glink_code): Delete.
	(PPC64_ELF_GLINK_SIZE): Delete.
	(ADDIS_R12_R2, STD_R2_40R1, LD_R11_0R12, LD_R2_0R12, MTCTR_R11,
	BCTR, ADDIS_R12_R12_1, LD_R2_40R1, NOP, LI_R0_0, B_DOT, LIS_R0_0,
	ORI_R0_R0_0): Define.
	(PLT_CALL_STUB_SIZE, GLINK_CALL_STUB_SIZE): Define.
	(struct ppc_link_hash_table): Add sstub and plt_overflow.
	(ppc64_elf_link_hash_table_create): Init them.
	(ppc64_elf_check_relocs <R_PPC64_REL24>): Refcount .plt entry.
	Don't copy to shared lib.
	(ppc64_elf_check_relocs): Call bfd_set_error on errors.
	(ppc64_elf_gc_sweep_hook <R_PPC64_REL24>): Sweep plt refcount.
	(allocate_dynrelocs <plt>): Don't change function sym here.  Make
	room for .stub and .glink code.
	(ppc64_elf_size_dynamic_sections): Handle .stub.  Make entry for
	DT_PPC64_GLINK.
	(ppc64_elf_final_link): Rename to ppc64_elf_set_toc.  Don't call
	bfd_elf64_bfd_final_link.
	(bfd_elf64_bfd_final_link): Don't define.
	(ppc64_elf_size_stubs): New.
	(build_plt_stub): New.
	(build_one_stub): New.
	(ppc64_elf_build_stubs): New.
	(ppc64_elf_relocate_section <toc relocs>): Remove assert.
	(ppc64_elf_relocate_section): Don't copy R_PPC64_REL24 relocs.
	(ppc64_elf_finish_dynamic_symbol): Don't build stubs here.  Set
	DT_PPC64_GLINK entry.  Tweak DT_PLTGOT, DT_JMPREL, DT_PLTRELSZ in
	case output sections not separate.  Adjust DT_RELASZ to not
	include plt relocs.  Set reserved got entry.  Set got and plt
	entry size.
	(elf_backend_got_header_size): Set to 8.
	* elf64-ppc.h: New file.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
d332 3
@


1.23.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
a331 3

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
@


1.22
log
@	* Makefile.am (BFD32_BACKENDS): Add elf-strtab.lo.
	(BFD32_BACKENDS_CFILES): Add elf-strtab.c.
	(elf-strtab.lo): Add rule.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-strtab.lo.
	* configure: Rebuilt.
	* elf-bfd.h (elf_strtab_hash): Forward declare.
	(struct elf_link_hash_table): Change dynstr type to
	struct elf_strtab_hash *.
	(struct elf_obj_tdata): Change strtab_ptr type to
	struct elf_strtab_hash *.
	(_bfd_elf_strtab_init, _bfd_elf_strtab_free, _bfd_elf_strtab_add,
	_bfd_elf_strtab_addref, _bfd_elf_strtab_delref,
	_bfd_elf_strtab_clear_all_refs, _bfd_elf_strtab_size,
	_bfd_elf_strtab_offset, _bfd_elf_strtab_emit,
	_bfd_elf_strtab_finalize): New prototypes.
	* elf-strtab.c: New file.
	* elflink.h (elf_link_add_object_symbols): Use _bfd_elf_strtab_add
	and _bfd_elf_strtab_size instead of _bfd_stringtab calls.
	Call _bfd_elf_strtab_delref if DT_NEEDED entry is not needed or
	when forcing dynamic symbol to local.
	(elf_link_create_dynamic_sections): Call
	_bfd_elf_strtab_init instead of elf_stringtab_init.
	(elf_link_record_local_dynamic_symbol): Likewise, change
	dynstr type.  Use _bfd_elf_strtab functions instead of
	_bfd_stringtab calls.
	(size_dynamic_sections): Use _bfd_elf_strtab functions instead of
	_bfd_stringtab calls.  For DT_RUNPATH and Verdaux vda_name fields,
	call _bfd_elf_strtab_addref.  Call elf_finalize_dynstr.
	(elf_adjust_dynstr_offsets, elf_finalize_dynstr): New functions.
	(elf_fix_symbol_flags): Call _bfd_elf_strtab_delref when forcing
	dynamic symbol to local.
	(elf_link_assign_sym_version): Likewise.
	(elf_bfd_final_link): Call _bfd_elf_strtab_emit instead of
	_bfd_stringtab_emit.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Change dynstr
	type.  Call _bfd_elf_strtab functions instead of
	_bfd_stringtab functions.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.
	* elf.c (_bfd_elf_init_reloc_shdr): Likewise.
	(elf_fake_sections): Likewise.
	(assign_section_numbers): Call _bfd_elf_strtab_clear_all_refs
	on shstrtab hash table, call _bfd_elf_strtab_addref on each section
	name in the output.  Call _bfd_elf_strtab_finalize and
	use _bfd_elf_strtab_offset to finalize sh_name section header fields.
	(_bfd_elf_compute_section_file_positions): Use _bfd_elf_strtab_size
	instead of _bfd_stringtab_size.
	(prep_headers): Change shstrtab type.
	Use _bfd_elf_strtab calls instead of _bfd_stringtab calls.
@
text
@d140 1
a140 1
    pltflags &= ~ (SEC_LOAD | SEC_HAS_CONTENTS);
@


1.21
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d233 1
a233 1
      struct bfd_strtab_hash *dynstr;
d265 1
a265 1
	  elf_hash_table (info)->dynstr = dynstr = _bfd_elf_stringtab_init ();
d290 1
a290 1
      indx = _bfd_stringtab_add (dynstr, name, true, copy);
@


1.20
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d434 1
a434 1
	      (*_bfd_error_handler) (_("%s: Section %s is already to large to put hole of %ld bytes in"),
d437 1
a437 1
				     (long)lsect->hole_size);
@


1.19
log
@	* elf-bfd.h (struct elf_backend_data): Add want_got_sym.
	* elfxx-target.h (elf_backend_want_got_sym): Define.
	(elfNN_bed): Add elf_backend_want_got_sym.
	* elflink.c (_bfd_elf_create_got_section): Define
	_GLOBAL_OFFSET_TABLE_ only if bed->want_got_sym.
@
text
@d281 1
a281 1
	  alc = bfd_malloc (p - name + 1);
d284 1
a284 1
	  strncpy (alc, name, p - name);
d400 1
d402 1
a402 2
      lsect = (elf_linker_section_t *)
	bfd_alloc (dynobj, sizeof (elf_linker_section_t));
d509 1
a509 1
     bfd_signed_vma addend;
@


1.18
log
@	* ecoff.c (bfd_debug_section): Fix initialization.
	* elf.c (_bfd_elf_slurp_version_tables): Change maxidx to unsigned, it
	is always a positive integer. Cast away sign mismatch.
	* elf32-mips.c: Fix misleading comment and typo.
	(_bfd_mips_elf_section_from_bfd_section): Remove unused attribute, use
	correct data type.
	* elflink.c: Fix typo.
	(_bfd_elf_create_dynamic_sections): Remove superfluous initialization.
	* ecoffswap.h (ecoff_swap_fdr_in): Cast away sign mismatch.
@
text
@d76 14
a89 12
  /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
     (or .got.plt) section.  We don't do this in the linker script
     because we don't want to define the symbol if we are not creating
     a global offset table.  */
  h = NULL;
  if (!(_bfd_generic_link_add_one_symbol
	(info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
	 bed->got_symbol_offset, (const char *) NULL, false,
	 bed->collect, (struct bfd_link_hash_entry **) &h)))
    return false;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;
d91 3
a93 3
  if (info->shared
      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
    return false;
d95 2
a96 1
  elf_hash_table (info)->hgot = h;
@


1.17
log
@Update copyright notices
@
text
@d111 1
a111 1
  int ptralign = 0;
d336 1
a336 1
/* Assign dynsym indicies.  In a shared library we generate a section
@


1.16
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1995, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
@


1.16.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.16.2.2
log
@Merge from mainline.
@
text
@d111 1
a111 1
  int ptralign;
d336 1
a336 1
/* Assign dynsym indices.  In a shared library we generate a section
@


1.15
log
@2001-01-03  Kazu Hirata  <kazu@@hxi.com>

	* ecoffswap.h: Fix formatting.
	* elf-bfd.h: Likewise.
	* elfarm-nabi.c: Likewise.
	* elfarm-oabi.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-target.h: Likewise.
@
text
@a99 1

a213 1

a498 1

a515 1

@


1.14
log
@* elflink.c (_bfd_elf_create_got_section): Don't abort().
Formatting fixes.
(_bfd_elf_create_dynamic_sections): Likewise.
@
text
@d166 1
a166 1
  s = bfd_make_section (abfd, 
d202 3
a204 3
	  s = bfd_make_section (abfd, 
				(bed->default_use_rela_p 
				 ? ".rela.bss" : ".rel.bss")); 
@


1.13
log
@2000-06-05  H.J. Lu  <hjl@@gnu.org>

	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Don't flag
	an error when seeing an undefined symbol with hidden/internal
	attribute. It is handled in *_relocate_section ().
@
text
@d44 11
a54 3
    case 32: ptralign = 2; break;
    case 64: ptralign = 3; break;
    default: abort();
d115 11
a125 3
    case 32: ptralign = 2; break;
    case 64: ptralign = 3; break;
    default: abort();
@


1.12
log
@2000-05-30  H.J. Lu  <hjl@@gnu.org>

	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Clear the
	visibility bits if the symbol is undefined. Correctly handle
	weak undefined symbols with hidden and internal attributes.

	* elflink.h (elf_link_add_object_symbols): Always turn the
	symbol into local if it has the hidden or internal attribute.
@
text
@d229 2
a230 15
	  /* This symbol must be defined in the shared object or
	     executable.  */
	  if (h->root.type == bfd_link_hash_undefined)
	    {
	      bfd * abfd = h->root.u.undef.abfd;
	      const char * name = h->root.root.string;
	      
	      (*info->callbacks->undefined_symbol)
		(info, name, abfd, bfd_und_section_ptr, 0, true);

	      /* We have flaged a fatal error. We now treat this as
	         a normal symbol to avoid further error messages. */
	      h->other ^= ELF_ST_VISIBILITY (h->other);
	    }
	  else if (h->root.type != bfd_link_hash_undefweak)
@


1.11
log
@2000-05-03  Martin v. Lwis  <loewis@@informatik.hu-berlin.de>

	* elflink.h (elf_link_add_object_symbols): Reset dynindx for
	hidden and internal symbols.
	(elf_fix_symbol_flags): Clear NEEDS_PLT for symbols with
	visibility.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Do not
	assign a PLT or GOT entry to symbols with hidden and
	internal visibility.
@
text
@d238 9
a247 3
	  
	  h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
	  return true;
@


1.10
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d241 2
a242 2
	  break;
	  
@


1.10.2.1
log
@Merge from mainline
@
text
@a237 4

	      /* We have flaged a fatal error. We now treat this as
	         a normal symbol to avoid further error messages. */
	      h->other ^= ELF_ST_VISIBILITY (h->other);
d239 4
a242 6
	  else if (h->root.type != bfd_link_hash_undefweak)
	    {
	      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
	      return true;
	    }

@


1.10.2.2
log
@Merge from mainline
@
text
@d229 15
a243 2
	  if (h->root.type != bfd_link_hash_undefined
	      && h->root.type != bfd_link_hash_undefweak)
@


1.9
log
@Most of these changes are really only cosmetic.  The readelf.c patch
fixes a thinko in get_dynamic_flags.  I found at least one message
string that included a `%' being passed to printf in the format
argument.
@
text
@d237 1
a237 1
		(info, name, abfd, bfd_und_section_ptr, 0);
@


1.8
log
@ELF visibility patch from Martin Loewis.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d234 1
a234 1
	      char * name = h->root.root.string;
@


1.7
log
@        * elf-bfd.h (struct elf_backend_data): Add want_dynbss.
        * elflink.c (_bfd_elf_create_dynamic_sections): Only create
        .dynbss and .rel[a].bss if want_dynbss.
        * elfxx-target.h (elf_backend_want_dynbss): Provide default.
@
text
@d221 26
@


1.6
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): New.
	(struct elf_link_hash_table): Add dynlocal.
	(_bfd_elf_link_lookup_local_dynindx): Prototype.
	(_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_renumber_dynsyms): Prototype.
	(_bfd_elf,link_record_local_dynamic_symbol): Prototype.
	* elfcode.h (elf_link_record_local_dynamic_symbol): New alias.
	* elflink.c (_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_lookup_local_dynindx): New function.
	(elf_link_renumber_hash_table_dynsyms): New function.
	(_bfd_elf_link_renumber_dynsyms): New function.
	* elflink.h (elf_link_record_local_dynamic_symbol): New function.
	(struct elf_assign_sym_version_info): Delete removed_dynamic.
	(bfd_elf,size_dynamic_sections): Use _bfd_strip_section_from_output
	instead of elf_link_remove_section_and_adjust_dynindices.
	Remove removed_dynamic code.  Use _bfd_elf_link_renumber_dynsyms.
	(elf_link_assign_sym_version): Remove removed_dynamic code.
	(elf_link_renumber_dynsyms): Delete.
	(elf_bfd_final_link): Install section and local symbols into .dynsym.
	* elf32-m68k.c (elf_m68k_adjust_dynindx): Delete.
	(elf_m68k_size_dynamic_sections): Don't set section dynindicies.
	(elf_m68k_finish_dynamic_sections): Don't write section dynsyms.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-sparc.c: Similarly.
@
text
@d160 12
a171 10
  /* The .dynbss section is a place to put symbols which are defined
     by dynamic objects, are referenced by regular objects, and are
     not functions.  We must allocate space for them in the process
     image and use a R_*_COPY reloc to tell the dynamic linker to
     initialize them at run time.  The linker script puts the .dynbss
     section into the .bss section of the final image.  */
  s = bfd_make_section (abfd, ".dynbss");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
    return false;
d173 1
a173 1
  /* The .rel[a].bss section holds copy relocs.  This section is not
d184 10
a193 9
  if (! info->shared)
    {
      s = bfd_make_section (abfd, 
			    (bed->default_use_rela_p 
			     ? ".rela.bss" : ".rel.bss")); 
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, ptralign))
	return false;
@


1.5
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf1.c (parse_line_table): Change eachLine to unsigned long.
	(dwarf1_unit_find_nearest_line): Change i to unsigned long.
@
text
@d263 1
a263 3
/* Increase the index at which H will appear in the dynamic symbol
   table by INCREMENT (which is really an `int *').  Called via
   elf_link_hash_traverse.  */
d265 23
a287 2
boolean
_bfd_elf_link_adjust_dynindx (h, increment)
d289 1
a289 1
     PTR increment;
d291 2
d294 2
a295 2
    h->dynindx += *((int *) increment);
    
d298 39
d338 2
a339 1
/* Create a special linker section, or return a pointer to a linker section already created  */
@


1.4
log
@	* elf-bfd.h (_bfd_elf_link_adjust_dynindx): New function.
	* elflink.c (_bfd_elf_link_adjust_dynindx): Define it.
	* elflink.h (elf_link_remove_section_and_adjust_dynindices): New
	function.
	(bfd_elf_size_dynamic_sections): Use it.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1999 Free Software Foundation, Inc.
d103 1
a103 1
  int ptralign;
@


1.3
log
@Update copyright dates.
@
text
@d262 15
@


1.2
log
@	* elf-bfd.h (elf_backend_data): Remove use_rela_p.  Add
	may_use_rel_p, may_use_rela_p, default_use_rela_p.
	(bfd_elf_section_data): Add use_rela_p.
	* elf.c (bfd_section_from_shdr): Set use_rela_p appropriately.
	(_bfd_elf_new_section_hook): Likewise.
	(elf_fake_sections): Use may_use_rela_p, etc., instead of
	use_rela_p.
	(_bfd_elf_copy_private_section_data): Copy use_rela_p.
	* elfcode.h (write_relocs): Determine whether or not use rela
	relocs based on the relocation section header.
	* elflink.c (_bfd_elf_create_dynamic_sections): Use default_use_rela_p
	instead of use_rela_p.
	* elfxx-target.h (elf_backend_may_use_relp): New macro.
	(elf_backend_may_use_rela_p): Likewise.
	(elf_backend_default_use_rela_p): Likewise.
	(elfNN_bed): Use them.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d150 2
a151 1
  s = bfd_make_section (abfd, bed->use_rela_p ? ".rela.plt" : ".rel.plt");
d184 3
a186 1
      s = bfd_make_section (abfd, bed->use_rela_p ? ".rela.bss" : ".rel.bss");
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

