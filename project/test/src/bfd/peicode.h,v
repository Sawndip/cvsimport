head	1.67;
access;
symbols
	sid-snapshot-20180601:1.67
	sid-snapshot-20180501:1.67
	sid-snapshot-20180401:1.67
	sid-snapshot-20180301:1.67
	sid-snapshot-20180201:1.67
	sid-snapshot-20180101:1.67
	sid-snapshot-20171201:1.67
	sid-snapshot-20171101:1.67
	sid-snapshot-20171001:1.67
	sid-snapshot-20170901:1.67
	sid-snapshot-20170801:1.67
	sid-snapshot-20170701:1.67
	sid-snapshot-20170601:1.67
	sid-snapshot-20170501:1.67
	sid-snapshot-20170401:1.67
	sid-snapshot-20170301:1.67
	sid-snapshot-20170201:1.67
	sid-snapshot-20170101:1.67
	sid-snapshot-20161201:1.67
	sid-snapshot-20161101:1.67
	sid-snapshot-20160901:1.67
	sid-snapshot-20160801:1.67
	sid-snapshot-20160701:1.67
	sid-snapshot-20160601:1.67
	sid-snapshot-20160501:1.67
	sid-snapshot-20160401:1.67
	sid-snapshot-20160301:1.67
	sid-snapshot-20160201:1.67
	sid-snapshot-20160101:1.67
	sid-snapshot-20151201:1.67
	sid-snapshot-20151101:1.67
	sid-snapshot-20151001:1.67
	sid-snapshot-20150901:1.67
	sid-snapshot-20150801:1.67
	sid-snapshot-20150701:1.67
	sid-snapshot-20150601:1.67
	sid-snapshot-20150501:1.67
	sid-snapshot-20150401:1.67
	sid-snapshot-20150301:1.67
	sid-snapshot-20150201:1.67
	sid-snapshot-20150101:1.67
	sid-snapshot-20141201:1.67
	sid-snapshot-20141101:1.67
	sid-snapshot-20141001:1.67
	sid-snapshot-20140901:1.67
	sid-snapshot-20140801:1.67
	sid-snapshot-20140701:1.67
	sid-snapshot-20140601:1.67
	sid-snapshot-20140501:1.67
	sid-snapshot-20140401:1.67
	sid-snapshot-20140301:1.67
	sid-snapshot-20140201:1.67
	sid-snapshot-20140101:1.67
	sid-snapshot-20131201:1.67
	sid-snapshot-20131101:1.67
	sid-snapshot-20131001:1.67
	binutils-2_24-branch:1.67.0.2
	binutils-2_24-branchpoint:1.67
	binutils-2_21_1:1.62
	sid-snapshot-20130901:1.67
	gdb_7_6_1-2013-08-30-release:1.65
	sid-snapshot-20130801:1.67
	sid-snapshot-20130701:1.67
	sid-snapshot-20130601:1.67
	sid-snapshot-20130501:1.67
	gdb_7_6-2013-04-26-release:1.65
	sid-snapshot-20130401:1.66
	binutils-2_23_2:1.64
	gdb_7_6-branch:1.65.0.2
	gdb_7_6-2013-03-12-branchpoint:1.65
	sid-snapshot-20130301:1.65
	sid-snapshot-20130201:1.65
	sid-snapshot-20130101:1.64
	sid-snapshot-20121201:1.64
	gdb_7_5_1-2012-11-29-release:1.64
	binutils-2_23_1:1.64
	sid-snapshot-20121101:1.64
	binutils-2_23:1.64
	sid-snapshot-20121001:1.64
	sid-snapshot-20120901:1.64
	gdb_7_5-2012-08-17-release:1.64
	sid-snapshot-20120801:1.64
	binutils-2_23-branch:1.64.0.4
	binutils-2_23-branchpoint:1.64
	gdb_7_5-branch:1.64.0.2
	gdb_7_5-2012-07-18-branchpoint:1.64
	sid-snapshot-20120701:1.64
	sid-snapshot-20120601:1.64
	sid-snapshot-20120501:1.63
	binutils-2_22_branch:1.63.0.6
	gdb_7_4_1-2012-04-26-release:1.63
	sid-snapshot-20120401:1.63
	sid-snapshot-20120301:1.63
	sid-snapshot-20120201:1.63
	gdb_7_4-2012-01-24-release:1.63
	sid-snapshot-20120101:1.63
	gdb_7_4-branch:1.63.0.4
	gdb_7_4-2011-12-13-branchpoint:1.63
	sid-snapshot-20111201:1.63
	binutils-2_22:1.63
	sid-snapshot-20111101:1.63
	sid-snapshot-20111001:1.63
	binutils-2_22-branch:1.63.0.2
	binutils-2_22-branchpoint:1.63
	gdb_7_3_1-2011-09-04-release:1.62
	sid-snapshot-20110901:1.62
	sid-snapshot-20110801:1.62
	gdb_7_3-2011-07-26-release:1.62
	sid-snapshot-20110701:1.62
	sid-snapshot-20110601:1.62
	sid-snapshot-20110501:1.62
	gdb_7_3-branch:1.62.0.6
	gdb_7_3-2011-04-01-branchpoint:1.62
	sid-snapshot-20110401:1.62
	sid-snapshot-20110301:1.62
	sid-snapshot-20110201:1.62
	sid-snapshot-20110101:1.62
	binutils-2_21:1.62
	sid-snapshot-20101201:1.62
	binutils-2_21-branch:1.62.0.4
	binutils-2_21-branchpoint:1.62
	sid-snapshot-20101101:1.62
	sid-snapshot-20101001:1.62
	binutils-2_20_1:1.59.2.2
	gdb_7_2-2010-09-02-release:1.62
	sid-snapshot-20100901:1.62
	sid-snapshot-20100801:1.62
	gdb_7_2-branch:1.62.0.2
	gdb_7_2-2010-07-07-branchpoint:1.62
	sid-snapshot-20100701:1.62
	sid-snapshot-20100601:1.62
	sid-snapshot-20100501:1.61
	sid-snapshot-20100401:1.61
	gdb_7_1-2010-03-18-release:1.61
	sid-snapshot-20100301:1.61
	gdb_7_1-branch:1.61.0.2
	gdb_7_1-2010-02-18-branchpoint:1.61
	sid-snapshot-20100201:1.61
	sid-snapshot-20100101:1.61
	gdb_7_0_1-2009-12-22-release:1.60
	sid-snapshot-20091201:1.61
	sid-snapshot-20091101:1.61
	binutils-2_20:1.59.2.2
	gdb_7_0-2009-10-06-release:1.60
	sid-snapshot-20091001:1.60
	gdb_7_0-branch:1.60.0.2
	gdb_7_0-2009-09-16-branchpoint:1.60
	arc-sim-20090309:1.56
	binutils-arc-20081103-branch:1.56.0.22
	binutils-arc-20081103-branchpoint:1.56
	binutils-2_20-branch:1.59.0.2
	binutils-2_20-branchpoint:1.59
	sid-snapshot-20090901:1.58
	sid-snapshot-20090801:1.58
	msnyder-checkpoint-072509-branch:1.58.0.4
	msnyder-checkpoint-072509-branchpoint:1.58
	sid-snapshot-20090701:1.58
	dje-cgen-play1-branch:1.58.0.2
	dje-cgen-play1-branchpoint:1.58
	sid-snapshot-20090601:1.58
	sid-snapshot-20090501:1.58
	sid-snapshot-20090401:1.56
	arc-20081103-branch:1.56.0.20
	arc-20081103-branchpoint:1.56
	arc-insight_6_8-branch:1.56.0.18
	arc-insight_6_8-branchpoint:1.56
	insight_6_8-branch:1.56.0.16
	insight_6_8-branchpoint:1.56
	sid-snapshot-20090301:1.56
	binutils-2_19_1:1.56
	sid-snapshot-20090201:1.56
	sid-snapshot-20090101:1.56
	reverse-20081226-branch:1.56.0.14
	reverse-20081226-branchpoint:1.56
	sid-snapshot-20081201:1.56
	multiprocess-20081120-branch:1.56.0.12
	multiprocess-20081120-branchpoint:1.56
	sid-snapshot-20081101:1.56
	binutils-2_19:1.56
	sid-snapshot-20081001:1.56
	reverse-20080930-branch:1.56.0.10
	reverse-20080930-branchpoint:1.56
	binutils-2_19-branch:1.56.0.8
	binutils-2_19-branchpoint:1.56
	sid-snapshot-20080901:1.56
	sid-snapshot-20080801:1.56
	reverse-20080717-branch:1.56.0.6
	reverse-20080717-branchpoint:1.56
	sid-snapshot-20080701:1.56
	msnyder-reverse-20080609-branch:1.56.0.4
	msnyder-reverse-20080609-branchpoint:1.56
	drow-reverse-20070409-branch:1.50.0.4
	drow-reverse-20070409-branchpoint:1.50
	sid-snapshot-20080601:1.56
	sid-snapshot-20080501:1.56
	sid-snapshot-20080403:1.56
	sid-snapshot-20080401:1.56
	gdb_6_8-2008-03-27-release:1.56
	sid-snapshot-20080301:1.56
	gdb_6_8-branch:1.56.0.2
	gdb_6_8-2008-02-26-branchpoint:1.56
	sid-snapshot-20080201:1.55
	sid-snapshot-20080101:1.55
	sid-snapshot-20071201:1.55
	sid-snapshot-20071101:1.54
	gdb_6_7_1-2007-10-29-release:1.54
	gdb_6_7-2007-10-10-release:1.54
	sid-snapshot-20071001:1.54
	gdb_6_7-branch:1.54.0.4
	gdb_6_7-2007-09-07-branchpoint:1.54
	binutils-2_18:1.54
	binutils-2_18-branch:1.54.0.2
	binutils-2_18-branchpoint:1.54
	insight_6_6-20070208-release:1.50
	binutils-csl-coldfire-4_1-32:1.49
	binutils-csl-sourcerygxx-4_1-32:1.49
	gdb_6_6-2006-12-18-release:1.50
	binutils-csl-innovasic-fido-3_4_4-33:1.49
	binutils-csl-sourcerygxx-3_4_4-32:1.45
	binutils-csl-coldfire-4_1-30:1.49
	binutils-csl-sourcerygxx-4_1-30:1.49
	binutils-csl-coldfire-4_1-28:1.49
	binutils-csl-sourcerygxx-4_1-29:1.49
	binutils-csl-sourcerygxx-4_1-28:1.49
	gdb_6_6-branch:1.50.0.2
	gdb_6_6-2006-11-15-branchpoint:1.50
	binutils-csl-arm-2006q3-27:1.49
	binutils-csl-sourcerygxx-4_1-27:1.49
	binutils-csl-arm-2006q3-26:1.49
	binutils-csl-sourcerygxx-4_1-26:1.49
	binutils-csl-sourcerygxx-4_1-25:1.49
	binutils-csl-sourcerygxx-4_1-24:1.49
	binutils-csl-sourcerygxx-4_1-23:1.49
	insight_6_5-20061003-release:1.49
	gdb-csl-symbian-6_4_50_20060226-12:1.49
	binutils-csl-sourcerygxx-4_1-21:1.49
	binutils-csl-arm-2006q3-21:1.49
	binutils-csl-sourcerygxx-4_1-22:1.49
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.49
	binutils-csl-sourcerygxx-4_1-20:1.49
	binutils-csl-arm-2006q3-19:1.49
	binutils-csl-sourcerygxx-4_1-19:1.49
	binutils-csl-sourcerygxx-4_1-18:1.49
	binutils-csl-renesas-4_1-9:1.49
	gdb-csl-sourcerygxx-3_4_4-25:1.49
	binutils-csl-sourcerygxx-3_4_4-25:1.45
	nickrob-async-20060828-mergepoint:1.49
	gdb-csl-symbian-6_4_50_20060226-11:1.49
	binutils-csl-renesas-4_1-8:1.49
	binutils-csl-renesas-4_1-7:1.49
	binutils-csl-renesas-4_1-6:1.49
	gdb-csl-sourcerygxx-4_1-17:1.49
	binutils-csl-sourcerygxx-4_1-17:1.49
	gdb-csl-20060226-branch-local-2:1.49
	gdb-csl-sourcerygxx-4_1-14:1.49
	binutils-csl-sourcerygxx-4_1-14:1.49
	binutils-csl-sourcerygxx-4_1-15:1.49
	gdb-csl-sourcerygxx-4_1-13:1.49
	binutils-csl-sourcerygxx-4_1-13:1.49
	binutils-2_17:1.49
	gdb-csl-sourcerygxx-4_1-12:1.49
	binutils-csl-sourcerygxx-4_1-12:1.49
	gdb-csl-sourcerygxx-3_4_4-21:1.49
	binutils-csl-sourcerygxx-3_4_4-21:1.49
	gdb_6_5-20060621-release:1.49
	binutils-csl-wrs-linux-3_4_4-24:1.45
	binutils-csl-wrs-linux-3_4_4-23:1.45
	gdb-csl-sourcerygxx-4_1-9:1.49
	binutils-csl-sourcerygxx-4_1-9:1.49
	gdb-csl-sourcerygxx-4_1-8:1.49
	binutils-csl-sourcerygxx-4_1-8:1.49
	gdb-csl-sourcerygxx-4_1-7:1.49
	binutils-csl-sourcerygxx-4_1-7:1.49
	gdb-csl-arm-2006q1-6:1.49
	binutils-csl-arm-2006q1-6:1.49
	gdb-csl-sourcerygxx-4_1-6:1.49
	binutils-csl-sourcerygxx-4_1-6:1.49
	binutils-csl-wrs-linux-3_4_4-22:1.45
	gdb-csl-symbian-6_4_50_20060226-10:1.49
	gdb-csl-symbian-6_4_50_20060226-9:1.49
	gdb-csl-symbian-6_4_50_20060226-8:1.49
	gdb-csl-coldfire-4_1-11:1.49
	binutils-csl-coldfire-4_1-11:1.49
	gdb-csl-sourcerygxx-3_4_4-19:1.49
	binutils-csl-sourcerygxx-3_4_4-19:1.49
	gdb-csl-coldfire-4_1-10:1.49
	gdb_6_5-branch:1.49.0.30
	gdb_6_5-2006-05-14-branchpoint:1.49
	binutils-csl-coldfire-4_1-10:1.49
	gdb-csl-sourcerygxx-4_1-5:1.49
	binutils-csl-sourcerygxx-4_1-5:1.49
	nickrob-async-20060513-branch:1.49.0.28
	nickrob-async-20060513-branchpoint:1.49
	gdb-csl-sourcerygxx-4_1-4:1.49
	binutils-csl-sourcerygxx-4_1-4:1.49
	msnyder-reverse-20060502-branch:1.49.0.26
	msnyder-reverse-20060502-branchpoint:1.49
	binutils-csl-wrs-linux-3_4_4-21:1.45
	gdb-csl-morpho-4_1-4:1.49
	binutils-csl-morpho-4_1-4:1.49
	gdb-csl-sourcerygxx-3_4_4-17:1.49
	binutils-csl-sourcerygxx-3_4_4-17:1.49
	binutils-csl-wrs-linux-3_4_4-20:1.45
	readline_5_1-import-branch:1.49.0.24
	readline_5_1-import-branchpoint:1.49
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.49
	binutils-2_17-branch:1.49.0.22
	binutils-2_17-branchpoint:1.49
	gdb-csl-symbian-20060226-branch:1.49.0.20
	gdb-csl-symbian-20060226-branchpoint:1.49
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.49
	msnyder-reverse-20060331-branch:1.49.0.18
	msnyder-reverse-20060331-branchpoint:1.49
	binutils-csl-2_17-branch:1.49.0.16
	binutils-csl-2_17-branchpoint:1.49
	gdb-csl-available-20060303-branch:1.49.0.14
	gdb-csl-available-20060303-branchpoint:1.49
	gdb-csl-20060226-branch:1.49.0.12
	gdb-csl-20060226-branchpoint:1.49
	gdb_6_4-20051202-release:1.49
	msnyder-fork-checkpoint-branch:1.49.0.10
	msnyder-fork-checkpoint-branchpoint:1.49
	gdb-csl-gxxpro-6_3-branch:1.49.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.49
	gdb_6_4-branch:1.49.0.6
	gdb_6_4-2005-11-01-branchpoint:1.49
	gdb-csl-arm-20051020-branch:1.49.0.4
	gdb-csl-arm-20051020-branchpoint:1.49
	binutils-csl-gxxpro-3_4-branch:1.45.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.45
	binutils-2_16_1:1.45
	msnyder-tracepoint-checkpoint-branch:1.49.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.49
	gdb-csl-arm-20050325-2005-q1b:1.46
	binutils-csl-arm-2005q1b:1.45
	binutils-2_16:1.45
	gdb-csl-arm-20050325-2005-q1a:1.46
	binutils-csl-arm-2005q1a:1.45
	csl-arm-20050325-branch:1.46.0.2
	csl-arm-20050325-branchpoint:1.46
	binutils-csl-arm-2005q1-branch:1.45.0.4
	binutils-csl-arm-2005q1-branchpoint:1.45
	binutils-2_16-branch:1.45.0.2
	binutils-2_16-branchpoint:1.45
	csl-arm-2004-q3d:1.41
	gdb_6_3-20041109-release:1.41
	gdb_6_3-branch:1.41.0.2
	gdb_6_3-20041019-branchpoint:1.41
	csl-arm-2004-q3:1.41
	drow_intercu-merge-20040921:1.41
	drow_intercu-merge-20040915:1.41
	jimb-gdb_6_2-e500-branch:1.40.0.20
	jimb-gdb_6_2-e500-branchpoint:1.40
	gdb_6_2-20040730-release:1.40
	gdb_6_2-branch:1.40.0.16
	gdb_6_2-2004-07-10-gmt-branchpoint:1.40
	gdb_6_1_1-20040616-release:1.40
	binutils-2_15:1.40
	binutils-2_15-branchpoint:1.40
	csl-arm-2004-q1a:1.40
	csl-arm-2004-q1:1.40
	gdb_6_1-2004-04-05-release:1.40
	drow_intercu-merge-20040402:1.40
	drow_intercu-merge-20040327:1.40
	ezannoni_pie-20040323-branch:1.40.0.14
	ezannoni_pie-20040323-branchpoint:1.40
	cagney_tramp-20040321-mergepoint:1.40
	cagney_tramp-20040309-branch:1.40.0.12
	cagney_tramp-20040309-branchpoint:1.40
	gdb_6_1-branch:1.40.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.40
	drow_intercu-20040221-branch:1.40.0.8
	drow_intercu-20040221-branchpoint:1.40
	binutils-2_15-branch:1.40.0.6
	cagney_bfdfile-20040213-branch:1.40.0.4
	cagney_bfdfile-20040213-branchpoint:1.40
	drow-cplus-merge-20040208:1.40
	carlton_dictionary-20040126-merge:1.40
	cagney_bigcore-20040122-branch:1.40.0.2
	cagney_bigcore-20040122-branchpoint:1.40
	drow-cplus-merge-20040113:1.40
	csl-arm-2003-q4:1.40
	drow-cplus-merge-20031224:1.40
	drow-cplus-merge-20031220:1.40
	carlton_dictionary-20031215-merge:1.39
	drow-cplus-merge-20031214:1.39
	carlton-dictionary-20031111-merge:1.39
	gdb_6_0-2003-10-04-release:1.37
	kettenis_sparc-20030918-branch:1.37.0.24
	kettenis_sparc-20030918-branchpoint:1.37
	carlton_dictionary-20030917-merge:1.37
	ezannoni_pie-20030916-branchpoint:1.37
	ezannoni_pie-20030916-branch:1.37.0.22
	cagney_x86i386-20030821-branch:1.37.0.20
	cagney_x86i386-20030821-branchpoint:1.37
	carlton_dictionary-20030805-merge:1.37
	carlton_dictionary-20030627-merge:1.37
	gdb_6_0-branch:1.37.0.18
	gdb_6_0-2003-06-23-branchpoint:1.37
	jimb-ppc64-linux-20030613-branch:1.37.0.16
	jimb-ppc64-linux-20030613-branchpoint:1.37
	binutils-2_14:1.37
	cagney_convert-20030606-branch:1.37.0.14
	cagney_convert-20030606-branchpoint:1.37
	cagney_writestrings-20030508-branch:1.37.0.12
	cagney_writestrings-20030508-branchpoint:1.37
	jimb-ppc64-linux-20030528-branch:1.37.0.10
	jimb-ppc64-linux-20030528-branchpoint:1.37
	carlton_dictionary-20030523-merge:1.37
	cagney_fileio-20030521-branch:1.37.0.8
	cagney_fileio-20030521-branchpoint:1.37
	kettenis_i386newframe-20030517-mergepoint:1.37
	jimb-ppc64-linux-20030509-branch:1.37.0.6
	jimb-ppc64-linux-20030509-branchpoint:1.37
	kettenis_i386newframe-20030504-mergepoint:1.37
	carlton_dictionary-20030430-merge:1.37
	binutils-2_14-branch:1.37.0.4
	binutils-2_14-branchpoint:1.37
	kettenis_i386newframe-20030419-branch:1.37.0.2
	kettenis_i386newframe-20030419-branchpoint:1.37
	carlton_dictionary-20030416-merge:1.37
	cagney_frameaddr-20030409-mergepoint:1.36
	kettenis_i386newframe-20030406-branch:1.36.0.4
	kettenis_i386newframe-20030406-branchpoint:1.36
	cagney_frameaddr-20030403-branchpoint:1.36
	cagney_frameaddr-20030403-branch:1.36.0.2
	cagney_framebase-20030330-mergepoint:1.35
	cagney_framebase-20030326-branch:1.35.0.14
	cagney_framebase-20030326-branchpoint:1.35
	cagney_lazyid-20030317-branch:1.35.0.12
	cagney_lazyid-20030317-branchpoint:1.35
	kettenis-i386newframe-20030316-mergepoint:1.35
	offbyone-20030313-branch:1.35.0.10
	offbyone-20030313-branchpoint:1.35
	kettenis-i386newframe-20030308-branch:1.35.0.8
	kettenis-i386newframe-20030308-branchpoint:1.35
	carlton_dictionary-20030305-merge:1.35
	cagney_offbyone-20030303-branch:1.35.0.6
	cagney_offbyone-20030303-branchpoint:1.35
	carlton_dictionary-20030207-merge:1.35
	interps-20030202-branch:1.35.0.4
	interps-20030202-branchpoint:1.35
	cagney-unwind-20030108-branch:1.35.0.2
	cagney-unwind-20030108-branchpoint:1.35
	binutils-2_13_2_1:1.33.2.1
	binutils-2_13_2:1.33.2.1
	carlton_dictionary-20021223-merge:1.35
	gdb_5_3-2002-12-12-release:1.34
	carlton_dictionary-20021115-merge:1.34
	binutils-2_13_1:1.33.2.1
	kseitz_interps-20021105-merge:1.34
	kseitz_interps-20021103-merge:1.34
	drow-cplus-merge-20021020:1.34
	drow-cplus-merge-20021025:1.34
	carlton_dictionary-20021025-merge:1.34
	carlton_dictionary-20021011-merge:1.34
	drow-cplus-branch:1.34.0.12
	drow-cplus-branchpoint:1.34
	kseitz_interps-20020930-merge:1.34
	carlton_dictionary-20020927-merge:1.34
	carlton_dictionary-branch:1.34.0.10
	carlton_dictionary-20020920-branchpoint:1.34
	sid-20020905-branchpoint:1.34
	sid-20020905-branch:1.34.0.8
	gdb_5_3-branch:1.34.0.6
	gdb_5_3-2002-09-04-branchpoint:1.34
	kseitz_interps-20020829-merge:1.34
	cagney_sysregs-20020825-branch:1.34.0.4
	cagney_sysregs-20020825-branchpoint:1.34
	readline_4_3-import-branch:1.34.0.2
	readline_4_3-import-branchpoint:1.34
	binutils-2_13:1.33
	gdb_5_2_1-2002-07-23-release:1.32
	binutils-2_13-branchpoint:1.33
	binutils-2_13-branch:1.33.0.2
	kseitz_interps-20020528-branch:1.32.0.10
	kseitz_interps-20020528-branchpoint:1.32
	cagney_regbuf-20020515-branch:1.32.0.8
	cagney_regbuf-20020515-branchpoint:1.32
	binutils-2_12_1:1.32
	jimb-macro-020506-branch:1.32.0.6
	jimb-macro-020506-branchpoint:1.32
	gdb_5_2-2002-04-29-release:1.32
	binutils-2_12:1.32
	gdb_5_2-branch:1.32.0.4
	gdb_5_2-2002-03-03-branchpoint:1.32
	binutils-2_12-branch:1.32.0.2
	binutils-2_12-branchpoint:1.32
	gdb_5_1_1-2002-01-24-release:1.30
	gdb_5_1_0_1-2002-01-03-release:1.30
	cygnus_cvs_20020108_pre:1.32
	gdb_5_1_0_1-2002-01-03-branch:1.30.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.30
	gdb_5_1-2001-11-21-release:1.30
	gdb_s390-2001-09-26-branch:1.30.0.4
	gdb_s390-2001-09-26-branchpoint:1.30
	gdb_5_1-2001-07-29-branch:1.30.0.2
	gdb_5_1-2001-07-29-branchpoint:1.30
	binutils-2_11_2:1.26.2.3
	binutils-2_11_1:1.26.2.3
	binutils-2_11:1.26.2.1
	x86_64versiong3:1.28
	binutils-2_11-branch:1.26.0.2
	insight-precleanup-2001-01-01:1.25
	binutils-2_10_1:1.20
	binutils-2_10:1.20
	gdb-premipsmulti-2000-06-06-branch:1.21.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.21
	gdb_5_0-2000-05-19-release:1.20
	gdb_4_18_2-2000-05-18-release:1.20
	gdb_4_95_1-2000-05-11-snapshot:1.20
	gdb_4_95_0-2000-04-27-snapshot:1.20
	gdb_5_0-2000-04-10-branch:1.20.0.4
	gdb_5_0-2000-04-10-branchpoint:1.20
	binutils-2_10-branch:1.20.0.2
	binutils-2_10-branchpoint:1.20
	binutils_latest_snapshot:1.67
	repo-unification-2000-02-06:1.16
	binu_ss_19990721:1.6
	binu_ss_19990602:1.3
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.67
date	2013.04.17.14.16.01;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2013.03.21.14.07.08;	author ktietz;	state Exp;
branches;
next	1.65;

1.65
date	2013.01.10.20.03.55;	author hjl;	state Exp;
branches;
next	1.64;

1.64
date	2012.05.05.03.05.25;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2011.09.09.16.28.12;	author ktietz;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.26.07.37.36;	author gingold;	state Exp;
branches;
next	1.61;

1.61
date	2009.10.16.07.14.43;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2009.09.09.21.38.58;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches
	1.59.2.1;
next	1.58;

1.58
date	2009.04.21.17.08.20;	author hjl;	state Exp;
branches;
next	1.57;

1.57
date	2009.04.17.13.46.16;	author hjl;	state Exp;
branches;
next	1.56;

1.56
date	2008.02.14.15.20.26;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.12.21.55.50;	author hjl;	state Exp;
branches;
next	1.54;

1.54
date	2007.07.12.07.16.41;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2007.07.05.02.50.02;	author hjl;	state Exp;
branches;
next	1.52;

1.52
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.18.16.26.28;	author hjl;	state Exp;
branches;
next	1.50;

1.50
date	2006.09.20.11.35.07;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2005.05.04.15.53.37;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.04.07.19.34;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2005.04.21.07.45.38;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.19.06.48.31;	author dannysmith;	state Exp;
branches;
next	1.45;

1.45
date	2005.02.28.16.07.33;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.20.14.59.07;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.14.11.20.37;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2005.01.31.23.13.29;	author bje;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.13.03.16.00;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.16.11.10.42;	author nickc;	state Exp;
branches
	1.40.8.1;
next	1.39;

1.39
date	2003.10.31.05.32.46;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.22.15.12.58;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.15.14.26.06;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.03.11.13.27;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.30.05.49.24;	author amodra;	state Exp;
branches
	1.34.10.1
	1.34.12.1;
next	1.33;

1.33
date	2002.06.25.06.21.54;	author amodra;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2001.09.20.23.30.37;	author amodra;	state Exp;
branches
	1.32.10.1;
next	1.31;

1.31
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.05.10.52.25;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.13.19.23.08;	author dj;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.06.19.43.19;	author hjl;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.02.19.22.56;	author kazu;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2000.12.21.18.40.21;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.30.21.54.03;	author dj;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.19.01.22.37;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.13.00.30.46;	author amylaar;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.13.01.08.04;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.06.22.38.43;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.06.19.49.58;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.01.20.39.07;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2000.02.28.18.56.11;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	99.12.28.00.25.18;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	99.12.17.19.03.09;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	99.09.12.00.30.27;	author ian;	state Exp;
branches;
next	1.13;

1.13
date	99.09.12.00.02.11;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	99.09.11.23.37.28;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	99.09.11.22.52.20;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	99.09.11.22.46.37;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.09.11.22.41.54;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.09.11.22.33.45;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.08.08.16.50.27;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.07.12.10.29.58;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.26.19.33.44;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.26.19.32.54;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.05.25.11.37.40;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	99.05.11.21.05.44;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.59.2.1
date	2009.09.09.21.40.20;	author nickc;	state Exp;
branches;
next	1.59.2.2;

1.59.2.2
date	2009.10.16.10.02.44;	author gingold;	state Exp;
branches;
next	;

1.40.8.1
date	2004.09.16.17.00.36;	author drow;	state Exp;
branches;
next	;

1.34.10.1
date	2002.12.23.19.37.58;	author carlton;	state Exp;
branches;
next	1.34.10.2;

1.34.10.2
date	2003.04.16.19.56.46;	author carlton;	state Exp;
branches;
next	1.34.10.3;

1.34.10.3
date	2003.11.11.23.50.28;	author carlton;	state Exp;
branches;
next	1.34.10.4;

1.34.10.4
date	2004.01.26.19.11.10;	author carlton;	state Exp;
branches;
next	;

1.34.12.1
date	2003.12.14.20.26.50;	author drow;	state Exp;
branches;
next	1.34.12.2;

1.34.12.2
date	2003.12.20.18.16.47;	author drow;	state Exp;
branches;
next	;

1.33.2.1
date	2002.09.23.22.12.41;	author drow;	state Exp;
branches;
next	;

1.32.10.1
date	2002.07.22.21.46.49;	author kseitz;	state Exp;
branches;
next	1.32.10.2;

1.32.10.2
date	2002.08.09.18.34.17;	author kseitz;	state Exp;
branches;
next	;

1.26.2.1
date	2001.02.14.14.58.33;	author pb;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2001.06.11.10.04.19;	author amodra;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2001.07.05.16.56.12;	author nickc;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;


desc
@@


1.67
log
@	* coffcode.h: Added a cast to void when a bfd_set_section_*()
	macro's return value is ignored.
	* elf32-hppa.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* mach-o.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* peicode.h: Likewise.
	* elf32-m32r.c: Check return value of bfd_set_section_*().
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* vms-alpha.c: Likewise.
@
text
@/* Support for the generic parts of PE/PEI, for BFD.
   Copyright 1995-2013 Free Software Foundation, Inc.
   Written by Cygnus Solutions.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* Most of this hacked by  Steve Chamberlain,
			sac@@cygnus.com

   PE/PEI rearrangement (and code added): Donn Terry
                                       Softway Systems, Inc.  */

/* Hey look, some documentation [and in a place you expect to find it]!

   The main reference for the pei format is "Microsoft Portable Executable
   and Common Object File Format Specification 4.1".  Get it if you need to
   do some serious hacking on this code.

   Another reference:
   "Peering Inside the PE: A Tour of the Win32 Portable Executable
   File Format", MSJ 1994, Volume 9.

   The *sole* difference between the pe format and the pei format is that the
   latter has an MSDOS 2.0 .exe header on the front that prints the message
   "This app must be run under Windows." (or some such).
   (FIXME: Whether that statement is *really* true or not is unknown.
   Are there more subtle differences between pe and pei formats?
   For now assume there aren't.  If you find one, then for God sakes
   document it here!)

   The Microsoft docs use the word "image" instead of "executable" because
   the former can also refer to a DLL (shared library).  Confusion can arise
   because the `i' in `pei' also refers to "image".  The `pe' format can
   also create images (i.e. executables), it's just that to run on a win32
   system you need to use the pei format.

   FIXME: Please add more docs here so the next poor fool that has to hack
   on this code has a chance of getting something accomplished without
   wasting too much time.  */

#include "libpei.h"

static bfd_boolean (*pe_saved_coff_bfd_print_private_bfd_data) (bfd *, void *) =
#ifndef coff_bfd_print_private_bfd_data
     NULL;
#else
     coff_bfd_print_private_bfd_data;
#undef coff_bfd_print_private_bfd_data
#endif

static bfd_boolean                      pe_print_private_bfd_data (bfd *, void *);
#define coff_bfd_print_private_bfd_data pe_print_private_bfd_data

static bfd_boolean (*pe_saved_coff_bfd_copy_private_bfd_data) (bfd *, bfd *) =
#ifndef coff_bfd_copy_private_bfd_data
     NULL;
#else
     coff_bfd_copy_private_bfd_data;
#undef coff_bfd_copy_private_bfd_data
#endif

static bfd_boolean                     pe_bfd_copy_private_bfd_data (bfd *, bfd *);
#define coff_bfd_copy_private_bfd_data pe_bfd_copy_private_bfd_data

#define coff_mkobject      pe_mkobject
#define coff_mkobject_hook pe_mkobject_hook

#ifdef COFF_IMAGE_WITH_PE
/* This structure contains static variables used by the ILF code.  */
typedef asection * asection_ptr;

typedef struct
{
  bfd *			abfd;
  bfd_byte *		data;
  struct bfd_in_memory * bim;
  unsigned short        magic;

  arelent *		reltab;
  unsigned int 		relcount;

  coff_symbol_type * 	sym_cache;
  coff_symbol_type * 	sym_ptr;
  unsigned int       	sym_index;

  unsigned int * 	sym_table;
  unsigned int * 	table_ptr;

  combined_entry_type * native_syms;
  combined_entry_type * native_ptr;

  coff_symbol_type **	sym_ptr_table;
  coff_symbol_type **	sym_ptr_ptr;

  unsigned int		sec_index;

  char *                string_table;
  char *                string_ptr;
  char *		end_string_ptr;

  SYMENT *              esym_table;
  SYMENT *              esym_ptr;

  struct internal_reloc * int_reltab;
}
pe_ILF_vars;
#endif /* COFF_IMAGE_WITH_PE */

const bfd_target *coff_real_object_p
  (bfd *, unsigned, struct internal_filehdr *, struct internal_aouthdr *);

#ifndef NO_COFF_RELOCS
static void
coff_swap_reloc_in (bfd * abfd, void * src, void * dst)
{
  RELOC *reloc_src = (RELOC *) src;
  struct internal_reloc *reloc_dst = (struct internal_reloc *) dst;

  reloc_dst->r_vaddr  = H_GET_32 (abfd, reloc_src->r_vaddr);
  reloc_dst->r_symndx = H_GET_S32 (abfd, reloc_src->r_symndx);
  reloc_dst->r_type   = H_GET_16 (abfd, reloc_src->r_type);
#ifdef SWAP_IN_RELOC_OFFSET
  reloc_dst->r_offset = SWAP_IN_RELOC_OFFSET (abfd, reloc_src->r_offset);
#endif
}

static unsigned int
coff_swap_reloc_out (bfd * abfd, void * src, void * dst)
{
  struct internal_reloc *reloc_src = (struct internal_reloc *) src;
  struct external_reloc *reloc_dst = (struct external_reloc *) dst;

  H_PUT_32 (abfd, reloc_src->r_vaddr, reloc_dst->r_vaddr);
  H_PUT_32 (abfd, reloc_src->r_symndx, reloc_dst->r_symndx);
  H_PUT_16 (abfd, reloc_src->r_type, reloc_dst->r_type);

#ifdef SWAP_OUT_RELOC_OFFSET
  SWAP_OUT_RELOC_OFFSET (abfd, reloc_src->r_offset, reloc_dst->r_offset);
#endif
#ifdef SWAP_OUT_RELOC_EXTRA
  SWAP_OUT_RELOC_EXTRA (abfd, reloc_src, reloc_dst);
#endif
  return RELSZ;
}
#endif /* not NO_COFF_RELOCS */

#ifdef COFF_IMAGE_WITH_PE
#undef FILHDR
#define FILHDR struct external_PEI_IMAGE_hdr
#endif

static void
coff_swap_filehdr_in (bfd * abfd, void * src, void * dst)
{
  FILHDR *filehdr_src = (FILHDR *) src;
  struct internal_filehdr *filehdr_dst = (struct internal_filehdr *) dst;

  filehdr_dst->f_magic  = H_GET_16 (abfd, filehdr_src->f_magic);
  filehdr_dst->f_nscns  = H_GET_16 (abfd, filehdr_src->f_nscns);
  filehdr_dst->f_timdat = H_GET_32 (abfd, filehdr_src->f_timdat);
  filehdr_dst->f_nsyms  = H_GET_32 (abfd, filehdr_src->f_nsyms);
  filehdr_dst->f_flags  = H_GET_16 (abfd, filehdr_src->f_flags);
  filehdr_dst->f_symptr = H_GET_32 (abfd, filehdr_src->f_symptr);

  /* Other people's tools sometimes generate headers with an nsyms but
     a zero symptr.  */
  if (filehdr_dst->f_nsyms != 0 && filehdr_dst->f_symptr == 0)
    {
      filehdr_dst->f_nsyms = 0;
      filehdr_dst->f_flags |= F_LSYMS;
    }

  filehdr_dst->f_opthdr = H_GET_16 (abfd, filehdr_src-> f_opthdr);
}

#ifdef COFF_IMAGE_WITH_PE
# define coff_swap_filehdr_out _bfd_XXi_only_swap_filehdr_out
#elif defined COFF_WITH_pex64
# define coff_swap_filehdr_out _bfd_pex64_only_swap_filehdr_out
#elif defined COFF_WITH_pep
# define coff_swap_filehdr_out _bfd_pep_only_swap_filehdr_out
#else
# define coff_swap_filehdr_out _bfd_pe_only_swap_filehdr_out
#endif

static void
coff_swap_scnhdr_in (bfd * abfd, void * ext, void * in)
{
  SCNHDR *scnhdr_ext = (SCNHDR *) ext;
  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;

  memcpy (scnhdr_int->s_name, scnhdr_ext->s_name, sizeof (scnhdr_int->s_name));

  scnhdr_int->s_vaddr   = GET_SCNHDR_VADDR (abfd, scnhdr_ext->s_vaddr);
  scnhdr_int->s_paddr   = GET_SCNHDR_PADDR (abfd, scnhdr_ext->s_paddr);
  scnhdr_int->s_size    = GET_SCNHDR_SIZE (abfd, scnhdr_ext->s_size);
  scnhdr_int->s_scnptr  = GET_SCNHDR_SCNPTR (abfd, scnhdr_ext->s_scnptr);
  scnhdr_int->s_relptr  = GET_SCNHDR_RELPTR (abfd, scnhdr_ext->s_relptr);
  scnhdr_int->s_lnnoptr = GET_SCNHDR_LNNOPTR (abfd, scnhdr_ext->s_lnnoptr);
  scnhdr_int->s_flags   = H_GET_32 (abfd, scnhdr_ext->s_flags);

  /* MS handles overflow of line numbers by carrying into the reloc
     field (it appears).  Since it's supposed to be zero for PE
     *IMAGE* format, that's safe.  This is still a bit iffy.  */
#ifdef COFF_IMAGE_WITH_PE
  scnhdr_int->s_nlnno = (H_GET_16 (abfd, scnhdr_ext->s_nlnno)
			 + (H_GET_16 (abfd, scnhdr_ext->s_nreloc) << 16));
  scnhdr_int->s_nreloc = 0;
#else
  scnhdr_int->s_nreloc = H_GET_16 (abfd, scnhdr_ext->s_nreloc);
  scnhdr_int->s_nlnno = H_GET_16 (abfd, scnhdr_ext->s_nlnno);
#endif

  if (scnhdr_int->s_vaddr != 0)
    {
      scnhdr_int->s_vaddr += pe_data (abfd)->pe_opthdr.ImageBase;
      /* Do not cut upper 32-bits for 64-bit vma.  */
#ifndef COFF_WITH_pex64
      scnhdr_int->s_vaddr &= 0xffffffff;
#endif
    }

#ifndef COFF_NO_HACK_SCNHDR_SIZE
  /* If this section holds uninitialized data and is from an object file
     or from an executable image that has not initialized the field,
     or if the image is an executable file and the physical size is padded,
     use the virtual size (stored in s_paddr) instead.  */
  if (scnhdr_int->s_paddr > 0
      && (((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0
	   && (! bfd_pei_p (abfd) || scnhdr_int->s_size == 0))
          || (bfd_pei_p (abfd) && (scnhdr_int->s_size > scnhdr_int->s_paddr))))
  /* This code used to set scnhdr_int->s_paddr to 0.  However,
     coff_set_alignment_hook stores s_paddr in virt_size, which
     only works if it correctly holds the virtual size of the
     section.  */
    scnhdr_int->s_size = scnhdr_int->s_paddr;
#endif
}

static bfd_boolean
pe_mkobject (bfd * abfd)
{
  pe_data_type *pe;
  bfd_size_type amt = sizeof (pe_data_type);

  abfd->tdata.pe_obj_data = (struct pe_tdata *) bfd_zalloc (abfd, amt);

  if (abfd->tdata.pe_obj_data == 0)
    return FALSE;

  pe = pe_data (abfd);

  pe->coff.pe = 1;

  /* in_reloc_p is architecture dependent.  */
  pe->in_reloc_p = in_reloc_p;

  return TRUE;
}

/* Create the COFF backend specific information.  */

static void *
pe_mkobject_hook (bfd * abfd,
		  void * filehdr,
		  void * aouthdr ATTRIBUTE_UNUSED)
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
  pe_data_type *pe;

  if (! pe_mkobject (abfd))
    return NULL;

  pe = pe_data (abfd);
  pe->coff.sym_filepos = internal_f->f_symptr;
  /* These members communicate important constants about the symbol
     table to GDB's symbol-reading code.  These `constants'
     unfortunately vary among coff implementations...  */
  pe->coff.local_n_btmask = N_BTMASK;
  pe->coff.local_n_btshft = N_BTSHFT;
  pe->coff.local_n_tmask = N_TMASK;
  pe->coff.local_n_tshift = N_TSHIFT;
  pe->coff.local_symesz = SYMESZ;
  pe->coff.local_auxesz = AUXESZ;
  pe->coff.local_linesz = LINESZ;

  pe->coff.timestamp = internal_f->f_timdat;

  obj_raw_syment_count (abfd) =
    obj_conv_table_size (abfd) =
      internal_f->f_nsyms;

  pe->real_flags = internal_f->f_flags;

  if ((internal_f->f_flags & F_DLL) != 0)
    pe->dll = 1;

  if ((internal_f->f_flags & IMAGE_FILE_DEBUG_STRIPPED) == 0)
    abfd->flags |= HAS_DEBUG;

#ifdef COFF_IMAGE_WITH_PE
  if (aouthdr)
    pe->pe_opthdr = ((struct internal_aouthdr *) aouthdr)->pe;
#endif

#ifdef ARM
  if (! _bfd_coff_arm_set_private_flags (abfd, internal_f->f_flags))
    coff_data (abfd) ->flags = 0;
#endif

  return (void *) pe;
}

static bfd_boolean
pe_print_private_bfd_data (bfd *abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;

  if (!_bfd_XX_print_private_bfd_data_common (abfd, vfile))
    return FALSE;

  if (pe_saved_coff_bfd_print_private_bfd_data == NULL)
    return TRUE;

  fputc ('\n', file);

  return pe_saved_coff_bfd_print_private_bfd_data (abfd, vfile);
}

/* Copy any private info we understand from the input bfd
   to the output bfd.  */

static bfd_boolean
pe_bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  /* PR binutils/716: Copy the large address aware flag.
     XXX: Should we be copying other flags or other fields in the pe_data()
     structure ?  */
  if (pe_data (obfd) != NULL
      && pe_data (ibfd) != NULL
      && pe_data (ibfd)->real_flags & IMAGE_FILE_LARGE_ADDRESS_AWARE)
    pe_data (obfd)->real_flags |= IMAGE_FILE_LARGE_ADDRESS_AWARE;

  if (!_bfd_XX_bfd_copy_private_bfd_data_common (ibfd, obfd))
    return FALSE;

  if (pe_saved_coff_bfd_copy_private_bfd_data)
    return pe_saved_coff_bfd_copy_private_bfd_data (ibfd, obfd);

  return TRUE;
}

#define coff_bfd_copy_private_section_data \
  _bfd_XX_bfd_copy_private_section_data

#define coff_get_symbol_info _bfd_XX_get_symbol_info

#ifdef COFF_IMAGE_WITH_PE

/* Code to handle Microsoft's Image Library Format.
   Also known as LINK6 format.
   Documentation about this format can be found at:

   http://msdn.microsoft.com/library/specs/pecoff_section8.htm  */

/* The following constants specify the sizes of the various data
   structures that we have to create in order to build a bfd describing
   an ILF object file.  The final "+ 1" in the definitions of SIZEOF_IDATA6
   and SIZEOF_IDATA7 below is to allow for the possibility that we might
   need a padding byte in order to ensure 16 bit alignment for the section's
   contents.

   The value for SIZEOF_ILF_STRINGS is computed as follows:

      There will be NUM_ILF_SECTIONS section symbols.  Allow 9 characters
      per symbol for their names (longest section name is .idata$x).

      There will be two symbols for the imported value, one the symbol name
      and one with _imp__ prefixed.  Allowing for the terminating nul's this
      is strlen (symbol_name) * 2 + 8 + 21 + strlen (source_dll).

      The strings in the string table must start STRING__SIZE_SIZE bytes into
      the table in order to for the string lookup code in coffgen/coffcode to
      work.  */
#define NUM_ILF_RELOCS		8
#define NUM_ILF_SECTIONS        6
#define NUM_ILF_SYMS 		(2 + NUM_ILF_SECTIONS)

#define SIZEOF_ILF_SYMS		 (NUM_ILF_SYMS * sizeof (* vars.sym_cache))
#define SIZEOF_ILF_SYM_TABLE	 (NUM_ILF_SYMS * sizeof (* vars.sym_table))
#define SIZEOF_ILF_NATIVE_SYMS	 (NUM_ILF_SYMS * sizeof (* vars.native_syms))
#define SIZEOF_ILF_SYM_PTR_TABLE (NUM_ILF_SYMS * sizeof (* vars.sym_ptr_table))
#define SIZEOF_ILF_EXT_SYMS	 (NUM_ILF_SYMS * sizeof (* vars.esym_table))
#define SIZEOF_ILF_RELOCS	 (NUM_ILF_RELOCS * sizeof (* vars.reltab))
#define SIZEOF_ILF_INT_RELOCS	 (NUM_ILF_RELOCS * sizeof (* vars.int_reltab))
#define SIZEOF_ILF_STRINGS	 (strlen (symbol_name) * 2 + 8 \
					+ 21 + strlen (source_dll) \
					+ NUM_ILF_SECTIONS * 9 \
					+ STRING_SIZE_SIZE)
#define SIZEOF_IDATA2		(5 * 4)

/* For PEx64 idata4 & 5 have thumb size of 8 bytes.  */
#ifdef COFF_WITH_pex64
#define SIZEOF_IDATA4		(2 * 4)
#define SIZEOF_IDATA5		(2 * 4)
#else
#define SIZEOF_IDATA4		(1 * 4)
#define SIZEOF_IDATA5		(1 * 4)
#endif

#define SIZEOF_IDATA6		(2 + strlen (symbol_name) + 1 + 1)
#define SIZEOF_IDATA7		(strlen (source_dll) + 1 + 1)
#define SIZEOF_ILF_SECTIONS     (NUM_ILF_SECTIONS * sizeof (struct coff_section_tdata))

#define ILF_DATA_SIZE				\
    + SIZEOF_ILF_SYMS				\
    + SIZEOF_ILF_SYM_TABLE			\
    + SIZEOF_ILF_NATIVE_SYMS			\
    + SIZEOF_ILF_SYM_PTR_TABLE			\
    + SIZEOF_ILF_EXT_SYMS			\
    + SIZEOF_ILF_RELOCS				\
    + SIZEOF_ILF_INT_RELOCS			\
    + SIZEOF_ILF_STRINGS			\
    + SIZEOF_IDATA2				\
    + SIZEOF_IDATA4				\
    + SIZEOF_IDATA5				\
    + SIZEOF_IDATA6				\
    + SIZEOF_IDATA7				\
    + SIZEOF_ILF_SECTIONS			\
    + MAX_TEXT_SECTION_SIZE

/* Create an empty relocation against the given symbol.  */

static void
pe_ILF_make_a_symbol_reloc (pe_ILF_vars *               vars,
			    bfd_vma                     address,
			    bfd_reloc_code_real_type    reloc,
			    struct bfd_symbol **  	sym,
			    unsigned int                sym_index)
{
  arelent * entry;
  struct internal_reloc * internal;

  entry = vars->reltab + vars->relcount;
  internal = vars->int_reltab + vars->relcount;

  entry->address     = address;
  entry->addend      = 0;
  entry->howto       = bfd_reloc_type_lookup (vars->abfd, reloc);
  entry->sym_ptr_ptr = sym;

  internal->r_vaddr  = address;
  internal->r_symndx = sym_index;
  internal->r_type   = entry->howto->type;

  vars->relcount ++;

  BFD_ASSERT (vars->relcount <= NUM_ILF_RELOCS);
}

/* Create an empty relocation against the given section.  */

static void
pe_ILF_make_a_reloc (pe_ILF_vars *             vars,
		     bfd_vma                   address,
		     bfd_reloc_code_real_type  reloc,
		     asection_ptr              sec)
{
  pe_ILF_make_a_symbol_reloc (vars, address, reloc, sec->symbol_ptr_ptr,
			      coff_section_data (vars->abfd, sec)->i);
}

/* Move the queued relocs into the given section.  */

static void
pe_ILF_save_relocs (pe_ILF_vars * vars,
		    asection_ptr  sec)
{
  /* Make sure that there is somewhere to store the internal relocs.  */
  if (coff_section_data (vars->abfd, sec) == NULL)
    /* We should probably return an error indication here.  */
    abort ();

  coff_section_data (vars->abfd, sec)->relocs = vars->int_reltab;
  coff_section_data (vars->abfd, sec)->keep_relocs = TRUE;

  sec->relocation  = vars->reltab;
  sec->reloc_count = vars->relcount;
  sec->flags      |= SEC_RELOC;

  vars->reltab     += vars->relcount;
  vars->int_reltab += vars->relcount;
  vars->relcount   = 0;

  BFD_ASSERT ((bfd_byte *) vars->int_reltab < (bfd_byte *) vars->string_table);
}

/* Create a global symbol and add it to the relevant tables.  */

static void
pe_ILF_make_a_symbol (pe_ILF_vars *  vars,
		      const char *   prefix,
		      const char *   symbol_name,
		      asection_ptr   section,
		      flagword       extra_flags)
{
  coff_symbol_type * sym;
  combined_entry_type * ent;
  SYMENT * esym;
  unsigned short sclass;

  if (extra_flags & BSF_LOCAL)
    sclass = C_STAT;
  else
    sclass = C_EXT;

#ifdef THUMBPEMAGIC
  if (vars->magic == THUMBPEMAGIC)
    {
      if (extra_flags & BSF_FUNCTION)
	sclass = C_THUMBEXTFUNC;
      else if (extra_flags & BSF_LOCAL)
	sclass = C_THUMBSTAT;
      else
	sclass = C_THUMBEXT;
    }
#endif

  BFD_ASSERT (vars->sym_index < NUM_ILF_SYMS);

  sym = vars->sym_ptr;
  ent = vars->native_ptr;
  esym = vars->esym_ptr;

  /* Copy the symbol's name into the string table.  */
  sprintf (vars->string_ptr, "%s%s", prefix, symbol_name);

  if (section == NULL)
    section = bfd_und_section_ptr;

  /* Initialise the external symbol.  */
  H_PUT_32 (vars->abfd, vars->string_ptr - vars->string_table,
	    esym->e.e.e_offset);
  H_PUT_16 (vars->abfd, section->target_index, esym->e_scnum);
  esym->e_sclass[0] = sclass;

  /* The following initialisations are unnecessary - the memory is
     zero initialised.  They are just kept here as reminders.  */

  /* Initialise the internal symbol structure.  */
  ent->u.syment.n_sclass          = sclass;
  ent->u.syment.n_scnum           = section->target_index;
  ent->u.syment._n._n_n._n_offset = (bfd_hostptr_t) sym;

  sym->symbol.the_bfd = vars->abfd;
  sym->symbol.name    = vars->string_ptr;
  sym->symbol.flags   = BSF_EXPORT | BSF_GLOBAL | extra_flags;
  sym->symbol.section = section;
  sym->native         = ent;

  * vars->table_ptr = vars->sym_index;
  * vars->sym_ptr_ptr = sym;

  /* Adjust pointers for the next symbol.  */
  vars->sym_index ++;
  vars->sym_ptr ++;
  vars->sym_ptr_ptr ++;
  vars->table_ptr ++;
  vars->native_ptr ++;
  vars->esym_ptr ++;
  vars->string_ptr += strlen (symbol_name) + strlen (prefix) + 1;

  BFD_ASSERT (vars->string_ptr < vars->end_string_ptr);
}

/* Create a section.  */

static asection_ptr
pe_ILF_make_a_section (pe_ILF_vars * vars,
		       const char *  name,
		       unsigned int  size,
		       flagword      extra_flags)
{
  asection_ptr sec;
  flagword     flags;

  sec = bfd_make_section_old_way (vars->abfd, name);
  if (sec == NULL)
    return NULL;

  flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_KEEP | SEC_IN_MEMORY;

  bfd_set_section_flags (vars->abfd, sec, flags | extra_flags);

  (void) bfd_set_section_alignment (vars->abfd, sec, 2);

  /* Check that we will not run out of space.  */
  BFD_ASSERT (vars->data + size < vars->bim->buffer + vars->bim->size);

  /* Set the section size and contents.  The actual
     contents are filled in by our parent.  */
  bfd_set_section_size (vars->abfd, sec, (bfd_size_type) size);
  sec->contents = vars->data;
  sec->target_index = vars->sec_index ++;

  /* Advance data pointer in the vars structure.  */
  vars->data += size;

  /* Skip the padding byte if it was not needed.
     The logic here is that if the string length is odd,
     then the entire string length, including the null byte,
     is even and so the extra, padding byte, is not needed.  */
  if (size & 1)
    vars->data --;

  /* Create a coff_section_tdata structure for our use.  */
  sec->used_by_bfd = (struct coff_section_tdata *) vars->data;
  vars->data += sizeof (struct coff_section_tdata);

  BFD_ASSERT (vars->data <= vars->bim->buffer + vars->bim->size);

  /* Create a symbol to refer to this section.  */
  pe_ILF_make_a_symbol (vars, "", name, sec, BSF_LOCAL);

  /* Cache the index to the symbol in the coff_section_data structure.  */
  coff_section_data (vars->abfd, sec)->i = vars->sym_index - 1;

  return sec;
}

/* This structure contains the code that goes into the .text section
   in order to perform a jump into the DLL lookup table.  The entries
   in the table are index by the magic number used to represent the
   machine type in the PE file.  The contents of the data[] arrays in
   these entries are stolen from the jtab[] arrays in ld/pe-dll.c.
   The SIZE field says how many bytes in the DATA array are actually
   used.  The OFFSET field says where in the data array the address
   of the .idata$5 section should be placed.  */
#define MAX_TEXT_SECTION_SIZE 32

typedef struct
{
  unsigned short magic;
  unsigned char  data[MAX_TEXT_SECTION_SIZE];
  unsigned int   size;
  unsigned int   offset;
}
jump_table;

static jump_table jtab[] =
{
#ifdef I386MAGIC
  { I386MAGIC,
    { 0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90 },
    8, 2
  },
#endif

#ifdef AMD64MAGIC
  { AMD64MAGIC,
    { 0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90 },
    8, 2
  },
#endif

#ifdef  MC68MAGIC
  { MC68MAGIC,
    { /* XXX fill me in */ },
    0, 0
  },
#endif

#ifdef  MIPS_ARCH_MAGIC_WINCE
  { MIPS_ARCH_MAGIC_WINCE,
    { 0x00, 0x00, 0x08, 0x3c, 0x00, 0x00, 0x08, 0x8d,
      0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 },
    16, 0
  },
#endif

#ifdef  SH_ARCH_MAGIC_WINCE
  { SH_ARCH_MAGIC_WINCE,
    { 0x01, 0xd0, 0x02, 0x60, 0x2b, 0x40,
      0x09, 0x00, 0x00, 0x00, 0x00, 0x00 },
    12, 8
  },
#endif

#ifdef  ARMPEMAGIC
  { ARMPEMAGIC,
    { 0x00, 0xc0, 0x9f, 0xe5, 0x00, 0xf0,
      0x9c, 0xe5, 0x00, 0x00, 0x00, 0x00},
    12, 8
  },
#endif

#ifdef  THUMBPEMAGIC
  { THUMBPEMAGIC,
    { 0x40, 0xb4, 0x02, 0x4e, 0x36, 0x68, 0xb4, 0x46,
      0x40, 0xbc, 0x60, 0x47, 0x00, 0x00, 0x00, 0x00 },
    16, 12
  },
#endif
  { 0, { 0 }, 0, 0 }
};

#ifndef NUM_ENTRIES
#define NUM_ENTRIES(a) (sizeof (a) / sizeof (a)[0])
#endif

/* Build a full BFD from the information supplied in a ILF object.  */

static bfd_boolean
pe_ILF_build_a_bfd (bfd *           abfd,
		    unsigned int    magic,
		    char *          symbol_name,
		    char *          source_dll,
		    unsigned int    ordinal,
		    unsigned int    types)
{
  bfd_byte *               ptr;
  pe_ILF_vars              vars;
  struct internal_filehdr  internal_f;
  unsigned int             import_type;
  unsigned int             import_name_type;
  asection_ptr             id4, id5, id6 = NULL, text = NULL;
  coff_symbol_type **      imp_sym;
  unsigned int             imp_index;

  /* Decode and verify the types field of the ILF structure.  */
  import_type = types & 0x3;
  import_name_type = (types & 0x1c) >> 2;

  switch (import_type)
    {
    case IMPORT_CODE:
    case IMPORT_DATA:
      break;

    case IMPORT_CONST:
      /* XXX code yet to be written.  */
      _bfd_error_handler (_("%B: Unhandled import type; %x"),
			  abfd, import_type);
      return FALSE;

    default:
      _bfd_error_handler (_("%B: Unrecognised import type; %x"),
			  abfd, import_type);
      return FALSE;
    }

  switch (import_name_type)
    {
    case IMPORT_ORDINAL:
    case IMPORT_NAME:
    case IMPORT_NAME_NOPREFIX:
    case IMPORT_NAME_UNDECORATE:
      break;

    default:
      _bfd_error_handler (_("%B: Unrecognised import name type; %x"),
			  abfd, import_name_type);
      return FALSE;
    }

  /* Initialise local variables.

     Note these are kept in a structure rather than being
     declared as statics since bfd frowns on global variables.

     We are going to construct the contents of the BFD in memory,
     so allocate all the space that we will need right now.  */
  vars.bim
    = (struct bfd_in_memory *) bfd_malloc ((bfd_size_type) sizeof (*vars.bim));
  if (vars.bim == NULL)
    return FALSE;

  ptr = (bfd_byte *) bfd_zmalloc ((bfd_size_type) ILF_DATA_SIZE);
  vars.bim->buffer = ptr;
  vars.bim->size   = ILF_DATA_SIZE;
  if (ptr == NULL)
    goto error_return;

  /* Initialise the pointers to regions of the memory and the
     other contents of the pe_ILF_vars structure as well.  */
  vars.sym_cache = (coff_symbol_type *) ptr;
  vars.sym_ptr   = (coff_symbol_type *) ptr;
  vars.sym_index = 0;
  ptr += SIZEOF_ILF_SYMS;

  vars.sym_table = (unsigned int *) ptr;
  vars.table_ptr = (unsigned int *) ptr;
  ptr += SIZEOF_ILF_SYM_TABLE;

  vars.native_syms = (combined_entry_type *) ptr;
  vars.native_ptr  = (combined_entry_type *) ptr;
  ptr += SIZEOF_ILF_NATIVE_SYMS;

  vars.sym_ptr_table = (coff_symbol_type **) ptr;
  vars.sym_ptr_ptr   = (coff_symbol_type **) ptr;
  ptr += SIZEOF_ILF_SYM_PTR_TABLE;

  vars.esym_table = (SYMENT *) ptr;
  vars.esym_ptr   = (SYMENT *) ptr;
  ptr += SIZEOF_ILF_EXT_SYMS;

  vars.reltab   = (arelent *) ptr;
  vars.relcount = 0;
  ptr += SIZEOF_ILF_RELOCS;

  vars.int_reltab  = (struct internal_reloc *) ptr;
  ptr += SIZEOF_ILF_INT_RELOCS;

  vars.string_table = (char *) ptr;
  vars.string_ptr   = (char *) ptr + STRING_SIZE_SIZE;
  ptr += SIZEOF_ILF_STRINGS;
  vars.end_string_ptr = (char *) ptr;

  /* The remaining space in bim->buffer is used
     by the pe_ILF_make_a_section() function.  */
  vars.data = ptr;
  vars.abfd = abfd;
  vars.sec_index = 0;
  vars.magic = magic;

  /* Create the initial .idata$<n> sections:
     [.idata$2:  Import Directory Table -- not needed]
     .idata$4:  Import Lookup Table
     .idata$5:  Import Address Table

     Note we do not create a .idata$3 section as this is
     created for us by the linker script.  */
  id4 = pe_ILF_make_a_section (& vars, ".idata$4", SIZEOF_IDATA4, 0);
  id5 = pe_ILF_make_a_section (& vars, ".idata$5", SIZEOF_IDATA5, 0);
  if (id4 == NULL || id5 == NULL)
    goto error_return;

  /* Fill in the contents of these sections.  */
  if (import_name_type == IMPORT_ORDINAL)
    {
      if (ordinal == 0)
	/* XXX - treat as IMPORT_NAME ??? */
	abort ();

#ifdef COFF_WITH_pex64
      ((unsigned int *) id4->contents)[0] = ordinal;
      ((unsigned int *) id4->contents)[1] = 0x80000000;
      ((unsigned int *) id5->contents)[0] = ordinal;
      ((unsigned int *) id5->contents)[1] = 0x80000000;
#else
      * (unsigned int *) id4->contents = ordinal | 0x80000000;
      * (unsigned int *) id5->contents = ordinal | 0x80000000;
#endif
    }
  else
    {
      char * symbol;
      unsigned int len;

      /* Create .idata$6 - the Hint Name Table.  */
      id6 = pe_ILF_make_a_section (& vars, ".idata$6", SIZEOF_IDATA6, 0);
      if (id6 == NULL)
	goto error_return;

      /* If necessary, trim the import symbol name.  */
      symbol = symbol_name;

      /* As used by MS compiler, '_', '@@', and '?' are alternative
	 forms of USER_LABEL_PREFIX, with '?' for c++ mangled names,
	 '@@' used for fastcall (in C),  '_' everywhere else.  Only one
	 of these is used for a symbol.  We strip this leading char for
	 IMPORT_NAME_NOPREFIX and IMPORT_NAME_UNDECORATE as per the
	 PE COFF 6.0 spec (section 8.3, Import Name Type).  */

      if (import_name_type != IMPORT_NAME)
	{
	  char c = symbol[0];

	  /* Check that we don't remove for targets with empty
	     USER_LABEL_PREFIX the leading underscore.  */
	  if ((c == '_' && abfd->xvec->symbol_leading_char != 0)
	      || c == '@@' || c == '?')
	    symbol++;
	}

      len = strlen (symbol);
      if (import_name_type == IMPORT_NAME_UNDECORATE)
	{
	  /* Truncate at the first '@@'.  */
	  char *at = strchr (symbol, '@@');

	  if (at != NULL)
	    len = at - symbol;
	}

      id6->contents[0] = ordinal & 0xff;
      id6->contents[1] = ordinal >> 8;

      memcpy ((char *) id6->contents + 2, symbol, len);
      id6->contents[len + 2] = '\0';
    }

  if (import_name_type != IMPORT_ORDINAL)
    {
      pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (&vars, id4);

      pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (&vars, id5);
    }

  /* Create extra sections depending upon the type of import we are dealing with.  */
  switch (import_type)
    {
      int i;

    case IMPORT_CODE:
      /* Create a .text section.
	 First we need to look up its contents in the jump table.  */
      for (i = NUM_ENTRIES (jtab); i--;)
	{
	  if (jtab[i].size == 0)
	    continue;
	  if (jtab[i].magic == magic)
	    break;
	}
      /* If we did not find a matching entry something is wrong.  */
      if (i < 0)
	abort ();

      /* Create the .text section.  */
      text = pe_ILF_make_a_section (& vars, ".text", jtab[i].size, SEC_CODE);
      if (text == NULL)
	goto error_return;

      /* Copy in the jump code.  */
      memcpy (text->contents, jtab[i].data, jtab[i].size);

      /* Create an import symbol.  */
      pe_ILF_make_a_symbol (& vars, "__imp_", symbol_name, id5, 0);
      imp_sym   = vars.sym_ptr_ptr - 1;
      imp_index = vars.sym_index - 1;

      /* Create a reloc for the data in the text section.  */
#ifdef MIPS_ARCH_MAGIC_WINCE
      if (magic == MIPS_ARCH_MAGIC_WINCE)
	{
	  pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) 0, BFD_RELOC_HI16_S,
				      (struct bfd_symbol **) imp_sym,
				      imp_index);
	  pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_LO16, text);
	  pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) 4, BFD_RELOC_LO16,
				      (struct bfd_symbol **) imp_sym,
				      imp_index);
	}
      else
#endif
	pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) jtab[i].offset,
				    BFD_RELOC_32, (asymbol **) imp_sym,
				    imp_index);

      pe_ILF_save_relocs (& vars, text);
      break;

    case IMPORT_DATA:
      break;

    default:
      /* XXX code not yet written.  */
      abort ();
    }

  /* Initialise the bfd.  */
  memset (& internal_f, 0, sizeof (internal_f));

  internal_f.f_magic  = magic;
  internal_f.f_symptr = 0;
  internal_f.f_nsyms  = 0;
  internal_f.f_flags  = F_AR32WR | F_LNNO; /* XXX is this correct ?  */

  if (   ! bfd_set_start_address (abfd, (bfd_vma) 0)
      || ! bfd_coff_set_arch_mach_hook (abfd, & internal_f))
    goto error_return;

  if (bfd_coff_mkobject_hook (abfd, (void *) & internal_f, NULL) == NULL)
    goto error_return;

  coff_data (abfd)->pe = 1;
#ifdef THUMBPEMAGIC
  if (vars.magic == THUMBPEMAGIC)
    /* Stop some linker warnings about thumb code not supporting interworking.  */
    coff_data (abfd)->flags |= F_INTERWORK | F_INTERWORK_SET;
#endif

  /* Switch from file contents to memory contents.  */
  bfd_cache_close (abfd);

  abfd->iostream = (void *) vars.bim;
  abfd->flags |= BFD_IN_MEMORY /* | HAS_LOCALS */;
  abfd->iovec = &_bfd_memory_iovec;
  abfd->where = 0;
  abfd->origin = 0;
  obj_sym_filepos (abfd) = 0;

  /* Now create a symbol describing the imported value.  */
  switch (import_type)
    {
    case IMPORT_CODE:
      pe_ILF_make_a_symbol (& vars, "", symbol_name, text,
			    BSF_NOT_AT_END | BSF_FUNCTION);

      /* Create an import symbol for the DLL, without the
       .dll suffix.  */
      ptr = (bfd_byte *) strrchr (source_dll, '.');
      if (ptr)
	* ptr = 0;
      pe_ILF_make_a_symbol (& vars, "__IMPORT_DESCRIPTOR_", source_dll, NULL, 0);
      if (ptr)
	* ptr = '.';
      break;

    case IMPORT_DATA:
      /* Nothing to do here.  */
      break;

    default:
      /* XXX code not yet written.  */
      abort ();
    }

  /* Point the bfd at the symbol table.  */
  obj_symbols (abfd) = vars.sym_cache;
  bfd_get_symcount (abfd) = vars.sym_index;

  obj_raw_syments (abfd) = vars.native_syms;
  obj_raw_syment_count (abfd) = vars.sym_index;

  obj_coff_external_syms (abfd) = (void *) vars.esym_table;
  obj_coff_keep_syms (abfd) = TRUE;

  obj_convert (abfd) = vars.sym_table;
  obj_conv_table_size (abfd) = vars.sym_index;

  obj_coff_strings (abfd) = vars.string_table;
  obj_coff_keep_strings (abfd) = TRUE;

  abfd->flags |= HAS_SYMS;

  return TRUE;

 error_return:
  if (vars.bim->buffer != NULL)
    free (vars.bim->buffer);
  free (vars.bim);
  return FALSE;
}

/* We have detected a Image Library Format archive element.
   Decode the element and return the appropriate target.  */

static const bfd_target *
pe_ILF_object_p (bfd * abfd)
{
  bfd_byte        buffer[16];
  bfd_byte *      ptr;
  char *          symbol_name;
  char *          source_dll;
  unsigned int    machine;
  bfd_size_type   size;
  unsigned int    ordinal;
  unsigned int    types;
  unsigned int    magic;

  /* Upon entry the first four buyes of the ILF header have
      already been read.  Now read the rest of the header.  */
  if (bfd_bread (buffer, (bfd_size_type) 16, abfd) != 16)
    return NULL;

  ptr = buffer;

  /*  We do not bother to check the version number.
      version = H_GET_16 (abfd, ptr);  */
  ptr += 2;

  machine = H_GET_16 (abfd, ptr);
  ptr += 2;

  /* Check that the machine type is recognised.  */
  magic = 0;

  switch (machine)
    {
    case IMAGE_FILE_MACHINE_UNKNOWN:
    case IMAGE_FILE_MACHINE_ALPHA:
    case IMAGE_FILE_MACHINE_ALPHA64:
    case IMAGE_FILE_MACHINE_IA64:
      break;

    case IMAGE_FILE_MACHINE_I386:
#ifdef I386MAGIC
      magic = I386MAGIC;
#endif
      break;

    case IMAGE_FILE_MACHINE_AMD64:
#ifdef AMD64MAGIC
      magic = AMD64MAGIC;
#endif
      break;

    case IMAGE_FILE_MACHINE_M68K:
#ifdef MC68AGIC
      magic = MC68MAGIC;
#endif
      break;

    case IMAGE_FILE_MACHINE_R3000:
    case IMAGE_FILE_MACHINE_R4000:
    case IMAGE_FILE_MACHINE_R10000:

    case IMAGE_FILE_MACHINE_MIPS16:
    case IMAGE_FILE_MACHINE_MIPSFPU:
    case IMAGE_FILE_MACHINE_MIPSFPU16:
#ifdef MIPS_ARCH_MAGIC_WINCE
      magic = MIPS_ARCH_MAGIC_WINCE;
#endif
      break;

    case IMAGE_FILE_MACHINE_SH3:
    case IMAGE_FILE_MACHINE_SH4:
#ifdef SH_ARCH_MAGIC_WINCE
      magic = SH_ARCH_MAGIC_WINCE;
#endif
      break;

    case IMAGE_FILE_MACHINE_ARM:
#ifdef ARMPEMAGIC
      magic = ARMPEMAGIC;
#endif
      break;

    case IMAGE_FILE_MACHINE_THUMB:
#ifdef THUMBPEMAGIC
      {
	extern const bfd_target TARGET_LITTLE_SYM;

	if (abfd->xvec == & TARGET_LITTLE_SYM)
	  magic = THUMBPEMAGIC;
      }
#endif
      break;

    case IMAGE_FILE_MACHINE_POWERPC:
      /* We no longer support PowerPC.  */
    default:
      _bfd_error_handler
	(_("%B: Unrecognised machine type (0x%x)"
	   " in Import Library Format archive"),
	 abfd, machine);
      bfd_set_error (bfd_error_malformed_archive);

      return NULL;
      break;
    }

  if (magic == 0)
    {
      _bfd_error_handler
	(_("%B: Recognised but unhandled machine type (0x%x)"
	   " in Import Library Format archive"),
	 abfd, machine);
      bfd_set_error (bfd_error_wrong_format);

      return NULL;
    }

  /* We do not bother to check the date.
     date = H_GET_32 (abfd, ptr);  */
  ptr += 4;

  size = H_GET_32 (abfd, ptr);
  ptr += 4;

  if (size == 0)
    {
      _bfd_error_handler
	(_("%B: size field is zero in Import Library Format header"), abfd);
      bfd_set_error (bfd_error_malformed_archive);

      return NULL;
    }

  ordinal = H_GET_16 (abfd, ptr);
  ptr += 2;

  types = H_GET_16 (abfd, ptr);
  /* ptr += 2; */

  /* Now read in the two strings that follow.  */
  ptr = (bfd_byte *) bfd_alloc (abfd, size);
  if (ptr == NULL)
    return NULL;

  if (bfd_bread (ptr, size, abfd) != size)
    {
      bfd_release (abfd, ptr);
      return NULL;
    }

  symbol_name = (char *) ptr;
  source_dll  = symbol_name + strlen (symbol_name) + 1;

  /* Verify that the strings are null terminated.  */
  if (ptr[size - 1] != 0
      || (bfd_size_type) ((bfd_byte *) source_dll - ptr) >= size)
    {
      _bfd_error_handler
	(_("%B: string not null terminated in ILF object file."), abfd);
      bfd_set_error (bfd_error_malformed_archive);
      bfd_release (abfd, ptr);
      return NULL;
    }

  /* Now construct the bfd.  */
  if (! pe_ILF_build_a_bfd (abfd, magic, symbol_name,
			    source_dll, ordinal, types))
    {
      bfd_release (abfd, ptr);
      return NULL;
    }

  return abfd->xvec;
}

static const bfd_target *
pe_bfd_object_p (bfd * abfd)
{
  bfd_byte buffer[4];
  struct external_PEI_DOS_hdr dos_hdr;
  struct external_PEI_IMAGE_hdr image_hdr;
  struct internal_filehdr internal_f;
  struct internal_aouthdr internal_a;
  file_ptr opt_hdr_size;
  file_ptr offset;

  /* Detect if this a Microsoft Import Library Format element.  */
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bread (buffer, (bfd_size_type) 4, abfd) != 4)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  if (H_GET_32 (abfd, buffer) == 0xffff0000)
    return pe_ILF_object_p (abfd);

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || bfd_bread (&dos_hdr, (bfd_size_type) sizeof (dos_hdr), abfd)
	 != sizeof (dos_hdr))
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* There are really two magic numbers involved; the magic number
     that says this is a NT executable (PEI) and the magic number that
     determines the architecture.  The former is DOSMAGIC, stored in
     the e_magic field.  The latter is stored in the f_magic field.
     If the NT magic number isn't valid, the architecture magic number
     could be mimicked by some other field (specifically, the number
     of relocs in section 3).  Since this routine can only be called
     correctly for a PEI file, check the e_magic number here, and, if
     it doesn't match, clobber the f_magic number so that we don't get
     a false match.  */
  if (H_GET_16 (abfd, dos_hdr.e_magic) != DOSMAGIC)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  offset = H_GET_32 (abfd, dos_hdr.e_lfanew);
  if (bfd_seek (abfd, offset, SEEK_SET) != 0
      || (bfd_bread (&image_hdr, (bfd_size_type) sizeof (image_hdr), abfd)
	  != sizeof (image_hdr)))
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  if (H_GET_32 (abfd, image_hdr.nt_signature) != 0x4550)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Swap file header, so that we get the location for calling
     real_object_p.  */
  bfd_coff_swap_filehdr_in (abfd, (PTR)&image_hdr, &internal_f);

  if (! bfd_coff_bad_format_hook (abfd, &internal_f)
      || internal_f.f_opthdr > bfd_coff_aoutsz (abfd))
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* Read the optional header, which has variable size.  */
  opt_hdr_size = internal_f.f_opthdr;

  if (opt_hdr_size != 0)
    {
      PTR opthdr;

      opthdr = bfd_alloc (abfd, opt_hdr_size);
      if (opthdr == NULL)
	return NULL;
      if (bfd_bread (opthdr, opt_hdr_size, abfd)
	  != (bfd_size_type) opt_hdr_size)
	return NULL;

      bfd_coff_swap_aouthdr_in (abfd, opthdr, (PTR) & internal_a);
    }

  return coff_real_object_p (abfd, internal_f.f_nscns, &internal_f,
                            (opt_hdr_size != 0
                             ? &internal_a
                             : (struct internal_aouthdr *) NULL));
}

#define coff_object_p pe_bfd_object_p
#endif /* COFF_IMAGE_WITH_PE */
@


1.66
log
@	* coffgen.c (coff_real_object_p): Make global.
	* peicode.h (coff_real_object_p): Add prototype.
	(FILHDR): Defined for COFF_IMAGE_WITH_PE as
	external_PEI_IMAGE_hdr structure.
	(coff_swap_filehdr_in): Handle variable header-size.
	* peXXigen.c (_bfd_XXi_swap_aouthdr_in): Just handle amount
	of directory-entiries as specified in pe-header.
@
text
@d2 1
a2 3
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
d611 1
a611 1
  bfd_set_section_alignment (vars->abfd, sec, 2);
@


1.65
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d126 3
d165 5
d1259 3
d1317 6
a1322 4
  /* Here is the hack.  coff_object_p wants to read filhsz bytes to
     pick up the COFF header for PE, see "struct external_PEI_filehdr"
     in include/coff/pe.h.  We adjust so that that will work. */
  if (bfd_seek (abfd, (file_ptr) (offset - sizeof (dos_hdr)), SEEK_SET) != 0)
d1324 1
a1324 2
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
d1328 21
a1348 1
  return coff_object_p (abfd);
@


1.64
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d152 1
a152 1
#ifdef SWAP_OUT_RELOC_OFFSET 
d353 1
a353 1
      
d888 1
a888 1
	  
d895 1
a895 1
      
@


1.63
log
@2011-09-09  Kai Tietz  <ktietz@@redhat.com>

        * peicode.h (pe_ILF_build_a_bfd): Don't remove leading underscore
        for targets without symbol_leading_char.
@
text
@d3 2
a4 1
   2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
d549 1
a549 1
    section = (asection_ptr) & bfd_und_section;
@


1.62
log
@2010-05-25  Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c: Declare and define _bfd_memory_iovec.
	(bfd_bread): Move code for BFD_IN_MEMORY...
	(bfd_bwrite): ... Ditto ...
	(bfd_tell): ... Ditto ...
	(bfd_flush): ... Ditto ...
	(bfd_stat): ... Ditto ...
	(bfd_seek): ... Ditto ...
	(bfd_get_size): ... Ditto ...
	(bfd_mmap): ... Ditto ...
	(memory_bread): ... to these new functions.
	(memory_bwrite): Ditto.
	(memory_btell): Ditto.
	(memory_bseek): Ditto.
	(memory_bflush): Ditto.
	(memory_bstat): Ditto.
	(memory_bmmap): Ditto.
	(memory_bclose): New function.
	* peicode.h (pe_ILF_build_a_bfd): Use BFD_IN_MEMORY.
	* xcofflink.c (bfd_xcoff_link_generate_rtinit): Ditto.
	* opncls.c (bfd_close): Do not handle BFD_IN_MEMORY case.
	(bfd_make_writable): Use _bfd_memory_iovec.
	* elfcode.h (bfd_from_remote_memory): Use _bfd_memory_iovec.
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Use
	_bfd_memory_iovec.
	(alpha_ecoff_openr_next_archived_file): Use proxy_origin
	instead of origin.
	* libbfd.h: Regenerate.
@
text
@d887 5
a891 1
	  if (c == '_' || c == '@@' || c == '?')
@


1.61
log
@	PR binutils/10785
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Don't bfd_alloc
	bim and bim->buffer.  bfd_malloc instead.
	* peicode.h (pe_ILF_build_a_bfd): Similarly.
	(ILF_DATA_SIZE): Don't include bim.
	* opncls.c (bfd_close): Test bim->buffer non-NULL before freeing.
@
text
@d1005 1
d1007 1
@


1.60
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@a424 1
      sizeof (* vars.bim)			\
d782 3
a784 2
  ptr = (bfd_byte *) bfd_zalloc (abfd, (bfd_size_type) ILF_DATA_SIZE);
  if (ptr == NULL)
d787 1
a787 2
  /* Create a bfd_in_memory structure.  */
  vars.bim = (struct bfd_in_memory *) ptr;
d790 2
a791 1
  ptr += sizeof (* vars.bim);
d845 1
a845 1
    return FALSE;
d872 1
a872 1
	return FALSE;
d939 1
a939 1
	return FALSE;
d988 1
a988 1
    return FALSE;
d991 1
a991 1
    return FALSE;
d1053 6
@


1.59
log
@update copyright dates
@
text
@d783 1
a783 1
  ptr = bfd_zalloc (abfd, (bfd_size_type) ILF_DATA_SIZE);
d1197 1
a1197 1
  ptr = bfd_alloc (abfd, size);
@


1.59.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d783 1
a783 1
  ptr = (bfd_byte *) bfd_zalloc (abfd, (bfd_size_type) ILF_DATA_SIZE);
d1197 1
a1197 1
  ptr = (bfd_byte *) bfd_alloc (abfd, size);
@


1.59.2.2
log
@2009-10-16  Alan Modra  <amodra@@bigpond.net.au>

	PR binutils/10785
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Don't bfd_alloc
	bim and bim->buffer.  bfd_malloc instead.
	* peicode.h (pe_ILF_build_a_bfd): Similarly.
	(ILF_DATA_SIZE): Don't include bim.
	* opncls.c (bfd_close): Test bim->buffer non-NULL before freeing.
@
text
@d425 1
d783 2
a784 3
  vars.bim
    = (struct bfd_in_memory *) bfd_malloc ((bfd_size_type) sizeof (*vars.bim));
  if (vars.bim == NULL)
d787 2
a788 1
  ptr = (bfd_byte *) bfd_zmalloc ((bfd_size_type) ILF_DATA_SIZE);
d791 1
a791 2
  if (ptr == NULL)
    goto error_return;
d845 1
a845 1
    goto error_return;
d872 1
a872 1
	goto error_return;
d939 1
a939 1
	goto error_return;
d988 1
a988 1
    goto error_return;
d991 1
a991 1
    goto error_return;
a1052 6

 error_return:
  if (vars.bim->buffer != NULL)
    free (vars.bim->buffer);
  free (vars.bim);
  return FALSE;
@


1.58
log
@2009-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* coff-ia64.c (COFF_PAGE_SIZE): Changed to 8K.

	* coffcode.h (coff_compute_section_file_positions): Clear
	D_PAGED if PE section alignment is smaller than COFF_PAGE_SIZE.

	* libcoff-in.h (pe_tdata): Remove force_minimum_alignment and
	force_minimum_alignment.

	* libcoff.h: Regenerated.

	* pei-ia64.c (PEI_TARGET_SUBSYSTEM): Removed.
	(PEI_FORCE_MINIMUM_ALIGNMENT): Likewise.

	* peicode.h (pe_mkobject): Don't set force_minimum_alignment
	nor target_subsystem.

	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Don't check
	force_minimum_alignment nor target_subsystem.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008  Free Software Foundation, Inc.
@


1.57
log
@bfd/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10074
	* coffcode.h (bfd_pei_p): New.

	* config.bfd: Remove bfd_efi_bsdrv_ia32_vec,
	bfd_efi_rtdrv_ia32_vec, bfd_efi_bsdrv_x86_64_vec,
	bfd_efi_rtdrv_x86_64_vec, bfd_efi_bsdrv_ia64_vec and
	bfd_efi_rtdrv_ia64_vec.  Replace bfd_efi_app_ia32_vec,
	bfd_efi_app_x86_64_vec and bfd_efi_app_ia64_vec with
	i386pei_vec, x86_64pei_vec and bfd_pei_ia64_vec, respectively.

	* configure.in: Remove bfd_efi_bsdrv_ia32_vec,
	bfd_efi_rtdrv_ia32_vec, bfd_efi_bsdrv_x86_64_vec,
	bfd_efi_rtdrv_x86_64_vec,
	bfd_efi_bsdrv_ia64_vec and bfd_efi_rtdrv_ia64_vec.  Replace
	bfd_efi_ia64_vec with bfd_pei_ia64_vec.
	* targets.c: Likewise.

	* configure: Regenerated.
	* libcoff.h: Likewise.
	* Makefile.in: Likewise.

	* efi-app-ia32.c: Removed.
	* efi-app-x86_64.c: Likewise.
	* efi-bsdrv-ia32.c: Likewise.
	* efi-bsdrv-ia64.c: Likewise.
	* efi-bsdrv-x86_64.c: Likewise.
	* efi-rtdrv-ia32.c: Likewise.
	* efi-rtdrv-ia64.c: Likewise.
	* efi-rtdrv-x86_64.c: Likewise.
	* efi-rtdrv-ia32.c: Likewise.

	* efi-app-ia64.c: Moved to ...
	* pei-ia64.c: This.
	(TARGET_SYM): Set to bfd_pei_ia64_vec.
	(TARGET_NAME): Set to pei-ia64.

	* libpei.h (bfd_target_pei_p): Removed.
	(bfd_target_pei_arch): Likewise.
	(bfd_target_efi_app_p): Likewise.
	(bfd_target_efi_app_arch): Likewise.
	(bfd_target_efi_bsdrv_p): Likewise.
	(bfd_target_efi_bsdrv_arch): Likewise.
	(bfd_target_efi_rtdrv_p): Likewise.
	(bfd_target_efi_rtdrv_arch): Likewise.
	(bfd_pe_executable_p): Likewise.

	* Makefile.am (BFD32_BACKENDS): Remove efi-app-ia32.lo,
	efi-bsdrv-ia32.lo and efi-rtdrv-ia32.lo.
	(BFD32_BACKENDS_CFILES): Remove efi-app-ia32.c, efi-bsdrv-ia32.c
	and efi-rtdrv-ia32.c.
	(BFD64_BACKENDS): Remove efi-app-ia64.lo, efi-bsdrv-ia64.lo,
	efi-rtdrv-ia64.lo, efi-app-x86_64.lo, efi-bsdrv-x86_64.lo and
	efi-rtdrv-x86_64.lo. Add pei-ia64.lo.
	(BFD64_BACKENDS_CFILES): Remove efi-app-ia64.c, efi-bsdrv-ia64.c,
	efi-rtdrv-ia64.c, efi-app-x86_64.c, efi-bsdrv-x86_64.c and
	efi-rtdrv-x86_64.c. Add pei-ia64.c.
	(efi-app-ia64.lo): Removed.
	(efi-bsdrv-ia32.lo): Likewise.
	(efi-rtdrv-ia32.lo): Likewise.
	(efi-app-ia64.lo): Likewise.
	(efi-bsdrv-ia64.lo): Likewise.
	(efi-rtdrv-ia64.lo): Likewise.
	(efi-app-x86_64.lo): Likewise.
	(efi-bsdrv-x86_64.lo): Likewise.
	(efi-rtdrv-x86_64.lo): Likewise.
	(pei-ia64.lo): New.

	* peicode.h (coff_swap_scnhdr_in): Replace bfd_pe_executable_p
	with bfd_pei_p.
	(arch_type): Removed.
	(pe_arch): Likewise.
	(pe_bfd_object_p): Just return coff_object_p.

	* peXXigen.c (_bfd_XXi_swap_scnhdr_out): Replace
	bfd_pe_executable_p with bfd_pei_p.

binutils/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10074
	* objcopy.c: Include coff/i386.h and coff/pe.h.
	(pe_file_alignment): New.
	(pe_heap_commit): Likewise.
	(pe_heap_reserve): Likewise.
	(pe_image_base): Likewise.
	(pe_section_alignment): Likewise.
	(pe_stack_commit): Likewise.
	(pe_stack_reserve): Likewise.
	(pe_subsystem): Likewise.
	(pe_major_subsystem_version): Likewise.
	(pe_minor_subsystem_version): Likewise.
	(set_pe_subsystem): Likewise.
	(convert_efi_target): Likewise.
	(command_line_switch): Add OPTION_FILE_ALIGNMENT,
	OPTION_HEAP, OPTION_IMAGE_BASE, OPTION_SECTION_ALIGNMENT,
	OPTION_STACK and OPTION_SUBSYSTEM.
	(copy_options): Likewise.
	(copy_usage): Add --file-alignment, --heap, --image-base,
	--section-alignment, --stack and --subsystem.
	(copy_object): Set up PE parameters.
	(copy_main): Process Add OPTION_FILE_ALIGNMENT,
	OPTION_HEAP, OPTION_IMAGE_BASE, OPTION_SECTION_ALIGNMENT,
	OPTION_STACK and OPTION_SUBSYSTEM.   Convert EFI target to
	PEI target.

	* NEWS: Mention --file-alignment, --heap, --image-base,
	--section-alignment, --stack and --subsystem command line
	options for objcopy.

	* doc/binutils.texi: Document --file-alignment, --heap,
	--image-base, --section-alignment, --stack and --subsystem
	command line options for objcopy.
@
text
@a266 7
#ifdef PEI_FORCE_MINIMUM_ALIGNMENT
  pe->force_minimum_alignment = 1;
#endif
#ifdef PEI_TARGET_SUBSYSTEM
  pe->target_subsystem = PEI_TARGET_SUBSYSTEM;
#endif

@


1.56
log
@        * efi-rtdrv-ia32.c: New file.
        * efi-bsdrv-ia32.c: New file.
        * efi-rtdrv-ia64.c: New file.
        * efi-bsdrv-ia64.c: New file.
        * efi-rtdrv-x86_64.c: New file.
        * efi-bsdrv-x86_64.c: New file.
        * peicode.h (pe_bfd_object_p): Add support for boot service and
        runtime service drivers.
        * libpei.h: Add macros for EFI formats, and rename the efi application
        format macros to disambiguate.
        * targets.c: Add bfd_target _vec externs.
        (_bfd_tar): Add EFI _vec entries.
        * config.bfd: Add EFI vectors into the selection routines.
        * configure.in: add EFI _vec entries.
        * configure: Regenerate.
        * Makefile.am: Add EFI files.
        * Makefile.in: Regenerate.
@
text
@d239 2
a240 2
	   && (! bfd_pe_executable_p (abfd) || scnhdr_int->s_size == 0))
          || (bfd_pe_executable_p (abfd) && (scnhdr_int->s_size > scnhdr_int->s_paddr))))
a1238 19
enum arch_type
{
  arch_type_unknown,
  arch_type_i386,
  arch_type_x86_64
};

static enum arch_type
pe_arch (const char *arch)
{
  if (strcmp (arch, "i386") == 0 || strcmp (arch, "ia32") == 0)
    return arch_type_i386;

  if (strcmp (arch, "x86_64") == 0 || strcmp (arch, "x86-64") == 0)
    return arch_type_x86_64;

  return arch_type_unknown;
}

a1245 2
  const bfd_target *target;
  struct bfd_preserve preserve;
d1310 1
a1310 104
  preserve.marker = NULL;
  if (! bfd_preserve_save (abfd, &preserve))
    return NULL;

  target = coff_object_p (abfd);
  if (target)
    {
      pe_data_type *pe = pe_data (abfd);
      struct internal_extra_pe_aouthdr *i = &pe->pe_opthdr;
      bfd_boolean efi = i->Subsystem == IMAGE_SUBSYSTEM_EFI_APPLICATION
                     || i->Subsystem == IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER
                     || i->Subsystem == IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER;
      enum arch_type arch;
      const bfd_target * const *target_ptr;

      /* Get the machine.  */
      if (bfd_target_efi_app_p (abfd->xvec))
	arch = pe_arch (bfd_target_efi_app_arch (abfd->xvec));
      else if (bfd_target_efi_bsdrv_p (abfd->xvec))
        arch = pe_arch (bfd_target_efi_bsdrv_arch (abfd->xvec));
      else if (bfd_target_efi_rtdrv_p (abfd->xvec))
        arch = pe_arch (bfd_target_efi_rtdrv_arch (abfd->xvec));
      else
	arch = pe_arch (bfd_target_pei_arch (abfd->xvec));

      /* Don't check PE vs. EFI if arch is unknown.  */
      if (arch == arch_type_unknown)
	{
	  bfd_preserve_finish (abfd, &preserve);
	  return target;
	}

      for (target_ptr = bfd_target_vector; *target_ptr != NULL;
	   target_ptr++)
	{
	  if (*target_ptr == target
	      || (*target_ptr)->flavour != bfd_target_coff_flavour)
	    continue;

	  if (bfd_target_efi_app_p (*target_ptr))
	    {
	      /* Skip incompatible arch.  */
	      if (pe_arch (bfd_target_efi_app_arch (*target_ptr)) != arch)
		continue;

	      if (efi)
		{
		  /* TARGET_PTR is an EFI backend.  Don't match
		     TARGET with a EFI file.  */
		  bfd_set_error (bfd_error_wrong_format);
		  return NULL;
		}
	    }
          else if (bfd_target_efi_bsdrv_p (*target_ptr))
	    {
	      /* Skip incompatible arch.  */
	      if (pe_arch (bfd_target_efi_bsdrv_arch (*target_ptr)) != arch)
		continue;

	      if (efi)
		{
		  /* TARGET_PTR is an EFI backend.  Don't match
		     TARGET with a EFI file.  */
		  bfd_set_error (bfd_error_wrong_format);
		  return NULL;
		}
	    }
          else if (bfd_target_efi_rtdrv_p (*target_ptr))
	    {
	      /* Skip incompatible arch.  */
	      if (pe_arch (bfd_target_efi_rtdrv_arch (*target_ptr)) != arch)
		continue;

	      if (efi)
		{
no_match:
		  /* TARGET_PTR is an EFI backend.  Don't match
		     TARGET with a EFI file.  */
		  bfd_preserve_restore (abfd, &preserve);
		  bfd_set_error (bfd_error_wrong_format);
		  return NULL;
		}
	    }
	  else if (bfd_target_pei_p (*target_ptr))
	    {
	      /* Skip incompatible arch.  */
	      if (pe_arch (bfd_target_pei_arch (*target_ptr)) != arch)
		continue;

	      if (!efi)
		{
		  /* TARGET_PTR is a PE backend.  Don't match
		     TARGET with a PE file.  */
		  goto no_match;
		}
	    }
	}

      bfd_preserve_finish (abfd, &preserve);
    }
  else
    bfd_preserve_restore (abfd, &preserve);

  return target;
@


1.55
log
@2007-11-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/5299
	* peicode.h (pe_bfd_object_p): Save and restore previous bfd
	state when calling coff_object_p.
@
text
@d3 1
a3 1
   2005, 2006, 2007 Free Software Foundation, Inc.
d240 1
a240 1
          || (bfd_pe_executable_p (abfd) && scnhdr_int->s_size > scnhdr_int->s_paddr)))
d1340 3
a1342 1
      bfd_boolean efi = i->Subsystem == IMAGE_SUBSYSTEM_EFI_APPLICATION;
d1347 6
a1352 2
      if (bfd_target_efi_p (abfd->xvec))
	arch = pe_arch (bfd_target_efi_arch (abfd->xvec));
d1370 1
a1370 1
	  if (bfd_target_efi_p (*target_ptr))
d1373 29
a1401 1
	      if (pe_arch (bfd_target_efi_arch (*target_ptr)) != arch)
@


1.54
log
@Add support for building on a 64-bit Windows host.
@
text
@d1266 1
d1331 4
d1352 4
a1355 1
	return target;
d1372 1
d1375 1
d1390 1
a1390 2
		  bfd_set_error (bfd_error_wrong_format);
		  return NULL;
d1394 2
d1397 2
@


1.53
log
@2007-07-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* peicode.h (pe_bfd_object_p): Don't check PE vs. EFI target
	if arch is unknown.
@
text
@d570 1
a570 1
  ent->u.syment._n._n_n._n_offset = (long) sym;
@


1.52
log
@Switch sources over to use the GPL version 3
@
text
@d1345 4
d1362 7
a1368 7
		if (efi)
		  {
		    /* TARGET_PTR is an EFI backend.  Don't match
		       TARGET with a EFI file.  */
		    bfd_set_error (bfd_error_wrong_format);
		    return NULL;
		  }
d1376 7
a1382 7
		if (!efi)
		  {
		    /* TARGET_PTR is a PE backend.  Don't match
		       TARGET with a PE file.  */
		    bfd_set_error (bfd_error_wrong_format);
		    return NULL;
		  }
@


1.51
log
@2007-06-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* libpei.h (_bfd_XXi_final_link_postscript): Remove
	duplication.
	(bfd_target_pei_p): New.
	(bfd_target_pei_arch): New
	(bfd_target_efi_p): Likewise.
	(bfd_target_efi_arch): New
	(bfd_pe_executable_p): Use bfd_target_pei_p and
	bfd_target_efi_p.

	* peicode.h (arch_type): New enum.
	(pe_arch): New function.
	(pe_bfd_object_p): Don't match PE/EFI target with EFI/PE file
	if there is an EFI/PE target.
@
text
@d3 1
a3 1
   2005, 2006 Free Software Foundation, Inc.
d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 3
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.50
log
@Add x86_64-mingw64 target
@
text
@d1237 19
d1263 1
d1328 54
a1381 1
  return coff_object_p (abfd);
@


1.49
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 1
a3 1
   2005 Free Software Foundation, Inc.
d185 4
d224 2
d227 1
d415 6
d423 2
d674 7
d682 4
a685 1
  { MC68MAGIC, { /* XXX fill me in */ }, 0, 0 },
d687 1
d859 6
d867 1
d1107 6
@


1.48
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.47
log
@Update to ISO-C90 and fix formatting
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.46
log
@	* peicode.h (pe_ILF_build_a_bfd): Strip only one prefix
	character in IMPORT_NAME_UNDECORATE and IMPORT_NAME_NOPREFIX
	cases.  Add comment.
@
text
@d58 1
a58 2
static bfd_boolean (*pe_saved_coff_bfd_print_private_bfd_data)
    PARAMS ((bfd *, PTR)) =
d66 1
a66 1
static bfd_boolean pe_print_private_bfd_data PARAMS ((bfd *, PTR));
d69 1
a69 2
static bfd_boolean (*pe_saved_coff_bfd_copy_private_bfd_data)
    PARAMS ((bfd *, bfd *)) =
d77 1
a77 1
static bfd_boolean pe_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
a82 9
#ifndef NO_COFF_RELOCS
static void coff_swap_reloc_in PARAMS ((bfd *, PTR, PTR));
static unsigned int coff_swap_reloc_out PARAMS ((bfd *, PTR, PTR));
#endif
static void coff_swap_filehdr_in PARAMS ((bfd *, PTR, PTR));
static void coff_swap_scnhdr_in PARAMS ((bfd *, PTR, PTR));
static bfd_boolean pe_mkobject PARAMS ((bfd *));
static PTR pe_mkobject_hook PARAMS ((bfd *, PTR, PTR));

d123 1
a123 3

/**********************************************************************/

d126 1
a126 4
coff_swap_reloc_in (abfd, src, dst)
     bfd *abfd;
     PTR src;
     PTR dst;
d131 1
a131 1
  reloc_dst->r_vaddr = H_GET_32 (abfd, reloc_src->r_vaddr);
d133 1
a133 3

  reloc_dst->r_type = H_GET_16 (abfd, reloc_src->r_type);

d140 1
a140 4
coff_swap_reloc_out (abfd, src, dst)
     bfd       *abfd;
     PTR	src;
     PTR	dst;
d142 3
a144 2
  struct internal_reloc *reloc_src = (struct internal_reloc *)src;
  struct external_reloc *reloc_dst = (struct external_reloc *)dst;
a146 1

d149 1
a149 1
#ifdef SWAP_OUT_RELOC_OFFSET
d153 1
a153 1
  SWAP_OUT_RELOC_EXTRA(abfd, reloc_src, reloc_dst);
d160 1
a160 4
coff_swap_filehdr_in (abfd, src, dst)
     bfd            *abfd;
     PTR	     src;
     PTR	     dst;
a163 3
  filehdr_dst->f_magic = H_GET_16 (abfd, filehdr_src->f_magic);
  filehdr_dst->f_nscns = H_GET_16 (abfd, filehdr_src-> f_nscns);
  filehdr_dst->f_timdat = H_GET_32 (abfd, filehdr_src-> f_timdat);
d165 5
a169 2
  filehdr_dst->f_nsyms = H_GET_32 (abfd, filehdr_src-> f_nsyms);
  filehdr_dst->f_flags = H_GET_16 (abfd, filehdr_src-> f_flags);
d190 1
a190 4
coff_swap_scnhdr_in (abfd, ext, in)
     bfd            *abfd;
     PTR	     ext;
     PTR	     in;
d195 7
a201 6
  memcpy(scnhdr_int->s_name, scnhdr_ext->s_name, sizeof (scnhdr_int->s_name));
  scnhdr_int->s_vaddr = GET_SCNHDR_VADDR (abfd, scnhdr_ext->s_vaddr);
  scnhdr_int->s_paddr = GET_SCNHDR_PADDR (abfd, scnhdr_ext->s_paddr);
  scnhdr_int->s_size = GET_SCNHDR_SIZE (abfd, scnhdr_ext->s_size);
  scnhdr_int->s_scnptr = GET_SCNHDR_SCNPTR (abfd, scnhdr_ext->s_scnptr);
  scnhdr_int->s_relptr = GET_SCNHDR_RELPTR (abfd, scnhdr_ext->s_relptr);
d203 1
a203 1
  scnhdr_int->s_flags = H_GET_32 (abfd, scnhdr_ext->s_flags);
d232 5
a236 8
    {
      scnhdr_int->s_size = scnhdr_int->s_paddr;

      /* This code used to set scnhdr_int->s_paddr to 0.  However,
         coff_set_alignment_hook stores s_paddr in virt_size, which
         only works if it correctly holds the virtual size of the
         section.  */
    }
d241 1
a241 2
pe_mkobject (abfd)
     bfd * abfd;
d269 5
a273 5
static PTR
pe_mkobject_hook (abfd, filehdr, aouthdr)
     bfd * abfd;
     PTR filehdr;
     PTR aouthdr ATTRIBUTE_UNUSED;
d310 1
a310 1
    pe->pe_opthdr = ((struct internal_aouthdr *)aouthdr)->pe;
d318 1
a318 1
  return (PTR) pe;
d322 1
a322 3
pe_print_private_bfd_data (abfd, vfile)
     bfd *abfd;
     PTR vfile;
d329 2
a330 3
  if (pe_saved_coff_bfd_print_private_bfd_data != NULL)
    {
      fputc ('\n', file);
d332 1
a332 2
      return pe_saved_coff_bfd_print_private_bfd_data (abfd, vfile);
    }
d334 1
a334 1
  return TRUE;
d341 1
a341 2
pe_bfd_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
d396 3
a398 3
#define SIZEOF_ILF_SYMS		(NUM_ILF_SYMS * sizeof (* vars.sym_cache))
#define SIZEOF_ILF_SYM_TABLE	(NUM_ILF_SYMS * sizeof (* vars.sym_table))
#define SIZEOF_ILF_NATIVE_SYMS	(NUM_ILF_SYMS * sizeof (* vars.native_syms))
d400 4
a403 4
#define SIZEOF_ILF_EXT_SYMS	(NUM_ILF_SYMS * sizeof (* vars.esym_table))
#define SIZEOF_ILF_RELOCS	(NUM_ILF_RELOCS * sizeof (* vars.reltab))
#define SIZEOF_ILF_INT_RELOCS	(NUM_ILF_RELOCS * sizeof (* vars.int_reltab))
#define SIZEOF_ILF_STRINGS	(strlen (symbol_name) * 2 + 8 \
d433 1
d435 5
a439 5
pe_ILF_make_a_symbol_reloc (pe_ILF_vars *                 vars,
			    bfd_vma                       address,
			    bfd_reloc_code_real_type      reloc,
			    struct bfd_symbol **  sym,
			    unsigned int                  sym_index)
d462 1
d474 1
d499 1
d577 1
d701 1
d962 1
a962 1
  if (bfd_coff_mkobject_hook (abfd, (PTR) & internal_f, NULL) == NULL)
d975 1
a975 1
  abfd->iostream = (PTR) vars.bim;
d1013 1
a1013 1
  obj_coff_external_syms (abfd) = (PTR) vars.esym_table;
d1029 1
@


1.45
log
@(pe_ILF_build_a_bfd): Do not assume that an @@ will be present when
IMPORT_NAME_UNDOECRATE is used.
@
text
@d878 7
d887 3
a889 31
	  bfd_boolean skipped_leading_underscore = FALSE;
	  bfd_boolean skipped_leading_at = FALSE;
	  bfd_boolean skipped_leading_question_mark = FALSE;
	  bfd_boolean check_again;
	  
	  /* Skip any prefix in symbol_name.  */
	  -- symbol;
	  do
	    {
	      check_again = FALSE;
	      ++ symbol;

	      switch (*symbol)
		{
		case '@@':
		  if (! skipped_leading_at)
		    check_again = skipped_leading_at = TRUE;
		  break;
		case '?':
		  if (! skipped_leading_question_mark)
		    check_again = skipped_leading_question_mark = TRUE;
		  break;
		case '_':
		  if (! skipped_leading_underscore)
		    check_again = skipped_leading_underscore = TRUE;
		  break;
		default:
		  break;
		}
	    }
	  while (check_again);
@


1.44
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d868 1
d913 1
d916 2
a917 3
	  /* Truncate at the first '@@'  */
	  while (* symbol != 0 && * symbol != '@@')
	    symbol ++;
d919 2
a920 1
	  * symbol = 0;
d926 2
a927 1
      strcpy ((char *) id6->contents + 2, symbol);
@


1.43
log
@PR binutils/716
* peicode.h (pe_bfd_copy_private_bfd_data): Copy the large address aware flag
from the input bfd to the output bfd.
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
a132 9

static asection_ptr       pe_ILF_make_a_section   PARAMS ((pe_ILF_vars *, const char *, unsigned int, flagword));
static void               pe_ILF_make_a_reloc     PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type, asection_ptr));
static void               pe_ILF_make_a_symbol    PARAMS ((pe_ILF_vars *, const char *, const char *, asection_ptr, flagword));
static void               pe_ILF_save_relocs      PARAMS ((pe_ILF_vars *, asection_ptr));
static void		  pe_ILF_make_a_symbol_reloc  PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type, struct bfd_symbol **, unsigned int));
static bfd_boolean        pe_ILF_build_a_bfd      PARAMS ((bfd *, unsigned int, bfd_byte *, bfd_byte *, unsigned int, unsigned int));
static const bfd_target * pe_ILF_object_p         PARAMS ((bfd *));
static const bfd_target * pe_bfd_object_p 	  PARAMS ((bfd *));
d734 2
a735 2
		    bfd_byte *      symbol_name,
		    bfd_byte *      source_dll,
d831 2
a832 2
  vars.string_table = ptr;
  vars.string_ptr   = ptr + STRING_SIZE_SIZE;
d834 1
a834 1
  vars.end_string_ptr = ptr;
d924 1
a924 1
      strcpy (id6->contents + 2, symbol);
d1036 1
a1036 1
      ptr = strrchr (source_dll, '.');
d1081 2
a1082 2
  bfd_byte *      symbol_name;
  bfd_byte *      source_dll;
d1219 2
a1220 2
  symbol_name = ptr;
  source_dll  = ptr + strlen (ptr) + 1;
d1223 2
a1224 1
  if (ptr[size - 1] != 0 || ((unsigned long) (source_dll - ptr) >= size))
@


1.42
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d387 8
@


1.41
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@a489 5
#if 0  /* These fields do not need to be initialised.  */
  internal->r_size   = 0;
  internal->r_extern = 0;
  internal->r_offset = 0;
#endif
a580 6
#if 0
  esym->e.e.e_zeroes = 0;
  esym->e_value = 0;
  esym->e_type = T_NULL;
  esym->e_numaux = 0;
#endif
a586 8
#if 0 /* See comment above.  */
  ent->u.syment.n_value  = 0;
  ent->u.syment.n_flags  = 0;
  ent->u.syment.n_type   = T_NULL;
  ent->u.syment.n_numaux = 0;
  ent->fix_value         = 0;
#endif

a592 7
#if 0 /* See comment above.  */
  sym->symbol.value   = 0;
  sym->symbol.udata.i = 0;
  sym->done_lineno    = FALSE;
  sym->lineno         = NULL;
#endif

@


1.40
log
@Only skip one instance of each prefix character, if they are present.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d787 2
a788 2
      _bfd_error_handler (_("%s: Unhandled import type; %x"),
			  bfd_archive_filename (abfd), import_type);
d792 2
a793 2
      _bfd_error_handler (_("%s: Unrecognised import type; %x"),
			  bfd_archive_filename (abfd), import_type);
d806 2
a807 2
      _bfd_error_handler (_("%s: Unrecognised import name type; %x"),
			  bfd_archive_filename (abfd), import_name_type);
d1193 3
a1195 3
	(
_("%s: Unrecognised machine type (0x%x) in Import Library Format archive"),
         bfd_archive_filename (abfd), machine);
d1205 3
a1207 3
	(
_("%s: Recognised but unhandled machine type (0x%x) in Import Library Format archive"),
	 bfd_archive_filename (abfd), machine);
d1223 1
a1223 2
	(_("%s: size field is zero in Import Library Format header"),
	 bfd_archive_filename (abfd));
d1253 1
a1253 2
	(_("%s: string not null terminated in ILF object file."),
	 bfd_archive_filename (abfd));
@


1.40.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d787 2
a788 2
      _bfd_error_handler (_("%B: Unhandled import type; %x"),
			  abfd, import_type);
d792 2
a793 2
      _bfd_error_handler (_("%B: Unrecognised import type; %x"),
			  abfd, import_type);
d806 2
a807 2
      _bfd_error_handler (_("%B: Unrecognised import name type; %x"),
			  abfd, import_name_type);
d1193 3
a1195 3
	(_("%B: Unrecognised machine type (0x%x)"
	   " in Import Library Format archive"),
	 abfd, machine);
d1205 3
a1207 3
	(_("%B: Recognised but unhandled machine type (0x%x)"
	   " in Import Library Format archive"),
	 abfd, machine);
d1223 2
a1224 1
	(_("%B: size field is zero in Import Library Format header"), abfd);
d1254 2
a1255 1
	(_("%B: string not null terminated in ILF object file."), abfd);
@


1.39
log
@Index: sim/frv/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* traps.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/d10v/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* simops.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/common/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* sim-trace.c, sim-base.h: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: ld/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* emultempl/pe.em, pe-dll.c: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: bfd/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* syms.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".
	* vms.h, targets.c, section.c, reloc.c, peicode.h: Ditto.
	* mipsbsd.c, elf.c, linker.c, elf-bfd.h, ecoff.c: Ditto.
	* cpu-z8k.c, cpu-ns32k.c, cpu-h8500.c, bfd.c, bfd-in.h: Ditto.
	* bfd-in2.h: Re-generate.
@
text
@d905 12
a916 3
	/* Skip any prefix in symbol_name.  */
	while (*symbol == '@@' || * symbol == '?' || * symbol == '_')
	  ++ symbol;
d918 21
@


1.38
log
@(coff_swap_scnhdr_in): Only remove padding when	processing an executable.
@
text
@d138 1
a138 1
static void		  pe_ILF_make_a_symbol_reloc  PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type, struct symbol_cache_entry **, unsigned int));
d473 1
a473 1
			    struct symbol_cache_entry **  sym,
d970 1
a970 1
				      (struct symbol_cache_entry **) imp_sym,
d974 1
a974 1
				      (struct symbol_cache_entry **) imp_sym,
@


1.37
log
@If a section holds uninitialized data and is from an object file or from an
executable image that has not initialized the s_size field, or if the physical
size is padded, use the virtual size (stored in s_paddr) instead.
@
text
@d261 2
a262 2
     or if the physical size is padded, use the virtual size (stored in
     s_paddr) instead.  */
d265 2
a266 2
          && (! bfd_pe_executable_p (abfd) || scnhdr_int->s_size == 0))
          || scnhdr_int->s_size > scnhdr_int->s_paddr))
@


1.36
log
@(_bfd_XXi_swap_scnhdr_out): Compute ps and ss differently for object files and
  executables.
(coff_swap_scnhdr_in): Only set the s_size field for object files or for
  executables who have not already initialised the field.
(bfd_pe_executable_p): New macro.  Return true if the PE format bfd is an
  executable.
@
text
@d259 8
a266 4
  /* If this section holds uninitialized data, use the virtual size
     (stored in s_paddr) instead of the physical size.  */
  if ((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0
      && (scnhdr_int->s_paddr > 0))
d268 1
a268 4
     /* Always set it for non pe-obj files, and don't overwrite it
        if it's zero for object files.  */
     if (! bfd_pe_executable_p (abfd) || !scnhdr_int->s_size)
       scnhdr_int->s_size = scnhdr_int->s_paddr;
@


1.35
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 1
a22 2
/*
Most of this hacked by  Steve Chamberlain,
d25 2
a26 3
PE/PEI rearrangement (and code added): Donn Terry
                                       Softway Systems, Inc.
*/
d54 1
a54 2
   wasting too much time.
*/
d264 5
a268 1
      scnhdr_int->s_size = scnhdr_int->s_paddr;
@


1.34
log
@	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.
@
text
@d61 1
a61 1
static boolean (*pe_saved_coff_bfd_print_private_bfd_data)
d70 1
a70 1
static boolean pe_print_private_bfd_data PARAMS ((bfd *, PTR));
d73 1
a73 1
static boolean (*pe_saved_coff_bfd_copy_private_bfd_data)
d82 1
a82 1
static boolean pe_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
d94 1
a94 1
static boolean pe_mkobject PARAMS ((bfd *));
d142 1
a142 1
static boolean            pe_ILF_build_a_bfd      PARAMS ((bfd *, unsigned int, bfd_byte *, bfd_byte *, unsigned int, unsigned int));
d276 1
a276 1
static boolean
d286 1
a286 1
    return false;
d302 1
a302 1
  return true;
d358 1
a358 1
static boolean
d366 1
a366 1
    return false;
d375 1
a375 1
  return true;
d381 1
a381 1
static boolean
d386 1
a386 1
    return false;
d391 1
a391 1
  return true;
d521 1
a521 1
  coff_section_data (vars->abfd, sec)->keep_relocs = true;
d613 1
a613 1
  sym->done_lineno    = false;
d756 1
a756 1
static boolean
d787 1
a787 1
      return false;
d792 1
a792 1
      return false;
d806 1
a806 1
      return false;
d818 1
a818 1
    return false;
d878 1
a878 1
    return false;
d897 1
a897 1
	return false;
d953 1
a953 1
	return false;
d1002 1
a1002 1
    return false;
d1005 1
a1005 1
    return false;
d1056 1
a1056 1
  obj_coff_keep_syms (abfd) = true;
d1062 1
a1062 1
  obj_coff_keep_strings (abfd) = true;
d1066 1
a1066 1
  return true;
@


1.34.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 2
a23 1
/* Most of this hacked by  Steve Chamberlain,
d26 3
a28 2
   PE/PEI rearrangement (and code added): Donn Terry
                                       Softway Systems, Inc.  */
d56 2
a57 1
   wasting too much time.  */
d61 1
a61 1
static bfd_boolean (*pe_saved_coff_bfd_print_private_bfd_data)
d70 1
a70 1
static bfd_boolean pe_print_private_bfd_data PARAMS ((bfd *, PTR));
d73 1
a73 1
static bfd_boolean (*pe_saved_coff_bfd_copy_private_bfd_data)
d82 1
a82 1
static bfd_boolean pe_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
d94 1
a94 1
static bfd_boolean pe_mkobject PARAMS ((bfd *));
d141 2
a142 2
static void		  pe_ILF_make_a_symbol_reloc  PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type, struct bfd_symbol **, unsigned int));
static bfd_boolean        pe_ILF_build_a_bfd      PARAMS ((bfd *, unsigned int, bfd_byte *, bfd_byte *, unsigned int, unsigned int));
d262 4
a265 8
  /* If this section holds uninitialized data and is from an object file
     or from an executable image that has not initialized the field,
     or if the image is an executable file and the physical size is padded,
     use the virtual size (stored in s_paddr) instead.  */
  if (scnhdr_int->s_paddr > 0
      && (((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0
	   && (! bfd_pe_executable_p (abfd) || scnhdr_int->s_size == 0))
          || (bfd_pe_executable_p (abfd) && scnhdr_int->s_size > scnhdr_int->s_paddr)))
a267 1

d276 1
a276 1
static bfd_boolean
d286 1
a286 1
    return FALSE;
d302 1
a302 1
  return TRUE;
d358 1
a358 1
static bfd_boolean
d366 1
a366 1
    return FALSE;
d375 1
a375 1
  return TRUE;
d381 1
a381 1
static bfd_boolean
d386 1
a386 1
    return FALSE;
d391 1
a391 1
  return TRUE;
d471 1
a471 1
			    struct bfd_symbol **  sym,
d521 1
a521 1
  coff_section_data (vars->abfd, sec)->keep_relocs = TRUE;
d613 1
a613 1
  sym->done_lineno    = FALSE;
d756 1
a756 1
static bfd_boolean
d787 1
a787 1
      return FALSE;
d792 1
a792 1
      return FALSE;
d806 1
a806 1
      return FALSE;
d818 1
a818 1
    return FALSE;
d878 1
a878 1
    return FALSE;
d897 1
a897 1
	return FALSE;
d953 1
a953 1
	return FALSE;
d968 1
a968 1
				      (struct bfd_symbol **) imp_sym,
d972 1
a972 1
				      (struct bfd_symbol **) imp_sym,
d1002 1
a1002 1
    return FALSE;
d1005 1
a1005 1
    return FALSE;
d1056 1
a1056 1
  obj_coff_keep_syms (abfd) = TRUE;
d1062 1
a1062 1
  obj_coff_keep_strings (abfd) = TRUE;
d1066 1
a1066 1
  return TRUE;
@


1.34.12.2
log
@Merge from mainline.
@
text
@d905 3
a907 12
	{
	  bfd_boolean skipped_leading_underscore = FALSE;
	  bfd_boolean skipped_leading_at = FALSE;
	  bfd_boolean skipped_leading_question_mark = FALSE;
	  bfd_boolean check_again;
	  
	  /* Skip any prefix in symbol_name.  */
	  -- symbol;
	  do
	    {
	      check_again = FALSE;
	      ++ symbol;
a908 21
	      switch (*symbol)
		{
		case '@@':
		  if (! skipped_leading_at)
		    check_again = skipped_leading_at = TRUE;
		  break;
		case '?':
		  if (! skipped_leading_question_mark)
		    check_again = skipped_leading_question_mark = TRUE;
		  break;
		case '_':
		  if (! skipped_leading_underscore)
		    check_again = skipped_leading_underscore = TRUE;
		  break;
		default:
		  break;
		}
	    }
	  while (check_again);
	}
      
@


1.34.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d61 1
a61 1
static bfd_boolean (*pe_saved_coff_bfd_print_private_bfd_data)
d70 1
a70 1
static bfd_boolean pe_print_private_bfd_data PARAMS ((bfd *, PTR));
d73 1
a73 1
static bfd_boolean (*pe_saved_coff_bfd_copy_private_bfd_data)
d82 1
a82 1
static bfd_boolean pe_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
d94 1
a94 1
static bfd_boolean pe_mkobject PARAMS ((bfd *));
d142 1
a142 1
static bfd_boolean        pe_ILF_build_a_bfd      PARAMS ((bfd *, unsigned int, bfd_byte *, bfd_byte *, unsigned int, unsigned int));
d276 1
a276 1
static bfd_boolean
d286 1
a286 1
    return FALSE;
d302 1
a302 1
  return TRUE;
d358 1
a358 1
static bfd_boolean
d366 1
a366 1
    return FALSE;
d375 1
a375 1
  return TRUE;
d381 1
a381 1
static bfd_boolean
d386 1
a386 1
    return FALSE;
d391 1
a391 1
  return TRUE;
d521 1
a521 1
  coff_section_data (vars->abfd, sec)->keep_relocs = TRUE;
d613 1
a613 1
  sym->done_lineno    = FALSE;
d756 1
a756 1
static bfd_boolean
d787 1
a787 1
      return FALSE;
d792 1
a792 1
      return FALSE;
d806 1
a806 1
      return FALSE;
d818 1
a818 1
    return FALSE;
d878 1
a878 1
    return FALSE;
d897 1
a897 1
	return FALSE;
d953 1
a953 1
	return FALSE;
d1002 1
a1002 1
    return FALSE;
d1005 1
a1005 1
    return FALSE;
d1056 1
a1056 1
  obj_coff_keep_syms (abfd) = TRUE;
d1062 1
a1062 1
  obj_coff_keep_strings (abfd) = TRUE;
d1066 1
a1066 1
  return TRUE;
@


1.34.10.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 2
a23 1
/* Most of this hacked by  Steve Chamberlain,
d26 3
a28 2
   PE/PEI rearrangement (and code added): Donn Terry
                                       Softway Systems, Inc.  */
d56 2
a57 1
   wasting too much time.  */
d262 4
a265 8
  /* If this section holds uninitialized data and is from an object file
     or from an executable image that has not initialized the field,
     or if the physical size is padded, use the virtual size (stored in
     s_paddr) instead.  */
  if (scnhdr_int->s_paddr > 0
      && (((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0
          && (! bfd_pe_executable_p (abfd) || scnhdr_int->s_size == 0))
          || scnhdr_int->s_size > scnhdr_int->s_paddr))
a267 1

@


1.34.10.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d138 1
a138 1
static void		  pe_ILF_make_a_symbol_reloc  PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type, struct bfd_symbol **, unsigned int));
d261 2
a262 2
     or if the image is an executable file and the physical size is padded,
     use the virtual size (stored in s_paddr) instead.  */
d265 2
a266 2
	   && (! bfd_pe_executable_p (abfd) || scnhdr_int->s_size == 0))
          || (bfd_pe_executable_p (abfd) && scnhdr_int->s_size > scnhdr_int->s_paddr)))
d473 1
a473 1
			    struct bfd_symbol **  sym,
d970 1
a970 1
				      (struct bfd_symbol **) imp_sym,
d974 1
a974 1
				      (struct bfd_symbol **) imp_sym,
@


1.34.10.4
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d905 3
a907 12
	{
	  bfd_boolean skipped_leading_underscore = FALSE;
	  bfd_boolean skipped_leading_at = FALSE;
	  bfd_boolean skipped_leading_question_mark = FALSE;
	  bfd_boolean check_again;
	  
	  /* Skip any prefix in symbol_name.  */
	  -- symbol;
	  do
	    {
	      check_again = FALSE;
	      ++ symbol;
a908 21
	      switch (*symbol)
		{
		case '@@':
		  if (! skipped_leading_at)
		    check_again = skipped_leading_at = TRUE;
		  break;
		case '?':
		  if (! skipped_leading_question_mark)
		    check_again = skipped_leading_question_mark = TRUE;
		  break;
		case '_':
		  if (! skipped_leading_underscore)
		    check_again = skipped_leading_underscore = TRUE;
		  break;
		default:
		  break;
		}
	    }
	  while (check_again);
	}
      
@


1.33
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d1210 4
a1213 1
    return NULL;
d1225 1
a1225 1

d1232 4
a1235 1
    return NULL;
@


1.33.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d1210 1
a1210 4
    {
      bfd_release (abfd, ptr);
      return NULL;
    }
d1222 1
a1222 1
      bfd_release (abfd, ptr);
d1229 1
a1229 4
    {
      bfd_release (abfd, ptr);
      return NULL;
    }
@


1.32
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
d315 1
a315 1
  if (pe_mkobject (abfd) == false)
@


1.32.10.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d315 1
a315 1
  if (! pe_mkobject (abfd))
@


1.32.10.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1210 1
a1210 4
    {
      bfd_release (abfd, ptr);
      return NULL;
    }
d1222 1
a1222 1
      bfd_release (abfd, ptr);
d1229 1
a1229 4
    {
      bfd_release (abfd, ptr);
      return NULL;
    }
@


1.31
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d786 1
a786 1
			  bfd_get_filename (abfd), import_type);
d791 1
a791 1
			  bfd_get_filename (abfd), import_type);
d805 1
a805 1
			  bfd_get_filename (abfd), import_name_type);
d1163 1
a1163 1
         bfd_get_filename (abfd), machine);
d1175 1
a1175 1
	 bfd_get_filename (abfd), machine);
d1192 1
a1192 1
	 bfd_get_filename (abfd));
d1220 1
a1220 1
	 bfd_get_filename (abfd));
@


1.30
log
@For sections containing uninitialised data, only set their size to s_paddr
if this does not reset their size to zero.  MS's latest compilers will set
s_paddr to zero.
@
text
@d142 1
a142 1
static boolean            pe_ILF_build_a_bfd      PARAMS ((bfd *, unsigned short, bfd_byte *, bfd_byte *, unsigned int, unsigned int));
d159 2
a160 2
  reloc_dst->r_vaddr = bfd_h_get_32(abfd, (bfd_byte *)reloc_src->r_vaddr);
  reloc_dst->r_symndx = bfd_h_get_signed_32(abfd, (bfd_byte *) reloc_src->r_symndx);
d162 1
a162 1
  reloc_dst->r_type = bfd_h_get_16(abfd, (bfd_byte *) reloc_src->r_type);
d165 1
a165 2
  reloc_dst->r_offset = SWAP_IN_RELOC_OFFSET(abfd,
					     (bfd_byte *) reloc_src->r_offset);
d177 2
a178 2
  bfd_h_put_32(abfd, reloc_src->r_vaddr, (bfd_byte *) reloc_dst->r_vaddr);
  bfd_h_put_32(abfd, reloc_src->r_symndx, (bfd_byte *) reloc_dst->r_symndx);
d180 1
a180 2
  bfd_h_put_16(abfd, reloc_src->r_type, (bfd_byte *)
	       reloc_dst->r_type);
d183 1
a183 3
  SWAP_OUT_RELOC_OFFSET(abfd,
			reloc_src->r_offset,
			(bfd_byte *) reloc_dst->r_offset);
d186 1
a186 1
  SWAP_OUT_RELOC_EXTRA(abfd,reloc_src, reloc_dst);
d200 7
a206 7
  filehdr_dst->f_magic = bfd_h_get_16(abfd, (bfd_byte *) filehdr_src->f_magic);
  filehdr_dst->f_nscns = bfd_h_get_16(abfd, (bfd_byte *)filehdr_src-> f_nscns);
  filehdr_dst->f_timdat = bfd_h_get_32(abfd, (bfd_byte *)filehdr_src-> f_timdat);

  filehdr_dst->f_nsyms = bfd_h_get_32(abfd, (bfd_byte *)filehdr_src-> f_nsyms);
  filehdr_dst->f_flags = bfd_h_get_16(abfd, (bfd_byte *)filehdr_src-> f_flags);
  filehdr_dst->f_symptr = bfd_h_get_32 (abfd, (bfd_byte *) filehdr_src->f_symptr);
d216 1
a216 2
  filehdr_dst->f_opthdr = bfd_h_get_16(abfd,
				       (bfd_byte *)filehdr_src-> f_opthdr);
d235 7
a241 13
  scnhdr_int->s_vaddr =
    GET_SCNHDR_VADDR (abfd, (bfd_byte *) scnhdr_ext->s_vaddr);
  scnhdr_int->s_paddr =
    GET_SCNHDR_PADDR (abfd, (bfd_byte *) scnhdr_ext->s_paddr);
  scnhdr_int->s_size =
    GET_SCNHDR_SIZE (abfd, (bfd_byte *) scnhdr_ext->s_size);
  scnhdr_int->s_scnptr =
    GET_SCNHDR_SCNPTR (abfd, (bfd_byte *) scnhdr_ext->s_scnptr);
  scnhdr_int->s_relptr =
    GET_SCNHDR_RELPTR (abfd, (bfd_byte *) scnhdr_ext->s_relptr);
  scnhdr_int->s_lnnoptr =
    GET_SCNHDR_LNNOPTR (abfd, (bfd_byte *) scnhdr_ext->s_lnnoptr);
  scnhdr_int->s_flags = bfd_h_get_32(abfd, (bfd_byte *) scnhdr_ext->s_flags);
d247 2
a248 3
  scnhdr_int->s_nlnno =
    (bfd_h_get_16 (abfd, (bfd_byte *) scnhdr_ext->s_nlnno)
     + (bfd_h_get_16 (abfd, (bfd_byte *) scnhdr_ext->s_nreloc) << 16));
d251 2
a252 4
  scnhdr_int->s_nreloc = bfd_h_get_16 (abfd,
				       (bfd_byte *) scnhdr_ext->s_nreloc);
  scnhdr_int->s_nlnno = bfd_h_get_16 (abfd,
				      (bfd_byte *) scnhdr_ext->s_nlnno);
d281 3
a283 2
  abfd->tdata.pe_obj_data =
    (struct pe_tdata *) bfd_zalloc (abfd, sizeof (pe_data_type));
d531 1
a531 1
  BFD_ASSERT ((bfd_byte *)vars->int_reltab < (bfd_byte *)vars->string_table);
d577 3
a579 2
  bfd_h_put_32 (vars->abfd, vars->string_ptr - vars->string_table, (bfd_byte *) esym->e.e.e_offset);
  bfd_h_put_16 (vars->abfd, section->target_index, (bfd_byte *) esym->e_scnum);
d657 1
a657 1
  bfd_set_section_size (vars->abfd, sec, size);
d758 1
a758 1
		    unsigned short  magic,
d816 1
a816 1
  ptr = bfd_zalloc (abfd, ILF_DATA_SIZE);
d924 2
a925 2
      pe_ILF_make_a_reloc (& vars, 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (& vars, id4);
d927 2
a928 2
      pe_ILF_make_a_reloc (& vars, 0, BFD_RELOC_RVA, id6);
      pe_ILF_save_relocs (& vars, id5);
d967 7
a973 5
	  pe_ILF_make_a_symbol_reloc (& vars, 0, BFD_RELOC_HI16_S,
				      (struct symbol_cache_entry **) imp_sym, imp_index);
	  pe_ILF_make_a_reloc (& vars, 0, BFD_RELOC_LO16, text);
	  pe_ILF_make_a_symbol_reloc (& vars, 4, BFD_RELOC_LO16,
				      (struct symbol_cache_entry **) imp_sym, imp_index);
d977 3
a979 2
	pe_ILF_make_a_symbol_reloc (& vars, jtab[i].offset, BFD_RELOC_32,
				    (asymbol **) imp_sym, imp_index);
d1000 1
a1000 1
  if (   ! bfd_set_start_address (abfd, 0)
a1024 2
      bfd_byte * ptr;

d1079 1
a1079 1
  unsigned long   size;
d1082 1
a1082 1
  unsigned short  magic;
d1086 1
a1086 1
  if (bfd_read (buffer, 1, 16, abfd) != 16)
d1092 1
a1092 1
      version = bfd_h_get_16 (abfd, ptr);  */
d1095 1
a1095 1
  machine = bfd_h_get_16 (abfd, ptr);
d1182 1
a1182 1
     date = bfd_h_get_32 (abfd, ptr);  */
d1185 1
a1185 1
  size = bfd_h_get_32 (abfd, ptr);
d1198 1
a1198 1
  ordinal = bfd_h_get_16 (abfd, ptr);
d1201 1
a1201 1
  types = bfd_h_get_16 (abfd, ptr);
d1209 1
a1209 1
  if (bfd_read (ptr, 1, size, abfd) != size)
d1243 2
a1244 2
  if (bfd_seek (abfd, 0x00, SEEK_SET) != 0
      || bfd_read (buffer, 1, 4, abfd) != 4)
d1251 1
a1251 1
  if (bfd_h_get_32 (abfd, buffer) == 0xffff0000)
d1254 2
a1255 2
  if (bfd_seek (abfd, 0x00, SEEK_SET) != 0
      || bfd_read (&dos_hdr, 1, sizeof (dos_hdr), abfd)
d1273 1
a1273 1
  if (bfd_h_get_16 (abfd, (bfd_byte *) dos_hdr.e_magic) != DOSMAGIC)
d1279 4
a1282 4
  offset = bfd_h_get_32 (abfd, (bfd_byte *) dos_hdr.e_lfanew);
  if (bfd_seek (abfd, (file_ptr) offset, SEEK_SET) != 0
      || bfd_read (&image_hdr, 1, sizeof (image_hdr), abfd)
	 != sizeof (image_hdr))
d1289 1
a1289 2
  if (bfd_h_get_32 (abfd, (bfd_byte *) image_hdr.nt_signature)
      != 0x4550)
d1298 1
a1298 4
  if (bfd_seek (abfd,
		(file_ptr) (offset - sizeof (dos_hdr)),
		SEEK_SET)
      != 0)
@


1.29
log
@Update copyright notices
@
text
@d278 2
a279 1
  if ((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0)
@


1.28
log
@* peicode.h (coff_swap_filehdr_out) [COFF_IMAGE_WITH_PE]: Define
as _bfd_XXi_only_swap_filehdr_out.
(pe_mkobject) [PEI_FORCE_MINIMUM_ALIGNMENT]: Set
pe->force_minimum_alignment to TRUE.
(pe_mkobject) [PEI_TARGET_SUBSYSTEM]: Set pe->target_subsystem to
PEI_TARGET_SUBSYSTEM.
(pe_print_private_bfd_data): Call
_bfd_XX_print_private_bfd_data_common() instead of
_bfd_pe_print_private_bfd_data_common().
(pe_bfd_copy_private_bfd_data): Call
_bfd_XX_bfd_copy_private_bfd_data_common() instead of
_bfd_pe_bfd_copy_private_bfd_data_common().
(coff_bfd_copy_private_section_data): Define as
_bfd_XX_bfd_copy_private_section_data instead of
_bfd_pe_bfd_copy_private_section_data.
(coff_get_symbol_info): Define as _bfd_XX_get_symbol_info instead
of a _bfd_pe_get_symbol_info.

* peigen.c: Delete.

* peXXigen.c: Renamed from peigen.c.
(COFF_WITH_XX): Define this macro (will get expanded into
COFF_WITH_pep or COFF_WITH_pe, depending on whether this is being
compiled as peigen.c or pepigen.c.
[COFF_WITH_pep]: Include "coff/ia64.h" instead of "coff/i386.h" to
define the canonical PEP structures and definitions.
(_bfd_XXi_swap_aouthdr_out): If pe->force_minimum_alignment is in
effect, enforce minimum file and section alignments.  If
extra->Subsystem is IMAGE_SUBSYSTEM_UNKNOWN, set it to
pe->target_subsystem (this defaults to IMAGE_SUBSYSTEM_UNKNOWN,
so, by default, this is a no-op).

* libpei.h: Rename COFF_WITH_PEP to COFF_WITH_pep.
(_bfd_XX_bfd_copy_private_bfd_data_common): Add macros to map
_bfd_XXfoo to _bfd_pepfoo if COFF_WIT_PEP is defined and to
_bfd_pefoo if it's not defined.  Use these macros to define
coff swap macros.

* libcoff.h (pe_tdata): Add members target_subsystem and
force_minimum_alignment.

* efi-app-ia64.c (COFF_WITH_pep): Rename COFF_WITH_PEP to
COFF_WITH_pep.
(PEI_TARGET_SUBSYSTEM): Rename from PEI_DEFAULT_TARGET_SUBSYSTEM.

* configure.in (bfd_efi_app_ia64_vec): Use pepigen.lo instead of
peigen.lo.

* coff-ia64.c: Rename COFF_WITH_PEP to COFF_WITH_pep.
(AOUTSZ): Rename PEP64AOUTSZ and PEP64AOUTHDR to PEPAOUTSZ and
PEPAOUTHDR.

* Makefile.in (BFD64_BACKENDS): Mention pepigen.lo.
(BFD64_BACKENDS_CFILES): Mention pepigen.c
(peigen.c): Add rule to generate from peXXigen.c.
(pepigen.c): Ditto.
(pepigen.lo): List dependencies for pepigen.lo.

* unwind-ia64.c (unw_decode_x1): Declare code arg with
ATTRIBUTE_UNUSED.
(unw_decode_x2): Ditto.
(unw_decode_x3): Ditto.
(unw_decode_x4): Ditto.

* pe.h (PEPAOUTSZ): Rename from PEP64AOUTSZ.
Rename from PEPAOUTHDR.
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.27
log
@2001-02-06  H.J. Lu  <hjl@@gnu.org>

	* bfd/peicode.h (coff_swap_filehdr_in): Remove the e_magic
	checking.
	(pe_bfd_object_p): Rewrite with external_PEI_DOS_hdr and
	external_PEI_IMAGE_hdr.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d224 1
a224 1
#define coff_swap_filehdr_out _bfd_pei_only_swap_filehdr_out
d226 1
a226 1
#define coff_swap_filehdr_out _bfd_pe_only_swap_filehdr_out
d305 8
d376 1
a376 1
  if (!_bfd_pe_print_private_bfd_data_common (abfd, vfile))
d396 1
a396 1
  if (!_bfd_pe_bfd_copy_private_bfd_data_common (ibfd, obfd))
d406 1
a406 1
  _bfd_pe_bfd_copy_private_section_data
d408 1
a408 1
#define coff_get_symbol_info _bfd_pe_get_symbol_info
@


1.26
log
@2001-01-02  Kazu Hirata  <kazu@@hxi.com>

	* peicode.h: Fix formatting.
@
text
@a210 20
#ifdef COFF_IMAGE_WITH_PE
  /* There are really two magic numbers involved; the magic number
     that says this is a NT executable (PEI) and the magic number that
     determines the architecture.  The former is DOSMAGIC, stored in
     the e_magic field.  The latter is stored in the f_magic field.
     If the NT magic number isn't valid, the architecture magic number
     could be mimicked by some other field (specifically, the number
     of relocs in section 3).  Since this routine can only be called
     correctly for a PEI file, check the e_magic number here, and, if
     it doesn't match, clobber the f_magic number so that we don't get
     a false match.  */
#if 0
  /* We can't assume that the PE header is at offset 0x80.  When it
     isn't, the DOS header isn't read correctly, so we can't assume
     e_magic is set even for valid PE files.  */
  if (bfd_h_get_16 (abfd, (bfd_byte *) filehdr_src->e_magic) != DOSMAGIC)
    filehdr_dst->f_magic = -1;
#endif
#endif

a1237 7
  /* We need to handle a PE image correctly.  In PE images created by
     the GNU linker, the offset to the COFF header is always the size.
     However, this is not the case in images generated by other PE
     linkers.  The PE format stores a four byte offset to the PE
     signature just before the COFF header at location 0x3c of the file.
     We pick up that offset, verify that the PE signature is there, and
     then set ourselves up to read in the COFF header.  */
d1239 2
a1241 1
  unsigned long signature;
d1252 1
a1252 3
  signature = bfd_h_get_32 (abfd, buffer);

  if (signature == 0xffff0000)
d1255 3
a1257 2
  if (bfd_seek (abfd, 0x3c, SEEK_SET) != 0
      || bfd_read (buffer, 1, 4, abfd) != 4)
d1264 15
a1278 1
  offset = bfd_h_get_32 (abfd, buffer);
d1280 4
a1283 2
  if (bfd_seek (abfd, offset, SEEK_SET) != 0
      || bfd_read (buffer, 1, 4, abfd) != 4)
d1290 2
a1291 3
  signature = bfd_h_get_32 (abfd, buffer);

  if (signature != 0x4550)
d1298 2
a1299 2
     pick up the COFF header.  We adjust so that that will work.  20
     is the size of the i386 COFF filehdr.  */
d1301 1
a1301 3
		(bfd_tell (abfd)
		 - bfd_coff_filhsz (abfd)
		 + 20),
@


1.26.2.1
log
@2001-02-14  Philip Blundell  <pb@@futuretv.com>

	From 2001-02-06  H.J. Lu  <hjl@@gnu.org>
	* bfd/peicode.h (coff_swap_filehdr_in): Remove the e_magic
	checking.
	(pe_bfd_object_p): Rewrite with external_PEI_DOS_hdr and
	external_PEI_IMAGE_hdr.
@
text
@d211 20
d1258 7
a1265 2
  struct external_PEI_DOS_hdr dos_hdr;
  struct external_PEI_IMAGE_hdr image_hdr;
d1267 1
d1278 3
a1280 1
  if (bfd_h_get_32 (abfd, buffer) == 0xffff0000)
d1283 2
a1284 3
  if (bfd_seek (abfd, 0x00, SEEK_SET) != 0
      || bfd_read (&dos_hdr, 1, sizeof (dos_hdr), abfd)
	 != sizeof (dos_hdr))
d1291 1
a1291 15
  /* There are really two magic numbers involved; the magic number
     that says this is a NT executable (PEI) and the magic number that
     determines the architecture.  The former is DOSMAGIC, stored in
     the e_magic field.  The latter is stored in the f_magic field.
     If the NT magic number isn't valid, the architecture magic number
     could be mimicked by some other field (specifically, the number
     of relocs in section 3).  Since this routine can only be called
     correctly for a PEI file, check the e_magic number here, and, if
     it doesn't match, clobber the f_magic number so that we don't get
     a false match.  */
  if (bfd_h_get_16 (abfd, (bfd_byte *) dos_hdr.e_magic) != DOSMAGIC)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
d1293 2
a1294 4
  offset = bfd_h_get_32 (abfd, (bfd_byte *) dos_hdr.e_lfanew);
  if (bfd_seek (abfd, (file_ptr) offset, SEEK_SET) != 0
      || bfd_read (&image_hdr, 1, sizeof (image_hdr), abfd)
	 != sizeof (image_hdr))
d1301 3
a1303 2
  if (bfd_h_get_32 (abfd, (bfd_byte *) image_hdr.nt_signature)
      != 0x4550)
d1310 2
a1311 2
     pick up the COFF header for PE, see "struct external_PEI_filehdr"
     in include/coff/pe.h.  We adjust so that that will work. */
d1313 3
a1315 1
		(file_ptr) (offset - sizeof (dos_hdr)),
@


1.26.2.2
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.26.2.3
log
@Merge from mainline.
@
text
@d225 1
a225 1
# define coff_swap_filehdr_out _bfd_XXi_only_swap_filehdr_out
d227 1
a227 1
# define coff_swap_filehdr_out _bfd_pe_only_swap_filehdr_out
a305 8

#ifdef PEI_FORCE_MINIMUM_ALIGNMENT
  pe->force_minimum_alignment = 1;
#endif
#ifdef PEI_TARGET_SUBSYSTEM
  pe->target_subsystem = PEI_TARGET_SUBSYSTEM;
#endif

d369 1
a369 1
  if (!_bfd_XX_print_private_bfd_data_common (abfd, vfile))
d389 1
a389 1
  if (!_bfd_XX_bfd_copy_private_bfd_data_common (ibfd, obfd))
d399 1
a399 1
  _bfd_XX_bfd_copy_private_section_data
d401 1
a401 1
#define coff_get_symbol_info _bfd_XX_get_symbol_info
@


1.26.2.4
log
@For sections containing uninitialised data, only set their size to s_paddr if
this does not reset their size to zero.  MS's latest compilers will set
s_paddr to zero.
@
text
@d278 1
a278 2
  if ((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0
      && (scnhdr_int->s_paddr > 0))
@


1.25
log
@Fixes to allow sources to compile under Solaris 2.8
@
text
@d106 1
a106 1
  
d113 1
a113 1
  
d116 1
a116 1
  
d122 1
a122 1
  
d128 1
a128 1
  
a168 1

d225 1
a225 1
     e_magic is set even for valid PE files. */
d239 1
a239 1
  filehdr_dst->f_opthdr = bfd_h_get_16(abfd, 
d258 1
a258 1
  memcpy(scnhdr_int->s_name, scnhdr_ext->s_name, sizeof(scnhdr_int->s_name));
d288 1
a288 1
  if (scnhdr_int->s_vaddr != 0) 
d313 1
a313 1
  abfd->tdata.pe_obj_data = 
d369 1
a369 1
  if (aouthdr) 
d373 1
a373 1
#ifdef ARM 
d377 1
a377 1
  
d426 1
a426 1
   Documentation about this format can be found at: 
d452 1
a452 1
  
d470 1
a470 1
  
a488 1

d502 1
a502 1
  
d516 1
a516 1
  
d518 1
a518 1
  
d574 2
a575 2
  
#ifdef THUMBPEMAGIC  
d588 1
a588 1
  
d598 1
a598 1
  
d612 1
a612 1
  
d617 1
a617 1
  
d625 1
a625 1
  
d631 1
a631 1
  
d638 1
a638 1
  
d641 1
a641 1
  
d663 1
a663 1
  
d667 1
a667 1
  
d669 1
a669 1
  
d671 1
a671 1
     
d673 1
a673 1
  
d676 1
a676 1
  
d685 1
a685 1
  
d692 1
a692 1
  
d698 1
a698 1
  
d704 1
a704 1
  
d735 1
a735 1
  
d746 1
a746 1
  
d754 1
a754 1
  
d762 1
a762 1
  
d785 1
a785 1
{ 
d804 1
a804 1
      
d810 1
a810 1
      
d824 1
a824 1
      
d832 1
a832 1
     
d835 1
a835 1
     
d847 1
a847 1
  
d854 1
a854 1
  
d866 1
a866 1
  
d870 1
a870 1
  
d882 1
a882 1
  
d889 1
a889 1
  
d901 1
a901 1
  
d908 1
a908 1
      
d915 1
a915 1
      
d937 1
a937 1
      
d940 1
a940 1
      
d948 1
a948 1
      
d957 1
a957 1
      
d984 1
a984 1
    
d986 1
a986 1
#ifdef MIPS_ARCH_MAGIC_WINCE      
d999 1
a999 1
      
d1010 1
a1010 1
  
d1013 1
a1013 1
  
d1018 1
a1018 1
  
d1027 1
a1027 1
#ifdef THUMBPEMAGIC  
d1032 1
a1032 1
    
d1045 1
a1045 1
      
d1049 1
a1049 1
      
d1063 1
a1063 1
      
d1072 1
a1072 1
  
d1078 1
a1078 1
  
d1081 1
a1081 1
  
d1104 1
a1104 1
  
d1111 1
a1111 1
  
d1121 1
a1121 1
  
d1129 1
a1129 1
      
d1135 1
a1135 1
      
d1141 1
a1141 1
      
d1145 1
a1145 1
      
d1153 1
a1153 1
      
d1160 1
a1160 1
      
d1164 1
a1164 1
#endif      
d1166 1
a1166 1
      
d1171 1
a1171 1
	
d1175 1
a1175 1
#endif      
d1177 1
a1177 1
      
d1186 1
a1186 1
	
d1198 1
a1198 1
	
d1200 1
a1200 1
    }  
d1205 1
a1205 1
  
d1215 1
a1215 1
	
d1229 1
a1229 1
  
d1235 1
a1235 1
  
d1243 1
a1243 1
	
d1246 1
a1246 1
  
d1251 1
a1251 1
  
d1277 1
a1277 1
  
d1279 1
a1279 1
  
d1282 1
a1282 1
  
d1308 1
a1308 1
  
@


1.24
log
@* peicode.h (coff_swap_filehdr_in): can't use e_magic because we
can't assume the PE header is at 0x80.
* coff/pe.h: clarify a comment
@
text
@d140 1
a140 1
static void		  pe_ILF_make_a_symbol_reloc  PARAMS ((pe_ILF_vars *, bfd_vma, bfd_reloc_code_real_type,	   struct symbol_cache_entry **, unsigned int));
d992 1
a992 1
				      (asection **) imp_sym, imp_index);
d995 1
a995 1
				      (asection **) imp_sym, imp_index);
d1172 1
a1172 1
	extern bfd_target TARGET_LITTLE_SYM;
@


1.23
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d223 4
d229 1
@


1.22
log
@Fix arm-epoc-pe build problem:
	* peicode.h (pe_ILF_object_p): Use TARGET_LITTLE_SYM instead of
	armpei_little_vec.
@
text
@a71 1

a243 1

@


1.21
log
@Remove U suffix from constants for K&R compilers.
Fix a couple of 64 bit nits.
@
text
@d1169 1
a1169 1
	extern bfd_target armpei_little_vec;
d1171 1
a1171 1
	if (abfd->xvec == & armpei_little_vec)
@


1.20
log
@Further LINK6 bug fix.
@
text
@d908 2
a909 2
      * (unsigned int *) id4->contents = ordinal | 0x80000000UL;
      * (unsigned int *) id5->contents = ordinal | 0x80000000UL;
@


1.19
log
@fix LINK6 code.
@
text
@d595 3
d600 1
a600 5
  if (section)
    bfd_h_put_16 (vars->abfd, section->target_index, (bfd_byte *) esym->e_scnum);
  else
    bfd_h_put_16 (vars->abfd, 0, (bfd_byte *) esym->e_scnum);
    
d614 1
a614 2
  if (section)
    ent->u.syment.n_scnum         = section->target_index;
@


1.18
log
@Fix building with --enable-targets=all
@
text
@d117 1
a117 1

d121 3
d141 1
d144 1
a144 1
static const bfd_target * pe_bfd_object_p         PARAMS ((bfd *));
d438 1
a438 1
      per symbol for their names (longest section name is .idata$2).
d442 1
a442 1
      is strlen (symbol_name) * 2 + 8.
d454 1
d458 4
a461 1
#define SIZEOF_ILF_STRINGS	(strlen (symbol_name) * 2 + 8 + NUM_ILF_SECTIONS * 9 + STRING_SIZE_SIZE)
d474 1
d490 5
a494 4
pe_ILF_make_a_reloc (pe_ILF_vars *             vars,
		     bfd_vma                   address,
		     bfd_reloc_code_real_type  reloc,
		     asection_ptr              sec)
d505 1
a505 1
  entry->sym_ptr_ptr = sec->symbol_ptr_ptr;
d508 1
a508 1
  internal->r_symndx = coff_section_data (vars->abfd, sec)->i;
d521 11
d570 1
a570 1
    sclass = C_LABEL;
d580 1
a580 1
	sclass = C_THUMBLABEL;
d597 5
a601 1
  bfd_h_put_16 (vars->abfd, section->target_index, (bfd_byte *) esym->e_scnum);
d615 2
a616 1
  ent->u.syment.n_scnum           = section->target_index;
d641 2
a642 1

d646 1
d650 1
a650 1
  vars->string_ptr += strlen (symbol_name) + 1;
d703 1
a703 1
  /* Cache the index to the symbol in the coff_section_data structire.  */
d792 3
a794 1
  asection_ptr             id2, id4, id5, id6 = NULL, id7, text;
a795 2
  text = NULL;
  
d863 4
d892 1
a892 1
     .idata$2:  Import Directory Table
a897 1
  id2 = pe_ILF_make_a_section (& vars, ".idata$2", SIZEOF_IDATA2, 0);
d900 1
a900 1
  if (id2 == NULL || id4 == NULL || id5 == NULL)
d910 2
a911 2
      * (unsigned int *) id4->contents = ordinal | 0x80000000;
      * (unsigned int *) id5->contents = ordinal | 0x80000000;
d939 4
a942 1
      strcpy (id6->contents, symbol);
a944 13
  /* Create .idata$7 - the Dll Name Table.  */
  id7 = pe_ILF_make_a_section (& vars, ".idata$7", SIZEOF_IDATA7, 0);
  if (id7 == NULL)
    return false;
  
  strcpy (id7->contents + 2, source_dll);

  /* Now generate the relocs for the sections.  */
  pe_ILF_make_a_reloc (& vars,  0, BFD_RELOC_RVA, id4);
  pe_ILF_make_a_reloc (& vars, 12, BFD_RELOC_RVA, id7);
  pe_ILF_make_a_reloc (& vars, 16, BFD_RELOC_RVA, id5);
  pe_ILF_save_relocs (& vars, id2);

d981 5
d990 2
a991 1
	  pe_ILF_make_a_reloc (& vars, 0, BFD_RELOC_HI16_S, id5);
d993 2
a994 1
	  pe_ILF_make_a_reloc (& vars, 4, BFD_RELOC_LO16, id5);
d998 2
a999 1
	pe_ILF_make_a_reloc (& vars, jtab[i].offset, BFD_RELOC_32, id5);
d1045 2
d1050 9
d1062 1
a1062 1
      /* XXX not sure if I need to do anythign here.  */
a1069 2
  pe_ILF_make_a_symbol (& vars, "_imp__", symbol_name, id5, 0);
  
d1238 1
a1238 1
  if (ptr[size - 1] != 0 || ((unsigned long)(source_dll - ptr) >= size))
@


1.17
log
@Add WinCE support.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d700 1
a700 1
jump_table jtab[] =
d764 1
a764 1
  asection_ptr             id2, id4, id5, id6, id7, text;
d1200 1
a1200 1
  if (ptr[size - 1] != 0 || ((source_dll - ptr) >= size))
@


1.16
log
@fix PE file format detection
@
text
@d88 1
d91 1
d97 46
d145 1
d191 1
a191 1

d288 1
d299 1
d417 801
d1219 1
a1219 2
pe_bfd_object_p (abfd)
     bfd * abfd;
d1244 1
a1244 8
    {
      _bfd_error_handler (
_("%s: Import Library Format archives are not currently supported"),
			  bfd_get_filename (abfd));
      bfd_set_error (bfd_error_wrong_format);
	
      return NULL;
    }
d1291 1
a1291 1
#endif
@


1.15
log
@Move PE format object file detection code into common place.
@
text
@d365 1
d394 2
a395 1
      _bfd_error_handler (_("%s: Import Library Format archives are not currently supported"),
d447 1
@


1.14
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* peicode.h (coff_swap_scnhdr_in): If COFF_IMAGE_WITH_PE, the
	get the overflow of the s_nlnno field from the s_nreloc field.
	* peigen.c (_bfd_pei_swap_scnhdr_out): If doing a final link, swap
	the s_nlnno overflow of the .text section into the s_nreloc
	field.
@
text
@d364 81
@


1.13
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* libpei.h (_bfd_pe_bfd_get_symbol_info): Declare.
	* peigen.c (_bfd_pe_bfd_get_symbol_info): New function.
	* peicode.h (coff_get_symbol_info): Define.
@
text
@d218 14
a231 2
  scnhdr_int->s_nreloc = bfd_h_get_16(abfd, (bfd_byte *) scnhdr_ext->s_nreloc);
  scnhdr_int->s_nlnno = bfd_h_get_16(abfd, (bfd_byte *) scnhdr_ext->s_nlnno);
@


1.12
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* libpei.h: New file, broken out of peicode.h.
	* peigen.c: New file, broken out of peicode.h.
	* peicode.h: A bunch of code moved out to libpei.h and peigen.c.
	* configure.in: Add peigen.lo to list of files required for each
	PE target.
	* Makefile.am: Rebuild dependencies.
	(BFD32_BACKENDS): Add peigen.lo.
	(BFD32_BACKENDS_CFILES): Add peigen.c.
	(SOURCE_HFILES): Add libpei.h.
	* configure, Makefile.in: Rebuild.
@
text
@d350 2
@


1.11
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* peicode.h (coff_swap_scnhdr_in): Don't check for a special
	section name of _BSS; check IMAGE_SCN_CNT_UNINITIALIZED_DATA
	instead.  Don't clear the s_paddr field for an uninitialized data
	section.
@
text
@d1 1
a1 1
/* Support for the generic parts of most COFF variants, for BFD.
d3 1
a3 1
   Written by Cygnus Support.
d24 3
d58 2
a59 1
#ifdef coff_bfd_print_private_bfd_data
d61 5
a65 2
     PARAMS ((bfd *, PTR))
     = coff_bfd_print_private_bfd_data;
a66 4
#else
static boolean (*pe_saved_coff_bfd_print_private_bfd_data)
     PARAMS ((bfd *, PTR))
     = NULL;
d68 2
a71 2
#define coff_mkobject      pe_mkobject
#define coff_mkobject_hook pe_mkobject_hook
d73 7
a79 3
#ifndef GET_FCN_LNNOPTR
#define GET_FCN_LNNOPTR(abfd, ext) \
     bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_lnnoptr)
d82 2
a83 4
#ifndef GET_FCN_ENDNDX
#define GET_FCN_ENDNDX(abfd, ext)  \
	bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_endndx)
#endif
d85 2
a86 126
#ifndef PUT_FCN_LNNOPTR
#define PUT_FCN_LNNOPTR(abfd, in, ext)  bfd_h_put_32(abfd,  in, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_lnnoptr)
#endif
#ifndef PUT_FCN_ENDNDX
#define PUT_FCN_ENDNDX(abfd, in, ext) bfd_h_put_32(abfd, in, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_endndx)
#endif
#ifndef GET_LNSZ_LNNO
#define GET_LNSZ_LNNO(abfd, ext) bfd_h_get_16(abfd, (bfd_byte *) ext->x_sym.x_misc.x_lnsz.x_lnno)
#endif
#ifndef GET_LNSZ_SIZE
#define GET_LNSZ_SIZE(abfd, ext) bfd_h_get_16(abfd, (bfd_byte *) ext->x_sym.x_misc.x_lnsz.x_size)
#endif
#ifndef PUT_LNSZ_LNNO
#define PUT_LNSZ_LNNO(abfd, in, ext) bfd_h_put_16(abfd, in, (bfd_byte *)ext->x_sym.x_misc.x_lnsz.x_lnno)
#endif
#ifndef PUT_LNSZ_SIZE
#define PUT_LNSZ_SIZE(abfd, in, ext) bfd_h_put_16(abfd, in, (bfd_byte*) ext->x_sym.x_misc.x_lnsz.x_size)
#endif
#ifndef GET_SCN_SCNLEN
#define GET_SCN_SCNLEN(abfd,  ext) bfd_h_get_32(abfd, (bfd_byte *) ext->x_scn.x_scnlen)
#endif
#ifndef GET_SCN_NRELOC
#define GET_SCN_NRELOC(abfd,  ext) bfd_h_get_16(abfd, (bfd_byte *)ext->x_scn.x_nreloc)
#endif
#ifndef GET_SCN_NLINNO
#define GET_SCN_NLINNO(abfd, ext)  bfd_h_get_16(abfd, (bfd_byte *)ext->x_scn.x_nlinno)
#endif
#ifndef PUT_SCN_SCNLEN
#define PUT_SCN_SCNLEN(abfd,in, ext) bfd_h_put_32(abfd, in, (bfd_byte *) ext->x_scn.x_scnlen)
#endif
#ifndef PUT_SCN_NRELOC
#define PUT_SCN_NRELOC(abfd,in, ext) bfd_h_put_16(abfd, in, (bfd_byte *)ext->x_scn.x_nreloc)
#endif
#ifndef PUT_SCN_NLINNO
#define PUT_SCN_NLINNO(abfd,in, ext)  bfd_h_put_16(abfd,in, (bfd_byte  *) ext->x_scn.x_nlinno)
#endif
#ifndef GET_LINENO_LNNO
#define GET_LINENO_LNNO(abfd, ext) bfd_h_get_16(abfd, (bfd_byte *) (ext->l_lnno));
#endif
#ifndef PUT_LINENO_LNNO
#define PUT_LINENO_LNNO(abfd,val, ext) bfd_h_put_16(abfd,val,  (bfd_byte *) (ext->l_lnno));
#endif

/* The f_symptr field in the filehdr is sometimes 64 bits.  */
#ifndef GET_FILEHDR_SYMPTR
#define GET_FILEHDR_SYMPTR bfd_h_get_32
#endif
#ifndef PUT_FILEHDR_SYMPTR
#define PUT_FILEHDR_SYMPTR bfd_h_put_32
#endif

/* Some fields in the aouthdr are sometimes 64 bits.  */
#ifndef GET_AOUTHDR_TSIZE
#define GET_AOUTHDR_TSIZE bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_TSIZE
#define PUT_AOUTHDR_TSIZE bfd_h_put_32
#endif
#ifndef GET_AOUTHDR_DSIZE
#define GET_AOUTHDR_DSIZE bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_DSIZE
#define PUT_AOUTHDR_DSIZE bfd_h_put_32
#endif
#ifndef GET_AOUTHDR_BSIZE
#define GET_AOUTHDR_BSIZE bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_BSIZE
#define PUT_AOUTHDR_BSIZE bfd_h_put_32
#endif
#ifndef GET_AOUTHDR_ENTRY
#define GET_AOUTHDR_ENTRY bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_ENTRY
#define PUT_AOUTHDR_ENTRY bfd_h_put_32
#endif
#ifndef GET_AOUTHDR_TEXT_START
#define GET_AOUTHDR_TEXT_START bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_TEXT_START
#define PUT_AOUTHDR_TEXT_START bfd_h_put_32
#endif
#ifndef GET_AOUTHDR_DATA_START
#define GET_AOUTHDR_DATA_START bfd_h_get_32
#endif
#ifndef PUT_AOUTHDR_DATA_START
#define PUT_AOUTHDR_DATA_START bfd_h_put_32
#endif

/* Some fields in the scnhdr are sometimes 64 bits.  */
#ifndef GET_SCNHDR_PADDR
#define GET_SCNHDR_PADDR bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_PADDR
#define PUT_SCNHDR_PADDR bfd_h_put_32
#endif
#ifndef GET_SCNHDR_VADDR
#define GET_SCNHDR_VADDR bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_VADDR
#define PUT_SCNHDR_VADDR bfd_h_put_32
#endif
#ifndef GET_SCNHDR_SIZE
#define GET_SCNHDR_SIZE bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_SIZE
#define PUT_SCNHDR_SIZE bfd_h_put_32
#endif
#ifndef GET_SCNHDR_SCNPTR
#define GET_SCNHDR_SCNPTR bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_SCNPTR
#define PUT_SCNHDR_SCNPTR bfd_h_put_32
#endif
#ifndef GET_SCNHDR_RELPTR
#define GET_SCNHDR_RELPTR bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_RELPTR
#define PUT_SCNHDR_RELPTR bfd_h_put_32
#endif
#ifndef GET_SCNHDR_LNNOPTR
#define GET_SCNHDR_LNNOPTR bfd_h_get_32
#endif
#ifndef PUT_SCNHDR_LNNOPTR
#define PUT_SCNHDR_LNNOPTR bfd_h_put_32
#endif
a90 12
static unsigned int coff_swap_filehdr_out PARAMS ((bfd *, PTR, PTR));
static void coff_swap_sym_in PARAMS ((bfd *, PTR, PTR));
static unsigned int coff_swap_sym_out PARAMS ((bfd *, PTR, PTR));
static void coff_swap_aux_in PARAMS ((bfd *, PTR, int, int, int, int, PTR));
static unsigned int coff_swap_aux_out
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
static void coff_swap_lineno_in PARAMS ((bfd *, PTR, PTR));
static unsigned int coff_swap_lineno_out PARAMS ((bfd *, PTR, PTR));
static void coff_swap_aouthdr_in PARAMS ((bfd *, PTR, PTR));
static void add_data_entry
  PARAMS ((bfd *, struct internal_extra_pe_aouthdr *, int, char *, bfd_vma));
static unsigned int coff_swap_aouthdr_out PARAMS ((bfd *, PTR, PTR));
a91 6
static unsigned int coff_swap_scnhdr_out PARAMS ((bfd *, PTR, PTR));
static boolean pe_print_idata PARAMS ((bfd *, PTR));
static boolean pe_print_edata PARAMS ((bfd *, PTR));
static boolean pe_print_pdata PARAMS ((bfd *, PTR));
static boolean pe_print_reloc PARAMS ((bfd *, PTR));
static boolean pe_print_private_bfd_data PARAMS ((bfd *, PTR));
a93 1
static boolean pe_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
d188 1
a188 716

static  unsigned int
coff_swap_filehdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
{
  int idx;
  struct internal_filehdr *filehdr_in = (struct internal_filehdr *)in;
  FILHDR *filehdr_out = (FILHDR *)out;

  if (pe_data (abfd)->has_reloc_section)
    filehdr_in->f_flags &= ~F_RELFLG;

  if (pe_data (abfd)->dll)
    filehdr_in->f_flags |= F_DLL;

  filehdr_in->pe.e_magic    = DOSMAGIC;
  filehdr_in->pe.e_cblp     = 0x90;
  filehdr_in->pe.e_cp       = 0x3;
  filehdr_in->pe.e_crlc     = 0x0;
  filehdr_in->pe.e_cparhdr  = 0x4;
  filehdr_in->pe.e_minalloc = 0x0;
  filehdr_in->pe.e_maxalloc = 0xffff;
  filehdr_in->pe.e_ss       = 0x0;
  filehdr_in->pe.e_sp       = 0xb8;
  filehdr_in->pe.e_csum     = 0x0;
  filehdr_in->pe.e_ip       = 0x0;
  filehdr_in->pe.e_cs       = 0x0;
  filehdr_in->pe.e_lfarlc   = 0x40;
  filehdr_in->pe.e_ovno     = 0x0;

  for (idx=0; idx < 4; idx++)
    filehdr_in->pe.e_res[idx] = 0x0;

  filehdr_in->pe.e_oemid   = 0x0;
  filehdr_in->pe.e_oeminfo = 0x0;

  for (idx=0; idx < 10; idx++)
    filehdr_in->pe.e_res2[idx] = 0x0;

  filehdr_in->pe.e_lfanew = 0x80;

  /* this next collection of data are mostly just characters.  It appears
     to be constant within the headers put on NT exes */
  filehdr_in->pe.dos_message[0]  = 0x0eba1f0e;
  filehdr_in->pe.dos_message[1]  = 0xcd09b400;
  filehdr_in->pe.dos_message[2]  = 0x4c01b821;
  filehdr_in->pe.dos_message[3]  = 0x685421cd;
  filehdr_in->pe.dos_message[4]  = 0x70207369;
  filehdr_in->pe.dos_message[5]  = 0x72676f72;
  filehdr_in->pe.dos_message[6]  = 0x63206d61;
  filehdr_in->pe.dos_message[7]  = 0x6f6e6e61;
  filehdr_in->pe.dos_message[8]  = 0x65622074;
  filehdr_in->pe.dos_message[9]  = 0x6e757220;
  filehdr_in->pe.dos_message[10] = 0x206e6920;
  filehdr_in->pe.dos_message[11] = 0x20534f44;
  filehdr_in->pe.dos_message[12] = 0x65646f6d;
  filehdr_in->pe.dos_message[13] = 0x0a0d0d2e;
  filehdr_in->pe.dos_message[14] = 0x24;
  filehdr_in->pe.dos_message[15] = 0x0;
  filehdr_in->pe.nt_signature = NT_SIGNATURE;



  bfd_h_put_16(abfd, filehdr_in->f_magic, (bfd_byte *) filehdr_out->f_magic);
  bfd_h_put_16(abfd, filehdr_in->f_nscns, (bfd_byte *) filehdr_out->f_nscns);

  bfd_h_put_32(abfd, time (0), (bfd_byte *) filehdr_out->f_timdat);
  PUT_FILEHDR_SYMPTR (abfd, (bfd_vma) filehdr_in->f_symptr,
		      (bfd_byte *) filehdr_out->f_symptr);
  bfd_h_put_32(abfd, filehdr_in->f_nsyms, (bfd_byte *) filehdr_out->f_nsyms);
  bfd_h_put_16(abfd, filehdr_in->f_opthdr, (bfd_byte *) filehdr_out->f_opthdr);
  bfd_h_put_16(abfd, filehdr_in->f_flags, (bfd_byte *) filehdr_out->f_flags);

  /* put in extra dos header stuff.  This data remains essentially
     constant, it just has to be tacked on to the beginning of all exes 
     for NT */
  bfd_h_put_16(abfd, filehdr_in->pe.e_magic, (bfd_byte *) filehdr_out->e_magic);
  bfd_h_put_16(abfd, filehdr_in->pe.e_cblp, (bfd_byte *) filehdr_out->e_cblp);
  bfd_h_put_16(abfd, filehdr_in->pe.e_cp, (bfd_byte *) filehdr_out->e_cp);
  bfd_h_put_16(abfd, filehdr_in->pe.e_crlc, (bfd_byte *) filehdr_out->e_crlc);
  bfd_h_put_16(abfd, filehdr_in->pe.e_cparhdr, 
	       (bfd_byte *) filehdr_out->e_cparhdr);
  bfd_h_put_16(abfd, filehdr_in->pe.e_minalloc, 
	       (bfd_byte *) filehdr_out->e_minalloc);
  bfd_h_put_16(abfd, filehdr_in->pe.e_maxalloc, 
	       (bfd_byte *) filehdr_out->e_maxalloc);
  bfd_h_put_16(abfd, filehdr_in->pe.e_ss, (bfd_byte *) filehdr_out->e_ss);
  bfd_h_put_16(abfd, filehdr_in->pe.e_sp, (bfd_byte *) filehdr_out->e_sp);
  bfd_h_put_16(abfd, filehdr_in->pe.e_csum, (bfd_byte *) filehdr_out->e_csum);
  bfd_h_put_16(abfd, filehdr_in->pe.e_ip, (bfd_byte *) filehdr_out->e_ip);
  bfd_h_put_16(abfd, filehdr_in->pe.e_cs, (bfd_byte *) filehdr_out->e_cs);
  bfd_h_put_16(abfd, filehdr_in->pe.e_lfarlc, (bfd_byte *) filehdr_out->e_lfarlc);
  bfd_h_put_16(abfd, filehdr_in->pe.e_ovno, (bfd_byte *) filehdr_out->e_ovno);
  {
    int idx;
    for (idx=0; idx < 4; idx++)
      bfd_h_put_16(abfd, filehdr_in->pe.e_res[idx], 
		   (bfd_byte *) filehdr_out->e_res[idx]);
  }
  bfd_h_put_16(abfd, filehdr_in->pe.e_oemid, (bfd_byte *) filehdr_out->e_oemid);
  bfd_h_put_16(abfd, filehdr_in->pe.e_oeminfo,
	       (bfd_byte *) filehdr_out->e_oeminfo);
  {
    int idx;
    for (idx=0; idx < 10; idx++)
      bfd_h_put_16(abfd, filehdr_in->pe.e_res2[idx],
		   (bfd_byte *) filehdr_out->e_res2[idx]);
  }
  bfd_h_put_32(abfd, filehdr_in->pe.e_lfanew, (bfd_byte *) filehdr_out->e_lfanew);

  {
    int idx;
    for (idx=0; idx < 16; idx++)
      bfd_h_put_32(abfd, filehdr_in->pe.dos_message[idx],
		   (bfd_byte *) filehdr_out->dos_message[idx]);
  }

  /* also put in the NT signature */
  bfd_h_put_32(abfd, filehdr_in->pe.nt_signature, 
	       (bfd_byte *) filehdr_out->nt_signature);




  return FILHSZ;
}
#else

static  unsigned int
coff_swap_filehdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
{
  struct internal_filehdr *filehdr_in = (struct internal_filehdr *)in;
  FILHDR *filehdr_out = (FILHDR *)out;

  bfd_h_put_16(abfd, filehdr_in->f_magic, (bfd_byte *) filehdr_out->f_magic);
  bfd_h_put_16(abfd, filehdr_in->f_nscns, (bfd_byte *) filehdr_out->f_nscns);
  bfd_h_put_32(abfd, filehdr_in->f_timdat, (bfd_byte *) filehdr_out->f_timdat);
  PUT_FILEHDR_SYMPTR (abfd, (bfd_vma) filehdr_in->f_symptr,
		      (bfd_byte *) filehdr_out->f_symptr);
  bfd_h_put_32(abfd, filehdr_in->f_nsyms, (bfd_byte *) filehdr_out->f_nsyms);
  bfd_h_put_16(abfd, filehdr_in->f_opthdr, (bfd_byte *) filehdr_out->f_opthdr);
  bfd_h_put_16(abfd, filehdr_in->f_flags, (bfd_byte *) filehdr_out->f_flags);

  return FILHSZ;
}

#endif


static void
coff_swap_sym_in (abfd, ext1, in1)
     bfd            *abfd;
     PTR ext1;
     PTR in1;
{
  SYMENT *ext = (SYMENT *)ext1;
  struct internal_syment      *in = (struct internal_syment *)in1;

  if( ext->e.e_name[0] == 0) {
    in->_n._n_n._n_zeroes = 0;
    in->_n._n_n._n_offset = bfd_h_get_32(abfd, (bfd_byte *) ext->e.e.e_offset);
  }
  else {
#if SYMNMLEN != E_SYMNMLEN
    -> Error, we need to cope with truncating or extending SYMNMLEN!;
#else
    memcpy(in->_n._n_name, ext->e.e_name, SYMNMLEN);
#endif
  }

  in->n_value = bfd_h_get_32(abfd, (bfd_byte *) ext->e_value); 
  in->n_scnum = bfd_h_get_16(abfd, (bfd_byte *) ext->e_scnum);
  if (sizeof(ext->e_type) == 2){
    in->n_type = bfd_h_get_16(abfd, (bfd_byte *) ext->e_type);
  }
  else {
    in->n_type = bfd_h_get_32(abfd, (bfd_byte *) ext->e_type);
  }
  in->n_sclass = bfd_h_get_8(abfd, ext->e_sclass);
  in->n_numaux = bfd_h_get_8(abfd, ext->e_numaux);

  /* The section symbols for the .idata$ sections have class 0x68
     (C_SECTION), which MS documentation indicates is a section
     symbol.  Unfortunately, the value field in the symbol is simply a
     copy of the .idata section's flags rather than something useful.
     When these symbols are encountered, change the value to 0 so that
     they will be handled somewhat correctly in the bfd code.  */
  if (in->n_sclass == C_SECTION)
    {
      in->n_value = 0x0;

#if 0
      /* FIXME: This is clearly wrong.  The problem seems to be that
         undefined C_SECTION symbols appear in the first object of a
         MS generated .lib file, and the symbols are not defined
         anywhere.  */
      in->n_scnum = 1;

      /* I have tried setting the class to 3 and using the following
	 to set the section number.  This will put the address of the
	 pointer to the string kernel32.dll at addresses 0 and 0x10
	 off start of idata section which is not correct */
      /*    if (strcmp (in->_n._n_name, ".idata$4") == 0) */
      /*      in->n_scnum = 3; */
      /*    else */
      /*      in->n_scnum = 2; */
#else
      /* Create synthetic empty sections as needed.  DJ */
      if (in->n_scnum == 0)
	{
	  asection *sec;
	  for (sec=abfd->sections; sec; sec=sec->next)
	    {
	      if (strcmp (sec->name, in->n_name) == 0)
		{
		  in->n_scnum = sec->target_index;
		  break;
		}
	    }
	}
      if (in->n_scnum == 0)
	{
	  int unused_section_number = 0;
	  asection *sec;
	  char *name;
	  for (sec=abfd->sections; sec; sec=sec->next)
	    if (unused_section_number <= sec->target_index)
	      unused_section_number = sec->target_index+1;

	  name = bfd_alloc (abfd, strlen (in->n_name) + 10);
	  if (name == NULL)
	    return;
	  strcpy (name, in->n_name);
	  sec = bfd_make_section_anyway (abfd, name);

	  sec->vma = 0;
	  sec->lma = 0;
	  sec->_cooked_size = 0;
	  sec->_raw_size = 0;
	  sec->filepos = 0;
	  sec->rel_filepos = 0;
	  sec->reloc_count = 0;
	  sec->line_filepos = 0;
	  sec->lineno_count = 0;
	  sec->userdata = NULL;
	  sec->next = (asection *) NULL;
	  sec->flags = 0;
	  sec->alignment_power = 2;
	  sec->flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_DATA | SEC_LOAD;

	  sec->target_index = unused_section_number;

	  in->n_scnum = unused_section_number;
	}
      in->n_sclass = C_STAT;
#endif
    }

#ifdef coff_swap_sym_in_hook
  coff_swap_sym_in_hook(abfd, ext1, in1);
#endif
}

static unsigned int
coff_swap_sym_out (abfd, inp, extp)
     bfd       *abfd;
     PTR	inp;
     PTR	extp;
{
  struct internal_syment *in = (struct internal_syment *)inp;
  SYMENT *ext =(SYMENT *)extp;
  if(in->_n._n_name[0] == 0) {
    bfd_h_put_32(abfd, 0, (bfd_byte *) ext->e.e.e_zeroes);
    bfd_h_put_32(abfd, in->_n._n_n._n_offset, (bfd_byte *)  ext->e.e.e_offset);
  }
  else {
#if SYMNMLEN != E_SYMNMLEN
    -> Error, we need to cope with truncating or extending SYMNMLEN!;
#else
    memcpy(ext->e.e_name, in->_n._n_name, SYMNMLEN);
#endif
  }

  bfd_h_put_32(abfd,  in->n_value , (bfd_byte *) ext->e_value);
  bfd_h_put_16(abfd,  in->n_scnum , (bfd_byte *) ext->e_scnum);
  if (sizeof(ext->e_type) == 2)
    {
      bfd_h_put_16(abfd,  in->n_type , (bfd_byte *) ext->e_type);
    }
  else
    {
      bfd_h_put_32(abfd,  in->n_type , (bfd_byte *) ext->e_type);
    }
  bfd_h_put_8(abfd,  in->n_sclass , ext->e_sclass);
  bfd_h_put_8(abfd,  in->n_numaux , ext->e_numaux);

  return SYMESZ;
}

static void
coff_swap_aux_in (abfd, ext1, type, class, indx, numaux, in1)
     bfd            *abfd;
     PTR 	      ext1;
     int             type;
     int             class;
     int	      indx ATTRIBUTE_UNUSED;
     int	      numaux ATTRIBUTE_UNUSED;
     PTR 	      in1;
{
  AUXENT    *ext = (AUXENT *)ext1;
  union internal_auxent *in = (union internal_auxent *)in1;

  switch (class) {
  case C_FILE:
    if (ext->x_file.x_fname[0] == 0) {
      in->x_file.x_n.x_zeroes = 0;
      in->x_file.x_n.x_offset = 
	bfd_h_get_32(abfd, (bfd_byte *) ext->x_file.x_n.x_offset);
    } else {
#if FILNMLEN != E_FILNMLEN
      -> Error, we need to cope with truncating or extending FILNMLEN!;
#else
      memcpy (in->x_file.x_fname, ext->x_file.x_fname, FILNMLEN);
#endif
    }
    return;


  case C_STAT:
#ifdef C_LEAFSTAT
  case C_LEAFSTAT:
#endif
  case C_HIDDEN:
    if (type == T_NULL) {
      in->x_scn.x_scnlen = GET_SCN_SCNLEN(abfd, ext);
      in->x_scn.x_nreloc = GET_SCN_NRELOC(abfd, ext);
      in->x_scn.x_nlinno = GET_SCN_NLINNO(abfd, ext);
      in->x_scn.x_checksum = bfd_h_get_32 (abfd,
					   (bfd_byte *) ext->x_scn.x_checksum);
      in->x_scn.x_associated =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_scn.x_associated);
      in->x_scn.x_comdat = bfd_h_get_8 (abfd,
					(bfd_byte *) ext->x_scn.x_comdat);
      return;
    }
    break;
  }

  in->x_sym.x_tagndx.l = bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_tagndx);
#ifndef NO_TVNDX
  in->x_sym.x_tvndx = bfd_h_get_16(abfd, (bfd_byte *) ext->x_sym.x_tvndx);
#endif

  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
    {
      in->x_sym.x_fcnary.x_fcn.x_lnnoptr = GET_FCN_LNNOPTR (abfd, ext);
      in->x_sym.x_fcnary.x_fcn.x_endndx.l = GET_FCN_ENDNDX (abfd, ext);
    }
  else
    {
#if DIMNUM != E_DIMNUM
 #error we need to cope with truncating or extending DIMNUM
#endif
      in->x_sym.x_fcnary.x_ary.x_dimen[0] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      in->x_sym.x_fcnary.x_ary.x_dimen[1] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      in->x_sym.x_fcnary.x_ary.x_dimen[2] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      in->x_sym.x_fcnary.x_ary.x_dimen[3] =
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }

  if (ISFCN(type)) {
    in->x_sym.x_misc.x_fsize = bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_misc.x_fsize);
  }
  else {
    in->x_sym.x_misc.x_lnsz.x_lnno = GET_LNSZ_LNNO(abfd, ext);
    in->x_sym.x_misc.x_lnsz.x_size = GET_LNSZ_SIZE(abfd, ext);
  }
}

static unsigned int
coff_swap_aux_out (abfd, inp, type, class, indx, numaux, extp)
     bfd   *abfd;
     PTR 	inp;
     int   type;
     int   class;
     int   indx ATTRIBUTE_UNUSED;
     int   numaux ATTRIBUTE_UNUSED;
     PTR	extp;
{
  union internal_auxent *in = (union internal_auxent *)inp;
  AUXENT *ext = (AUXENT *)extp;

  memset((PTR)ext, 0, AUXESZ);
  switch (class) {
  case C_FILE:
    if (in->x_file.x_fname[0] == 0) {
      bfd_h_put_32(abfd, 0, (bfd_byte *) ext->x_file.x_n.x_zeroes);
      bfd_h_put_32(abfd,
	      in->x_file.x_n.x_offset,
	      (bfd_byte *) ext->x_file.x_n.x_offset);
    }
    else {
#if FILNMLEN != E_FILNMLEN
      -> Error, we need to cope with truncating or extending FILNMLEN!;
#else
      memcpy (ext->x_file.x_fname, in->x_file.x_fname, FILNMLEN);
#endif
    }
    return AUXESZ;


  case C_STAT:
#ifdef C_LEAFSTAT
  case C_LEAFSTAT:
#endif
  case C_HIDDEN:
    if (type == T_NULL) {
      PUT_SCN_SCNLEN(abfd, in->x_scn.x_scnlen, ext);
      PUT_SCN_NRELOC(abfd, in->x_scn.x_nreloc, ext);
      PUT_SCN_NLINNO(abfd, in->x_scn.x_nlinno, ext);
      bfd_h_put_32 (abfd, in->x_scn.x_checksum,
		    (bfd_byte *) ext->x_scn.x_checksum);
      bfd_h_put_16 (abfd, in->x_scn.x_associated,
		    (bfd_byte *) ext->x_scn.x_associated);
      bfd_h_put_8 (abfd, in->x_scn.x_comdat,
		   (bfd_byte *) ext->x_scn.x_comdat);
      return AUXESZ;
    }
    break;
  }

  bfd_h_put_32(abfd, in->x_sym.x_tagndx.l, (bfd_byte *) ext->x_sym.x_tagndx);
#ifndef NO_TVNDX
  bfd_h_put_16(abfd, in->x_sym.x_tvndx , (bfd_byte *) ext->x_sym.x_tvndx);
#endif

  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
    {
      PUT_FCN_LNNOPTR(abfd,  in->x_sym.x_fcnary.x_fcn.x_lnnoptr, ext);
      PUT_FCN_ENDNDX(abfd,  in->x_sym.x_fcnary.x_fcn.x_endndx.l, ext);
    }
  else
    {
#if DIMNUM != E_DIMNUM
 #error we need to cope with truncating or extending DIMNUM
#endif
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[0],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[1],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[2],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[3],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }

  if (ISFCN (type))
    bfd_h_put_32 (abfd, in->x_sym.x_misc.x_fsize,
	     (bfd_byte *)  ext->x_sym.x_misc.x_fsize);
  else
    {
      PUT_LNSZ_LNNO (abfd, in->x_sym.x_misc.x_lnsz.x_lnno, ext);
      PUT_LNSZ_SIZE (abfd, in->x_sym.x_misc.x_lnsz.x_size, ext);
    }

  return AUXESZ;
}


static void
coff_swap_lineno_in (abfd, ext1, in1)
     bfd            *abfd;
     PTR ext1;
     PTR in1;
{
  LINENO *ext = (LINENO *)ext1;
  struct internal_lineno      *in = (struct internal_lineno *)in1;

  in->l_addr.l_symndx = bfd_h_get_32(abfd, (bfd_byte *) ext->l_addr.l_symndx);
  in->l_lnno = GET_LINENO_LNNO(abfd, ext);
}

static unsigned int
coff_swap_lineno_out (abfd, inp, outp)
     bfd       *abfd;
     PTR	inp;
     PTR	outp;
{
  struct internal_lineno *in = (struct internal_lineno *)inp;
  struct external_lineno *ext = (struct external_lineno *)outp;
  bfd_h_put_32(abfd, in->l_addr.l_symndx, (bfd_byte *)
	  ext->l_addr.l_symndx);

  PUT_LINENO_LNNO (abfd, in->l_lnno, ext);
  return LINESZ;
}



static void
coff_swap_aouthdr_in (abfd, aouthdr_ext1, aouthdr_int1)
     bfd            *abfd;
     PTR aouthdr_ext1;
     PTR aouthdr_int1;
{
  struct internal_extra_pe_aouthdr *a;
  PEAOUTHDR *src = (PEAOUTHDR *)(aouthdr_ext1);
  AOUTHDR        *aouthdr_ext = (AOUTHDR *) aouthdr_ext1;
  struct internal_aouthdr *aouthdr_int = (struct internal_aouthdr *)aouthdr_int1;

  aouthdr_int->magic = bfd_h_get_16(abfd, (bfd_byte *) aouthdr_ext->magic);
  aouthdr_int->vstamp = bfd_h_get_16(abfd, (bfd_byte *) aouthdr_ext->vstamp);
  aouthdr_int->tsize =
    GET_AOUTHDR_TSIZE (abfd, (bfd_byte *) aouthdr_ext->tsize);
  aouthdr_int->dsize =
    GET_AOUTHDR_DSIZE (abfd, (bfd_byte *) aouthdr_ext->dsize);
  aouthdr_int->bsize =
    GET_AOUTHDR_BSIZE (abfd, (bfd_byte *) aouthdr_ext->bsize);
  aouthdr_int->entry =
    GET_AOUTHDR_ENTRY (abfd, (bfd_byte *) aouthdr_ext->entry);
  aouthdr_int->text_start =
    GET_AOUTHDR_TEXT_START (abfd, (bfd_byte *) aouthdr_ext->text_start);
  aouthdr_int->data_start =
    GET_AOUTHDR_DATA_START (abfd, (bfd_byte *) aouthdr_ext->data_start);

  a = &aouthdr_int->pe;
  a->ImageBase = bfd_h_get_32 (abfd, (bfd_byte *) src->ImageBase);
  a->SectionAlignment = bfd_h_get_32 (abfd, (bfd_byte *) src->SectionAlignment);
  a->FileAlignment = bfd_h_get_32 (abfd, (bfd_byte *) src->FileAlignment);
  a->MajorOperatingSystemVersion = 
    bfd_h_get_16 (abfd, (bfd_byte *) src->MajorOperatingSystemVersion);
  a->MinorOperatingSystemVersion = 
    bfd_h_get_16 (abfd, (bfd_byte *) src->MinorOperatingSystemVersion);
  a->MajorImageVersion = bfd_h_get_16 (abfd, (bfd_byte *) src->MajorImageVersion);
  a->MinorImageVersion = bfd_h_get_16 (abfd, (bfd_byte *) src->MinorImageVersion);
  a->MajorSubsystemVersion = bfd_h_get_16 (abfd, (bfd_byte *) src->MajorSubsystemVersion);
  a->MinorSubsystemVersion = bfd_h_get_16 (abfd, (bfd_byte *) src->MinorSubsystemVersion);
  a->Reserved1 = bfd_h_get_32 (abfd, (bfd_byte *) src->Reserved1);
  a->SizeOfImage = bfd_h_get_32 (abfd, (bfd_byte *) src->SizeOfImage);
  a->SizeOfHeaders = bfd_h_get_32 (abfd, (bfd_byte *) src->SizeOfHeaders);
  a->CheckSum = bfd_h_get_32 (abfd, (bfd_byte *) src->CheckSum);
  a->Subsystem = bfd_h_get_16 (abfd, (bfd_byte *) src->Subsystem);
  a->DllCharacteristics = bfd_h_get_16 (abfd, (bfd_byte *) src->DllCharacteristics);
  a->SizeOfStackReserve = bfd_h_get_32 (abfd, (bfd_byte *) src->SizeOfStackReserve);
  a->SizeOfStackCommit = bfd_h_get_32 (abfd, (bfd_byte *) src->SizeOfStackCommit);
  a->SizeOfHeapReserve = bfd_h_get_32 (abfd, (bfd_byte *) src->SizeOfHeapReserve);
  a->SizeOfHeapCommit = bfd_h_get_32 (abfd, (bfd_byte *) src->SizeOfHeapCommit);
  a->LoaderFlags = bfd_h_get_32 (abfd, (bfd_byte *) src->LoaderFlags);
  a->NumberOfRvaAndSizes = bfd_h_get_32 (abfd, (bfd_byte *) src->NumberOfRvaAndSizes);

  {
    int idx;
    for (idx=0; idx < 16; idx++)
      {
	a->DataDirectory[idx].VirtualAddress =
	  bfd_h_get_32 (abfd, (bfd_byte *) src->DataDirectory[idx][0]);
	a->DataDirectory[idx].Size =
	  bfd_h_get_32 (abfd, (bfd_byte *) src->DataDirectory[idx][1]);
      }
  }

  if (aouthdr_int->entry)
    {
      aouthdr_int->entry += a->ImageBase;
      aouthdr_int->entry &= 0xffffffff;
    }
  if (aouthdr_int->tsize) 
    {
      aouthdr_int->text_start += a->ImageBase;
      aouthdr_int->text_start &= 0xffffffff;
    }
  if (aouthdr_int->dsize) 
    {
      aouthdr_int->data_start += a->ImageBase;
      aouthdr_int->data_start &= 0xffffffff;
    }

#ifdef POWERPC_LE_PE
  /* These three fields are normally set up by ppc_relocate_section.
     In the case of reading a file in, we can pick them up from
     the DataDirectory.
  */
  first_thunk_address = a->DataDirectory[12].VirtualAddress ;
  thunk_size = a->DataDirectory[12].Size;
  import_table_size = a->DataDirectory[1].Size;
#endif
}


static void add_data_entry (abfd, aout, idx, name, base)
     bfd *abfd;
     struct internal_extra_pe_aouthdr *aout;
     int idx;
     char *name;
     bfd_vma base;
{
  asection *sec = bfd_get_section_by_name (abfd, name);

  /* add import directory information if it exists */
  if ((sec != NULL)
      && (coff_section_data (abfd, sec) != NULL)
      && (pei_section_data (abfd, sec) != NULL))
    {
      aout->DataDirectory[idx].VirtualAddress = (sec->vma - base) & 0xffffffff;
      aout->DataDirectory[idx].Size = pei_section_data (abfd, sec)->virt_size;
      sec->flags |= SEC_DATA;
    }
}

static unsigned int
coff_swap_aouthdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
{
  struct internal_aouthdr *aouthdr_in = (struct internal_aouthdr *)in;
  struct internal_extra_pe_aouthdr *extra = &pe_data (abfd)->pe_opthdr;
  PEAOUTHDR *aouthdr_out = (PEAOUTHDR *)out;

  bfd_vma sa = extra->SectionAlignment;
  bfd_vma fa = extra->FileAlignment;
  bfd_vma ib = extra->ImageBase ;

  if (aouthdr_in->tsize) 
    {
      aouthdr_in->text_start -= ib;
      aouthdr_in->text_start &= 0xffffffff;
    }
  if (aouthdr_in->dsize) 
    {
      aouthdr_in->data_start -= ib;
      aouthdr_in->data_start &= 0xffffffff;
    }
  if (aouthdr_in->entry) 
    {
      aouthdr_in->entry -= ib;
      aouthdr_in->entry &= 0xffffffff;
    }

#define FA(x)  (((x) + fa -1 ) & (- fa))
#define SA(x)  (((x) + sa -1 ) & (- sa))

  /* We like to have the sizes aligned */

  aouthdr_in->bsize = FA (aouthdr_in->bsize);


  extra->NumberOfRvaAndSizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;

  /* first null out all data directory entries .. */
  memset (extra->DataDirectory, sizeof (extra->DataDirectory), 0);

  add_data_entry (abfd, extra, 0, ".edata", ib);
  add_data_entry (abfd, extra, 1, ".idata", ib);
  add_data_entry (abfd, extra, 2, ".rsrc" ,ib);

#ifdef POWERPC_LE_PE
  /* FIXME: do other PE platforms use this? */
  add_data_entry (abfd, extra, 3, ".pdata" ,ib);
#endif

  add_data_entry (abfd, extra, 5, ".reloc", ib);

#ifdef POWERPC_LE_PE
  /* On the PPC NT system, this field is set up as follows. It is
     not an "officially" reserved field, so it currently has no title.
     first_thunk_address is idata$5, and the thunk_size is the size
     of the idata$5 chunk of the idata section.
  */
  extra->DataDirectory[12].VirtualAddress = first_thunk_address;
  extra->DataDirectory[12].Size = thunk_size;

  /* On the PPC NT system, the size of the directory entry is not the
     size of the entire section. It's actually offset to the end of 
     the idata$3 component of the idata section. This is the size of
     the entire import table. (also known as the start of idata$4)
  */
  extra->DataDirectory[1].Size = import_table_size;
#endif

  {
    asection *sec;
    bfd_vma dsize= 0;
    bfd_vma isize = SA(abfd->sections->filepos);
    bfd_vma tsize= 0;

    for (sec = abfd->sections; sec; sec = sec->next)
      {
	int rounded = FA(sec->_raw_size);

	if (sec->flags & SEC_DATA) 
	  dsize += rounded;
	if (sec->flags & SEC_CODE)
	  tsize += rounded;
	isize += SA(rounded);
      }

    aouthdr_in->dsize = dsize;
    aouthdr_in->tsize = tsize;
    extra->SizeOfImage = isize;
  }

  extra->SizeOfHeaders = abfd->sections->filepos;
  bfd_h_put_16(abfd, aouthdr_in->magic, (bfd_byte *) aouthdr_out->standard.magic);

#ifdef POWERPC_LE_PE
  /* this little piece of magic sets the "linker version" field to 2.60 */
  bfd_h_put_16(abfd, 2  + 60 * 256, (bfd_byte *) aouthdr_out->standard.vstamp);
d190 1
a190 2
  /* this little piece of magic sets the "linker version" field to 2.55 */
  bfd_h_put_16(abfd, 2  + 55 * 256, (bfd_byte *) aouthdr_out->standard.vstamp);
a192 66
  PUT_AOUTHDR_TSIZE (abfd, aouthdr_in->tsize, (bfd_byte *) aouthdr_out->standard.tsize);
  PUT_AOUTHDR_DSIZE (abfd, aouthdr_in->dsize, (bfd_byte *) aouthdr_out->standard.dsize);
  PUT_AOUTHDR_BSIZE (abfd, aouthdr_in->bsize, (bfd_byte *) aouthdr_out->standard.bsize);
  PUT_AOUTHDR_ENTRY (abfd, aouthdr_in->entry, (bfd_byte *) aouthdr_out->standard.entry);
  PUT_AOUTHDR_TEXT_START (abfd, aouthdr_in->text_start,
			  (bfd_byte *) aouthdr_out->standard.text_start);

  PUT_AOUTHDR_DATA_START (abfd, aouthdr_in->data_start,
			  (bfd_byte *) aouthdr_out->standard.data_start);


  bfd_h_put_32 (abfd, extra->ImageBase, 
		(bfd_byte *) aouthdr_out->ImageBase);
  bfd_h_put_32 (abfd, extra->SectionAlignment,
		(bfd_byte *) aouthdr_out->SectionAlignment);
  bfd_h_put_32 (abfd, extra->FileAlignment,
		(bfd_byte *) aouthdr_out->FileAlignment);
  bfd_h_put_16 (abfd, extra->MajorOperatingSystemVersion,
		(bfd_byte *) aouthdr_out->MajorOperatingSystemVersion);
  bfd_h_put_16 (abfd, extra->MinorOperatingSystemVersion,
		(bfd_byte *) aouthdr_out->MinorOperatingSystemVersion);
  bfd_h_put_16 (abfd, extra->MajorImageVersion,
		(bfd_byte *) aouthdr_out->MajorImageVersion);
  bfd_h_put_16 (abfd, extra->MinorImageVersion,
		(bfd_byte *) aouthdr_out->MinorImageVersion);
  bfd_h_put_16 (abfd, extra->MajorSubsystemVersion,
		(bfd_byte *) aouthdr_out->MajorSubsystemVersion);
  bfd_h_put_16 (abfd, extra->MinorSubsystemVersion,
		(bfd_byte *) aouthdr_out->MinorSubsystemVersion);
  bfd_h_put_32 (abfd, extra->Reserved1,
		(bfd_byte *) aouthdr_out->Reserved1);
  bfd_h_put_32 (abfd, extra->SizeOfImage,
		(bfd_byte *) aouthdr_out->SizeOfImage);
  bfd_h_put_32 (abfd, extra->SizeOfHeaders,
		(bfd_byte *) aouthdr_out->SizeOfHeaders);
  bfd_h_put_32 (abfd, extra->CheckSum,
		(bfd_byte *) aouthdr_out->CheckSum);
  bfd_h_put_16 (abfd, extra->Subsystem,
		(bfd_byte *) aouthdr_out->Subsystem);
  bfd_h_put_16 (abfd, extra->DllCharacteristics,
		(bfd_byte *) aouthdr_out->DllCharacteristics);
  bfd_h_put_32 (abfd, extra->SizeOfStackReserve,
		(bfd_byte *) aouthdr_out->SizeOfStackReserve);
  bfd_h_put_32 (abfd, extra->SizeOfStackCommit,
		(bfd_byte *) aouthdr_out->SizeOfStackCommit);
  bfd_h_put_32 (abfd, extra->SizeOfHeapReserve,
		(bfd_byte *) aouthdr_out->SizeOfHeapReserve);
  bfd_h_put_32 (abfd, extra->SizeOfHeapCommit,
		(bfd_byte *) aouthdr_out->SizeOfHeapCommit);
  bfd_h_put_32 (abfd, extra->LoaderFlags,
		(bfd_byte *) aouthdr_out->LoaderFlags);
  bfd_h_put_32 (abfd, extra->NumberOfRvaAndSizes,
		(bfd_byte *) aouthdr_out->NumberOfRvaAndSizes);
  {
    int idx;
    for (idx=0; idx < 16; idx++)
      {
	bfd_h_put_32 (abfd, extra->DataDirectory[idx].VirtualAddress,
		      (bfd_byte *) aouthdr_out->DataDirectory[idx][0]);
	bfd_h_put_32 (abfd, extra->DataDirectory[idx].Size,
		      (bfd_byte *) aouthdr_out->DataDirectory[idx][1]);
      }
  }

  return AOUTSZ;
}
a238 918
static unsigned int
coff_swap_scnhdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
{
  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *)in;
  SCNHDR *scnhdr_ext = (SCNHDR *)out;
  unsigned int ret = SCNHSZ;
  bfd_vma ps;
  bfd_vma ss;

  memcpy(scnhdr_ext->s_name, scnhdr_int->s_name, sizeof(scnhdr_int->s_name));

  PUT_SCNHDR_VADDR (abfd, 
		    ((scnhdr_int->s_vaddr 
		      - pe_data(abfd)->pe_opthdr.ImageBase)
		     & 0xffffffff),
		    (bfd_byte *) scnhdr_ext->s_vaddr);

  /* NT wants the size data to be rounded up to the next NT_FILE_ALIGNMENT
     value except for the BSS section, its s_size should be 0 */


  if (strcmp (scnhdr_int->s_name, _BSS) == 0) 
    {
      ps = scnhdr_int->s_size;
      ss = 0;
    }
  else
    {
      ps = scnhdr_int->s_paddr;
      ss = scnhdr_int->s_size;
    }

  PUT_SCNHDR_SIZE (abfd, ss,
		   (bfd_byte *) scnhdr_ext->s_size);


  PUT_SCNHDR_PADDR (abfd, ps, (bfd_byte *) scnhdr_ext->s_paddr);

  PUT_SCNHDR_SCNPTR (abfd, scnhdr_int->s_scnptr,
		     (bfd_byte *) scnhdr_ext->s_scnptr);
  PUT_SCNHDR_RELPTR (abfd, scnhdr_int->s_relptr,
		     (bfd_byte *) scnhdr_ext->s_relptr);
  PUT_SCNHDR_LNNOPTR (abfd, scnhdr_int->s_lnnoptr,
		      (bfd_byte *) scnhdr_ext->s_lnnoptr);

  /* Extra flags must be set when dealing with NT.  All sections should also
     have the IMAGE_SCN_MEM_READ (0x40000000) flag set.  In addition, the
     .text section must have IMAGE_SCN_MEM_EXECUTE (0x20000000) and the data
     sections (.idata, .data, .bss, .CRT) must have IMAGE_SCN_MEM_WRITE set
     (this is especially important when dealing with the .idata section since
     the addresses for routines from .dlls must be overwritten).  If .reloc
     section data is ever generated, we must add IMAGE_SCN_MEM_DISCARDABLE
     (0x02000000).  Also, the resource data should also be read and
     writable.  */

  /* FIXME: alignment is also encoded in this field, at least on ppc (krk) */
  /* FIXME: even worse, I don't see how to get the original alignment field*/
  /*        back...                                                        */

  /* FIXME: Basing this on section names is bogus.  Also, this should
     be in sec_to_styp_flags.  */

  {
    int flags = scnhdr_int->s_flags;
    if (strcmp (scnhdr_int->s_name, ".data")  == 0 ||
	strcmp (scnhdr_int->s_name, ".CRT")   == 0 ||
	strcmp (scnhdr_int->s_name, ".bss")   == 0)
      flags |= IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;
    else if (strcmp (scnhdr_int->s_name, ".text") == 0)
      flags |= IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE;
    else if (strcmp (scnhdr_int->s_name, ".reloc") == 0)
      flags = (SEC_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE
	       | IMAGE_SCN_MEM_SHARED);
    else if (strcmp (scnhdr_int->s_name, ".idata") == 0)
      flags = IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | SEC_DATA;     
    else if (strcmp (scnhdr_int->s_name, ".rdata") == 0
	     || strcmp (scnhdr_int->s_name, ".edata") == 0)
      flags =  IMAGE_SCN_MEM_READ | SEC_DATA;     
    else if (strcmp (scnhdr_int->s_name, ".pdata") == 0)
      flags = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_ALIGN_4BYTES |
			  IMAGE_SCN_MEM_READ ;
    /* Remember this field is a max of 8 chars, so the null is _not_ there
       for an 8 character name like ".reldata". (yep. Stupid bug) */
    else if (strncmp (scnhdr_int->s_name, ".reldata", 8) == 0)
      flags =  IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_ALIGN_8BYTES |
	       IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE ;
    else if (strcmp (scnhdr_int->s_name, ".ydata") == 0)
      flags =  IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_ALIGN_8BYTES |
	       IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE ;
    else if (strncmp (scnhdr_int->s_name, ".drectve", 8) == 0)
      flags =  IMAGE_SCN_LNK_INFO | IMAGE_SCN_LNK_REMOVE ;
    else if (strncmp (scnhdr_int->s_name, ".stab", 5) == 0)
      flags |= (IMAGE_SCN_LNK_INFO | IMAGE_SCN_MEM_DISCARDABLE
		| IMAGE_SCN_MEM_SHARED | IMAGE_SCN_MEM_READ);
    else if (strcmp (scnhdr_int->s_name, ".rsrc")  == 0)
      flags |= IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_SHARED;
    else
      {
	flags |= IMAGE_SCN_MEM_READ;
	if (! (flags & SEC_READONLY))
	  flags |= IMAGE_SCN_MEM_WRITE;
	if (flags & SEC_SHARED)
	  flags |= IMAGE_SCN_MEM_SHARED;
      }

    bfd_h_put_32(abfd, flags, (bfd_byte *) scnhdr_ext->s_flags);
  }

  if (scnhdr_int->s_nlnno <= 0xffff)
    bfd_h_put_16(abfd, scnhdr_int->s_nlnno, (bfd_byte *) scnhdr_ext->s_nlnno);
  else
    {
      (*_bfd_error_handler) (_("%s: line number overflow: 0x%lx > 0xffff"),
			     bfd_get_filename (abfd),
			     scnhdr_int->s_nlnno);
      bfd_set_error (bfd_error_file_truncated);
      bfd_h_put_16 (abfd, 0xffff, (bfd_byte *) scnhdr_ext->s_nlnno);
      ret = 0;
    }
  if (scnhdr_int->s_nreloc <= 0xffff)
    bfd_h_put_16(abfd, scnhdr_int->s_nreloc, (bfd_byte *) scnhdr_ext->s_nreloc);
  else
    {
      (*_bfd_error_handler) (_("%s: reloc overflow: 0x%lx > 0xffff"),
			     bfd_get_filename (abfd),
			     scnhdr_int->s_nreloc);
      bfd_set_error (bfd_error_file_truncated);
      bfd_h_put_16 (abfd, 0xffff, (bfd_byte *) scnhdr_ext->s_nreloc);
      ret = 0;
    }
  return ret;
}

static char * dir_names[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] = 
{
  N_ ("Export Directory [.edata (or where ever we found it)]"),
  N_ ("Import Directory [parts of .idata]"),
  N_ ("Resource Directory [.rsrc]"),
  N_ ("Exception Directory [.pdata]"),
  N_ ("Security Directory"),
  N_ ("Base Relocation Directory [.reloc]"),
  N_ ("Debug Directory"),
  N_ ("Description Directory"),
  N_ ("Special Directory"),
  N_ ("Thread Storage Directory [.tls]"),
  N_ ("Load Configuration Directory"),
  N_ ("Bound Import Directory"),
  N_ ("Import Address Table Directory"),
  N_ ("Reserved"),
  N_ ("Reserved"),
  N_ ("Reserved")
};

/**********************************************************************/
static boolean
pe_print_idata(abfd, vfile)
     bfd *abfd;
     PTR vfile;
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".idata");
  unsigned long adj;

#ifdef POWERPC_LE_PE
  asection *rel_section = bfd_get_section_by_name (abfd, ".reldata");
#endif

  bfd_size_type datasize;
  bfd_size_type dataoff;
  bfd_size_type secsize;
  bfd_size_type i;
  bfd_size_type start, stop;
  int onaline = 20;

  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;

  if (section != NULL)
    {
      datasize = bfd_section_size (abfd, section);
      dataoff = 0;

      if (datasize == 0)
	return true;
    }
  else
    {
      bfd_vma addr, size;

      addr = extra->DataDirectory[1].VirtualAddress;
      size = extra->DataDirectory[1].Size;

      if (addr == 0 || size == 0)
	return true;

      for (section = abfd->sections; section != NULL; section = section->next)
	{
	  if (section->vma - extra->ImageBase <= addr
	      && ((section->vma - extra->ImageBase
		   + bfd_section_size (abfd, section))
		  >= addr + size))
	    break;
	}
      if (section == NULL)
	return true;

      /* For some reason the import table size is not reliable.  The
         import data will extend past the indicated size, and before
         the indicated address.  */
      dataoff = addr - (section->vma - extra->ImageBase);
      datasize = size;
    }

#ifdef POWERPC_LE_PE
  if (rel_section != 0 && bfd_section_size (abfd, rel_section) != 0)
    {
      /* The toc address can be found by taking the starting address,
	 which on the PPC locates a function descriptor. The descriptor
	 consists of the function code starting address followed by the
	 address of the toc. The starting address we get from the bfd,
	 and the descriptor is supposed to be in the .reldata section. 
      */

      bfd_vma loadable_toc_address;
      bfd_vma toc_address;
      bfd_vma start_address;
      bfd_byte *data = 0;
      int offset;
      data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, 
								 rel_section));
      if (data == NULL && bfd_section_size (abfd, rel_section) != 0)
	return false;

      datasize = bfd_section_size (abfd, rel_section);
  
      bfd_get_section_contents (abfd, 
				rel_section, 
				(PTR) data, 0, 
				bfd_section_size (abfd, rel_section));

      offset = abfd->start_address - rel_section->vma;

      start_address = bfd_get_32(abfd, data+offset);
      loadable_toc_address = bfd_get_32(abfd, data+offset+4);
      toc_address = loadable_toc_address - 32768;

      fprintf(file,
	      _("\nFunction descriptor located at the start address: %04lx\n"),
	      (unsigned long int) (abfd->start_address));
      fprintf (file,
	       _("\tcode-base %08lx toc (loadable/actual) %08lx/%08lx\n"), 
	       start_address, loadable_toc_address, toc_address);
    }
  else 
    {
      fprintf(file,
	      _("\nNo reldata section! Function descriptor not decoded.\n"));
    }
#endif

  fprintf(file,
	  _("\nThe Import Tables (interpreted .idata section contents)\n"));
  fprintf(file,
	  _(" vma:            Hint    Time      Forward  DLL       First\n"));
  fprintf(file,
	  _("                 Table   Stamp     Chain    Name      Thunk\n"));

  secsize = bfd_section_size (abfd, section);
  data = (bfd_byte *) bfd_malloc (secsize);
  if (data == NULL && secsize != 0)
    return false;

  if (! bfd_get_section_contents (abfd, section, (PTR) data, 0, secsize))
    return false;

  adj = (extra->ImageBase - section->vma) & 0xffffffff;

  start = dataoff;
  stop = dataoff + datasize;
  for (i = start; i < stop; i += onaline)
    {
      bfd_vma hint_addr;
      bfd_vma time_stamp;
      bfd_vma forward_chain;
      bfd_vma dll_name;
      bfd_vma first_thunk;
      int idx = 0;
      bfd_size_type j;
      char *dll;

      fprintf (file,
	       " %08lx\t", 
	       (unsigned long int) (i + section->vma + dataoff));
      
      if (i+20 > stop)
	{
	  /* check stuff */
	  ;
	}
      
      hint_addr = bfd_get_32(abfd, data+i);
      time_stamp = bfd_get_32(abfd, data+i+4);
      forward_chain = bfd_get_32(abfd, data+i+8);
      dll_name = bfd_get_32(abfd, data+i+12);
      first_thunk = bfd_get_32(abfd, data+i+16);
      
      fprintf(file, "%08lx %08lx %08lx %08lx %08lx\n",
	      hint_addr,
	      time_stamp,
	      forward_chain,
	      dll_name,
	      first_thunk);

      if (hint_addr == 0 && first_thunk == 0)
	break;

      /* the image base is present in the section->vma */
      dll = (char *) data + dll_name + adj;
      fprintf(file, _("\n\tDLL Name: %s\n"), dll);

      if (hint_addr != 0)
	{
	  fprintf (file, _("\tvma:  Hint/Ord Member-Name\n"));

	  idx = hint_addr + adj;

	  for (j = 0; j < stop; j += 4)
	    {
	      unsigned long member = bfd_get_32 (abfd, data + idx + j);

	      if (member == 0)
		break;
	      if (member & 0x80000000)
		fprintf (file, "\t%04lx\t %4lu", member,
			 member & 0x7fffffff);
	      else
		{
		  int ordinal;
		  char *member_name;

		  ordinal = bfd_get_16 (abfd, data + member + adj);
		  member_name = (char *) data + member + adj + 2;
		  fprintf (file, "\t%04lx\t %4d  %s",
			   member, ordinal, member_name);
		}

	      /* If the time stamp is not zero, the import address
                 table holds actual addresses.  */
	      if (time_stamp != 0
		  && first_thunk != 0
		  && first_thunk != hint_addr)
		fprintf (file, "\t%04lx",
			 bfd_get_32 (abfd, data + first_thunk + adj + j));

	      fprintf (file, "\n");
	    }
	}

      if (hint_addr != first_thunk && time_stamp == 0)
	{
	  int differ = 0;
	  int idx2;

	  idx2 = first_thunk + adj;

	  for (j=0;j<stop;j+=4)
	    {
	      int ordinal;
	      char *member_name;
	      bfd_vma hint_member = 0;
	      bfd_vma iat_member;

	      if (hint_addr != 0)
		hint_member = bfd_get_32 (abfd, data + idx + j);
	      iat_member = bfd_get_32 (abfd, data + idx2 + j);

	      if (hint_addr == 0 && iat_member == 0)
		break;

	      if (hint_addr == 0 || hint_member != iat_member)
		{
		  if (differ == 0)
		    {
		      fprintf (file, 
			       _("\tThe Import Address Table (difference found)\n"));
		      fprintf(file, _("\tvma:  Hint/Ord Member-Name\n"));
		      differ = 1;
		    }
		  if (iat_member == 0)
		    {
		      fprintf(file,
			      _("\t>>> Ran out of IAT members!\n"));
		    }
		  else 
		    {
		      ordinal = bfd_get_16(abfd,
					   data + iat_member + adj);
		      member_name = (char *) data + iat_member + adj + 2;
		      fprintf(file, "\t%04lx\t %4d  %s\n",
			      iat_member, ordinal, member_name);
		    }
		}

	      if (hint_addr != 0 && hint_member == 0)
		break;
	    }
	  if (differ == 0)
	    {
	      fprintf(file,
		      _("\tThe Import Address Table is identical\n"));
	    }
	}

      fprintf(file, "\n");

    }

  free (data);

  return true;
}

static boolean
pe_print_edata (abfd, vfile)
     bfd *abfd;
     PTR vfile;
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".edata");

  bfd_size_type datasize;
  bfd_size_type dataoff;
  bfd_size_type i;

  int adj;
  struct EDT_type 
    {
      long export_flags;             /* reserved - should be zero */
      long time_stamp;
      short major_ver;
      short minor_ver;
      bfd_vma name;                  /* rva - relative to image base */
      long base;                     /* ordinal base */
      unsigned long num_functions;   /* Number in the export address table */
      unsigned long num_names;       /* Number in the name pointer table */
      bfd_vma eat_addr;    /* rva to the export address table */
      bfd_vma npt_addr;        /* rva to the Export Name Pointer Table */
      bfd_vma ot_addr; /* rva to the Ordinal Table */
    } edt;

  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;

  if (section != NULL)
    {
      datasize = bfd_section_size (abfd, section);
      dataoff = 0;
    }
  else
    {
      bfd_vma addr, size;

      addr = extra->DataDirectory[0].VirtualAddress;
      size = extra->DataDirectory[0].Size;

      if (addr == 0 || size == 0)
	return true;

      for (section = abfd->sections; section != NULL; section = section->next)
	{
	  if (section->vma - extra->ImageBase <= addr
	      && ((section->vma - extra->ImageBase
		   + bfd_section_size (abfd, section))
		  >= addr + size))
	    break;
	}
      if (section == NULL)
	return true;

      datasize = size;
      dataoff = addr - (section->vma - extra->ImageBase);
    }

  data = (bfd_byte *) bfd_malloc (datasize);
  if (data == NULL && datasize != 0)
    return false;

  if (! bfd_get_section_contents (abfd, section, (PTR) data, dataoff,
				  datasize))
    return false;

  /* Go get Export Directory Table */
  edt.export_flags   = bfd_get_32(abfd, data+0); 
  edt.time_stamp     = bfd_get_32(abfd, data+4);
  edt.major_ver      = bfd_get_16(abfd, data+8);
  edt.minor_ver      = bfd_get_16(abfd, data+10);
  edt.name           = bfd_get_32(abfd, data+12);
  edt.base           = bfd_get_32(abfd, data+16);
  edt.num_functions  = bfd_get_32(abfd, data+20); 
  edt.num_names      = bfd_get_32(abfd, data+24); 
  edt.eat_addr       = bfd_get_32(abfd, data+28);
  edt.npt_addr       = bfd_get_32(abfd, data+32); 
  edt.ot_addr        = bfd_get_32(abfd, data+36);

  adj = (extra->ImageBase - (section->vma + dataoff)) & 0xffffffff;


  /* Dump the EDT first first */
  fprintf(file,
	  _("\nThe Export Tables (interpreted .edata section contents)\n\n"));

  fprintf(file,
	  _("Export Flags \t\t\t%lx\n"), (unsigned long) edt.export_flags);

  fprintf(file,
	  _("Time/Date stamp \t\t%lx\n"), (unsigned long) edt.time_stamp);

  fprintf(file,
	  _("Major/Minor \t\t\t%d/%d\n"), edt.major_ver, edt.minor_ver);

  fprintf (file,
	   _("Name \t\t\t\t"));
  fprintf_vma (file, edt.name);
  fprintf (file,
	   " %s\n", data + edt.name + adj);

  fprintf(file,
	  _("Ordinal Base \t\t\t%ld\n"), edt.base);

  fprintf(file,
	  _("Number in:\n"));

  fprintf(file,
	  _("\tExport Address Table \t\t%lx\n"),
	  edt.num_functions);

  fprintf(file,
	  _("\t[Name Pointer/Ordinal] Table\t%lu\n"), edt.num_names);

  fprintf(file,
	  _("Table Addresses\n"));

  fprintf (file,
	   _("\tExport Address Table \t\t"));
  fprintf_vma (file, edt.eat_addr);
  fprintf (file, "\n");

  fprintf (file,
	  _("\tName Pointer Table \t\t"));
  fprintf_vma (file, edt.npt_addr);
  fprintf (file, "\n");

  fprintf (file,
	   _("\tOrdinal Table \t\t\t"));
  fprintf_vma (file, edt.ot_addr);
  fprintf (file, "\n");

  
  /* The next table to find si the Export Address Table. It's basically
     a list of pointers that either locate a function in this dll, or
     forward the call to another dll. Something like:
      typedef union 
      {
        long export_rva;
        long forwarder_rva;
      } export_address_table_entry;
  */

  fprintf(file,
	  _("\nExport Address Table -- Ordinal Base %ld\n"),
	  edt.base);

  for (i = 0; i < edt.num_functions; ++i)
    {
      bfd_vma eat_member = bfd_get_32 (abfd, 
				       data + edt.eat_addr + (i * 4) + adj);
      bfd_vma eat_actual = (extra->ImageBase + eat_member) & 0xffffffff;
      bfd_vma edata_start = bfd_get_section_vma (abfd,section) + dataoff;
      bfd_vma edata_end = edata_start + datasize;

      if (eat_member == 0)
	continue;

      if (edata_start < eat_actual && eat_actual < edata_end) 
	{
	  /* this rva is to a name (forwarding function) in our section */
	  /* Should locate a function descriptor */
	  fprintf(file,
		  "\t[%4ld] +base[%4ld] %04lx %s -- %s\n", 
		  (long) i, (long) (i + edt.base), eat_member,
		  "Forwarder RVA", data + eat_member + adj);
	}
      else
	{
	  /* Should locate a function descriptor in the reldata section */
	  fprintf(file,
		  "\t[%4ld] +base[%4ld] %04lx %s\n", 
		  (long) i, (long) (i + edt.base), eat_member, "Export RVA");
	}
    }

  /* The Export Name Pointer Table is paired with the Export Ordinal Table */
  /* Dump them in parallel for clarity */
  fprintf(file,
	  _("\n[Ordinal/Name Pointer] Table\n"));

  for (i = 0; i < edt.num_names; ++i)
    {
      bfd_vma name_ptr = bfd_get_32(abfd, 
				    data + 
				    edt.npt_addr
				    + (i*4) + adj);
      
      char *name = (char *) data + name_ptr + adj;

      bfd_vma ord = bfd_get_16(abfd, 
				    data + 
				    edt.ot_addr
				    + (i*2) + adj);
      fprintf(file,
	      "\t[%4ld] %s\n", (long) ord, name);

    }

  free (data);

  return true;
}

static boolean
pe_print_pdata (abfd, vfile)
     bfd  *abfd;
     PTR vfile;
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".pdata");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;
  int onaline = 20;

  if (section == 0)
    return true;

  stop = bfd_section_size (abfd, section);
  if ((stop % onaline) != 0)
    fprintf (file, _("Warning, .pdata section size (%ld) is not a multiple of %d\n"),
	     (long)stop, onaline);

  fprintf(file,
	  _("\nThe Function Table (interpreted .pdata section contents)\n"));
  fprintf(file,
	  _(" vma:\t\tBegin    End      EH       EH       PrologEnd\n"));
  fprintf(file,
	  _("     \t\tAddress  Address  Handler  Data     Address\n"));

  if (bfd_section_size (abfd, section) == 0)
    return true;

  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, section));
  datasize = bfd_section_size (abfd, section);
  if (data == NULL && datasize != 0)
    return false;

  bfd_get_section_contents (abfd, 
			    section, 
			    (PTR) data, 0, 
			    bfd_section_size (abfd, section));

  start = 0;

  for (i = start; i < stop; i += onaline)
    {
      bfd_vma begin_addr;
      bfd_vma end_addr;
      bfd_vma eh_handler;
      bfd_vma eh_data;
      bfd_vma prolog_end_addr;

      if (i+20 > stop)
	  break;
      
      begin_addr = bfd_get_32(abfd, data+i);
      end_addr = bfd_get_32(abfd, data+i+4);
      eh_handler = bfd_get_32(abfd, data+i+8);
      eh_data = bfd_get_32(abfd, data+i+12);
      prolog_end_addr = bfd_get_32(abfd, data+i+16);
      
      if (begin_addr == 0 && end_addr == 0 && eh_handler == 0
	  && eh_data == 0 && prolog_end_addr == 0)
	{
	  /* We are probably into the padding of the
	     section now */
	  break;
	}

      fprintf (file,
	       " %08lx\t", 
	       (unsigned long int) (i + section->vma));

      fprintf(file, "%08lx %08lx %08lx %08lx %08lx",
	      begin_addr,
	      end_addr,
	      eh_handler,
	      eh_data,
	      prolog_end_addr);

#ifdef POWERPC_LE_PE
      if (eh_handler == 0 && eh_data != 0)
	{
	  /* Special bits here, although the meaning may */
	  /* be a little mysterious. The only one I know */
	  /* for sure is 0x03.                           */
	  /* Code Significance                           */
	  /* 0x00 None                                   */
	  /* 0x01 Register Save Millicode                */
	  /* 0x02 Register Restore Millicode             */
	  /* 0x03 Glue Code Sequence                     */
	  switch (eh_data)
	    {
	    case 0x01:
	      fprintf(file, _(" Register save millicode"));
	      break;
	    case 0x02:
	      fprintf(file, _(" Register restore millicode"));
	      break;
	    case 0x03:
	      fprintf(file, _(" Glue code sequence"));
	      break;
	    default:
	      break;
	    }
	}
#endif	   
      fprintf(file, "\n");
    }

  free (data);

  return true;
}

static const char *tbl[6] =
{
"ABSOLUTE",
"HIGH",
"LOW",
"HIGHLOW",
"HIGHADJ",
"MIPS_JMPADDR"
};

static boolean
pe_print_reloc (abfd, vfile)
     bfd *abfd;
     PTR vfile;
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".reloc");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;

  if (section == 0)
    return true;

  if (bfd_section_size (abfd, section) == 0)
    return true;

  fprintf(file,
	  _("\n\nPE File Base Relocations (interpreted .reloc section contents)\n"));

  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, section));
  datasize = bfd_section_size (abfd, section);
  if (data == NULL && datasize != 0)
    return false;

  bfd_get_section_contents (abfd, 
			    section, 
			    (PTR) data, 0, 
			    bfd_section_size (abfd, section));

  start = 0;

  stop = bfd_section_size (abfd, section);

  for (i = start; i < stop;)
    {
      int j;
      bfd_vma virtual_address;
      long number, size;

      /* The .reloc section is a sequence of blocks, with a header consisting
	 of two 32 bit quantities, followed by a number of 16 bit entries */

      virtual_address = bfd_get_32(abfd, data+i);
      size = bfd_get_32(abfd, data+i+4);
      number = (size - 8) / 2;

      if (size == 0) 
	{
	  break;
	}

      fprintf (file,
	       _("\nVirtual Address: %08lx Chunk size %ld (0x%lx) Number of fixups %ld\n"),
	       virtual_address, size, size, number);

      for (j = 0; j < number; ++j)
	{
	  unsigned short e = bfd_get_16(abfd, data + i + 8 + j*2);
	  int t =   (e & 0xF000) >> 12;
	  int off = e & 0x0FFF;

	  if (t > 5) 
	    abort();

	  fprintf(file,
		  _("\treloc %4d offset %4x [%4lx] %s\n"), 
		  j, off, (long) (off + virtual_address), tbl[t]);
	  
	}
      i += size;
    }

  free (data);

  return true;
}

static boolean
pe_print_private_bfd_data (abfd, vfile)
     bfd *abfd;
     PTR vfile;
{
  FILE *file = (FILE *) vfile;
  int j;
  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *i = &pe->pe_opthdr;

  /* The MS dumpbin program reportedly ands with 0xff0f before
     printing the characteristics field.  Not sure why.  No reason to
     emulate it here.  */
  fprintf (file, _("\nCharacteristics 0x%x\n"), pe->real_flags);
#undef PF
#define PF(x, y)    if (pe->real_flags & x) { fprintf (file, "\t%s\n", y); }
  PF (F_RELFLG, "relocations stripped");
  PF (F_EXEC, "executable");
  PF (F_LNNO, "line numbers stripped");
  PF (F_LSYMS, "symbols stripped");
  PF (0x80, "little endian");
  PF (F_AR32WR, "32 bit words");
  PF (0x200, "debugging information removed");
  PF (0x1000, "system file");
  PF (F_DLL, "DLL");
  PF (0x8000, "big endian");
#undef PF

  fprintf (file,"\nImageBase\t\t");
  fprintf_vma (file, i->ImageBase);
  fprintf (file,"\nSectionAlignment\t");
  fprintf_vma (file, i->SectionAlignment);
  fprintf (file,"\nFileAlignment\t\t");
  fprintf_vma (file, i->FileAlignment);
  fprintf (file,"\nMajorOSystemVersion\t%d\n", i->MajorOperatingSystemVersion);
  fprintf (file,"MinorOSystemVersion\t%d\n", i->MinorOperatingSystemVersion);
  fprintf (file,"MajorImageVersion\t%d\n", i->MajorImageVersion);
  fprintf (file,"MinorImageVersion\t%d\n", i->MinorImageVersion);
  fprintf (file,"MajorSubsystemVersion\t%d\n", i->MajorSubsystemVersion);
  fprintf (file,"MinorSubsystemVersion\t%d\n", i->MinorSubsystemVersion);
  fprintf (file,"Reserved1\t\t%08lx\n", i->Reserved1);
  fprintf (file,"SizeOfImage\t\t%08lx\n", i->SizeOfImage);
  fprintf (file,"SizeOfHeaders\t\t%08lx\n", i->SizeOfHeaders);
  fprintf (file,"CheckSum\t\t%08lx\n", i->CheckSum);
  fprintf (file,"Subsystem\t\t%08x\n", i->Subsystem);
  fprintf (file,"DllCharacteristics\t%08x\n", i->DllCharacteristics);
  fprintf (file,"SizeOfStackReserve\t");
  fprintf_vma (file, i->SizeOfStackReserve);
  fprintf (file,"\nSizeOfStackCommit\t");
  fprintf_vma (file, i->SizeOfStackCommit);
  fprintf (file,"\nSizeOfHeapReserve\t");
  fprintf_vma (file, i->SizeOfHeapReserve);
  fprintf (file,"\nSizeOfHeapCommit\t");
  fprintf_vma (file, i->SizeOfHeapCommit);
  fprintf (file,"\nLoaderFlags\t\t%08lx\n", i->LoaderFlags);
  fprintf (file,"NumberOfRvaAndSizes\t%08lx\n", i->NumberOfRvaAndSizes);

  fprintf (file,"\nThe Data Directory\n");
  for (j = 0; j < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; j++) 
    {
      fprintf (file, "Entry %1x ", j);
      fprintf_vma (file, i->DataDirectory[j].VirtualAddress);
      fprintf (file, " %08lx ", i->DataDirectory[j].Size);
      fprintf (file, "%s\n", dir_names[j]);
    }

  pe_print_idata (abfd, vfile);
  pe_print_edata (abfd, vfile);
  pe_print_pdata (abfd, vfile);
  pe_print_reloc (abfd, vfile);

  if (pe_saved_coff_bfd_print_private_bfd_data != NULL)
    {
      fputc ('\n', file);
  
      return pe_saved_coff_bfd_print_private_bfd_data (abfd, vfile);
    }

  return true;
}

d253 2
d312 16
d329 2
a334 12
#ifdef coff_bfd_copy_private_bfd_data
static boolean (*pe_saved_coff_bfd_copy_private_bfd_data)
     PARAMS ((bfd *, bfd *))
     = coff_bfd_copy_private_bfd_data;
#undef coff_bfd_copy_private_bfd_data
#else
static boolean (*pe_saved_coff_bfd_copy_private_bfd_data)
     PARAMS ((bfd *, bfd *))
     = NULL;
#endif
#define coff_bfd_copy_private_bfd_data pe_bfd_copy_private_bfd_data

d339 2
a340 7
  /* One day we may try to grok other private data.  */
  if (ibfd->xvec->flavour != bfd_target_coff_flavour
      || obfd->xvec->flavour != bfd_target_coff_flavour)
    return true;

  pe_data (obfd)->pe_opthdr = pe_data (ibfd)->pe_opthdr;
  pe_data (obfd)->dll = pe_data (ibfd)->dll;
a343 44
  
  return true;
}

#ifdef COFF_IMAGE_WITH_PE

/* Copy private section data.  */

#define coff_bfd_copy_private_section_data pe_bfd_copy_private_section_data

static boolean pe_bfd_copy_private_section_data
  PARAMS ((bfd *, asection *, bfd *, asection *));

static boolean
pe_bfd_copy_private_section_data (ibfd, isec, obfd, osec)
     bfd *ibfd;
     asection *isec;
     bfd *obfd;
     asection *osec;
{
  if (bfd_get_flavour (ibfd) != bfd_target_coff_flavour
      || bfd_get_flavour (obfd) != bfd_target_coff_flavour)
    return true;

  if (coff_section_data (ibfd, isec) != NULL
      && pei_section_data (ibfd, isec) != NULL)
    {
      if (coff_section_data (obfd, osec) == NULL)
	{
	  osec->used_by_bfd =
	    (PTR) bfd_zalloc (obfd, sizeof (struct coff_section_tdata));
	  if (osec->used_by_bfd == NULL)
	    return false;
	}
      if (pei_section_data (obfd, osec) == NULL)
	{
	  coff_section_data (obfd, osec)->tdata =
	    (PTR) bfd_zalloc (obfd, sizeof (struct pei_section_tdata));
	  if (coff_section_data (obfd, osec)->tdata == NULL)
	    return false;
	}
      pei_section_data (obfd, osec)->virt_size =
	pei_section_data (ibfd, isec)->virt_size;
    }
d348 2
a349 1
#endif
@


1.10
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* coffcode.h (coff_mkobject_hook): Set timestamp field in
	coff_data_type to f_timdat.
	* peicode.h (pe_mkobject_hook): Likewise.
@
text
@d1115 4
a1118 4
    coff_swap_scnhdr_in (abfd, ext, in)
      bfd            *abfd;
  PTR	     ext;
  PTR	     in;
d1146 4
a1149 1
  if (strcmp (scnhdr_int->s_name, _BSS) == 0) 
d1152 4
a1155 1
      scnhdr_int->s_paddr = 0;
@


1.9
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* peicode.h (coff_swap_filehdr_in): Check the NT executable magic
	number if COFF_IMAGE_WITH_PE.
@
text
@d2115 2
@


1.8
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* coffcode.h (coff_mkobject_hook): If COFF_WITH_PE, set HAS_DEBUG
	to the reverse of IMAGE_FILE_DEBUG_STRIPPED.
	(coff_write_object_contents): Set IMAGE_FILE_DEBUG_STRIPPED if
	there is no SEC_DEBUGGING section.
	* peicode.h (pe_mkobject_hook): Set HAS_DEBUG to the reverse of
	IMAGE_FILE_DEBUG_STRIPPED.
@
text
@d298 15
@


1.7
log
@1999-08-08  Mumit Khan  <khan@@xraylith.wisc.edu>

	* section.c (SEC_SHARED): Define.
	* coffcode.h (sec_to_styp_flags): Handle SEC_SHARED.
	(styp_to_sec_flags): Likewise.
	* peicode.h (coff_swap_scnhdr_out): Likewise.
	* bfd-in2.h: Rebuild.

1999-08-08  Ian Lance Taylor  <ian@@zembu.com>

	* coffcode.h (coff_classify_symbol): Comment out part of
	1999-08-05 change which breaks cygwin DLLs.
@
text
@d2109 3
@


1.6
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d1242 2
@


1.5
log
@fix copyright
@
text
@d621 2
a622 2
     int	      indx;
     int	      numaux;
d704 2
a705 2
     int   indx;
     int   numaux;
d2077 1
a2077 1
     PTR aouthdr;
@


1.4
log
@1999-06-26  Mumit Khan  <khan@@xraylith.wisc.edu>
	* peicode.h (coff_swap_scnhdr_out): Mark non readonly BFD sections
	as writable PE sections.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
@


1.3
log
@* peicode.h (coff_swap_sym_in): When we create the actual section
to reflect the not-there section C_SECTION symbols refer to,
change the symbol class to C_STAT as the section is now really
there.
@
text
@d1238 5
a1242 1
      flags |= IMAGE_SCN_MEM_READ;
@


1.2
log
@	* ecoff.c (_bfd_ecoff_write_armap): give the symtab element a
	reasonable mode until "ar x" is smart enough to skip it (fixes
	gcc/libgcc.a builds on mips-ecoff targets
	* coffcode.h (styp_to_sec_flags): Explain how COMDATs are supposed
	to work.  Hack to support MS import libraries, which use different
	COMDAT types than GNU.
	(coff_slurp_symbol_table): C_SECTION symbols are local; they refer
	to implied zero-length sections (see peicode below)
	* coffgen.c (coff_get_normalized_symtab): Properly read long MS
	filename symbols, which use one *or more* auxents.
	* coffswap.h (coff_swap_aux_in): ditto
	* peicode.h (coff_swap_sym_in): Build the implied zero-length
	sections
@
text
@d570 1
@


1.1
log
@Initial revision
@
text
@d507 1
d522 49
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

