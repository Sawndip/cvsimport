head	1.219;
access;
symbols
	sid-snapshot-20180601:1.219
	sid-snapshot-20180501:1.219
	sid-snapshot-20180401:1.219
	sid-snapshot-20180301:1.219
	sid-snapshot-20180201:1.219
	sid-snapshot-20180101:1.219
	sid-snapshot-20171201:1.219
	sid-snapshot-20171101:1.219
	sid-snapshot-20171001:1.219
	sid-snapshot-20170901:1.219
	sid-snapshot-20170801:1.219
	sid-snapshot-20170701:1.219
	sid-snapshot-20170601:1.219
	sid-snapshot-20170501:1.219
	sid-snapshot-20170401:1.219
	sid-snapshot-20170301:1.219
	sid-snapshot-20170201:1.219
	sid-snapshot-20170101:1.219
	sid-snapshot-20161201:1.219
	sid-snapshot-20161101:1.219
	sid-snapshot-20160901:1.219
	sid-snapshot-20160801:1.219
	sid-snapshot-20160701:1.219
	sid-snapshot-20160601:1.219
	sid-snapshot-20160501:1.219
	sid-snapshot-20160401:1.219
	sid-snapshot-20160301:1.219
	sid-snapshot-20160201:1.219
	sid-snapshot-20160101:1.219
	sid-snapshot-20151201:1.219
	sid-snapshot-20151101:1.219
	sid-snapshot-20151001:1.219
	sid-snapshot-20150901:1.219
	sid-snapshot-20150801:1.219
	sid-snapshot-20150701:1.219
	sid-snapshot-20150601:1.219
	sid-snapshot-20150501:1.219
	sid-snapshot-20150401:1.219
	sid-snapshot-20150301:1.219
	sid-snapshot-20150201:1.219
	sid-snapshot-20150101:1.219
	sid-snapshot-20141201:1.219
	sid-snapshot-20141101:1.219
	sid-snapshot-20141001:1.219
	sid-snapshot-20140901:1.219
	sid-snapshot-20140801:1.219
	sid-snapshot-20140701:1.219
	sid-snapshot-20140601:1.219
	sid-snapshot-20140501:1.219
	sid-snapshot-20140401:1.219
	sid-snapshot-20140301:1.219
	sid-snapshot-20140201:1.219
	sid-snapshot-20140101:1.219
	sid-snapshot-20131201:1.219
	sid-snapshot-20131101:1.219
	sid-snapshot-20131001:1.219
	binutils-2_24-branch:1.218.0.2
	binutils-2_24-branchpoint:1.218
	binutils-2_21_1:1.209
	sid-snapshot-20130901:1.218
	gdb_7_6_1-2013-08-30-release:1.215
	sid-snapshot-20130801:1.218
	sid-snapshot-20130701:1.218
	sid-snapshot-20130601:1.217
	sid-snapshot-20130501:1.215
	gdb_7_6-2013-04-26-release:1.215
	sid-snapshot-20130401:1.215
	binutils-2_23_2:1.212
	gdb_7_6-branch:1.215.0.2
	gdb_7_6-2013-03-12-branchpoint:1.215
	sid-snapshot-20130301:1.215
	sid-snapshot-20130201:1.214
	sid-snapshot-20130101:1.214
	sid-snapshot-20121201:1.212
	gdb_7_5_1-2012-11-29-release:1.212
	binutils-2_23_1:1.212
	sid-snapshot-20121101:1.212
	binutils-2_23:1.212
	sid-snapshot-20121001:1.212
	sid-snapshot-20120901:1.212
	gdb_7_5-2012-08-17-release:1.212
	sid-snapshot-20120801:1.212
	binutils-2_23-branch:1.212.0.4
	binutils-2_23-branchpoint:1.212
	gdb_7_5-branch:1.212.0.2
	gdb_7_5-2012-07-18-branchpoint:1.212
	sid-snapshot-20120701:1.212
	sid-snapshot-20120601:1.212
	sid-snapshot-20120501:1.212
	binutils-2_22_branch:1.211.0.6
	gdb_7_4_1-2012-04-26-release:1.211
	sid-snapshot-20120401:1.212
	sid-snapshot-20120301:1.212
	sid-snapshot-20120201:1.212
	gdb_7_4-2012-01-24-release:1.211
	sid-snapshot-20120101:1.212
	gdb_7_4-branch:1.211.0.4
	gdb_7_4-2011-12-13-branchpoint:1.211
	sid-snapshot-20111201:1.211
	binutils-2_22:1.211
	sid-snapshot-20111101:1.211
	sid-snapshot-20111001:1.211
	binutils-2_22-branch:1.211.0.2
	binutils-2_22-branchpoint:1.211
	gdb_7_3_1-2011-09-04-release:1.210
	sid-snapshot-20110901:1.211
	sid-snapshot-20110801:1.211
	gdb_7_3-2011-07-26-release:1.210
	sid-snapshot-20110701:1.210
	sid-snapshot-20110601:1.210
	sid-snapshot-20110501:1.210
	gdb_7_3-branch:1.210.0.2
	gdb_7_3-2011-04-01-branchpoint:1.210
	sid-snapshot-20110401:1.210
	sid-snapshot-20110301:1.210
	sid-snapshot-20110201:1.210
	sid-snapshot-20110101:1.210
	binutils-2_21:1.209
	sid-snapshot-20101201:1.209
	binutils-2_21-branch:1.209.0.2
	binutils-2_21-branchpoint:1.209
	sid-snapshot-20101101:1.209
	sid-snapshot-20101001:1.209
	binutils-2_20_1:1.206
	gdb_7_2-2010-09-02-release:1.206
	sid-snapshot-20100901:1.209
	sid-snapshot-20100801:1.207
	gdb_7_2-branch:1.206.0.8
	gdb_7_2-2010-07-07-branchpoint:1.206
	sid-snapshot-20100701:1.206
	sid-snapshot-20100601:1.206
	sid-snapshot-20100501:1.206
	sid-snapshot-20100401:1.206
	gdb_7_1-2010-03-18-release:1.206
	sid-snapshot-20100301:1.206
	gdb_7_1-branch:1.206.0.6
	gdb_7_1-2010-02-18-branchpoint:1.206
	sid-snapshot-20100201:1.206
	sid-snapshot-20100101:1.206
	gdb_7_0_1-2009-12-22-release:1.206
	sid-snapshot-20091201:1.206
	sid-snapshot-20091101:1.206
	binutils-2_20:1.206
	gdb_7_0-2009-10-06-release:1.206
	sid-snapshot-20091001:1.206
	gdb_7_0-branch:1.206.0.4
	gdb_7_0-2009-09-16-branchpoint:1.206
	arc-sim-20090309:1.196
	binutils-arc-20081103-branch:1.202.0.12
	binutils-arc-20081103-branchpoint:1.202
	binutils-2_20-branch:1.206.0.2
	binutils-2_20-branchpoint:1.206
	sid-snapshot-20090901:1.205
	sid-snapshot-20090801:1.203
	msnyder-checkpoint-072509-branch:1.203.0.4
	msnyder-checkpoint-072509-branchpoint:1.203
	sid-snapshot-20090701:1.203
	dje-cgen-play1-branch:1.203.0.2
	dje-cgen-play1-branchpoint:1.203
	sid-snapshot-20090601:1.203
	sid-snapshot-20090501:1.203
	sid-snapshot-20090401:1.203
	arc-20081103-branch:1.202.0.10
	arc-20081103-branchpoint:1.202
	arc-insight_6_8-branch:1.196.0.10
	arc-insight_6_8-branchpoint:1.196
	insight_6_8-branch:1.196.0.8
	insight_6_8-branchpoint:1.196
	sid-snapshot-20090301:1.203
	binutils-2_19_1:1.202
	sid-snapshot-20090201:1.202
	sid-snapshot-20090101:1.202
	reverse-20081226-branch:1.202.0.8
	reverse-20081226-branchpoint:1.202
	sid-snapshot-20081201:1.202
	multiprocess-20081120-branch:1.202.0.6
	multiprocess-20081120-branchpoint:1.202
	sid-snapshot-20081101:1.202
	binutils-2_19:1.202
	sid-snapshot-20081001:1.202
	reverse-20080930-branch:1.202.0.4
	reverse-20080930-branchpoint:1.202
	binutils-2_19-branch:1.202.0.2
	binutils-2_19-branchpoint:1.202
	sid-snapshot-20080901:1.202
	sid-snapshot-20080801:1.198
	reverse-20080717-branch:1.197.0.4
	reverse-20080717-branchpoint:1.197
	sid-snapshot-20080701:1.197
	msnyder-reverse-20080609-branch:1.197.0.2
	msnyder-reverse-20080609-branchpoint:1.197
	drow-reverse-20070409-branch:1.194.0.2
	drow-reverse-20070409-branchpoint:1.194
	sid-snapshot-20080601:1.197
	sid-snapshot-20080501:1.197
	sid-snapshot-20080403:1.197
	sid-snapshot-20080401:1.197
	gdb_6_8-2008-03-27-release:1.196
	sid-snapshot-20080301:1.197
	gdb_6_8-branch:1.196.0.6
	gdb_6_8-2008-02-26-branchpoint:1.196
	sid-snapshot-20080201:1.196
	sid-snapshot-20080101:1.196
	sid-snapshot-20071201:1.196
	sid-snapshot-20071101:1.196
	gdb_6_7_1-2007-10-29-release:1.196
	gdb_6_7-2007-10-10-release:1.196
	sid-snapshot-20071001:1.196
	gdb_6_7-branch:1.196.0.4
	gdb_6_7-2007-09-07-branchpoint:1.196
	binutils-2_18:1.196
	binutils-2_18-branch:1.196.0.2
	binutils-2_18-branchpoint:1.196
	insight_6_6-20070208-release:1.193
	binutils-csl-coldfire-4_1-32:1.186.6.1
	binutils-csl-sourcerygxx-4_1-32:1.186.6.1
	gdb_6_6-2006-12-18-release:1.193
	binutils-csl-innovasic-fido-3_4_4-33:1.186.6.1
	binutils-csl-sourcerygxx-3_4_4-32:1.182
	binutils-csl-coldfire-4_1-30:1.186.6.1
	binutils-csl-sourcerygxx-4_1-30:1.186.6.1
	binutils-csl-coldfire-4_1-28:1.186.6.1
	binutils-csl-sourcerygxx-4_1-29:1.186.6.1
	binutils-csl-sourcerygxx-4_1-28:1.186.6.1
	gdb_6_6-branch:1.193.0.2
	gdb_6_6-2006-11-15-branchpoint:1.193
	binutils-csl-arm-2006q3-27:1.186.6.1
	binutils-csl-sourcerygxx-4_1-27:1.186.6.1
	binutils-csl-arm-2006q3-26:1.186.6.1
	binutils-csl-sourcerygxx-4_1-26:1.186.6.1
	binutils-csl-sourcerygxx-4_1-25:1.186.6.1
	binutils-csl-sourcerygxx-4_1-24:1.186.6.1
	binutils-csl-sourcerygxx-4_1-23:1.186.6.1
	insight_6_5-20061003-release:1.187
	gdb-csl-symbian-6_4_50_20060226-12:1.186
	binutils-csl-sourcerygxx-4_1-21:1.186.6.1
	binutils-csl-arm-2006q3-21:1.186.6.1
	binutils-csl-sourcerygxx-4_1-22:1.186.6.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.186.6.1
	binutils-csl-sourcerygxx-4_1-20:1.186.6.1
	binutils-csl-arm-2006q3-19:1.186.6.1
	binutils-csl-sourcerygxx-4_1-19:1.186.6.1
	binutils-csl-sourcerygxx-4_1-18:1.186.6.1
	binutils-csl-renesas-4_1-9:1.186.6.1
	gdb-csl-sourcerygxx-3_4_4-25:1.185
	binutils-csl-sourcerygxx-3_4_4-25:1.182
	nickrob-async-20060828-mergepoint:1.191
	gdb-csl-symbian-6_4_50_20060226-11:1.186
	binutils-csl-renesas-4_1-8:1.186
	binutils-csl-renesas-4_1-7:1.186
	binutils-csl-renesas-4_1-6:1.186
	gdb-csl-sourcerygxx-4_1-17:1.186
	binutils-csl-sourcerygxx-4_1-17:1.186
	gdb-csl-20060226-branch-local-2:1.186
	gdb-csl-sourcerygxx-4_1-14:1.186
	binutils-csl-sourcerygxx-4_1-14:1.186
	binutils-csl-sourcerygxx-4_1-15:1.186
	gdb-csl-sourcerygxx-4_1-13:1.186
	binutils-csl-sourcerygxx-4_1-13:1.186
	binutils-2_17:1.187
	gdb-csl-sourcerygxx-4_1-12:1.186
	binutils-csl-sourcerygxx-4_1-12:1.186
	gdb-csl-sourcerygxx-3_4_4-21:1.186
	binutils-csl-sourcerygxx-3_4_4-21:1.186
	gdb_6_5-20060621-release:1.187
	binutils-csl-wrs-linux-3_4_4-24:1.182
	binutils-csl-wrs-linux-3_4_4-23:1.182
	gdb-csl-sourcerygxx-4_1-9:1.186
	binutils-csl-sourcerygxx-4_1-9:1.186
	gdb-csl-sourcerygxx-4_1-8:1.186
	binutils-csl-sourcerygxx-4_1-8:1.186
	gdb-csl-sourcerygxx-4_1-7:1.186
	binutils-csl-sourcerygxx-4_1-7:1.186
	gdb-csl-arm-2006q1-6:1.186
	binutils-csl-arm-2006q1-6:1.186
	gdb-csl-sourcerygxx-4_1-6:1.186
	binutils-csl-sourcerygxx-4_1-6:1.186
	binutils-csl-wrs-linux-3_4_4-22:1.182
	gdb-csl-symbian-6_4_50_20060226-10:1.186
	gdb-csl-symbian-6_4_50_20060226-9:1.186
	gdb-csl-symbian-6_4_50_20060226-8:1.186
	gdb-csl-coldfire-4_1-11:1.186
	binutils-csl-coldfire-4_1-11:1.186
	gdb-csl-sourcerygxx-3_4_4-19:1.186
	binutils-csl-sourcerygxx-3_4_4-19:1.186
	gdb-csl-coldfire-4_1-10:1.186
	gdb_6_5-branch:1.187.0.12
	gdb_6_5-2006-05-14-branchpoint:1.187
	binutils-csl-coldfire-4_1-10:1.186
	gdb-csl-sourcerygxx-4_1-5:1.186
	binutils-csl-sourcerygxx-4_1-5:1.186
	nickrob-async-20060513-branch:1.187.0.10
	nickrob-async-20060513-branchpoint:1.187
	gdb-csl-sourcerygxx-4_1-4:1.186
	binutils-csl-sourcerygxx-4_1-4:1.186
	msnyder-reverse-20060502-branch:1.187.0.8
	msnyder-reverse-20060502-branchpoint:1.187
	binutils-csl-wrs-linux-3_4_4-21:1.182
	gdb-csl-morpho-4_1-4:1.186
	binutils-csl-morpho-4_1-4:1.186
	gdb-csl-sourcerygxx-3_4_4-17:1.186
	binutils-csl-sourcerygxx-3_4_4-17:1.186
	binutils-csl-wrs-linux-3_4_4-20:1.182
	readline_5_1-import-branch:1.187.0.6
	readline_5_1-import-branchpoint:1.187
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.186
	binutils-2_17-branch:1.187.0.4
	binutils-2_17-branchpoint:1.187
	gdb-csl-symbian-20060226-branch:1.186.0.8
	gdb-csl-symbian-20060226-branchpoint:1.186
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.186
	msnyder-reverse-20060331-branch:1.187.0.2
	msnyder-reverse-20060331-branchpoint:1.187
	binutils-csl-2_17-branch:1.186.0.6
	binutils-csl-2_17-branchpoint:1.186
	gdb-csl-available-20060303-branch:1.186.0.4
	gdb-csl-available-20060303-branchpoint:1.186
	gdb-csl-20060226-branch:1.186.0.2
	gdb-csl-20060226-branchpoint:1.186
	gdb_6_4-20051202-release:1.185
	msnyder-fork-checkpoint-branch:1.185.0.10
	msnyder-fork-checkpoint-branchpoint:1.185
	gdb-csl-gxxpro-6_3-branch:1.185.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.185
	gdb_6_4-branch:1.185.0.6
	gdb_6_4-2005-11-01-branchpoint:1.185
	gdb-csl-arm-20051020-branch:1.185.0.4
	gdb-csl-arm-20051020-branchpoint:1.185
	binutils-csl-gxxpro-3_4-branch:1.182.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.182
	binutils-2_16_1:1.182
	msnyder-tracepoint-checkpoint-branch:1.185.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.185
	gdb-csl-arm-20050325-2005-q1b:1.182
	binutils-csl-arm-2005q1b:1.182
	binutils-2_16:1.182
	gdb-csl-arm-20050325-2005-q1a:1.182
	binutils-csl-arm-2005q1a:1.182
	csl-arm-20050325-branch:1.182.0.6
	csl-arm-20050325-branchpoint:1.182
	binutils-csl-arm-2005q1-branch:1.182.0.4
	binutils-csl-arm-2005q1-branchpoint:1.182
	binutils-2_16-branch:1.182.0.2
	binutils-2_16-branchpoint:1.182
	csl-arm-2004-q3d:1.178
	gdb_6_3-20041109-release:1.178
	gdb_6_3-branch:1.178.0.4
	gdb_6_3-20041019-branchpoint:1.178
	csl-arm-2004-q3:1.178
	drow_intercu-merge-20040921:1.178
	drow_intercu-merge-20040915:1.178
	jimb-gdb_6_2-e500-branch:1.178.0.6
	jimb-gdb_6_2-e500-branchpoint:1.178
	gdb_6_2-20040730-release:1.178
	gdb_6_2-branch:1.178.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.178
	gdb_6_1_1-20040616-release:1.173
	binutils-2_15:1.173
	binutils-2_15-branchpoint:1.173
	csl-arm-2004-q1a:1.175
	csl-arm-2004-q1:1.173
	gdb_6_1-2004-04-05-release:1.173
	drow_intercu-merge-20040402:1.173
	drow_intercu-merge-20040327:1.173
	ezannoni_pie-20040323-branch:1.173.0.14
	ezannoni_pie-20040323-branchpoint:1.173
	cagney_tramp-20040321-mergepoint:1.173
	cagney_tramp-20040309-branch:1.173.0.12
	cagney_tramp-20040309-branchpoint:1.173
	gdb_6_1-branch:1.173.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.173
	drow_intercu-20040221-branch:1.173.0.8
	drow_intercu-20040221-branchpoint:1.173
	binutils-2_15-branch:1.173.0.6
	cagney_bfdfile-20040213-branch:1.173.0.4
	cagney_bfdfile-20040213-branchpoint:1.173
	drow-cplus-merge-20040208:1.173
	carlton_dictionary-20040126-merge:1.173
	cagney_bigcore-20040122-branch:1.173.0.2
	cagney_bigcore-20040122-branchpoint:1.173
	drow-cplus-merge-20040113:1.173
	csl-arm-2003-q4:1.172
	drow-cplus-merge-20031224:1.172
	drow-cplus-merge-20031220:1.172
	carlton_dictionary-20031215-merge:1.171
	drow-cplus-merge-20031214:1.171
	carlton-dictionary-20031111-merge:1.170
	gdb_6_0-2003-10-04-release:1.167
	kettenis_sparc-20030918-branch:1.169.0.6
	kettenis_sparc-20030918-branchpoint:1.169
	carlton_dictionary-20030917-merge:1.169
	ezannoni_pie-20030916-branchpoint:1.169
	ezannoni_pie-20030916-branch:1.169.0.4
	cagney_x86i386-20030821-branch:1.169.0.2
	cagney_x86i386-20030821-branchpoint:1.169
	carlton_dictionary-20030805-merge:1.169
	carlton_dictionary-20030627-merge:1.169
	gdb_6_0-branch:1.167.0.4
	gdb_6_0-2003-06-23-branchpoint:1.167
	jimb-ppc64-linux-20030613-branch:1.167.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.167
	binutils-2_14:1.164
	cagney_convert-20030606-branch:1.166.0.6
	cagney_convert-20030606-branchpoint:1.166
	cagney_writestrings-20030508-branch:1.165.0.4
	cagney_writestrings-20030508-branchpoint:1.165
	jimb-ppc64-linux-20030528-branch:1.166.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.166
	carlton_dictionary-20030523-merge:1.166
	cagney_fileio-20030521-branch:1.166.0.2
	cagney_fileio-20030521-branchpoint:1.166
	kettenis_i386newframe-20030517-mergepoint:1.166
	jimb-ppc64-linux-20030509-branch:1.165.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.165
	kettenis_i386newframe-20030504-mergepoint:1.164
	carlton_dictionary-20030430-merge:1.164
	binutils-2_14-branch:1.164.0.4
	binutils-2_14-branchpoint:1.164
	kettenis_i386newframe-20030419-branch:1.164.0.2
	kettenis_i386newframe-20030419-branchpoint:1.164
	carlton_dictionary-20030416-merge:1.164
	cagney_frameaddr-20030409-mergepoint:1.164
	kettenis_i386newframe-20030406-branch:1.163.0.10
	kettenis_i386newframe-20030406-branchpoint:1.163
	cagney_frameaddr-20030403-branchpoint:1.163
	cagney_frameaddr-20030403-branch:1.163.0.8
	cagney_framebase-20030330-mergepoint:1.163
	cagney_framebase-20030326-branch:1.163.0.6
	cagney_framebase-20030326-branchpoint:1.163
	cagney_lazyid-20030317-branch:1.163.0.4
	cagney_lazyid-20030317-branchpoint:1.163
	kettenis-i386newframe-20030316-mergepoint:1.163
	offbyone-20030313-branch:1.163.0.2
	offbyone-20030313-branchpoint:1.163
	kettenis-i386newframe-20030308-branch:1.162.0.4
	kettenis-i386newframe-20030308-branchpoint:1.162
	carlton_dictionary-20030305-merge:1.162
	cagney_offbyone-20030303-branch:1.162.0.2
	cagney_offbyone-20030303-branchpoint:1.162
	carlton_dictionary-20030207-merge:1.161
	interps-20030202-branch:1.161.0.2
	interps-20030202-branchpoint:1.161
	cagney-unwind-20030108-branch:1.160.0.2
	cagney-unwind-20030108-branchpoint:1.160
	binutils-2_13_2_1:1.155
	binutils-2_13_2:1.155
	carlton_dictionary-20021223-merge:1.160
	gdb_5_3-2002-12-12-release:1.158
	carlton_dictionary-20021115-merge:1.158
	binutils-2_13_1:1.155
	kseitz_interps-20021105-merge:1.158
	kseitz_interps-20021103-merge:1.158
	drow-cplus-merge-20021020:1.158
	drow-cplus-merge-20021025:1.158
	carlton_dictionary-20021025-merge:1.158
	carlton_dictionary-20021011-merge:1.158
	drow-cplus-branch:1.158.0.12
	drow-cplus-branchpoint:1.158
	kseitz_interps-20020930-merge:1.158
	carlton_dictionary-20020927-merge:1.158
	carlton_dictionary-branch:1.158.0.10
	carlton_dictionary-20020920-branchpoint:1.158
	sid-20020905-branchpoint:1.158
	sid-20020905-branch:1.158.0.8
	gdb_5_3-branch:1.158.0.6
	gdb_5_3-2002-09-04-branchpoint:1.158
	kseitz_interps-20020829-merge:1.158
	cagney_sysregs-20020825-branch:1.158.0.4
	cagney_sysregs-20020825-branchpoint:1.158
	readline_4_3-import-branch:1.158.0.2
	readline_4_3-import-branchpoint:1.158
	binutils-2_13:1.155
	gdb_5_2_1-2002-07-23-release:1.147
	binutils-2_13-branchpoint:1.155
	binutils-2_13-branch:1.155.0.2
	kseitz_interps-20020528-branch:1.151.0.2
	kseitz_interps-20020528-branchpoint:1.151
	cagney_regbuf-20020515-branch:1.150.0.4
	cagney_regbuf-20020515-branchpoint:1.150
	binutils-2_12_1:1.145.2.3
	jimb-macro-020506-branch:1.150.0.2
	jimb-macro-020506-branchpoint:1.150
	gdb_5_2-2002-04-29-release:1.147
	binutils-2_12:1.145.2.1
	gdb_5_2-branch:1.147.0.2
	gdb_5_2-2002-03-03-branchpoint:1.147
	binutils-2_12-branch:1.145.0.2
	binutils-2_12-branchpoint:1.145
	gdb_5_1_1-2002-01-24-release:1.103
	gdb_5_1_0_1-2002-01-03-release:1.103
	cygnus_cvs_20020108_pre:1.135
	gdb_5_1_0_1-2002-01-03-branch:1.103.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.103
	gdb_5_1-2001-11-21-release:1.103
	gdb_s390-2001-09-26-branch:1.103.0.4
	gdb_s390-2001-09-26-branchpoint:1.103
	gdb_5_1-2001-07-29-branch:1.103.0.2
	gdb_5_1-2001-07-29-branchpoint:1.103
	binutils-2_11_2:1.87.2.2
	binutils-2_11_1:1.87.2.2
	binutils-2_11:1.87
	x86_64versiong3:1.88
	binutils-2_11-branch:1.87.0.2
	insight-precleanup-2001-01-01:1.87
	binutils-2_10_1:1.60.2.2
	binutils-2_10:1.60
	gdb-premipsmulti-2000-06-06-branch:1.65.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.65
	gdb_5_0-2000-05-19-release:1.60
	gdb_4_18_2-2000-05-18-release:1.60
	gdb_4_95_1-2000-05-11-snapshot:1.60
	gdb_4_95_0-2000-04-27-snapshot:1.60
	gdb_5_0-2000-04-10-branch:1.60.0.4
	gdb_5_0-2000-04-10-branchpoint:1.60
	binutils-2_10-branch:1.60.0.2
	binutils-2_10-branchpoint:1.60
	binutils_latest_snapshot:1.219
	repo-unification-2000-02-06:1.55
	binu_ss_19990721:1.32
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.219
date	2013.09.24.10.22.27;	author amodra;	state Exp;
branches;
next	1.218;

1.218
date	2013.06.24.23.55.44;	author macro;	state Exp;
branches
	1.218.2.1;
next	1.217;

1.217
date	2013.05.30.20.27.21;	author clm;	state Exp;
branches;
next	1.216;

1.216
date	2013.05.04.09.33.08;	author rsandifo;	state Exp;
branches;
next	1.215;

1.215
date	2013.02.21.03.02.29;	author amodra;	state Exp;
branches;
next	1.214;

1.214
date	2012.12.03.16.33.13;	author macro;	state Exp;
branches;
next	1.213;

1.213
date	2012.12.03.16.17.46;	author macro;	state Exp;
branches;
next	1.212;

1.212
date	2011.12.19.07.57.59;	author cltang;	state Exp;
branches;
next	1.211;

1.211
date	2011.07.24.14.20.05;	author rsandifo;	state Exp;
branches
	1.211.2.1;
next	1.210;

1.210
date	2010.12.31.11.00.52;	author rsandifo;	state Exp;
branches;
next	1.209;

1.209
date	2010.08.25.14.53.42;	author hjl;	state Exp;
branches;
next	1.208;

1.208
date	2010.08.18.12.24.05;	author palves;	state Exp;
branches;
next	1.207;

1.207
date	2010.07.27.21.18.52;	author macro;	state Exp;
branches;
next	1.206;

1.206
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.205;

1.205
date	2009.08.06.13.08.24;	author jakub;	state Exp;
branches;
next	1.204;

1.204
date	2009.08.05.21.17.51;	author chaoyingfu;	state Exp;
branches;
next	1.203;

1.203
date	2009.02.12.08.28.19;	author nathan;	state Exp;
branches;
next	1.202;

1.202
date	2008.08.08.19.24.48;	author drow;	state Exp;
branches;
next	1.201;

1.201
date	2008.08.07.20.03.25;	author rsandifo;	state Exp;
branches;
next	1.200;

1.200
date	2008.08.07.19.57.27;	author rsandifo;	state Exp;
branches;
next	1.199;

1.199
date	2008.08.06.19.44.47;	author rsandifo;	state Exp;
branches;
next	1.198;

1.198
date	2008.07.24.16.17.42;	author drow;	state Exp;
branches;
next	1.197;

1.197
date	2008.02.27.17.06.06;	author clm;	state Exp;
branches;
next	1.196;

1.196
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.195;

1.195
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.194;

1.194
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.193;

1.193
date	2006.10.28.10.13.49;	author rsandifo;	state Exp;
branches;
next	1.192;

1.192
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.191;

1.191
date	2006.08.15.18.28.47;	author ths;	state Exp;
branches;
next	1.190;

1.190
date	2006.07.20.16.46.29;	author ths;	state Exp;
branches;
next	1.189;

1.189
date	2006.06.12.11.35.43;	author ths;	state Exp;
branches;
next	1.188;

1.188
date	2006.05.30.16.45.31;	author hjl;	state Exp;
branches;
next	1.187;

1.187
date	2006.03.22.09.28.13;	author rsandifo;	state Exp;
branches;
next	1.186;

1.186
date	2005.11.23.14.04.16;	author drow;	state Exp;
branches
	1.186.6.1;
next	1.185;

1.185
date	2005.05.23.17.44.53;	author fnf;	state Exp;
branches;
next	1.184;

1.184
date	2005.05.04.15.53.17;	author nickc;	state Exp;
branches;
next	1.183;

1.183
date	2005.05.04.07.19.23;	author nickc;	state Exp;
branches;
next	1.182;

1.182
date	2005.03.02.21.23.20;	author drow;	state Exp;
branches;
next	1.181;

1.181
date	2005.02.15.19.57.48;	author macro;	state Exp;
branches;
next	1.180;

1.180
date	2005.02.11.22.29.09;	author macro;	state Exp;
branches;
next	1.179;

1.179
date	2005.02.07.02.44.59;	author macro;	state Exp;
branches;
next	1.178;

1.178
date	2004.06.29.13.46.30;	author amodra;	state Exp;
branches;
next	1.177;

1.177
date	2004.06.24.04.46.20;	author amodra;	state Exp;
branches;
next	1.176;

1.176
date	2004.06.14.18.25.09;	author cgd;	state Exp;
branches;
next	1.175;

1.175
date	2004.04.24.22.07.13;	author cgd;	state Exp;
branches;
next	1.174;

1.174
date	2004.04.21.20.52.25;	author cgd;	state Exp;
branches;
next	1.173;

1.173
date	2004.01.05.22.09.38;	author macro;	state Exp;
branches
	1.173.8.1;
next	1.172;

1.172
date	2003.12.18.10.23.07;	author rsandifo;	state Exp;
branches;
next	1.171;

1.171
date	2003.12.07.21.24.27;	author rsandifo;	state Exp;
branches;
next	1.170;

1.170
date	2003.11.03.15.17.38;	author drow;	state Exp;
branches;
next	1.169;

1.169
date	2003.06.27.07.31.27;	author ths;	state Exp;
branches;
next	1.168;

1.168
date	2003.06.25.06.40.21;	author amodra;	state Exp;
branches;
next	1.167;

1.167
date	2003.06.11.16.22.25;	author ths;	state Exp;
branches;
next	1.166;

1.166
date	2003.05.15.00.04.34;	author ths;	state Exp;
branches;
next	1.165;

1.165
date	2003.05.09.02.27.03;	author amodra;	state Exp;
branches;
next	1.164;

1.164
date	2003.04.09.02.55.40;	author aoliva;	state Exp;
branches
	1.164.2.1;
next	1.163;

1.163
date	2003.03.12.23.05.50;	author aoliva;	state Exp;
branches
	1.163.8.1;
next	1.162;

1.162
date	2003.03.02.21.30.13;	author ths;	state Exp;
branches
	1.162.4.1;
next	1.161;

1.161
date	2003.01.23.11.51.32;	author amodra;	state Exp;
branches;
next	1.160;

1.160
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches;
next	1.159;

1.159
date	2002.11.28.11.55.40;	author amodra;	state Exp;
branches;
next	1.158;

1.158
date	2002.08.07.04.32.14;	author ths;	state Exp;
branches
	1.158.10.1
	1.158.12.1;
next	1.157;

1.157
date	2002.07.31.00.32.10;	author ths;	state Exp;
branches;
next	1.156;

1.156
date	2002.07.19.21.34.02;	author ths;	state Exp;
branches;
next	1.155;

1.155
date	2002.07.07.09.10.40;	author amodra;	state Exp;
branches;
next	1.154;

1.154
date	2002.06.06.00.29.21;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2002.06.05.13.31.59;	author amodra;	state Exp;
branches;
next	1.152;

1.152
date	2002.06.05.10.31.46;	author macro;	state Exp;
branches;
next	1.151;

1.151
date	2002.05.14.23.37.52;	author ths;	state Exp;
branches
	1.151.2.1;
next	1.150;

1.150
date	2002.04.16.00.57.00;	author rth;	state Exp;
branches
	1.150.4.1;
next	1.149;

1.149
date	2002.04.04.07.01.20;	author ths;	state Exp;
branches;
next	1.148;

1.148
date	2002.03.28.03.27.44;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2002.02.19.12.40.29;	author jakub;	state Exp;
branches;
next	1.146;

1.146
date	2002.02.15.02.10.34;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2002.02.09.04.40.18;	author echristo;	state Exp;
branches
	1.145.2.1;
next	1.144;

1.144
date	2002.02.08.19.18.35;	author cgd;	state Exp;
branches;
next	1.143;

1.143
date	2002.02.06.21.34.17;	author hjl;	state Exp;
branches;
next	1.142;

1.142
date	2002.01.31.11.17.22;	author nickc;	state Exp;
branches;
next	1.141;

1.141
date	2002.01.30.02.19.21;	author cgd;	state Exp;
branches;
next	1.140;

1.140
date	2002.01.30.02.13.20;	author cgd;	state Exp;
branches;
next	1.139;

1.139
date	2002.01.21.10.29.09;	author amodra;	state Exp;
branches;
next	1.138;

1.138
date	2002.01.17.20.06.48;	author echristo;	state Exp;
branches;
next	1.137;

1.137
date	2002.01.17.13.02.40;	author amodra;	state Exp;
branches;
next	1.136;

1.136
date	2002.01.17.08.19.08;	author echristo;	state Exp;
branches;
next	1.135;

1.135
date	2002.01.05.13.11.31;	author amodra;	state Exp;
branches;
next	1.134;

1.134
date	2002.01.05.12.36.18;	author amodra;	state Exp;
branches;
next	1.133;

1.133
date	2001.12.18.17.59.58;	author hjl;	state Exp;
branches;
next	1.132;

1.132
date	2001.12.17.20.14.48;	author ths;	state Exp;
branches;
next	1.131;

1.131
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2001.12.07.11.12.18;	author jakub;	state Exp;
branches;
next	1.129;

1.129
date	2001.12.04.14.38.46;	author ths;	state Exp;
branches;
next	1.128;

1.128
date	2001.12.02.13.27.45;	author ths;	state Exp;
branches;
next	1.127;

1.127
date	2001.12.02.13.14.48;	author ths;	state Exp;
branches;
next	1.126;

1.126
date	2001.11.15.01.34.10;	author drow;	state Exp;
branches;
next	1.125;

1.125
date	2001.11.11.23.51.36;	author hjl;	state Exp;
branches;
next	1.124;

1.124
date	2001.11.10.00.23.34;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2001.11.02.19.46.59;	author hjl;	state Exp;
branches;
next	1.122;

1.122
date	2001.11.01.01.33.45;	author cgd;	state Exp;
branches;
next	1.121;

1.121
date	2001.10.23.20.24.23;	author hjl;	state Exp;
branches;
next	1.120;

1.120
date	2001.10.15.09.45.47;	author amodra;	state Exp;
branches;
next	1.119;

1.119
date	2001.10.05.16.14.39;	author ths;	state Exp;
branches;
next	1.118;

1.118
date	2001.10.04.16.18.32;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2001.10.04.16.09.03;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2001.10.04.05.50.29;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2001.09.21.14.25.08;	author nickc;	state Exp;
branches;
next	1.114;

1.114
date	2001.09.20.23.30.35;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	2001.09.18.09.57.23;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2001.09.07.05.00.33;	author ths;	state Exp;
branches;
next	1.110;

1.110
date	2001.08.31.21.41.10;	author hjl;	state Exp;
branches;
next	1.109;

1.109
date	2001.08.31.21.24.28;	author echristo;	state Exp;
branches;
next	1.108;

1.108
date	2001.08.30.21.26.26;	author hjl;	state Exp;
branches;
next	1.107;

1.107
date	2001.08.30.15.24.18;	author hjl;	state Exp;
branches;
next	1.106;

1.106
date	2001.08.27.15.40.38;	author hjl;	state Exp;
branches;
next	1.105;

1.105
date	2001.08.27.14.47.33;	author hjl;	state Exp;
branches;
next	1.104;

1.104
date	2001.08.25.01.27.54;	author ths;	state Exp;
branches;
next	1.103;

1.103
date	2001.07.04.07.15.20;	author hjl;	state Exp;
branches;
next	1.102;

1.102
date	2001.06.30.04.05.12;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2001.06.30.03.15.46;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2001.06.17.16.14.42;	author hjl;	state Exp;
branches;
next	1.99;

1.99
date	2001.06.10.05.20.59;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2001.06.07.17.31.22;	author hjl;	state Exp;
branches;
next	1.97;

1.97
date	2001.05.23.17.26.35;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2001.05.23.08.23.27;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2001.05.08.17.14.35;	author ian;	state Exp;
branches;
next	1.94;

1.94
date	2001.05.07.09.15.25;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2001.04.30.16.13.26;	author hjl;	state Exp;
branches;
next	1.92;

1.92
date	2001.04.24.15.08.15;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	2001.04.08.05.11.48;	author hjl;	state Exp;
branches;
next	1.90;

1.90
date	2001.03.22.00.29.15;	author dnovillo;	state Exp;
branches;
next	1.89;

1.89
date	2001.03.08.21.04.00;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2001.02.11.23.11.40;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2000.12.12.19.23.15;	author nickc;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2000.12.09.20.12.57;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2000.12.08.22.50.07;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2000.12.07.01.05.04;	author ulfc;	state Exp;
branches;
next	1.83;

1.83
date	2000.12.02.01.10.31;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2000.12.02.00.52.55;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2000.12.01.21.35.35;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2000.11.29.04.56.32;	author kazu;	state Exp;
branches;
next	1.79;

1.79
date	2000.10.14.04.05.23;	author ulfc;	state Exp;
branches;
next	1.78;

1.78
date	2000.10.02.06.04.16;	author ulfc;	state Exp;
branches;
next	1.77;

1.77
date	2000.09.14.01.47.31;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	2000.07.23.20.51.35;	author ulfc;	state Exp;
branches;
next	1.75;

1.75
date	2000.07.21.19.56.19;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2000.07.20.03.21.59;	author hjl;	state Exp;
branches;
next	1.73;

1.73
date	2000.07.18.09.45.26;	author ulfc;	state Exp;
branches;
next	1.72;

1.72
date	2000.07.17.19.39.40;	author ulfc;	state Exp;
branches;
next	1.71;

1.71
date	2000.07.11.06.37.34;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2000.07.09.13.48.21;	author ulfc;	state Exp;
branches;
next	1.69;

1.69
date	2000.07.03.23.49.36;	author ulfc;	state Exp;
branches;
next	1.68;

1.68
date	2000.06.20.16.37.36;	author ulfc;	state Exp;
branches;
next	1.67;

1.67
date	2000.06.20.11.06.19;	author ulfc;	state Exp;
branches;
next	1.66;

1.66
date	2000.06.17.09.47.14;	author ulfc;	state Exp;
branches;
next	1.65;

1.65
date	2000.05.23.14.20.57;	author hjl;	state Exp;
branches;
next	1.64;

1.64
date	2000.05.23.14.05.50;	author hjl;	state Exp;
branches;
next	1.63;

1.63
date	2000.05.22.18.44.02;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2000.04.13.01.08.04;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2000.04.11.13.07.56;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2000.03.11.02.23.10;	author geoffk;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2000.03.11.02.16.24;	author geoffk;	state Exp;
branches;
next	1.58;

1.58
date	2000.03.01.20.39.07;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches;
next	1.56;

1.56
date	2000.02.13.22.45.29;	author ian;	state Exp;
branches;
next	1.55;

1.55
date	99.12.03.06.51.54;	author ian;	state Exp;
branches;
next	1.54;

1.54
date	99.11.18.01.06.45;	author rth;	state Exp;
branches;
next	1.53;

1.53
date	99.10.08.03.07.07;	author geoffk;	state Exp;
branches;
next	1.52;

1.52
date	99.09.28.04.11.05;	author geoffk;	state Exp;
branches;
next	1.51;

1.51
date	99.08.27.00.08.49;	author mmitchel;	state Exp;
branches;
next	1.50;

1.50
date	99.08.17.07.50.30;	author ian;	state Exp;
branches;
next	1.49;

1.49
date	99.08.15.22.56.20;	author mmitchel;	state Exp;
branches;
next	1.48;

1.48
date	99.08.10.06.43.10;	author mmitchel;	state Exp;
branches;
next	1.47;

1.47
date	99.08.10.06.27.47;	author mmitchel;	state Exp;
branches;
next	1.46;

1.46
date	99.08.09.22.45.38;	author mmitchel;	state Exp;
branches;
next	1.45;

1.45
date	99.08.06.02.44.41;	author mmitchel;	state Exp;
branches;
next	1.44;

1.44
date	99.08.04.16.32.34;	author mmitchel;	state Exp;
branches;
next	1.43;

1.43
date	99.08.04.03.52.59;	author mmitchel;	state Exp;
branches;
next	1.42;

1.42
date	99.08.03.16.58.26;	author mmitchel;	state Exp;
branches;
next	1.41;

1.41
date	99.08.03.06.06.47;	author mmitchel;	state Exp;
branches;
next	1.40;

1.40
date	99.08.03.06.04.21;	author mmitchel;	state Exp;
branches;
next	1.39;

1.39
date	99.08.01.22.45.06;	author mmitchel;	state Exp;
branches;
next	1.38;

1.38
date	99.08.01.22.38.53;	author mmitchel;	state Exp;
branches;
next	1.37;

1.37
date	99.08.01.20.58.19;	author mmitchel;	state Exp;
branches;
next	1.36;

1.36
date	99.07.29.22.20.26;	author rth;	state Exp;
branches;
next	1.35;

1.35
date	99.07.29.21.39.01;	author rth;	state Exp;
branches;
next	1.34;

1.34
date	99.07.28.08.19.34;	author mmitchel;	state Exp;
branches;
next	1.33;

1.33
date	99.07.21.23.32.29;	author ian;	state Exp;
branches;
next	1.32;

1.32
date	99.07.19.20.11.22;	author mmitchel;	state Exp;
branches;
next	1.31;

1.31
date	99.07.19.20.06.23;	author mmitchel;	state Exp;
branches;
next	1.30;

1.30
date	99.07.18.06.31.29;	author mmitchel;	state Exp;
branches;
next	1.29;

1.29
date	99.07.16.19.09.22;	author ian;	state Exp;
branches;
next	1.28;

1.28
date	99.07.15.16.57.55;	author mmitchel;	state Exp;
branches;
next	1.27;

1.27
date	99.07.15.13.12.00;	author mmitchel;	state Exp;
branches;
next	1.26;

1.26
date	99.07.14.19.00.32;	author mmitchel;	state Exp;
branches;
next	1.25;

1.25
date	99.07.14.14.23.13;	author rth;	state Exp;
branches;
next	1.24;

1.24
date	99.07.14.11.46.04;	author mmitchel;	state Exp;
branches;
next	1.23;

1.23
date	99.07.14.09.45.44;	author mmitchel;	state Exp;
branches;
next	1.22;

1.22
date	99.07.13.23.55.07;	author mmitchel;	state Exp;
branches;
next	1.21;

1.21
date	99.07.13.18.21.19;	author rth;	state Exp;
branches;
next	1.20;

1.20
date	99.07.13.15.23.22;	author mmitchel;	state Exp;
branches;
next	1.19;

1.19
date	99.07.12.17.15.34;	author mmitchel;	state Exp;
branches;
next	1.18;

1.18
date	99.07.12.10.29.26;	author ian;	state Exp;
branches;
next	1.17;

1.17
date	99.07.12.07.35.06;	author ian;	state Exp;
branches;
next	1.16;

1.16
date	99.07.11.09.46.10;	author mmitchel;	state Exp;
branches;
next	1.15;

1.15
date	99.07.11.09.28.45;	author mmitchel;	state Exp;
branches;
next	1.14;

1.14
date	99.07.07.19.23.19;	author mmitchel;	state Exp;
branches;
next	1.13;

1.13
date	99.07.02.21.03.53;	author mmitchel;	state Exp;
branches;
next	1.12;

1.12
date	99.07.01.23.20.08;	author mmitchel;	state Exp;
branches;
next	1.11;

1.11
date	99.06.30.20.13.43;	author mmitchel;	state Exp;
branches;
next	1.10;

1.10
date	99.06.30.18.16.46;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.06.27.21.23.34;	author mmitchel;	state Exp;
branches;
next	1.8;

1.8
date	99.06.27.16.11.13;	author mmitchel;	state Exp;
branches;
next	1.7;

1.7
date	99.06.27.11.05.14;	author mmitchel;	state Exp;
branches;
next	1.6;

1.6
date	99.06.26.21.17.49;	author mmitchel;	state Exp;
branches;
next	1.5;

1.5
date	99.06.12.13.08.29;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.06.22.31.46;	author mmitchel;	state Exp;
branches;
next	1.3;

1.3
date	99.06.02.18.17.57;	author mmitchel;	state Exp;
branches;
next	1.2;

1.2
date	99.06.02.10.20.14;	author mmitchel;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.218.2.1
date	2013.09.25.02.55.03;	author amodra;	state Exp;
branches;
next	;

1.211.2.1
date	2011.12.19.10.49.25;	author cltang;	state Exp;
branches;
next	;

1.186.6.1
date	2006.08.22.15.08.28;	author jsm28;	state Exp;
branches;
next	;

1.173.8.1
date	2004.09.16.17.00.24;	author drow;	state Exp;
branches;
next	;

1.164.2.1
date	2003.05.18.09.43.41;	author kettenis;	state Exp;
branches;
next	;

1.163.8.1
date	2003.04.10.21.33.44;	author cagney;	state Exp;
branches;
next	;

1.162.4.1
date	2003.03.16.14.01.43;	author kettenis;	state Exp;
branches;
next	;

1.158.10.1
date	2002.12.23.19.37.43;	author carlton;	state Exp;
branches;
next	1.158.10.2;

1.158.10.2
date	2003.02.07.19.17.38;	author carlton;	state Exp;
branches;
next	1.158.10.3;

1.158.10.3
date	2003.03.06.00.56.15;	author carlton;	state Exp;
branches;
next	1.158.10.4;

1.158.10.4
date	2003.04.16.19.56.42;	author carlton;	state Exp;
branches;
next	1.158.10.5;

1.158.10.5
date	2003.05.23.18.40.24;	author carlton;	state Exp;
branches;
next	1.158.10.6;

1.158.10.6
date	2003.06.27.21.49.15;	author carlton;	state Exp;
branches;
next	1.158.10.7;

1.158.10.7
date	2003.11.11.23.50.18;	author carlton;	state Exp;
branches;
next	1.158.10.8;

1.158.10.8
date	2003.12.15.23.59.26;	author carlton;	state Exp;
branches;
next	1.158.10.9;

1.158.10.9
date	2004.01.26.19.11.05;	author carlton;	state Exp;
branches;
next	;

1.158.12.1
date	2003.12.14.20.26.40;	author drow;	state Exp;
branches;
next	1.158.12.2;

1.158.12.2
date	2003.12.20.18.16.46;	author drow;	state Exp;
branches;
next	1.158.12.3;

1.158.12.3
date	2004.01.13.16.11.37;	author drow;	state Exp;
branches;
next	;

1.151.2.1
date	2002.06.20.01.30.18;	author kseitz;	state Exp;
branches;
next	1.151.2.2;

1.151.2.2
date	2002.07.22.21.46.44;	author kseitz;	state Exp;
branches;
next	1.151.2.3;

1.151.2.3
date	2002.08.09.18.34.14;	author kseitz;	state Exp;
branches;
next	;

1.150.4.1
date	2002.06.15.16.42.36;	author cagney;	state Exp;
branches;
next	;

1.145.2.1
date	2002.02.19.13.10.29;	author jakub;	state Exp;
branches;
next	1.145.2.2;

1.145.2.2
date	2002.04.04.14.52.57;	author amodra;	state Exp;
branches;
next	1.145.2.3;

1.145.2.3
date	2002.05.11.18.05.35;	author drow;	state Exp;
branches;
next	;

1.87.2.1
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	1.87.2.2;

1.87.2.2
date	2001.06.11.10.04.11;	author amodra;	state Exp;
branches;
next	;

1.60.2.1
date	2000.10.22.15.19.57;	author pb;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2000.10.23.12.38.15;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.219
log
@	* elf32-mips.c (ELF_OSABI): Undef for vxworks.
@
text
@/* MIPS-specific support for 32-bit ELF
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.

   Most of the information added by Ian Lance Taylor, Cygnus Support,
   <ian@@cygnus.com>.
   N32/64 ABI support added by Mark Mitchell, CodeSourcery, LLC.
   <mark@@codesourcery.com>
   Traditional MIPS targets support added by Koundinya.K, Dansk Data
   Elektronik & Operations Research Group. <kk@@ddeorg.soft.net>

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* This file handles MIPS ELF targets.  SGI Irix 5 uses a slightly
   different MIPS ELF from other targets.  This matters when linking.
   This file supports both, switching at runtime.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "bfdlink.h"
#include "genlink.h"
#include "elf-bfd.h"
#include "elfxx-mips.h"
#include "elf/mips.h"
#include "elf-vxworks.h"

/* Get the ECOFF swapping routines.  */
#include "coff/sym.h"
#include "coff/symconst.h"
#include "coff/internal.h"
#include "coff/ecoff.h"
#include "coff/mips.h"
#define ECOFF_SIGNED_32
#include "ecoffswap.h"

static bfd_reloc_status_type gprel32_with_gp
  (bfd *, asymbol *, arelent *, asection *, bfd_boolean, void *, bfd_vma);
static bfd_reloc_status_type mips_elf_gprel32_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips32_64bit_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type);
static reloc_howto_type *mips_elf32_rtype_to_howto
  (unsigned int, bfd_boolean);
static void mips_info_to_howto_rel
  (bfd *, arelent *, Elf_Internal_Rela *);
static void mips_info_to_howto_rela
  (bfd *, arelent *, Elf_Internal_Rela *);
static bfd_boolean mips_elf_sym_is_global
  (bfd *, asymbol *);
static bfd_boolean mips_elf32_object_p
  (bfd *);
static bfd_boolean mips_elf_is_local_label_name
  (bfd *, const char *);
static bfd_reloc_status_type mips16_gprel_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips_elf_final_gp
  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
static bfd_boolean mips_elf_assign_gp
  (bfd *, bfd_vma *);
static bfd_boolean elf32_mips_grok_prstatus
  (bfd *, Elf_Internal_Note *);
static bfd_boolean elf32_mips_grok_psinfo
  (bfd *, Elf_Internal_Note *);
static irix_compat_t elf32_mips_irix_compat
  (bfd *);

extern const bfd_target bfd_elf32_bigmips_vec;
extern const bfd_target bfd_elf32_littlemips_vec;

/* Nonzero if ABFD is using the N32 ABI.  */
#define ABI_N32_P(abfd) \
  ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI2) != 0)

/* Whether we are trying to be compatible with IRIX at all.  */
#define SGI_COMPAT(abfd) \
  (elf32_mips_irix_compat (abfd) != ict_none)

/* The number of local .got entries we reserve.  */
#define MIPS_RESERVED_GOTNO (2)

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)

/* The relocation table used for SHT_REL sections.  */

static reloc_howto_type elf_mips_howto_table_rel[] =
{
  /* No relocation.  */
  HOWTO (R_MIPS_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit relocation.  */
  HOWTO (R_MIPS_16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit relocation.  */
  HOWTO (R_MIPS_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit symbol relative relocation.  */
  HOWTO (R_MIPS_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_REL32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 26 bit jump address.  */
  HOWTO (R_MIPS_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC + 4.  */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03ffffff,		/* src_mask */
	 0x03ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of symbol value.  */
  HOWTO (R_MIPS_HI16,		/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MIPS_HI16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_MIPS_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MIPS_LO16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GP relative reference.  */
  HOWTO (R_MIPS_GPREL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
	 "R_MIPS_GPREL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to literal section.  */
  HOWTO (R_MIPS_LITERAL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
	 "R_MIPS_LITERAL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to global offset table.  */
  HOWTO (R_MIPS_GOT16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_got16_reloc, /* special_function */
	 "R_MIPS_GOT16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit PC relative reference.  Note that the ABI document has a typo
     and claims R_MIPS_PC16 to be not rightshifted, rendering it useless.
     We do the right thing here.  */
  HOWTO (R_MIPS_PC16,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_PC16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit call through global offset table.  */
  HOWTO (R_MIPS_CALL16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_CALL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit GP relative reference.  */
  HOWTO (R_MIPS_GPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_elf_gprel32_reloc, /* special_function */
	 "R_MIPS_GPREL32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The remaining relocs are defined on Irix 5, although they are
     not defined by the ABI.  */
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),

  /* A 5 bit shift field.  */
  HOWTO (R_MIPS_SHIFT5,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 5,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_SHIFT5",	/* name */
	 TRUE,			/* partial_inplace */
	 0x000007c0,		/* src_mask */
	 0x000007c0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 6 bit shift field.  */
  /* FIXME: This is not handled correctly; a special function is
     needed to put the most significant bit in the right place.  */
  HOWTO (R_MIPS_SHIFT6,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_SHIFT6",	/* name */
	 TRUE,			/* partial_inplace */
	 0x000007c4,		/* src_mask */
	 0x000007c4,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 64 bit relocation.  */
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips32_64bit_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement in the global offset table.  */
  HOWTO (R_MIPS_GOT_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT_DISP",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement to page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_PAGE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT_PAGE",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Offset from page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_OFST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT_OFST",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit subtraction.  Used in the N32 ABI.  */
  HOWTO (R_MIPS_SUB,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_SUB",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used to cause the linker to insert and delete instructions?  */
  EMPTY_HOWTO (R_MIPS_INSERT_A),
  EMPTY_HOWTO (R_MIPS_INSERT_B),
  EMPTY_HOWTO (R_MIPS_DELETE),

  /* Get the higher value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHER,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_HIGHER",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Get the highest value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHEST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_HIGHEST",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_CALL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_CALL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Section displacement.  */
  HOWTO (R_MIPS_SCN_DISP,       /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_SCN_DISP",     /* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (R_MIPS_REL16),
  EMPTY_HOWTO (R_MIPS_ADD_IMMEDIATE),
  EMPTY_HOWTO (R_MIPS_PJUMP),
  EMPTY_HOWTO (R_MIPS_RELGOT),

  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_JALR",	        /* name */
	 FALSE,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS GD/LD dynamic relocations.  */
  HOWTO (R_MIPS_TLS_DTPMOD32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPMOD32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MIPS_TLS_DTPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPREL32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (R_MIPS_TLS_DTPMOD64),
  EMPTY_HOWTO (R_MIPS_TLS_DTPREL64),

  /* TLS general dynamic variable reference.  */
  HOWTO (R_MIPS_TLS_GD,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_GD",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic variable reference.  */
  HOWTO (R_MIPS_TLS_LDM,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_LDM",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic offset.  */
  HOWTO (R_MIPS_TLS_DTPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPREL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic offset.  */
  HOWTO (R_MIPS_TLS_DTPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPREL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS thread pointer offset.  */
  HOWTO (R_MIPS_TLS_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_GOTTPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS IE dynamic relocations.  */
  HOWTO (R_MIPS_TLS_TPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_TPREL32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (R_MIPS_TLS_TPREL64),

  /* TLS thread pointer offset.  */
  HOWTO (R_MIPS_TLS_TPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_TPREL_HI16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS thread pointer offset.  */
  HOWTO (R_MIPS_TLS_TPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_TPREL_LO16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit relocation with no addend.  */
  HOWTO (R_MIPS_GLOB_DAT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GLOB_DAT",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* The reloc used for BFD_RELOC_CTOR when doing a 64 bit link.  This
   is a hack to make the linker think that we need 64 bit values.  */
static reloc_howto_type elf_mips_ctor64_howto =
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips32_64bit_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

static reloc_howto_type elf_mips16_howto_table_rel[] =
{
  /* The reloc used for the mips16 jump instruction.  */
  HOWTO (R_MIPS16_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The reloc used for the mips16 gprel instruction.  */
  HOWTO (R_MIPS16_GPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips16_gprel_reloc,	/* special_function */
	 "R_MIPS16_GPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,	        /* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A MIPS16 reference to the global offset table.  */
  HOWTO (R_MIPS16_GOT16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_got16_reloc, /* special_function */
	 "R_MIPS16_GOT16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,	        /* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A MIPS16 call through the global offset table.  */
  HOWTO (R_MIPS16_CALL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_CALL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,	        /* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 high 16 bits of symbol value.  */
  HOWTO (R_MIPS16_HI16,		/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MIPS16_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,	        /* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 low 16 bits of symbol value.  */
  HOWTO (R_MIPS16_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MIPS16_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,	        /* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS general dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_GD,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GD",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_LDM,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_LDM",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GOTTPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_HI16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_LO16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

static reloc_howto_type elf_micromips_howto_table_rel[] =
{
  EMPTY_HOWTO (130),
  EMPTY_HOWTO (131),
  EMPTY_HOWTO (132),

  /* 26 bit jump address.  */
  HOWTO (R_MICROMIPS_26_S1,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_26_S1",	/* name */
	 TRUE,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of symbol value.  */
  HOWTO (R_MICROMIPS_HI16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MICROMIPS_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_MICROMIPS_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MICROMIPS_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GP relative reference.  */
  HOWTO (R_MICROMIPS_GPREL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
	 "R_MICROMIPS_GPREL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to literal section.  */
  HOWTO (R_MICROMIPS_LITERAL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
	 "R_MICROMIPS_LITERAL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to global offset table.  */
  HOWTO (R_MICROMIPS_GOT16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_got16_reloc, /* special_function */
	 "R_MICROMIPS_GOT16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* This is for microMIPS branches.  */
  HOWTO (R_MICROMIPS_PC7_S1,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_PC7_S1",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000007f,		/* src_mask */
	 0x0000007f,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MICROMIPS_PC10_S1,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_PC10_S1",	/* name */
	 TRUE,			/* partial_inplace */
	 0x000003ff,		/* src_mask */
	 0x000003ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MICROMIPS_PC16_S1,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_PC16_S1",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit call through global offset table.  */
  HOWTO (R_MICROMIPS_CALL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_CALL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (143),
  EMPTY_HOWTO (144),

  /* Displacement in the global offset table.  */
  HOWTO (R_MICROMIPS_GOT_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_DISP",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement to page pointer in the global offset table.  */
  HOWTO (R_MICROMIPS_GOT_PAGE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_PAGE",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Offset from page pointer in the global offset table.  */
  HOWTO (R_MICROMIPS_GOT_OFST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_OFST",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_GOT_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_HI16",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_GOT_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_LO16",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit subtraction.  Used in the N32 ABI.  */
  HOWTO (R_MICROMIPS_SUB,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_SUB",	/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Get the higher value of a 64 bit addend.  */
  HOWTO (R_MICROMIPS_HIGHER,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_HIGHER",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Get the highest value of a 64 bit addend.  */
  HOWTO (R_MICROMIPS_HIGHEST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_HIGHEST",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_CALL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_CALL_HI16",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_CALL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_CALL_LO16",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Section displacement.  */
  HOWTO (R_MICROMIPS_SCN_DISP,  /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_SCN_DISP",/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MICROMIPS_JALR,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_JALR",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of symbol value.  Note that the high 16 bits of symbol values
     must be zero.  This is used for relaxation.  */
  HOWTO (R_MICROMIPS_HI0_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_HI0_LO16",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (158),
  EMPTY_HOWTO (159),
  EMPTY_HOWTO (160),
  EMPTY_HOWTO (161),

  /* TLS general dynamic variable reference.  */
  HOWTO (R_MICROMIPS_TLS_GD,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_TLS_GD",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic variable reference.  */
  HOWTO (R_MICROMIPS_TLS_LDM,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_TLS_LDM",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic offset.  */
  HOWTO (R_MICROMIPS_TLS_DTPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_TLS_DTPREL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic offset.  */
  HOWTO (R_MICROMIPS_TLS_DTPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_TLS_DTPREL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS thread pointer offset.  */
  HOWTO (R_MICROMIPS_TLS_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_TLS_GOTTPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (167),
  EMPTY_HOWTO (168),

  /* TLS thread pointer offset.  */
  HOWTO (R_MICROMIPS_TLS_TPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_TLS_TPREL_HI16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS thread pointer offset.  */
  HOWTO (R_MICROMIPS_TLS_TPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_TLS_TPREL_LO16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (171),

  /* GP- and PC-relative relocations.  */
  HOWTO (R_MICROMIPS_GPREL7_S2,	/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
	 "R_MICROMIPS_GPREL7_S2",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000007f,		/* src_mask */
	 0x0000007f,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MICROMIPS_PC23_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 23,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_PC23_S2",	/* name */
	 TRUE,			/* partial_inplace */
	 0x007fffff,		/* src_mask */
	 0x007fffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
};

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rel16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* 32 bit pc-relative.  This was a GNU extension used by embedded-PIC.
   It was co-opted by mips-linux for exception-handling data.  It is no
   longer used, but should continue to be supported by the linker for
   backward compatibility.  (GCC stopped using it in May, 2004.)  */
static reloc_howto_type elf_mips_gnu_pcrel32 =
  HOWTO (R_MIPS_PC32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_PC32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* GNU extension to record C++ vtable hierarchy */
static reloc_howto_type elf_mips_gnu_vtinherit_howto =
  HOWTO (R_MIPS_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_MIPS_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* GNU extension to record C++ vtable member usage */
static reloc_howto_type elf_mips_gnu_vtentry_howto =
  HOWTO (R_MIPS_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
	 "R_MIPS_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Originally a VxWorks extension, but now used for other systems too.  */
static reloc_howto_type elf_mips_copy_howto =
  HOWTO (R_MIPS_COPY,		/* type */
	 0,			/* rightshift */
	 0,			/* this one is variable size */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_COPY",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,         		/* src_mask */
	 0x0,		        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Originally a VxWorks extension, but now used for other systems too.  */
static reloc_howto_type elf_mips_jump_slot_howto =
  HOWTO (R_MIPS_JUMP_SLOT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_JUMP_SLOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,         		/* src_mask */
	 0x0,		        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Used in EH tables.  */
static reloc_howto_type elf_mips_eh_howto =
  HOWTO (R_MIPS_EH,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_EH",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,	        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
   dangerous relocation.  */

static bfd_boolean
mips_elf_assign_gp (bfd *output_bfd, bfd_vma *pgp)
{
  unsigned int count;
  asymbol **sym;
  unsigned int i;

  /* If we've already figured out what GP will be, just return it.  */
  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp)
    return TRUE;

  count = bfd_get_symcount (output_bfd);
  sym = bfd_get_outsymbols (output_bfd);

  /* The linker script will have created a symbol named `_gp' with the
     appropriate value.  */
  if (sym == NULL)
    i = count;
  else
    {
      for (i = 0; i < count; i++, sym++)
	{
	  register const char *name;

	  name = bfd_asymbol_name (*sym);
	  if (*name == '_' && strcmp (name, "_gp") == 0)
	    {
	      *pgp = bfd_asymbol_value (*sym);
	      _bfd_set_gp_value (output_bfd, *pgp);
	      break;
	    }
	}
    }

  if (i >= count)
    {
      /* Only get the error once.  */
      *pgp = 4;
      _bfd_set_gp_value (output_bfd, *pgp);
      return FALSE;
    }

  return TRUE;
}

/* We have to figure out the gp value, so that we can adjust the
   symbol value correctly.  We look up the symbol _gp in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocatable output.  */

static bfd_reloc_status_type
mips_elf_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
		   char **error_message, bfd_vma *pgp)
{
  if (bfd_is_und_section (symbol->section)
      && ! relocatable)
    {
      *pgp = 0;
      return bfd_reloc_undefined;
    }

  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp == 0
      && (! relocatable
	  || (symbol->flags & BSF_SECTION_SYM) != 0))
    {
      if (relocatable)
	{
	  /* Make up a value.  */
	  *pgp = symbol->section->output_section->vma /*+ 0x4000*/;
	  _bfd_set_gp_value (output_bfd, *pgp);
	}
      else if (!mips_elf_assign_gp (output_bfd, pgp))
	{
	  *error_message =
	    (char *) _("GP relative relocation when _gp not defined");
	  return bfd_reloc_dangerous;
	}
    }

  return bfd_reloc_ok;
}

/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must
   become the offset from the gp register.  This function also handles
   R_MIPS_LITERAL relocations, although those can be handled more
   cleverly because the entries in the .lit8 and .lit4 sections can be
   merged.  */

bfd_reloc_status_type
_bfd_mips_elf32_gprel16_reloc (bfd *abfd, arelent *reloc_entry,
			       asymbol *symbol, void *data,
			       asection *input_section, bfd *output_bfd,
			       char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_byte *location;
  bfd_vma gp;

  /* R_MIPS_LITERAL/R_MICROMIPS_LITERAL relocations are defined for local
     symbols only.  */
  if (literal_reloc_p (reloc_entry->howto->type)
      && output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      *error_message = (char *)
	_("literal relocation occurs for an external symbol");
      return bfd_reloc_outofrange;
    }

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf_final_gp (output_bfd, symbol, relocatable, error_message,
			   &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  location = (bfd_byte *) data + reloc_entry->address;
  _bfd_mips_elf_reloc_unshuffle (abfd, reloc_entry->howto->type, FALSE,
				 location);
  ret = _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
				       input_section, relocatable,
				       data, gp);
  _bfd_mips_elf_reloc_shuffle (abfd, reloc_entry->howto->type, !relocatable,
			       location);

  return ret;
}

/* Do a R_MIPS_GPREL32 relocation.  This is a 32 bit value which must
   become the offset from the gp register.  */

static bfd_reloc_status_type
mips_elf_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section, bfd *output_bfd,
			char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  /* R_MIPS_GPREL32 relocations are defined for local symbols only.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      *error_message = (char *)
	_("32bits gp relative relocation occurs for an external symbol");
      return bfd_reloc_outofrange;
    }

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf_final_gp (output_bfd, symbol, relocatable,
			   error_message, &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  return gprel32_with_gp (abfd, symbol, reloc_entry, input_section,
			  relocatable, data, gp);
}

static bfd_reloc_status_type
gprel32_with_gp (bfd *abfd, asymbol *symbol, arelent *reloc_entry,
		 asection *input_section, bfd_boolean relocatable,
		 void *data, bfd_vma gp)
{
  bfd_vma relocation;
  bfd_vma val;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* Handle a 64 bit reloc in a 32 bit MIPS ELF file.  These are
   generated when addresses are 64 bits.  The upper 32 bits are a simple
   sign extension.  */

static bfd_reloc_status_type
mips32_64bit_reloc (bfd *abfd, arelent *reloc_entry,
		    asymbol *symbol ATTRIBUTE_UNUSED,
		    void *data, asection *input_section,
		    bfd *output_bfd, char **error_message)
{
  bfd_reloc_status_type r;
  arelent reloc32;
  unsigned long val;
  bfd_size_type addr;

  /* Do a normal 32 bit relocation on the lower 32 bits.  */
  reloc32 = *reloc_entry;
  if (bfd_big_endian (abfd))
    reloc32.address += 4;
  reloc32.howto = &elf_mips_howto_table_rel[R_MIPS_32];
  r = bfd_perform_relocation (abfd, &reloc32, data, input_section,
			      output_bfd, error_message);

  /* Sign extend into the upper 32 bits.  */
  val = bfd_get_32 (abfd, (bfd_byte *) data + reloc32.address);
  if ((val & 0x80000000) != 0)
    val = 0xffffffff;
  else
    val = 0;
  addr = reloc_entry->address;
  if (bfd_little_endian (abfd))
    addr += 4;
  bfd_put_32 (abfd, val, (bfd_byte *) data + addr);

  return r;
}

/* Handle a mips16 GP relative reloc.  */

static bfd_reloc_status_type
mips16_gprel_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_byte *location;
  bfd_vma gp;

  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf_final_gp (output_bfd, symbol, relocatable, error_message,
			   &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  location = (bfd_byte *) data + reloc_entry->address;
  _bfd_mips_elf_reloc_unshuffle (abfd, reloc_entry->howto->type, FALSE,
				 location);
  ret = _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
				       input_section, relocatable,
				       data, gp);
  _bfd_mips_elf_reloc_shuffle (abfd, reloc_entry->howto->type, !relocatable,
			       location);

  return ret;
}

/* A mapping from BFD reloc types to MIPS ELF reloc types.  */

struct elf_reloc_map {
  bfd_reloc_code_real_type bfd_val;
  enum elf_mips_reloc_type elf_val;
};

static const struct elf_reloc_map mips_reloc_map[] =
{
  { BFD_RELOC_NONE, R_MIPS_NONE },
  { BFD_RELOC_16, R_MIPS_16 },
  { BFD_RELOC_32, R_MIPS_32 },
  /* There is no BFD reloc for R_MIPS_REL32.  */
  { BFD_RELOC_64, R_MIPS_64 },
  { BFD_RELOC_MIPS_JMP, R_MIPS_26 },
  { BFD_RELOC_HI16_S, R_MIPS_HI16 },
  { BFD_RELOC_LO16, R_MIPS_LO16 },
  { BFD_RELOC_GPREL16, R_MIPS_GPREL16 },
  { BFD_RELOC_MIPS_LITERAL, R_MIPS_LITERAL },
  { BFD_RELOC_MIPS_GOT16, R_MIPS_GOT16 },
  { BFD_RELOC_16_PCREL_S2, R_MIPS_PC16 },
  { BFD_RELOC_MIPS_CALL16, R_MIPS_CALL16 },
  { BFD_RELOC_GPREL32, R_MIPS_GPREL32 },
  { BFD_RELOC_MIPS_GOT_HI16, R_MIPS_GOT_HI16 },
  { BFD_RELOC_MIPS_GOT_LO16, R_MIPS_GOT_LO16 },
  { BFD_RELOC_MIPS_CALL_HI16, R_MIPS_CALL_HI16 },
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 },
  { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
  { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
  { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP },
  { BFD_RELOC_MIPS_JALR, R_MIPS_JALR },
  { BFD_RELOC_MIPS_TLS_DTPMOD32, R_MIPS_TLS_DTPMOD32 },
  { BFD_RELOC_MIPS_TLS_DTPREL32, R_MIPS_TLS_DTPREL32 },
  { BFD_RELOC_MIPS_TLS_DTPMOD64, R_MIPS_TLS_DTPMOD64 },
  { BFD_RELOC_MIPS_TLS_DTPREL64, R_MIPS_TLS_DTPREL64 },
  { BFD_RELOC_MIPS_TLS_GD, R_MIPS_TLS_GD },
  { BFD_RELOC_MIPS_TLS_LDM, R_MIPS_TLS_LDM },
  { BFD_RELOC_MIPS_TLS_DTPREL_HI16, R_MIPS_TLS_DTPREL_HI16 },
  { BFD_RELOC_MIPS_TLS_DTPREL_LO16, R_MIPS_TLS_DTPREL_LO16 },
  { BFD_RELOC_MIPS_TLS_GOTTPREL, R_MIPS_TLS_GOTTPREL },
  { BFD_RELOC_MIPS_TLS_TPREL32, R_MIPS_TLS_TPREL32 },
  { BFD_RELOC_MIPS_TLS_TPREL64, R_MIPS_TLS_TPREL64 },
  { BFD_RELOC_MIPS_TLS_TPREL_HI16, R_MIPS_TLS_TPREL_HI16 },
  { BFD_RELOC_MIPS_TLS_TPREL_LO16, R_MIPS_TLS_TPREL_LO16 }
};

static const struct elf_reloc_map mips16_reloc_map[] =
{
  { BFD_RELOC_MIPS16_JMP, R_MIPS16_26 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_GPREL, R_MIPS16_GPREL - R_MIPS16_min },
  { BFD_RELOC_MIPS16_GOT16, R_MIPS16_GOT16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_CALL16, R_MIPS16_CALL16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_HI16_S, R_MIPS16_HI16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_LO16, R_MIPS16_LO16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_GD, R_MIPS16_TLS_GD - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_LDM, R_MIPS16_TLS_LDM - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
    R_MIPS16_TLS_DTPREL_HI16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
    R_MIPS16_TLS_DTPREL_LO16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_GOTTPREL, R_MIPS16_TLS_GOTTPREL - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_TPREL_HI16, R_MIPS16_TLS_TPREL_HI16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_TPREL_LO16, R_MIPS16_TLS_TPREL_LO16 - R_MIPS16_min }
};

static const struct elf_reloc_map micromips_reloc_map[] =
{
  { BFD_RELOC_MICROMIPS_JMP, R_MICROMIPS_26_S1 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_HI16_S, R_MICROMIPS_HI16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_LO16, R_MICROMIPS_LO16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GPREL16, R_MICROMIPS_GPREL16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_LITERAL, R_MICROMIPS_LITERAL - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT16, R_MICROMIPS_GOT16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_7_PCREL_S1, R_MICROMIPS_PC7_S1 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_10_PCREL_S1, R_MICROMIPS_PC10_S1 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_16_PCREL_S1, R_MICROMIPS_PC16_S1 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_CALL16, R_MICROMIPS_CALL16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT_DISP, R_MICROMIPS_GOT_DISP - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT_PAGE, R_MICROMIPS_GOT_PAGE - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT_OFST, R_MICROMIPS_GOT_OFST - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT_HI16, R_MICROMIPS_GOT_HI16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT_LO16, R_MICROMIPS_GOT_LO16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_SUB, R_MICROMIPS_SUB - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_HIGHER, R_MICROMIPS_HIGHER - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_HIGHEST, R_MICROMIPS_HIGHEST - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_CALL_HI16, R_MICROMIPS_CALL_HI16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_CALL_LO16, R_MICROMIPS_CALL_LO16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_SCN_DISP, R_MICROMIPS_SCN_DISP - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_JALR, R_MICROMIPS_JALR - R_MICROMIPS_min },
  /* There is no BFD reloc for R_MICROMIPS_HI0_LO16.  */
  { BFD_RELOC_MICROMIPS_TLS_GD, R_MICROMIPS_TLS_GD - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_TLS_LDM, R_MICROMIPS_TLS_LDM - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16,
    R_MICROMIPS_TLS_DTPREL_HI16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16,
    R_MICROMIPS_TLS_DTPREL_LO16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_TLS_GOTTPREL,
    R_MICROMIPS_TLS_GOTTPREL - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_TLS_TPREL_HI16,
    R_MICROMIPS_TLS_TPREL_HI16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_TLS_TPREL_LO16,
    R_MICROMIPS_TLS_TPREL_LO16 - R_MICROMIPS_min },
  /* There is no BFD reloc for R_MICROMIPS_GPREL7_S2.  */
  /* There is no BFD reloc for R_MICROMIPS_PC23_S2.  */
};

/* Given a BFD reloc type, return a howto structure.  */

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
{
  unsigned int i;
  reloc_howto_type *howto_table = elf_mips_howto_table_rel;
  reloc_howto_type *howto16_table = elf_mips16_howto_table_rel;
  reloc_howto_type *howto_micromips_table = elf_micromips_howto_table_rel;

  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
    {
      if (mips_reloc_map[i].bfd_val == code)
	return &howto_table[(int) mips_reloc_map[i].elf_val];
    }

  for (i = 0; i < sizeof (mips16_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
    {
      if (mips16_reloc_map[i].bfd_val == code)
	return &howto16_table[(int) mips16_reloc_map[i].elf_val];
    }

  for (i = 0; i < sizeof (micromips_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
    {
      if (micromips_reloc_map[i].bfd_val == code)
	return &howto_micromips_table[(int) micromips_reloc_map[i].elf_val];
    }

  switch (code)
    {
    default:
      bfd_set_error (bfd_error_bad_value);
      return NULL;

    case BFD_RELOC_CTOR:
      /* We need to handle BFD_RELOC_CTOR specially.
	 Select the right relocation (R_MIPS_32 or R_MIPS_64) based on the
	 size of addresses of the ABI.  */
      if ((elf_elfheader (abfd)->e_flags & (E_MIPS_ABI_O64
					    | E_MIPS_ABI_EABI64)) != 0)
	return &elf_mips_ctor64_howto;
      else
	return &howto_table[(int) R_MIPS_32];

    case BFD_RELOC_VTABLE_INHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf_mips_gnu_vtentry_howto;
    case BFD_RELOC_32_PCREL:
      return &elf_mips_gnu_pcrel32;
    case BFD_RELOC_MIPS_COPY:
      return &elf_mips_copy_howto;
    case BFD_RELOC_MIPS_JUMP_SLOT:
      return &elf_mips_jump_slot_howto;
    case BFD_RELOC_MIPS_EH:
      return &elf_mips_eh_howto;
    }
}

static reloc_howto_type *
bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < (sizeof (elf_mips_howto_table_rel)
	    / sizeof (elf_mips_howto_table_rel[0]));
       i++)
    if (elf_mips_howto_table_rel[i].name != NULL
	&& strcasecmp (elf_mips_howto_table_rel[i].name, r_name) == 0)
      return &elf_mips_howto_table_rel[i];

  for (i = 0;
       i < (sizeof (elf_mips16_howto_table_rel)
	    / sizeof (elf_mips16_howto_table_rel[0]));
       i++)
    if (elf_mips16_howto_table_rel[i].name != NULL
	&& strcasecmp (elf_mips16_howto_table_rel[i].name, r_name) == 0)
      return &elf_mips16_howto_table_rel[i];

  for (i = 0;
       i < (sizeof (elf_micromips_howto_table_rel)
	    / sizeof (elf_micromips_howto_table_rel[0]));
       i++)
    if (elf_micromips_howto_table_rel[i].name != NULL
	&& strcasecmp (elf_micromips_howto_table_rel[i].name, r_name) == 0)
      return &elf_micromips_howto_table_rel[i];

  if (strcasecmp (elf_mips_gnu_pcrel32.name, r_name) == 0)
    return &elf_mips_gnu_pcrel32;
  if (strcasecmp (elf_mips_gnu_rel16_s2.name, r_name) == 0)
    return &elf_mips_gnu_rel16_s2;
  if (strcasecmp (elf_mips_gnu_vtinherit_howto.name, r_name) == 0)
    return &elf_mips_gnu_vtinherit_howto;
  if (strcasecmp (elf_mips_gnu_vtentry_howto.name, r_name) == 0)
    return &elf_mips_gnu_vtentry_howto;
  if (strcasecmp (elf_mips_copy_howto.name, r_name) == 0)
    return &elf_mips_copy_howto;
  if (strcasecmp (elf_mips_jump_slot_howto.name, r_name) == 0)
    return &elf_mips_jump_slot_howto;
  if (strcasecmp (elf_mips_eh_howto.name, r_name) == 0)
    return &elf_mips_eh_howto;

  return NULL;
}

/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */

static reloc_howto_type *
mips_elf32_rtype_to_howto (unsigned int r_type,
			   bfd_boolean rela_p ATTRIBUTE_UNUSED)
{
  switch (r_type)
    {
    case R_MIPS_GNU_VTINHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case R_MIPS_GNU_VTENTRY:
      return &elf_mips_gnu_vtentry_howto;
    case R_MIPS_GNU_REL16_S2:
      return &elf_mips_gnu_rel16_s2;
    case R_MIPS_PC32:
      return &elf_mips_gnu_pcrel32;
    case R_MIPS_COPY:
      return &elf_mips_copy_howto;
    case R_MIPS_JUMP_SLOT:
      return &elf_mips_jump_slot_howto;
    case R_MIPS_EH:
      return &elf_mips_eh_howto;
    default:
      if (r_type >= R_MICROMIPS_min && r_type < R_MICROMIPS_max)
	return &elf_micromips_howto_table_rel[r_type - R_MICROMIPS_min];
      if (r_type >= R_MIPS16_min && r_type < R_MIPS16_max)
        return &elf_mips16_howto_table_rel[r_type - R_MIPS16_min];
      BFD_ASSERT (r_type < (unsigned int) R_MIPS_max);
      return &elf_mips_howto_table_rel[r_type];
    }
}

/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */

static void
mips_info_to_howto_rel (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  const struct elf_backend_data *bed;
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  bed = get_elf_backend_data (abfd);
  cache_ptr->howto = bed->elf_backend_mips_rtype_to_howto (r_type, FALSE);

  /* The addend for a GPREL16 or LITERAL relocation comes from the GP
     value for the object file.  We get the addend now, rather than
     when we do the relocation, because the symbol manipulations done
     by the linker may cause us to lose track of the input BFD.  */
  if (((*cache_ptr->sym_ptr_ptr)->flags & BSF_SECTION_SYM) != 0
      && (gprel16_reloc_p (r_type) || literal_reloc_p (r_type)))
    cache_ptr->addend = elf_gp (abfd);
}

/* Given a MIPS Elf_Internal_Rela, fill in an arelent structure.  */

static void
mips_info_to_howto_rela (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  mips_info_to_howto_rel (abfd, cache_ptr, dst);

  /* If we ever need to do any extra processing with dst->r_addend
     (the field omitted in an Elf_Internal_Rel) we can do it here.  */
}

/* Determine whether a symbol is global for the purposes of splitting
   the symbol table into global symbols and local symbols.  At least
   on Irix 5, this split must be between section symbols and all other
   symbols.  On most ELF targets the split is between static symbols
   and externally visible symbols.  */

static bfd_boolean
mips_elf_sym_is_global (bfd *abfd ATTRIBUTE_UNUSED, asymbol *sym)
{
  if (SGI_COMPAT (abfd))
    return (sym->flags & BSF_SECTION_SYM) == 0;
  else
    return ((sym->flags & (BSF_GLOBAL | BSF_WEAK | BSF_GNU_UNIQUE)) != 0
	    || bfd_is_und_section (bfd_get_section (sym))
	    || bfd_is_com_section (bfd_get_section (sym)));
}

/* Set the right machine number for a MIPS ELF file.  */

static bfd_boolean
mips_elf32_object_p (bfd *abfd)
{
  unsigned long mach;

  if (ABI_N32_P (abfd))
    return FALSE;

  /* Irix 5 and 6 are broken.  Object file symbol tables are not always
     sorted correctly such that local symbols precede global symbols,
     and the sh_info field in the symbol table is not always right.  */
  if (SGI_COMPAT (abfd))
    elf_bad_symtab (abfd) = TRUE;

  mach = _bfd_elf_mips_mach (elf_elfheader (abfd)->e_flags);
  bfd_default_set_arch_mach (abfd, bfd_arch_mips, mach);
  return TRUE;
}

/* MIPS ELF local labels start with '$', not 'L'.  */

static bfd_boolean
mips_elf_is_local_label_name (bfd *abfd, const char *name)
{
  if (name[0] == '$')
    return TRUE;

  /* On Irix 6, the labels go back to starting with '.', so we accept
     the generic ELF local label syntax as well.  */
  return _bfd_elf_is_local_label_name (abfd, name);
}

/* Support for core dump NOTE sections.  */
static bfd_boolean
elf32_mips_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  unsigned int size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 256:		/* Linux/MIPS */
	/* pr_cursig */
	elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	size = 180;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
elf32_mips_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      case 128:		/* Linux/MIPS elf_prpsinfo */
	elf_tdata (abfd)->core->program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
	elf_tdata (abfd)->core->command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

/* Depending on the target vector we generate some version of Irix
   executables or "normal" MIPS ELF ABI executables.  */
static irix_compat_t
elf32_mips_irix_compat (bfd *abfd)
{
  if ((abfd->xvec == &bfd_elf32_bigmips_vec)
      || (abfd->xvec == &bfd_elf32_littlemips_vec))
    return ict_irix5;
  else
    return ict_none;
}

/* ECOFF swapping routines.  These are used when dealing with the
   .mdebug section, which is in the ECOFF debugging format.  */
static const struct ecoff_debug_swap mips_elf32_ecoff_debug_swap = {
  /* Symbol table magic number.  */
  magicSym,
  /* Alignment of debugging information.  E.g., 4.  */
  4,
  /* Sizes of external symbolic information.  */
  sizeof (struct hdr_ext),
  sizeof (struct dnr_ext),
  sizeof (struct pdr_ext),
  sizeof (struct sym_ext),
  sizeof (struct opt_ext),
  sizeof (struct fdr_ext),
  sizeof (struct rfd_ext),
  sizeof (struct ext_ext),
  /* Functions to swap in external symbolic data.  */
  ecoff_swap_hdr_in,
  ecoff_swap_dnr_in,
  ecoff_swap_pdr_in,
  ecoff_swap_sym_in,
  ecoff_swap_opt_in,
  ecoff_swap_fdr_in,
  ecoff_swap_rfd_in,
  ecoff_swap_ext_in,
  _bfd_ecoff_swap_tir_in,
  _bfd_ecoff_swap_rndx_in,
  /* Functions to swap out external symbolic data.  */
  ecoff_swap_hdr_out,
  ecoff_swap_dnr_out,
  ecoff_swap_pdr_out,
  ecoff_swap_sym_out,
  ecoff_swap_opt_out,
  ecoff_swap_fdr_out,
  ecoff_swap_rfd_out,
  ecoff_swap_ext_out,
  _bfd_ecoff_swap_tir_out,
  _bfd_ecoff_swap_rndx_out,
  /* Function to read in symbolic data.  */
  _bfd_mips_elf_read_ecoff_info
};

#define ELF_ARCH			bfd_arch_mips
#define ELF_TARGET_ID			MIPS_ELF_DATA
#define ELF_MACHINE_CODE		EM_MIPS

#define elf_backend_collect		TRUE
#define elf_backend_type_change_ok	TRUE
#define elf_backend_can_gc_sections	TRUE
#define elf_info_to_howto		mips_info_to_howto_rela
#define elf_info_to_howto_rel		mips_info_to_howto_rel
#define elf_backend_sym_is_global	mips_elf_sym_is_global
#define elf_backend_object_p		mips_elf32_object_p
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
#define elf_backend_section_from_shdr	_bfd_mips_elf_section_from_shdr
#define elf_backend_fake_sections	_bfd_mips_elf_fake_sections
#define elf_backend_section_from_bfd_section \
					_bfd_mips_elf_section_from_bfd_section
#define elf_backend_add_symbol_hook	_bfd_mips_elf_add_symbol_hook
#define elf_backend_link_output_symbol_hook \
					_bfd_mips_elf_link_output_symbol_hook
#define elf_backend_create_dynamic_sections \
					_bfd_mips_elf_create_dynamic_sections
#define elf_backend_check_relocs	_bfd_mips_elf_check_relocs
#define elf_backend_merge_symbol_attribute \
					_bfd_mips_elf_merge_symbol_attribute
#define elf_backend_get_target_dtag	_bfd_mips_elf_get_target_dtag
#define elf_backend_adjust_dynamic_symbol \
					_bfd_mips_elf_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
					_bfd_mips_elf_always_size_sections
#define elf_backend_size_dynamic_sections \
					_bfd_mips_elf_size_dynamic_sections
#define elf_backend_init_index_section	_bfd_elf_init_1_index_section
#define elf_backend_relocate_section	_bfd_mips_elf_relocate_section
#define elf_backend_finish_dynamic_symbol \
					_bfd_mips_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					_bfd_mips_elf_finish_dynamic_sections
#define elf_backend_final_write_processing \
					_bfd_mips_elf_final_write_processing
#define elf_backend_additional_program_headers \
					_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
#define elf_backend_gc_mark_hook	_bfd_mips_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	_bfd_mips_elf_gc_sweep_hook
#define elf_backend_copy_indirect_symbol \
					_bfd_mips_elf_copy_indirect_symbol
#define elf_backend_grok_prstatus	elf32_mips_grok_prstatus
#define elf_backend_grok_psinfo		elf32_mips_grok_psinfo
#define elf_backend_ecoff_debug_swap	&mips_elf32_ecoff_debug_swap

#define elf_backend_got_header_size	(4 * MIPS_RESERVED_GOTNO)
#define elf_backend_may_use_rel_p	1
#define elf_backend_may_use_rela_p	0
#define elf_backend_default_use_rela_p	0
#define elf_backend_sign_extend_vma	TRUE
#define elf_backend_plt_readonly	1

#define elf_backend_discard_info	_bfd_mips_elf_discard_info
#define elf_backend_ignore_discarded_relocs \
					_bfd_mips_elf_ignore_discarded_relocs
#define elf_backend_write_section	_bfd_mips_elf_write_section
#define elf_backend_mips_irix_compat	elf32_mips_irix_compat
#define elf_backend_mips_rtype_to_howto	mips_elf32_rtype_to_howto
#define bfd_elf32_bfd_is_local_label_name \
					mips_elf_is_local_label_name
#define bfd_elf32_bfd_is_target_special_symbol \
					_bfd_mips_elf_is_target_special_symbol
#define bfd_elf32_get_synthetic_symtab	_bfd_mips_elf_get_synthetic_symtab
#define bfd_elf32_find_nearest_line	_bfd_mips_elf_find_nearest_line
#define bfd_elf32_find_inliner_info	_bfd_mips_elf_find_inliner_info
#define bfd_elf32_new_section_hook	_bfd_mips_elf_new_section_hook
#define bfd_elf32_set_section_contents	_bfd_mips_elf_set_section_contents
#define bfd_elf32_bfd_get_relocated_section_contents \
				_bfd_elf_mips_get_relocated_section_contents
#define bfd_elf32_bfd_link_hash_table_create \
					_bfd_mips_elf_link_hash_table_create
#define bfd_elf32_bfd_final_link	_bfd_mips_elf_final_link
#define bfd_elf32_bfd_merge_private_bfd_data \
					_bfd_mips_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags	_bfd_mips_elf_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data \
					_bfd_mips_elf_print_private_bfd_data
#define bfd_elf32_bfd_relax_section	_bfd_mips_elf_relax_section
#define bfd_elf32_mkobject		_bfd_mips_elf_mkobject

/* Support for SGI-ish mips targets.  */
#define TARGET_LITTLE_SYM		bfd_elf32_littlemips_vec
#define TARGET_LITTLE_NAME		"elf32-littlemips"
#define TARGET_BIG_SYM			bfd_elf32_bigmips_vec
#define TARGET_BIG_NAME			"elf32-bigmips"

/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.  */
#define ELF_MAXPAGESIZE			0x1000
#define ELF_COMMONPAGESIZE		0x1000

#include "elf32-target.h"

/* Support for traditional mips targets.  */
#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME
#undef TARGET_BIG_SYM
#undef TARGET_BIG_NAME

#undef ELF_MAXPAGESIZE
#undef ELF_COMMONPAGESIZE

#define TARGET_LITTLE_SYM               bfd_elf32_tradlittlemips_vec
#define TARGET_LITTLE_NAME              "elf32-tradlittlemips"
#define TARGET_BIG_SYM                  bfd_elf32_tradbigmips_vec
#define TARGET_BIG_NAME                 "elf32-tradbigmips"

/* The MIPS ABI says at Page 5-1:
   Virtual addresses and file offsets for MIPS segments are congruent
   modulo 64 KByte (0x10000) or larger powers of 2.  Because 64 KBytes
   is the maximum page size, the files are suitable for paging
   regardless of physical page size.  */
#define ELF_MAXPAGESIZE			0x10000
#define ELF_COMMONPAGESIZE		0x1000
#define elf32_bed			elf32_tradbed

/* Include the target file again for this target.  */
#include "elf32-target.h"

/* FreeBSD support.  */

#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME
#undef TARGET_BIG_SYM
#undef TARGET_BIG_NAME

#define	TARGET_LITTLE_SYM		bfd_elf32_tradlittlemips_freebsd_vec
#define	TARGET_LITTLE_NAME		"elf32-tradlittlemips-freebsd"
#define	TARGET_BIG_SYM			bfd_elf32_tradbigmips_freebsd_vec
#define	TARGET_BIG_NAME			"elf32-tradbigmips-freebsd"

#undef	ELF_OSABI
#define	ELF_OSABI			ELFOSABI_FREEBSD

/* The kernel recognizes executables as valid only if they carry a
   "FreeBSD" label in the ELF header.  So we put this label on all
   executables and (for simplicity) also all other object files.  */

static void
elf_fbsd_post_process_headers (bfd *abfd, struct bfd_link_info *info)
{
  _bfd_elf_set_osabi (abfd, info);
}

#undef	elf_backend_post_process_headers
#define	elf_backend_post_process_headers	elf_fbsd_post_process_headers
#undef	elf32_bed
#define elf32_bed				elf32_fbsd_tradbed

#include "elf32-target.h"
/* Implement elf_backend_final_write_processing for VxWorks.  */

static void
mips_vxworks_final_write_processing (bfd *abfd, bfd_boolean linker)
{
  _bfd_mips_elf_final_write_processing (abfd, linker);
  elf_vxworks_final_write_processing (abfd, linker);
}

#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME
#undef TARGET_BIG_SYM
#undef TARGET_BIG_NAME

#undef ELF_MAXPAGESIZE
#undef ELF_COMMONPAGESIZE

#define TARGET_LITTLE_SYM               bfd_elf32_littlemips_vxworks_vec
#define TARGET_LITTLE_NAME              "elf32-littlemips-vxworks"
#define TARGET_BIG_SYM                  bfd_elf32_bigmips_vxworks_vec
#define TARGET_BIG_NAME                 "elf32-bigmips-vxworks"
#undef	ELF_OSABI

#undef elf32_bed
#define elf32_bed			elf32_mips_vxworks_bed

#define ELF_MAXPAGESIZE			0x1000
#define ELF_COMMONPAGESIZE		0x1000

#undef elf_backend_want_got_plt
#define elf_backend_want_got_plt		1
#undef elf_backend_want_plt_sym
#define elf_backend_want_plt_sym		1
#undef elf_backend_may_use_rel_p
#define elf_backend_may_use_rel_p		0
#undef elf_backend_may_use_rela_p
#define elf_backend_may_use_rela_p		1
#undef elf_backend_default_use_rela_p
#define elf_backend_default_use_rela_p		1
#undef elf_backend_got_header_size
#define elf_backend_got_header_size		(4 * 3)

#undef elf_backend_finish_dynamic_symbol
#define elf_backend_finish_dynamic_symbol \
  _bfd_mips_vxworks_finish_dynamic_symbol
#undef bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create \
  _bfd_mips_vxworks_link_hash_table_create
#undef elf_backend_add_symbol_hook
#define elf_backend_add_symbol_hook \
  elf_vxworks_add_symbol_hook
#undef elf_backend_link_output_symbol_hook
#define elf_backend_link_output_symbol_hook \
  elf_vxworks_link_output_symbol_hook
#undef elf_backend_emit_relocs
#define elf_backend_emit_relocs \
  elf_vxworks_emit_relocs
#undef elf_backend_final_write_processing
#define elf_backend_final_write_processing \
  mips_vxworks_final_write_processing

#undef elf_backend_additional_program_headers
#undef elf_backend_modify_segment_map
#undef elf_backend_symbol_processing
/* NOTE: elf_backend_rela_normal is not defined for MIPS.  */

#undef bfd_elf32_get_synthetic_symtab

#include "elf32-target.h"
@


1.218
log
@	bfd/
	* elfxx-mips.h (_bfd_mips_elf_get_synthetic_symtab): New
	prototype.
	* elf32-mips.c (elf_backend_plt_sym_val): Remove macro.
	(bfd_elf32_get_synthetic_symtab): New macro.
	* elfxx-mips.c (plt_entry): New structure.
	(mips_elf_link_hash_entry): Add use_plt_entry member.
	(mips_elf_link_hash_table): Rename plt_entry_size member to
	plt_mips_entry_size.  Add plt_comp_entry_size, plt_mips_offset,
	plt_comp_offset, plt_got_index entries and plt_header_is_comp
	members.
	(STUB_LW_MICROMIPS, STUB_MOVE_MICROMIPS): New macros.
	(STUB_LUI_MICROMIPS, STUB_JALR_MICROMIPS): Likewise.
	(STUB_ORI_MICROMIPS, STUB_LI16U_MICROMIPS): Likewise.
	(STUB_LI16S_MICROMIPS): Likewise.
	(MICROMIPS_FUNCTION_STUB_NORMAL_SIZE): Likewise.
	(MICROMIPS_FUNCTION_STUB_BIG_SIZE): Likewise.
	(micromips_o32_exec_plt0_entry): New variable.
	(mips16_o32_exec_plt_entry): Likewise.
	(micromips_o32_exec_plt_entry): Likewise.
	(mips_elf_link_hash_newfunc): Initialize use_plt_entry.
	(mips_elf_output_extsym): Update to use gotplt_union's plist
	member rather than offset.
	(mips_elf_gotplt_index): Likewise.  Remove the VxWorks
	restriction.  Use MIPS_ELF_GOT_SIZE to calculate GOT address.
	(mips_elf_count_got_symbols): Update to use gotplt_union's plist
	member rather than offset.
	(mips_elf_calculate_relocation): Handle MIPS16/microMIPS PLT
	entries.
	(_bfd_mips_elf_create_dynamic_sections): Don't set PLT sizes
	here.
	(mips_elf_make_plt_record): New function.
	(_bfd_mips_elf_check_relocs): Update comment.  Record occurences
	of JAL relocations that might need a PLT entry.
	(_bfd_mips_elf_adjust_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Set individual
	PLT entry sizes here.  Handle MIPS16/microMIPS PLT entries.
	Don't set the symbol's value in the symbol table for PLT
	references here.  Don't set the PLT or PLT GOT section sizes
	here.
	(mips_elf_estimate_stub_size): Handle microMIPS stubs.
	(mips_elf_allocate_lazy_stub): Likewise.
	(mips_elf_lay_out_lazy_stubs): Likewise.  Define a _MIPS_STUBS_
	magic symbol.
	(mips_elf_set_plt_sym_value): New function.
	(_bfd_mips_elf_size_dynamic_sections): Set PLT header size and
	PLT and PLT GOT section sizes here.  Set the symbol values in
	the symbol table for PLT references here.  Handle microMIPS
	annotation of the _PROCEDURE_LINKAGE_TABLE_ magic symbol.
	(_bfd_mips_elf_finish_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Handle
	MIPS16/microMIPS PLT entries.  Handle microMIPS stubs.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Use
	MIPS_ELF_GOT_SIZE to calculate GOT address.
	(mips_finish_exec_plt): Handle microMIPS PLT.  Return status.
	(_bfd_mips_elf_finish_dynamic_sections): Handle result from
	mips_finish_exec_plt.
	(_bfd_mips_elf_link_hash_table_create): Update to use
	gotplt_union's plist member rather than offset.
	(_bfd_mips_elf_get_synthetic_symtab): New function.

	include/elf/
	* mips.h (ELF_ST_IS_MIPS_PLT): Respect STO_MIPS16 setting.
	(ELF_ST_SET_MIPS_PLT): Likewise.

	gdb/
	* mips-tdep.c (mips_elf_make_msymbol_special): Handle MIPS16 and
	microMIPS synthetic symbols.

	ld/
	* emulparams/elf32btsmip.sh: Arrange for .got.plt to be placed
	as close to .plt as possible.
	* scripttempl/elf.sc: Handle $INITIAL_READWRITE_SECTIONS and
	$PLT_NEXT_DATA variables.

	ld/testsuite/
	* ld-mips-elf/jalx-2.dd: Update for microMIPS PLT support.
	* ld-mips-elf/pic-and-nonpic-3a.dd: Update for the _MIPS_STUBS_
	magic symbol.
	* ld-mips-elf/pic-and-nonpic-3b.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-n32.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-n64.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-o32.dd: Likewise.
	* ld-mips-elf/stub-dynsym-1-10000.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-2fe80.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-7fff.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-8000.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-fff0.d: Likewise.
	* ld-mips-elf/tlslib-o32.d: Likewise.

	opcodes/
	* mips-dis.c (is_mips16_plt_tail): New function.
	(print_insn_mips16): Handle MIPS16 PLT entry's GOT slot address
	word.
	(is_compressed_mode_p): Handle MIPS16/microMIPS PLT entries.
@
text
@d2489 1
@


1.218.2.1
log
@	* elf32-mips.c (ELF_OSABI): Undef for vxworks.
@
text
@a2488 1
#undef	ELF_OSABI
@


1.217
log
@2013-05-30  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* bfd-in2.h: Regenerate.
	* elf32-mips.c (elf_mips_eh_howto): New.
	(bfd_elf32_bfd_reloc_type_lookup ): Support BFD_RELOC_MIPS_EH.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(mips_elf32_rtype_to_howto): Support R_MIPS_EH.
	* elf64-mips.c (elf_mips_eh_howto): New.
	(bfd_elf64_bfd_reloc_type_lookup): Support BFD_RELOC_MIPS_EH.
	(bfd_elf64_bfd_reloc_name_lookup): Likewise.
	(mips_elf64_rtype_to_howto): Support R_MIPS_EH.
	* libbfd.h: Regenerate.
	* reloc.c (BFD_RELOC_MIPS_EH): New.

	gas/
	* config/tc-mips.c (md_apply_fix): Support BFD_RELOC_MIPS_EH.

	include/elf
	* mips.h (R_MIPS_EH): New.
@
text
@a2368 1
#define elf_backend_plt_sym_val		_bfd_mips_elf_plt_sym_val
d2380 1
a2507 1
#undef elf_backend_plt_sym_val
d2533 2
@


1.216
log
@bfd/
	* elf32-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto):
	Use _bfd_mips_elf_generic_reloc instead of bfd_elf_generic_reloc.
	* elfn32-mips.c: Likewise.
	* elf64-mips.c: Likewise.
@
text
@d1541 16
d2029 2
d2076 2
d2102 2
@


1.215
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d1518 1
a1518 1
	 bfd_elf_generic_reloc,	/* special_function */
d1534 1
a1534 1
	 bfd_elf_generic_reloc,	/* special_function */
@


1.214
log
@	* elf32-mips.c (mips_elf32_object_p): Return right away when the
	ABI is not compatible.
	* elfn32-mips.c (mips_elf_n32_object_p): Likewise.
@
text
@d2189 1
a2189 1
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d2192 1
a2192 1
	elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 24);
d2215 1
a2215 1
	elf_tdata (abfd)->core_program
d2217 1
a2217 1
	elf_tdata (abfd)->core_command
d2226 1
a2226 1
    char *command = elf_tdata (abfd)->core_command;
@


1.213
log
@	bfd/
	* elf32-mips.c (bfd_elf32_mkobject): New macro.
	* elf64-mips.c (bfd_elf64_mkobject): Likewise.
	* elfn32-mips.c (bfd_elf32_mkobject): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): New prototype.
	* elfxx-mips.c (mips_elf_obj_tdata): New struct.
	(mips_elf_tdata): New macro.
	(_bfd_mips_elf_mkobject): New function.
	(mips_elf_merge_obj_attributes): Report the originating input BFD
	on attribute conflicts.

	ld/testsuite/
	* ld-mips-elf/attr-gnu-4-12.d: Update the warning message.
	* ld-mips-elf/attr-gnu-4-13.d: Likewise.
	* ld-mips-elf/attr-gnu-4-14.d: Likewise.
	* ld-mips-elf/attr-gnu-4-15.d: Likewise.
	* ld-mips-elf/attr-gnu-4-21.d: Likewise.
	* ld-mips-elf/attr-gnu-4-23.d: Likewise.
	* ld-mips-elf/attr-gnu-4-24.d: Likewise.
	* ld-mips-elf/attr-gnu-4-25.d: Likewise.
	* ld-mips-elf/attr-gnu-4-31.d: Likewise.
	* ld-mips-elf/attr-gnu-4-32.d: Likewise.
	* ld-mips-elf/attr-gnu-4-34.d: Likewise.
	* ld-mips-elf/attr-gnu-4-35.d: Likewise.
	* ld-mips-elf/attr-gnu-4-41.d: Likewise.
	* ld-mips-elf/attr-gnu-4-42.d: Likewise.
	* ld-mips-elf/attr-gnu-4-43.d: Likewise.
	* ld-mips-elf/attr-gnu-4-45.d: Likewise.
	* ld-mips-elf/attr-gnu-4-51.d: Likewise.
@
text
@d2148 3
a2156 3
  if (ABI_N32_P (abfd))
    return FALSE;

a2158 1

@


1.212
log
@
2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	gas/
	* config/tc-mips.c (mips_pseudo_table): Add tprelword/tpreldword
	entries.
	(mips16_percent_op): Add MIPS16 TLS relocation ops.
	(md_apply_fix): Add BFD_RELOC_MIPS16_TLS_* switch cases.
	(s_tls_rel_directive): Rename from s_dtprel_internal(). Abstract out
	directive string and reloc type as function parameters. Update
	comments.
	(s_dtprelword,s_dtpreldword): Change to use s_tls_rel_directive().
	(s_tprelword,s_tpreldword): New functions.

	include/
	* elf/mips.h (elf_mips_reloc_type): Add R_MIPS16_TLS_* entries.

	bfd/
	* reloc.c (BFD_RELOC_MIPS16_TLS_GD,BFD_RELOC_MIPS16_TLS_LDM,
	BFD_RELOC_MIPS16_TLS_DTPREL_HI16,BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
	BFD_RELOC_MIPS16_TLS_GOTTPREL,BFD_RELOC_MIPS16_TLS_TPREL_HI16,
	BFD_RELOC_MIPS16_TLS_TPREL_LO16): New relocations for MIPS16 TLS.
	* bfd-in2.h (bfd_reloc_code_real): Regenerate.
	* libbfd.h (bfd_reloc_code_real_names): Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Add R_MIPS16_TLS_*
	entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel,
	elf_mips16_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel,
	mips16_elf64_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfxx-mips.c (TLS_RELOC_P,mips16_reloc_p,
	_bfd_mips_elf_check_relocs): Add cases for R_MIPS16_TLS_* relocations.
	(tls_gd_reloc_p): Add R_MIPS16_TLS_GD case.
	(tls_ldm_reloc_p): Add R_MIPS16_TLS_LDM case.
	(tls_gottprel_reloc_p): Add R_MIPS16_TLS_GOTTPREL case.
	(mips_elf_calculate_relocation): Add cases for R_MIPS16_TLS_*,
	R_MIPS_TLS_DTPREL32/64, and R_MIPS_TLS_TPREL32/64 relocations.
@
text
@d2375 1
@


1.211
log
@bfd/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Ilie Garbacea  <ilie@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Catherine Moore  <clm@@codesourcery.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* archures.c (bfd_mach_mips_micromips): New macro.
	* cpu-mips.c (I_micromips): New enum value.
	(arch_info_struct): Add bfd_mach_mips_micromips.
	* elfxx-mips.h (_bfd_mips_elf_is_target_special_symbol): New
	prototype.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(gprel16_reloc_p): Handle microMIPS ASE.
	(literal_reloc_p): New function.
	* elf32-mips.c (elf_micromips_howto_table_rel): New variable.
	(_bfd_mips_elf32_gprel16_reloc): Handle microMIPS ASE.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(mips_elf_gprel32_reloc): Update comment.
	(micromips_reloc_map): New variable.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(mips_elf32_rtype_to_howto): Likewise.
	(mips_info_to_howto_rel): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	(bfd_elf32_bfd_relax_section): Likewise.
	* elf64-mips.c (micromips_elf64_howto_table_rel): New variable.
	(micromips_elf64_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf64_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf64_bfd_reloc_name_lookup): Likewise.
	(mips_elf64_rtype_to_howto): Likewise.
	(bfd_elf64_bfd_is_target_special_symbol): Define.
	* elfn32-mips.c (elf_micromips_howto_table_rel): New variable.
	(elf_micromips_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(mips_elf_n32_rtype_to_howto): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	* elfxx-mips.c (LA25_LUI_MICROMIPS_1): New macro.
	(LA25_LUI_MICROMIPS_2): Likewise.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise.
	(TLS_RELOC_P): Handle microMIPS ASE.
	(mips_elf_create_stub_symbol): Adjust value of stub symbol if
	target is a microMIPS function.
	(micromips_reloc_p): New function.
	(micromips_reloc_shuffle_p): Likewise.
	(got16_reloc_p, call16_reloc_p): Handle microMIPS ASE.
	(got_disp_reloc_p, got_page_reloc_p): New functions.
	(got_ofst_reloc_p): Likewise.
	(got_hi16_reloc_p, got_lo16_reloc_p): Likewise.
	(call_hi16_reloc_p, call_lo16_reloc_p): Likewise.
	(hi16_reloc_p, lo16_reloc_p, jal_reloc_p): Handle microMIPS ASE.
	(micromips_branch_reloc_p): New function.
	(tls_gd_reloc_p, tls_ldm_reloc_p): Likewise.
	(tls_gottprel_reloc_p): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(_bfd_mips_elf_lo16_reloc): Handle microMIPS ASE.
	(mips_tls_got_index, mips_elf_got_page): Likewise.
	(mips_elf_create_local_got_entry): Likewise.
	(mips_elf_relocation_needs_la25_stub): Likewise.
	(mips_elf_calculate_relocation): Likewise.
	(mips_elf_perform_relocation): Likewise.
	(_bfd_mips_elf_symbol_processing): Likewise.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_link_output_symbol_hook): Likewise.
	(mips_elf_add_lo16_rel_addend): Likewise.
	(_bfd_mips_elf_check_relocs): Likewise.
	(mips_elf_adjust_addend): Likewise.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_create_la25_stub): Likewise.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_gc_sweep_hook): Likewise.
	(_bfd_mips_elf_is_target_special_symbol): New function.
	(mips_elf_relax_delete_bytes): Likewise.
	(opcode_descriptor): New structure.
	(RA): New macro.
	(OP32_SREG, OP32_TREG, OP16_VALID_REG): Likewise.
	(b_insns_32, bc_insn_32, bz_insn_32, bzal_insn_32): New variables.
	(beq_insn_32): Likewise.
	(b_insn_16, bz_insn_16): New variables.
	(BZC32_REG_FIELD): New macro.
	(bz_rs_insns_32, bz_rt_insns_32): New variables.
	(bzc_insns_32, bz_insns_16):Likewise.
	(BZ16_REG, BZ16_REG_FIELD): New macros.
	(jal_insn_32_bd16, jal_insn_32_bd32): New variables.
	(jal_x_insn_32_bd32): Likewise.
	(j_insn_32, jalr_insn_32): Likewise.
	(ds_insns_32_bd16, ds_insns_32_bd32): Likewise.
	(jalr_insn_16_bd16, jalr_insn_16_bd32, jr_insn_16): Likewise.
	(JR16_REG): New macro.
	(ds_insns_16_bd16): New variable.
	(lui_insn): Likewise.
	(addiu_insn, addiupc_insn): Likewise.
	(ADDIUPC_REG_FIELD): New macro.
	(MOVE32_RD, MOVE32_RS): Likewise.
	(MOVE16_RD_FIELD, MOVE16_RS_FIELD): Likewise.
	(move_insns_32, move_insns_16): New variables.
	(nop_insn_32, nop_insn_16): Likewise.
	(MATCH): New macro.
	(find_match): New function.
	(check_br16_dslot, check_br32_dslot): Likewise.
	(check_br16, check_br32): Likewise.
	(IS_BITSIZE): New macro.
	(check_4byte_branch): New function.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips_elf_merge_private_bfd_data): Disallow linking MIPS16
	and microMIPS modules together.
	(_bfd_mips_elf_print_private_bfd_data):	Handle microMIPS ASE.
	* reloc.c (BFD_RELOC_MICROMIPS_7_PCREL_S1): New relocation.
	(BFD_RELOC_MICROMIPS_10_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_16_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_GPREL16): Likewise.
	(BFD_RELOC_MICROMIPS_JMP, BFD_RELOC_MICROMIPS_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_HI16_S): Likewise.
	(BFD_RELOC_MICROMIPS_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_LITERAL): Likewise.
	(BFD_RELOC_MICROMIPS_GOT16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_SUB): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_PAGE): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_OFST): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHEST): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHER): Likewise.
	(BFD_RELOC_MICROMIPS_SCN_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_JALR): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GD): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_LDM): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GOTTPREL): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_LO16): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

binutils/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* readelf.c (get_machine_flags): Handle microMIPS ASE.
	(get_mips_symbol_other): Likewise.

gas/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.h (mips_segment_info): Add one bit for
	microMIPS.
	(TC_LABEL_IS_LOCAL): New macro.
	(mips_label_is_local): New prototype.
	* config/tc-mips.c (S0, S7): New macros.
	(emit_branch_likely_macro): New variable.
	(mips_set_options): Add micromips.
	(mips_opts): Initialise micromips to -1.
	(file_ase_micromips): New variable.
	(CPU_HAS_MICROMIPS): New macro.
	(hilo_interlocks): Set for microMIPS too.
	(gpr_interlocks): Likewise.
	(cop_interlocks): Likewise.
	(cop_mem_interlocks): Likewise.
	(HAVE_CODE_COMPRESSION): New macro.
	(micromips_op_hash): New variable.
	(micromips_nop16_insn, micromips_nop32_insn): New variables.
	(NOP_INSN): Handle microMIPS ASE.
	(mips32_to_micromips_reg_b_map): New macro.
	(mips32_to_micromips_reg_c_map): Likewise.
	(mips32_to_micromips_reg_d_map): Likewise.
	(mips32_to_micromips_reg_e_map): Likewise.
	(mips32_to_micromips_reg_f_map): Likewise.
	(mips32_to_micromips_reg_g_map): Likewise.
	(mips32_to_micromips_reg_l_map): Likewise.
	(mips32_to_micromips_reg_n_map): Likewise.
	(mips32_to_micromips_reg_h_map): New variable.
	(mips32_to_micromips_reg_m_map): Likewise.
	(mips32_to_micromips_reg_q_map): Likewise.
	(micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_to_32_reg_b_map): New macro.
	(micromips_to_32_reg_c_map): Likewise.
	(micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map): Likewise.
	(micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map): Likewise.
	(micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_n_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): New macros.
	(RELAX_DELAY_SLOT_16BIT): New macro.
	(RELAX_DELAY_SLOT_SIZE_FIRST): Likewise.
	(RELAX_DELAY_SLOT_SIZE_SECOND): Likewise.
	(RELAX_MICROMIPS_ENCODE, RELAX_MICROMIPS_P): New macros.
	(RELAX_MICROMIPS_TYPE, RELAX_MICROMIPS_AT): Likewise.
	(RELAX_MICROMIPS_U16BIT, RELAX_MICROMIPS_UNCOND): Likewise.
	(RELAX_MICROMIPS_COMPACT, RELAX_MICROMIPS_LINK): Likewise.
	(RELAX_MICROMIPS_RELAX32, RELAX_MICROMIPS_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR32): Likewise.
	(INSERT_OPERAND, EXTRACT_OPERAND): Handle microMIPS ASE.
	(mips_macro_warning): Add delay_slot_16bit_p, delay_slot_32bit_p,
	fsize and insns.
	(mips_mark_labels): New function.
	(mips16_small, mips16_ext): Remove variables, replacing with...
	(forced_insn_size): ... this.
	(append_insn, mips16_ip): Update accordingly.
	(micromips_insn_length): New function.
	(insn_length): Return the length of microMIPS instructions.
	(mips_record_mips16_mode): Rename to...
	(mips_record_compressed_mode): ... this.  Handle microMIPS ASE.
	(install_insn): Handle microMIPS ASE.
	(reglist_lookup): New function.
	(is_size_valid, is_delay_slot_valid): Likewise.
	(md_begin): Handle microMIPS ASE.
	(md_assemble): Likewise.  Update for append_insn interface change.
	(micromips_reloc_p): New function.
	(got16_reloc_p): Handle microMIPS ASE.
	(hi16_reloc_p): Likewise.
	(lo16_reloc_p): Likewise.
	(jmp_reloc_p): New function.
	(jalr_reloc_p): Likewise.
	(matching_lo_reloc): Handle microMIPS ASE.
	(insn_uses_reg, reg_needs_delay): Likewise.
	(mips_move_labels): Likewise.
	(mips16_mark_labels): Rename to...
	(mips_compressed_mark_labels): ... this.  Handle microMIPS ASE.
	(gpr_mod_mask): New function.
	(gpr_read_mask, gpr_write_mask): Handle microMIPS ASE.
	(fpr_read_mask, fpr_write_mask): Likewise.
	(insns_between, nops_for_vr4130, nops_for_insn): Likewise.
	(fix_loongson2f_nop, fix_loongson2f_jump): Likewise.
	(MICROMIPS_LABEL_CHAR): New macro.
	(micromips_target_label, micromips_target_name): New variables.
	(micromips_label_name, micromips_label_expr): New functions.
	(micromips_label_inc, micromips_add_label): Likewise.
	(mips_label_is_local): Likewise.
	(micromips_map_reloc): Likewise.
	(can_swap_branch_p): Handle microMIPS ASE.
	(append_insn): Add expansionp argument.  Handle microMIPS ASE.
	(start_noreorder, end_noreorder): Handle microMIPS ASE.
	(macro_start, macro_warning, macro_end): Likewise.
	(brk_fmt, cop12_fmt, jalr_fmt, lui_fmt): New variables.
	(mem12_fmt, mfhl_fmt, shft_fmt, trap_fmt): Likewise.
	(BRK_FMT, COP12_FMT, JALR_FMT, LUI_FMT): New macros.
	(MEM12_FMT, MFHL_FMT, SHFT_FMT, TRAP_FMT): Likewise.
	(macro_build): Handle microMIPS ASE.  Update for append_insn
	interface change.
	(mips16_macro_build): Update for append_insn interface change.
	(macro_build_jalr): Handle microMIPS ASE.
	(macro_build_lui): Likewise.  Simplify.
	(load_register): Handle microMIPS ASE.
	(load_address): Likewise.
	(move_register): Likewise.
	(macro_build_branch_likely): New function.
	(macro_build_branch_ccl): Likewise.
	(macro_build_branch_rs): Likewise.
	(macro_build_branch_rsrt): Likewise.
	(macro): Handle microMIPS ASE.
	(validate_micromips_insn): New function.
	(expr_const_in_range): Likewise.
	(mips_ip): Handle microMIPS ASE.
	(options): Add OPTION_MICROMIPS and OPTION_NO_MICROMIPS.
	(md_longopts): Add mmicromips and mno-micromips.
	(md_parse_option): Handle OPTION_MICROMIPS and
	OPTION_NO_MICROMIPS.
	(mips_after_parse_args): Handle microMIPS ASE.
	(md_pcrel_from): Handle microMIPS relocations.
	(mips_force_relocation): Likewise.
	(md_apply_fix): Likewise.
	(mips_align): Handle microMIPS ASE.
	(s_mipsset): Likewise.
	(s_cpload, s_cpsetup, s_cpreturn): Use relocation wrappers.
	(s_dtprel_internal): Likewise.
	(s_gpword, s_gpdword): Likewise.
	(s_insn): Handle microMIPS ASE.
	(s_mips_stab): Likewise.
	(relaxed_micromips_32bit_branch_length): New function.
	(relaxed_micromips_16bit_branch_length): New function.
	(md_estimate_size_before_relax): Handle microMIPS ASE.
	(mips_fix_adjustable): Likewise.
	(tc_gen_reloc): Handle microMIPS relocations.
	(mips_relax_frag): Handle microMIPS ASE.
	(md_convert_frag): Likewise.
	(mips_frob_file_after_relocs): Likewise.
	(mips_elf_final_processing): Likewise.
	(mips_nop_opcode): Likewise.
	(mips_handle_align): Likewise.
	(md_show_usage): Handle microMIPS options.
	* symbols.c (TC_LABEL_IS_LOCAL): New macro.
	(S_IS_LOCAL): Add a TC_LABEL_IS_LOCAL check.

	* doc/as.texinfo (Target MIPS options): Add -mmicromips and
	-mno-micromips.
	(-mmicromips, -mno-micromips): New options.
	* doc/c-mips.texi (-mmicromips, -mno-micromips): New options.
	(MIPS ISA): Document .set micromips and .set nomicromips.
	(MIPS insn): Update for microMIPS support.

gas/testsuite/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/micromips.d: New test.
	* gas/mips/micromips-branch-delay.d: Likewise.
	* gas/mips/micromips-branch-relax.d: Likewise.
	* gas/mips/micromips-branch-relax-pic.d: Likewise.
	* gas/mips/micromips-size-1.d: Likewise.
	* gas/mips/micromips-trap.d: Likewise.
	* gas/mips/micromips.l: New stderr output.
	* gas/mips/micromips-branch-delay.l: Likewise.
	* gas/mips/micromips-branch-relax.l: Likewise.
	* gas/mips/micromips-branch-relax-pic.l: Likewise.
	* gas/mips/micromips-size-0.l: New list test.
	* gas/mips/micromips-size-1.l: New stderr output.
	* gas/mips/micromips.s: New test source.
	* gas/mips/micromips-branch-delay.s: Likewise.
	* gas/mips/micromips-branch-relax.s: Likewise.
	* gas/mips/micromips-size-0.s: Likewise.
	* gas/mips/micromips-size-1.s: Likewise.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/dli.s: Use .p2align.
	* gas/mips/elf_ase_micromips.d: New test.
	* gas/mips/elf_ase_micromips-2.d: Likewise.
	* gas/mips/micromips@@abs.d: Likewise.
	* gas/mips/micromips@@add.d: Likewise.
	* gas/mips/micromips@@alnv_ps-swap.d: Likewise.
	* gas/mips/micromips@@and.d: Likewise.
	* gas/mips/micromips@@beq.d: Likewise.
	* gas/mips/micromips@@bge.d: Likewise.
	* gas/mips/micromips@@bgeu.d: Likewise.
	* gas/mips/micromips@@blt.d: Likewise.
	* gas/mips/micromips@@bltu.d: Likewise.
	* gas/mips/micromips@@branch-likely.d: Likewise.
	* gas/mips/micromips@@branch-misc-1.d: Likewise.
	* gas/mips/micromips@@branch-misc-2-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic.d: Likewise.
	* gas/mips/micromips@@branch-misc-4-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-4.d: Likewise.
	* gas/mips/micromips@@branch-self.d: Likewise.
	* gas/mips/micromips@@cache.d: Likewise.
	* gas/mips/micromips@@daddi.d: Likewise.
	* gas/mips/micromips@@dli.d: Likewise.
	* gas/mips/micromips@@elf-jal.d: Likewise.
	* gas/mips/micromips@@elf-rel2.d: Likewise.
	* gas/mips/micromips@@elfel-rel2.d: Likewise.
	* gas/mips/micromips@@elf-rel4.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic-noreorder.d: Likewise.
	* gas/mips/micromips@@lb-svr4pic-ilocks.d: Likewise.
	* gas/mips/micromips@@li.d: Likewise.
	* gas/mips/micromips@@loc-swap-dis.d: Likewise.
	* gas/mips/micromips@@loc-swap.d: Likewise.
	* gas/mips/micromips@@mips1-fp.d: Likewise.
	* gas/mips/micromips@@mips32-cp2.d: Likewise.
	* gas/mips/micromips@@mips32-imm.d: Likewise.
	* gas/mips/micromips@@mips32-sf32.d: Likewise.
	* gas/mips/micromips@@mips32.d: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.d: Likewise.
	* gas/mips/micromips@@mips32r2-fp32.d: Likewise.
	* gas/mips/micromips@@mips32r2-sync.d: Likewise.
	* gas/mips/micromips@@mips32r2.d: Likewise.
	* gas/mips/micromips@@mips4-branch-likely.d: Likewise.
	* gas/mips/micromips@@mips4-fp.d: Likewise.
	* gas/mips/micromips@@mips4.d: Likewise.
	* gas/mips/micromips@@mips5.d: Likewise.
	* gas/mips/micromips@@mips64-cp2.d: Likewise.
	* gas/mips/micromips@@mips64.d: Likewise.
	* gas/mips/micromips@@mips64r2.d: Likewise.
	* gas/mips/micromips@@pref.d: Likewise.
	* gas/mips/micromips@@relax-at.d: Likewise.
	* gas/mips/micromips@@relax.d: Likewise.
	* gas/mips/micromips@@rol-hw.d: Likewise.
	* gas/mips/micromips@@uld2-eb.d: Likewise.
	* gas/mips/micromips@@uld2-el.d: Likewise.
	* gas/mips/micromips@@ulh2-eb.d: Likewise.
	* gas/mips/micromips@@ulh2-el.d: Likewise.
	* gas/mips/micromips@@ulw2-eb-ilocks.d: Likewise.
	* gas/mips/micromips@@ulw2-el-ilocks.d: Likewise.
	* gas/mips/cache.d: Likewise.
	* gas/mips/daddi.d: Likewise.
	* gas/mips/mips32-imm.d: Likewise.
	* gas/mips/pref.d: Likewise.
	* gas/mips/elf-rel27.d: Handle microMIPS ASE.
	* gas/mips/l_d.d: Likewise.
	* gas/mips/l_d-n32.d: Likewise.
	* gas/mips/l_d-n64.d: Likewise.
	* gas/mips/ld.d: Likewise.
	* gas/mips/ld-n32.d: Likewise.
	* gas/mips/ld-n64.d: Likewise.
	* gas/mips/s_d.d: Likewise.
	* gas/mips/s_d-n32.d: Likewise.
	* gas/mips/s_d-n64.d: Likewise.
	* gas/mips/sd.d: Likewise.
	* gas/mips/sd-n32.d: Likewise.
	* gas/mips/sd-n64.d: Likewise.
	* gas/mips/mips32.d: Update immediates.
	* gas/mips/micromips@@mips32-cp2.s: New test source.
	* gas/mips/micromips@@mips32-imm.s: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.s: Likewise.
	* gas/mips/micromips@@mips64-cp2.s: Likewise.
	* gas/mips/cache.s: Likewise.
	* gas/mips/daddi.s: Likewise.
	* gas/mips/mips32-imm.s: Likewise.
	* gas/mips/elf-rel4.s: Handle microMIPS ASE.
	* gas/mips/lb-pic.s: Likewise.
	* gas/mips/ld.s: Likewise.
	* gas/mips/mips32.s: Likewise.
	* gas/mips/mips.exp: Add the micromips arch.  Exclude mips16e
	from micromips.  Run mips32-imm.

	* gas/mips/jal-mask-11.d: New test.
	* gas/mips/jal-mask-12.d: Likewise.
	* gas/mips/micromips@@jal-mask-11.d: Likewise.
	* gas/mips/jal-mask-1.s: Source for the new tests.
	* gas/mips/jal-mask-21.d: New test.
	* gas/mips/jal-mask-22.d: Likewise.
	* gas/mips/micromips@@jal-mask-12.d: Likewise.
	* gas/mips/jal-mask-2.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/mips16-e.d: Add --special-syms to `objdump'.
	* gas/mips/tmips16-e.d: Likewise.
	* gas/mips/mipsel16-e.d: Likewise.
	* gas/mips/tmipsel16-e.d: Likewise.

	* gas/mips/and.s: Adjust padding.
	* gas/mips/beq.s: Likewise.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/branch-misc-2.s: Likewise.
	* gas/mips/jal.s: Likewise.
	* gas/mips/li.s: Likewise.
	* gas/mips/mips4.s: Likewise.
	* gas/mips/mips4-fp.s: Likewise.
	* gas/mips/relax.s: Likewise.
	* gas/mips/and.d: Update accordingly.
	* gas/mips/elf-jal.d: Likewise.
	* gas/mips/jal.d: Likewise.
	* gas/mips/li.d: Likewise.
	* gas/mips/relax-at.d: Likewise.
	* gas/mips/relax.d: Likewise.

include/elf/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (R_MICROMIPS_min): New relocations.
	(R_MICROMIPS_26_S1): Likewise.
	(R_MICROMIPS_HI16, R_MICROMIPS_LO16): Likewise.
	(R_MICROMIPS_GPREL16, R_MICROMIPS_LITERAL): Likewise.
	(R_MICROMIPS_GOT16, R_MICROMIPS_PC7_S1): Likewise.
	(R_MICROMIPS_PC10_S1, R_MICROMIPS_PC16_S1): Likewise.
	(R_MICROMIPS_CALL16, R_MICROMIPS_GOT_DISP): Likewise.
	(R_MICROMIPS_GOT_PAGE, R_MICROMIPS_GOT_OFST): Likewise.
	(R_MICROMIPS_GOT_HI16, R_MICROMIPS_GOT_LO16): Likewise.
	(R_MICROMIPS_SUB, R_MICROMIPS_HIGHER): Likewise.
	(R_MICROMIPS_HIGHEST, R_MICROMIPS_CALL_HI16): Likewise.
	(R_MICROMIPS_CALL_LO16, R_MICROMIPS_SCN_DISP): Likewise.
	(R_MICROMIPS_JALR, R_MICROMIPS_HI0_LO16): Likewise.
	(R_MICROMIPS_TLS_GD, R_MICROMIPS_TLS_LDM): Likewise.
	(R_MICROMIPS_TLS_DTPREL_HI, R_MICROMIPS_TLS_DTPREL_LO): Likewise.
	(R_MICROMIPS_TLS_GOTTPREL): Likewise.
	(R_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(R_MICROMIPS_TLS_TPREL_LO16): Likewise.
	(R_MICROMIPS_GPREL7_S2, R_MICROMIPS_PC23_S2): Likewise.
	(R_MICROMIPS_max): Likewise.
	(EF_MIPS_ARCH_ASE_MICROMIPS): New macro.
	(STO_MIPS_ISA, STO_MIPS_FLAGS): Likewise.
	(ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT): Likewise.
	(STO_MICROMIPS): Likewise.
	(ELF_ST_IS_MICROMIPS, ELF_ST_SET_MICROMIPS): Likewise.
	(ELF_ST_IS_COMPRESSED): Likewise.
	(STO_MIPS_PLT, STO_MIPS_PIC): Rework.
	(ELF_ST_IS_MIPS_PIC, ELF_ST_SET_MIPS_PIC): Likewise.
	(STO_MIPS16, ELF_ST_IS_MIPS16, ELF_ST_SET_MIPS16): Likewise.

include/opcode/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (OP_MASK_EXTLSB, OP_SH_EXTLSB): New macros.
	(OP_MASK_STYPE, OP_SH_STYPE): Likewise.
	(OP_MASK_CODE10, OP_SH_CODE10): Likewise.
	(OP_MASK_TRAP, OP_SH_TRAP): Likewise.
	(OP_MASK_OFFSET12, OP_SH_OFFSET12): Likewise.
	(OP_MASK_OFFSET10, OP_SH_OFFSET10): Likewise.
	(OP_MASK_RS3, OP_SH_RS3): Likewise.
	(OP_MASK_MB, OP_SH_MB, OP_MASK_MC, OP_SH_MC): Likewise.
	(OP_MASK_MD, OP_SH_MD, OP_MASK_ME, OP_SH_ME): Likewise.
	(OP_MASK_MF, OP_SH_MF, OP_MASK_MG, OP_SH_MG): Likewise.
	(OP_MASK_MJ, OP_SH_MJ, OP_MASK_ML, OP_SH_ML): Likewise.
	(OP_MASK_MP, OP_SH_MP, OP_MASK_MQ, OP_SH_MQ): Likewise.
	(OP_MASK_IMMA, OP_SH_IMMA, OP_MASK_IMMB, OP_SH_IMMB): Likewise.
	(OP_MASK_IMMC, OP_SH_IMMC, OP_MASK_IMMF, OP_SH_IMMF): Likewise.
	(OP_MASK_IMMG, OP_SH_IMMG, OP_MASK_IMMH, OP_SH_IMMH): Likewise.
	(OP_MASK_IMMI, OP_SH_IMMI, OP_MASK_IMMJ, OP_SH_IMMJ): Likewise.
	(OP_MASK_IMML, OP_SH_IMML, OP_MASK_IMMM, OP_SH_IMMM): Likewise.
	(OP_MASK_IMMN, OP_SH_IMMN, OP_MASK_IMMO, OP_SH_IMMO): Likewise.
	(OP_MASK_IMMP, OP_SH_IMMP, OP_MASK_IMMQ, OP_SH_IMMQ): Likewise.
	(OP_MASK_IMMU, OP_SH_IMMU, OP_MASK_IMMW, OP_SH_IMMW): Likewise.
	(OP_MASK_IMMX, OP_SH_IMMX, OP_MASK_IMMY, OP_SH_IMMY): Likewise.
	(INSN_WRITE_GPR_S): New macro.
	(INSN2_BRANCH_DELAY_16BIT, INSN2_BRANCH_DELAY_32BIT): Likewise.
	(INSN2_READ_FPR_D): Likewise.
	(INSN2_MOD_GPR_MB, INSN2_MOD_GPR_MC): Likewise.
	(INSN2_MOD_GPR_MD, INSN2_MOD_GPR_ME): Likewise.
	(INSN2_MOD_GPR_MF, INSN2_MOD_GPR_MG): Likewise.
	(INSN2_MOD_GPR_MJ, INSN2_MOD_GPR_MP): Likewise.
	(INSN2_MOD_GPR_MQ, INSN2_MOD_SP): Likewise.
	(INSN2_READ_GPR_31, INSN2_READ_GP, INSN2_READ_PC): Likewise.
	(INSN2_UNCOND_BRANCH, INSN2_COND_BRANCH): Likewise.
	(INSN2_MOD_GPR_MHI, INSN2_MOD_GPR_MM, INSN2_MOD_GPR_MN): Likewise.
	(CPU_MICROMIPS): New macro.
	(M_BC1FL, M_BC1TL, M_BC2FL, M_BC2TL): New enum values.
	(M_BEQL, M_BGEZ, M_BGEZL, M_BGEZALL, M_BGTZ, M_BGTZL): Likewise.
	(M_BLEZ, M_BLEZL, M_BLTZ, M_BLTZL, M_BLTZALL, M_BNEL): Likewise.
	(M_CACHE_OB, M_JALS_1, M_JALS_2, M_JALS_A): Likewise.
	(M_LDC2_OB, M_LDL_OB, M_LDM_AB, M_LDM_OB): Likewise.
	(M_LDP_AB, M_LDP_OB, M_LDR_OB, M_LL_OB, M_LLD_OB): Likewise.
	(M_LWC2_OB, M_LWL_OB, M_LWM_AB, M_LWM_OB): Likewise.
	(M_LWP_AB, M_LWP_OB, M_LWR_OB): Likewise.
	(M_LWU_OB, M_PREF_OB, M_SC_OB, M_SCD_OB): Likewise.
	(M_SDC2_OB, M_SDL_OB, M_SDM_AB, M_SDM_OB): Likewise.
	(M_SDP_AB, M_SDP_OB, M_SDR_OB): Likewise.
	(M_SWC2_OB, M_SWL_OB, M_SWM_AB, M_SWM_OB): Likewise.
	(M_SWP_AB, M_SWP_OB, M_SWR_OB): Likewise.
	(MICROMIPSOP_MASK_MAJOR, MICROMIPSOP_SH_MAJOR): New macros.
	(MICROMIPSOP_MASK_IMMEDIATE, MICROMIPSOP_SH_IMMEDIATE): Likewise.
	(MICROMIPSOP_MASK_DELTA, MICROMIPSOP_SH_DELTA): Likewise.
	(MICROMIPSOP_MASK_CODE10, MICROMIPSOP_SH_CODE10): Likewise.
	(MICROMIPSOP_MASK_TRAP, MICROMIPSOP_SH_TRAP): Likewise.
	(MICROMIPSOP_MASK_SHAMT, MICROMIPSOP_SH_SHAMT): Likewise.
	(MICROMIPSOP_MASK_TARGET, MICROMIPSOP_SH_TARGET): Likewise.
	(MICROMIPSOP_MASK_EXTLSB, MICROMIPSOP_SH_EXTLSB): Likewise.
	(MICROMIPSOP_MASK_EXTMSBD, MICROMIPSOP_SH_EXTMSBD): Likewise.
	(MICROMIPSOP_MASK_INSMSB, MICROMIPSOP_SH_INSMSB): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_SEL, MICROMIPSOP_SH_SEL): Likewise.
	(MICROMIPSOP_MASK_OFFSET12, MICROMIPSOP_SH_OFFSET12): Likewise.
	(MICROMIPSOP_MASK_3BITPOS, MICROMIPSOP_SH_3BITPOS): Likewise.
	(MICROMIPSOP_MASK_STYPE, MICROMIPSOP_SH_STYPE): Likewise.
	(MICROMIPSOP_MASK_OFFSET10, MICROMIPSOP_SH_OFFSET10): Likewise.
	(MICROMIPSOP_MASK_RS, MICROMIPSOP_SH_RS): Likewise.
	(MICROMIPSOP_MASK_RT, MICROMIPSOP_SH_RT): Likewise.
	(MICROMIPSOP_MASK_RD, MICROMIPSOP_SH_RD): Likewise.
	(MICROMIPSOP_MASK_FS, MICROMIPSOP_SH_FS): Likewise.
	(MICROMIPSOP_MASK_FT, MICROMIPSOP_SH_FT): Likewise.
	(MICROMIPSOP_MASK_FD, MICROMIPSOP_SH_FD): Likewise.
	(MICROMIPSOP_MASK_FR, MICROMIPSOP_SH_FR): Likewise.
	(MICROMIPSOP_MASK_RS3, MICROMIPSOP_SH_RS3): Likewise.
	(MICROMIPSOP_MASK_PREFX, MICROMIPSOP_SH_PREFX): Likewise.
	(MICROMIPSOP_MASK_BCC, MICROMIPSOP_SH_BCC): Likewise.
	(MICROMIPSOP_MASK_CCC, MICROMIPSOP_SH_CCC): Likewise.
	(MICROMIPSOP_MASK_COPZ, MICROMIPSOP_SH_COPZ): Likewise.
	(MICROMIPSOP_MASK_MB, MICROMIPSOP_SH_MB): Likewise.
	(MICROMIPSOP_MASK_MC, MICROMIPSOP_SH_MC): Likewise.
	(MICROMIPSOP_MASK_MD, MICROMIPSOP_SH_MD): Likewise.
	(MICROMIPSOP_MASK_ME, MICROMIPSOP_SH_ME): Likewise.
	(MICROMIPSOP_MASK_MF, MICROMIPSOP_SH_MF): Likewise.
	(MICROMIPSOP_MASK_MG, MICROMIPSOP_SH_MG): Likewise.
	(MICROMIPSOP_MASK_MH, MICROMIPSOP_SH_MH): Likewise.
	(MICROMIPSOP_MASK_MI, MICROMIPSOP_SH_MI): Likewise.
	(MICROMIPSOP_MASK_MJ, MICROMIPSOP_SH_MJ): Likewise.
	(MICROMIPSOP_MASK_ML, MICROMIPSOP_SH_ML): Likewise.
	(MICROMIPSOP_MASK_MM, MICROMIPSOP_SH_MM): Likewise.
	(MICROMIPSOP_MASK_MN, MICROMIPSOP_SH_MN): Likewise.
	(MICROMIPSOP_MASK_MP, MICROMIPSOP_SH_MP): Likewise.
	(MICROMIPSOP_MASK_MQ, MICROMIPSOP_SH_MQ): Likewise.
	(MICROMIPSOP_MASK_IMMA, MICROMIPSOP_SH_IMMA): Likewise.
	(MICROMIPSOP_MASK_IMMB, MICROMIPSOP_SH_IMMB): Likewise.
	(MICROMIPSOP_MASK_IMMC, MICROMIPSOP_SH_IMMC): Likewise.
	(MICROMIPSOP_MASK_IMMD, MICROMIPSOP_SH_IMMD): Likewise.
	(MICROMIPSOP_MASK_IMME, MICROMIPSOP_SH_IMME): Likewise.
	(MICROMIPSOP_MASK_IMMF, MICROMIPSOP_SH_IMMF): Likewise.
	(MICROMIPSOP_MASK_IMMG, MICROMIPSOP_SH_IMMG): Likewise.
	(MICROMIPSOP_MASK_IMMH, MICROMIPSOP_SH_IMMH): Likewise.
	(MICROMIPSOP_MASK_IMMI, MICROMIPSOP_SH_IMMI): Likewise.
	(MICROMIPSOP_MASK_IMMJ, MICROMIPSOP_SH_IMMJ): Likewise.
	(MICROMIPSOP_MASK_IMML, MICROMIPSOP_SH_IMML): Likewise.
	(MICROMIPSOP_MASK_IMMM, MICROMIPSOP_SH_IMMM): Likewise.
	(MICROMIPSOP_MASK_IMMN, MICROMIPSOP_SH_IMMN): Likewise.
	(MICROMIPSOP_MASK_IMMO, MICROMIPSOP_SH_IMMO): Likewise.
	(MICROMIPSOP_MASK_IMMP, MICROMIPSOP_SH_IMMP): Likewise.
	(MICROMIPSOP_MASK_IMMQ, MICROMIPSOP_SH_IMMQ): Likewise.
	(MICROMIPSOP_MASK_IMMU, MICROMIPSOP_SH_IMMU): Likewise.
	(MICROMIPSOP_MASK_IMMW, MICROMIPSOP_SH_IMMW): Likewise.
	(MICROMIPSOP_MASK_IMMX, MICROMIPSOP_SH_IMMX): Likewise.
	(MICROMIPSOP_MASK_IMMY, MICROMIPSOP_SH_IMMY): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_CODE20, MICROMIPSOP_SH_CODE20): Likewise.
	(MICROMIPSOP_MASK_PERFREG, MICROMIPSOP_SH_PERFREG): Likewise.
	(MICROMIPSOP_MASK_CODE19, MICROMIPSOP_SH_CODE19): Likewise.
	(MICROMIPSOP_MASK_ALN, MICROMIPSOP_SH_ALN): Likewise.
	(MICROMIPSOP_MASK_VECBYTE, MICROMIPSOP_SH_VECBYTE): Likewise.
	(MICROMIPSOP_MASK_VECALIGN, MICROMIPSOP_SH_VECALIGN): Likewise.
	(MICROMIPSOP_MASK_DSPACC, MICROMIPSOP_SH_DSPACC): Likewise.
	(MICROMIPSOP_MASK_DSPACC_S, MICROMIPSOP_SH_DSPACC_S): Likewise.
	(MICROMIPSOP_MASK_DSPSFT, MICROMIPSOP_SH_DSPSFT): Likewise.
	(MICROMIPSOP_MASK_DSPSFT_7, MICROMIPSOP_SH_DSPSFT_7): Likewise.
	(MICROMIPSOP_MASK_SA3, MICROMIPSOP_SH_SA3): Likewise.
	(MICROMIPSOP_MASK_SA4, MICROMIPSOP_SH_SA4): Likewise.
	(MICROMIPSOP_MASK_IMM8, MICROMIPSOP_SH_IMM8): Likewise.
	(MICROMIPSOP_MASK_IMM10, MICROMIPSOP_SH_IMM10): Likewise.
	(MICROMIPSOP_MASK_WRDSP, MICROMIPSOP_SH_WRDSP): Likewise.
	(MICROMIPSOP_MASK_RDDSP, MICROMIPSOP_SH_RDDSP): Likewise.
	(MICROMIPSOP_MASK_BP, MICROMIPSOP_SH_BP): Likewise.
	(MICROMIPSOP_MASK_MT_U, MICROMIPSOP_SH_MT_U): Likewise.
	(MICROMIPSOP_MASK_MT_H, MICROMIPSOP_SH_MT_H): Likewise.
	(MICROMIPSOP_MASK_MTACC_T, MICROMIPSOP_SH_MTACC_T): Likewise.
	(MICROMIPSOP_MASK_MTACC_D, MICROMIPSOP_SH_MTACC_D): Likewise.
	(MICROMIPSOP_MASK_BBITIND, MICROMIPSOP_SH_BBITIND): Likewise.
	(MICROMIPSOP_MASK_CINSPOS, MICROMIPSOP_SH_CINSPOS): Likewise.
	(MICROMIPSOP_MASK_CINSLM1, MICROMIPSOP_SH_CINSLM1): Likewise.
	(MICROMIPSOP_MASK_SEQI, MICROMIPSOP_SH_SEQI): Likewise.
	(micromips_opcodes): New declaration.
	(bfd_micromips_num_opcodes): Likewise.

ld/testsuite/
2011-02-25  Catherine Moore  <clm@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* lib/ld-lib.exp (run_dump_test): Support distinct assembler
	flags for the same source named multiple times.
	* ld-mips-elf/jalx-1.s: New test source.
	* ld-mips-elf/jalx-1.d: New test output.
	* ld-mips-elf/jalx-1.ld: New test linker script.
	* ld-mips-elf/jalx-2-main.s: New test source.
	* ld-mips-elf/jalx-2-ex.s: Likewise.
	* ld-mips-elf/jalx-2-printf.s: Likewise.
	* ld-mips-elf/jalx-2.dd: New test output.
	* ld-mips-elf/jalx-2.ld: New test linker script.
	* ld-mips-elf/mips16-and-micromips.d: New test.
	* ld-mips-elf/mips-elf.exp: Run the new tests

opcodes/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* micromips-opc.c: New file.
	* mips-dis.c (micromips_to_32_reg_b_map): New array.
	(micromips_to_32_reg_c_map, micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map, micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map, micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): Likewise.
	(micromips_ase): New variable.
	(is_micromips): New function.
	(set_default_mips_dis_options): Handle microMIPS ASE.
	(print_insn_micromips): New function.
	(is_compressed_mode_p): Likewise.
	(_print_insn_mips): Handle microMIPS instructions.
	* Makefile.am (CFILES): Add micromips-opc.c.
	* configure.in (bfd_mips_arch): Add micromips-opc.lo.
	* Makefile.in: Regenerate.
	* configure: Regenerate.

	* mips-dis.c (micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_n_map): New macro.
@
text
@d833 105
d1904 9
@


1.211.2.1
log
@
2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	Backport from mainline:

	2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	gas/
	* config/tc-mips.c (mips_pseudo_table): Add tprelword/tpreldword
	entries.
	(mips16_percent_op): Add MIPS16 TLS relocation ops.
	(md_apply_fix): Add BFD_RELOC_MIPS16_TLS_* switch cases.
	(s_tls_rel_directive): Rename from s_dtprel_internal(). Abstract out
	directive string and reloc type as function parameters. Update
	comments.
	(s_dtprelword,s_dtpreldword): Change to use s_tls_rel_directive().
	(s_tprelword,s_tpreldword): New functions.

	include/
	* elf/mips.h (elf_mips_reloc_type): Add R_MIPS16_TLS_* entries.

	bfd/
	* reloc.c (BFD_RELOC_MIPS16_TLS_GD,BFD_RELOC_MIPS16_TLS_LDM,
	BFD_RELOC_MIPS16_TLS_DTPREL_HI16,BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
	BFD_RELOC_MIPS16_TLS_GOTTPREL,BFD_RELOC_MIPS16_TLS_TPREL_HI16,
	BFD_RELOC_MIPS16_TLS_TPREL_LO16): New relocations for MIPS16 TLS.
	* bfd-in2.h (bfd_reloc_code_real): Regenerate.
	* libbfd.h (bfd_reloc_code_real_names): Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Add R_MIPS16_TLS_*
	entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel,
	elf_mips16_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel,
	mips16_elf64_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfxx-mips.c (TLS_RELOC_P,mips16_reloc_p,
	_bfd_mips_elf_check_relocs): Add cases for R_MIPS16_TLS_* relocations.
	(tls_gd_reloc_p): Add R_MIPS16_TLS_GD case.
	(tls_ldm_reloc_p): Add R_MIPS16_TLS_LDM case.
	(tls_gottprel_reloc_p): Add R_MIPS16_TLS_GOTTPREL case.
	(mips_elf_calculate_relocation): Add cases for R_MIPS16_TLS_*,
	R_MIPS_TLS_DTPREL32/64, and R_MIPS_TLS_TPREL32/64 relocations.
@
text
@a832 105

  /* MIPS16 TLS general dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_GD,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GD",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_LDM,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_LDM",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GOTTPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_HI16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_LO16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
a1798 9
  { BFD_RELOC_MIPS16_TLS_GD, R_MIPS16_TLS_GD - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_LDM, R_MIPS16_TLS_LDM - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
    R_MIPS16_TLS_DTPREL_HI16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
    R_MIPS16_TLS_DTPREL_LO16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_GOTTPREL, R_MIPS16_TLS_GOTTPREL - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_TPREL_HI16, R_MIPS16_TLS_TPREL_HI16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_TPREL_LO16, R_MIPS16_TLS_TPREL_LO16 - R_MIPS16_min }
@


1.210
log
@bfd/
2010-12-23  Robert Millan  <rmh@@gnu.org>

	* config.bfd: Recognize mips-freebsd and mips-kfreebsd-gnu.
	* configure.host: Likewise.
	* configure.in: Support for `bfd_elf32_ntradbigmips_freebsd_vec',
	`bfd_elf32_ntradlittlemips_freebsd_vec',
	`bfd_elf32_tradbigmips_freebsd_vec',
	`bfd_elf32_tradlittlemips_freebsd_vec',
	`bfd_elf64_tradbigmips_freebsd_vec' and
	`bfd_elf64_tradlittlemips_freebsd_vec'.
	* configure: Regenerate.
	* elf32-mips.c: New target for FreeBSD support
	(same as traditional MIPS but overrides ELF_OSABI
	with ELFOSABI_FREEBSD).
	* elf64-mips.c: Likewise.
	* elfn32-mips.c: Likewise.
	* targets.c (_bfd_target_vector): Add
	`bfd_elf32_ntradbigmips_freebsd_vec',
	`bfd_elf32_ntradlittlemips_freebsd_vec',
	`bfd_elf32_tradbigmips_freebsd_vec',
	`bfd_elf32_tradlittlemips_freebsd_vec',
	`bfd_elf64_tradbigmips_freebsd_vec' and
	`bfd_elf64_tradlittlemips_freebsd_vec'.

ld/
2010-12-14  Robert Millan  <rmh@@gnu.org>

	* configure.tgt: Recognize mips-freebsd and mips-kfreebsd-gnu.

	* emulparams/elf32btsmip_fbsd.sh: New file.
	* emulparams/elf32btsmipn32_fbsd.sh: Likewise.
	* emulparams/elf32ltsmip_fbsd.sh: Likewise.
	* emulparams/elf32ltsmipn32_fbsd.sh: Likewise.
	* emulparams/elf64btsmip_fbsd.sh: Likewise.
	* emulparams/elf64ltsmip_fbsd.sh: Likewise.

	* Makefile.am: Add build rules for `eelf32btsmip_fbsd.c',
	`eelf32btsmipn32_fbsd.c', `eelf32ltsmip_fbsd.c',
	`eelf32ltsmipn32_fbsd.c', `eelf64btsmip_fbsd.c' and
	`eelf64ltsmip_fbsd.c'.
	* Makefile.in: Regenerate.

gas/
2010-12-19  Robert Millan  <rmh@@gnu.org>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.c (ELF_TARGET): New macro.  Generates target
	names accordingly to whether TE_FreeBSD and whether TE_TMIPS
	are defined.
	(mips_target_format): Refactor code using ELF_TARGET().
	(support_64bit_objects): Likewise.

	* configure.in: Recognize mips-freebsd and mips-kfreebsd-gnu.
	* configure.tgt: Likewise.
	* configure: Regenerate.

binutils/testsuite/
	* binutils-all/readelf.exp: Handle MIPS FreeBSD targets.

gas/testsuite/
	* gas/mips/e32el-rel2.d: Accept any file format.
	* gas/mips/elf-rel.d: Likewise.
	* gas/mips/elf-rel2.d: Likewise.
	* gas/mips/elf-rel3.d: Likewise.
	* gas/mips/elfel-rel.d: Likewise.
	* gas/mips/elfel-rel2.d: Likewise.
	* gas/mips/elfel-rel3.d: Likewise.
	* gas/mips/ldstla-32-mips3-shared.d: Likewise.
	* gas/mips/ldstla-32-mips3.d: Likewise.
	* gas/mips/ldstla-32-shared.d: Likewise.
	* gas/mips/ldstla-32.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/noat-1.d: Likewise.
	* gas/mips/set-arch.d: Likewise.
	* gas/mips/tls-o32.d: Likewise.

ld/testsuite/
	* ld-mips-elf/mips-elf-flags.exp: Handle FreeBSD targets.
	* ld-mips-elf/mips-elf.exp: Likewise.
	* ld-mips-elf/mips16-call-global.d: Accept any file format.
	* ld-mips-elf/mips16-intermix.d: Likewise.
@
text
@d835 502
d1538 1
d1541 3
a1543 2
  /* R_MIPS_LITERAL relocations are defined for local symbols only.  */
  if (reloc_entry->howto->type == R_MIPS_LITERAL
d1566 10
a1575 3
  return _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
					input_section, relocatable,
					data, gp);
d1733 2
a1734 2
  _bfd_mips16_elf_reloc_unshuffle (abfd, reloc_entry->howto->type, FALSE,
				   location);
d1738 2
a1739 2
  _bfd_mips16_elf_reloc_shuffle (abfd, reloc_entry->howto->type, !relocatable,
				 location);
d1801 41
d1850 1
d1866 7
d1924 8
d1969 2
d1995 1
a1995 1
      && (gprel16_reloc_p (r_type) || r_type == (unsigned int) R_MIPS_LITERAL))
d2244 2
d2260 1
@


1.209
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d1728 31
@


1.208
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d1608 1
a1679 1
#define bfd_elf32_mkobject		_bfd_mips_elf_mkobject
@


1.207
log
@	* elfxx-mips.h: Include "elf/mips.h".
	(gprel16_reloc_p): New static inline function.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs)
	[R_MIPS16_GOT16, R_MIPS_GOT16, R_MIPS_GOT_HI16, R_MIPS_GOT_LO16]:
	Use got16_reloc_p.
	(_bfd_mips_elf_relocate_section)[bfd_reloc_overflow]: Use
	gprel16_reloc_p.
	* elf32-mips.c (mips_info_to_howto_rel): Likewise.
	* elfn32-mips.c (mips_info_to_howto_rel): Likewise.
@
text
@d1509 1
a1509 1
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
@


1.206
log
@update copyright dates
@
text
@d1425 1
a1425 2
      && (r_type == (unsigned int) R_MIPS_GPREL16
	  || r_type == (unsigned int) R_MIPS_LITERAL))
@


1.205
log
@	PR binutils/10492
	* elf.c (sym_is_global): Return true even for BSF_GNU_UNIQUE
	symbols.
	* elf32-mips.c (mips_elf_sym_is_global): Likewise.
	* elfn32-mips.c (mips_elf_sym_is_global): Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.204
log
@2009-08-05  Chao-ying Fu  <fu@@mips.com>

	* elf32-mips.c (mips_reloc_map): Add BFD_RELOC_MIPS_JALR.
	* elfxx-mips.c (JAL_TO_BAL_P): New define to transform JAL to BAL
	for CPUs.  It is true for RM9000.
	(JALR_TO_BAL_P): New define to transform JALR to BAL.  It is true
	for all CPUs.
	(mips_elf_perform_relocation): Use JAL_TO_BAL_P and JALR_TO_BAL_P
	to guard the transformation.
@
text
@d1453 1
a1453 1
    return ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
@


1.203
log
@	* elf32-mips.c (mips_elf_final_gp): Don't add 0x4000 offset for
	relocatable link.
@
text
@d1264 1
@


1.202
log
@2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>
	    Maxim Kuvyrkov  <maxim@@codesourcery.com>

	* elf32-mips.c (mips_vxworks_copy_howto_rela): Replace with...
	(elf_mips_copy_howto): ...this howto.  Clear the size fields.
	(mips_vxworks_jump_slot_howto_rela): Replace with...
	(elf_mips_jump_slot_howto): ...this howto.
	(bfd_elf32_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf32_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf32_rtype_to_howto): Handle R_MIPS_COPY and R_MIPS_JUMP_SLOT.
	(elf_backend_plt_readonly): Define.
	(elf_backend_plt_sym_val): Define for non-VxWorks targets.
	(mips_vxworks_bfd_reloc_type_lookup): Delete.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(mips_vxworks_rtype_to_howto): Likewise.
	(elf_backend_want_dynbss): Don't define for VxWorks.
	(elf_backend_plt_readonly): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(elf_backend_mips_rtype_to_howto): Likewise.
	(elf_backend_adjust_dynamic_symbol): Likewise.
	(elf_backend_got_symbol_offset): Don't define.
	* elfn32-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto): New.
	(bfd_elf32_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf32_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf32_n32_rtype_to_howto): Handle R_MIPS_COPY and
	R_MIPS_JUMP_SLOT.
	(elf_backend_rela_plts_and_copies_p, elf_backend_plt_readonly)
	(elf_backend_plt_sym_val): Define.
	* elf64-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto): New.
	(bfd_elf64_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf64_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf64_rtype_to_howto): Handle R_MIPS_COPY and R_MIPS_JUMP_SLOT.
	(elf_backend_rela_plts_and_copies_p, elf_backend_plt_readonly)
	(elf_backend_plt_sym_val): Define.
	* elfxx-mips.h (_bfd_mips_vxworks_adjust_dynamic_symbol): Delete.
	(_bfd_mips_elf_use_plts_and_copy_relocs, _bfd_mips_elf_init_stubs)
	(_bfd_mips_elf_plt_sym_val, _bfd_mips_post_process_headers): Declare.
	* elfxx-mips.c (mips_elf_la25_stub): New structure.
	(LA25_LUI, LA25_J, LA25_ADDIU): New macros.
	(mips_elf_link_hash_entry): Add "la25_stubs", "has_static_relocs"
	and "has_nonpic_branches" fields.  Remove "is_relocation_target" and
	"is_branch_target".
	(mips_elf_link_hash_table): Add blank lines.  Add
	"use_plts_and_copy_relocs", "reserved_gotno", "strampoline",
	"la25_stubs" and "add_stub_section" fields.
	(mips_htab_traverse_info): New structure.
	(PIC_OBJECT_P, MIPS_ELF_LOAD_WORD): New macros.
	(MIPS_RESERVED_GOTNO): Delete.
	(mips_o32_exec_plt0_entry, mips_n32_exec_plt0_entry)
	(mips_n64_exec_plt0_entry, mips_exec_plt_entry): New tables.
	(mips_elf_link_hash_newfunc): Update after the changes to
	mips_elf_link_hash_entry.
	(mips_elf_check_mips16_stubs): Replace the DATA parameter with
	an INFO parameter.  Don't look through warnings symbols here;
	do it in mips_elf_check_symbols instead.
	(mips_elf_create_stub_symbol): New function.
	(mips_elf_la25_stub_hash, mips_elf_la25_stub_eq): New functions.
	(_bfd_mips_elf_init_stubs, mips_elf_local_pic_function_p): Likewise.
	(mips_elf_add_la25_intro, mips_elf_add_la25_trampoline): Likewise.
	(mips_elf_add_la25_stub, mips_elf_check_symbols): New functions.
	(mips_elf_gotplt_index): Check for VxWorks.
	(mips_elf_output_dynamic_relocation): Take the relocation index
	as an extra parameter.  Do not increment reloc_count here.
	(mips_elf_initialize_tls_slots): Update the calls to
	mips_elf_output_dynamic_relocation accordingly.
	(mips_elf_multi_got): Use htab->reserved_gotno instead of
	MIPS_RESERVED_GOTNO.
	(mips_elf_create_got_section): Don't allocate reserved GOT
	entries here.  Unconditionally create .got.plt, but don't
	set its alignment here.
	(mips_elf_relocation_needs_la25_stub): New function.
	(mips_elf_calculate_relocation): Redirect branches and jumps to
	a non-PIC stub if one exists.  Check !h->has_static_relocs instead
	of !htab->is_vxworks when deciding whether to create dynamic
	relocations for R_MIPS_32, R_MIPS_REL32 and R_MIPS_64.
	(_bfd_mips_elf_create_dynamic_sections): Unconditionally call
	_bfd_elf_create_dynamic_sections.  Unconditionally set up
	htab->splt and htab->sdynbss.  Set htab->srelplt to ".rel.plt"
	if !htab->is_vxworks.  Add non-VxWorks values of
	htab->plt_header_size and htab->plt_entry_size.
	(_bfd_mips_elf_check_relocs): Set pointer_equality_needed for
	non-branch static relocations.  Set has_nonpic_branches when an la25
	stub might be required.  Set can_make_dynamic_p to TRUE if R_MIPS_32,
	R_MIPS_REL32 and R_MIPS_64 relocations can be made dynamic,
	rather than duplicating the condition.  Do not make them dynamic
	for read-only sections in non-PIC executable objects.
	Do not protect this code with dynobj == NULL || htab->sgot == NULL;
	handle each group of cases separately.  Add a default case that
	sets has_static_relocs for non-GOT relocations that cannot be
	made dynamic.  Don't set is_relocation_target and is_branch_target.
	Reject non-PIC static relocations in shared objects.
	(_bfd_mips_vxworks_adjust_dynamic_symbol): Fold into...
	(_bfd_mips_elf_adjust_dynamic_symbol): ...here, using
	htab->use_plts_and_copy_relocs instead of htab->is_vxworks
	to select PLT and copy-reloc handling.  Set the alignment of
	.plt and .got.plt when allocating the first entry.  Generalize
	code to handle REL as well as RELA sections and 64-bit as well as
	32-bit GOT entries.  Complain if we find a static-only reloc
	against an externally-defined symbol and if we cannot create
	dynamic relocations for it.  Allocate copy relocs using
	mips_elf_allocate_dynamic_relocations on non-VxWorks targets.
	Set possibly_dynamic_relocs to 0 when using PLTs or copy relocs.
	Skip reserved .got.plt entries.
	(_bfd_mips_elf_always_size_sections): Use mips_elf_check_symbols
	instead of mips_elf_check_mips16_stubs to process each symbol.
	Do the traversal for relocatable objects too.
	(mips_elf_lay_out_got): Use htab->reserved_gotno instead of
	MIPS_RESERVED_GOTNO.
	(_bfd_mips_elf_size_dynamic_sections): Exclude sdynbss if it
	is empty.  Extend the DT_PLTREL, DT_JMPREL and DT_PLTRELSZ handling
	to non-VxWorks targets.  Only add DT_REL{,A}, DT_REL{,A}SZ and
	DT_REL{,A}ENT if .rel.dyn is nonempty.  Create a symbol for the
	PLT.  Allocate a nop at the end of the PLT.  Allocate DT_MIPS_PLTGOT.
	(mips_elf_create_la25_stub_info): New function.
	(_bfd_mips_elf_finish_dynamic_symbol): Write out PLT entries
	and copy relocs where necessary.  Check pointer_equality_needed.
	(mips_finish_exec_plt): New function.
	(_bfd_mips_elf_finish_dynamic_sections): Always set DT_PLTGOT
	to the beginning of htab->sgot.  Use htab->reserved_gotno instead
	of MIPS_RESERVED_GOTNO.  Assert htab->use_plts_and_copy_relocs
	instead of htab->is_vxworks for DT_PLTREL, DT_PLTRELSZ and DT_JMPREL.
	Set DT_PLTREL to DT_REL instead of DT_RELA on non-VxWorks targets.
	Use mips_finish_exec_plt to create non-VxWorks PLT headers.  Set
	DT_MIPS_PLTGOT.
	(_bfd_mips_elf_copy_indirect_symbol): Copy has_static_relocs
	from the indirect symbol to the direct symbol.  Also copy
	has_nonpic_branches for indirect symbols.
	(_bfd_mips_elf_get_target_dtag): Handle DT_MIPS_PLTGOT and
	DT_MIPS_RWPLT.
	(_bfd_mips_elf_link_hash_table_create): Initialize the new
	mips_elf_link_hash_table fields.
	(_bfd_mips_vxworks_link_hash_table_create): Set
	use_plts_and_copy_relocs to TRUE.  Use TRUE rather than 1
	when setting is_vxworks.
	(_bfd_mips_elf_use_plts_and_copy_relocs): New function.
	(_bfd_mips_elf_final_link): Call mips_elf_create_la25_stub for
	each la25_stub.
	(_bfd_mips_elf_merge_private_bfd_data): Treat dynamic objects
	as PIC.  Generalize message about linking PIC and non-PIC.
	(_bfd_mips_elf_plt_sym_val, _bfd_mips_post_process_headers): New
	functions.
	* reloc.c: Update comment near BFD_RELOC_MIPS_JUMP_SLOT.
	* bfd-in2.h: Regenerated.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>

	* readelf.c (get_mips_symbol_other): Handle STO_MIPS_PLT and
	STO_MIPS_PIC.
	(slurp_rela_relocs, slurp_rel_relocs): Handle MIPS ELF64 here.
	(dump_relocations, debug_apply_relocations): Don't handle it here.
	(get_mips_dynamic_type): Handle DT_MIPS_PLTGOT and DT_MIPS_RWPLT.
	(print_mips_pltgot_entry): New function.
	(process_mips_specific): Dump the PLT GOT.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* config/tc-mips.c (OPTION_CALL_NONPIC): New macro.
	(OPTION_NON_SHARED, OPTION_XGOT, OPTION_MABI, OPTION_32)
	(OPTION_N32, OPTION_64, OPTION_MDEBUG, OPTION_NO_MDEBUG)
	(OPTION_PDR, OPTION_NO_PDR, OPTION_MVXWORKS_PIC): Bump by 1.
	(md_longopts): Add -call_nonpic.
	(md_parse_option): Handle OPTION_CALL_NONPIC.
	(md_show_usage): Add -call_nonpic.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/call-nonpic-1.s, gas/mips/call-nonpic-1.d: New test.
	* gas/mips/mips.exp: Run it.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>

	* mips.h (STO_MIPS_PLT, ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT)
	(STO_MIPS_PIC, DT_MIPS_PLTGOT, DT_MIPS_RWPLT): New macros.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* emulparams/elf32bmip.sh (GOT): Define, moving .got.plt to...
	(OTHER_RELRO_SECTIONS, OTHER_READWRITE_SECTIONS): ...one of these
	two variables.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emultempl/mipself.em: Include ldctor.h, elf/mips.h and elfxx-mips.h.
	(is_mips_elf): New macro.
	(stub_file, stub_bfd): New variables.
	(hook_stub_info): New structure.
	(hook_in_stub): New function.
	(mips_add_stub_section): Likewise.
	(mips_create_output_section_statements): Likewise.
	(mips_before_allocation): Likewise.
	(real_func): New variable.
	(mips_for_each_input_file_wrapper): New function.
	(mips_lang_for_each_input_file): Likewise.
	(lang_for_each_input_file): Define.
	(LDEMUL_BEFORE_ALLOCATION): Likewise.
	(LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS): Likewise.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* ld-mips-elf/mips16-pic-3a.s,
	ld-mips-elf/mips16-pic-3b.s,
	ld-mips-elf/mips16-pic-3.dd,
	ld-mips-elf/mips16-pic-3.gd,
	ld-mips-elf/mips16-pic-3.rd,
	ld-mips-elf/mips16-pic-3.inc,
	ld-mips-elf/pic-and-nonpic-1a.s,
	ld-mips-elf/pic-and-nonpic-1b.s,
	ld-mips-elf/pic-and-nonpic-1.ld,
	ld-mips-elf/pic-and-nonpic-1.dd,
	ld-mips-elf/pic-and-nonpic-1.nd,
	ld-mips-elf/pic-and-nonpic-1-rel.dd,
	ld-mips-elf/pic-and-nonpic-1-rel.nd,
	ld-mips-elf/pic-and-nonpic-2a.s,
	ld-mips-elf/pic-and-nonpic-2b.s,
	ld-mips-elf/pic-and-nonpic-2.d,
	ld-mips-elf/pic-and-nonpic-3a.s,
	ld-mips-elf/pic-and-nonpic-3a.ld,
	ld-mips-elf/pic-and-nonpic-3a.dd,
	ld-mips-elf/pic-and-nonpic-3a.gd,
	ld-mips-elf/pic-and-nonpic-3a.sd,
	ld-mips-elf/pic-and-nonpic-3b.s,
	ld-mips-elf/pic-and-nonpic-3b.ld,
	ld-mips-elf/pic-and-nonpic-3b.ad,
	ld-mips-elf/pic-and-nonpic-3b.dd,
	ld-mips-elf/pic-and-nonpic-3b.gd,
	ld-mips-elf/pic-and-nonpic-3b.nd,
	ld-mips-elf/pic-and-nonpic-3b.pd,
	ld-mips-elf/pic-and-nonpic-3b.rd,
	ld-mips-elf/pic-and-nonpic-3b.sd,
	ld-mips-elf/pic-and-nonpic-3-error.d,
	ld-mips-elf/pic-and-nonpic-4a.s,
	ld-mips-elf/pic-and-nonpic-4b.s,
	ld-mips-elf/pic-and-nonpic-4b.ld,
	ld-mips-elf/pic-and-nonpic-4b.ad,
	ld-mips-elf/pic-and-nonpic-4b.dd,
	ld-mips-elf/pic-and-nonpic-4b.gd,
	ld-mips-elf/pic-and-nonpic-4b.nd,
	ld-mips-elf/pic-and-nonpic-4b.rd,
	ld-mips-elf/pic-and-nonpic-4b.sd,
	ld-mips-elf/pic-and-nonpic-4-error.d,
	ld-mips-elf/pic-and-nonpic-5a.s,
	ld-mips-elf/pic-and-nonpic-5b.s,
	ld-mips-elf/pic-and-nonpic-5b.ld,
	ld-mips-elf/pic-and-nonpic-5b.ad,
	ld-mips-elf/pic-and-nonpic-5b.dd,
	ld-mips-elf/pic-and-nonpic-5b.gd,
	ld-mips-elf/pic-and-nonpic-5b.nd,
	ld-mips-elf/pic-and-nonpic-5b.rd,
	ld-mips-elf/pic-and-nonpic-5b.sd,
	ld-mips-elf/pic-and-nonpic-5b.pd,
	ld-mips-elf/pic-and-nonpic-6.ld,
	ld-mips-elf/pic-and-nonpic-6-o32a.s,
	ld-mips-elf/pic-and-nonpic-6-o32b.s,
	ld-mips-elf/pic-and-nonpic-6-o32c.s,
	ld-mips-elf/pic-and-nonpic-6-o32.ad,
	ld-mips-elf/pic-and-nonpic-6-o32.dd,
	ld-mips-elf/pic-and-nonpic-6-o32.gd,
	ld-mips-elf/pic-and-nonpic-6-o32.nd,
	ld-mips-elf/pic-and-nonpic-6-o32.pd,
	ld-mips-elf/pic-and-nonpic-6-o32.rd,
	ld-mips-elf/pic-and-nonpic-6-o32.sd,
	ld-mips-elf/pic-and-nonpic-6-n32a.s,
	ld-mips-elf/pic-and-nonpic-6-n32b.s,
	ld-mips-elf/pic-and-nonpic-6-n32c.s,
	ld-mips-elf/pic-and-nonpic-6-n32.ad,
	ld-mips-elf/pic-and-nonpic-6-n32.dd,
	ld-mips-elf/pic-and-nonpic-6-n32.gd,
	ld-mips-elf/pic-and-nonpic-6-n32.nd,
	ld-mips-elf/pic-and-nonpic-6-n32.pd,
	ld-mips-elf/pic-and-nonpic-6-n32.rd,
	ld-mips-elf/pic-and-nonpic-6-n32.sd,
	ld-mips-elf/pic-and-nonpic-6-n64a.s,
	ld-mips-elf/pic-and-nonpic-6-n64b.s,
	ld-mips-elf/pic-and-nonpic-6-n64c.s,
	ld-mips-elf/pic-and-nonpic-6-n64.ad,
	ld-mips-elf/pic-and-nonpic-6-n64.dd,
	ld-mips-elf/pic-and-nonpic-6-n64.gd,
	ld-mips-elf/pic-and-nonpic-6-n64.nd,
	ld-mips-elf/pic-and-nonpic-6-n64.pd,
	ld-mips-elf/pic-and-nonpic-6-n64.rd,
	ld-mips-elf/pic-and-nonpic-6-n64.sd: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d1008 1
a1008 1
	  *pgp = symbol->section->output_section->vma + 0x4000;
@


1.201
log
@bfd/
	* elf-bfd.h (MIPS_ELF_TDATA): New elf_object_id.
	* elf32-mips.c (bfd_elf32_mkobject): Define.
	* elf64-mips.c (bfd_elf64_mkobject): Likewise.
	* elfn32-mips.c (bfd_elf32_mkobject): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Declare.
	* elfxx-mips.c (is_mips_elf): New macro.
	(_bfd_mips_elf_mkobject): New function.
	(_bfd_mips_elf_final_link): Use is_mips_elf.
	(_bfd_mips_elf_merge_private_bfd_data): Likewise.
@
text
@d902 32
d1334 4
d1371 4
d1395 4
d1662 2
a1727 76

/* Specific to VxWorks.  */
static reloc_howto_type mips_vxworks_copy_howto_rela =
  HOWTO (R_MIPS_COPY,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_COPY",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,         		/* src_mask */
	 0x0,		        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Specific to VxWorks.  */
static reloc_howto_type mips_vxworks_jump_slot_howto_rela =
  HOWTO (R_MIPS_JUMP_SLOT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_JUMP_SLOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,         		/* src_mask */
	 0x0,		        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Implement elf_backend_bfd_reloc_type_lookup for VxWorks.  */

static reloc_howto_type *
mips_vxworks_bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
{
  switch (code)
    {
    case BFD_RELOC_MIPS_COPY:
      return &mips_vxworks_copy_howto_rela;
    case BFD_RELOC_MIPS_JUMP_SLOT:
      return &mips_vxworks_jump_slot_howto_rela;
    default:
      return bfd_elf32_bfd_reloc_type_lookup (abfd, code);
    }
}

static reloc_howto_type *
mips_vxworks_bfd_reloc_name_lookup (bfd *abfd, const char *r_name)
{
  if (strcasecmp (mips_vxworks_copy_howto_rela.name, r_name) == 0)
    return &mips_vxworks_copy_howto_rela;
  if (strcasecmp (mips_vxworks_jump_slot_howto_rela.name, r_name) == 0)
    return &mips_vxworks_jump_slot_howto_rela;

  return bfd_elf32_bfd_reloc_name_lookup (abfd, r_name);
}

/* Implement elf_backend_mips_rtype_to_lookup for VxWorks.  */

static reloc_howto_type *
mips_vxworks_rtype_to_howto (unsigned int r_type, bfd_boolean rela_p)
{
  switch (r_type)
    {
    case R_MIPS_COPY:
      return &mips_vxworks_copy_howto_rela;
    case R_MIPS_JUMP_SLOT:
      return &mips_vxworks_jump_slot_howto_rela;
    default:
      return mips_elf32_rtype_to_howto (r_type, rela_p);
    }
}

a1759 4
#undef elf_backend_got_symbol_offset
#define elf_backend_got_symbol_offset		0
#undef elf_backend_want_dynbss
#define elf_backend_want_dynbss			1
d1768 1
a1768 2
#undef elf_backend_plt_readonly
#define elf_backend_plt_readonly		1
a1769 12
#undef bfd_elf32_bfd_reloc_type_lookup
#define bfd_elf32_bfd_reloc_type_lookup \
  mips_vxworks_bfd_reloc_type_lookup
#undef bfd_elf32_bfd_reloc_name_lookup
#define bfd_elf32_bfd_reloc_name_lookup \
  mips_vxworks_bfd_reloc_name_lookup
#undef elf_backend_mips_rtype_to_howto
#define elf_backend_mips_rtype_to_howto	\
  mips_vxworks_rtype_to_howto
#undef elf_backend_adjust_dynamic_symbol
#define elf_backend_adjust_dynamic_symbol \
  _bfd_mips_vxworks_adjust_dynamic_symbol
@


1.200
log
@bfd/
	* elf32-mips.c (elf_backend_hide_symbol): Delete.
	* elfn32-mips.c (elf_backend_hide_symbol): Likewise.
	* elf64-mips.c (elf_backend_hide_symbol): Likewise.
	* elfxx-mips.h (elf_backend_hide_symbol): Likewise.
	* elfxx-mips.c (mips_elf_link_hash_entry): Remove "forced_local"
	and add "needs_lazy_stub".
	(mips_elf_link_hash_newfunc): Update accordingly.
	(mips_elf_link_hash_table): Remove "computed_got_sizes" and
	add "lazy_stub_count".
	(_bfd_mips_elf_link_hash_table_create): Update accordingly.
	(mips_elf_output_extsym): Use hd->needs_lazy_stub to detect
	cases where a lazy stub is being used.
	(mips_elf_sort_hash_table_f): Use h->root.forced_local instead
	of h->forced_local.
	(mips_elf_record_global_got_symbol): Use _bfd_elf_link_hash_hide_symbol
	instead of _bfd_mips_elf_hide_symbol.  Do not increment local_gotno
	here.
	(mips_elf_allocate_dynamic_relocations): Move before new first use.
	(mips_elf_check_recreate_got, mips_elf_recreate_got): New functions.
	(mips_elf_resolve_final_got_entries): Move earlier in file.  Make at
	most two passes over the hash table.  Use mips_elf_check_recreate_got
	to see if there are any indirect or warning entries and
	mips_elf_recreate_got to create a new GOT without them.
	Return a boolean success value.
	(mips_elf_count_forced_local_got_entries): New function.
	(mips_elf_make_got_per_bfd): Check h->root.forced_local instead of
	h->forced_local.
	(mips_elf_set_global_got_offset): Likewise.
	(mips_elf_set_no_stub): Replace with...
	(mips_elf_forbid_lazy_stubs): ...this new function.
	(mips_elf_resolve_final_got_entry): Delete.
	(mips_elf_multi_got): Fix formatting.  Use mips_elf_forbid_lazy_stubs
	instead of mips_elf_set_no_stub.  Move the code that sets
	global offsets and allocates dynamic relocations from the main
	_bfd_mips_elf_size_dynamic_sections loop to here.
	(_bfd_mips_elf_adjust_dynamic_symbol): Do not allocate room in
	.MIPS.stubs here; just set hmips->needs_lazy_stub and increment
	htab->lazy_stub_count.
	(_bfd_mips_elf_always_size_sections): Move the stub-estimation
	code to mips_elf_estimate_stub_size and the GOT-sizing code to
	mips_elf_lay_out_got.  Do not call these functions here.
	(mips_elf_estimate_stub_size): New function, split
	out from _bfd_mips_elf_always_size_sections.  Call
	mips_elf_resolve_final_got_entries earlier.  Count the number
	of forced-local entries.  Do not add stub sizes to loadable_size;
	after this patch, the stub sizes are already included in the main
	estimate.  Allocate dynamic relocations here rather than in the
	main _bfd_mips_elf_size_dynamic_sections loop.
	(mips_elf_estimate_stub_size): New function, split out from
	_bfd_mips_elf_always_size_sections.
	(mips_elf_allocate_lazy_stub): New function.
	(mips_elf_lay_out_lazy_stubs): Likewise.
	(_bfd_mips_elf_size_dynamic_sections): Call mips_elf_estimate_stub_size,
	mips_elf_lay_out_got and mips_elf_lay_out_lazy_stubs.  Do not handle
	the allocation of sreldyn specially.
	(_bfd_mips_elf_hide_symbol): Delete.

ld/testsuite/
	* ld-mips-elf/tlsdyn-o32-2.got, ld-mips-elf/tlsdyn-o32-3.got,
	ld-mips-elf/tlsdyn-o32-2.d, ld-mips-elf/tlsdyn-o32-3.d: Change the
	GOT layout as follows:

	         BEFORE                  AFTER
	   +0x08 %call16(__tls_get_addr) %call16(__tls_get_addr)
	   +0x0c %tlsldm(tlsbin_ld)      %gottprel(tlsvar_ie)
	   +0x10   "  "                  %tlsgd(tlsvar_gd)
	   +0x14 %tlsgd(tlsvar_gd)          "  "
	   +0x18   "  "                  %tlsgd(tlsbin_gd)
	   +0x1c %gottprel(tlsvar_ie)       "  "
	   +0x20 %tlsgd(tlsbin_gd)       %tlsldm(tlsbin_ld)
	   +0x24   "  "                     "  "
	   +0x28 %gottprel(tlsbin_ie)    %gottprel(tlsbin_ie)
@
text
@d1633 1
@


1.199
log
@bfd/
	* reloc.c (BFD_RELOC_MIPS16_GOT16, BFD_RELOC_MIPS16_CALL16): Declare.
	* libbfd.h, bfd-in2.h: Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(mips16_reloc_map): Add mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(mips16_elf64_howto_table_rela): Likewise.
	(mips16_reloc_map): Add mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(elf_mips16_howto_table_rela): Likewise.
	(mips16_reloc_map): Add mappings.
	* elfxx-mips.c (mips_elf_create_shadow_symbol): New function.
	(section_allows_mips16_refs_p): Likewise.
	(mips16_stub_symndx): Likewise.
	(mips_elf_check_mips16_stubs): Treat the data argument as a
	bfd_link_info.  Mark every dynamic symbol as needing MIPS16 stubs
	and create a "shadow" symbol for the original MIPS16 definition.
	(mips16_reloc_p, got16_reloc_p, call16_reloc_p, hi16_reloc_p)
	(lo16_reloc_p, mips16_call_reloc_p): New functions.
	(_bfd_mips16_elf_reloc_unshuffle): Use mips16_reloc_p to generalize
	relocation checks.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	(_bfd_mips_elf_lo16_reloc): Handle R_MIPS16_GOT16.
	(mips_elf_got16_entry): Add comment.
	(mips_elf_calculate_relocation): Use hi16_reloc_p,
	lo16_reloc_p, mips16_call_reloc_p, call16_reloc_p and got16_reloc_p
	to generalize relocation checks.  Use section_allows_mips16_refs_p
	instead of mips16_stub_section_p.   Handle R_MIPS16_CALL16 and
	R_MIPS16_GOT16, allowing the former to refer directly to a
	MIPS16 function if its stub is not needed.
	(mips16_stub_section_p): Delete.
	(_bfd_mips_elf_symbol_processing): Convert odd-valued function
	symbols into even MIPS16 symbols.
	(mips_elf_add_lo16_rel_addend): Use mips16_reloc_p to generalize
	a relocation check.
	(_bfd_mips_elf_check_relocs): Calculate "bed" and "rel_end"
	earlier in the function.  Use mips16_stub_symndx to identify
	the target function.  Avoid out-of-bounds accesses when the
	stub has no relocations; report an error instead.  Use
	section_allows_mips16_refs_p instead of mips16_stub_section_p.
	Use mips16_call_reloc_p and got16_reloc_p to generalize relocation
	checks.  Handle R_MIPS16_CALL16 and R_MIPS16_GOT16.  Don't create
	dynamic relocations for absolute references to __gnu_local_gp.
	(_bfd_mips_elf_always_size_sections): Pass a bfd_link_info as
	the argument to mips_elf_check_mips16_stubs.  Generalize comment.
	(_bfd_mips_elf_relocate_section): Use hi16_reloc_p and got16_reloc_p
	to generalize relocation checks.
	(_bfd_mips_elf_finish_dynamic_symbol): If a dynamic MIPS16 function
	symbol has a non-MIPS16 stub, redirect the symbol to the stub.
	Fix an overly long line.  Don't give dynamic symbols type STO_MIPS16.
	(_bfd_mips_elf_gc_sweep_hook): Handle R_MIPS16_CALL16 and
	R_MIPS16_GOT16.

gas/
	* config/tc-mips.c (mips16_reloc_p, got16_reloc_p, hi16_reloc_p)
	(lo16_reloc_p): New functions.
	(reloc_needs_lo_p): Use hi16_reloc_p and got16_reloc_p to
	generalize relocation checks.
	(matching_lo_reloc): New function.
	(fixup_has_matching_lo_p): Use it.
	(mips16_mark_labels): Don't clobber a symbol's visibility.
	(append_insn): Use hi16_reloc_p and lo16_reloc_p.
	(mips16_ip): Handle BFD_RELOC_MIPS16_GOT16 and BFD_RELOC_MIPS16_CALL16.
	(md_apply_fix): Likewise.
	(mips16_percent_op): Add %got and %call16.
	(mips_frob_file): Use got16_reloc_p to generalize relocation checks.
	Use matching_lo_reloc.
	(mips_force_relocation): Use hi16_reloc_p and lo16_reloc_p to
	generalize relocation checks.
	(mips_fix_adjustable): Use lo16_reloc_p to generalize relocation
	checks.

gas/testsuite/
	* gas/mips/elf-rel8-mips16.d, gas/mips/elf-rel8-mips16.s,
	* gas/mips/elf-rel9-mips16.d, gas/mips/elf-rel9-mips16.s,
	* gas/mips/elf-rel13-mips16.d, gas/mips/elf-rel13-mips16.s: New tests.
	* gas/mips/mips.exp: Run them.

ld/testsuite/
	* ld-mips-elf/mips16-local-stubs-1.d: Remove stub_for_h3,
	which was only referenced by the .pdr section, and was not
	actually needed by code.
	* ld-mips-elf/mips16-intermix.d: Remove unused static function stubs.
	* ld-mips-elf/mips16-pic-1a.s,
	ld-mips-elf/mips16-pic-1b.s,
	ld-mips-elf/mips16-pic-1-dummy.s,
	ld-mips-elf/mips16-pic-1.dd,
	ld-mips-elf/mips16-pic-1.gd,
	ld-mips-elf/mips16-pic-1.inc,
	ld-mips-elf/mips16-pic-1.ld,
	ld-mips-elf/mips16-pic-2a.s,
	ld-mips-elf/mips16-pic-2b.s,
	ld-mips-elf/mips16-pic-2.ad,
	ld-mips-elf/mips16-pic-2.dd,
	ld-mips-elf/mips16-pic-2.gd,
	ld-mips-elf/mips16-pic-2.nd,
	ld-mips-elf/mips16-pic-2.rd: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@a1608 1
#define elf_backend_hide_symbol		_bfd_mips_elf_hide_symbol
@


1.198
log
@	* elf32-mips.c (elf_backend_write_section): Define.
@
text
@d774 14
a787 2
  /* A placeholder for MIPS16 reference to global offset table.  */
  EMPTY_HOWTO (R_MIPS16_GOT16),
d789 14
a802 2
  /* A placeholder for MIPS16 16 bit call through global offset table.  */
  EMPTY_HOWTO (R_MIPS16_CALL16),
d1251 2
@


1.197
log
@        * elf.c ( _bfd_elf_print_private_bfd_data): Call
        elf_backend_get_target_dtag if defined.
        * elf32-mips.c (elf_backend_get_target_dtag): Define.
        * elf64-mips.c: Likewise.
        * elfn32-mips.c: Likewise.
        * elfxx-mips.c (_bfd_mips_elf_get_target_dtag): New.
        * elfxx-mips.h (_bfd_mips_elf_get_target_dtag): Declare.
        * elf-bfd.h (elf_backend_get_target_dtag): Add prototype.
        * elfxx-target.h (elf_backend_get_target_dtag): Add default.
        (elf_backend_data): Add elf_backend_get_target_dtag.
@
text
@d1597 1
@


1.196
log
@Switch sources over to use the GPL version 3
@
text
@d1561 1
@


1.195
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d12 16
a27 1
This file is part of BFD, the Binary File Descriptor library.
a28 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.194
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d32 1
a33 1
#include "sysdep.h"
@


1.193
log
@include/elf/
	* mips.h (R_MIPS_GLOB_DAT): Define
	(R_MIPS_max): Bump by 1.

bfd/
	* elf32-mips.c (elf_mips_howto_table_rel): Add R_MIPS_GLOB_DAT.
	* elfn32-mips.c (elf_mips_howto_table_rel): Likewise.
	(elf_mips_howto_table_rela): Likewise.
	* elf64-mips.c (mips_elf64_howto_table_rel): Likewise.
	(mips_elf64_howto_table_rela): Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005 Free Software Foundation, Inc.
d1277 34
d1701 11
d1778 3
@


1.192
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d703 15
@


1.191
log
@	* elf32-mips.c, elf64-mips.c, elfn32-mips.c
	(elf_backend_merge_symbol_attribute): Define.
	* elflink.c (elf_link_add_object_symbols): Merge only the ELF
	visibility flags.
	* elfxx-mips.c (_bfd_mips_elf_merge_symbol_attribute): New function.
@
text
@d1516 1
@


1.190
log
@	[ bfd/ChangeLog ]
	* elf32-mips.c (mips16_jump_reloc): Remove function.
	(elf_mips16_howto_table_rel): Use _bfd_mips_elf_generic_reloc
	instead of mips16_jump_reloc.
	* elf64_mips.c, wlfn32-mips.c (mips16_jump_reloc): Remove function.
	(elf_mips16_howto_table_rel, elf_mips16_howto_table_rela): Use
	_bfd_mips_elf_generic_reloc instead of mips16_jump_reloc.

	[ gas/ChangeLog ]
	* config/tc-mips.c (mips_fix_adjustable): Handle BFD_RELOC_MIPS16_JMP.
	(tc_gen_reloc): Handle mips16 jumps to section symbol offsets.

	[ ld/testsuite/ChangeLog ]
	* ld-mips-elf/mips16-call-global-1.s,
	ld-mips-elf/mips16-call-global-2.s,
	ld-mips-elf/mips16-call-global-3.s, ld-mips-elf/mips16-call-global.d:
	Test linking of external mips16 jumps.
	* ld-mips-elf/mips-elf.exp: Run new test.
@
text
@d1508 2
@


1.189
log
@	[ bfd/ChangeLog ]
	* elf32-mips.c: Expand comment about ABI-mandated pagesize values.
	(ELF_MAXPAGESIZE, ELF_COMMONPAGESIZE): define in a more obvious way.
	* elf64-mips.c, elfn32-mips.c (ELF_MAXPAGESIZE): Fix value for IRIX6.
	Delete old comments.
	(ELF_COMMONPAGESIZE): Define in a more obvious way.

	[ ld/ChangeLog ]
	* emulparams/elf64bmip.sh, emulparams/elf64btsmip.sh (COMMONPAGESIZE):
	Define.

	[ ld/testsuite/ChangeLog ]
	* ld-mips-elf/multi-got-no-shared.d: Adjust for recent change of
	ELF_MAXPAGESIZE.
@
text
@a70 2
static bfd_reloc_status_type mips16_jump_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d735 1
a735 1
	 mips16_jump_reloc,	/* special_function */
a1112 30
/* Handle a mips16 jump.  */

static bfd_reloc_status_type
mips16_jump_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		   asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		   asection *input_section, bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* FIXME.  */
  {
    static bfd_boolean warned;

    if (! warned)
      (*_bfd_error_handler)
	(_("Linking mips16 objects into %s format is not supported"),
	 bfd_get_target (input_section->output_section->owner));
    warned = TRUE;
  }

  return bfd_reloc_undefined;
}

@


1.188
log
@bfd/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_emul_get_maxpagesize): New.
	(bfd_elf_set_pagesize): Likewise.
	(bfd_emul_set_maxpagesize): Likewise.
	(bfd_emul_get_commonpagesize): Likewise.
	(bfd_emul_set_commonpagesize): Likewise.
	* bfd-in2.h: Regenerated.

	* elf-bfd.h (elf_backend_data): Add commonpagesize.
	(xvec_get_elf_backend_data): New.
	(get_elf_backend_data): Use xvec_get_elf_backend_data.

	* elf32-arm.c (elf32_arm_vxworks_bed): Remove const.
	* elfxx-target.h (elfNN_bed): Likewise.

	* elf32-arm.c (ELF_COMMONPAGESIZE): Defined.
	* elf32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh64.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-alpha.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-x86-64.c (ELF_COMMONPAGESIZE): Likewise.
	* elfn32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elfxx-ia64.c (ELF_COMMONPAGESIZE): Likewise.

	* elfxx-target.h (ELF_COMMONPAGESIZE): Define if not defined.
	(elfNN_bed): Initialize commonpagesize with ELF_COMMONPAGESIZE.

	* targets.c (bfd_find_target): Support NULL abfd.

ld/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/arcelf.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	* emulparams/armelf_nbsd.sh: Likewise.
	* emulparams/armelf_vxworks.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/armsymbian.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32_i960.sh: Likewise.
	* emulparams/elf32am33lin.sh: Likewise.
	* emulparams/elf32bfinfd.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32frvfd.sh: Likewise.
	* emulparams/elf32i370.sh: Likewise.
	* emulparams/elf32lppcnto.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32openrisc.sh: Likewise.
	* emulparams/elf32ppcnto.sh: Likewise.
	* emulparams/elf32ppcwindiss.sh: Likewise.
	* emulparams/elf32vax.sh: Likewise.
	* emulparams/elf32xc16x.sh: Likewise.
	* emulparams/elf32xc16xl.sh: Likewise.
	* emulparams/elf32xc16xs.sh: Likewise.
	* emulparams/elf64_aix.sh: Likewise.
	* emulparams/elf64hppa.sh: Likewise.
	* emulparams/elf64mmix.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* emulparams/hppalinux.sh: Likewise.
	* emulparams/hppaobsd.sh: Likewise.
	* emulparams/i386lynx.sh: Likewise.
	* emulparams/i386moss.sh: Likewise.
	* emulparams/i386nto.sh: Likewise.
	* emulparams/i386nw.sh: Likewise.
	* emulparams/m32relf_linux.sh: Likewise.
	* emulparams/m68kpsos.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/pjlelf.sh: Likewise.
	* emulparams/ppclynx.sh: Likewise.
	* emulparams/ppcnw.sh: Likewise.
	* emulparams/shelf32_nbsd.sh : Likewise.
	* emulparams/shelf_nbsd.sh: Likewise.
	* emulparams/shelf_nto.sh: Likewise.
	* emulparams/shlelf_nto.sh: Likewise.
	* emulparams/xtensa-config.sh: Likewise.

	* emulparams/armelf_linux.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	(COMMONPAGESIZE): Changed to "CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32_sparc.sh: Likewise.
	* emulparams/elf32bmip.sh: Likewise.
	* emulparams/elf32ppccommon.sh: Likewise.
	* emulparams/elf64_ia64.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/shlelf32_linux.sh: Likewise.
	* emulparams/shlelf_linux.sh: Likewise.

	* emulparams/elf32bmipn32.sh (COMMONPAGESIZE): Changed to
	"CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32btsmipn32.sh: Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	"-z max-page-size=" and "-z common-page-size=".
	(gld${EMULATION_NAME}_list_options): Likewise.

	* ld.h (ld_config_type): Add maxpagesize and commonpagesize.

	* ld.texinfo: Document "-z max-page-size=" and
	"-z common-page-size=".

	* ldexp.c (exp_print_token): Handle CONSTANT.
	(fold_name): Likewise.
	* ldgram.y: Likewise.
	* ldlex.l: Likewise.

	* ldmain.c (main): Initiliaze config.maxpagesize and
	config.commonpagesize. Call bfd_emul_set_maxpagesize if
	config.maxpagesize isn't 0. Call bfd_emul_set_commonpagesize if
	config.commonpagesize config.maxpagesize isn't 0.
ld/testsuite/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/binutils.exp: New file.
	* ld-elf/commonpage1.d: Likewise.
	* ld-elf/maxpage1.d: Likewise.
	* ld-elf/maxpage1.s: Likewise.
@
text
@d1613 1
d1620 5
a1624 2
/* The SVR4 MIPS ABI says that this should be 0x10000, and Linux uses
   page sizes of up to that limit, so we need to respect it.  */
d1626 1
d1711 3
a1721 1
#undef ELF_MAXPAGESIZE
d1723 1
@


1.187
log
@	Richard Sandiford  <richard@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>
	Phil Edwards  <phil@@codesourcery.com>
	Zack Weinberg  <zack@@codesourcery.com>
	Mark Mitchell  <mark@@codesourcery.com>
	Nathan Sidwell  <nathan@@codesourcery.com>

bfd/
	* bfd-in2.h: Regenerate.
	* config.bfd (mips*-*-vxworks*, mips*el-*-vxworks*): New stanzas.
	* configure.in (bfd_elf32_bigmips_vxworks_vec): New stanza.
	(bfd_elf32_littlemips_vxworks_vec): Likewise.
	(bfd_elf32_bigmips_vec): Add elf-vxworks.lo.
	(bfd_elf32_littlemips_vec): Likewise.
	(bfd_elf32_nbigmips_vec): Likewise.
	(bfd_elf32_nlittlemips_vec): Likewise.
	(bfd_elf32_ntradbigmips_vec): Likewise.
	(bfd_elf32_ntradlittlemips_vec): Likewise.
	(bfd_elf32_tradbigmips_vec): Likewise.
	(bfd_elf32_tradlittlemips_vec): Likewise.
	(bfd_elf64_bigmips_vec): Likewise.
	(bfd_elf64_littlemips_vec): Likewise.
	(bfd_elf64_tradbigmips_vec): Likewise.
	(bfd_elf64_tradlittlemips_vec): Likewise.
	* elf32-mips.c: Include elf-vxworks.h.
	(mips_info_to_howto_rel): Use elf_backend_mips_rtype_to_howto
	instead of calling mips_elf32_rtype_to_howto directly.
	(mips_vxworks_copy_howto_rela): New reloc howto.
	(mips_vxworks_jump_slot_howto_rela): Likewise.
	(mips_vxworks_bfd_reloc_type_lookup): New function.
	(mips_vxworks_rtype_to_howto): Likewise.
	(mips_vxworks_final_write_processing): Likewise.
	(TARGET_LITTLE_SYM, TARGET_LITTLE_NAME): Override for VxWorks.
	(TARGET_BIG_SYM, TARGET_BIG_NAME, elf_bed, ELF_MAXPAGESIZE): Likewise.
	(elf_backend_want_got_plt): Likewise.
	(elf_backend_want_plt_sym): Likewise.
	(elf_backend_got_symbol_offset): Likewise.
	(elf_backend_want_dynbss): Likewise.
	(elf_backend_may_use_rel_p): Likewise.
	(elf_backend_may_use_rela_p): Likewise.
	(elf_backend_default_use_rela_p): Likewise.
	(elf_backend_got_header_size: Likewise.
	(elf_backend_plt_readonly): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Likewise.
	(elf_backend_mips_rtype_to_howto): Likewise.
	(elf_backend_adjust_dynamic_symbol): Likewise.
	(elf_backend_finish_dynamic_symbol): Likewise.
	(bfd_elf32_bfd_link_hash_table_create): Likewise.
	(elf_backend_add_symbol_hook): Likewise.
	(elf_backend_link_output_symbol_hook): Likewise.
	(elf_backend_emit_relocs): Likewise.
	(elf_backend_final_write_processing: Likewise.
	(elf_backend_additional_program_headers): Likewise.
	(elf_backend_modify_segment_map): Likewise.
	(elf_backend_symbol_processing): Likewise.
	* elfxx-mips.c: Include elf-vxworks.h.
	(mips_elf_link_hash_entry): Add is_relocation_target and
	is_branch_target fields.
	(mips_elf_link_hash_table): Add is_vxworks, srelbss, sdynbss, srelplt,
	srelplt2, sgotplt, splt, plt_header_size and plt_entry_size fields.
	(MIPS_ELF_RELA_SIZE, MIPS_ELF_REL_DYN_NAME): New macros.
	(MIPS_RESERVED_GOTNO): Take a mips_elf_link_hash_table argument.
	Return 3 for VxWorks.
	(ELF_MIPS_GP_OFFSET): Change the argument from a bfd to a
	mips_elf_link_hash_table.  Return 0 for VxWorks.
	(MIPS_ELF_GOT_MAX_SIZE): Change the argument from a bfd to a
	mips_elf_link_hash_table.  Update the call to ELF_MIPS_GP_OFFSET.
	(mips_vxworks_exec_plt0_entry): New variable.
	(mips_vxworks_exec_plt_entry): Likewise.
	(mips_vxworks_shared_plt0_entry): Likewise.
	(mips_vxworks_shared_plt_entry): Likewise.
	(mips_elf_link_hash_newfunc): Initialize the new hash_entry fields.
	(mips_elf_rel_dyn_section): Change the bfd argument to a
	mips_elf_link_hash_table.  Use MIPS_ELF_REL_DYN_NAME to get
	the name of the section.
	(mips_elf_initialize_tls_slots): Update the call to
	mips_elf_rel_dyn_section.
	(mips_elf_gotplt_index): New function.
	(mips_elf_local_got_index): Add an input_section argument.
	Update the call to mips_elf_create_local_got_entry.
	(mips_elf_got_page): Likewise.
	(mips_elf_got16_entry): Likewise.
	(mips_elf_create_local_got_entry): Add bfd_link_info and input_section
	arguments.  Create dynamic relocations for each entry on VxWorks.
	(mips_elf_merge_gots): Update the use of MIPS_ELF_GOT_MAX_SIZE.
	(mips_elf_multi_got): Update the uses of MIPS_ELF_GOT_MAX_SIZE
	and MIPS_RESERVED_GOTNO.
	(mips_elf_create_got_section): Update the uses of
	MIPS_ELF_GOT_MAX_SIZE.  Create .got.plt on VxWorks.
	(is_gott_symbol): New function.
	(mips_elf_calculate_relocation): Use a dynobj local variable.
	Update the calls to mips_elf_local_got_index, mips_elf_got16_entry and
	mips_elf_got_page_entry.  Set G to the .got.plt entry when calculating
	VxWorks R_MIPS_CALL* relocations.  Calculate and use G for all GOT
	relocations on VxWorks.  Add dynamic relocations for references
	to the VxWorks __GOTT_BASE__ and __GOTT_INDEX__ symbols.  Don't
	create dynamic relocations for R_MIPS_32, R_MIPS_REL32 or R_MIPS_64
	in VxWorks executables.
	(mips_elf_allocate_dynamic_relocations): Add a bfd_link_info argument.
	Use MIPS_ELF_RELA_SIZE to calculate the size of a VxWorks entry.
	Don't allocate a null entry on VxWorks.
	(mips_elf_create_dynamic_relocation): Update the call to
	mips_elf_rel_dyn_section.  Use absolute rather than relative
	relocations for VxWorks, and make them RELA rather than REL.
	(_bfd_mips_elf_create_dynamic_sections): Don't make .dynamic
	read-only on VxWorks.  Update the call to mips_elf_rel_dyn_section.
	Create the .plt, .rela.plt, .dynbss and .rela.bss sections on
	VxWorks.  Likewise create the _PROCEDURE_LINKAGE_TABLE symbol.
	Call elf_vxworks_create_dynamic_sections for VxWorks and
	initialize the plt_header_size and plt_entry_size fields.
	(_bfd_mips_elf_check_relocs): Don't allow GOT relocations to be
	used in VxWorks executables.  Don't allocate dynamic relocations
	for R_MIPS_32, R_MIPS_REL32 or R_MIPS_64 in VxWorks executables.
	Set is_relocation_target for each symbol referenced by a relocation.
	Allocate .rela.dyn entries for relocations against the special
	VxWorks __GOTT_BASE__ and __GOTT_INDEX__ symbols.  Create GOT
	entries for all VxWorks R_MIPS_GOT16 relocations.  Don't allocate
	a global GOT entry for symbols mentioned in VxWorks R_MIPS_CALL*,
	R_MIPS_32, R_MIPS_REL32 or R_MIPS_64 relocations.  Update the calls
	to mips_elf_rel_dyn_section and mips_elf_allocate_dynamic_relocations.
	Set is_branch_target for symbols mentioned in R_MIPS_PC16 or R_MIPS_26
	relocations.  Don't set no_fn_stub on VxWorks.
	(_bfd_mips_elf_adjust_dynamic_symbol): Update the call to
	mips_elf_allocate_dynamic_relocations.
	(_bfd_mips_vxworks_adjust_dynamic_symbol): New function.
	(_bfd_mips_elf_always_size_sections): Do not allocate GOT page
	entries for VxWorks, and do not create multiple GOTs.
	(_bfd_mips_elf_size_dynamic_sections): Use MIPS_ELF_REL_DYN_NAME.
	Handle .got specially for VxWorks.  Update the uses of
	MIPS_RESERVED_GOTNO and mips_elf_allocate_dynamic_relocations.
	Check for sgotplt and splt.  Allocate the .rel(a).dyn contents last,
	once its final size is known.  Set DF_TEXTREL for VxWorks.  Add
	DT_RELA, DT_RELASZ, DT_RELAENT, DT_PLTREL, DT_PLTRELSZ and DT_JMPREL
	tags on VxWorks.  Do not add the MIPS-specific tags for VxWorks.
	(_bfd_mips_vxworks_finish_dynamic_symbol): New function.
	(mips_vxworks_finish_exec_plt): Likewise.
	(mips_vxworks_finish_shared_plt): Likewise.
	(_bfd_mips_elf_finish_dynamic_sections): Remove an unncessary call
	to mips_elf_rel_dyn_section.  Use a VxWorks-specific value of
	DT_PLTGOT.  Handle DT_RELA, DT_RELASZ, DT_RELAENT, DT_PLTREL,
	DT_PLTRELSZ and DT_JMPREL.  Update the uses of MIPS_RESERVED_GOTNO
	and mips_elf_rel_dyn_section.  Use a different GOT header for
	VxWorks.  Don't sort .rela.dyn on VxWorks.  Finish the PLT on VxWorks.
	(_bfd_mips_elf_link_hash_table_create): Initialize the new
	mips_elf_link_hash_table fields.
	(_bfd_mips_vxworks_link_hash_table_create): New function.
	(_bfd_mips_elf_final_link): Set the GP value to _GLOBAL_OFFSET_TABLE_
	on VxWorks.  Update the call to ELF_MIPS_GP_OFFSET.
	* elfxx-mips.h (_bfd_mips_vxworks_adjust_dynamic_symbol): Declare.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_vxworks_link_hash_table_create): Likewise.
	* libbfd.h: Regenerate.
	* Makefile.am (elfxx-mips.lo): Depend on elf-vxworks.h.
	(elf32-mips.lo): Likewise.
	* Makefile.in: Regenerate.
	* reloc.c (BFD_RELOC_MIPS_COPY, BFD_RELOC_MIPS_JUMP_SLOT): Declare.
	* targets.c (bfd_elf32_bigmips_vxworks_vec): Declare.
	(bfd_elf32_littlemips_vxworks_vec): Likewise.
	(_bfd_target_vector): Add entries for them.

gas/
	* config/tc-mips.c (mips_target_format): Handle vxworks targets.
	(md_begin): Complain about -G being used for PIC.  Don't change
	the text, data and bss alignments on VxWorks.
	(reloc_needs_lo_p): Don't return true for R_MIPS_GOT16 when
	generating VxWorks PIC.
	(load_address): Extend SVR4_PIC handling to VXWORKS_PIC.
	(macro): Likewise, but do not treat la $25 specially for
	VxWorks PIC, and do not handle jal.
	(OPTION_MVXWORKS_PIC): New macro.
	(md_longopts): Add -mvxworks-pic.
	(md_parse_option): Don't complain about using PIC and -G together here.
	Handle OPTION_MVXWORKS_PIC.
	(md_estimate_size_before_relax): Always use the first relaxation
	sequence on VxWorks.
	* config/tc-mips.h (VXWORKS_PIC): New.

gas/testsuite/
	* gas/mips/vxworks1.s, gas/mips/vxworks1.d,
	* gas/mips/vxworks1-xgot.d: New tests.
	* gas/mips/mips.exp: Run them.  Do not run other tests on VxWorks.

include/elf/
	* mips.h (R_MIPS_COPY, R_MIPS_JUMP_SLOT): New relocs.

ld/
	* configure.tgt (mips*el-*-vxworks*, mips*-*-vxworks*): Use
	separate VxWorks emulations.
	* emulparams/elf32ebmipvxworks.sh: New file.
	* emulparams/elf32elmipvxworks.sh: New file.
	* Makefile.am (ALL_EMULATIONS): Add eelf32ebmipvxworks.o and
	eelf32elmipvxworks.o.
	(eelf32ebmipvxworks.c, eelf32elmipvxworks.c): New rules.
	* Makefile.in: Regenerate.

ld/testsuite/
	* ld-mips/vxworks1.dd, ld-mips/vxworks1.ld, ld-mips/vxworks1-lib.dd,
	* ld-mips/vxworks1-lib.nd, ld-mips/vxworks1-lib.rd,
	* ld-mips/vxworks1-lib.s, ld-mips/vxworks1.rd, ld-mips/vxworks1.s,
	* ld-mips/vxworks1-static.d, ld-mips/vxworks2.s, ld-mips/vxworks2.sd,
	* ld-mips/vxworks2-static.sd: New tests.
	* ld-mips/mips-elf.exp: Run them.
@
text
@d1602 1
@


1.186
log
@bfd/
	* elf32-mips.c (elf_mips_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf32_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elf64-mips.c (mips_elf64_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(mips_elf64_howto_table_rela): Likewise.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf64_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elfn32-mips.c (elf_mips_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(elf_mips_howto_table_rela): Likewise.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf32_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elfxx-mips.c: Formatting fixes.
	(mips_elf_calculate_relocation): Handle R_MIPS_GNU_REL16_S2
	and R_MIPS_PC16 identically.
gas/
	* config/tc-mips.c (append_insn): Handle BFD_RELOC_16_PCREL_S2.
	(macro_build): Complain for invalid branch displacements.
	(mips_validate_fix): Delete.
	(md_apply_fix): Re-add pcrel support for branches.  Use consistent
	text for misaligned branch targets.
	(tc_gen_reloc: Re-add pcrel support for branches.  Handle strange
	BFD pcrel processing.  Remove error for unresolved branches.
	* config/tc-mips.h (TC_VALIDATE_FIX, mips_validate_fix): Delete.
gas/testsuite/
	* gas/mips/bge.d, gas/mips/bge.s, gas/mips/bgeu.d, gas/mips/bgeu.s,
	gas/mips/blt.d, gas/mips/blt.s, gas/mips/bltu.d,
	gas/mips/bltu.s: Reactivate external branch tests.
	* gas/mips/branch-misc-2.d, gas/mips/branch-misc-2pic.d,
	gas/mips/branch-misc-2-64.d, gas/mips/branch-misc-2pic-64.d: New
	tests.
	* gas/mips/branch-misc-2.l, gas/mips/branch-misc-2pic.l,
	gas/testsuite/gas/mips/branch-misc-2pic.s: Remove.
	* gas/mips/mips.exp: Adjust branch-misc-2 tests.  Add 64-bit
	variants.
@
text
@d40 1
d1323 1
d1327 2
a1328 1
  cache_ptr->howto = mips_elf32_rtype_to_howto (r_type, FALSE);
d1625 144
@


1.186.6.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a39 1
#include "elf-vxworks.h"
a1321 1
  const struct elf_backend_data *bed;
d1325 1
a1325 2
  bed = get_elf_backend_data (abfd);
  cache_ptr->howto = bed->elf_backend_mips_rtype_to_howto (r_type, FALSE);
a1621 144


/* Specific to VxWorks.  */
static reloc_howto_type mips_vxworks_copy_howto_rela =
  HOWTO (R_MIPS_COPY,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_COPY",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,         		/* src_mask */
	 0x0,		        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Specific to VxWorks.  */
static reloc_howto_type mips_vxworks_jump_slot_howto_rela =
  HOWTO (R_MIPS_JUMP_SLOT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_JUMP_SLOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,         		/* src_mask */
	 0x0,		        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Implement elf_backend_bfd_reloc_type_lookup for VxWorks.  */

static reloc_howto_type *
mips_vxworks_bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
{
  switch (code)
    {
    case BFD_RELOC_MIPS_COPY:
      return &mips_vxworks_copy_howto_rela;
    case BFD_RELOC_MIPS_JUMP_SLOT:
      return &mips_vxworks_jump_slot_howto_rela;
    default:
      return bfd_elf32_bfd_reloc_type_lookup (abfd, code);
    }
}

/* Implement elf_backend_mips_rtype_to_lookup for VxWorks.  */

static reloc_howto_type *
mips_vxworks_rtype_to_howto (unsigned int r_type, bfd_boolean rela_p)
{
  switch (r_type)
    {
    case R_MIPS_COPY:
      return &mips_vxworks_copy_howto_rela;
    case R_MIPS_JUMP_SLOT:
      return &mips_vxworks_jump_slot_howto_rela;
    default:
      return mips_elf32_rtype_to_howto (r_type, rela_p);
    }
}

/* Implement elf_backend_final_write_processing for VxWorks.  */

static void
mips_vxworks_final_write_processing (bfd *abfd, bfd_boolean linker)
{
  _bfd_mips_elf_final_write_processing (abfd, linker);
  elf_vxworks_final_write_processing (abfd, linker);
}

#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME
#undef TARGET_BIG_SYM
#undef TARGET_BIG_NAME

#define TARGET_LITTLE_SYM               bfd_elf32_littlemips_vxworks_vec
#define TARGET_LITTLE_NAME              "elf32-littlemips-vxworks"
#define TARGET_BIG_SYM                  bfd_elf32_bigmips_vxworks_vec
#define TARGET_BIG_NAME                 "elf32-bigmips-vxworks"

#undef elf32_bed
#define elf32_bed			elf32_mips_vxworks_bed

#undef ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE			0x1000

#undef elf_backend_want_got_plt
#define elf_backend_want_got_plt		1
#undef elf_backend_want_plt_sym
#define elf_backend_want_plt_sym		1
#undef elf_backend_got_symbol_offset
#define elf_backend_got_symbol_offset		0
#undef elf_backend_want_dynbss
#define elf_backend_want_dynbss			1
#undef elf_backend_may_use_rel_p
#define elf_backend_may_use_rel_p		0
#undef elf_backend_may_use_rela_p
#define elf_backend_may_use_rela_p		1
#undef elf_backend_default_use_rela_p
#define elf_backend_default_use_rela_p		1
#undef elf_backend_got_header_size
#define elf_backend_got_header_size		(4 * 3)
#undef elf_backend_plt_readonly
#define elf_backend_plt_readonly		1

#undef bfd_elf32_bfd_reloc_type_lookup
#define bfd_elf32_bfd_reloc_type_lookup \
  mips_vxworks_bfd_reloc_type_lookup
#undef elf_backend_mips_rtype_to_howto
#define elf_backend_mips_rtype_to_howto	\
  mips_vxworks_rtype_to_howto
#undef elf_backend_adjust_dynamic_symbol
#define elf_backend_adjust_dynamic_symbol \
  _bfd_mips_vxworks_adjust_dynamic_symbol
#undef elf_backend_finish_dynamic_symbol
#define elf_backend_finish_dynamic_symbol \
  _bfd_mips_vxworks_finish_dynamic_symbol
#undef bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create \
  _bfd_mips_vxworks_link_hash_table_create
#undef elf_backend_add_symbol_hook
#define elf_backend_add_symbol_hook \
  elf_vxworks_add_symbol_hook
#undef elf_backend_link_output_symbol_hook
#define elf_backend_link_output_symbol_hook \
  elf_vxworks_link_output_symbol_hook
#undef elf_backend_emit_relocs
#define elf_backend_emit_relocs \
  elf_vxworks_emit_relocs
#undef elf_backend_final_write_processing
#define elf_backend_final_write_processing \
  mips_vxworks_final_write_processing

#undef elf_backend_additional_program_headers
#undef elf_backend_modify_segment_map
#undef elf_backend_symbol_processing
/* NOTE: elf_backend_rela_normal is not defined for MIPS.  */

#include "elf32-target.h"
@


1.185
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@d260 3
a262 1
  /* 16 bit PC relative reference.  */
d264 1
a264 1
	 0,			/* rightshift */
d1211 1
a1211 1
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
a1287 2
    case BFD_RELOC_16_PCREL_S2:
      return &elf_mips_gnu_rel16_s2;
@


1.184
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d1576 1
@


1.183
log
@Update the FSF address in the copyright/GPL notice
@
text
@d26 1
a26 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.182
log
@	* elfxx-mips.c (struct mips_got_entry): Add tls_type.
	(struct mips_got_info): Add tls_gotno, tls_assigned_gotno,
	and tls_ldm_offset.
	(struct mips_elf_got_per_bfd_arg): Add global_count.
	(struct mips_elf_count_tls_arg): New.
	(struct mips_elf_hash_sort_data): Update comment for min_got_dynindx.
	(struct mips_elf_link_hash_entry): Add tls_type and tls_got_offset.
	(GOT_NORMAL, GOT_TLS_GD, GOT_TLS_LDM, GOT_TLS_IE)
	(GOT_TLS_OFFSET_DONE, GOT_TLS_DONE): Define.
	(TLS_RELOC_P): Define.
	(TP_OFFSET, DTP_OFFSET): Define.
	(dtprel_base, tprel_base): New functions.
	(mips_elf_link_hash_newfunc): Initialize tls_type.
	(mips_elf_got_entry_hash, mips_elf_got_entry_eq)
	(mips_elf_multi_got_entry_hash, mips_elf_multi_got_entry_eq): Handle
	TLS entries.
	(mips_tls_got_relocs, mips_elf_count_local_tls_relocs)
	(mips_elf_count_global_tls_entries, mips_elf_count_global_tls_relocs)
	(mips_elf_output_dynamic_relocation, mips_elf_initialize_tls_slots)
	(mips_tls_got_index): New functions.
	(mips_elf_local_got_index): Add new R_SYMNDX, H, and R_TYPE
	arguments.  Pass them to mips_elf_create_local_got_entry.  Use
	mips_tls_got_index.
	(mips_elf_global_got_index): Add new R_TYPE and INFO arguments.
	Handle TLS entries.
	(mips_elf_got_page, mips_elf_got16_entry): Update calls to
	mips_elf_create_local_got_entry.
	(mips_elf_create_local_got_entry): Add new R_SYMNDX, H, and R_TYPE
	arguments.  Handle TLS entries.
	(mips_elf_sort_hash_table_f): Add non-TLS assertions.
	(mips_elf_record_local_got_symbol): Add new TLS_FLAG argument.  Handle
	TLS entries.
	(mips_elf_record_global_got_symbol): Likewise.
	(mips_elf_make_got_per_bfd): Initialize new mips_got_info members.
	Count TLS entries.
	(mips_elf_merge_gots): Handle TLS entries when merging.
	(mips_elf_initialize_tls_index): New function.
	(mips_elf_set_global_got_offset): Handle TLS entries.
	(mips_elf_adjust_gp): Handle TLS.
	(mips_elf_multi_got): Remove redundant call to
	mips_elf_resolve_final_got_entries.  Initialize global_count.
	Correct a comment.  Initialize new TLS members of mips_got_info.
	Assign TLS GOT indexes for new GOTs.
	(mips_elf_create_got_section): Initialize new TLS members of
	mips_got_info.
	(mips_elf_calculate_relocation): Handle TLS relocs.
	(_bfd_mips_elf_check_relocs): Likewise.  Update calls to changed
	functions.
	(_bfd_mips_elf_always_size_sections): Handle TLS.
	(_bfd_mips_elf_size_dynamic_sections): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.  Update calls to
	changed functions.
	(_bfd_mips_elf_copy_indirect_symbol): Copy tls_type.
	(_bfd_mips_elf_hide_symbol): Handle TLS.
	* elfn32-mips.c (elf_mips_howto_table_rel, elf_mips_howto_table_rela)
	(mips_reloc_map): Add TLS relocs.
	* elf32-mips.c (elf_mips_howto_table_rel, mips_reloc_map): Likewise.
	* elf64-mips.c (mips_elf64_howto_table_rel)
	(mips_elf64_howto_table_rela, mips_reloc_map): Likewise.
	* reloc.c: Define new MIPS TLS relocations.
	* libbfd.h, bfd-in2.h: Regenerated.
@
text
@d26 1
a26 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.181
log
@bfd/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* elf32-mips.c (elf_mips16_howto_table_rel): New array for MIPS16
	reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16 relocs and
	R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into elf_mips16_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf32_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf32_rtype_to_howto): Fetch MIPS16 howtos from
	elf_mips16_howto_table_rel.
	* elf64-mips.c (mips16_elf64_howto_table_rel): New array for
	MIPS16 REL reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16
	relocs and R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into mips16_elf64_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_elf64_howto_table_rela): New array for MIPS16 RELA
	reloc howtos.  Add R_MIPS16_26, R_MIPS16_GPREL, R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs and R_MIPS16_GOT16 and R_MIPS16_CALL16
	placeholders.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf64_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf64_rtype_to_howto): Fetch MIPS16 howtos from
	mips16_elf64_howto_table_rela or mips16_elf64_howto_table_rel.
	* elfn32-mips.c (elf_mips16_howto_table_rel): New array for MIPS16
	REL reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16 relocs and
	R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into elf_mips16_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf32_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf_n32_rtype_to_howto): Fetch MIPS16 howtos from
	elf_mips16_howto_table_rela or elf_mips16_howto_table_rel.
	* elfxx-mips.c (_bfd_mips16_elf_reloc_unshuffle): New function to
	handle bit shuffling for MIPS16 relocs.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	(_bfd_mips_elf_lo16_reloc): Use _bfd_mips16_elf_reloc_unshuffle()
	and _bfd_mips16_elf_reloc_shuffle().
	(_bfd_mips_elf_generic_reloc): Likewise.
	(mips_elf_calculate_relocation): Likewise.  Handle R_MIPS16_HI16
	and R_MIPS16_LO16.
	(mips_elf_obtain_contents): Remove bit shuffling.
	(mips_elf_perform_relocation): Likewise; call
	_bfd_mips16_elf_reloc_unshuffle() and _bfd_mips16_elf_reloc_shuffle()
	instead.
	(_bfd_mips_elf_relocate_section): Likewise.  Handle R_MIPS16_HI16
	and R_MIPS16_LO16.
	* elfxx-mips.h (_bfd_mips16_elf_reloc_unshuffle): Declare.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	* reloc.c (BFD_RELOC_MIPS16_HI16): New reloc.
	(BFD_RELOC_MIPS16_HI16_S): Likewise.
	(BFD_RELOC_MIPS16_LO16): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

gas/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* config/tc-mips.c (reloc_needs_lo_p): Handle
	BFD_RELOC_MIPS16_HI16_S.
	(fixup_has_matching_lo_p): Handle BFD_RELOC_MIPS16_LO16.
	(append_insn): Add BFD_RELOC_MIPS16_GPREL, BFD_RELOC_MIPS16_HI16_S
	and BFD_RELOC_MIPS16_LO16 to relocs to suppress overflow
	complaints on.
	(mips16_ip): Resolve BFD_RELOC_MIPS16_HI16_S,
	BFD_RELOC_MIPS16_HI16 and BFD_RELOC_MIPS16_LO16 for constants.
	Call my_getSmallExpression() to parse percent operators.
	(percent_op_match, mips_percent_op): Separate definitions.
	(mips16_percent_op): Define percent operators for the MIPS16 mode.
	(parse_relocation): Handle the MIPS16 mode using
	mips16_percent_op.
	(md_apply_fix3): Handle BFD_RELOC_MIPS16_HI16,
	BFD_RELOC_MIPS16_HI16_S and BFD_RELOC_MIPS16_LO16.

gas/testsuite/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* gas/mips/mips16-hilo.d: New test for the R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs.
	* gas/mips/mips16-hilo-n32.d: Likewise, for the n32 ABI.
	* gas/mips/mips16-hilo.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.

include/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* elf/mips.h (R_MIPS16_GOT16): New reloc code.
	(R_MIPS16_CALL16): Likewise.
	(R_MIPS16_HI16): Likewise.
	(R_MIPS16_LO16): Likewise.
	(R_MIPS16_min): New fake reloc code.
	(R_MIPS16_max): Likewise.

ld/testsuite/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* ld-mips-elf/mips16-hilo.d: New test for the R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs.
	* ld-mips-elf/mips16-hilo-n32.d: Likewise, for the n32 ABI.
	* ld-mips-elf/mips16-hilo.s: Auxiliary source for the new tests.
	* ld-mips-elf/mips-elf.exp: Run the new tests.
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
d548 154
d1219 14
a1232 1
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP }
@


1.180
log
@* elf32-mips.c (_bfd_mips_elf32_gprel16_reloc): Reject
R_MIPS_LITERAL relocations for external symbols.
* elf64-mips.c (mips_elf64_literal_reloc): Likewise.
* elfn32-mips.c (mips_elf_literal_reloc): Likewise.
@
text
@d567 3
a569 2
/* The reloc used for the mips16 jump instruction.  */
static reloc_howto_type elf_mips16_jump_howto =
d585 1
a585 1
	 FALSE);		/* pcrel_offset */
d587 1
a587 2
/* The reloc used for the mips16 gprel instruction.  */
static reloc_howto_type elf_mips16_gprel_howto =
d598 40
a637 3
	 0x07ff001f,		/* src_mask */
	 0x07ff001f,	        /* dst_mask */
	 FALSE);		/* pcrel_offset */
d997 1
a998 4
  unsigned short extend = 0;
  unsigned short insn = 0;
  bfd_signed_vma val;
  bfd_vma relocation;
d1023 8
a1030 2
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;
d1032 1
a1032 46
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    {
      /* Pick up the mips16 extend instruction and the real instruction.  */
      extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
      insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);
      val += ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
    }

  _bfd_mips_elf_sign_extend(val, 16);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    {
      bfd_put_16 (abfd,
		  (extend & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0),
		  (bfd_byte *) data + reloc_entry->address);
      bfd_put_16 (abfd,
		  (insn & 0xffe0) | (val & 0x1f),
		  (bfd_byte *) data + reloc_entry->address + 2);
    }
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
d1068 8
d1083 1
d1092 7
a1114 4
    case BFD_RELOC_MIPS16_JMP:
      return &elf_mips16_jump_howto;
    case BFD_RELOC_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
a1133 4
    case R_MIPS16_26:
      return &elf_mips16_jump_howto;
    case R_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
d1143 2
@


1.179
log
@* elf32-mips.c (mips_elf_gprel32_reloc): Reject
R_MIPS_GPREL32 relocations against external symbols.
* elf64-mips.c (mips_elf64_gprel32_reloc): Replace an incorrect
comment.
@
text
@d773 11
@


1.178
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d803 10
@


1.177
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a826 1
  bfd_size_type sz;
d836 1
a836 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
a943 1
  bfd_size_type sz;
d968 1
a968 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
@


1.176
log
@[ bfd/ChangeLog ]
2004-06-14  Chris Demetriou  <cgd@@broadcom.com>

        * elf32-mips.c (elf_mips_gnu_pcrel32): Add (undoing 2004-04-24
        removal) with updated comment.
        (bfd_elf32_bfd_reloc_type_lookup): Add back case for
        BFD_RELOC_32_PCREL.
        (mips_elf32_rtype_to_howto): Add back case for R_MIPS_PC32.
        * elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

[ include/elf/ChangeLog ]
2004-06-14  Chris Demetriou  <cgd@@broadcom.com>

        * mips.h (R_MIPS_PC32): Add back (undoing removal on 2004-04-24),
        with an updated comment.
@
text
@d3 1
a3 1
   2003 Free Software Foundation, Inc.
d827 1
d837 2
a838 1
  if (reloc_entry->address > input_section->_cooked_size)
d946 1
d971 2
a972 1
  if (reloc_entry->address > input_section->_cooked_size)
d1216 1
a1216 1
  unsigned int raw_size;
d1232 1
a1232 1
	raw_size = 180;
d1239 1
a1239 1
					  raw_size, note->descpos + offset);
@


1.175
log
@[ bfd/ChangeLog ]
2004-04-24  Chris Demetriou  <cgd@@broadcom.com>

	* elf32-mips.c (elf_mips_gnu_rel_hi16, elf_mips_gnu_rel_lo16)
	(elf_mips_gnu_pcrel64, elf_mips_gnu_pcrel32): Remove.
	(bfd_elf32_bfd_reloc_type_lookup): Remove cases for
	BFD_RELOC_PCREL_HI16_S, BFD_RELOC_PCREL_LO16, BFD_RELOC_64_PCREL,
	and BFD_RELOC_32_PCREL.
	(mips_elf32_rtype_to_howto): Remove cases for R_MIPS_GNU_REL_HI16,
	R_MIPS_GNU_REL_LO16, R_MIPS_PC64, R_MIPS_PC32.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
	(_bfd_mips_elf_lo16_reloc): Remove handling for R_MIPS_GNU_REL_HI16.
	(mips_elf_next_relocation): Move comment about matching HI/LO
	relocations to...
	(_bfd_mips_elf_relocate_section): Here.  Remove handling for
	R_MIPS_GNU_REL_HI16.

[ include/elf/ChangeLog ]
2004-04-24  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h (R_MIPS_PC32, R_MIPS_PC64, R_MIPS_GNU_REL_LO16)
	(R_MIPS_GNU_REL_HI16): Remove.
	(R_MIPS_GNU_REL16_S2): Update comment.

[ ld/testsuite/ChangeLog ]
2004-04-24  Chris Demetriou  <cgd@@broadcom.com>

	* ld-elf/merge.d: XFAIL on all MIPS targets.
@
text
@d618 19
d1093 2
d1116 2
@


1.174
log
@[ bfd/ChangeLog ]
2004-04-21  Chris Demetriou  <cgd@@broadcom.com>

	* coff-mips.c (bfd_mips_ecoff_create_embedded_relocs): Remove.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Remove.
	* bfd-in.h (bfd_mips_ecoff_create_embedded_relocs)
	(bfd_mips_elf32_create_embedded_relocs): Remove prototypes
	* bfd-in2.h: Regenerate.

[ ld/ChangeLog ]
2004-04-21  Chris Demetriou  <cgd@@broadcom.com>

	* ld.texinfo: Remove MIPS --embedded-relocs documentation.
	* emulparams/elf32bmip.sh (EXTRA_EM_FILE): Remove definition.
	* emulparams/mipsidt.sh (TEMPLATE_NAME): Use generic.em.
	(EXTRA_EM_FILE): Use mipsecoff.em
	* emulparams/mipsidtl.sh (TEMPLATE_NAME): Use generic.em.
	(EXTRA_EM_FILE): Use mipsecoff.em
	* emultempl/mipsecoff.em: Restructure to be included as an
	extra emulation file.
	(check_sections, gld${EMULATION_NAME}_after_open)
	(gld${EMULATION_NAME}_after_allocation)
	(gld${EMULATION_NAME}_get_script)
	(ld_${EMULATION_NAME}_emulation): Remove
	(gld${EMULATION_NAME}_before_parse): Rename to...
	(mipsecoff_before_parse): This.
	(LDEMUL_BEFORE_PARSE): Define.
	* emultempl/mipself.em: Remove file.
	* scripttempl/mips.sc (.rel.sdata): Do not include in output.
	(__runtime_reloc_start, __runtime_reloc_stop): Stop providing
	these symbols.
	* Makefile.am: Remove dependencies on emultempl/mipself.em.
	* Makefile.in: Regenerate.

[ ld/testsuite/ChangeLog ]
2004-04-21  Chris Demetriou  <cgd@@broadcom.com>

	* ld-empic/run.c: Removed as part of MIPS --embedded-relocs removal.
	* ld-empic/empic.exp: Likewise.
	* ld-empic/relax.t: Likewise.
	* ld-empic/relax1.c: Likewise.
	* ld-empic/relax2.c: Likewise.
	* ld-empic/relax3.c: Likewise.
	* ld-empic/relax4.c: Likewise.
	* ld-empic/runtest1.c: Likewise.
	* ld-empic/runtest2.c: Likewise.
	* ld-empic/runtesti.s: Likewise.
	* ld-mips-elf/empic1-ln.d: Likewise.
	* ld-mips-elf/empic1-lp.d: Likewise.
	* ld-mips-elf/empic1-mn.d: Likewise.
	* ld-mips-elf/empic1-mp.d: Likewise.
	* ld-mips-elf/empic1-ref.s: Likewise.
	* ld-mips-elf/empic1-sn.d: Likewise.
	* ld-mips-elf/empic1-sp.d: Likewise.
	* ld-mips-elf/empic1-space.s: Likewise.
	* ld-mips-elf/empic1-tgt.s: Likewise.
	* ld-mips-elf/empic2-fwd-0.d: Likewise.
	* ld-mips-elf/empic2-fwd-1.d: Likewise.
	* ld-mips-elf/empic2-fwd-tgt.s: Likewise.
	* ld-mips-elf/empic2-ref.s: Likewise.
	* ld-mips-elf/empic2-rev-0.d: Likewise.
	* ld-mips-elf/empic2-rev-1.d: Likewise.
	* ld-mips-elf/empic2-rev-tgt.s: Likewise.
	* ld-mips-elf/empic2-space.s: Likewise.
	* ld-mips-elf/emrelocs-eb.d: Likewise.
	* ld-mips-elf/emrelocs-el.d: Likewise.
	* ld-mips-elf/emrelocs.ld: Likewise.
	* ld-mips-elf/emrelocs1.s: Likewise.
	* ld-mips-elf/emrelocs2.s: Likewise.
	* ld-mips-elf/mips-elf.exp: Don't run now-removed tests.
@
text
@a601 33
/* GNU extensions for embedded-pic.  */
/* High 16 bits of symbol value, pc-relative.  */
static reloc_howto_type elf_mips_gnu_rel_hi16 =
  HOWTO (R_MIPS_GNU_REL_HI16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MIPS_GNU_REL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* Low 16 bits of symbol value, pc-relative.  */
static reloc_howto_type elf_mips_gnu_rel_lo16 =
  HOWTO (R_MIPS_GNU_REL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MIPS_GNU_REL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

a617 32
/* 64 bit pc-relative.  */
static reloc_howto_type elf_mips_gnu_pcrel64 =
  HOWTO (R_MIPS_PC64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_PC64",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* 32 bit pc-relative.  */
static reloc_howto_type elf_mips_gnu_pcrel32 =
  HOWTO (R_MIPS_PC32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_PC32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

a1071 4
    case BFD_RELOC_PCREL_HI16_S:
      return &elf_mips_gnu_rel_hi16;
    case BFD_RELOC_PCREL_LO16:
      return &elf_mips_gnu_rel_lo16;
a1073 4
    case BFD_RELOC_64_PCREL:
      return &elf_mips_gnu_pcrel64;
    case BFD_RELOC_32_PCREL:
      return &elf_mips_gnu_pcrel32;
a1092 4
    case R_MIPS_GNU_REL_HI16:
      return &elf_mips_gnu_rel_hi16;
    case R_MIPS_GNU_REL_LO16:
      return &elf_mips_gnu_rel_lo16;
a1094 4
    case R_MIPS_PC64:
      return &elf_mips_gnu_pcrel64;
    case R_MIPS_PC32:
      return &elf_mips_gnu_pcrel32;
@


1.173
log
@* elf32-mips.c (ELF_MAXPAGESIZE): Redefine for traditional
targets to support pages of up to 64kB.
(elf32_bed): Redefine to get a separate backend data structure for
traditional targets.
* elf64-mips.c (ELF_MAXPAGESIZE): Redefine for traditional
targets to support pages of up to 64kB.
(elf64_bed): Redefine to get a separate backend data structure for
traditional targets.
* elfn32-mips.c (ELF_MAXPAGESIZE): Redefine for traditional
targets to support pages of up to 64kB.
(elf32_bed): Redefine to get a separate backend data structure for
traditional targets.
@
text
@a1337 133
/* Given a data section and an in-memory embedded reloc section, store
   relocation information into the embedded reloc section which can be
   used at runtime to relocate the data section.  This is called by the
   linker when the --embedded-relocs switch is used.  This is called
   after the add_symbols entry point has been called for all the
   objects, and before the final_link entry point is called.  */

bfd_boolean
bfd_mips_elf32_create_embedded_relocs (bfd *abfd, struct bfd_link_info *info,
				       asection *datasec, asection *relsec,
				       char **errmsg)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *p;

  BFD_ASSERT (! info->relocatable);

  *errmsg = NULL;

  if (datasec->reloc_count == 0)
    return TRUE;

  /* Read this BFD's symbols if we haven't done so already, or get the cached
     copy if it exists.  */
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  if (symtab_hdr->sh_info != 0)
    {
      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isymbuf == NULL)
	isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					symtab_hdr->sh_info, 0,
					NULL, NULL, NULL);
      if (isymbuf == NULL)
	goto error_return;
    }

  /* Get a copy of the native relocations.  */
  internal_relocs = _bfd_elf_link_read_relocs (abfd, datasec, NULL, NULL,
					       info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;

  relsec->contents = bfd_alloc (abfd, datasec->reloc_count * 12);
  if (relsec->contents == NULL)
    goto error_return;

  p = relsec->contents;

  irelend = internal_relocs + datasec->reloc_count;

  for (irel = internal_relocs; irel < irelend; irel++, p += 12)
    {
      asection *targetsec;

      /* We are going to write a four byte longword into the runtime
	 reloc section.  The longword will be the address in the data
	 section which must be relocated.  It is followed by the name
	 of the target section NUL-padded or truncated to 8
	 characters.  */

      /* We can only relocate absolute longword relocs at run time.  */
      if ((ELF32_R_TYPE (irel->r_info) != (int) R_MIPS_32) &&
	  (ELF32_R_TYPE (irel->r_info) != (int) R_MIPS_64))
	{
	  *errmsg = _("unsupported reloc type");
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}
      /* Get the target section referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
          Elf_Internal_Sym *isym;

          /* A local symbol.  */
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  targetsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info);
	  h = elf_sym_hashes (abfd)[indx];
	  targetsec = NULL;
	  /*
	     For some reason, in certain programs, the symbol will
	     not be in the hash table.  It seems to happen when you
	     declare a static table of pointers to const external structures.
	     In this case, the relocs are relative to data, not
	     text, so just treating it like an undefined link
	     should be sufficient.  */
	  BFD_ASSERT(h != NULL);
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    targetsec = h->root.u.def.section;
	}


      /*
         Set the low bit of the relocation offset if it's a MIPS64 reloc.
         Relocations will always be on (at least) 32-bit boundaries.  */

      bfd_put_32 (abfd, ((irel->r_offset + datasec->output_offset) +
		  ((ELF32_R_TYPE (irel->r_info) == (int) R_MIPS_64) ? 1 : 0)),
		  p);
      memset (p + 4, 0, 8);
      if (targetsec != NULL)
	strncpy (p + 4, targetsec->output_section->name, 8);
    }

  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  return TRUE;

 error_return:
  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  return FALSE;
}

@


1.173.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
d602 33
d651 17
a667 4
/* 32 bit pc-relative.  This was a GNU extension used by embedded-PIC.
   It was co-opted by mips-linux for exception-handling data.  It is no
   longer used, but should continue to be supported by the linker for
   backward compatibility.  (GCC stopped using it in May, 2004.)  */
d882 1
a882 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1014 1
a1014 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1137 4
d1143 2
d1166 4
d1172 2
d1270 1
a1270 1
  unsigned int size;
d1286 1
a1286 1
	size = 180;
d1293 1
a1293 1
					  size, note->descpos + offset);
d1338 133
@


1.172
log
@bfd/
	* elf32-mips.c (elf_mips_howto_table_rel): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.  Use
	_bfd_mips_elf_hi16_reloc for R_MIPS_HI16 and R_MIPS_GNU_REL_HI16,
	_bfd_mips_elf_lo16_reloc for R_MIPS_LO16 and R_MIPS_GNU_REL_LO16,
	and _bfd_mips_elf_got16_reloc for R_MIPS_GOT16.  Change rightshift
	to 16 for R_MIPS_HI16 and R_MIPS_GNU_REL_HI16.
	(mips_elf_generic_reloc, struct mips_hi16, mips_elf_hi16_reloc)
	(mips_elf_lo16_reloc, mips_elf_got16_reloc): Delete.
	(_bfd_mips_elf32_gprel16_reloc): Remove special case.
	(mips_elf_gprel32_reloc, mips32_64bit_reloc): Likewise.

	* elf64-mips.c (mips_elf64_howto_table_rel): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.  Use
	_bfd_mips_elf_hi16_reloc for R_MIPS_HI16, _bfd_mips_elf_lo16_reloc
	for R_MIPS_LO16 and _bfd_mips_elf_got16_reloc for R_MIPS_GOT16.
	Change R_MIPS_HI16's rightshift to 16.
	(mips_elf64_howto_table_rela): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.
	Use _bfd_mips_elf_generic_reloc for R_MIPS_GOT16 as well.
	(mips_elf64_hi16_reloc, mips_elf64_got16_reloc): Delete.
	(mips_elf64_shift6_reloc): Remove special case.  Use
	_bfd_mips_elf_generic_reloc instead of returning bfd_reloc_continue.

	* elfn32-mips.c (prev_reloc_section): Delete.
	(prev_reloc_address, prev_reloc_addend): Delete.
	(elf_mips_howto_table_rel, elf_mips_howto_table_rela): As for
	elf64-mips.c
	(GET_RELOC_ADDEND, SET_RELOC_ADDEND): Delete.
	(mips_elf_generic_reloc, struct mips_hi16, mips_elf_hi16_reloc)
	(mips_elf_lo16_reloc, mips_elf_got16_reloc): Delete.
	(mips_elf_gprel16_reloc): Delete use of GET_RELOC_ADDEND.
	(mips_elf_literal_reloc, mips_elf_gprel32_reloc): Likewise.
	(mips16_jump_reloc, mips16_gprel_reloc): Likewise.
	(mips_elf_shift6_reloc): Likewise.  Delete use of SET_RELOC_ADDEND.

	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp): Use
	_bfd_relocate_contents to install an in-place addend.
	(mips_hi16): New structure.
	(mips_hi16_list): Moved from elf32-mips.c.
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_got16_reloc): New functions.
	(_bfd_mips_elf_lo16_reloc, _bfd_mips_elf_generic_reloc): New functions.
	(mips_elf_calculate_relocation): Assume addend is unshifted.
	(_bfd_mips_elf_relocate_section): Don't apply the howto rightshift
	on top of the usual high-part shift.  Don't shift the addend right
	before calling mips_elf_calculate_relocation.

	* elfxx-mips.h (_bfd_mips_elf_hi16_reloc): Declare.
	(_bfd_mips_elf_got16_reloc, _bfd_mips_elf_lo16_reloc): Declare.
	(_bfd_mips_elf_generic_reloc): Declare.

gas/
	* config/tc-mips.c (mips_need_elf_addend_fixup): Delete.
	(md_apply_fix3): Remove bfd_install_relocation workarounds.
	(tc_gen_reloc): Likewise. Factor handling of pc-relative relocations
	and treat fx_addnumber as relative to the relocation address.

gas/testsuite/
	* gas/mips/mips16-jalx.d: Use -mabi=o64.
	* gas/mips/mips16.d: Likewise.
	* gas/mips/elf-rel17.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@a1515 4
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.  */
#define ELF_MAXPAGESIZE			0x1000

d1593 4
a1599 2
#define INCLUDED_TARGET_FILE            /* More a type of flag.  */

d1605 2
d1611 5
@


1.171
log
@	* elf32-mips.c, elfn32-mips.c, elf64-mips.c: Convert prototypes.
	Remove casts that were only needed for K&R compatibility.
@
text
@a49 8
static bfd_reloc_status_type mips_elf_generic_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips_elf_hi16_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips_elf_lo16_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips_elf_got16_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d115 1
a115 1
	 mips_elf_generic_reloc, /* special_function */
d130 1
a130 1
	 mips_elf_generic_reloc, /* special_function */
d145 1
a145 1
	 mips_elf_generic_reloc, /* special_function */
d160 1
a160 1
	 mips_elf_generic_reloc, /* special_function */
d178 1
a178 1
	 mips_elf_generic_reloc, /* special_function */
d187 1
a187 1
	 0,			/* rightshift */
d193 1
a193 1
	 mips_elf_hi16_reloc,	/* special_function */
d208 1
a208 1
	 mips_elf_lo16_reloc,	/* special_function */
d253 1
a253 1
	 mips_elf_got16_reloc,	/* special_function */
d268 1
a268 1
	 mips_elf_generic_reloc, /* special_function */
d283 1
a283 1
	 mips_elf_generic_reloc, /* special_function */
d319 1
a319 1
	 mips_elf_generic_reloc, /* special_function */
d336 1
a336 1
	 mips_elf_generic_reloc, /* special_function */
d366 1
a366 1
	 mips_elf_generic_reloc, /* special_function */
d381 1
a381 1
	 mips_elf_generic_reloc, /* special_function */
d396 1
a396 1
	 mips_elf_generic_reloc, /* special_function */
d411 1
a411 1
	 mips_elf_generic_reloc, /* special_function */
d426 1
a426 1
	 mips_elf_generic_reloc, /* special_function */
d441 1
a441 1
	 mips_elf_generic_reloc, /* special_function */
d461 1
a461 1
	 mips_elf_generic_reloc, /* special_function */
d476 1
a476 1
	 mips_elf_generic_reloc, /* special_function */
d491 1
a491 1
	 mips_elf_generic_reloc, /* special_function */
d506 1
a506 1
	 mips_elf_generic_reloc, /* special_function */
d521 1
a521 1
	 mips_elf_generic_reloc, /* special_function */
d542 1
a542 1
	 mips_elf_generic_reloc, /* special_function */
d606 1
a606 1
	 0,			/* rightshift */
d612 1
a612 1
	 mips_elf_hi16_reloc,	/* special_function */
d628 1
a628 1
	 mips_elf_lo16_reloc,	/* special_function */
d644 1
a644 1
	 mips_elf_generic_reloc, /* special_function */
d660 1
a660 1
	 mips_elf_generic_reloc, /* special_function */
d676 1
a676 1
	 mips_elf_generic_reloc, /* special_function */
a714 254
/* We use this instead of bfd_elf_generic_reloc because the latter
   gets the handling of zero addends wrong. */
static bfd_reloc_status_type
mips_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			asymbol *symbol, void *data ATTRIBUTE_UNUSED,
			asection *input_section, bfd *output_bfd,
			char **error_message ATTRIBUTE_UNUSED)
{
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Just go on, nothing to see here.  */
  return bfd_reloc_continue;
}

/* Do a R_MIPS_HI16 relocation.  This has to be done in combination
   with a R_MIPS_LO16 reloc, because there is a carry from the LO16 to
   the HI16.  Here we just save the information we need; we do the
   actual relocation when we see the LO16.

   MIPS ELF requires that the LO16 immediately follow the HI16.  As a
   GNU extension, for non-pc-relative relocations, we permit an
   arbitrary number of HI16 relocs to be associated with a single LO16
   reloc.  This extension permits gcc to output the HI and LO relocs
   itself.

   This cannot be done for PC-relative relocations because both the HI16
   and LO16 parts of the relocations must be done relative to the LO16
   part, and there can be carry to or borrow from the HI16 part.  */

struct mips_hi16
{
  struct mips_hi16 *next;
  bfd_byte *addr;
  bfd_vma addend;
};

/* FIXME: This should not be a static variable.  */

static struct mips_hi16 *mips_hi16_list;

static bfd_reloc_status_type
mips_elf_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		     asymbol *symbol, void *data, asection *input_section,
		     bfd *output_bfd, char **error_message)
{
  bfd_reloc_status_type ret;
  bfd_vma relocation;
  struct mips_hi16 *n;

  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  ret = bfd_reloc_ok;

  if (strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
    {
      bfd_boolean relocatable;
      bfd_vma gp;

      if (ret == bfd_reloc_undefined)
	abort ();

      if (output_bfd != NULL)
	relocatable = TRUE;
      else
	{
	  relocatable = FALSE;
	  output_bfd = symbol->section->output_section->owner;
	}

      ret = mips_elf_final_gp (output_bfd, symbol, relocatable,
			       error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;

      relocation = gp - reloc_entry->address;
    }
  else
    {
      if (bfd_is_und_section (symbol->section) && output_bfd == NULL)
	ret = bfd_reloc_undefined;

      if (bfd_is_com_section (symbol->section))
	relocation = 0;
      else
	relocation = symbol->value;
    }

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Save the information, and let LO16 do the actual relocation.  */
  n = bfd_malloc (sizeof *n);
  if (n == NULL)
    return bfd_reloc_outofrange;
  n->addr = (bfd_byte *) data + reloc_entry->address;
  n->addend = relocation;
  n->next = mips_hi16_list;
  mips_hi16_list = n;

  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;

  return ret;
}

/* Do a R_MIPS_LO16 relocation.  This is a straightforward 16 bit
   inplace relocation; this function exists in order to do the
   R_MIPS_HI16 relocation described above.  */

static bfd_reloc_status_type
mips_elf_lo16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		     void *data, asection *input_section, bfd *output_bfd,
		     char **error_message)
{
  arelent gp_disp_relent;

  if (mips_hi16_list != NULL)
    {
      struct mips_hi16 *l;

      l = mips_hi16_list;
      while (l != NULL)
	{
	  unsigned long insn;
	  unsigned long val;
	  unsigned long vallo;
	  struct mips_hi16 *next;

	  if (strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
	    {
	      gp_disp_relent = *reloc_entry;
	      reloc_entry = &gp_disp_relent;
	      reloc_entry->addend = l->addend;
	    }
	  else
	    {
	      /* Do the HI16 relocation.  Note that we actually don't need
		 to know anything about the LO16 itself, except where to
		 find the low 16 bits of the addend needed by the LO16.  */
	      insn = bfd_get_32 (abfd, l->addr);
	      vallo = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
	      /* The low order 16 bits are always treated as a signed
		 value.  */
	      vallo = ((vallo & 0xffff) ^ 0x8000) - 0x8000;
	      val = ((insn & 0xffff) << 16) + vallo;
	      val += l->addend;

	      /* If PC-relative, we need to subtract out the address of the LO
		 half of the HI/LO.  (The actual relocation is relative
		 to that instruction.)  */
	      if (reloc_entry->howto->pc_relative)
		val -= reloc_entry->address;

	      /* At this point, "val" has the value of the combined HI/LO
		 pair.  If the low order 16 bits (which will be used for
		 the LO16 insn) are negative, then we will need an
		 adjustment for the high order 16 bits.  */
	      val += 0x8000;
	      val = (val >> 16) & 0xffff;

	      insn &= ~ (bfd_vma) 0xffff;
	      insn |= val;
	      bfd_put_32 (abfd, insn, l->addr);
	    }

	  next = l->next;
	  free (l);
	  l = next;
	}

      mips_hi16_list = NULL;
    }
  else if (strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
    {
      bfd_reloc_status_type ret;
      bfd_vma gp, relocation;

      /* FIXME: Does this case ever occur?  */

      ret = mips_elf_final_gp (output_bfd, symbol, TRUE, error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;

      relocation = gp - reloc_entry->address;
      relocation += symbol->section->output_section->vma;
      relocation += symbol->section->output_offset;
      relocation += reloc_entry->addend;

      if (reloc_entry->address > input_section->_cooked_size)
	return bfd_reloc_outofrange;

      gp_disp_relent = *reloc_entry;
      reloc_entry = &gp_disp_relent;
      reloc_entry->addend = relocation - 4;
    }

  /* Now do the LO16 reloc in the usual way.  */
  return mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				 input_section, output_bfd, error_message);
}

/* Do a R_MIPS_GOT16 reloc.  This is a reloc against the global offset
   table used for PIC code.  If the symbol is an external symbol, the
   instruction is modified to contain the offset of the appropriate
   entry in the global offset table.  If the symbol is a section
   symbol, the next reloc is a R_MIPS_LO16 reloc.  The two 16 bit
   addends are combined to form the real addend against the section
   symbol; the GOT16 is modified to contain the offset of an entry in
   the global offset table, and the LO16 is modified to offset it
   appropriately.  Thus an offset larger than 16 bits requires a
   modified value in the global offset table.

   This implementation suffices for the assembler, but the linker does
   not yet know how to create global offset tables.  */

static bfd_reloc_status_type
mips_elf_got16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		      void *data, asection *input_section, bfd *output_bfd,
		      char **error_message)
{
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  return mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
			      input_section, output_bfd, error_message);
}

a818 10
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

a848 11
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      *error_message = (char *)
	_("32bits gp relative relocation occurs for an external symbol");
      return bfd_reloc_outofrange;
    }

d914 4
a917 3
mips32_64bit_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
a922 5

  r = mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
			      input_section, output_bfd, error_message);
  if (r != bfd_reloc_continue)
    return r;
@


1.170
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d51 1
a51 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d53 1
a53 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d55 1
a55 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d57 1
a57 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d59 1
a59 2
  PARAMS ((bfd *, asymbol *, arelent *, asection *, bfd_boolean, PTR,
	   bfd_vma));
d61 1
a61 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d63 1
a63 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d65 1
a65 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d67 1
a67 1
  PARAMS ((unsigned int, bfd_boolean));
d69 1
a69 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d71 1
a71 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d73 1
a73 1
  PARAMS ((bfd *, asymbol *));
d75 1
a75 1
  PARAMS ((bfd *));
d77 1
a77 1
  PARAMS ((bfd *, const char *));
d79 1
a79 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d81 1
a81 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d83 1
a83 1
  PARAMS ((bfd *, asymbol *, bfd_boolean, char **, bfd_vma *));
d85 1
a85 1
  PARAMS ((bfd *, bfd_vma *));
d87 1
a87 1
  PARAMS ((bfd *, Elf_Internal_Note *));
d89 1
a89 1
  PARAMS ((bfd *, Elf_Internal_Note *));
d91 1
a91 1
  PARAMS ((bfd *));
d726 4
a729 9
mips_elf_generic_reloc (abfd, reloc_entry, symbol, data, input_section,
			output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d733 1
a733 1
  if (output_bfd != (bfd *) NULL
d772 3
a774 9
mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d782 1
a782 1
  if (output_bfd != (bfd *) NULL
d817 1
a817 2
      if (bfd_is_und_section (symbol->section)
	  && output_bfd == (bfd *) NULL)
d834 1
a834 1
  n = (struct mips_hi16 *) bfd_malloc ((bfd_size_type) sizeof *n);
d842 1
a842 1
  if (output_bfd != (bfd *) NULL)
d853 3
a855 9
mips_elf_lo16_reloc (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d905 1
a905 1
	      bfd_put_32 (abfd, (bfd_vma) insn, l->addr);
d959 3
a961 9
mips_elf_got16_reloc (abfd, reloc_entry, symbol, data, input_section,
		      output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d965 1
a965 1
  if (output_bfd != (bfd *) NULL
d981 1
a981 3
mips_elf_assign_gp (output_bfd, pgp)
     bfd *output_bfd;
     bfd_vma *pgp;
d997 1
a997 1
  if (sym == (asymbol **) NULL)
d1033 2
a1034 6
mips_elf_final_gp (output_bfd, symbol, relocatable, error_message, pgp)
     bfd *output_bfd;
     asymbol *symbol;
     bfd_boolean relocatable;
     char **error_message;
     bfd_vma *pgp;
d1072 4
a1075 9
_bfd_mips_elf32_gprel16_reloc (abfd, reloc_entry, symbol, data, input_section,
			       output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1083 1
a1083 1
  if (output_bfd != (bfd *) NULL
d1091 1
a1091 1
  if (output_bfd != (bfd *) NULL)
d1113 3
a1115 9
mips_elf_gprel32_reloc (abfd, reloc_entry, symbol, data, input_section,
			output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1123 1
a1123 1
  if (output_bfd != (bfd *) NULL
d1132 1
a1132 1
  if (output_bfd != (bfd *) NULL)
d1150 3
a1152 9
gprel32_with_gp (abfd, symbol, reloc_entry, input_section, relocatable, data,
		 gp)
     bfd *abfd;
     asymbol *symbol;
     arelent *reloc_entry;
     asection *input_section;
     bfd_boolean relocatable;
     PTR data;
     bfd_vma gp;
d1197 3
a1199 9
mips32_64bit_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1228 1
a1228 1
  bfd_put_32 (abfd, (bfd_vma) val, (bfd_byte *) data + addr);
d1236 4
a1239 9
mips16_jump_reloc (abfd, reloc_entry, symbol, data, input_section,
		   output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1241 1
a1241 1
  if (output_bfd != (bfd *) NULL
d1266 3
a1268 9
mips16_gprel_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1335 1
a1335 3
		  (bfd_vma) ((extend & 0xf800)
			     | ((val >> 11) & 0x1f)
			     | (val & 0x7e0)),
d1338 1
a1338 2
		  (bfd_vma) ((insn & 0xffe0)
			     | (val & 0x1f)),
d1388 1
a1388 3
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
d1440 2
a1441 3
mips_elf32_rtype_to_howto (r_type, rela_p)
     unsigned int r_type;
     bfd_boolean rela_p ATTRIBUTE_UNUSED;
d1472 1
a1472 4
mips_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d1492 1
a1492 4
mips_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d1507 1
a1507 3
mips_elf_sym_is_global (abfd, sym)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *sym;
d1520 1
a1520 2
mips_elf32_object_p (abfd)
     bfd *abfd;
d1542 1
a1542 3
mips_elf_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
d1554 1
a1554 3
elf32_mips_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d1584 1
a1584 3
elf32_mips_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d1616 1
a1616 2
elf32_mips_irix_compat (abfd)
     bfd *abfd;
d1633 3
a1635 6
bfd_mips_elf32_create_embedded_relocs (abfd, info, datasec, relsec, errmsg)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *datasec;
     asection *relsec;
     char **errmsg;
d1665 2
a1666 3
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, datasec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
		      info->keep_memory));
d1670 1
a1670 1
  relsec->contents = (bfd_byte *) bfd_alloc (abfd, datasec->reloc_count * 12);
@


1.169
log
@	* elf32-mips.c: Fix addend for _gp_disp special symbol.
@
text
@a1942 1
#define elf_backend_plt_header_size	0
@


1.168
log
@Correct spelling of "relocatable".
@
text
@a889 29
	  /* Do the HI16 relocation.  Note that we actually don't need
	     to know anything about the LO16 itself, except where to
	     find the low 16 bits of the addend needed by the LO16.  */
	  insn = bfd_get_32 (abfd, l->addr);
	  vallo = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

	  /* The low order 16 bits are always treated as a signed
	     value.  */
	  vallo = ((vallo & 0xffff) ^ 0x8000) - 0x8000;
	  val = ((insn & 0xffff) << 16) + vallo;
	  val += l->addend;

	  /* If PC-relative, we need to subtract out the address of the LO
	     half of the HI/LO.  (The actual relocation is relative
	     to that instruction.)  */
	  if (reloc_entry->howto->pc_relative)
	    val -= reloc_entry->address;

	  /* At this point, "val" has the value of the combined HI/LO
	     pair.  If the low order 16 bits (which will be used for
	     the LO16 insn) are negative, then we will need an
	     adjustment for the high order 16 bits.  */
	  val += 0x8000;
	  val = (val >> 16) & 0xffff;

	  insn &= ~ (bfd_vma) 0xffff;
	  insn |= val;
	  bfd_put_32 (abfd, (bfd_vma) insn, l->addr);

d895 30
@


1.167
log
@	* elf32-mips.c (mips_elf_generic_reloc): New Function.
	(elf_mips_howto_table_rel): Use it.
	(gprel32_with_gp): Move prototype.
	(mips_elf_hi16_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Use mips_elf_generic_reloc.
	(mips_elf_got16_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Code cleanup.
	(_bfd_mips_elf32_gprel16_reloc): Check for ! BSF_LOCAL instead of
	zero addend.
	(mips_elf_gprel32_reloc): Likewise. Use the same GP assignment logic
	as in the other *_gprel*_reloc functions.
	(gprel32_with_gp): Handle partial_inplace properly.
	(mips32_64bit_reloc): Use mips_elf_generic_reloc.
	(mips16_gprel_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Do addend handling directly instead of calling
	_bfd_mips_elf_gprel16_with_gp. Handle partial_inplace properly.
	* elf64-mips.c (mips_elf64_hi16_reloc): Check for ! BSF_LOCAL instead
	of zero addend. Handle partial_inplace properly.
	(mips_elf64_got16_reloc): Check for ! BSF_LOCAL instead of zero
	addend.
	(mips_elf64_gprel16_reloc): Likewise.
	(mips_elf64_literal_reloc): Likewise.
	(mips_elf64_gprel32_reloc): Likewise. Use the same GP assignment
	logic as in the other *_gprel*_reloc functions. Handle
	partial_inplace properly.
	(mips_elf64_shift6_reloc): Check for ! BSF_LOCAL instead of zero
	addend. Handle partial_inplace properly.
	(mips16_gprel_reloc): Likewise. Do addend handling directly instead
	of calling _bfd_mips_elf_gprel16_with_gp.
	* elfn32-mips.c (mips_elf_got16_reloc): Check for BSF_LOCAL.
	(mips_elf_gprel32_reloc): Check for ! BSF_LOCAL instead
	of zero addend.
	(mips_elf_shift6_reloc): Handle partial_inplace properly.
	(mips16_gprel_reloc): Likewise. Do addend handling directly instead
	of calling _bfd_mips_elf_gprel16_with_gp.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp): Handle
	partial_inplace properly. Fix wrong addend handling. Fix overflow
	check.
	(_bfd_mips_elf_sign_extend): Renamed from mips_elf_sign_extend and
	exported.
	(mips_elf_calculate_relocation): Use _bfd_mips_elf_sign_extend.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_create_dynamic_relocation): Update sec_info_type access.
	* elfxx-mips.h (_bfd_mips_relax_section): Fix prototype declaration.
	(_bfd_mips_elf_sign_extend): New prototype.
	* config/tc-mips.c (md_pcrel_from): Return actual pcrel address.
	(md_apply_fix3): Ignore non-special relocations. Remove superfluous
	exceptions from size assert. Remove most of the addend fixup
	specialcasing. Remove value, use valP directly. simplify fx_addnumber
	handling. Remove zero addend specialcases.
	(tc_gen_reloc): Use appropriate value for reloc2 addend. Remove
	the addend fixup specialcase.
	* config/tc-mips.h (MD_APPLY_SYM_VALUE): Define as 0.
@
text
@d806 1
a806 1
      bfd_boolean relocateable;
d813 1
a813 1
	relocateable = TRUE;
d816 1
a816 1
	  relocateable = FALSE;
d820 1
a820 1
      ret = mips_elf_final_gp (output_bfd, symbol, relocateable,
d1056 1
a1056 1
   external symbol if we are producing relocateable output.  */
d1059 1
a1059 1
mips_elf_final_gp (output_bfd, symbol, relocateable, error_message, pgp)
d1062 1
a1062 1
     bfd_boolean relocateable;
d1067 1
a1067 1
      && ! relocateable)
d1075 1
a1075 1
      && (! relocateable
d1078 1
a1078 1
      if (relocateable)
d1112 1
a1112 1
  bfd_boolean relocateable;
d1127 1
a1127 1
    relocateable = TRUE;
d1130 1
a1130 1
      relocateable = FALSE;
d1134 1
a1134 1
  ret = mips_elf_final_gp (output_bfd, symbol, relocateable, error_message,
d1140 1
a1140 1
					input_section, relocateable,
d1158 1
a1158 1
  bfd_boolean relocateable;
d1174 1
a1174 1
    relocateable = TRUE;
d1177 1
a1177 1
      relocateable = FALSE;
d1181 1
a1181 1
  ret = mips_elf_final_gp (output_bfd, symbol, relocateable,
d1187 1
a1187 1
			  relocateable, data, gp);
d1191 1
a1191 1
gprel32_with_gp (abfd, symbol, reloc_entry, input_section, relocateable, data,
d1197 1
a1197 1
     bfd_boolean relocateable;
d1222 1
a1222 1
     are producing relocateable output, we don't want to do this for
d1224 1
a1224 1
  if (! relocateable
d1233 1
a1233 1
  if (relocateable)
d1334 1
a1334 1
  bfd_boolean relocateable;
d1353 1
a1353 1
    relocateable = TRUE;
d1356 1
a1356 1
      relocateable = FALSE;
d1360 1
a1360 1
  ret = mips_elf_final_gp (output_bfd, symbol, relocateable, error_message,
d1390 1
a1390 1
     are producing relocateable output, we don't want to do this for
d1392 1
a1392 1
  if (! relocateable
d1411 1
a1411 1
  if (relocateable)
d1732 1
a1732 1
  BFD_ASSERT (! info->relocateable);
@


1.166
log
@	* elf32-mips.c (gprel32_with_gp): Remove useless N64 ABI case.
@
text
@d50 2
d58 3
d124 1
a124 1
	 bfd_elf_generic_reloc,	/* special_function */
d139 1
a139 1
	 bfd_elf_generic_reloc,	/* special_function */
d154 1
a154 1
	 bfd_elf_generic_reloc,	/* special_function */
d169 1
a169 1
	 bfd_elf_generic_reloc,	/* special_function */
d187 1
a187 1
	 bfd_elf_generic_reloc,	/* special_function */
d277 1
a277 1
	 bfd_elf_generic_reloc,	/* special_function */
d292 1
a292 1
	 bfd_elf_generic_reloc,	/* special_function */
d328 1
a328 1
	 bfd_elf_generic_reloc,	/* special_function */
d345 1
a345 1
	 bfd_elf_generic_reloc,	/* special_function */
d375 1
a375 1
	 bfd_elf_generic_reloc,	/* special_function */
d390 1
a390 1
	 bfd_elf_generic_reloc,	/* special_function */
d405 1
a405 1
	 bfd_elf_generic_reloc,	/* special_function */
d420 1
a420 1
	 bfd_elf_generic_reloc,	/* special_function */
d435 1
a435 1
	 bfd_elf_generic_reloc,	/* special_function */
d450 1
a450 1
	 bfd_elf_generic_reloc,	/* special_function */
d470 1
a470 1
	 bfd_elf_generic_reloc,	/* special_function */
d485 1
a485 1
	 bfd_elf_generic_reloc,	/* special_function */
d500 1
a500 1
	 bfd_elf_generic_reloc,	/* special_function */
d515 1
a515 1
	 bfd_elf_generic_reloc,	/* special_function */
d530 1
a530 1
	 bfd_elf_generic_reloc,	/* special_function */
d551 1
a551 1
	 bfd_elf_generic_reloc,	/* special_function */
d653 1
a653 1
	 bfd_elf_generic_reloc,	/* special_function */
d669 1
a669 1
	 bfd_elf_generic_reloc,	/* special_function */
d685 1
a685 1
	 bfd_elf_generic_reloc,	/* special_function */
d724 27
d796 1
a796 1
      && reloc_entry->addend == 0)
d958 2
a959 2
  return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
d991 1
a991 1
      && reloc_entry->addend == 0)
d997 2
a998 8
  /* If we're relocating, and this is a local symbol, we can handle it
     just like HI16.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) != 0)
    return mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);

  abort ();
d1116 2
a1117 4
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
d1120 1
a1120 1
      && reloc_entry->addend == 0)
a1146 4
static bfd_reloc_status_type gprel32_with_gp
  PARAMS ((bfd *, asymbol *, arelent *, asection *, bfd_boolean, PTR,
	   bfd_vma));

d1162 2
a1163 4
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
d1166 1
a1166 1
      && reloc_entry->addend == 0)
d1174 1
a1174 4
    {
      relocateable = TRUE;
      gp = _bfd_get_gp_value (output_bfd);
    }
d1179 1
d1181 4
a1184 5
      ret = mips_elf_final_gp (output_bfd, symbol, relocateable,
			       error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;
    }
d1202 1
a1202 1
  unsigned long val;
d1215 2
a1216 1
  val = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1218 2
a1219 2
  /* Set val to the offset into the section or symbol.  */
  val += reloc_entry->addend;
d1228 4
a1231 1
  bfd_put_32 (abfd, (bfd_vma) val, (bfd_byte *) data + reloc_entry->address);
d1259 2
a1260 2
  r = bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
			     input_section, output_bfd, error_message);
d1337 4
a1340 2
  unsigned short extend, insn;
  unsigned long final;
d1342 2
a1343 4
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
d1346 1
a1346 1
      && reloc_entry->addend == 0)
d1368 4
a1371 25
  /* Pick up the mips16 extend instruction and the real instruction.  */
  extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);

  /* Stuff the current addend back as a 32 bit value, do the usual
     relocation, and then clean up.  */
  bfd_put_32 (abfd,
	      (bfd_vma) (((extend & 0x1f) << 11)
			 | (extend & 0x7e0)
			 | (insn & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address);

  ret = _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
				       input_section, relocateable, data, gp);

  final = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((extend & 0xf800)
			 | ((final >> 11) & 0x1f)
			 | (final & 0x7e0)),
	      (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((insn & 0xffe0)
			 | (final & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address + 2);
d1373 44
a1416 1
  return ret;
@


1.165
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d1200 1
a1200 7
  if (reloc_entry->howto->src_mask == 0)
    {
      /* This case arises with the 64-bit MIPS ELF ABI.  */
      val = 0;
    }
  else
    val = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
@


1.164
log
@* elf32-mips.c (bfd_elf32_bfd_reloc_type_lookup): Detect (ctor)
pointer size from ABI, not arch_bits_per_address.
@
text
@d1719 1
a1719 1
  internal_relocs = (_bfd_elf32_link_read_relocs
@


1.164.2.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1200 7
a1206 1
  val = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1719 1
a1719 1
  internal_relocs = (_bfd_elf_link_read_relocs
@


1.163
log
@* Reverted 2003-03-02's patch.
@
text
@d1443 5
a1447 2
	 size of addresses on this architecture.  */
      if (bfd_arch_bits_per_address (abfd) == 32)
a1448 2
      else
	return &elf_mips_ctor64_howto;
@


1.163.8.1
log
@Merge with mainline.
@
text
@d1443 4
a1446 3
	 size of addresses of the ABI.  */
      if ((elf_elfheader (abfd)->e_flags & (E_MIPS_ABI_O64
					    | E_MIPS_ABI_EABI64)) != 0)
a1447 2
      else
	return &howto_table[(int) R_MIPS_32];
@


1.162
log
@	* elf32-mips.c (elf_mips_howto_table_rel): Change definition of
	R_MIPS_PC16 to rightshift 2.
	(elf_reloc_map mips_reloc_map): Map to rightshifted BFD reloc.
	(bfd_elf32_bfd_reloc_type_lookup): Support
	BFD_RELOC_MIPSEMB_16_PCREL_S2.
	* elf64-mips.c (mips_elf64_howto_table_rel): Change definition of
	R_MIPS_PC16 to rightshift 2.
	(mips_elf64_howto_table_rela): Likewise.
	(mips_reloc_map): Map to rightshifted BFD reloc.
	* elfn32-mips.c: The same as in elf64-mips.c.
	* elfxx-mips.c (mips_elf_got_for_ibfd): Typo in comment.
	(mips_elf_calculate_relocation): Handle rightshifted addends for
	R_MIPS_PC16.
	* reloc.c (BFD_RELOC_MIPSEMB_16_PCREL_S2): New BFD relocation for
	MIPS Embedded PIC. Remove superfluous empty COMMENT.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* config/tc-mips.c (append_insn): Add handling of
	BFD_RELOC_MIPSEMB_16_PCREL_S2. Avoid emitting unneeded
	BFD_RELOC_16_PCREL_S2 relocs and add earlier warnings about
	misaligned address and reange overflow.
	(macro_build): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2. Add
	earlier warnings about misaligned address and reange overflow.
	(mips_ip): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	(md_apply_fix): Likewise. Fix warning output.
	(tc_gen_reloc): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	Allow BFD_RELOC_16_PCREL_S2 for all ABIs.
	(md_convert_frag): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	* gas/mips/bge.d: Reactivate external branch tests.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.d: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.d: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.d: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/branch-misc-2.d: New File.
	* gas/mips/branch-misc-2.l: Remove.
	* gas/mips/mips.exp: Adjust branch-misc-2 test.
@
text
@d264 1
a264 3
  /* 16 bit PC relative reference.  Note that the ABI document has a typo
     and claims R_MIPS_PC16 to be not rightshifted, rendering it useless.
     We do the right thing here.  */
d266 1
a266 1
	 2,			/* rightshift */
d1404 1
a1404 1
  { BFD_RELOC_16_PCREL_S2, R_MIPS_PC16 },
d1461 1
a1461 1
    case BFD_RELOC_MIPSEMB_16_PCREL_S2:
@


1.162.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d264 3
a266 1
  /* 16 bit PC relative reference.  */
d268 1
a268 1
	 0,			/* rightshift */
d1406 1
a1406 1
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
d1463 1
a1463 1
    case BFD_RELOC_16_PCREL_S2:
@


1.161
log
@include/elf/ChangeLog
	* sh.h: Split out various bits to bfd/elf32-sh64.h.

include/opcode/ChangeLog
	* m68hc11.h (cpu6812s): Define.

bfd/ChangeLog
	* elf-bfd.h (struct bfd_elf_section_data): Remove tdata.  Change
	dynindx to an int.  Rearrange for better packing.
	* elf.c (_bfd_elf_new_section_hook): Don't alloc if already done.
	* elf32-mips.c (bfd_elf32_new_section_hook): Define.
	* elf32-sh64.h: New.  Split out from include/elf/sh.h.
	(struct _sh64_elf_section_data): New struct.
	(sh64_elf_section_data): Don't dereference sh64_info (was tdata).
	* elf32-sh64-com.c: Include elf32-sh64.h.
	* elf32-sh64.c: Likewise.
	(sh64_elf_new_section_hook): New function.
	(bfd_elf32_new_section_hook): Define.
	(sh64_elf_fake_sections): Adjust for sh64_elf_section_data change.
	(sh64_bfd_elf_copy_private_section_data): Likewise.
	(sh64_elf_final_write_processing): Likewise.
	* elf32-sparc.c (struct elf32_sparc_section_data): New.
	(elf32_sparc_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(elf32_sparc_relax_section): Adjust to use sec_do_relax.
	(elf32_sparc_relocate_section): Likewise.
	* elf64-mips.c (bfd_elf64_new_section_hook): Define.
	* elf64-mmix.c (struct _mmix_elf_section_data): New.
	(mmix_elf_section_data): Define.  Use throughout file.
	(mmix_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-ppc.c (struct _ppc64_elf_section_data): New.
	(ppc64_elf_section_data): Define.  Use throughout.
	(ppc64_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-sparc.c (struct sparc64_elf_section_data): New.
	(sparc64_elf_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(sparc64_elf_relax_section): Adjust to use sec_do_relax.
	(sparc64_elf_relocate_section): Likewise.
	(bfd_elf64_new_section_hook): Define.
	* elfn32-mips.c (bfd_elf32_new_section_hook): Define.
	* elfxx-mips.c (struct _mips_elf_section_data): New.
	(mips_elf_section_data): Define.  Use throughout.
	(_bfd_mips_elf_new_section_hook): New function.
	(mips_elf_create_got_section): Don't alloc used_by_bfd.
	* elfxx-mips.h (_bfd_mips_elf_new_section_hook): Declare.
	* elfxx-target.h (bfd_elfNN_new_section_hook): Add #ifndef.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

opcodes/ChangeLog
	* sh64-dis.c: Include elf32-sh64.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

gas/ChangeLog
	* config/tc-sh64.c (shmedia_frob_section_type): Adjust for changed
	sh64_elf_section_data.
	* config/tc-sh64.h: Include elf32-sh64.h.
	* config/tc-m68hc11.c: Don't include stdio.h.
	(md_show_usage): Fix missing continuation.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

ld/ChangeLog
	* emultempl/sh64elf.em: Include elf32-sh64.h.
	(sh64_elf_${EMULATION_NAME}_before_allocation): Adjust for changed
	sh64_elf_section_data.
	(sh64_elf_${EMULATION_NAME}_after_allocation): Likewise.
@
text
@d264 3
a266 1
  /* 16 bit PC relative reference.  */
d268 1
a268 1
	 0,			/* rightshift */
d1406 1
a1406 1
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
d1463 1
a1463 1
    case BFD_RELOC_16_PCREL_S2:
@


1.160
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d1920 1
@


1.159
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d63 1
a63 1
  PARAMS ((unsigned int, boolean));
d68 5
a72 3
static boolean mips_elf_sym_is_global PARAMS ((bfd *, asymbol *));
static boolean mips_elf32_object_p PARAMS ((bfd *));
static boolean mips_elf_is_local_label_name
d79 4
a82 3
  PARAMS ((bfd *, asymbol *, boolean, char **, bfd_vma *));
static boolean mips_elf_assign_gp PARAMS ((bfd *, bfd_vma *));
static boolean elf32_mips_grok_prstatus
d84 1
a84 1
static boolean elf32_mips_grok_psinfo
d116 1
a116 1
	 false,			/* pc_relative */
d121 1
a121 1
	 false,			/* partial_inplace */
d124 1
a124 1
	 false),		/* pcrel_offset */
d131 1
a131 1
	 false,			/* pc_relative */
d136 1
a136 1
	 true,			/* partial_inplace */
d139 1
a139 1
	 false),		/* pcrel_offset */
d146 1
a146 1
	 false,			/* pc_relative */
d151 1
a151 1
	 true,			/* partial_inplace */
d154 1
a154 1
	 false),		/* pcrel_offset */
d161 1
a161 1
	 false,			/* pc_relative */
d166 1
a166 1
	 true,			/* partial_inplace */
d169 1
a169 1
	 false),		/* pcrel_offset */
d176 1
a176 1
	 false,			/* pc_relative */
d184 1
a184 1
	 true,			/* partial_inplace */
d187 1
a187 1
	 false),		/* pcrel_offset */
d194 1
a194 1
	 false,			/* pc_relative */
d199 1
a199 1
	 true,			/* partial_inplace */
d202 1
a202 1
	 false),		/* pcrel_offset */
d209 1
a209 1
	 false,			/* pc_relative */
d214 1
a214 1
	 true,			/* partial_inplace */
d217 1
a217 1
	 false),		/* pcrel_offset */
d224 1
a224 1
	 false,			/* pc_relative */
d229 1
a229 1
	 true,			/* partial_inplace */
d232 1
a232 1
	 false),		/* pcrel_offset */
d239 1
a239 1
	 false,			/* pc_relative */
d244 1
a244 1
	 true,			/* partial_inplace */
d247 1
a247 1
	 false),		/* pcrel_offset */
d254 1
a254 1
	 false,			/* pc_relative */
d259 1
a259 1
	 true,			/* partial_inplace */
d262 1
a262 1
	 false),		/* pcrel_offset */
d269 1
a269 1
	 true,			/* pc_relative */
d274 1
a274 1
	 true,			/* partial_inplace */
d277 1
a277 1
	 true),			/* pcrel_offset */
d284 1
a284 1
	 false,			/* pc_relative */
d289 1
a289 1
	 true,			/* partial_inplace */
d292 1
a292 1
	 false),		/* pcrel_offset */
d299 1
a299 1
	 false,			/* pc_relative */
d304 1
a304 1
	 true,			/* partial_inplace */
d307 1
a307 1
	 false),		/* pcrel_offset */
d320 1
a320 1
	 false,			/* pc_relative */
d325 1
a325 1
	 true,			/* partial_inplace */
d328 1
a328 1
	 false),		/* pcrel_offset */
d337 1
a337 1
	 false,			/* pc_relative */
d342 1
a342 1
	 true,			/* partial_inplace */
d345 1
a345 1
	 false),		/* pcrel_offset */
d352 1
a352 1
	 false,			/* pc_relative */
d357 1
a357 1
	 true,			/* partial_inplace */
d360 1
a360 1
	 false),		/* pcrel_offset */
d367 1
a367 1
	 false,			/* pc_relative */
d372 1
a372 1
	 true,			/* partial_inplace */
d375 1
a375 1
	 false),		/* pcrel_offset */
d382 1
a382 1
	 false,			/* pc_relative */
d387 1
a387 1
	 true,			/* partial_inplace */
d390 1
a390 1
	 false),		/* pcrel_offset */
d397 1
a397 1
	 false,			/* pc_relative */
d402 1
a402 1
	 true,			/* partial_inplace */
d405 1
a405 1
	 false),		/* pcrel_offset */
d412 1
a412 1
	 false,			/* pc_relative */
d417 1
a417 1
	 true,			/* partial_inplace */
d420 1
a420 1
	 false),		/* pcrel_offset */
d427 1
a427 1
	 false,			/* pc_relative */
d432 1
a432 1
	 true,			/* partial_inplace */
d435 1
a435 1
	 false),		/* pcrel_offset */
d442 1
a442 1
	 false,			/* pc_relative */
d447 1
a447 1
	 true,			/* partial_inplace */
d450 1
a450 1
	 false),		/* pcrel_offset */
d462 1
a462 1
	 false,			/* pc_relative */
d467 1
a467 1
	 true,			/* partial_inplace */
d470 1
a470 1
	 false),		/* pcrel_offset */
d477 1
a477 1
	 false,			/* pc_relative */
d482 1
a482 1
	 true,			/* partial_inplace */
d485 1
a485 1
	 false),		/* pcrel_offset */
d492 1
a492 1
	 false,			/* pc_relative */
d497 1
a497 1
	 true,			/* partial_inplace */
d500 1
a500 1
	 false),		/* pcrel_offset */
d507 1
a507 1
	 false,			/* pc_relative */
d512 1
a512 1
	 true,			/* partial_inplace */
d515 1
a515 1
	 false),		/* pcrel_offset */
d522 1
a522 1
	 false,			/* pc_relative */
d527 1
a527 1
	 true,			/* partial_inplace */
d530 1
a530 1
	 false),		/* pcrel_offset */
d543 1
a543 1
	 false,			/* pc_relative */
d548 1
a548 1
	 false,			/* partial_inplace */
d551 1
a551 1
	 false),		/* pcrel_offset */
d561 1
a561 1
	 false,			/* pc_relative */
d566 1
a566 1
	 true,			/* partial_inplace */
d569 1
a569 1
	 false);		/* pcrel_offset */
d577 1
a577 1
	 false,			/* pc_relative */
d585 1
a585 1
	 true,			/* partial_inplace */
d588 1
a588 1
	 false);		/* pcrel_offset */
d596 1
a596 1
	 false,			/* pc_relative */
d601 1
a601 1
	 true,			/* partial_inplace */
d604 1
a604 1
	 false);		/* pcrel_offset */
d613 1
a613 1
	 true,			/* pc_relative */
d618 1
a618 1
	 true,			/* partial_inplace */
d621 1
a621 1
	 true);			/* pcrel_offset */
d629 1
a629 1
	 true,			/* pc_relative */
d634 1
a634 1
	 true,			/* partial_inplace */
d637 1
a637 1
	 true);			/* pcrel_offset */
d645 1
a645 1
	 true,			/* pc_relative */
d650 1
a650 1
	 true,			/* partial_inplace */
d653 1
a653 1
	 true);			/* pcrel_offset */
d661 1
a661 1
	 true,			/* pc_relative */
d666 1
a666 1
	 true,			/* partial_inplace */
d669 1
a669 1
	 true);			/* pcrel_offset */
d677 1
a677 1
	 true,			/* pc_relative */
d682 1
a682 1
	 true,			/* partial_inplace */
d685 1
a685 1
	 true);			/* pcrel_offset */
d693 1
a693 1
	 false,			/* pc_relative */
d698 1
a698 1
	 false,			/* partial_inplace */
d701 1
a701 1
	 false);		/* pcrel_offset */
d709 1
a709 1
	 false,			/* pc_relative */
d714 1
a714 1
	 false,			/* partial_inplace */
d717 1
a717 1
	 false);		/* pcrel_offset */
d774 1
a774 1
      boolean relocateable;
d781 1
a781 1
	relocateable = true;
d784 1
a784 1
	  relocateable = false;
d908 1
a908 1
      ret = mips_elf_final_gp (output_bfd, symbol, true, error_message, &gp);
d975 1
a975 1
/* Set the GP value for OUTPUT_BFD.  Returns false if this is a
d978 1
a978 1
static boolean
d990 1
a990 1
    return true;
d1020 1
a1020 1
      return false;
d1023 1
a1023 1
  return true;
d1036 1
a1036 1
     boolean relocateable;
d1086 1
a1086 1
  boolean relocateable;
d1103 1
a1103 1
    relocateable = true;
d1106 1
a1106 1
      relocateable = false;
d1123 3
a1125 3
static bfd_reloc_status_type gprel32_with_gp PARAMS ((bfd *, asymbol *,
						      arelent *, asection *,
						      boolean, PTR, bfd_vma));
d1138 1
a1138 1
  boolean relocateable;
d1157 1
a1157 1
      relocateable = true;
d1162 1
a1162 1
      relocateable = false;
d1182 1
a1182 1
     boolean relocateable;
d1296 1
a1296 1
    static boolean warned;
d1302 1
a1302 1
    warned = true;
d1321 1
a1321 1
  boolean relocateable;
d1340 1
a1340 1
    relocateable = true;
d1343 1
a1343 1
      relocateable = false;
d1475 1
a1475 1
     boolean rela_p ATTRIBUTE_UNUSED;
d1514 1
a1514 1
  cache_ptr->howto = mips_elf32_rtype_to_howto (r_type, false);
d1546 1
a1546 1
static boolean
d1561 1
a1561 1
static boolean
d1571 1
a1571 1
    elf_bad_symtab (abfd) = true;
d1574 1
a1574 1
    return false;
d1579 1
a1579 1
  return true;
d1584 1
a1584 1
static boolean
d1590 1
a1590 1
    return true;
d1598 1
a1598 1
static boolean
d1609 1
a1609 1
	return false;
d1630 1
a1630 1
static boolean
d1638 1
a1638 1
	return false;
d1659 1
a1659 1
  return true;
d1682 1
a1682 1
boolean
d1701 1
a1701 1
    return true;
d1800 1
a1800 1
  return true;
d1809 1
a1809 1
  return false;
d1861 3
a1863 3
#define elf_backend_collect		true
#define elf_backend_type_change_ok	true
#define elf_backend_can_gc_sections	true
d1910 1
a1910 1
#define elf_backend_sign_extend_vma	true
@


1.158
log
@	* elf32-mips.c (mips_reloc_map): Fix typo.
@
text
@d65 1
a65 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
d67 1
a67 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
d1467 1
a1467 1
/* Given a MIPS Elf32_Internal_Rel, fill in an arelent structure.  */
d1500 1
a1500 1
/* Given a MIPS Elf32_Internal_Rel, fill in an arelent structure.  */
d1506 1
a1506 1
     Elf32_Internal_Rel *dst;
d1523 1
a1523 1
/* Given a MIPS Elf32_Internal_Rela, fill in an arelent structure.  */
d1529 1
a1529 1
     Elf32_Internal_Rela *dst;
d1531 1
a1531 4
  /* Since an Elf32_Internal_Rel is an initial prefix of an
     Elf32_Internal_Rela, we can just use mips_info_to_howto_rel
     above.  */
  mips_info_to_howto_rel (abfd, cache_ptr, (Elf32_Internal_Rel *) dst);
d1534 1
a1534 1
     (the field omitted in an Elf32_Internal_Rel) we can do it here.  */
@


1.158.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
a49 2
static bfd_reloc_status_type mips_elf_generic_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d51 1
a51 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d53 1
a53 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d55 1
a55 3
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type gprel32_with_gp
  (bfd *, asymbol *, arelent *, asection *, bfd_boolean, void *, bfd_vma);
d57 1
a57 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d59 1
a59 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d61 1
a61 1
  (bfd *, bfd_reloc_code_real_type);
d63 1
a63 1
  (unsigned int, bfd_boolean);
d65 1
a65 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d67 5
a71 7
  (bfd *, arelent *, Elf_Internal_Rela *);
static bfd_boolean mips_elf_sym_is_global
  (bfd *, asymbol *);
static bfd_boolean mips_elf32_object_p
  (bfd *);
static bfd_boolean mips_elf_is_local_label_name
  (bfd *, const char *);
d73 1
a73 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d75 1
a75 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d77 6
a82 7
  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
static bfd_boolean mips_elf_assign_gp
  (bfd *, bfd_vma *);
static bfd_boolean elf32_mips_grok_prstatus
  (bfd *, Elf_Internal_Note *);
static bfd_boolean elf32_mips_grok_psinfo
  (bfd *, Elf_Internal_Note *);
d84 1
a84 1
  (bfd *);
d113 1
a113 1
	 FALSE,			/* pc_relative */
d116 1
a116 1
	 mips_elf_generic_reloc, /* special_function */
d118 1
a118 1
	 FALSE,			/* partial_inplace */
d121 1
a121 1
	 FALSE),		/* pcrel_offset */
d128 1
a128 1
	 FALSE,			/* pc_relative */
d131 1
a131 1
	 mips_elf_generic_reloc, /* special_function */
d133 1
a133 1
	 TRUE,			/* partial_inplace */
d136 1
a136 1
	 FALSE),		/* pcrel_offset */
d143 1
a143 1
	 FALSE,			/* pc_relative */
d146 1
a146 1
	 mips_elf_generic_reloc, /* special_function */
d148 1
a148 1
	 TRUE,			/* partial_inplace */
d151 1
a151 1
	 FALSE),		/* pcrel_offset */
d158 1
a158 1
	 FALSE,			/* pc_relative */
d161 1
a161 1
	 mips_elf_generic_reloc, /* special_function */
d163 1
a163 1
	 TRUE,			/* partial_inplace */
d166 1
a166 1
	 FALSE),		/* pcrel_offset */
d173 1
a173 1
	 FALSE,			/* pc_relative */
d179 1
a179 1
	 mips_elf_generic_reloc, /* special_function */
d181 1
a181 1
	 TRUE,			/* partial_inplace */
d184 1
a184 1
	 FALSE),		/* pcrel_offset */
d191 1
a191 1
	 FALSE,			/* pc_relative */
d196 1
a196 1
	 TRUE,			/* partial_inplace */
d199 1
a199 1
	 FALSE),		/* pcrel_offset */
d206 1
a206 1
	 FALSE,			/* pc_relative */
d211 1
a211 1
	 TRUE,			/* partial_inplace */
d214 1
a214 1
	 FALSE),		/* pcrel_offset */
d221 1
a221 1
	 FALSE,			/* pc_relative */
d226 1
a226 1
	 TRUE,			/* partial_inplace */
d229 1
a229 1
	 FALSE),		/* pcrel_offset */
d236 1
a236 1
	 FALSE,			/* pc_relative */
d241 1
a241 1
	 TRUE,			/* partial_inplace */
d244 1
a244 1
	 FALSE),		/* pcrel_offset */
d251 1
a251 1
	 FALSE,			/* pc_relative */
d256 1
a256 1
	 TRUE,			/* partial_inplace */
d259 1
a259 1
	 FALSE),		/* pcrel_offset */
d266 1
a266 1
	 TRUE,			/* pc_relative */
d269 1
a269 1
	 mips_elf_generic_reloc, /* special_function */
d271 1
a271 1
	 TRUE,			/* partial_inplace */
d274 1
a274 1
	 TRUE),			/* pcrel_offset */
d281 1
a281 1
	 FALSE,			/* pc_relative */
d284 1
a284 1
	 mips_elf_generic_reloc, /* special_function */
d286 1
a286 1
	 TRUE,			/* partial_inplace */
d289 1
a289 1
	 FALSE),		/* pcrel_offset */
d296 1
a296 1
	 FALSE,			/* pc_relative */
d301 1
a301 1
	 TRUE,			/* partial_inplace */
d304 1
a304 1
	 FALSE),		/* pcrel_offset */
d317 1
a317 1
	 FALSE,			/* pc_relative */
d320 1
a320 1
	 mips_elf_generic_reloc, /* special_function */
d322 1
a322 1
	 TRUE,			/* partial_inplace */
d325 1
a325 1
	 FALSE),		/* pcrel_offset */
d334 1
a334 1
	 FALSE,			/* pc_relative */
d337 1
a337 1
	 mips_elf_generic_reloc, /* special_function */
d339 1
a339 1
	 TRUE,			/* partial_inplace */
d342 1
a342 1
	 FALSE),		/* pcrel_offset */
d349 1
a349 1
	 FALSE,			/* pc_relative */
d354 1
a354 1
	 TRUE,			/* partial_inplace */
d357 1
a357 1
	 FALSE),		/* pcrel_offset */
d364 1
a364 1
	 FALSE,			/* pc_relative */
d367 1
a367 1
	 mips_elf_generic_reloc, /* special_function */
d369 1
a369 1
	 TRUE,			/* partial_inplace */
d372 1
a372 1
	 FALSE),		/* pcrel_offset */
d379 1
a379 1
	 FALSE,			/* pc_relative */
d382 1
a382 1
	 mips_elf_generic_reloc, /* special_function */
d384 1
a384 1
	 TRUE,			/* partial_inplace */
d387 1
a387 1
	 FALSE),		/* pcrel_offset */
d394 1
a394 1
	 FALSE,			/* pc_relative */
d397 1
a397 1
	 mips_elf_generic_reloc, /* special_function */
d399 1
a399 1
	 TRUE,			/* partial_inplace */
d402 1
a402 1
	 FALSE),		/* pcrel_offset */
d409 1
a409 1
	 FALSE,			/* pc_relative */
d412 1
a412 1
	 mips_elf_generic_reloc, /* special_function */
d414 1
a414 1
	 TRUE,			/* partial_inplace */
d417 1
a417 1
	 FALSE),		/* pcrel_offset */
d424 1
a424 1
	 FALSE,			/* pc_relative */
d427 1
a427 1
	 mips_elf_generic_reloc, /* special_function */
d429 1
a429 1
	 TRUE,			/* partial_inplace */
d432 1
a432 1
	 FALSE),		/* pcrel_offset */
d439 1
a439 1
	 FALSE,			/* pc_relative */
d442 1
a442 1
	 mips_elf_generic_reloc, /* special_function */
d444 1
a444 1
	 TRUE,			/* partial_inplace */
d447 1
a447 1
	 FALSE),		/* pcrel_offset */
d459 1
a459 1
	 FALSE,			/* pc_relative */
d462 1
a462 1
	 mips_elf_generic_reloc, /* special_function */
d464 1
a464 1
	 TRUE,			/* partial_inplace */
d467 1
a467 1
	 FALSE),		/* pcrel_offset */
d474 1
a474 1
	 FALSE,			/* pc_relative */
d477 1
a477 1
	 mips_elf_generic_reloc, /* special_function */
d479 1
a479 1
	 TRUE,			/* partial_inplace */
d482 1
a482 1
	 FALSE),		/* pcrel_offset */
d489 1
a489 1
	 FALSE,			/* pc_relative */
d492 1
a492 1
	 mips_elf_generic_reloc, /* special_function */
d494 1
a494 1
	 TRUE,			/* partial_inplace */
d497 1
a497 1
	 FALSE),		/* pcrel_offset */
d504 1
a504 1
	 FALSE,			/* pc_relative */
d507 1
a507 1
	 mips_elf_generic_reloc, /* special_function */
d509 1
a509 1
	 TRUE,			/* partial_inplace */
d512 1
a512 1
	 FALSE),		/* pcrel_offset */
d519 1
a519 1
	 FALSE,			/* pc_relative */
d522 1
a522 1
	 mips_elf_generic_reloc, /* special_function */
d524 1
a524 1
	 TRUE,			/* partial_inplace */
d527 1
a527 1
	 FALSE),		/* pcrel_offset */
d540 1
a540 1
	 FALSE,			/* pc_relative */
d543 1
a543 1
	 mips_elf_generic_reloc, /* special_function */
d545 1
a545 1
	 FALSE,			/* partial_inplace */
d548 1
a548 1
	 FALSE),		/* pcrel_offset */
d558 1
a558 1
	 FALSE,			/* pc_relative */
d563 1
a563 1
	 TRUE,			/* partial_inplace */
d566 1
a566 1
	 FALSE);		/* pcrel_offset */
d574 1
a574 1
	 FALSE,			/* pc_relative */
d582 1
a582 1
	 TRUE,			/* partial_inplace */
d585 1
a585 1
	 FALSE);		/* pcrel_offset */
d593 1
a593 1
	 FALSE,			/* pc_relative */
d598 1
a598 1
	 TRUE,			/* partial_inplace */
d601 1
a601 1
	 FALSE);		/* pcrel_offset */
d610 1
a610 1
	 TRUE,			/* pc_relative */
d615 1
a615 1
	 TRUE,			/* partial_inplace */
d618 1
a618 1
	 TRUE);			/* pcrel_offset */
d626 1
a626 1
	 TRUE,			/* pc_relative */
d631 1
a631 1
	 TRUE,			/* partial_inplace */
d634 1
a634 1
	 TRUE);			/* pcrel_offset */
d642 1
a642 1
	 TRUE,			/* pc_relative */
d645 1
a645 1
	 mips_elf_generic_reloc, /* special_function */
d647 1
a647 1
	 TRUE,			/* partial_inplace */
d650 1
a650 1
	 TRUE);			/* pcrel_offset */
d658 1
a658 1
	 TRUE,			/* pc_relative */
d661 1
a661 1
	 mips_elf_generic_reloc, /* special_function */
d663 1
a663 1
	 TRUE,			/* partial_inplace */
d666 1
a666 1
	 TRUE);			/* pcrel_offset */
d674 1
a674 1
	 TRUE,			/* pc_relative */
d677 1
a677 1
	 mips_elf_generic_reloc, /* special_function */
d679 1
a679 1
	 TRUE,			/* partial_inplace */
d682 1
a682 1
	 TRUE);			/* pcrel_offset */
d690 1
a690 1
	 FALSE,			/* pc_relative */
d695 1
a695 1
	 FALSE,			/* partial_inplace */
d698 1
a698 1
	 FALSE);		/* pcrel_offset */
d706 1
a706 1
	 FALSE,			/* pc_relative */
d711 1
a711 1
	 FALSE,			/* partial_inplace */
d714 1
a714 23
	 FALSE);		/* pcrel_offset */

/* We use this instead of bfd_elf_generic_reloc because the latter
   gets the handling of zero addends wrong. */
static bfd_reloc_status_type
mips_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			asymbol *symbol, void *data ATTRIBUTE_UNUSED,
			asection *input_section, bfd *output_bfd,
			char **error_message ATTRIBUTE_UNUSED)
{
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Just go on, nothing to see here.  */
  return bfd_reloc_continue;
}
d743 9
a751 3
mips_elf_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		     asymbol *symbol, void *data, asection *input_section,
		     bfd *output_bfd, char **error_message)
d759 1
a759 1
  if (output_bfd != NULL
d761 1
a761 1
      && (symbol->flags & BSF_LOCAL) != 0)
d771 1
a771 1
      bfd_boolean relocatable;
d778 1
a778 1
	relocatable = TRUE;
d781 1
a781 1
	  relocatable = FALSE;
d785 1
a785 1
      ret = mips_elf_final_gp (output_bfd, symbol, relocatable,
d794 2
a795 1
      if (bfd_is_und_section (symbol->section) && output_bfd == NULL)
d812 1
a812 1
  n = bfd_malloc (sizeof *n);
d820 1
a820 1
  if (output_bfd != NULL)
d831 9
a839 3
mips_elf_lo16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		     void *data, asection *input_section, bfd *output_bfd,
		     char **error_message)
d855 29
a889 30
	  else
	    {
	      /* Do the HI16 relocation.  Note that we actually don't need
		 to know anything about the LO16 itself, except where to
		 find the low 16 bits of the addend needed by the LO16.  */
	      insn = bfd_get_32 (abfd, l->addr);
	      vallo = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
	      /* The low order 16 bits are always treated as a signed
		 value.  */
	      vallo = ((vallo & 0xffff) ^ 0x8000) - 0x8000;
	      val = ((insn & 0xffff) << 16) + vallo;
	      val += l->addend;

	      /* If PC-relative, we need to subtract out the address of the LO
		 half of the HI/LO.  (The actual relocation is relative
		 to that instruction.)  */
	      if (reloc_entry->howto->pc_relative)
		val -= reloc_entry->address;

	      /* At this point, "val" has the value of the combined HI/LO
		 pair.  If the low order 16 bits (which will be used for
		 the LO16 insn) are negative, then we will need an
		 adjustment for the high order 16 bits.  */
	      val += 0x8000;
	      val = (val >> 16) & 0xffff;

	      insn &= ~ (bfd_vma) 0xffff;
	      insn |= val;
	      bfd_put_32 (abfd, insn, l->addr);
	    }
d905 1
a905 1
      ret = mips_elf_final_gp (output_bfd, symbol, TRUE, error_message, &gp);
d923 2
a924 2
  return mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				 input_section, output_bfd, error_message);
d942 9
a950 3
mips_elf_got16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		      void *data, asection *input_section, bfd *output_bfd,
		      char **error_message)
d954 1
a954 1
  if (output_bfd != NULL
d956 1
a956 1
      && (symbol->flags & BSF_LOCAL) != 0)
d962 8
a969 2
  return mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
			      input_section, output_bfd, error_message);
d972 1
a972 1
/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
d975 4
a978 2
static bfd_boolean
mips_elf_assign_gp (bfd *output_bfd, bfd_vma *pgp)
d987 1
a987 1
    return TRUE;
d994 1
a994 1
  if (sym == NULL)
d1017 1
a1017 1
      return FALSE;
d1020 1
a1020 1
  return TRUE;
d1027 1
a1027 1
   external symbol if we are producing relocatable output.  */
d1030 6
a1035 2
mips_elf_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
		   char **error_message, bfd_vma *pgp)
d1038 1
a1038 1
      && ! relocatable)
d1046 1
a1046 1
      && (! relocatable
d1049 1
a1049 1
      if (relocatable)
d1073 9
a1081 4
_bfd_mips_elf32_gprel16_reloc (bfd *abfd, arelent *reloc_entry,
			       asymbol *symbol, void *data,
			       asection *input_section, bfd *output_bfd,
			       char **error_message)
d1083 1
a1083 1
  bfd_boolean relocatable;
d1087 5
a1091 3
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
d1093 1
a1093 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1099 2
a1100 2
  if (output_bfd != NULL)
    relocatable = TRUE;
d1103 1
a1103 1
      relocatable = FALSE;
d1107 1
a1107 1
  ret = mips_elf_final_gp (output_bfd, symbol, relocatable, error_message,
d1113 1
a1113 1
					input_section, relocatable,
d1120 4
d1125 9
a1133 3
mips_elf_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section, bfd *output_bfd,
			char **error_message)
d1135 1
a1135 1
  bfd_boolean relocatable;
d1139 5
a1143 3
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
d1145 1
a1145 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1152 5
a1156 2
  if (output_bfd != NULL)
    relocatable = TRUE;
d1159 1
a1159 1
      relocatable = FALSE;
d1161 5
a1167 5
  ret = mips_elf_final_gp (output_bfd, symbol, relocatable,
			   error_message, &gp);
  if (ret != bfd_reloc_ok)
    return ret;

d1169 1
a1169 1
			  relocatable, data, gp);
d1173 9
a1181 3
gprel32_with_gp (bfd *abfd, asymbol *symbol, arelent *reloc_entry,
		 asection *input_section, bfd_boolean relocatable,
		 void *data, bfd_vma gp)
d1184 1
a1184 1
  bfd_vma val;
d1197 8
d1206 1
a1206 4
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1209 1
a1209 1
     are producing relocatable output, we don't want to do this for
d1211 1
a1211 1
  if (! relocatable
d1215 1
a1215 4
  if (reloc_entry->howto->partial_inplace)
    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
  else
    reloc_entry->addend = val;
d1217 1
a1217 1
  if (relocatable)
d1228 9
a1236 3
mips32_64bit_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
d1243 2
a1244 2
  r = mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
			      input_section, output_bfd, error_message);
d1265 1
a1265 1
  bfd_put_32 (abfd, val, (bfd_byte *) data + addr);
d1273 9
a1281 4
mips16_jump_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		   asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		   asection *input_section, bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
d1283 1
a1283 1
  if (output_bfd != NULL
d1293 1
a1293 1
    static bfd_boolean warned;
d1299 1
a1299 1
    warned = TRUE;
d1308 9
a1316 3
mips16_gprel_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
d1318 1
a1318 1
  bfd_boolean relocatable;
d1321 2
a1322 4
  unsigned short extend = 0;
  unsigned short insn = 0;
  bfd_signed_vma val;
  bfd_vma relocation;
d1324 4
a1327 2
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
d1330 1
a1330 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1337 1
a1337 1
    relocatable = TRUE;
d1340 1
a1340 1
      relocatable = FALSE;
d1344 1
a1344 1
  ret = mips_elf_final_gp (output_bfd, symbol, relocatable, error_message,
d1352 25
a1376 4
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;
d1378 1
a1378 41
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    {
      /* Pick up the mips16 extend instruction and the real instruction.  */
      extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
      insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);
      val += ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
    }

  _bfd_mips_elf_sign_extend(val, 16);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    {
      bfd_put_16 (abfd,
		  (extend & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0),
		  (bfd_byte *) data + reloc_entry->address);
      bfd_put_16 (abfd,
		  (insn & 0xffe0) | (val & 0x1f),
		  (bfd_byte *) data + reloc_entry->address + 2);
    }
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
d1417 3
a1419 1
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
d1440 4
a1443 3
	 size of addresses of the ABI.  */
      if ((elf_elfheader (abfd)->e_flags & (E_MIPS_ABI_O64
					    | E_MIPS_ABI_EABI64)) != 0)
a1444 2
      else
	return &howto_table[(int) R_MIPS_32];
d1467 1
a1467 1
/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */
d1470 3
a1472 2
mips_elf32_rtype_to_howto (unsigned int r_type,
			   bfd_boolean rela_p ATTRIBUTE_UNUSED)
d1500 1
a1500 1
/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */
d1503 4
a1506 1
mips_info_to_howto_rel (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
d1511 1
a1511 1
  cache_ptr->howto = mips_elf32_rtype_to_howto (r_type, FALSE);
d1523 1
a1523 1
/* Given a MIPS Elf_Internal_Rela, fill in an arelent structure.  */
d1526 9
a1534 3
mips_info_to_howto_rela (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  mips_info_to_howto_rel (abfd, cache_ptr, dst);
d1537 1
a1537 1
     (the field omitted in an Elf_Internal_Rel) we can do it here.  */
d1546 4
a1549 2
static bfd_boolean
mips_elf_sym_is_global (bfd *abfd ATTRIBUTE_UNUSED, asymbol *sym)
d1561 3
a1563 2
static bfd_boolean
mips_elf32_object_p (bfd *abfd)
d1571 1
a1571 1
    elf_bad_symtab (abfd) = TRUE;
d1574 1
a1574 1
    return FALSE;
d1579 1
a1579 1
  return TRUE;
d1584 4
a1587 2
static bfd_boolean
mips_elf_is_local_label_name (bfd *abfd, const char *name)
d1590 1
a1590 1
    return TRUE;
d1598 4
a1601 2
static bfd_boolean
elf32_mips_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d1609 1
a1609 1
	return FALSE;
d1630 4
a1633 2
static bfd_boolean
elf32_mips_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d1638 1
a1638 1
	return FALSE;
d1659 1
a1659 1
  return TRUE;
d1665 2
a1666 1
elf32_mips_irix_compat (bfd *abfd)
d1682 7
a1688 4
bfd_boolean
bfd_mips_elf32_create_embedded_relocs (bfd *abfd, struct bfd_link_info *info,
				       asection *datasec, asection *relsec,
				       char **errmsg)
d1696 1
a1696 1
  BFD_ASSERT (! info->relocatable);
d1701 1
a1701 1
    return TRUE;
d1718 3
a1720 2
  internal_relocs = _bfd_elf_link_read_relocs (abfd, datasec, NULL, NULL,
					       info->keep_memory);
d1724 1
a1724 1
  relsec->contents = bfd_alloc (abfd, datasec->reloc_count * 12);
d1800 1
a1800 1
  return TRUE;
d1809 1
a1809 1
  return FALSE;
d1861 3
a1863 3
#define elf_backend_collect		TRUE
#define elf_backend_type_change_ok	TRUE
#define elf_backend_can_gc_sections	TRUE
d1906 1
d1910 1
a1910 1
#define elf_backend_sign_extend_vma	TRUE
a1919 1
#define bfd_elf32_new_section_hook	_bfd_mips_elf_new_section_hook
@


1.158.12.2
log
@Merge from mainline.
@
text
@d50 8
d123 1
a123 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d138 1
a138 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d153 1
a153 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d168 1
a168 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d186 1
a186 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d195 1
a195 1
	 16,			/* rightshift */
d201 1
a201 1
	 _bfd_mips_elf_hi16_reloc, /* special_function */
d216 1
a216 1
	 _bfd_mips_elf_lo16_reloc, /* special_function */
d261 1
a261 1
	 _bfd_mips_elf_got16_reloc, /* special_function */
d276 1
a276 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d291 1
a291 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d327 1
a327 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d344 1
a344 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d374 1
a374 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d389 1
a389 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d404 1
a404 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d419 1
a419 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d434 1
a434 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d449 1
a449 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d469 1
a469 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d484 1
a484 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d499 1
a499 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d514 1
a514 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d529 1
a529 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d550 1
a550 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d614 1
a614 1
	 16,			/* rightshift */
d620 1
a620 1
	 _bfd_mips_elf_hi16_reloc, /* special_function */
d636 1
a636 1
	 _bfd_mips_elf_lo16_reloc, /* special_function */
d652 1
a652 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d668 1
a668 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d684 1
a684 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d723 254
d1081 10
d1121 11
d1197 3
a1199 4
mips32_64bit_reloc (bfd *abfd, arelent *reloc_entry,
		    asymbol *symbol ATTRIBUTE_UNUSED,
		    void *data, asection *input_section,
		    bfd *output_bfd, char **error_message)
d1205 5
@


1.158.12.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d1516 4
a1596 4
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.  */
#define ELF_MAXPAGESIZE			0x1000

d1600 2
a1606 2
#undef ELF_MAXPAGESIZE

a1610 5

/* The SVR4 MIPS ABI says that this should be 0x10000, and Linux uses
   page sizes of up to that limit, so we need to respect it.  */
#define ELF_MAXPAGESIZE			0x10000
#define elf32_bed			elf32_tradbed
@


1.158.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d63 1
a63 1
  PARAMS ((unsigned int, bfd_boolean));
d65 1
a65 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d67 4
a70 6
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean mips_elf_sym_is_global
  PARAMS ((bfd *, asymbol *));
static bfd_boolean mips_elf32_object_p
  PARAMS ((bfd *));
static bfd_boolean mips_elf_is_local_label_name
d77 3
a79 4
  PARAMS ((bfd *, asymbol *, bfd_boolean, char **, bfd_vma *));
static bfd_boolean mips_elf_assign_gp
  PARAMS ((bfd *, bfd_vma *));
static bfd_boolean elf32_mips_grok_prstatus
d81 1
a81 1
static bfd_boolean elf32_mips_grok_psinfo
d113 1
a113 1
	 FALSE,			/* pc_relative */
d118 1
a118 1
	 FALSE,			/* partial_inplace */
d121 1
a121 1
	 FALSE),		/* pcrel_offset */
d128 1
a128 1
	 FALSE,			/* pc_relative */
d133 1
a133 1
	 TRUE,			/* partial_inplace */
d136 1
a136 1
	 FALSE),		/* pcrel_offset */
d143 1
a143 1
	 FALSE,			/* pc_relative */
d148 1
a148 1
	 TRUE,			/* partial_inplace */
d151 1
a151 1
	 FALSE),		/* pcrel_offset */
d158 1
a158 1
	 FALSE,			/* pc_relative */
d163 1
a163 1
	 TRUE,			/* partial_inplace */
d166 1
a166 1
	 FALSE),		/* pcrel_offset */
d173 1
a173 1
	 FALSE,			/* pc_relative */
d181 1
a181 1
	 TRUE,			/* partial_inplace */
d184 1
a184 1
	 FALSE),		/* pcrel_offset */
d191 1
a191 1
	 FALSE,			/* pc_relative */
d196 1
a196 1
	 TRUE,			/* partial_inplace */
d199 1
a199 1
	 FALSE),		/* pcrel_offset */
d206 1
a206 1
	 FALSE,			/* pc_relative */
d211 1
a211 1
	 TRUE,			/* partial_inplace */
d214 1
a214 1
	 FALSE),		/* pcrel_offset */
d221 1
a221 1
	 FALSE,			/* pc_relative */
d226 1
a226 1
	 TRUE,			/* partial_inplace */
d229 1
a229 1
	 FALSE),		/* pcrel_offset */
d236 1
a236 1
	 FALSE,			/* pc_relative */
d241 1
a241 1
	 TRUE,			/* partial_inplace */
d244 1
a244 1
	 FALSE),		/* pcrel_offset */
d251 1
a251 1
	 FALSE,			/* pc_relative */
d256 1
a256 1
	 TRUE,			/* partial_inplace */
d259 1
a259 1
	 FALSE),		/* pcrel_offset */
d266 1
a266 1
	 TRUE,			/* pc_relative */
d271 1
a271 1
	 TRUE,			/* partial_inplace */
d274 1
a274 1
	 TRUE),			/* pcrel_offset */
d281 1
a281 1
	 FALSE,			/* pc_relative */
d286 1
a286 1
	 TRUE,			/* partial_inplace */
d289 1
a289 1
	 FALSE),		/* pcrel_offset */
d296 1
a296 1
	 FALSE,			/* pc_relative */
d301 1
a301 1
	 TRUE,			/* partial_inplace */
d304 1
a304 1
	 FALSE),		/* pcrel_offset */
d317 1
a317 1
	 FALSE,			/* pc_relative */
d322 1
a322 1
	 TRUE,			/* partial_inplace */
d325 1
a325 1
	 FALSE),		/* pcrel_offset */
d334 1
a334 1
	 FALSE,			/* pc_relative */
d339 1
a339 1
	 TRUE,			/* partial_inplace */
d342 1
a342 1
	 FALSE),		/* pcrel_offset */
d349 1
a349 1
	 FALSE,			/* pc_relative */
d354 1
a354 1
	 TRUE,			/* partial_inplace */
d357 1
a357 1
	 FALSE),		/* pcrel_offset */
d364 1
a364 1
	 FALSE,			/* pc_relative */
d369 1
a369 1
	 TRUE,			/* partial_inplace */
d372 1
a372 1
	 FALSE),		/* pcrel_offset */
d379 1
a379 1
	 FALSE,			/* pc_relative */
d384 1
a384 1
	 TRUE,			/* partial_inplace */
d387 1
a387 1
	 FALSE),		/* pcrel_offset */
d394 1
a394 1
	 FALSE,			/* pc_relative */
d399 1
a399 1
	 TRUE,			/* partial_inplace */
d402 1
a402 1
	 FALSE),		/* pcrel_offset */
d409 1
a409 1
	 FALSE,			/* pc_relative */
d414 1
a414 1
	 TRUE,			/* partial_inplace */
d417 1
a417 1
	 FALSE),		/* pcrel_offset */
d424 1
a424 1
	 FALSE,			/* pc_relative */
d429 1
a429 1
	 TRUE,			/* partial_inplace */
d432 1
a432 1
	 FALSE),		/* pcrel_offset */
d439 1
a439 1
	 FALSE,			/* pc_relative */
d444 1
a444 1
	 TRUE,			/* partial_inplace */
d447 1
a447 1
	 FALSE),		/* pcrel_offset */
d459 1
a459 1
	 FALSE,			/* pc_relative */
d464 1
a464 1
	 TRUE,			/* partial_inplace */
d467 1
a467 1
	 FALSE),		/* pcrel_offset */
d474 1
a474 1
	 FALSE,			/* pc_relative */
d479 1
a479 1
	 TRUE,			/* partial_inplace */
d482 1
a482 1
	 FALSE),		/* pcrel_offset */
d489 1
a489 1
	 FALSE,			/* pc_relative */
d494 1
a494 1
	 TRUE,			/* partial_inplace */
d497 1
a497 1
	 FALSE),		/* pcrel_offset */
d504 1
a504 1
	 FALSE,			/* pc_relative */
d509 1
a509 1
	 TRUE,			/* partial_inplace */
d512 1
a512 1
	 FALSE),		/* pcrel_offset */
d519 1
a519 1
	 FALSE,			/* pc_relative */
d524 1
a524 1
	 TRUE,			/* partial_inplace */
d527 1
a527 1
	 FALSE),		/* pcrel_offset */
d540 1
a540 1
	 FALSE,			/* pc_relative */
d545 1
a545 1
	 FALSE,			/* partial_inplace */
d548 1
a548 1
	 FALSE),		/* pcrel_offset */
d558 1
a558 1
	 FALSE,			/* pc_relative */
d563 1
a563 1
	 TRUE,			/* partial_inplace */
d566 1
a566 1
	 FALSE);		/* pcrel_offset */
d574 1
a574 1
	 FALSE,			/* pc_relative */
d582 1
a582 1
	 TRUE,			/* partial_inplace */
d585 1
a585 1
	 FALSE);		/* pcrel_offset */
d593 1
a593 1
	 FALSE,			/* pc_relative */
d598 1
a598 1
	 TRUE,			/* partial_inplace */
d601 1
a601 1
	 FALSE);		/* pcrel_offset */
d610 1
a610 1
	 TRUE,			/* pc_relative */
d615 1
a615 1
	 TRUE,			/* partial_inplace */
d618 1
a618 1
	 TRUE);			/* pcrel_offset */
d626 1
a626 1
	 TRUE,			/* pc_relative */
d631 1
a631 1
	 TRUE,			/* partial_inplace */
d634 1
a634 1
	 TRUE);			/* pcrel_offset */
d642 1
a642 1
	 TRUE,			/* pc_relative */
d647 1
a647 1
	 TRUE,			/* partial_inplace */
d650 1
a650 1
	 TRUE);			/* pcrel_offset */
d658 1
a658 1
	 TRUE,			/* pc_relative */
d663 1
a663 1
	 TRUE,			/* partial_inplace */
d666 1
a666 1
	 TRUE);			/* pcrel_offset */
d674 1
a674 1
	 TRUE,			/* pc_relative */
d679 1
a679 1
	 TRUE,			/* partial_inplace */
d682 1
a682 1
	 TRUE);			/* pcrel_offset */
d690 1
a690 1
	 FALSE,			/* pc_relative */
d695 1
a695 1
	 FALSE,			/* partial_inplace */
d698 1
a698 1
	 FALSE);		/* pcrel_offset */
d706 1
a706 1
	 FALSE,			/* pc_relative */
d711 1
a711 1
	 FALSE,			/* partial_inplace */
d714 1
a714 1
	 FALSE);		/* pcrel_offset */
d771 1
a771 1
      bfd_boolean relocateable;
d778 1
a778 1
	relocateable = TRUE;
d781 1
a781 1
	  relocateable = FALSE;
d905 1
a905 1
      ret = mips_elf_final_gp (output_bfd, symbol, TRUE, error_message, &gp);
d972 1
a972 1
/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
d975 1
a975 1
static bfd_boolean
d987 1
a987 1
    return TRUE;
d1017 1
a1017 1
      return FALSE;
d1020 1
a1020 1
  return TRUE;
d1033 1
a1033 1
     bfd_boolean relocateable;
d1083 1
a1083 1
  bfd_boolean relocateable;
d1100 1
a1100 1
    relocateable = TRUE;
d1103 1
a1103 1
      relocateable = FALSE;
d1120 3
a1122 3
static bfd_reloc_status_type gprel32_with_gp
  PARAMS ((bfd *, asymbol *, arelent *, asection *, bfd_boolean, PTR,
	   bfd_vma));
d1135 1
a1135 1
  bfd_boolean relocateable;
d1154 1
a1154 1
      relocateable = TRUE;
d1159 1
a1159 1
      relocateable = FALSE;
d1179 1
a1179 1
     bfd_boolean relocateable;
d1293 1
a1293 1
    static bfd_boolean warned;
d1299 1
a1299 1
    warned = TRUE;
d1318 1
a1318 1
  bfd_boolean relocateable;
d1337 1
a1337 1
    relocateable = TRUE;
d1340 1
a1340 1
      relocateable = FALSE;
d1467 1
a1467 1
/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */
d1472 1
a1472 1
     bfd_boolean rela_p ATTRIBUTE_UNUSED;
d1500 1
a1500 1
/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */
d1506 1
a1506 1
     Elf_Internal_Rela *dst;
d1511 1
a1511 1
  cache_ptr->howto = mips_elf32_rtype_to_howto (r_type, FALSE);
d1523 1
a1523 1
/* Given a MIPS Elf_Internal_Rela, fill in an arelent structure.  */
d1529 1
a1529 1
     Elf_Internal_Rela *dst;
d1531 4
a1534 1
  mips_info_to_howto_rel (abfd, cache_ptr, dst);
d1537 1
a1537 1
     (the field omitted in an Elf_Internal_Rel) we can do it here.  */
d1546 1
a1546 1
static bfd_boolean
d1561 1
a1561 1
static bfd_boolean
d1571 1
a1571 1
    elf_bad_symtab (abfd) = TRUE;
d1574 1
a1574 1
    return FALSE;
d1579 1
a1579 1
  return TRUE;
d1584 1
a1584 1
static bfd_boolean
d1590 1
a1590 1
    return TRUE;
d1598 1
a1598 1
static bfd_boolean
d1609 1
a1609 1
	return FALSE;
d1630 1
a1630 1
static bfd_boolean
d1638 1
a1638 1
	return FALSE;
d1659 1
a1659 1
  return TRUE;
d1682 1
a1682 1
bfd_boolean
d1701 1
a1701 1
    return TRUE;
d1800 1
a1800 1
  return TRUE;
d1809 1
a1809 1
  return FALSE;
d1861 3
a1863 3
#define elf_backend_collect		TRUE
#define elf_backend_type_change_ok	TRUE
#define elf_backend_can_gc_sections	TRUE
d1910 1
a1910 1
#define elf_backend_sign_extend_vma	TRUE
@


1.158.10.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
a1919 1
#define bfd_elf32_new_section_hook	_bfd_mips_elf_new_section_hook
@


1.158.10.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d264 1
a264 3
  /* 16 bit PC relative reference.  Note that the ABI document has a typo
     and claims R_MIPS_PC16 to be not rightshifted, rendering it useless.
     We do the right thing here.  */
d266 1
a266 1
	 2,			/* rightshift */
d1404 1
a1404 1
  { BFD_RELOC_16_PCREL_S2, R_MIPS_PC16 },
d1461 1
a1461 1
    case BFD_RELOC_MIPSEMB_16_PCREL_S2:
@


1.158.10.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d264 3
a266 1
  /* 16 bit PC relative reference.  */
d268 1
a268 1
	 0,			/* rightshift */
d1406 1
a1406 1
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
d1445 4
a1448 3
	 size of addresses of the ABI.  */
      if ((elf_elfheader (abfd)->e_flags & (E_MIPS_ABI_O64
					    | E_MIPS_ABI_EABI64)) != 0)
a1449 2
      else
	return &howto_table[(int) R_MIPS_32];
d1463 1
a1463 1
    case BFD_RELOC_16_PCREL_S2:
@


1.158.10.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1200 7
a1206 1
  val = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1719 1
a1719 1
  internal_relocs = (_bfd_elf_link_read_relocs
@


1.158.10.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a49 2
static bfd_reloc_status_type mips_elf_generic_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
a55 3
static bfd_reloc_status_type gprel32_with_gp
  PARAMS ((bfd *, asymbol *, arelent *, asection *, bfd_boolean, PTR,
	   bfd_vma));
d119 1
a119 1
	 mips_elf_generic_reloc, /* special_function */
d134 1
a134 1
	 mips_elf_generic_reloc, /* special_function */
d149 1
a149 1
	 mips_elf_generic_reloc, /* special_function */
d164 1
a164 1
	 mips_elf_generic_reloc, /* special_function */
d182 1
a182 1
	 mips_elf_generic_reloc, /* special_function */
d272 1
a272 1
	 mips_elf_generic_reloc, /* special_function */
d287 1
a287 1
	 mips_elf_generic_reloc, /* special_function */
d323 1
a323 1
	 mips_elf_generic_reloc, /* special_function */
d340 1
a340 1
	 mips_elf_generic_reloc, /* special_function */
d370 1
a370 1
	 mips_elf_generic_reloc, /* special_function */
d385 1
a385 1
	 mips_elf_generic_reloc, /* special_function */
d400 1
a400 1
	 mips_elf_generic_reloc, /* special_function */
d415 1
a415 1
	 mips_elf_generic_reloc, /* special_function */
d430 1
a430 1
	 mips_elf_generic_reloc, /* special_function */
d445 1
a445 1
	 mips_elf_generic_reloc, /* special_function */
d465 1
a465 1
	 mips_elf_generic_reloc, /* special_function */
d480 1
a480 1
	 mips_elf_generic_reloc, /* special_function */
d495 1
a495 1
	 mips_elf_generic_reloc, /* special_function */
d510 1
a510 1
	 mips_elf_generic_reloc, /* special_function */
d525 1
a525 1
	 mips_elf_generic_reloc, /* special_function */
d546 1
a546 1
	 mips_elf_generic_reloc, /* special_function */
d648 1
a648 1
	 mips_elf_generic_reloc, /* special_function */
d664 1
a664 1
	 mips_elf_generic_reloc, /* special_function */
d680 1
a680 1
	 mips_elf_generic_reloc, /* special_function */
a718 27
/* We use this instead of bfd_elf_generic_reloc because the latter
   gets the handling of zero addends wrong. */
static bfd_reloc_status_type
mips_elf_generic_reloc (abfd, reloc_entry, symbol, data, input_section,
			output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Just go on, nothing to see here.  */
  return bfd_reloc_continue;
}

d764 1
a764 1
      && (symbol->flags & BSF_LOCAL) != 0)
d774 1
a774 1
      bfd_boolean relocatable;
d781 1
a781 1
	relocatable = TRUE;
d784 1
a784 1
	  relocatable = FALSE;
d788 1
a788 1
      ret = mips_elf_final_gp (output_bfd, symbol, relocatable,
d858 29
a892 30
	  else
	    {
	      /* Do the HI16 relocation.  Note that we actually don't need
		 to know anything about the LO16 itself, except where to
		 find the low 16 bits of the addend needed by the LO16.  */
	      insn = bfd_get_32 (abfd, l->addr);
	      vallo = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
	      /* The low order 16 bits are always treated as a signed
		 value.  */
	      vallo = ((vallo & 0xffff) ^ 0x8000) - 0x8000;
	      val = ((insn & 0xffff) << 16) + vallo;
	      val += l->addend;

	      /* If PC-relative, we need to subtract out the address of the LO
		 half of the HI/LO.  (The actual relocation is relative
		 to that instruction.)  */
	      if (reloc_entry->howto->pc_relative)
		val -= reloc_entry->address;

	      /* At this point, "val" has the value of the combined HI/LO
		 pair.  If the low order 16 bits (which will be used for
		 the LO16 insn) are negative, then we will need an
		 adjustment for the high order 16 bits.  */
	      val += 0x8000;
	      val = (val >> 16) & 0xffff;

	      insn &= ~ (bfd_vma) 0xffff;
	      insn |= val;
	      bfd_put_32 (abfd, (bfd_vma) insn, l->addr);
	    }
d926 2
a927 2
  return mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				 input_section, output_bfd, error_message);
d959 1
a959 1
      && (symbol->flags & BSF_LOCAL) != 0)
d965 8
a972 2
  return mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
			      input_section, output_bfd, error_message);
d1030 1
a1030 1
   external symbol if we are producing relocatable output.  */
d1033 1
a1033 1
mips_elf_final_gp (output_bfd, symbol, relocatable, error_message, pgp)
d1036 1
a1036 1
     bfd_boolean relocatable;
d1041 1
a1041 1
      && ! relocatable)
d1049 1
a1049 1
      && (! relocatable
d1052 1
a1052 1
      if (relocatable)
d1086 1
a1086 1
  bfd_boolean relocatable;
d1090 4
a1093 2
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
d1096 1
a1096 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1103 1
a1103 1
    relocatable = TRUE;
d1106 1
a1106 1
      relocatable = FALSE;
d1110 1
a1110 1
  ret = mips_elf_final_gp (output_bfd, symbol, relocatable, error_message,
d1116 1
a1116 1
					input_section, relocatable,
d1123 4
d1138 1
a1138 1
  bfd_boolean relocatable;
d1142 4
a1145 2
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
d1148 1
a1148 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1156 4
a1159 1
    relocatable = TRUE;
d1162 1
a1162 1
      relocatable = FALSE;
d1164 5
a1170 5
  ret = mips_elf_final_gp (output_bfd, symbol, relocatable,
			   error_message, &gp);
  if (ret != bfd_reloc_ok)
    return ret;

d1172 1
a1172 1
			  relocatable, data, gp);
d1176 1
a1176 1
gprel32_with_gp (abfd, symbol, reloc_entry, input_section, relocatable, data,
d1182 1
a1182 1
     bfd_boolean relocatable;
d1187 1
a1187 1
  bfd_vma val;
d1200 2
d1203 1
a1203 4
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1206 1
a1206 1
     are producing relocatable output, we don't want to do this for
d1208 1
a1208 1
  if (! relocatable
d1212 1
a1212 4
  if (reloc_entry->howto->partial_inplace)
    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
  else
    reloc_entry->addend = val;
d1214 1
a1214 1
  if (relocatable)
d1240 2
a1241 2
  r = mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
			      input_section, output_bfd, error_message);
d1315 1
a1315 1
  bfd_boolean relocatable;
d1318 2
a1319 4
  unsigned short extend = 0;
  unsigned short insn = 0;
  bfd_signed_vma val;
  bfd_vma relocation;
d1321 4
a1324 2
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
d1327 1
a1327 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1334 1
a1334 1
    relocatable = TRUE;
d1337 1
a1337 1
      relocatable = FALSE;
d1341 1
a1341 1
  ret = mips_elf_final_gp (output_bfd, symbol, relocatable, error_message,
d1349 25
a1373 4
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;
d1375 1
a1375 44
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    {
      /* Pick up the mips16 extend instruction and the real instruction.  */
      extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
      insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);
      val += ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
    }

  _bfd_mips_elf_sign_extend(val, 16);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    {
      bfd_put_16 (abfd,
		  (bfd_vma) ((extend & 0xf800)
			     | ((val >> 11) & 0x1f)
			     | (val & 0x7e0)),
		  (bfd_byte *) data + reloc_entry->address);
      bfd_put_16 (abfd,
		  (bfd_vma) ((insn & 0xffe0)
			     | (val & 0x1f)),
		  (bfd_byte *) data + reloc_entry->address + 2);
    }
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
d1691 1
a1691 1
  BFD_ASSERT (! info->relocatable);
@


1.158.10.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1943 1
@


1.158.10.8
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d51 1
a51 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d53 1
a53 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d55 1
a55 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d57 1
a57 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d59 2
a60 1
  (bfd *, asymbol *, arelent *, asection *, bfd_boolean, void *, bfd_vma);
d62 1
a62 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d64 1
a64 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d66 1
a66 1
  (bfd *, bfd_reloc_code_real_type);
d68 1
a68 1
  (unsigned int, bfd_boolean);
d70 1
a70 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d72 1
a72 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d74 1
a74 1
  (bfd *, asymbol *);
d76 1
a76 1
  (bfd *);
d78 1
a78 1
  (bfd *, const char *);
d80 1
a80 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d82 1
a82 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d84 1
a84 1
  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
d86 1
a86 1
  (bfd *, bfd_vma *);
d88 1
a88 1
  (bfd *, Elf_Internal_Note *);
d90 1
a90 1
  (bfd *, Elf_Internal_Note *);
d92 1
a92 1
  (bfd *);
d727 9
a735 4
mips_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			asymbol *symbol, void *data ATTRIBUTE_UNUSED,
			asection *input_section, bfd *output_bfd,
			char **error_message ATTRIBUTE_UNUSED)
d739 1
a739 1
  if (output_bfd != NULL
d778 9
a786 3
mips_elf_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		     asymbol *symbol, void *data, asection *input_section,
		     bfd *output_bfd, char **error_message)
d794 1
a794 1
  if (output_bfd != NULL
d829 2
a830 1
      if (bfd_is_und_section (symbol->section) && output_bfd == NULL)
d847 1
a847 1
  n = bfd_malloc (sizeof *n);
d855 1
a855 1
  if (output_bfd != NULL)
d866 9
a874 3
mips_elf_lo16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		     void *data, asection *input_section, bfd *output_bfd,
		     char **error_message)
d924 1
a924 1
	      bfd_put_32 (abfd, insn, l->addr);
d978 9
a986 3
mips_elf_got16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		      void *data, asection *input_section, bfd *output_bfd,
		      char **error_message)
d990 1
a990 1
  if (output_bfd != NULL
d1006 3
a1008 1
mips_elf_assign_gp (bfd *output_bfd, bfd_vma *pgp)
d1024 1
a1024 1
  if (sym == NULL)
d1060 6
a1065 2
mips_elf_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
		   char **error_message, bfd_vma *pgp)
d1103 9
a1111 4
_bfd_mips_elf32_gprel16_reloc (bfd *abfd, arelent *reloc_entry,
			       asymbol *symbol, void *data,
			       asection *input_section, bfd *output_bfd,
			       char **error_message)
d1119 1
a1119 1
  if (output_bfd != NULL
d1127 1
a1127 1
  if (output_bfd != NULL)
d1149 9
a1157 3
mips_elf_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section, bfd *output_bfd,
			char **error_message)
d1165 1
a1165 1
  if (output_bfd != NULL
d1174 1
a1174 1
  if (output_bfd != NULL)
d1192 9
a1200 3
gprel32_with_gp (bfd *abfd, asymbol *symbol, arelent *reloc_entry,
		 asection *input_section, bfd_boolean relocatable,
		 void *data, bfd_vma gp)
d1245 9
a1253 3
mips32_64bit_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
d1282 1
a1282 1
  bfd_put_32 (abfd, val, (bfd_byte *) data + addr);
d1290 9
a1298 4
mips16_jump_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		   asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		   asection *input_section, bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
d1300 1
a1300 1
  if (output_bfd != NULL
d1325 9
a1333 3
mips16_gprel_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
d1400 3
a1402 1
		  (extend & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0),
d1405 2
a1406 1
		  (insn & 0xffe0) | (val & 0x1f),
d1456 3
a1458 1
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
d1510 3
a1512 2
mips_elf32_rtype_to_howto (unsigned int r_type,
			   bfd_boolean rela_p ATTRIBUTE_UNUSED)
d1543 4
a1546 1
mips_info_to_howto_rel (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
d1566 4
a1569 1
mips_info_to_howto_rela (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
d1584 3
a1586 1
mips_elf_sym_is_global (bfd *abfd ATTRIBUTE_UNUSED, asymbol *sym)
d1599 2
a1600 1
mips_elf32_object_p (bfd *abfd)
d1622 3
a1624 1
mips_elf_is_local_label_name (bfd *abfd, const char *name)
d1636 3
a1638 1
elf32_mips_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d1668 3
a1670 1
elf32_mips_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d1702 2
a1703 1
elf32_mips_irix_compat (bfd *abfd)
d1720 6
a1725 3
bfd_mips_elf32_create_embedded_relocs (bfd *abfd, struct bfd_link_info *info,
				       asection *datasec, asection *relsec,
				       char **errmsg)
d1755 3
a1757 2
  internal_relocs = _bfd_elf_link_read_relocs (abfd, datasec, NULL, NULL,
					       info->keep_memory);
d1761 1
a1761 1
  relsec->contents = bfd_alloc (abfd, datasec->reloc_count * 12);
@


1.158.10.9
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d50 8
d123 1
a123 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d138 1
a138 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d153 1
a153 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d168 1
a168 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d186 1
a186 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d195 1
a195 1
	 16,			/* rightshift */
d201 1
a201 1
	 _bfd_mips_elf_hi16_reloc, /* special_function */
d216 1
a216 1
	 _bfd_mips_elf_lo16_reloc, /* special_function */
d261 1
a261 1
	 _bfd_mips_elf_got16_reloc, /* special_function */
d276 1
a276 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d291 1
a291 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d327 1
a327 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d344 1
a344 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d374 1
a374 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d389 1
a389 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d404 1
a404 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d419 1
a419 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d434 1
a434 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d449 1
a449 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d469 1
a469 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d484 1
a484 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d499 1
a499 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d514 1
a514 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d529 1
a529 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d550 1
a550 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d614 1
a614 1
	 16,			/* rightshift */
d620 1
a620 1
	 _bfd_mips_elf_hi16_reloc, /* special_function */
d636 1
a636 1
	 _bfd_mips_elf_lo16_reloc, /* special_function */
d652 1
a652 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d668 1
a668 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d684 1
a684 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d723 254
d1081 10
d1121 11
d1197 3
a1199 4
mips32_64bit_reloc (bfd *abfd, arelent *reloc_entry,
		    asymbol *symbol ATTRIBUTE_UNUSED,
		    void *data, asection *input_section,
		    bfd *output_bfd, char **error_message)
d1206 5
d1803 4
a1883 4
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.  */
#define ELF_MAXPAGESIZE			0x1000

d1887 2
a1893 2
#undef ELF_MAXPAGESIZE

a1897 5

/* The SVR4 MIPS ABI says that this should be 0x10000, and Linux uses
   page sizes of up to that limit, so we need to respect it.  */
#define ELF_MAXPAGESIZE			0x10000
#define elf32_bed			elf32_tradbed
@


1.157
log
@	* Makefile.am: Add n32 ABI support.
	* Makefile.in: Regenerate.
	* config.bfd: Add n32 vectors to mips64*-*-linux* targets. Treat 64
	bit vectors for mips*-*-linux targets as optional.
	* configure.in: Add n32 ABI vectors.
	* configure: Regenerate.
	* elf32-mips.c (mips_elf32_object_p): Reject n32 ABI files.
	* elfn32-mips.c: New file, n32 ABI support.
	* targets.c: Add n32 ABI vectors.
@
text
@d1390 1
a1390 1
  { BFD_RELOC_NONE, R_MIPS_NONE, },
@


1.156
log
@	* elfxx-mips.c (_bfd_mips_elf_discard_info): New function, code from
	elf32-mips.c.
	(_bfd_mips_elf_write_section): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_discard_info): New prototype.
	(_bfd_mips_elf_write_section): Likewise.
	* elf32-mips.c (elf32_mips_discard_info): Move to elfxx-mips.c.
	(elf32_mips_write_section): Likewise.
	* elf64-mips.c (_bfd_mips_elf_ignore_discarded_relocs): Use it.
	(_bfd_mips_elf_write_section): Likewise.
@
text
@d1573 3
@


1.155
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@a82 4
static boolean elf32_mips_discard_info
  PARAMS ((bfd *, struct elf_reloc_cookie *, struct bfd_link_info *));
static boolean elf32_mips_write_section
  PARAMS ((bfd *, asection *, bfd_byte *));
a1658 97
#define PDR_SIZE 32

static boolean
elf32_mips_discard_info (abfd, cookie, info)
     bfd *abfd;
     struct elf_reloc_cookie *cookie;
     struct bfd_link_info *info;
{
  asection *o;
  boolean ret = false;
  unsigned char *tdata;
  size_t i, skip;

  o = bfd_get_section_by_name (abfd, ".pdr");
  if (! o)
    return false;
  if (o->_raw_size == 0)
    return false;
  if (o->_raw_size % PDR_SIZE != 0)
    return false;
  if (o->output_section != NULL
      && bfd_is_abs_section (o->output_section))
    return false;

  tdata = bfd_zmalloc (o->_raw_size / PDR_SIZE);
  if (! tdata)
    return false;

  cookie->rels = _bfd_elf32_link_read_relocs (abfd, o, (PTR) NULL,
					     (Elf_Internal_Rela *) NULL,
					      info->keep_memory);
  if (!cookie->rels)
    {
      free (tdata);
      return false;
    }

  cookie->rel = cookie->rels;
  cookie->relend = cookie->rels + o->reloc_count;

  for (i = 0, skip = 0; i < o->_raw_size; i ++)
    {
      if (_bfd_elf32_reloc_symbol_deleted_p (i * PDR_SIZE, cookie))
	{
	  tdata[i] = 1;
	  skip ++;
	}
    }

  if (skip != 0)
    {
      elf_section_data (o)->tdata = tdata;
      o->_cooked_size = o->_raw_size - skip * PDR_SIZE;
      ret = true;
    }
  else
    free (tdata);

  if (! info->keep_memory)
    free (cookie->rels);

  return ret;
}

static boolean
elf32_mips_write_section (output_bfd, sec, contents)
     bfd *output_bfd;
     asection *sec;
     bfd_byte *contents;
{
  bfd_byte *to, *from, *end;
  int i;

  if (strcmp (sec->name, ".pdr") != 0)
    return false;

  if (elf_section_data (sec)->tdata == NULL)
    return false;

  to = contents;
  end = contents + sec->_raw_size;
  for (from = contents, i = 0;
       from < end;
       from += PDR_SIZE, i++)
    {
      if (((unsigned char *)elf_section_data (sec)->tdata)[i] == 1)
	continue;
      if (to != from)
	memcpy (to, from, PDR_SIZE);
      to += PDR_SIZE;
    }
  bfd_set_section_contents (output_bfd, sec->output_section, contents,
			    (file_ptr) sec->output_offset,
			    sec->_cooked_size);
  return true;
}

d1909 1
a1909 1
#define elf_backend_discard_info	elf32_mips_discard_info
a1911 1
#define elf_backend_write_section	elf32_mips_write_section
@


1.154
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d1789 2
a1790 6
  Elf_Internal_Shdr *shndx_hdr;
  Elf32_External_Sym *extsyms;
  Elf32_External_Sym *free_extsyms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *free_relocs = NULL;
a1792 1
  bfd_size_type amt;
a1800 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d1803 2
a1804 25
  if (symtab_hdr->contents != NULL)
    extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
  else
    {
      /* Go get them off disk.  */
      if (info->keep_memory)
	extsyms = ((Elf32_External_Sym *)
		   bfd_alloc (abfd, symtab_hdr->sh_size));
      else
	extsyms = ((Elf32_External_Sym *)
		   bfd_malloc (symtab_hdr->sh_size));
      if (extsyms == NULL)
	goto error_return;
      if (! info->keep_memory)
	free_extsyms = extsyms;
      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || (bfd_bread (extsyms, symtab_hdr->sh_size, abfd)
	      != symtab_hdr->sh_size))
	goto error_return;
      if (info->keep_memory)
	symtab_hdr->contents = (unsigned char *) extsyms;
    }

  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (shndx_hdr->sh_size != 0)
d1806 6
a1811 6
      amt = symtab_hdr->sh_info * sizeof (Elf_External_Sym_Shndx);
      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (shndx_buf == NULL)
	goto error_return;
      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
a1820 2
  if (! info->keep_memory)
    free_relocs = internal_relocs;
d1851 1
a1851 3
          Elf32_External_Sym *esym;
          Elf_External_Sym_Shndx *shndx;
          Elf_Internal_Sym isym;
d1854 2
a1855 6
          esym = extsyms + ELF32_R_SYM (irel->r_info);
          shndx = shndx_buf + (shndx_buf ? ELF32_R_SYM (irel->r_info) : 0);
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);

	  targetsec = bfd_section_from_elf_index (abfd, isym.st_shndx);
d1892 6
a1897 6
  if (shndx_buf != NULL)
    free (shndx_buf);
  if (free_extsyms != NULL)
    free (free_extsyms);
  if (free_relocs != NULL)
    free (free_relocs);
d1901 6
a1906 6
  if (shndx_buf != NULL)
    free (shndx_buf);
  if (free_extsyms != NULL)
    free (free_extsyms);
  if (free_relocs != NULL)
    free (free_relocs);
@


1.153
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d1889 2
a1890 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR *) esym,
				    (const PTR *) shndx, &isym);
@


1.152
log
@* elf32-mips.c (elf32_mips_ignore_discarded_relocs): Move to...
elfxx-mips.c (_bfd_mips_elf_ignore_discarded_relocs): ... here.
elf64-mips.c (elf_backend_ignore_discarded_relocs): Use
_bfd_mips_elf_ignore_discarded_relocs.
elfxx-mips.h (_bfd_mips_elf_ignore_discarded_relocs): Declare.
@
text
@d1889 2
a1890 1
	  bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);
@


1.151
log
@	* elf32-mips.c: Remove superfluous definitions copied from
	elfxx-mips.c.
	(bfd_elf32_bigmips_vec,bfd_elf32_littlemips_vec): Use the
	SGIish vectors to check the special case.
	(mips_elf_hi16_reloc): Fix comment.
	(mips_elf_got16_reloc): Likewise.
	(_bfd_mips_elf32_gprel16_reloc): Likewise.
	(elf_reloc_map): Code cleanup.
	(mips_reloc_map): Add comment.
	(bfd_elf23_bfd_reloc_type_lookup): Code cleanup.
	(mips_elf32_rtype_to_howto): Likewise.
	(mips_elf32_discard_info): Likewise.
	(elf32_mips_irix_compat): Invert logic: Only SGIish vectors
	lead to IRIX compatibility now.
@
text
@a84 2
static boolean elf32_mips_ignore_discarded_relocs
  PARAMS ((asection *));
a1727 9
elf32_mips_ignore_discarded_relocs (sec)
     asection *sec;
{
  if (strcmp (sec->name, ".pdr") == 0)
    return true;
  return false;
}

static boolean
d2048 1
a2048 1
					elf32_mips_ignore_discarded_relocs
@


1.151.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d85 2
d1730 9
d1900 1
a1900 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d2059 1
a2059 1
					_bfd_mips_elf_ignore_discarded_relocs
@


1.151.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d83 4
d1663 97
d1789 6
a1794 2
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
d1797 1
d1806 1
d1809 25
a1833 2
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  if (symtab_hdr->sh_info != 0)
d1835 6
a1840 6
      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isymbuf == NULL)
	isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					symtab_hdr->sh_info, 0,
					NULL, NULL, NULL);
      if (isymbuf == NULL)
d1850 2
d1882 3
a1884 1
          Elf_Internal_Sym *isym;
d1887 6
a1892 2
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  targetsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
d1929 6
a1934 6
  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
d1938 6
a1943 6
  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
d2047 1
a2047 1
#define elf_backend_discard_info	_bfd_mips_elf_discard_info
d2050 1
@


1.151.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1390 1
a1390 1
  { BFD_RELOC_NONE, R_MIPS_NONE },
a1571 3

  if (ABI_N32_P (abfd))
    return false;
@


1.150
log
@        * elf32-mips.c (mips_elf32_object_p): Revert 0404 fragment: allow
        n32 binaries.
@
text
@d92 2
a93 2
extern const bfd_target bfd_elf32_tradbigmips_vec;
extern const bfd_target bfd_elf32_tradlittlemips_vec;
a95 1

a98 6
/* Nonzero if ABFD is using the 64-bit ABI. */
#define ABI_64_P(abfd) \
  ((elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64) != 0)

#define NEWABI_P(abfd) (ABI_N32_P (abfd) || ABI_64_P (abfd))

a102 4
/* The size of an external REL relocation.  */
#define MIPS_ELF_REL_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_rel)

a105 133
#if 0
/* We no longer try to identify particular sections for the .dynsym
   section.  When we do, we wind up crashing if there are other random
   sections with relocations.  */

/* Names of sections which appear in the .dynsym section in an Irix 5
   executable.  */

static const char * const mips_elf_dynsym_sec_names[] =
{
  ".text",
  ".init",
  ".fini",
  ".data",
  ".rodata",
  ".sdata",
  ".sbss",
  ".bss",
  NULL
};

#define SIZEOF_MIPS_DYNSYM_SECNAMES \
  (sizeof mips_elf_dynsym_sec_names / sizeof mips_elf_dynsym_sec_names[0])

/* The number of entries in mips_elf_dynsym_sec_names which go in the
   text segment.  */

#define MIPS_TEXT_DYNSYM_SECNO (3)

#endif /* 0 */

/* The names of the runtime procedure table symbols used on Irix 5.  */

static const char * const mips_elf_dynsym_rtproc_names[] =
{
  "_procedure_table",
  "_procedure_string_table",
  "_procedure_table_size",
  NULL
};

/* These structures are used to generate the .compact_rel section on
   Irix 5.  */

typedef struct
{
  unsigned long id1;		/* Always one?  */
  unsigned long num;		/* Number of compact relocation entries.  */
  unsigned long id2;		/* Always two?  */
  unsigned long offset;		/* The file offset of the first relocation.  */
  unsigned long reserved0;	/* Zero?  */
  unsigned long reserved1;	/* Zero?  */
} Elf32_compact_rel;

typedef struct
{
  bfd_byte id1[4];
  bfd_byte num[4];
  bfd_byte id2[4];
  bfd_byte offset[4];
  bfd_byte reserved0[4];
  bfd_byte reserved1[4];
} Elf32_External_compact_rel;

typedef struct
{
  unsigned int ctype : 1;	/* 1: long 0: short format. See below.  */
  unsigned int rtype : 4;	/* Relocation types. See below.  */
  unsigned int dist2to : 8;
  unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
  unsigned long konst;		/* KONST field. See below.  */
  unsigned long vaddr;		/* VADDR to be relocated.  */
} Elf32_crinfo;

typedef struct
{
  unsigned int ctype : 1;	/* 1: long 0: short format. See below.  */
  unsigned int rtype : 4;	/* Relocation types. See below.  */
  unsigned int dist2to : 8;
  unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
  unsigned long konst;		/* KONST field. See below.  */
} Elf32_crinfo2;

typedef struct
{
  bfd_byte info[4];
  bfd_byte konst[4];
  bfd_byte vaddr[4];
} Elf32_External_crinfo;

typedef struct
{
  bfd_byte info[4];
  bfd_byte konst[4];
} Elf32_External_crinfo2;

/* These are the constants used to swap the bitfields in a crinfo.  */

#define CRINFO_CTYPE (0x1)
#define CRINFO_CTYPE_SH (31)
#define CRINFO_RTYPE (0xf)
#define CRINFO_RTYPE_SH (27)
#define CRINFO_DIST2TO (0xff)
#define CRINFO_DIST2TO_SH (19)
#define CRINFO_RELVADDR (0x7ffff)
#define CRINFO_RELVADDR_SH (0)

/* A compact relocation info has long (3 words) or short (2 words)
   formats.  A short format doesn't have VADDR field and relvaddr
   fields contains ((VADDR - vaddr of the previous entry) >> 2).  */
#define CRF_MIPS_LONG			1
#define CRF_MIPS_SHORT			0

/* There are 4 types of compact relocation at least. The value KONST
   has different meaning for each type:

   (type)		(konst)
   CT_MIPS_REL32	Address in data
   CT_MIPS_WORD		Address in word (XXX)
   CT_MIPS_GPHI_LO	GP - vaddr
   CT_MIPS_JMPAD	Address to jump
   */

#define CRT_MIPS_REL32			0xa
#define CRT_MIPS_WORD			0xb
#define CRT_MIPS_GPHI_LO		0xc
#define CRT_MIPS_JMPAD			0xd

#define mips_elf_set_cr_format(x,format)	((x).ctype = (format))
#define mips_elf_set_cr_type(x,type)		((x).rtype = (type))
#define mips_elf_set_cr_dist2to(x,v)		((x).dist2to = (v))
#define mips_elf_set_cr_relvaddr(x,d)		((x).relvaddr = (d)<<2)

d763 1
a763 1
  /* If we're relocating, and this an external symbol, we don't want
d958 1
a958 1
  /* If we're relocating, and this an external symbol, we don't want
d1123 2
a1124 2
/* Do a R_MIPS_GPREL32 relocation.  Is this 32 bit value the offset
   from the gp register? XXX */
d1390 2
a1391 2
  bfd_reloc_code_real_type bfd_reloc_val;
  enum elf_mips_reloc_type elf_reloc_val;
d1399 1
d1428 1
d1430 2
a1431 1
  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map); i++)
d1433 2
a1434 2
      if (mips_reloc_map[i].bfd_reloc_val == code)
	return &elf_mips_howto_table_rel[(int) mips_reloc_map[i].elf_reloc_val];
d1448 1
a1448 1
	return &elf_mips_howto_table_rel[(int) R_MIPS_32];
a1483 1
      break;
a1485 1
      break;
a1487 1
      break;
a1489 1
      break;
a1491 1
      break;
a1493 1
      break;
a1495 1
      break;
a1497 1
      break;
a1499 2
      break;

a1673 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1703 1
a1703 2
  cookie->relend =
    cookie->rels + o->reloc_count * bed->s->int_rels_per_ext_rel;
d1777 4
a1780 2
  if ((abfd->xvec == &bfd_elf32_tradbigmips_vec)
      || (abfd->xvec == &bfd_elf32_tradlittlemips_vec))
a1781 2
  else
    return ict_irix5;
@


1.150.4.1
log
@merge from trunk
@
text
@d85 2
d92 2
a93 2
extern const bfd_target bfd_elf32_bigmips_vec;
extern const bfd_target bfd_elf32_littlemips_vec;
d96 1
d100 6
d110 4
d117 133
d907 1
a907 1
  /* If we're relocating, and this is an external symbol, we don't want
d1102 1
a1102 1
  /* If we're relocating, and this is an external symbol, we don't want
d1267 2
a1268 2
/* Do a R_MIPS_GPREL32 relocation.  This is a 32 bit value which must
   become the offset from the gp register.  */
d1534 2
a1535 2
  bfd_reloc_code_real_type bfd_val;
  enum elf_mips_reloc_type elf_val;
a1542 1
  /* There is no BFD reloc for R_MIPS_REL32.  */
a1570 1
  reloc_howto_type *howto_table = elf_mips_howto_table_rel;
d1572 1
a1572 2
  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
d1574 2
a1575 2
      if (mips_reloc_map[i].bfd_val == code)
	return &howto_table[(int) mips_reloc_map[i].elf_val];
d1589 1
a1589 1
	return &howto_table[(int) R_MIPS_32];
d1625 1
d1628 1
d1631 1
d1634 1
d1637 1
d1640 1
d1643 1
d1646 1
d1649 2
d1825 1
d1855 2
a1856 1
  cookie->relend = cookie->rels + o->reloc_count;
d1883 9
d1930 4
a1933 2
  if ((abfd->xvec == &bfd_elf32_bigmips_vec)
      || (abfd->xvec == &bfd_elf32_littlemips_vec))
a1934 2
  else
    return ict_none;
d2053 1
a2053 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d2212 1
a2212 1
					_bfd_mips_elf_ignore_discarded_relocs
@


1.149
log
@	* Makefile.am: Add elfxx-mips.c to the known backends.
	(elf32-mips.lo): remove dependency to coff/external.h.
	* Makefile.in: Regenerate.
	* configure.in: Add elfxx-mips.lo to all vectors using elf32-mips.lo
	Remove elf32-mips.lo from 64 bit vectors. Update dependencies
	accordingly.
	* configure: Regenerate.
	* elf-bfd.h: Move all MIPS ELF specific prototypes to elfxx-mips.h.
	(irix_compat_t): IRIX compatibility level, moved from elf32-mips.c.
	(elf_backend_mips_irix_compat, elf_backend_mips_rtype_to_howto): New
	MIPS specific backend functions.
	* elf32-mips.c: Moved most code to elfxx-mips.c.
	(mips_elf_hi16_reloc): Rename from _bfd_mips_elf_hi16_reloc and make
	static.
	(mips_elf_lo16_reloc): Likewise, was _bfd_mips_elf_lo16_reloc.
	(mips_elf_got16_reloc): Likewise, was _bfd_mips_elf_got16_reloc.
	(mips_elf_gprel32_reloc): Likewise, was _bfd_mips_elf_gprel32_reloc.
	(mips_elf32_rtype_to_howto): Rename from mips_rtype_to_howto. Changed
	interface to allow selection of the right REL or RELA howto table.
	(mips_elf32_object_p): Rename from _bfd_mips_elf_object_p and made
	static. Let it refuse n32 objects.
	(elf32_mips_grok_prstatus): Rename from _bfd_elf32_mips_grok_prstatus.
	(elf32_mips_grok_psinfo): Rename from _bfd_elf32_mips_grok_psinfo.
	(elf32_mips_discard_info): Rename from _bfd_elf32_mips_discard_info.
	(elf32_mips_ignore_discarded_relocs): Rename from
	_bfd_elf32_mips_ignore_discarded_relocs.
	(elf32_mips_write_section): Rename from _bfd_elf32_mips_write_section.
	(elf32_mips_irix_compat): New function, replaces IRIX_COMPAT.
	(elf_mips_howto_table_rela): Remove.
	* elf64-mips.c: Moved most code to elfxx-mips.c.
	(bfd_elf64_bfd_reloc_type_lookup): Make static.
	(mips_elf64_rtype_to_howto): New function.
	(mips_elf64_object_p): Likewise.
	(elf64_mips_irix_compat): Likewise.
	* elfxx-mips.c: New file containing common code merged together from
	elf32-mips.c and elf64-mips.c.
	* elfxx-mips.h: New file containing MIPS specific prototypes from
	elf-bfd.h.
	* elfxx-target.h: Add handling for elf_backend_mips_irix_compat and
	elf_backend_mips_rtype_to_howto.
@
text
@a1732 3
  if (ABI_N32_P (abfd))
    return false;

@


1.148
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d38 1
d50 8
a57 61
/* This structure is used to hold .got information when linking.  It
   is stored in the tdata field of the bfd_elf_section_data structure.  */

struct mips_got_info
{
  /* The global symbol in the GOT with the lowest index in the dynamic
     symbol table.  */
  struct elf_link_hash_entry *global_gotsym;
  /* The number of global .got entries.  */
  unsigned int global_gotno;
  /* The number of local .got entries.  */
  unsigned int local_gotno;
  /* The number of local .got entries we have used.  */
  unsigned int assigned_gotno;
};

/* The MIPS ELF linker needs additional information for each symbol in
   the global hash table.  */

struct mips_elf_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* External symbol information.  */
  EXTR esym;

  /* Number of R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 relocs against
     this symbol.  */
  unsigned int possibly_dynamic_relocs;

  /* If the R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 reloc is against
     a readonly section.  */
  boolean readonly_reloc;

  /* The index of the first dynamic relocation (in the .rel.dyn
     section) against this symbol.  */
  unsigned int min_dyn_reloc_index;

  /* We must not create a stub for a symbol that has relocations
     related to taking the function's address, i.e. any but
     R_MIPS_CALL*16 ones -- see "MIPS ABI Supplement, 3rd Edition",
     p. 4-20.  */
  boolean no_fn_stub;

  /* If there is a stub that 32 bit functions should use to call this
     16 bit function, this points to the section containing the stub.  */
  asection *fn_stub;

  /* Whether we need the fn_stub; this is set if this symbol appears
     in any relocs other than a 16 bit call.  */
  boolean need_fn_stub;

  /* If there is a stub that 16 bit functions should use to call this
     32 bit function, this points to the section containing the stub.  */
  asection *call_stub;

  /* This is like the call_stub field, but it is used if the function
     being called returns a floating point value.  */
  asection *call_fp_stub;
};

d62 2
a63 2
static reloc_howto_type *mips_rtype_to_howto
  PARAMS ((unsigned int));
a67 10
static void bfd_mips_elf32_swap_gptab_in
  PARAMS ((bfd *, const Elf32_External_gptab *, Elf32_gptab *));
static void bfd_mips_elf32_swap_gptab_out
  PARAMS ((bfd *, const Elf32_gptab *, Elf32_External_gptab *));
#if 0
static void bfd_mips_elf_swap_msym_in
  PARAMS ((bfd *, const Elf32_External_Msym *, Elf32_Internal_Msym *));
#endif
static void bfd_mips_elf_swap_msym_out
  PARAMS ((bfd *, const Elf32_Internal_Msym *, Elf32_External_Msym *));
d69 1
a69 6
static boolean mips_elf_create_procedure_table
  PARAMS ((PTR, bfd *, struct bfd_link_info *, asection *,
	   struct ecoff_debug_info *));
static INLINE int elf_mips_isa PARAMS ((flagword));
static INLINE unsigned long elf_mips_mach PARAMS ((flagword));
static INLINE char* elf_mips_abi_name PARAMS ((bfd *));
a71 3
static struct bfd_hash_entry *mips_elf_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static int gptab_compare PARAMS ((const void *, const void *));
a75 4
static boolean mips_elf_create_compact_rel_section
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf_create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
a77 37
static bfd_byte *elf32_mips_get_relocated_section_contents
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
	   bfd_byte *, boolean, asymbol **));
static asection *mips_elf_create_msym_section
  PARAMS ((bfd *));
static void mips_elf_irix6_finish_dynamic_symbol
  PARAMS ((bfd *, const char *, Elf_Internal_Sym *));
static bfd_vma mips_elf_sign_extend PARAMS ((bfd_vma, int));
static boolean mips_elf_overflow_p PARAMS ((bfd_vma, int));
static bfd_vma mips_elf_high PARAMS ((bfd_vma));
static bfd_vma mips_elf_higher PARAMS ((bfd_vma));
static bfd_vma mips_elf_highest PARAMS ((bfd_vma));
static bfd_vma mips_elf_global_got_index
  PARAMS ((bfd *, struct elf_link_hash_entry *));
static bfd_vma mips_elf_local_got_index
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma));
static bfd_vma mips_elf_got_offset_from_index
  PARAMS ((bfd *, bfd *, bfd_vma));
static boolean mips_elf_record_global_got_symbol
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *,
	   struct mips_got_info *));
static bfd_vma mips_elf_got_page
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, bfd_vma *));
static const Elf_Internal_Rela *mips_elf_next_relocation
  PARAMS ((unsigned int, const Elf_Internal_Rela *,
	   const Elf_Internal_Rela *));
static bfd_reloc_status_type mips_elf_calculate_relocation
  PARAMS ((bfd *, bfd *, asection *, struct bfd_link_info *,
	   const Elf_Internal_Rela *, bfd_vma, reloc_howto_type *,
	   Elf_Internal_Sym *, asection **, bfd_vma *, const char **,
	   boolean *));
static bfd_vma mips_elf_obtain_contents
  PARAMS ((reloc_howto_type *, const Elf_Internal_Rela *, bfd *, bfd_byte *));
static boolean mips_elf_perform_relocation
  PARAMS ((struct bfd_link_info *, reloc_howto_type *,
	   const Elf_Internal_Rela *, bfd_vma,
	   bfd *, asection *, bfd_byte *, boolean));
d79 1
a79 29
static boolean mips_elf_sort_hash_table_f
  PARAMS ((struct mips_elf_link_hash_entry *, PTR));
static boolean mips_elf_sort_hash_table
  PARAMS ((struct bfd_link_info *, unsigned long));
static asection * mips_elf_got_section PARAMS ((bfd *));
static struct mips_got_info *mips_elf_got_info
  PARAMS ((bfd *, asection **));
static boolean mips_elf_local_relocation_p
  PARAMS ((bfd *, const Elf_Internal_Rela *, asection **, boolean));
static bfd_vma mips_elf_create_local_got_entry
  PARAMS ((bfd *, struct mips_got_info *, asection *, bfd_vma));
static bfd_vma mips_elf_got16_entry
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, boolean));
static boolean mips_elf_create_dynamic_relocation
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Rela *,
	   struct mips_elf_link_hash_entry *, asection *,
	   bfd_vma, bfd_vma *, asection *));
static void mips_elf_allocate_dynamic_relocations
  PARAMS ((bfd *, unsigned int));
static boolean mips_elf_stub_section_p
  PARAMS ((bfd *, asection *));
static int sort_dynamic_relocs
  PARAMS ((const void *, const void *));
static void _bfd_mips_elf_hide_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, boolean));
static void _bfd_mips_elf_copy_indirect_symbol
  PARAMS ((struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
static boolean _bfd_elf32_mips_grok_prstatus
d81 1
a81 1
static boolean _bfd_elf32_mips_grok_psinfo
d83 1
a83 1
static boolean _bfd_elf32_mips_discard_info
d85 1
a85 1
static boolean _bfd_elf32_mips_ignore_discarded_relocs
d87 1
a87 1
static boolean _bfd_elf32_mips_write_section
d89 2
a93 15
#ifdef BFD64
extern const bfd_target bfd_elf64_tradbigmips_vec;
extern const bfd_target bfd_elf64_tradlittlemips_vec;
#endif

/* The level of IRIX compatibility we're striving for.  */

typedef enum {
  ict_none,
  ict_irix5,
  ict_irix6
} irix_compat_t;

/* This will be used when we sort the dynamic relocation records.  */
static bfd *reldyn_sorting_bfd;
d104 1
a104 17
/* Depending on the target vector we generate some version of Irix
   executables or "normal" MIPS ELF ABI executables.  */
#ifdef BFD64
#define IRIX_COMPAT(abfd) \
  (((abfd->xvec == &bfd_elf64_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf64_tradlittlemips_vec) || \
    (abfd->xvec == &bfd_elf32_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf32_tradlittlemips_vec)) ? ict_none : \
  ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5))
#else
#define IRIX_COMPAT(abfd) \
  (((abfd->xvec == &bfd_elf32_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf32_tradlittlemips_vec)) ? ict_none : \
  ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5))
#endif

#define NEWABI_P(abfd) (ABI_N32_P(abfd) || ABI_64_P(abfd))
d108 1
a108 18
  (IRIX_COMPAT (abfd) != ict_none)

/* The name of the msym section.  */
#define MIPS_ELF_MSYM_SECTION_NAME(abfd) ".msym"

/* The name of the srdata section.  */
#define MIPS_ELF_SRDATA_SECTION_NAME(abfd) ".srdata"

/* The name of the options section.  */
#define MIPS_ELF_OPTIONS_SECTION_NAME(abfd) \
  (IRIX_COMPAT (abfd) == ict_irix6 ? ".MIPS.options" : ".options")

/* The name of the stub section.  */
#define MIPS_ELF_STUB_SECTION_NAME(abfd) \
  (IRIX_COMPAT (abfd) == ict_irix6 ? ".MIPS.stubs" : ".stub")

/* The name of the dynamic relocation section.  */
#define MIPS_ELF_REL_DYN_SECTION_NAME(abfd) ".rel.dyn"
a113 39
/* The size of an external dynamic table entry.  */
#define MIPS_ELF_DYN_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_dyn)

/* The size of a GOT entry.  */
#define MIPS_ELF_GOT_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->arch_size / 8)

/* The size of a symbol-table entry.  */
#define MIPS_ELF_SYM_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_sym)

/* The default alignment for sections, as a power of two.  */
#define MIPS_ELF_LOG_FILE_ALIGN(abfd)				\
  (get_elf_backend_data (abfd)->s->file_align == 8 ? 3 : 2)

/* Get word-sized data.  */
#define MIPS_ELF_GET_WORD(abfd, ptr) \
  (ABI_64_P (abfd) ? bfd_get_64 (abfd, ptr) : bfd_get_32 (abfd, ptr))

/* Put out word-sized data.  */
#define MIPS_ELF_PUT_WORD(abfd, val, ptr)	\
  (ABI_64_P (abfd) 				\
   ? bfd_put_64 (abfd, val, ptr) 		\
   : bfd_put_32 (abfd, val, ptr))

/* Add a dynamic symbol table-entry.  */
#ifdef BFD64
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val)			\
  (ABI_64_P (elf_hash_table (info)->dynobj)				\
   ? bfd_elf64_add_dynamic_entry (info, (bfd_vma) tag, (bfd_vma) val)	\
   : bfd_elf32_add_dynamic_entry (info, (bfd_vma) tag, (bfd_vma) val))
#else
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val)			\
  (ABI_64_P (elf_hash_table (info)->dynobj)				\
   ? (boolean) (abort (), false)					\
   : bfd_elf32_add_dynamic_entry (info, (bfd_vma) tag, (bfd_vma) val))
#endif

a116 16
/* Instructions which appear in a stub.  For some reason the stub is
   slightly different on an SGI system.  */
#define ELF_MIPS_GP_OFFSET(abfd) (SGI_COMPAT (abfd) ? 0x7ff0 : 0x8000)
#define STUB_LW(abfd)						\
  (SGI_COMPAT (abfd)						\
   ? (ABI_64_P (abfd)  						\
      ? 0xdf998010		/* ld t9,0x8010(gp) */		\
      : 0x8f998010)             /* lw t9,0x8010(gp) */		\
   : 0x8f998010)		/* lw t9,0x8000(gp) */
#define STUB_MOVE(abfd)                                         \
  (SGI_COMPAT (abfd) ? 0x03e07825 : 0x03e07821)         /* move t7,ra */
#define STUB_JALR 0x0320f809				/* jal t9 */
#define STUB_LI16(abfd)                                         \
  (SGI_COMPAT (abfd) ? 0x34180000 : 0x24180000)         /* ori t8,zero,0 */
#define MIPS_FUNCTION_STUB_SIZE (16)

a249 5
static void bfd_elf32_swap_compact_rel_out
  PARAMS ((bfd *, const Elf32_compact_rel *, Elf32_External_compact_rel *));
static void bfd_elf32_swap_crinfo_out
  PARAMS ((bfd *, const Elf32_crinfo *, Elf32_External_crinfo *));

d344 1
a344 1
	 _bfd_mips_elf_hi16_reloc,	/* special_function */
d359 1
a359 1
	 _bfd_mips_elf_lo16_reloc,	/* special_function */
d374 1
a374 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d389 1
a389 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d404 1
a404 1
	 _bfd_mips_elf_got16_reloc,	/* special_function */
d449 1
a449 1
	 _bfd_mips_elf_gprel32_reloc, /* special_function */
d701 4
a704 6
/* The relocation table used for SHT_RELA sections.  */

static reloc_howto_type elf_mips_howto_table_rela[] =
{
  /* No relocation.  */
  HOWTO (R_MIPS_NONE,		/* type */
d706 2
a707 17
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_NONE",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  /* 16 bit relocation.  */
  HOWTO (R_MIPS_16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
d711 4
a714 19
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_16",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* 32 bit relocation.  */
  HOWTO (R_MIPS_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_32",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
d716 1
a716 1
	 false),		/* pcrel_offset */
d718 3
a720 17
  /* 32 bit symbol relative relocation.  */
  HOWTO (R_MIPS_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_REL32",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* 26 bit jump address.  */
  HOWTO (R_MIPS_26,		/* type */
d727 9
a735 9
				/* This needs complex overflow
				   detection, because the upper 36
				   bits must match the PC + 4.  */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_26",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x03ffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d737 3
a739 3
  /* R_MIPS_HI16 and R_MIPS_LO16 are unsupported for 64 bit REL.  */
  /* High 16 bits of symbol value.  */
  HOWTO (R_MIPS_HI16,		/* type */
d745 7
a751 7
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_HI16",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d753 4
a756 2
  /* Low 16 bits of symbol value.  */
  HOWTO (R_MIPS_LO16,		/* type */
d760 1
a760 1
	 false,			/* pc_relative */
d763 6
a768 6
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_LO16",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d770 3
a772 2
  /* GP relative reference.  */
  HOWTO (R_MIPS_GPREL16,	/* type */
d776 1
a776 1
	 false,			/* pc_relative */
d778 7
a784 7
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
	 "R_MIPS_GPREL16",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d786 4
a789 3
  /* Reference to literal section.  */
  HOWTO (R_MIPS_LITERAL,	/* type */
	 0,			/* rightshift */
d792 1
a792 1
	 false,			/* pc_relative */
d795 6
a800 6
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
	 "R_MIPS_LITERAL",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d802 3
a804 3
  /* Reference to global offset table.  */
  /* FIXME: This is not handled correctly.  */
  HOWTO (R_MIPS_GOT16,		/* type */
d806 3
a808 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
d811 6
a816 6
	 bfd_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT16",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d818 3
a820 2
  /* 16 bit PC relative reference.  */
  HOWTO (R_MIPS_PC16,		/* type */
d823 1
a823 1
	 16,			/* bitsize */
d828 5
a832 5
	 "R_MIPS_PC16",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 true),			/* pcrel_offset */
d834 3
a836 3
  /* 16 bit call through global offset table.  */
  /* FIXME: This is not handled correctly.  */
  HOWTO (R_MIPS_CALL16,		/* type */
d839 1
a839 1
	 16,			/* bitsize */
d842 3
a844 3
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL16",	/* name */
d847 2
a848 2
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d850 3
a852 2
  /* 32 bit GP relative reference.  */
  HOWTO (R_MIPS_GPREL32,	/* type */
d855 1
a855 1
	 32,			/* bitsize */
d859 2
a860 2
	 _bfd_mips_elf_gprel32_reloc, /* special_function */
	 "R_MIPS_GPREL32",	/* name */
d863 2
a864 5751
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),

  /* A 5 bit shift field.  */
  HOWTO (R_MIPS_SHIFT5,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 5,			/* bitsize */
	 false,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SHIFT5",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000007c0,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A 6 bit shift field.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_SHIFT6,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 false,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_MIPS_SHIFT6",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000007c4,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* 64 bit relocation.  */
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Displacement in the global offset table.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_GOT_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_DISP",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Displacement to page pointer in the global offset table.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_GOT_PAGE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_PAGE",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Offset from page pointer in the global offset table.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_GOT_OFST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_OFST",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_GOT_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_HI16",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_GOT_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_LO16",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* 64 bit substraction.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_SUB,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SUB",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Insert the addend as an instruction.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_INSERT_A,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_INSERT_A",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Insert the addend as an instruction, and change all relocations
     to refer to the old instruction at the address.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_INSERT_B,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_INSERT_B",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Delete a 32 bit instruction.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_DELETE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_DELETE",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Get the higher value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHER,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_MIPS_HIGHER",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Get the highest value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHEST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_MIPS_HIGHEST",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_CALL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL_HI16",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_CALL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL_LO16",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Section displacement, used by an associated event location section.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_SCN_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SCN_DISP",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_MIPS_REL16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_REL16",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* These two are obsolete.  */
  EMPTY_HOWTO (R_MIPS_ADD_IMMEDIATE),
  EMPTY_HOWTO (R_MIPS_PJUMP),

  /* Similiar to R_MIPS_REL32, but used for relocations in a GOT section.
     It must be used for multigot GOT's (and only there).  */
  HOWTO (R_MIPS_RELGOT,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_RELGOT",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_JALR",	        /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
};

/* The reloc used for BFD_RELOC_CTOR when doing a 64 bit link.  This
   is a hack to make the linker think that we need 64 bit values.  */
static reloc_howto_type elf_mips_ctor64_howto =
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips32_64bit_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false);		/* pcrel_offset */

/* The reloc used for the mips16 jump instruction.  */
static reloc_howto_type elf_mips16_jump_howto =
  HOWTO (R_MIPS16_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 mips16_jump_reloc,	/* special_function */
	 "R_MIPS16_26",		/* name */
	 true,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 false);		/* pcrel_offset */

/* The reloc used for the mips16 gprel instruction.  */
static reloc_howto_type elf_mips16_gprel_howto =
  HOWTO (R_MIPS16_GPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips16_gprel_reloc,	/* special_function */
	 "R_MIPS16_GPREL",	/* name */
	 true,			/* partial_inplace */
	 0x07ff001f,		/* src_mask */
	 0x07ff001f,	        /* dst_mask */
	 false);		/* pcrel_offset */

/* GNU extensions for embedded-pic.  */
/* High 16 bits of symbol value, pc-relative.  */
static reloc_howto_type elf_mips_gnu_rel_hi16 =
  HOWTO (R_MIPS_GNU_REL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc,	/* special_function */
	 "R_MIPS_GNU_REL_HI16",	/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 true);			/* pcrel_offset */

/* Low 16 bits of symbol value, pc-relative.  */
static reloc_howto_type elf_mips_gnu_rel_lo16 =
  HOWTO (R_MIPS_GNU_REL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc,	/* special_function */
	 "R_MIPS_GNU_REL_LO16",	/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 true);			/* pcrel_offset */

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rel16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 true);			/* pcrel_offset */

/* 64 bit pc-relative.  */
static reloc_howto_type elf_mips_gnu_pcrel64 =
  HOWTO (R_MIPS_PC64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_PC64",		/* name */
	 true,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 true);			/* pcrel_offset */

/* 32 bit pc-relative.  */
static reloc_howto_type elf_mips_gnu_pcrel32 =
  HOWTO (R_MIPS_PC32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_PC32",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 true);			/* pcrel_offset */

/* GNU extension to record C++ vtable hierarchy */
static reloc_howto_type elf_mips_gnu_vtinherit_howto =
  HOWTO (R_MIPS_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_MIPS_GNU_VTINHERIT", /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false);		/* pcrel_offset */

/* GNU extension to record C++ vtable member usage */
static reloc_howto_type elf_mips_gnu_vtentry_howto =
  HOWTO (R_MIPS_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
	 "R_MIPS_GNU_VTENTRY",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false);		/* pcrel_offset */

/* Do a R_MIPS_HI16 relocation.  This has to be done in combination
   with a R_MIPS_LO16 reloc, because there is a carry from the LO16 to
   the HI16.  Here we just save the information we need; we do the
   actual relocation when we see the LO16.

   MIPS ELF requires that the LO16 immediately follow the HI16.  As a
   GNU extension, for non-pc-relative relocations, we permit an
   arbitrary number of HI16 relocs to be associated with a single LO16
   reloc.  This extension permits gcc to output the HI and LO relocs
   itself.

   This cannot be done for PC-relative relocations because both the HI16
   and LO16 parts of the relocations must be done relative to the LO16
   part, and there can be carry to or borrow from the HI16 part.  */

struct mips_hi16
{
  struct mips_hi16 *next;
  bfd_byte *addr;
  bfd_vma addend;
};

/* FIXME: This should not be a static variable.  */

static struct mips_hi16 *mips_hi16_list;

bfd_reloc_status_type
_bfd_mips_elf_hi16_reloc (abfd,
		     reloc_entry,
		     symbol,
		     data,
		     input_section,
		     output_bfd,
		     error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  bfd_reloc_status_type ret;
  bfd_vma relocation;
  struct mips_hi16 *n;

  /* If we're relocating, and this an external symbol, we don't want
     to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  ret = bfd_reloc_ok;

  if (strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
    {
      boolean relocateable;
      bfd_vma gp;

      if (ret == bfd_reloc_undefined)
	abort ();

      if (output_bfd != NULL)
	relocateable = true;
      else
	{
	  relocateable = false;
	  output_bfd = symbol->section->output_section->owner;
	}

      ret = mips_elf_final_gp (output_bfd, symbol, relocateable,
			       error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;

      relocation = gp - reloc_entry->address;
    }
  else
    {
      if (bfd_is_und_section (symbol->section)
	  && output_bfd == (bfd *) NULL)
	ret = bfd_reloc_undefined;

      if (bfd_is_com_section (symbol->section))
	relocation = 0;
      else
	relocation = symbol->value;
    }

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Save the information, and let LO16 do the actual relocation.  */
  n = (struct mips_hi16 *) bfd_malloc ((bfd_size_type) sizeof *n);
  if (n == NULL)
    return bfd_reloc_outofrange;
  n->addr = (bfd_byte *) data + reloc_entry->address;
  n->addend = relocation;
  n->next = mips_hi16_list;
  mips_hi16_list = n;

  if (output_bfd != (bfd *) NULL)
    reloc_entry->address += input_section->output_offset;

  return ret;
}

/* Do a R_MIPS_LO16 relocation.  This is a straightforward 16 bit
   inplace relocation; this function exists in order to do the
   R_MIPS_HI16 relocation described above.  */

bfd_reloc_status_type
_bfd_mips_elf_lo16_reloc (abfd,
		     reloc_entry,
		     symbol,
		     data,
		     input_section,
		     output_bfd,
		     error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  arelent gp_disp_relent;

  if (mips_hi16_list != NULL)
    {
      struct mips_hi16 *l;

      l = mips_hi16_list;
      while (l != NULL)
	{
	  unsigned long insn;
	  unsigned long val;
	  unsigned long vallo;
	  struct mips_hi16 *next;

	  /* Do the HI16 relocation.  Note that we actually don't need
	     to know anything about the LO16 itself, except where to
	     find the low 16 bits of the addend needed by the LO16.  */
	  insn = bfd_get_32 (abfd, l->addr);
	  vallo = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

	  /* The low order 16 bits are always treated as a signed
	     value.  */
	  vallo = ((vallo & 0xffff) ^ 0x8000) - 0x8000;
	  val = ((insn & 0xffff) << 16) + vallo;
	  val += l->addend;

	  /* If PC-relative, we need to subtract out the address of the LO
	     half of the HI/LO.  (The actual relocation is relative
	     to that instruction.)  */
	  if (reloc_entry->howto->pc_relative)
	    val -= reloc_entry->address;

	  /* At this point, "val" has the value of the combined HI/LO
	     pair.  If the low order 16 bits (which will be used for
	     the LO16 insn) are negative, then we will need an
	     adjustment for the high order 16 bits.  */
	  val += 0x8000;
	  val = (val >> 16) & 0xffff;

	  insn &= ~ (bfd_vma) 0xffff;
	  insn |= val;
	  bfd_put_32 (abfd, (bfd_vma) insn, l->addr);

	  if (strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
	    {
	      gp_disp_relent = *reloc_entry;
	      reloc_entry = &gp_disp_relent;
	      reloc_entry->addend = l->addend;
	    }

	  next = l->next;
	  free (l);
	  l = next;
	}

      mips_hi16_list = NULL;
    }
  else if (strcmp (bfd_asymbol_name (symbol), "_gp_disp") == 0)
    {
      bfd_reloc_status_type ret;
      bfd_vma gp, relocation;

      /* FIXME: Does this case ever occur?  */

      ret = mips_elf_final_gp (output_bfd, symbol, true, error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;

      relocation = gp - reloc_entry->address;
      relocation += symbol->section->output_section->vma;
      relocation += symbol->section->output_offset;
      relocation += reloc_entry->addend;

      if (reloc_entry->address > input_section->_cooked_size)
	return bfd_reloc_outofrange;

      gp_disp_relent = *reloc_entry;
      reloc_entry = &gp_disp_relent;
      reloc_entry->addend = relocation - 4;
    }

  /* Now do the LO16 reloc in the usual way.  */
  return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
}

/* Do a R_MIPS_GOT16 reloc.  This is a reloc against the global offset
   table used for PIC code.  If the symbol is an external symbol, the
   instruction is modified to contain the offset of the appropriate
   entry in the global offset table.  If the symbol is a section
   symbol, the next reloc is a R_MIPS_LO16 reloc.  The two 16 bit
   addends are combined to form the real addend against the section
   symbol; the GOT16 is modified to contain the offset of an entry in
   the global offset table, and the LO16 is modified to offset it
   appropriately.  Thus an offset larger than 16 bits requires a
   modified value in the global offset table.

   This implementation suffices for the assembler, but the linker does
   not yet know how to create global offset tables.  */

bfd_reloc_status_type
_bfd_mips_elf_got16_reloc (abfd,
		      reloc_entry,
		      symbol,
		      data,
		      input_section,
		      output_bfd,
		      error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* If we're relocating, and this an external symbol, we don't want
     to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* If we're relocating, and this is a local symbol, we can handle it
     just like HI16.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) != 0)
    return _bfd_mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
				     input_section, output_bfd, error_message);

  abort ();
}

/* Set the GP value for OUTPUT_BFD.  Returns false if this is a
   dangerous relocation.  */

static boolean
mips_elf_assign_gp (output_bfd, pgp)
     bfd *output_bfd;
     bfd_vma *pgp;
{
  unsigned int count;
  asymbol **sym;
  unsigned int i;

  /* If we've already figured out what GP will be, just return it.  */
  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp)
    return true;

  count = bfd_get_symcount (output_bfd);
  sym = bfd_get_outsymbols (output_bfd);

  /* The linker script will have created a symbol named `_gp' with the
     appropriate value.  */
  if (sym == (asymbol **) NULL)
    i = count;
  else
    {
      for (i = 0; i < count; i++, sym++)
	{
	  register const char *name;

	  name = bfd_asymbol_name (*sym);
	  if (*name == '_' && strcmp (name, "_gp") == 0)
	    {
	      *pgp = bfd_asymbol_value (*sym);
	      _bfd_set_gp_value (output_bfd, *pgp);
	      break;
	    }
	}
    }

  if (i >= count)
    {
      /* Only get the error once.  */
      *pgp = 4;
      _bfd_set_gp_value (output_bfd, *pgp);
      return false;
    }

  return true;
}

/* We have to figure out the gp value, so that we can adjust the
   symbol value correctly.  We look up the symbol _gp in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocateable output.  */

static bfd_reloc_status_type
mips_elf_final_gp (output_bfd, symbol, relocateable, error_message, pgp)
     bfd *output_bfd;
     asymbol *symbol;
     boolean relocateable;
     char **error_message;
     bfd_vma *pgp;
{
  if (bfd_is_und_section (symbol->section)
      && ! relocateable)
    {
      *pgp = 0;
      return bfd_reloc_undefined;
    }

  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp == 0
      && (! relocateable
	  || (symbol->flags & BSF_SECTION_SYM) != 0))
    {
      if (relocateable)
	{
	  /* Make up a value.  */
	  *pgp = symbol->section->output_section->vma + 0x4000;
	  _bfd_set_gp_value (output_bfd, *pgp);
	}
      else if (!mips_elf_assign_gp (output_bfd, pgp))
	{
	  *error_message =
	    (char *) _("GP relative relocation when _gp not defined");
	  return bfd_reloc_dangerous;
	}
    }

  return bfd_reloc_ok;
}

/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must
   become the offset from the gp register.  This function also handles
   R_MIPS_LITERAL relocations, although those can be handled more
   cleverly because the entries in the .lit8 and .lit4 sections can be
   merged.  */

static bfd_reloc_status_type gprel16_with_gp PARAMS ((bfd *, asymbol *,
						      arelent *, asection *,
						      boolean, PTR, bfd_vma));

bfd_reloc_status_type
_bfd_mips_elf_gprel16_reloc (abfd, reloc_entry, symbol, data, input_section,
			     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != (bfd *) NULL)
    relocateable = true;
  else
    {
      relocateable = false;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf_final_gp (output_bfd, symbol, relocateable, error_message,
			   &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  return gprel16_with_gp (abfd, symbol, reloc_entry, input_section,
			  relocateable, data, gp);
}

static bfd_reloc_status_type
gprel16_with_gp (abfd, symbol, reloc_entry, input_section, relocateable, data,
		 gp)
     bfd *abfd;
     asymbol *symbol;
     arelent *reloc_entry;
     asection *input_section;
     boolean relocateable;
     PTR data;
     bfd_vma gp;
{
  bfd_vma relocation;
  unsigned long insn;
  unsigned long val;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

  /* Set val to the offset into the section or symbol.  */
  if (reloc_entry->howto->src_mask == 0)
    {
      /* This case occurs with the 64-bit MIPS ELF ABI.  */
      val = reloc_entry->addend;
    }
  else
    {
      val = ((insn & 0xffff) + reloc_entry->addend) & 0xffff;
      if (val & 0x8000)
	val -= 0x10000;
    }

  /* Adjust val for the final section location and GP value.  If we
     are producing relocateable output, we don't want to do this for
     an external symbol.  */
  if (! relocateable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  insn = (insn & ~0xffff) | (val & 0xffff);
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);

  if (relocateable)
    reloc_entry->address += input_section->output_offset;

  /* Make sure it fit in 16 bits.  */
  if ((long) val >= 0x8000 || (long) val < -0x8000)
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
}

/* Do a R_MIPS_GPREL32 relocation.  Is this 32 bit value the offset
   from the gp register? XXX */

static bfd_reloc_status_type gprel32_with_gp PARAMS ((bfd *, asymbol *,
						      arelent *, asection *,
						      boolean, PTR, bfd_vma));

bfd_reloc_status_type
_bfd_mips_elf_gprel32_reloc (abfd,
			reloc_entry,
			symbol,
			data,
			input_section,
			output_bfd,
			error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      *error_message = (char *)
	_("32bits gp relative relocation occurs for an external symbol");
      return bfd_reloc_outofrange;
    }

  if (output_bfd != (bfd *) NULL)
    {
      relocateable = true;
      gp = _bfd_get_gp_value (output_bfd);
    }
  else
    {
      relocateable = false;
      output_bfd = symbol->section->output_section->owner;

      ret = mips_elf_final_gp (output_bfd, symbol, relocateable,
			       error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;
    }

  return gprel32_with_gp (abfd, symbol, reloc_entry, input_section,
			  relocateable, data, gp);
}

static bfd_reloc_status_type
gprel32_with_gp (abfd, symbol, reloc_entry, input_section, relocateable, data,
		 gp)
     bfd *abfd;
     asymbol *symbol;
     arelent *reloc_entry;
     asection *input_section;
     boolean relocateable;
     PTR data;
     bfd_vma gp;
{
  bfd_vma relocation;
  unsigned long val;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  if (reloc_entry->howto->src_mask == 0)
    {
      /* This case arises with the 64-bit MIPS ELF ABI.  */
      val = 0;
    }
  else
    val = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

  /* Set val to the offset into the section or symbol.  */
  val += reloc_entry->addend;

  /* Adjust val for the final section location and GP value.  If we
     are producing relocateable output, we don't want to do this for
     an external symbol.  */
  if (! relocateable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  bfd_put_32 (abfd, (bfd_vma) val, (bfd_byte *) data + reloc_entry->address);

  if (relocateable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* Handle a 64 bit reloc in a 32 bit MIPS ELF file.  These are
   generated when addresses are 64 bits.  The upper 32 bits are a simple
   sign extension.  */

static bfd_reloc_status_type
mips32_64bit_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  bfd_reloc_status_type r;
  arelent reloc32;
  unsigned long val;
  bfd_size_type addr;

  r = bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
			     input_section, output_bfd, error_message);
  if (r != bfd_reloc_continue)
    return r;

  /* Do a normal 32 bit relocation on the lower 32 bits.  */
  reloc32 = *reloc_entry;
  if (bfd_big_endian (abfd))
    reloc32.address += 4;
  reloc32.howto = &elf_mips_howto_table_rel[R_MIPS_32];
  r = bfd_perform_relocation (abfd, &reloc32, data, input_section,
			      output_bfd, error_message);

  /* Sign extend into the upper 32 bits.  */
  val = bfd_get_32 (abfd, (bfd_byte *) data + reloc32.address);
  if ((val & 0x80000000) != 0)
    val = 0xffffffff;
  else
    val = 0;
  addr = reloc_entry->address;
  if (bfd_little_endian (abfd))
    addr += 4;
  bfd_put_32 (abfd, (bfd_vma) val, (bfd_byte *) data + addr);

  return r;
}

/* Handle a mips16 jump.  */

static bfd_reloc_status_type
mips16_jump_reloc (abfd, reloc_entry, symbol, data, input_section,
		   output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* FIXME.  */
  {
    static boolean warned;

    if (! warned)
      (*_bfd_error_handler)
	(_("Linking mips16 objects into %s format is not supported"),
	 bfd_get_target (input_section->output_section->owner));
    warned = true;
  }

  return bfd_reloc_undefined;
}

/* Handle a mips16 GP relative reloc.  */

static bfd_reloc_status_type
mips16_gprel_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;
  unsigned short extend, insn;
  unsigned long final;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    relocateable = true;
  else
    {
      relocateable = false;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf_final_gp (output_bfd, symbol, relocateable, error_message,
			   &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Pick up the mips16 extend instruction and the real instruction.  */
  extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);

  /* Stuff the current addend back as a 32 bit value, do the usual
     relocation, and then clean up.  */
  bfd_put_32 (abfd,
	      (bfd_vma) (((extend & 0x1f) << 11)
			 | (extend & 0x7e0)
			 | (insn & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address);

  ret = gprel16_with_gp (abfd, symbol, reloc_entry, input_section,
			 relocateable, data, gp);

  final = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((extend & 0xf800)
			 | ((final >> 11) & 0x1f)
			 | (final & 0x7e0)),
	      (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((insn & 0xffe0)
			 | (final & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address + 2);

  return ret;
}

/* Return the ISA for a MIPS e_flags value.  */

static INLINE int
elf_mips_isa (flags)
     flagword flags;
{
  switch (flags & EF_MIPS_ARCH)
    {
    case E_MIPS_ARCH_1:
      return 1;
    case E_MIPS_ARCH_2:
      return 2;
    case E_MIPS_ARCH_3:
      return 3;
    case E_MIPS_ARCH_4:
      return 4;
    case E_MIPS_ARCH_5:
      return 5;
    case E_MIPS_ARCH_32:
      return 32;
    case E_MIPS_ARCH_64:
      return 64;
    }
  return 4;
}

/* Return the MACH for a MIPS e_flags value.  */

static INLINE unsigned long
elf_mips_mach (flags)
     flagword flags;
{
  switch (flags & EF_MIPS_MACH)
    {
    case E_MIPS_MACH_3900:
      return bfd_mach_mips3900;

    case E_MIPS_MACH_4010:
      return bfd_mach_mips4010;

    case E_MIPS_MACH_4100:
      return bfd_mach_mips4100;

    case E_MIPS_MACH_4111:
      return bfd_mach_mips4111;

    case E_MIPS_MACH_4650:
      return bfd_mach_mips4650;

    case E_MIPS_MACH_SB1:
      return bfd_mach_mips_sb1;

    default:
      switch (flags & EF_MIPS_ARCH)
	{
	default:
	case E_MIPS_ARCH_1:
	  return bfd_mach_mips3000;
	  break;

	case E_MIPS_ARCH_2:
	  return bfd_mach_mips6000;
	  break;

	case E_MIPS_ARCH_3:
	  return bfd_mach_mips4000;
	  break;

	case E_MIPS_ARCH_4:
	  return bfd_mach_mips8000;
	  break;

	case E_MIPS_ARCH_5:
	  return bfd_mach_mips5;
	  break;

	case E_MIPS_ARCH_32:
	  return bfd_mach_mipsisa32;
	  break;

	case E_MIPS_ARCH_64:
	  return bfd_mach_mipsisa64;
	  break;
	}
    }

  return 0;
}

/* Return printable name for ABI.  */

static INLINE char *
elf_mips_abi_name (abfd)
     bfd *abfd;
{
  flagword flags;

  flags = elf_elfheader (abfd)->e_flags;
  switch (flags & EF_MIPS_ABI)
    {
    case 0:
      if (ABI_N32_P (abfd))
	return "N32";
      else if (ABI_64_P (abfd))
	return "64";
      else
	return "none";
    case E_MIPS_ABI_O32:
      return "O32";
    case E_MIPS_ABI_O64:
      return "O64";
    case E_MIPS_ABI_EABI32:
      return "EABI32";
    case E_MIPS_ABI_EABI64:
      return "EABI64";
    default:
      return "unknown abi";
    }
}

/* A mapping from BFD reloc types to MIPS ELF reloc types.  */

struct elf_reloc_map {
  bfd_reloc_code_real_type bfd_reloc_val;
  enum elf_mips_reloc_type elf_reloc_val;
};

static const struct elf_reloc_map mips_reloc_map[] =
{
  { BFD_RELOC_NONE, R_MIPS_NONE, },
  { BFD_RELOC_16, R_MIPS_16 },
  { BFD_RELOC_32, R_MIPS_32 },
  { BFD_RELOC_64, R_MIPS_64 },
  { BFD_RELOC_MIPS_JMP, R_MIPS_26 },
  { BFD_RELOC_HI16_S, R_MIPS_HI16 },
  { BFD_RELOC_LO16, R_MIPS_LO16 },
  { BFD_RELOC_GPREL16, R_MIPS_GPREL16 },
  { BFD_RELOC_MIPS_LITERAL, R_MIPS_LITERAL },
  { BFD_RELOC_MIPS_GOT16, R_MIPS_GOT16 },
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
  { BFD_RELOC_MIPS_CALL16, R_MIPS_CALL16 },
  { BFD_RELOC_GPREL32, R_MIPS_GPREL32 },
  { BFD_RELOC_MIPS_GOT_HI16, R_MIPS_GOT_HI16 },
  { BFD_RELOC_MIPS_GOT_LO16, R_MIPS_GOT_LO16 },
  { BFD_RELOC_MIPS_CALL_HI16, R_MIPS_CALL_HI16 },
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 },
  { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
  { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
  { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP }
};

/* Given a BFD reloc type, return a howto structure.  */

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
{
  unsigned int i;

  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map); i++)
    {
      if (mips_reloc_map[i].bfd_reloc_val == code)
	return &elf_mips_howto_table_rel[(int) mips_reloc_map[i].elf_reloc_val];
    }

  switch (code)
    {
    default:
      bfd_set_error (bfd_error_bad_value);
      return NULL;

    case BFD_RELOC_CTOR:
      /* We need to handle BFD_RELOC_CTOR specially.
	 Select the right relocation (R_MIPS_32 or R_MIPS_64) based on the
	 size of addresses on this architecture.  */
      if (bfd_arch_bits_per_address (abfd) == 32)
	return &elf_mips_howto_table_rel[(int) R_MIPS_32];
      else
	return &elf_mips_ctor64_howto;

    case BFD_RELOC_MIPS16_JMP:
      return &elf_mips16_jump_howto;
    case BFD_RELOC_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
    case BFD_RELOC_VTABLE_INHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf_mips_gnu_vtentry_howto;
    case BFD_RELOC_PCREL_HI16_S:
      return &elf_mips_gnu_rel_hi16;
    case BFD_RELOC_PCREL_LO16:
      return &elf_mips_gnu_rel_lo16;
    case BFD_RELOC_16_PCREL_S2:
      return &elf_mips_gnu_rel16_s2;
    case BFD_RELOC_64_PCREL:
      return &elf_mips_gnu_pcrel64;
    case BFD_RELOC_32_PCREL:
      return &elf_mips_gnu_pcrel32;
    }
}

/* Given a MIPS Elf32_Internal_Rel, fill in an arelent structure.  */

static reloc_howto_type *
mips_rtype_to_howto (r_type)
     unsigned int r_type;
{
  switch (r_type)
    {
    case R_MIPS16_26:
      return &elf_mips16_jump_howto;
      break;
    case R_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
      break;
    case R_MIPS_GNU_VTINHERIT:
      return &elf_mips_gnu_vtinherit_howto;
      break;
    case R_MIPS_GNU_VTENTRY:
      return &elf_mips_gnu_vtentry_howto;
      break;
    case R_MIPS_GNU_REL_HI16:
      return &elf_mips_gnu_rel_hi16;
      break;
    case R_MIPS_GNU_REL_LO16:
      return &elf_mips_gnu_rel_lo16;
      break;
    case R_MIPS_GNU_REL16_S2:
      return &elf_mips_gnu_rel16_s2;
      break;
    case R_MIPS_PC64:
      return &elf_mips_gnu_pcrel64;
      break;
    case R_MIPS_PC32:
      return &elf_mips_gnu_pcrel32;
      break;

    default:
      BFD_ASSERT (r_type < (unsigned int) R_MIPS_max);
      return &elf_mips_howto_table_rel[r_type];
      break;
    }
}

/* Given a MIPS Elf32_Internal_Rel, fill in an arelent structure.  */

static void
mips_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf32_Internal_Rel *dst;
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  cache_ptr->howto = mips_rtype_to_howto (r_type);

  /* The addend for a GPREL16 or LITERAL relocation comes from the GP
     value for the object file.  We get the addend now, rather than
     when we do the relocation, because the symbol manipulations done
     by the linker may cause us to lose track of the input BFD.  */
  if (((*cache_ptr->sym_ptr_ptr)->flags & BSF_SECTION_SYM) != 0
      && (r_type == (unsigned int) R_MIPS_GPREL16
	  || r_type == (unsigned int) R_MIPS_LITERAL))
    cache_ptr->addend = elf_gp (abfd);
}

/* Given a MIPS Elf32_Internal_Rela, fill in an arelent structure.  */

static void
mips_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf32_Internal_Rela *dst;
{
  /* Since an Elf32_Internal_Rel is an initial prefix of an
     Elf32_Internal_Rela, we can just use mips_info_to_howto_rel
     above.  */
  mips_info_to_howto_rel (abfd, cache_ptr, (Elf32_Internal_Rel *) dst);

  /* If we ever need to do any extra processing with dst->r_addend
     (the field omitted in an Elf32_Internal_Rel) we can do it here.  */
}

/* A .reginfo section holds a single Elf32_RegInfo structure.  These
   routines swap this structure in and out.  They are used outside of
   BFD, so they are globally visible.  */

void
bfd_mips_elf32_swap_reginfo_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_RegInfo *ex;
     Elf32_RegInfo *in;
{
  in->ri_gprmask = H_GET_32 (abfd, ex->ri_gprmask);
  in->ri_cprmask[0] = H_GET_32 (abfd, ex->ri_cprmask[0]);
  in->ri_cprmask[1] = H_GET_32 (abfd, ex->ri_cprmask[1]);
  in->ri_cprmask[2] = H_GET_32 (abfd, ex->ri_cprmask[2]);
  in->ri_cprmask[3] = H_GET_32 (abfd, ex->ri_cprmask[3]);
  in->ri_gp_value = H_GET_32 (abfd, ex->ri_gp_value);
}

void
bfd_mips_elf32_swap_reginfo_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_RegInfo *in;
     Elf32_External_RegInfo *ex;
{
  H_PUT_32 (abfd, in->ri_gprmask, ex->ri_gprmask);
  H_PUT_32 (abfd, in->ri_cprmask[0], ex->ri_cprmask[0]);
  H_PUT_32 (abfd, in->ri_cprmask[1], ex->ri_cprmask[1]);
  H_PUT_32 (abfd, in->ri_cprmask[2], ex->ri_cprmask[2]);
  H_PUT_32 (abfd, in->ri_cprmask[3], ex->ri_cprmask[3]);
  H_PUT_32 (abfd, in->ri_gp_value, ex->ri_gp_value);
}

/* In the 64 bit ABI, the .MIPS.options section holds register
   information in an Elf64_Reginfo structure.  These routines swap
   them in and out.  They are globally visible because they are used
   outside of BFD.  These routines are here so that gas can call them
   without worrying about whether the 64 bit ABI has been included.  */

void
bfd_mips_elf64_swap_reginfo_in (abfd, ex, in)
     bfd *abfd;
     const Elf64_External_RegInfo *ex;
     Elf64_Internal_RegInfo *in;
{
  in->ri_gprmask = H_GET_32 (abfd, ex->ri_gprmask);
  in->ri_pad = H_GET_32 (abfd, ex->ri_pad);
  in->ri_cprmask[0] = H_GET_32 (abfd, ex->ri_cprmask[0]);
  in->ri_cprmask[1] = H_GET_32 (abfd, ex->ri_cprmask[1]);
  in->ri_cprmask[2] = H_GET_32 (abfd, ex->ri_cprmask[2]);
  in->ri_cprmask[3] = H_GET_32 (abfd, ex->ri_cprmask[3]);
  in->ri_gp_value = H_GET_64 (abfd, ex->ri_gp_value);
}

void
bfd_mips_elf64_swap_reginfo_out (abfd, in, ex)
     bfd *abfd;
     const Elf64_Internal_RegInfo *in;
     Elf64_External_RegInfo *ex;
{
  H_PUT_32 (abfd, in->ri_gprmask, ex->ri_gprmask);
  H_PUT_32 (abfd, in->ri_pad, ex->ri_pad);
  H_PUT_32 (abfd, in->ri_cprmask[0], ex->ri_cprmask[0]);
  H_PUT_32 (abfd, in->ri_cprmask[1], ex->ri_cprmask[1]);
  H_PUT_32 (abfd, in->ri_cprmask[2], ex->ri_cprmask[2]);
  H_PUT_32 (abfd, in->ri_cprmask[3], ex->ri_cprmask[3]);
  H_PUT_64 (abfd, in->ri_gp_value, ex->ri_gp_value);
}

/* Swap an entry in a .gptab section.  Note that these routines rely
   on the equivalence of the two elements of the union.  */

static void
bfd_mips_elf32_swap_gptab_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_gptab *ex;
     Elf32_gptab *in;
{
  in->gt_entry.gt_g_value = H_GET_32 (abfd, ex->gt_entry.gt_g_value);
  in->gt_entry.gt_bytes = H_GET_32 (abfd, ex->gt_entry.gt_bytes);
}

static void
bfd_mips_elf32_swap_gptab_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_gptab *in;
     Elf32_External_gptab *ex;
{
  H_PUT_32 (abfd, in->gt_entry.gt_g_value, ex->gt_entry.gt_g_value);
  H_PUT_32 (abfd, in->gt_entry.gt_bytes, ex->gt_entry.gt_bytes);
}

static void
bfd_elf32_swap_compact_rel_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_compact_rel *in;
     Elf32_External_compact_rel *ex;
{
  H_PUT_32 (abfd, in->id1, ex->id1);
  H_PUT_32 (abfd, in->num, ex->num);
  H_PUT_32 (abfd, in->id2, ex->id2);
  H_PUT_32 (abfd, in->offset, ex->offset);
  H_PUT_32 (abfd, in->reserved0, ex->reserved0);
  H_PUT_32 (abfd, in->reserved1, ex->reserved1);
}

static void
bfd_elf32_swap_crinfo_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_crinfo *in;
     Elf32_External_crinfo *ex;
{
  unsigned long l;

  l = (((in->ctype & CRINFO_CTYPE) << CRINFO_CTYPE_SH)
       | ((in->rtype & CRINFO_RTYPE) << CRINFO_RTYPE_SH)
       | ((in->dist2to & CRINFO_DIST2TO) << CRINFO_DIST2TO_SH)
       | ((in->relvaddr & CRINFO_RELVADDR) << CRINFO_RELVADDR_SH));
  H_PUT_32 (abfd, l, ex->info);
  H_PUT_32 (abfd, in->konst, ex->konst);
  H_PUT_32 (abfd, in->vaddr, ex->vaddr);
}

/* Swap in an options header.  */

void
bfd_mips_elf_swap_options_in (abfd, ex, in)
     bfd *abfd;
     const Elf_External_Options *ex;
     Elf_Internal_Options *in;
{
  in->kind = H_GET_8 (abfd, ex->kind);
  in->size = H_GET_8 (abfd, ex->size);
  in->section = H_GET_16 (abfd, ex->section);
  in->info = H_GET_32 (abfd, ex->info);
}

/* Swap out an options header.  */

void
bfd_mips_elf_swap_options_out (abfd, in, ex)
     bfd *abfd;
     const Elf_Internal_Options *in;
     Elf_External_Options *ex;
{
  H_PUT_8 (abfd, in->kind, ex->kind);
  H_PUT_8 (abfd, in->size, ex->size);
  H_PUT_16 (abfd, in->section, ex->section);
  H_PUT_32 (abfd, in->info, ex->info);
}
#if 0
/* Swap in an MSYM entry.  */

static void
bfd_mips_elf_swap_msym_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_Msym *ex;
     Elf32_Internal_Msym *in;
{
  in->ms_hash_value = H_GET_32 (abfd, ex->ms_hash_value);
  in->ms_info = H_GET_32 (abfd, ex->ms_info);
}
#endif
/* Swap out an MSYM entry.  */

static void
bfd_mips_elf_swap_msym_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_Internal_Msym *in;
     Elf32_External_Msym *ex;
{
  H_PUT_32 (abfd, in->ms_hash_value, ex->ms_hash_value);
  H_PUT_32 (abfd, in->ms_info, ex->ms_info);
}

/* Determine whether a symbol is global for the purposes of splitting
   the symbol table into global symbols and local symbols.  At least
   on Irix 5, this split must be between section symbols and all other
   symbols.  On most ELF targets the split is between static symbols
   and externally visible symbols.  */

static boolean
mips_elf_sym_is_global (abfd, sym)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *sym;
{
  if (SGI_COMPAT (abfd))
    return (sym->flags & BSF_SECTION_SYM) == 0;
  else
    return ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
	    || bfd_is_und_section (bfd_get_section (sym))
	    || bfd_is_com_section (bfd_get_section (sym)));
}

/* Set the right machine number for a MIPS ELF file.  This is used for
   both the 32-bit and the 64-bit ABI.  */

boolean
_bfd_mips_elf_object_p (abfd)
     bfd *abfd;
{
  /* Irix 5 and 6 are broken.  Object file symbol tables are not always
     sorted correctly such that local symbols precede global symbols,
     and the sh_info field in the symbol table is not always right.  */
  if (SGI_COMPAT(abfd))
    elf_bad_symtab (abfd) = true;

  bfd_default_set_arch_mach (abfd, bfd_arch_mips,
			     elf_mips_mach (elf_elfheader (abfd)->e_flags));
  return true;
}

/* The final processing done just before writing out a MIPS ELF object
   file.  This gets the MIPS architecture right based on the machine
   number.  This is used by both the 32-bit and the 64-bit ABI.  */

void
_bfd_mips_elf_final_write_processing (abfd, linker)
     bfd *abfd;
     boolean linker ATTRIBUTE_UNUSED;
{
  unsigned long val;
  unsigned int i;
  Elf_Internal_Shdr **hdrpp;
  const char *name;
  asection *sec;

  switch (bfd_get_mach (abfd))
    {
    default:
    case bfd_mach_mips3000:
      val = E_MIPS_ARCH_1;
      break;

    case bfd_mach_mips3900:
      val = E_MIPS_ARCH_1 | E_MIPS_MACH_3900;
      break;

    case bfd_mach_mips6000:
      val = E_MIPS_ARCH_2;
      break;

    case bfd_mach_mips4000:
    case bfd_mach_mips4300:
    case bfd_mach_mips4400:
    case bfd_mach_mips4600:
      val = E_MIPS_ARCH_3;
      break;

    case bfd_mach_mips4010:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4010;
      break;

    case bfd_mach_mips4100:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4100;
      break;

    case bfd_mach_mips4111:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4111;
      break;

    case bfd_mach_mips4650:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4650;
      break;

    case bfd_mach_mips5000:
    case bfd_mach_mips8000:
    case bfd_mach_mips10000:
    case bfd_mach_mips12000:
      val = E_MIPS_ARCH_4;
      break;

    case bfd_mach_mips5:
      val = E_MIPS_ARCH_5;
      break;

    case bfd_mach_mips_sb1:
      val = E_MIPS_ARCH_64 | E_MIPS_MACH_SB1;
      break;

    case bfd_mach_mipsisa32:
      val = E_MIPS_ARCH_32;
      break;

    case bfd_mach_mipsisa64:
      val = E_MIPS_ARCH_64;
    }

  elf_elfheader (abfd)->e_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
  elf_elfheader (abfd)->e_flags |= val;

  /* Set the sh_info field for .gptab sections and other appropriate
     info for each special section.  */
  for (i = 1, hdrpp = elf_elfsections (abfd) + 1;
       i < elf_numsections (abfd);
       i++, hdrpp++)
    {
      switch ((*hdrpp)->sh_type)
	{
	case SHT_MIPS_MSYM:
	case SHT_MIPS_LIBLIST:
	  sec = bfd_get_section_by_name (abfd, ".dynstr");
	  if (sec != NULL)
	    (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_GPTAB:
	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
	  BFD_ASSERT (name != NULL
		      && strncmp (name, ".gptab.", sizeof ".gptab." - 1) == 0);
	  sec = bfd_get_section_by_name (abfd, name + sizeof ".gptab" - 1);
	  BFD_ASSERT (sec != NULL);
	  (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_CONTENT:
	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
	  BFD_ASSERT (name != NULL
		      && strncmp (name, ".MIPS.content",
				  sizeof ".MIPS.content" - 1) == 0);
	  sec = bfd_get_section_by_name (abfd,
					 name + sizeof ".MIPS.content" - 1);
	  BFD_ASSERT (sec != NULL);
	  (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_SYMBOL_LIB:
	  sec = bfd_get_section_by_name (abfd, ".dynsym");
	  if (sec != NULL)
	    (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  sec = bfd_get_section_by_name (abfd, ".liblist");
	  if (sec != NULL)
	    (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_EVENTS:
	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
	  BFD_ASSERT (name != NULL);
	  if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) == 0)
	    sec = bfd_get_section_by_name (abfd,
					   name + sizeof ".MIPS.events" - 1);
	  else
	    {
	      BFD_ASSERT (strncmp (name, ".MIPS.post_rel",
				   sizeof ".MIPS.post_rel" - 1) == 0);
	      sec = bfd_get_section_by_name (abfd,
					     (name
					      + sizeof ".MIPS.post_rel" - 1));
	    }
	  BFD_ASSERT (sec != NULL);
	  (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  break;

	}
    }
}

/* Function to keep MIPS specific file flags like as EF_MIPS_PIC.  */

boolean
_bfd_mips_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = true;
  return true;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

boolean
_bfd_mips_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  flagword old_flags;
  flagword new_flags;
  boolean ok;
  boolean null_input_bfd = true;
  asection *sec;

  /* Check if we have the same endianess */
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
    return false;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  new_flags = elf_elfheader (ibfd)->e_flags;
  elf_elfheader (obfd)->e_flags |= new_flags & EF_MIPS_NOREORDER;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (! elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = true;
      elf_elfheader (obfd)->e_flags = new_flags;
      elf_elfheader (obfd)->e_ident[EI_CLASS]
	= elf_elfheader (ibfd)->e_ident[EI_CLASS];

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	{
	  if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
				   bfd_get_mach (ibfd)))
	    return false;
	}

      return true;
    }

  /* Check flag compatibility.  */

  new_flags &= ~EF_MIPS_NOREORDER;
  old_flags &= ~EF_MIPS_NOREORDER;

  if (new_flags == old_flags)
    return true;

  /* Check to see if the input BFD actually contains any sections.
     If not, its flags may not have been initialised either, but it cannot
     actually cause any incompatibility.  */
  for (sec = ibfd->sections; sec != NULL; sec = sec->next)
    {
      /* Ignore synthetic sections and empty .text, .data and .bss sections
	  which are automatically generated by gas.  */
      if (strcmp (sec->name, ".reginfo")
	  && strcmp (sec->name, ".mdebug")
	  && ((!strcmp (sec->name, ".text")
	       || !strcmp (sec->name, ".data")
	       || !strcmp (sec->name, ".bss"))
	      && sec->_raw_size != 0))
	{
	  null_input_bfd = false;
	  break;
	}
    }
  if (null_input_bfd)
    return true;

  ok = true;

  if ((new_flags & EF_MIPS_PIC) != (old_flags & EF_MIPS_PIC))
    {
      new_flags &= ~EF_MIPS_PIC;
      old_flags &= ~EF_MIPS_PIC;
      (*_bfd_error_handler)
	(_("%s: linking PIC files with non-PIC files"),
	 bfd_archive_filename (ibfd));
      ok = false;
    }

  if ((new_flags & EF_MIPS_CPIC) != (old_flags & EF_MIPS_CPIC))
    {
      new_flags &= ~EF_MIPS_CPIC;
      old_flags &= ~EF_MIPS_CPIC;
      (*_bfd_error_handler)
	(_("%s: linking abicalls files with non-abicalls files"),
	 bfd_archive_filename (ibfd));
      ok = false;
    }

  /* Compare the ISA's.  */
  if ((new_flags & (EF_MIPS_ARCH | EF_MIPS_MACH))
      != (old_flags & (EF_MIPS_ARCH | EF_MIPS_MACH)))
    {
      int new_mach = new_flags & EF_MIPS_MACH;
      int old_mach = old_flags & EF_MIPS_MACH;
      int new_isa = elf_mips_isa (new_flags);
      int old_isa = elf_mips_isa (old_flags);

      /* If either has no machine specified, just compare the general isa's.
	 Some combinations of machines are ok, if the isa's match.  */
      if (! new_mach
	  || ! old_mach
	  || new_mach == old_mach
	  )
	{
	  /* Don't warn about mixing code using 32-bit ISAs, or mixing code
	     using 64-bit ISAs.  They will normally use the same data sizes
	     and calling conventions.  */

	  if ((  (new_isa == 1 || new_isa == 2 || new_isa == 32)
	       ^ (old_isa == 1 || old_isa == 2 || old_isa == 32)) != 0)
	    {
	      (*_bfd_error_handler)
	       (_("%s: ISA mismatch (-mips%d) with previous modules (-mips%d)"),
		bfd_archive_filename (ibfd), new_isa, old_isa);
	      ok = false;
	    }
	  else
	    {
	      /* Do we need to update the mach field?  */
	      if (old_mach == 0 && new_mach != 0) 
		elf_elfheader (obfd)->e_flags |= new_mach;

	      /* Do we need to update the ISA field?  */
	      if (new_isa > old_isa)
		{
		  elf_elfheader (obfd)->e_flags &= ~EF_MIPS_ARCH;
		  elf_elfheader (obfd)->e_flags
		    |= new_flags & EF_MIPS_ARCH;
		}
	    }
	}
      else
	{
	  (*_bfd_error_handler)
	    (_("%s: ISA mismatch (%d) with previous modules (%d)"),
	     bfd_archive_filename (ibfd),
	     elf_mips_mach (new_flags),
	     elf_mips_mach (old_flags));
	  ok = false;
	}

      new_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
      old_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
    }

  /* Compare ABI's.  The 64-bit ABI does not use EF_MIPS_ABI.  But, it
     does set EI_CLASS differently from any 32-bit ABI.  */
  if ((new_flags & EF_MIPS_ABI) != (old_flags & EF_MIPS_ABI)
      || (elf_elfheader (ibfd)->e_ident[EI_CLASS]
	  != elf_elfheader (obfd)->e_ident[EI_CLASS]))
    {
      /* Only error if both are set (to different values).  */
      if (((new_flags & EF_MIPS_ABI) && (old_flags & EF_MIPS_ABI))
	  || (elf_elfheader (ibfd)->e_ident[EI_CLASS]
	      != elf_elfheader (obfd)->e_ident[EI_CLASS]))
	{
	  (*_bfd_error_handler)
	    (_("%s: ABI mismatch: linking %s module with previous %s modules"),
	     bfd_archive_filename (ibfd),
	     elf_mips_abi_name (ibfd),
	     elf_mips_abi_name (obfd));
	  ok = false;
	}
      new_flags &= ~EF_MIPS_ABI;
      old_flags &= ~EF_MIPS_ABI;
    }

  /* Warn about any other mismatches */
  if (new_flags != old_flags)
    {
      (*_bfd_error_handler)
	(_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
	 bfd_archive_filename (ibfd), (unsigned long) new_flags,
	 (unsigned long) old_flags);
      ok = false;
    }

  if (! ok)
    {
      bfd_set_error (bfd_error_bad_value);
      return false;
    }

  return true;
}

boolean
_bfd_mips_elf_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
{
  FILE *file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_O32)
    fprintf (file, _(" [abi=O32]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_O64)
    fprintf (file, _(" [abi=O64]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI32)
    fprintf (file, _(" [abi=EABI32]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI64)
    fprintf (file, _(" [abi=EABI64]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI))
    fprintf (file, _(" [abi unknown]"));
  else if (ABI_N32_P (abfd))
    fprintf (file, _(" [abi=N32]"));
  else if (ABI_64_P (abfd))
    fprintf (file, _(" [abi=64]"));
  else
    fprintf (file, _(" [no abi set]"));

  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_1)
    fprintf (file, _(" [mips1]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_2)
    fprintf (file, _(" [mips2]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_3)
    fprintf (file, _(" [mips3]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_4)
    fprintf (file, _(" [mips4]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_5)
    fprintf (file, _(" [mips5]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32)
    fprintf (file, _(" [mips32]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_64)
    fprintf (file, _(" [mips64]"));
  else
    fprintf (file, _(" [unknown ISA]"));

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_32BITMODE)
    fprintf (file, _(" [32bitmode]"));
  else
    fprintf (file, _(" [not 32bitmode]"));

  fputc ('\n', file);

  return true;
}

/* Handle a MIPS specific section when reading an object file.  This
   is called when elfcode.h finds a section with an unknown type.
   This routine supports both the 32-bit and 64-bit ELF ABI.

   FIXME: We need to handle the SHF_MIPS_GPREL flag, but I'm not sure
   how to.  */

boolean
_bfd_mips_elf_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     char *name;
{
  flagword flags = 0;

  /* There ought to be a place to keep ELF backend specific flags, but
     at the moment there isn't one.  We just keep track of the
     sections by their name, instead.  Fortunately, the ABI gives
     suggested names for all the MIPS specific sections, so we will
     probably get away with this.  */
  switch (hdr->sh_type)
    {
    case SHT_MIPS_LIBLIST:
      if (strcmp (name, ".liblist") != 0)
	return false;
      break;
    case SHT_MIPS_MSYM:
      if (strcmp (name, MIPS_ELF_MSYM_SECTION_NAME (abfd)) != 0)
	return false;
      break;
    case SHT_MIPS_CONFLICT:
      if (strcmp (name, ".conflict") != 0)
	return false;
      break;
    case SHT_MIPS_GPTAB:
      if (strncmp (name, ".gptab.", sizeof ".gptab." - 1) != 0)
	return false;
      break;
    case SHT_MIPS_UCODE:
      if (strcmp (name, ".ucode") != 0)
	return false;
      break;
    case SHT_MIPS_DEBUG:
      if (strcmp (name, ".mdebug") != 0)
	return false;
      flags = SEC_DEBUGGING;
      break;
    case SHT_MIPS_REGINFO:
      if (strcmp (name, ".reginfo") != 0
	  || hdr->sh_size != sizeof (Elf32_External_RegInfo))
	return false;
      flags = (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_SAME_SIZE);
      break;
    case SHT_MIPS_IFACE:
      if (strcmp (name, ".MIPS.interfaces") != 0)
	return false;
      break;
    case SHT_MIPS_CONTENT:
      if (strncmp (name, ".MIPS.content", sizeof ".MIPS.content" - 1) != 0)
	return false;
      break;
    case SHT_MIPS_OPTIONS:
      if (strcmp (name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) != 0)
	return false;
      break;
    case SHT_MIPS_DWARF:
      if (strncmp (name, ".debug_", sizeof ".debug_" - 1) != 0)
	return false;
      break;
    case SHT_MIPS_SYMBOL_LIB:
      if (strcmp (name, ".MIPS.symlib") != 0)
	return false;
      break;
    case SHT_MIPS_EVENTS:
      if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) != 0
	  && strncmp (name, ".MIPS.post_rel",
		      sizeof ".MIPS.post_rel" - 1) != 0)
	return false;
      break;
    default:
      return false;
    }

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
    return false;

  if (flags)
    {
      if (! bfd_set_section_flags (abfd, hdr->bfd_section,
				   (bfd_get_section_flags (abfd,
							   hdr->bfd_section)
				    | flags)))
	return false;
    }

  /* FIXME: We should record sh_info for a .gptab section.  */

  /* For a .reginfo section, set the gp value in the tdata information
     from the contents of this section.  We need the gp value while
     processing relocs, so we just get it now.  The .reginfo section
     is not used in the 64-bit MIPS ELF ABI.  */
  if (hdr->sh_type == SHT_MIPS_REGINFO)
    {
      Elf32_External_RegInfo ext;
      Elf32_RegInfo s;

      if (! bfd_get_section_contents (abfd, hdr->bfd_section, (PTR) &ext,
				      (file_ptr) 0,
				      (bfd_size_type) sizeof ext))
	return false;
      bfd_mips_elf32_swap_reginfo_in (abfd, &ext, &s);
      elf_gp (abfd) = s.ri_gp_value;
    }

  /* For a SHT_MIPS_OPTIONS section, look for a ODK_REGINFO entry, and
     set the gp value based on what we find.  We may see both
     SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS/ODK_REGINFO; in that case,
     they should agree.  */
  if (hdr->sh_type == SHT_MIPS_OPTIONS)
    {
      bfd_byte *contents, *l, *lend;

      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	return false;
      if (! bfd_get_section_contents (abfd, hdr->bfd_section, contents,
				      (file_ptr) 0, hdr->sh_size))
	{
	  free (contents);
	  return false;
	}
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (ABI_64_P (abfd) && intopt.kind == ODK_REGINFO)
	    {
	      Elf64_Internal_RegInfo intreg;

	      bfd_mips_elf64_swap_reginfo_in
		(abfd,
		 ((Elf64_External_RegInfo *)
		  (l + sizeof (Elf_External_Options))),
		 &intreg);
	      elf_gp (abfd) = intreg.ri_gp_value;
	    }
	  else if (intopt.kind == ODK_REGINFO)
	    {
	      Elf32_RegInfo intreg;

	      bfd_mips_elf32_swap_reginfo_in
		(abfd,
		 ((Elf32_External_RegInfo *)
		  (l + sizeof (Elf_External_Options))),
		 &intreg);
	      elf_gp (abfd) = intreg.ri_gp_value;
	    }
	  l += intopt.size;
	}
      free (contents);
    }

  return true;
}

/* Set the correct type for a MIPS ELF section.  We do this by the
   section name, which is a hack, but ought to work.  This routine is
   used by both the 32-bit and the 64-bit ABI.  */

boolean
_bfd_mips_elf_fake_sections (abfd, hdr, sec)
     bfd *abfd;
     Elf32_Internal_Shdr *hdr;
     asection *sec;
{
  register const char *name;

  name = bfd_get_section_name (abfd, sec);

  if (strcmp (name, ".liblist") == 0)
    {
      hdr->sh_type = SHT_MIPS_LIBLIST;
      hdr->sh_info = sec->_raw_size / sizeof (Elf32_Lib);
      /* The sh_link field is set in final_write_processing.  */
    }
  else if (strcmp (name, ".conflict") == 0)
    hdr->sh_type = SHT_MIPS_CONFLICT;
  else if (strncmp (name, ".gptab.", sizeof ".gptab." - 1) == 0)
    {
      hdr->sh_type = SHT_MIPS_GPTAB;
      hdr->sh_entsize = sizeof (Elf32_External_gptab);
      /* The sh_info field is set in final_write_processing.  */
    }
  else if (strcmp (name, ".ucode") == 0)
    hdr->sh_type = SHT_MIPS_UCODE;
  else if (strcmp (name, ".mdebug") == 0)
    {
      hdr->sh_type = SHT_MIPS_DEBUG;
      /* In a shared object on Irix 5.3, the .mdebug section has an
         entsize of 0.  FIXME: Does this matter?  */
      if (SGI_COMPAT (abfd) && (abfd->flags & DYNAMIC) != 0)
	hdr->sh_entsize = 0;
      else
	hdr->sh_entsize = 1;
    }
  else if (strcmp (name, ".reginfo") == 0)
    {
      hdr->sh_type = SHT_MIPS_REGINFO;
      /* In a shared object on Irix 5.3, the .reginfo section has an
         entsize of 0x18.  FIXME: Does this matter?  */
      if (SGI_COMPAT (abfd))
	{
	  if ((abfd->flags & DYNAMIC) != 0)
	    hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
	  else
	    hdr->sh_entsize = 1;
	}
      else
	hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
    }
  else if (SGI_COMPAT (abfd)
	   && (strcmp (name, ".hash") == 0
	       || strcmp (name, ".dynamic") == 0
	       || strcmp (name, ".dynstr") == 0))
    {
      if (SGI_COMPAT (abfd))
	hdr->sh_entsize = 0;
#if 0
      /* This isn't how the Irix 6 linker behaves.  */
      hdr->sh_info = SIZEOF_MIPS_DYNSYM_SECNAMES;
#endif
    }
  else if (strcmp (name, ".got") == 0
	   || strcmp (name, MIPS_ELF_SRDATA_SECTION_NAME (abfd)) == 0
	   || strcmp (name, ".sdata") == 0
	   || strcmp (name, ".sbss") == 0
	   || strcmp (name, ".lit4") == 0
	   || strcmp (name, ".lit8") == 0)
    hdr->sh_flags |= SHF_MIPS_GPREL;
  else if (strcmp (name, ".MIPS.interfaces") == 0)
    {
      hdr->sh_type = SHT_MIPS_IFACE;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
    }
  else if (strncmp (name, ".MIPS.content", strlen (".MIPS.content")) == 0)
    {
      hdr->sh_type = SHT_MIPS_CONTENT;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
      /* The sh_info field is set in final_write_processing.  */
    }
  else if (strcmp (name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
    {
      hdr->sh_type = SHT_MIPS_OPTIONS;
      hdr->sh_entsize = 1;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
    }
  else if (strncmp (name, ".debug_", sizeof ".debug_" - 1) == 0)
    hdr->sh_type = SHT_MIPS_DWARF;
  else if (strcmp (name, ".MIPS.symlib") == 0)
    {
      hdr->sh_type = SHT_MIPS_SYMBOL_LIB;
      /* The sh_link and sh_info fields are set in
         final_write_processing.  */
    }
  else if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) == 0
	   || strncmp (name, ".MIPS.post_rel",
		       sizeof ".MIPS.post_rel" - 1) == 0)
    {
      hdr->sh_type = SHT_MIPS_EVENTS;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
      /* The sh_link field is set in final_write_processing.  */
    }
  else if (strcmp (name, MIPS_ELF_MSYM_SECTION_NAME (abfd)) == 0)
    {
      hdr->sh_type = SHT_MIPS_MSYM;
      hdr->sh_flags |= SHF_ALLOC;
      hdr->sh_entsize = 8;
    }

  /* The generic elf_fake_sections will set up REL_HDR using the
     default kind of relocations.  But, we may actually need both
     kinds of relocations, so we set up the second header here.

     This is not necessary for the O32 ABI since that only uses Elf32_Rel
     relocations (cf. System V ABI, MIPS RISC Processor Supplement,
     3rd Edition, p. 4-17).  It breaks the IRIX 5/6 32-bit ld, since one
     of the resulting empty .rela.<section> sections starts with
     sh_offset == object size, and ld doesn't allow that.  While the check
     is arguably bogus for empty or SHT_NOBITS sections, it can easily be
     avoided by not emitting those useless sections in the first place.  */
  if (IRIX_COMPAT (abfd) != ict_irix5 && (sec->flags & SEC_RELOC) != 0)
    {
      struct bfd_elf_section_data *esd;
      bfd_size_type amt = sizeof (Elf_Internal_Shdr);

      esd = elf_section_data (sec);
      BFD_ASSERT (esd->rel_hdr2 == NULL);
      esd->rel_hdr2 = (Elf_Internal_Shdr *) bfd_zalloc (abfd, amt);
      if (!esd->rel_hdr2)
	return false;
      _bfd_elf_init_reloc_shdr (abfd, esd->rel_hdr2, sec,
				!elf_section_data (sec)->use_rela_p);
    }

  return true;
}

/* Given a BFD section, try to locate the corresponding ELF section
   index.  This is used by both the 32-bit and the 64-bit ABI.
   Actually, it's not clear to me that the 64-bit ABI supports these,
   but for non-PIC objects we will certainly want support for at least
   the .scommon section.  */

boolean
_bfd_mips_elf_section_from_bfd_section (abfd, sec, retval)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     int *retval;
{
  if (strcmp (bfd_get_section_name (abfd, sec), ".scommon") == 0)
    {
      *retval = SHN_MIPS_SCOMMON;
      return true;
    }
  if (strcmp (bfd_get_section_name (abfd, sec), ".acommon") == 0)
    {
      *retval = SHN_MIPS_ACOMMON;
      return true;
    }
  return false;
}

/* When are writing out the .options or .MIPS.options section,
   remember the bytes we are writing out, so that we can install the
   GP value in the section_processing routine.  */

boolean
_bfd_mips_elf_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
{
  if (strcmp (section->name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
    {
      bfd_byte *c;

      if (elf_section_data (section) == NULL)
	{
	  bfd_size_type amt = sizeof (struct bfd_elf_section_data);
	  section->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
	  if (elf_section_data (section) == NULL)
	    return false;
	}
      c = (bfd_byte *) elf_section_data (section)->tdata;
      if (c == NULL)
	{
	  bfd_size_type size;

	  if (section->_cooked_size != 0)
	    size = section->_cooked_size;
	  else
	    size = section->_raw_size;
	  c = (bfd_byte *) bfd_zalloc (abfd, size);
	  if (c == NULL)
	    return false;
	  elf_section_data (section)->tdata = (PTR) c;
	}

      memcpy (c + offset, location, (size_t) count);
    }

  return _bfd_elf_set_section_contents (abfd, section, location, offset,
					count);
}

/* Work over a section just before writing it out.  This routine is
   used by both the 32-bit and the 64-bit ABI.  FIXME: We recognize
   sections that need the SHF_MIPS_GPREL flag by name; there has to be
   a better way.  */

boolean
_bfd_mips_elf_section_processing (abfd, hdr)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
{
  if (hdr->sh_type == SHT_MIPS_REGINFO
      && hdr->sh_size > 0)
    {
      bfd_byte buf[4];

      BFD_ASSERT (hdr->sh_size == sizeof (Elf32_External_RegInfo));
      BFD_ASSERT (hdr->contents == NULL);

      if (bfd_seek (abfd,
		    hdr->sh_offset + sizeof (Elf32_External_RegInfo) - 4,
		    SEEK_SET) != 0)
	return false;
      H_PUT_32 (abfd, elf_gp (abfd), buf);
      if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
	return false;
    }

  if (hdr->sh_type == SHT_MIPS_OPTIONS
      && hdr->bfd_section != NULL
      && elf_section_data (hdr->bfd_section) != NULL
      && elf_section_data (hdr->bfd_section)->tdata != NULL)
    {
      bfd_byte *contents, *l, *lend;

      /* We stored the section contents in the elf_section_data tdata
	 field in the set_section_contents routine.  We save the
	 section contents so that we don't have to read them again.
	 At this point we know that elf_gp is set, so we can look
	 through the section contents to see if there is an
	 ODK_REGINFO structure.  */

      contents = (bfd_byte *) elf_section_data (hdr->bfd_section)->tdata;
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (ABI_64_P (abfd) && intopt.kind == ODK_REGINFO)
	    {
	      bfd_byte buf[8];

	      if (bfd_seek (abfd,
			    (hdr->sh_offset
			     + (l - contents)
			     + sizeof (Elf_External_Options)
			     + (sizeof (Elf64_External_RegInfo) - 8)),
			     SEEK_SET) != 0)
		return false;
	      H_PUT_64 (abfd, elf_gp (abfd), buf);
	      if (bfd_bwrite (buf, (bfd_size_type) 8, abfd) != 8)
		return false;
	    }
	  else if (intopt.kind == ODK_REGINFO)
	    {
	      bfd_byte buf[4];

	      if (bfd_seek (abfd,
			    (hdr->sh_offset
			     + (l - contents)
			     + sizeof (Elf_External_Options)
			     + (sizeof (Elf32_External_RegInfo) - 4)),
			    SEEK_SET) != 0)
		return false;
	      H_PUT_32 (abfd, elf_gp (abfd), buf);
	      if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
		return false;
	    }
	  l += intopt.size;
	}
    }

  if (hdr->bfd_section != NULL)
    {
      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);

      if (strcmp (name, ".sdata") == 0
	  || strcmp (name, ".lit8") == 0
	  || strcmp (name, ".lit4") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".sbss") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_NOBITS;
	}
      else if (strcmp (name, MIPS_ELF_SRDATA_SECTION_NAME (abfd)) == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".compact_rel") == 0)
	{
	  hdr->sh_flags = 0;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".rtproc") == 0)
	{
	  if (hdr->sh_addralign != 0 && hdr->sh_entsize == 0)
	    {
	      unsigned int adjust;

	      adjust = hdr->sh_size % hdr->sh_addralign;
	      if (adjust != 0)
		hdr->sh_size += hdr->sh_addralign - adjust;
	    }
	}
    }

  return true;
}

/* MIPS ELF uses two common sections.  One is the usual one, and the
   other is for small objects.  All the small objects are kept
   together, and then referenced via the gp pointer, which yields
   faster assembler code.  This is what we use for the small common
   section.  This approach is copied from ecoff.c.  */
static asection mips_elf_scom_section;
static asymbol mips_elf_scom_symbol;
static asymbol *mips_elf_scom_symbol_ptr;

/* MIPS ELF also uses an acommon section, which represents an
   allocated common symbol which may be overridden by a
   definition in a shared library.  */
static asection mips_elf_acom_section;
static asymbol mips_elf_acom_symbol;
static asymbol *mips_elf_acom_symbol_ptr;

/* Handle the special MIPS section numbers that a symbol may use.
   This is used for both the 32-bit and the 64-bit ABI.  */

void
_bfd_mips_elf_symbol_processing (abfd, asym)
     bfd *abfd;
     asymbol *asym;
{
  elf_symbol_type *elfsym;

  elfsym = (elf_symbol_type *) asym;
  switch (elfsym->internal_elf_sym.st_shndx)
    {
    case SHN_MIPS_ACOMMON:
      /* This section is used in a dynamically linked executable file.
	 It is an allocated common section.  The dynamic linker can
	 either resolve these symbols to something in a shared
	 library, or it can just leave them here.  For our purposes,
	 we can consider these symbols to be in a new section.  */
      if (mips_elf_acom_section.name == NULL)
	{
	  /* Initialize the acommon section.  */
	  mips_elf_acom_section.name = ".acommon";
	  mips_elf_acom_section.flags = SEC_ALLOC;
	  mips_elf_acom_section.output_section = &mips_elf_acom_section;
	  mips_elf_acom_section.symbol = &mips_elf_acom_symbol;
	  mips_elf_acom_section.symbol_ptr_ptr = &mips_elf_acom_symbol_ptr;
	  mips_elf_acom_symbol.name = ".acommon";
	  mips_elf_acom_symbol.flags = BSF_SECTION_SYM;
	  mips_elf_acom_symbol.section = &mips_elf_acom_section;
	  mips_elf_acom_symbol_ptr = &mips_elf_acom_symbol;
	}
      asym->section = &mips_elf_acom_section;
      break;

    case SHN_COMMON:
      /* Common symbols less than the GP size are automatically
	 treated as SHN_MIPS_SCOMMON symbols on IRIX5.  */
      if (asym->value > elf_gp_size (abfd)
	  || IRIX_COMPAT (abfd) == ict_irix6)
	break;
      /* Fall through.  */
    case SHN_MIPS_SCOMMON:
      if (mips_elf_scom_section.name == NULL)
	{
	  /* Initialize the small common section.  */
	  mips_elf_scom_section.name = ".scommon";
	  mips_elf_scom_section.flags = SEC_IS_COMMON;
	  mips_elf_scom_section.output_section = &mips_elf_scom_section;
	  mips_elf_scom_section.symbol = &mips_elf_scom_symbol;
	  mips_elf_scom_section.symbol_ptr_ptr = &mips_elf_scom_symbol_ptr;
	  mips_elf_scom_symbol.name = ".scommon";
	  mips_elf_scom_symbol.flags = BSF_SECTION_SYM;
	  mips_elf_scom_symbol.section = &mips_elf_scom_section;
	  mips_elf_scom_symbol_ptr = &mips_elf_scom_symbol;
	}
      asym->section = &mips_elf_scom_section;
      asym->value = elfsym->internal_elf_sym.st_size;
      break;

    case SHN_MIPS_SUNDEFINED:
      asym->section = bfd_und_section_ptr;
      break;

#if 0 /* for SGI_COMPAT */
    case SHN_MIPS_TEXT:
      asym->section = mips_elf_text_section_ptr;
      break;

    case SHN_MIPS_DATA:
      asym->section = mips_elf_data_section_ptr;
      break;
#endif
    }
}

/* When creating an Irix 5 executable, we need REGINFO and RTPROC
   segments.  */

int
_bfd_mips_elf_additional_program_headers (abfd)
     bfd *abfd;
{
  asection *s;
  int ret = 0;

  /* See if we need a PT_MIPS_REGINFO segment.  */
  s = bfd_get_section_by_name (abfd, ".reginfo");
  if (s && (s->flags & SEC_LOAD))
    ++ret;

  /* See if we need a PT_MIPS_OPTIONS segment.  */
  if (IRIX_COMPAT (abfd) == ict_irix6
      && bfd_get_section_by_name (abfd,
				  MIPS_ELF_OPTIONS_SECTION_NAME (abfd)))
    ++ret;

  /* See if we need a PT_MIPS_RTPROC segment.  */
  if (IRIX_COMPAT (abfd) == ict_irix5
      && bfd_get_section_by_name (abfd, ".dynamic")
      && bfd_get_section_by_name (abfd, ".mdebug"))
    ++ret;

  return ret;
}

/* Modify the segment map for an Irix 5 executable.  */

boolean
_bfd_mips_elf_modify_segment_map (abfd)
     bfd *abfd;
{
  asection *s;
  struct elf_segment_map *m, **pm;
  bfd_size_type amt;

  /* If there is a .reginfo section, we need a PT_MIPS_REGINFO
     segment.  */
  s = bfd_get_section_by_name (abfd, ".reginfo");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	if (m->p_type == PT_MIPS_REGINFO)
	  break;
      if (m == NULL)
	{
	  amt = sizeof *m;
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
	  if (m == NULL)
	    return false;

	  m->p_type = PT_MIPS_REGINFO;
	  m->count = 1;
	  m->sections[0] = s;

	  /* We want to put it after the PHDR and INTERP segments.  */
	  pm = &elf_tdata (abfd)->segment_map;
	  while (*pm != NULL
		 && ((*pm)->p_type == PT_PHDR
		     || (*pm)->p_type == PT_INTERP))
	    pm = &(*pm)->next;

	  m->next = *pm;
	  *pm = m;
	}
    }

  /* For IRIX 6, we don't have .mdebug sections, nor does anything but
     .dynamic end up in PT_DYNAMIC.  However, we do have to insert a
     PT_OPTIONS segement immediately following the program header
     table.  */
  if (IRIX_COMPAT (abfd) == ict_irix6)
    {
      for (s = abfd->sections; s; s = s->next)
	if (elf_section_data (s)->this_hdr.sh_type == SHT_MIPS_OPTIONS)
	  break;

      if (s)
	{
	  struct elf_segment_map *options_segment;

	  /* Usually, there's a program header table.  But, sometimes
	     there's not (like when running the `ld' testsuite).  So,
	     if there's no program header table, we just put the
	     options segement at the end.  */
	  for (pm = &elf_tdata (abfd)->segment_map;
	       *pm != NULL;
	       pm = &(*pm)->next)
	    if ((*pm)->p_type == PT_PHDR)
	      break;

	  amt = sizeof (struct elf_segment_map);
	  options_segment = bfd_zalloc (abfd, amt);
	  options_segment->next = *pm;
	  options_segment->p_type = PT_MIPS_OPTIONS;
	  options_segment->p_flags = PF_R;
	  options_segment->p_flags_valid = true;
	  options_segment->count = 1;
	  options_segment->sections[0] = s;
	  *pm = options_segment;
	}
    }
  else
    {
      if (IRIX_COMPAT (abfd) == ict_irix5)
	{
	  /* If there are .dynamic and .mdebug sections, we make a room
	     for the RTPROC header.  FIXME: Rewrite without section names.  */
	  if (bfd_get_section_by_name (abfd, ".interp") == NULL
	      && bfd_get_section_by_name (abfd, ".dynamic") != NULL
	      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
	    {
	      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
		if (m->p_type == PT_MIPS_RTPROC)
		  break;
	      if (m == NULL)
		{
		  amt = sizeof *m;
		  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
		  if (m == NULL)
		    return false;

		  m->p_type = PT_MIPS_RTPROC;

		  s = bfd_get_section_by_name (abfd, ".rtproc");
		  if (s == NULL)
		    {
		      m->count = 0;
		      m->p_flags = 0;
		      m->p_flags_valid = 1;
		    }
		  else
		    {
		      m->count = 1;
		      m->sections[0] = s;
		    }

		  /* We want to put it after the DYNAMIC segment.  */
		  pm = &elf_tdata (abfd)->segment_map;
		  while (*pm != NULL && (*pm)->p_type != PT_DYNAMIC)
		    pm = &(*pm)->next;
		  if (*pm != NULL)
		    pm = &(*pm)->next;

		  m->next = *pm;
		  *pm = m;
		}
	    }
	}
      /* On Irix 5, the PT_DYNAMIC segment includes the .dynamic,
	 .dynstr, .dynsym, and .hash sections, and everything in
	 between.  */
      for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL;
	   pm = &(*pm)->next)
	if ((*pm)->p_type == PT_DYNAMIC)
	  break;
      m = *pm;
      if (m != NULL && IRIX_COMPAT (abfd) == ict_none)
	{
	  /* For a normal mips executable the permissions for the PT_DYNAMIC
	     segment are read, write and execute. We do that here since
	     the code in elf.c sets only the read permission. This matters
	     sometimes for the dynamic linker.  */
	  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL)
	    {
	      m->p_flags = PF_R | PF_W | PF_X;
	      m->p_flags_valid = 1;
	    }
	}
      if (m != NULL
	  && m->count == 1 && strcmp (m->sections[0]->name, ".dynamic") == 0)
	{
	  static const char *sec_names[] =
	  {
	    ".dynamic", ".dynstr", ".dynsym", ".hash"
	  };
	  bfd_vma low, high;
	  unsigned int i, c;
	  struct elf_segment_map *n;

	  low = 0xffffffff;
	  high = 0;
	  for (i = 0; i < sizeof sec_names / sizeof sec_names[0]; i++)
	    {
	      s = bfd_get_section_by_name (abfd, sec_names[i]);
	      if (s != NULL && (s->flags & SEC_LOAD) != 0)
		{
		  bfd_size_type sz;

		  if (low > s->vma)
		    low = s->vma;
		  sz = s->_cooked_size;
		  if (sz == 0)
		    sz = s->_raw_size;
		  if (high < s->vma + sz)
		    high = s->vma + sz;
		}
	    }

	  c = 0;
	  for (s = abfd->sections; s != NULL; s = s->next)
	    if ((s->flags & SEC_LOAD) != 0
		&& s->vma >= low
		&& ((s->vma
		     + (s->_cooked_size !=
			0 ? s->_cooked_size : s->_raw_size)) <= high))
	      ++c;

	  amt = sizeof *n + (bfd_size_type) (c - 1) * sizeof (asection *);
	  n = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
	  if (n == NULL)
	    return false;
	  *n = *m;
	  n->count = c;

	  i = 0;
	  for (s = abfd->sections; s != NULL; s = s->next)
	    {
	      if ((s->flags & SEC_LOAD) != 0
		  && s->vma >= low
		  && ((s->vma
		       + (s->_cooked_size != 0 ?
			  s->_cooked_size : s->_raw_size)) <= high))
		{
		  n->sections[i] = s;
		  ++i;
		}
	    }

	  *pm = n;
	}
    }

  return true;
}

/* The structure of the runtime procedure descriptor created by the
   loader for use by the static exception system.  */

typedef struct runtime_pdr {
	bfd_vma	adr;		/* memory address of start of procedure */
	long	regmask;	/* save register mask */
	long	regoffset;	/* save register offset */
	long	fregmask;	/* save floating point register mask */
	long	fregoffset;	/* save floating point register offset */
	long	frameoffset;	/* frame size */
	short	framereg;	/* frame pointer register */
	short	pcreg;		/* offset or reg of return pc */
	long	irpss;		/* index into the runtime string table */
	long	reserved;
	struct exception_info *exception_info;/* pointer to exception array */
} RPDR, *pRPDR;
#define cbRPDR sizeof (RPDR)
#define rpdNil ((pRPDR) 0)

/* Swap RPDR (runtime procedure table entry) for output.  */

static void ecoff_swap_rpdr_out
  PARAMS ((bfd *, const RPDR *, struct rpdr_ext *));

static void
ecoff_swap_rpdr_out (abfd, in, ex)
     bfd *abfd;
     const RPDR *in;
     struct rpdr_ext *ex;
{
  /* ECOFF_PUT_OFF was defined in ecoffswap.h.  */
  ECOFF_PUT_OFF (abfd, in->adr, ex->p_adr);
  H_PUT_32 (abfd, in->regmask, ex->p_regmask);
  H_PUT_32 (abfd, in->regoffset, ex->p_regoffset);
  H_PUT_32 (abfd, in->fregmask, ex->p_fregmask);
  H_PUT_32 (abfd, in->fregoffset, ex->p_fregoffset);
  H_PUT_32 (abfd, in->frameoffset, ex->p_frameoffset);

  H_PUT_16 (abfd, in->framereg, ex->p_framereg);
  H_PUT_16 (abfd, in->pcreg, ex->p_pcreg);

  H_PUT_32 (abfd, in->irpss, ex->p_irpss);
#if 0 /* FIXME */
  ECOFF_PUT_OFF (abfd, in->exception_info, ex->p_exception_info);
#endif
}

/* Read ECOFF debugging information from a .mdebug section into a
   ecoff_debug_info structure.  */

boolean
_bfd_mips_elf_read_ecoff_info (abfd, section, debug)
     bfd *abfd;
     asection *section;
     struct ecoff_debug_info *debug;
{
  HDRR *symhdr;
  const struct ecoff_debug_swap *swap;
  char *ext_hdr = NULL;

  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
  memset (debug, 0, sizeof (*debug));

  ext_hdr = (char *) bfd_malloc (swap->external_hdr_size);
  if (ext_hdr == NULL && swap->external_hdr_size != 0)
    goto error_return;

  if (bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
				swap->external_hdr_size)
      == false)
    goto error_return;

  symhdr = &debug->symbolic_header;
  (*swap->swap_hdr_in) (abfd, ext_hdr, symhdr);

  /* The symbolic header contains absolute file offsets and sizes to
     read.  */
#define READ(ptr, offset, count, size, type)				\
  if (symhdr->count == 0)						\
    debug->ptr = NULL;							\
  else									\
    {									\
      bfd_size_type amt = (bfd_size_type) size * symhdr->count;		\
      debug->ptr = (type) bfd_malloc (amt);				\
      if (debug->ptr == NULL)						\
	goto error_return;						\
      if (bfd_seek (abfd, (file_ptr) symhdr->offset, SEEK_SET) != 0	\
	  || bfd_bread (debug->ptr, amt, abfd) != amt)			\
	goto error_return;						\
    }

  READ (line, cbLineOffset, cbLine, sizeof (unsigned char), unsigned char *);
  READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, PTR);
  READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, PTR);
  READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, PTR);
  READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, PTR);
  READ (external_aux, cbAuxOffset, iauxMax, sizeof (union aux_ext),
	union aux_ext *);
  READ (ss, cbSsOffset, issMax, sizeof (char), char *);
  READ (ssext, cbSsExtOffset, issExtMax, sizeof (char), char *);
  READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, PTR);
  READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, PTR);
  READ (external_ext, cbExtOffset, iextMax, swap->external_ext_size, PTR);
#undef READ

  debug->fdr = NULL;
  debug->adjust = NULL;

  return true;

 error_return:
  if (ext_hdr != NULL)
    free (ext_hdr);
  if (debug->line != NULL)
    free (debug->line);
  if (debug->external_dnr != NULL)
    free (debug->external_dnr);
  if (debug->external_pdr != NULL)
    free (debug->external_pdr);
  if (debug->external_sym != NULL)
    free (debug->external_sym);
  if (debug->external_opt != NULL)
    free (debug->external_opt);
  if (debug->external_aux != NULL)
    free (debug->external_aux);
  if (debug->ss != NULL)
    free (debug->ss);
  if (debug->ssext != NULL)
    free (debug->ssext);
  if (debug->external_fdr != NULL)
    free (debug->external_fdr);
  if (debug->external_rfd != NULL)
    free (debug->external_rfd);
  if (debug->external_ext != NULL)
    free (debug->external_ext);
  return false;
}

/* MIPS ELF local labels start with '$', not 'L'.  */

static boolean
mips_elf_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
{
  if (name[0] == '$')
    return true;

  /* On Irix 6, the labels go back to starting with '.', so we accept
     the generic ELF local label syntax as well.  */
  return _bfd_elf_is_local_label_name (abfd, name);
}

/* MIPS ELF uses a special find_nearest_line routine in order the
   handle the ECOFF debugging information.  */

struct mips_elf_find_line
{
  struct ecoff_debug_info d;
  struct ecoff_find_line i;
};

boolean
_bfd_mips_elf_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
				 functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
{
  asection *msec;

  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr))
    return true;

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr,
				     (unsigned) (ABI_64_P (abfd) ? 8 : 0),
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    return true;

  msec = bfd_get_section_by_name (abfd, ".mdebug");
  if (msec != NULL)
    {
      flagword origflags;
      struct mips_elf_find_line *fi;
      const struct ecoff_debug_swap * const swap =
	get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;

      /* If we are called during a link, mips_elf_final_link may have
	 cleared the SEC_HAS_CONTENTS field.  We force it back on here
	 if appropriate (which it normally will be).  */
      origflags = msec->flags;
      if (elf_section_data (msec)->this_hdr.sh_type != SHT_NOBITS)
	msec->flags |= SEC_HAS_CONTENTS;

      fi = elf_tdata (abfd)->find_line_info;
      if (fi == NULL)
	{
	  bfd_size_type external_fdr_size;
	  char *fraw_src;
	  char *fraw_end;
	  struct fdr *fdr_ptr;
	  bfd_size_type amt = sizeof (struct mips_elf_find_line);

	  fi = (struct mips_elf_find_line *) bfd_zalloc (abfd, amt);
	  if (fi == NULL)
	    {
	      msec->flags = origflags;
	      return false;
	    }

	  if (! _bfd_mips_elf_read_ecoff_info (abfd, msec, &fi->d))
	    {
	      msec->flags = origflags;
	      return false;
	    }

	  /* Swap in the FDR information.  */
	  amt = fi->d.symbolic_header.ifdMax * sizeof (struct fdr);
	  fi->d.fdr = (struct fdr *) bfd_alloc (abfd, amt);
	  if (fi->d.fdr == NULL)
	    {
	      msec->flags = origflags;
	      return false;
	    }
	  external_fdr_size = swap->external_fdr_size;
	  fdr_ptr = fi->d.fdr;
	  fraw_src = (char *) fi->d.external_fdr;
	  fraw_end = (fraw_src
		      + fi->d.symbolic_header.ifdMax * external_fdr_size);
	  for (; fraw_src < fraw_end; fraw_src += external_fdr_size, fdr_ptr++)
	    (*swap->swap_fdr_in) (abfd, (PTR) fraw_src, fdr_ptr);

	  elf_tdata (abfd)->find_line_info = fi;

	  /* Note that we don't bother to ever free this information.
             find_nearest_line is either called all the time, as in
             objdump -l, so the information should be saved, or it is
             rarely called, as in ld error messages, so the memory
             wasted is unimportant.  Still, it would probably be a
             good idea for free_cached_info to throw it away.  */
	}

      if (_bfd_ecoff_locate_line (abfd, section, offset, &fi->d, swap,
				  &fi->i, filename_ptr, functionname_ptr,
				  line_ptr))
	{
	  msec->flags = origflags;
	  return true;
	}

      msec->flags = origflags;
    }

  /* Fall back on the generic ELF find_nearest_line routine.  */

  return _bfd_elf_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr);
}

  /* The mips16 compiler uses a couple of special sections to handle
     floating point arguments.

     Section names that look like .mips16.fn.FNNAME contain stubs that
     copy floating point arguments from the fp regs to the gp regs and
     then jump to FNNAME.  If any 32 bit function calls FNNAME, the
     call should be redirected to the stub instead.  If no 32 bit
     function calls FNNAME, the stub should be discarded.  We need to
     consider any reference to the function, not just a call, because
     if the address of the function is taken we will need the stub,
     since the address might be passed to a 32 bit function.

     Section names that look like .mips16.call.FNNAME contain stubs
     that copy floating point arguments from the gp regs to the fp
     regs and then jump to FNNAME.  If FNNAME is a 32 bit function,
     then any 16 bit function that calls FNNAME should be redirected
     to the stub instead.  If FNNAME is not a 32 bit function, the
     stub should be discarded.

     .mips16.call.fp.FNNAME sections are similar, but contain stubs
     which call FNNAME and then copy the return value from the fp regs
     to the gp regs.  These stubs store the return value in $18 while
     calling FNNAME; any function which might call one of these stubs
     must arrange to save $18 around the call.  (This case is not
     needed for 32 bit functions that call 16 bit functions, because
     16 bit functions always return floating point values in both
     $f0/$f1 and $2/$3.)

     Note that in all cases FNNAME might be defined statically.
     Therefore, FNNAME is not used literally.  Instead, the relocation
     information will indicate which symbol the section is for.

     We record any stubs that we find in the symbol table.  */

#define FN_STUB ".mips16.fn."
#define CALL_STUB ".mips16.call."
#define CALL_FP_STUB ".mips16.call.fp."

/* MIPS ELF linker hash table.  */

struct mips_elf_link_hash_table
{
  struct elf_link_hash_table root;
#if 0
  /* We no longer use this.  */
  /* String section indices for the dynamic section symbols.  */
  bfd_size_type dynsym_sec_strindex[SIZEOF_MIPS_DYNSYM_SECNAMES];
#endif
  /* The number of .rtproc entries.  */
  bfd_size_type procedure_count;
  /* The size of the .compact_rel section (if SGI_COMPAT).  */
  bfd_size_type compact_rel_size;
  /* This flag indicates that the value of DT_MIPS_RLD_MAP dynamic
     entry is set to the address of __rld_obj_head as in Irix 5.  */
  boolean use_rld_obj_head;
  /* This is the value of the __rld_map or __rld_obj_head symbol.  */
  bfd_vma rld_value;
  /* This is set if we see any mips16 stub sections.  */
  boolean mips16_stubs_seen;
};

/* Look up an entry in a MIPS ELF linker hash table.  */

#define mips_elf_link_hash_lookup(table, string, create, copy, follow)	\
  ((struct mips_elf_link_hash_entry *)					\
   elf_link_hash_lookup (&(table)->root, (string), (create),		\
			 (copy), (follow)))

/* Traverse a MIPS ELF linker hash table.  */

#define mips_elf_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
    (info)))

/* Get the MIPS ELF linker hash table from a link_info structure.  */

#define mips_elf_hash_table(p) \
  ((struct mips_elf_link_hash_table *) ((p)->hash))

static boolean mips_elf_output_extsym
  PARAMS ((struct mips_elf_link_hash_entry *, PTR));

/* Create an entry in a MIPS ELF linker hash table.  */

static struct bfd_hash_entry *
mips_elf_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct mips_elf_link_hash_entry *ret =
    (struct mips_elf_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct mips_elf_link_hash_entry *) NULL)
    ret = ((struct mips_elf_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct mips_elf_link_hash_entry)));
  if (ret == (struct mips_elf_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct mips_elf_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct mips_elf_link_hash_entry *) NULL)
    {
      /* Set local fields.  */
      memset (&ret->esym, 0, sizeof (EXTR));
      /* We use -2 as a marker to indicate that the information has
	 not been set.  -1 means there is no associated ifd.  */
      ret->esym.ifd = -2;
      ret->possibly_dynamic_relocs = 0;
      ret->readonly_reloc = false;
      ret->min_dyn_reloc_index = 0;
      ret->no_fn_stub = false;
      ret->fn_stub = NULL;
      ret->need_fn_stub = false;
      ret->call_stub = NULL;
      ret->call_fp_stub = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

static void
_bfd_mips_elf_hide_symbol (info, entry, force_local)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *entry;
     boolean force_local;
{
  bfd *dynobj;
  asection *got;
  struct mips_got_info *g;
  struct mips_elf_link_hash_entry *h;
  h = (struct mips_elf_link_hash_entry *) entry;
  dynobj = elf_hash_table (info)->dynobj;
  got = bfd_get_section_by_name (dynobj, ".got");
  g = (struct mips_got_info *) elf_section_data (got)->tdata;

  _bfd_elf_link_hash_hide_symbol (info, &h->root, force_local);

  /* FIXME: Do we allocate too much GOT space here?  */
  g->local_gotno++;
  got->_raw_size += MIPS_ELF_GOT_SIZE (dynobj);
}

/* Create a MIPS ELF linker hash table.  */

struct bfd_link_hash_table *
_bfd_mips_elf_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct mips_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct mips_elf_link_hash_table);

  ret = (struct mips_elf_link_hash_table *) bfd_alloc (abfd, amt);
  if (ret == (struct mips_elf_link_hash_table *) NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       mips_elf_link_hash_newfunc))
    {
      bfd_release (abfd, ret);
      return NULL;
    }

#if 0
  /* We no longer use this.  */
  for (i = 0; i < SIZEOF_MIPS_DYNSYM_SECNAMES; i++)
    ret->dynsym_sec_strindex[i] = (bfd_size_type) -1;
#endif
  ret->procedure_count = 0;
  ret->compact_rel_size = 0;
  ret->use_rld_obj_head = false;
  ret->rld_value = 0;
  ret->mips16_stubs_seen = false;

  return &ret->root.root;
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We must handle the special MIPS section numbers here.  */

boolean
_bfd_mips_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
{
  if (SGI_COMPAT (abfd)
      && (abfd->flags & DYNAMIC) != 0
      && strcmp (*namep, "_rld_new_interface") == 0)
    {
      /* Skip Irix 5 rld entry name.  */
      *namep = NULL;
      return true;
    }

  switch (sym->st_shndx)
    {
    case SHN_COMMON:
      /* Common symbols less than the GP size are automatically
	 treated as SHN_MIPS_SCOMMON symbols.  */
      if (sym->st_size > elf_gp_size (abfd)
	  || IRIX_COMPAT (abfd) == ict_irix6)
	break;
      /* Fall through.  */
    case SHN_MIPS_SCOMMON:
      *secp = bfd_make_section_old_way (abfd, ".scommon");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;

    case SHN_MIPS_TEXT:
      /* This section is used in a shared object.  */
      if (elf_tdata (abfd)->elf_text_section == NULL)
	{
	  asymbol *elf_text_symbol;
	  asection *elf_text_section;
	  bfd_size_type amt = sizeof (asection);

	  elf_text_section = bfd_zalloc (abfd, amt);
	  if (elf_text_section == NULL)
	    return false;

	  amt = sizeof (asymbol);
	  elf_text_symbol = bfd_zalloc (abfd, amt);
	  if (elf_text_symbol == NULL)
	    return false;

	  /* Initialize the section.  */

	  elf_tdata (abfd)->elf_text_section = elf_text_section;
	  elf_tdata (abfd)->elf_text_symbol = elf_text_symbol;

	  elf_text_section->symbol = elf_text_symbol;
	  elf_text_section->symbol_ptr_ptr = &elf_tdata (abfd)->elf_text_symbol;

	  elf_text_section->name = ".text";
	  elf_text_section->flags = SEC_NO_FLAGS;
	  elf_text_section->output_section = NULL;
	  elf_text_section->owner = abfd;
	  elf_text_symbol->name = ".text";
	  elf_text_symbol->flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  elf_text_symbol->section = elf_text_section;
	}
      /* This code used to do *secp = bfd_und_section_ptr if
         info->shared.  I don't know why, and that doesn't make sense,
         so I took it out.  */
      *secp = elf_tdata (abfd)->elf_text_section;
      break;

    case SHN_MIPS_ACOMMON:
      /* Fall through. XXX Can we treat this as allocated data?  */
    case SHN_MIPS_DATA:
      /* This section is used in a shared object.  */
      if (elf_tdata (abfd)->elf_data_section == NULL)
	{
	  asymbol *elf_data_symbol;
	  asection *elf_data_section;
	  bfd_size_type amt = sizeof (asection);

	  elf_data_section = bfd_zalloc (abfd, amt);
	  if (elf_data_section == NULL)
	    return false;

	  amt = sizeof (asymbol);
	  elf_data_symbol = bfd_zalloc (abfd, amt);
	  if (elf_data_symbol == NULL)
	    return false;

	  /* Initialize the section.  */

	  elf_tdata (abfd)->elf_data_section = elf_data_section;
	  elf_tdata (abfd)->elf_data_symbol = elf_data_symbol;

	  elf_data_section->symbol = elf_data_symbol;
	  elf_data_section->symbol_ptr_ptr = &elf_tdata (abfd)->elf_data_symbol;

	  elf_data_section->name = ".data";
	  elf_data_section->flags = SEC_NO_FLAGS;
	  elf_data_section->output_section = NULL;
	  elf_data_section->owner = abfd;
	  elf_data_symbol->name = ".data";
	  elf_data_symbol->flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  elf_data_symbol->section = elf_data_section;
	}
      /* This code used to do *secp = bfd_und_section_ptr if
         info->shared.  I don't know why, and that doesn't make sense,
         so I took it out.  */
      *secp = elf_tdata (abfd)->elf_data_section;
      break;

    case SHN_MIPS_SUNDEFINED:
      *secp = bfd_und_section_ptr;
      break;
    }

  if (SGI_COMPAT (abfd)
      && ! info->shared
      && info->hash->creator == abfd->xvec
      && strcmp (*namep, "__rld_obj_head") == 0)
    {
      struct elf_link_hash_entry *h;

      /* Mark __rld_obj_head as dynamic.  */
      h = NULL;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, *namep, BSF_GLOBAL, *secp,
	      (bfd_vma) *valp, (const char *) NULL, false,
	      get_elf_backend_data (abfd)->collect,
	      (struct bfd_link_hash_entry **) &h)))
	return false;
      h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_OBJECT;

      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	return false;

      mips_elf_hash_table (info)->use_rld_obj_head = true;
    }

  /* If this is a mips16 text symbol, add 1 to the value to make it
     odd.  This will cause something like .word SYM to come up with
     the right value when it is loaded into the PC.  */
  if (sym->st_other == STO_MIPS16)
    ++*valp;

  return true;
}

/* Structure used to pass information to mips_elf_output_extsym.  */

struct extsym_info
{
  bfd *abfd;
  struct bfd_link_info *info;
  struct ecoff_debug_info *debug;
  const struct ecoff_debug_swap *swap;
  boolean failed;
};

/* This routine is used to write out ECOFF debugging external symbol
   information.  It is called via mips_elf_link_hash_traverse.  The
   ECOFF external symbol information must match the ELF external
   symbol information.  Unfortunately, at this point we don't know
   whether a symbol is required by reloc information, so the two
   tables may wind up being different.  We must sort out the external
   symbol information before we can set the final size of the .mdebug
   section, and we must set the size of the .mdebug section before we
   can relocate any sections, and we can't know which symbols are
   required by relocation until we relocate the sections.
   Fortunately, it is relatively unlikely that any symbol will be
   stripped but required by a reloc.  In particular, it can not happen
   when generating a final executable.  */

static boolean
mips_elf_output_extsym (h, data)
     struct mips_elf_link_hash_entry *h;
     PTR data;
{
  struct extsym_info *einfo = (struct extsym_info *) data;
  boolean strip;
  asection *sec, *output_section;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

  if (h->root.indx == -2)
    strip = false;
  else if (((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	    || (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
    strip = true;
  else if (einfo->info->strip == strip_all
	   || (einfo->info->strip == strip_some
	       && bfd_hash_lookup (einfo->info->keep_hash,
				   h->root.root.root.string,
				   false, false) == NULL))
    strip = true;
  else
    strip = false;

  if (strip)
    return true;

  if (h->esym.ifd == -2)
    {
      h->esym.jmptbl = 0;
      h->esym.cobol_main = 0;
      h->esym.weakext = 0;
      h->esym.reserved = 0;
      h->esym.ifd = ifdNil;
      h->esym.asym.value = 0;
      h->esym.asym.st = stGlobal;

      if (h->root.root.type == bfd_link_hash_undefined
	  || h->root.root.type == bfd_link_hash_undefweak)
	{
	  const char *name;

	  /* Use undefined class.  Also, set class and type for some
             special symbols.  */
	  name = h->root.root.root.string;
	  if (strcmp (name, mips_elf_dynsym_rtproc_names[0]) == 0
	      || strcmp (name, mips_elf_dynsym_rtproc_names[1]) == 0)
	    {
	      h->esym.asym.sc = scData;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value = 0;
	    }
	  else if (strcmp (name, mips_elf_dynsym_rtproc_names[2]) == 0)
	    {
	      h->esym.asym.sc = scAbs;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value =
		mips_elf_hash_table (einfo->info)->procedure_count;
	    }
	  else if (strcmp (name, "_gp_disp") == 0)
	    {
	      h->esym.asym.sc = scAbs;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value = elf_gp (einfo->abfd);
	    }
	  else
	    h->esym.asym.sc = scUndefined;
	}
      else if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak)
	h->esym.asym.sc = scAbs;
      else
	{
	  const char *name;

	  sec = h->root.root.u.def.section;
	  output_section = sec->output_section;

	  /* When making a shared library and symbol h is the one from
	     the another shared library, OUTPUT_SECTION may be null.  */
	  if (output_section == NULL)
	    h->esym.asym.sc = scUndefined;
	  else
	    {
	      name = bfd_section_name (output_section->owner, output_section);

	      if (strcmp (name, ".text") == 0)
		h->esym.asym.sc = scText;
	      else if (strcmp (name, ".data") == 0)
		h->esym.asym.sc = scData;
	      else if (strcmp (name, ".sdata") == 0)
		h->esym.asym.sc = scSData;
	      else if (strcmp (name, ".rodata") == 0
		       || strcmp (name, ".rdata") == 0)
		h->esym.asym.sc = scRData;
	      else if (strcmp (name, ".bss") == 0)
		h->esym.asym.sc = scBss;
	      else if (strcmp (name, ".sbss") == 0)
		h->esym.asym.sc = scSBss;
	      else if (strcmp (name, ".init") == 0)
		h->esym.asym.sc = scInit;
	      else if (strcmp (name, ".fini") == 0)
		h->esym.asym.sc = scFini;
	      else
		h->esym.asym.sc = scAbs;
	    }
	}

      h->esym.asym.reserved = 0;
      h->esym.asym.index = indexNil;
    }

  if (h->root.root.type == bfd_link_hash_common)
    h->esym.asym.value = h->root.root.u.c.size;
  else if (h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
    {
      if (h->esym.asym.sc == scCommon)
	h->esym.asym.sc = scBss;
      else if (h->esym.asym.sc == scSCommon)
	h->esym.asym.sc = scSBss;

      sec = h->root.root.u.def.section;
      output_section = sec->output_section;
      if (output_section != NULL)
	h->esym.asym.value = (h->root.root.u.def.value
			      + sec->output_offset
			      + output_section->vma);
      else
	h->esym.asym.value = 0;
    }
  else if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      struct mips_elf_link_hash_entry *hd = h;
      boolean no_fn_stub = h->no_fn_stub;

      while (hd->root.root.type == bfd_link_hash_indirect)
	{
	  hd = (struct mips_elf_link_hash_entry *)h->root.root.u.i.link;
	  no_fn_stub = no_fn_stub || hd->no_fn_stub;
	}

      if (!no_fn_stub)
	{
	  /* Set type and value for a symbol with a function stub.  */
	  h->esym.asym.st = stProc;
	  sec = hd->root.root.u.def.section;
	  if (sec == NULL)
	    h->esym.asym.value = 0;
	  else
	    {
	      output_section = sec->output_section;
	      if (output_section != NULL)
		h->esym.asym.value = (hd->root.plt.offset
				      + sec->output_offset
				      + output_section->vma);
	      else
		h->esym.asym.value = 0;
	    }
#if 0 /* FIXME?  */
	  h->esym.ifd = 0;
#endif
	}
    }

  if (! bfd_ecoff_debug_one_external (einfo->abfd, einfo->debug, einfo->swap,
				      h->root.root.root.string,
				      &h->esym))
    {
      einfo->failed = true;
      return false;
    }

  return true;
}

/* Create a runtime procedure table from the .mdebug section.  */

static boolean
mips_elf_create_procedure_table (handle, abfd, info, s, debug)
     PTR handle;
     bfd *abfd;
     struct bfd_link_info *info;
     asection *s;
     struct ecoff_debug_info *debug;
{
  const struct ecoff_debug_swap *swap;
  HDRR *hdr = &debug->symbolic_header;
  RPDR *rpdr, *rp;
  struct rpdr_ext *erp;
  PTR rtproc;
  struct pdr_ext *epdr;
  struct sym_ext *esym;
  char *ss, **sv;
  char *str;
  bfd_size_type size;
  bfd_size_type count;
  unsigned long sindex;
  unsigned long i;
  PDR pdr;
  SYMR sym;
  const char *no_name_func = _("static procedure (no name)");

  epdr = NULL;
  rpdr = NULL;
  esym = NULL;
  ss = NULL;
  sv = NULL;

  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;

  sindex = strlen (no_name_func) + 1;
  count = hdr->ipdMax;
  if (count > 0)
    {
      size = swap->external_pdr_size;

      epdr = (struct pdr_ext *) bfd_malloc (size * count);
      if (epdr == NULL)
	goto error_return;

      if (! _bfd_ecoff_get_accumulated_pdr (handle, (PTR) epdr))
	goto error_return;

      size = sizeof (RPDR);
      rp = rpdr = (RPDR *) bfd_malloc (size * count);
      if (rpdr == NULL)
	goto error_return;

      size = sizeof (char *);
      sv = (char **) bfd_malloc (size * count);
      if (sv == NULL)
	goto error_return;

      count = hdr->isymMax;
      size = swap->external_sym_size;
      esym = (struct sym_ext *) bfd_malloc (size * count);
      if (esym == NULL)
	goto error_return;

      if (! _bfd_ecoff_get_accumulated_sym (handle, (PTR) esym))
	goto error_return;

      count = hdr->issMax;
      ss = (char *) bfd_malloc (count);
      if (ss == NULL)
	goto error_return;
      if (! _bfd_ecoff_get_accumulated_ss (handle, (PTR) ss))
	goto error_return;

      count = hdr->ipdMax;
      for (i = 0; i < (unsigned long) count; i++, rp++)
	{
	  (*swap->swap_pdr_in) (abfd, (PTR) (epdr + i), &pdr);
	  (*swap->swap_sym_in) (abfd, (PTR) &esym[pdr.isym], &sym);
	  rp->adr = sym.value;
	  rp->regmask = pdr.regmask;
	  rp->regoffset = pdr.regoffset;
	  rp->fregmask = pdr.fregmask;
	  rp->fregoffset = pdr.fregoffset;
	  rp->frameoffset = pdr.frameoffset;
	  rp->framereg = pdr.framereg;
	  rp->pcreg = pdr.pcreg;
	  rp->irpss = sindex;
	  sv[i] = ss + sym.iss;
	  sindex += strlen (sv[i]) + 1;
	}
    }

  size = sizeof (struct rpdr_ext) * (count + 2) + sindex;
  size = BFD_ALIGN (size, 16);
  rtproc = (PTR) bfd_alloc (abfd, size);
  if (rtproc == NULL)
    {
      mips_elf_hash_table (info)->procedure_count = 0;
      goto error_return;
    }

  mips_elf_hash_table (info)->procedure_count = count + 2;

  erp = (struct rpdr_ext *) rtproc;
  memset (erp, 0, sizeof (struct rpdr_ext));
  erp++;
  str = (char *) rtproc + sizeof (struct rpdr_ext) * (count + 2);
  strcpy (str, no_name_func);
  str += strlen (no_name_func) + 1;
  for (i = 0; i < count; i++)
    {
      ecoff_swap_rpdr_out (abfd, rpdr + i, erp + i);
      strcpy (str, sv[i]);
      str += strlen (sv[i]) + 1;
    }
  ECOFF_PUT_OFF (abfd, -1, (erp + count)->p_adr);

  /* Set the size and contents of .rtproc section.  */
  s->_raw_size = size;
  s->contents = (bfd_byte *) rtproc;

  /* Skip this section later on (I don't think this currently
     matters, but someday it might).  */
  s->link_order_head = (struct bfd_link_order *) NULL;

  if (epdr != NULL)
    free (epdr);
  if (rpdr != NULL)
    free (rpdr);
  if (esym != NULL)
    free (esym);
  if (ss != NULL)
    free (ss);
  if (sv != NULL)
    free (sv);

  return true;

 error_return:
  if (epdr != NULL)
    free (epdr);
  if (rpdr != NULL)
    free (rpdr);
  if (esym != NULL)
    free (esym);
  if (ss != NULL)
    free (ss);
  if (sv != NULL)
    free (sv);
  return false;
}

/* A comparison routine used to sort .gptab entries.  */

static int
gptab_compare (p1, p2)
     const PTR p1;
     const PTR p2;
{
  const Elf32_gptab *a1 = (const Elf32_gptab *) p1;
  const Elf32_gptab *a2 = (const Elf32_gptab *) p2;

  return a1->gt_entry.gt_g_value - a2->gt_entry.gt_g_value;
}

/* We need to use a special link routine to handle the .reginfo and
   the .mdebug sections.  We need to merge all instances of these
   sections together, not write them all out sequentially.  */

boolean
_bfd_mips_elf_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  asection **secpp;
  asection *o;
  struct bfd_link_order *p;
  asection *reginfo_sec, *mdebug_sec, *gptab_data_sec, *gptab_bss_sec;
  asection *rtproc_sec;
  Elf32_RegInfo reginfo;
  struct ecoff_debug_info debug;
  const struct ecoff_debug_swap *swap
    = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
  HDRR *symhdr = &debug.symbolic_header;
  PTR mdebug_handle = NULL;
  asection *s;
  EXTR esym;
  unsigned int i;
  bfd_size_type amt;

  static const char * const secname[] =
  {
    ".text", ".init", ".fini", ".data",
    ".rodata", ".sdata", ".sbss", ".bss"
  };
  static const int sc[] =
  {
    scText, scInit, scFini, scData,
    scRData, scSData, scSBss, scBss
  };

  /* If all the things we linked together were PIC, but we're
     producing an executable (rather than a shared object), then the
     resulting file is CPIC (i.e., it calls PIC code.)  */
  if (!info->shared
      && !info->relocateable
      && elf_elfheader (abfd)->e_flags & EF_MIPS_PIC)
    {
      elf_elfheader (abfd)->e_flags &= ~EF_MIPS_PIC;
      elf_elfheader (abfd)->e_flags |= EF_MIPS_CPIC;
    }

  /* We'd carefully arranged the dynamic symbol indices, and then the
     generic size_dynamic_sections renumbered them out from under us.
     Rather than trying somehow to prevent the renumbering, just do
     the sort again.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd *dynobj;
      asection *got;
      struct mips_got_info *g;

      /* When we resort, we must tell mips_elf_sort_hash_table what
	 the lowest index it may use is.  That's the number of section
	 symbols we're going to add.  The generic ELF linker only
	 adds these symbols when building a shared object.  Note that
	 we count the sections after (possibly) removing the .options
	 section above.  */
      if (!mips_elf_sort_hash_table (info, (info->shared
					    ? bfd_count_sections (abfd) + 1
					    : 1)))
	return false;

      /* Make sure we didn't grow the global .got region.  */
      dynobj = elf_hash_table (info)->dynobj;
      got = bfd_get_section_by_name (dynobj, ".got");
      g = (struct mips_got_info *) elf_section_data (got)->tdata;

      if (g->global_gotsym != NULL)
	BFD_ASSERT ((elf_hash_table (info)->dynsymcount
		     - g->global_gotsym->dynindx)
		    <= g->global_gotno);
    }

  /* On IRIX5, we omit the .options section.  On IRIX6, however, we
     include it, even though we don't process it quite right.  (Some
     entries are supposed to be merged.)  Empirically, we seem to be
     better off including it then not.  */
  if (IRIX_COMPAT (abfd) == ict_irix5 || IRIX_COMPAT (abfd) == ict_none)
    for (secpp = &abfd->sections; *secpp != NULL; secpp = &(*secpp)->next)
      {
	if (strcmp ((*secpp)->name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
	  {
	    for (p = (*secpp)->link_order_head; p != NULL; p = p->next)
	      if (p->type == bfd_indirect_link_order)
		p->u.indirect.section->flags &= ~SEC_HAS_CONTENTS;
	    (*secpp)->link_order_head = NULL;
	    bfd_section_list_remove (abfd, secpp);
	    --abfd->section_count;

	    break;
	  }
      }

  /* Get a value for the GP register.  */
  if (elf_gp (abfd) == 0)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (info->hash, "_gp", false, false, true);
      if (h != (struct bfd_link_hash_entry *) NULL
	  && h->type == bfd_link_hash_defined)
	elf_gp (abfd) = (h->u.def.value
			 + h->u.def.section->output_section->vma
			 + h->u.def.section->output_offset);
      else if (info->relocateable)
	{
	  bfd_vma lo;

	  /* Find the GP-relative section with the lowest offset.  */
	  lo = (bfd_vma) -1;
	  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
	    if (o->vma < lo
		&& (elf_section_data (o)->this_hdr.sh_flags & SHF_MIPS_GPREL))
	      lo = o->vma;

	  /* And calculate GP relative to that.  */
	  elf_gp (abfd) = lo + ELF_MIPS_GP_OFFSET (abfd);
	}
      else
	{
	  /* If the relocate_section function needs to do a reloc
	     involving the GP value, it should make a reloc_dangerous
	     callback to warn that GP is not defined.  */
	}
    }

  /* Go through the sections and collect the .reginfo and .mdebug
     information.  */
  reginfo_sec = NULL;
  mdebug_sec = NULL;
  gptab_data_sec = NULL;
  gptab_bss_sec = NULL;
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
    {
      if (strcmp (o->name, ".reginfo") == 0)
	{
	  memset (&reginfo, 0, sizeof reginfo);

	  /* We have found the .reginfo section in the output file.
	     Look through all the link_orders comprising it and merge
	     the information together.  */
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      Elf32_External_RegInfo ext;
	      Elf32_RegInfo sub;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_data_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      /* The linker emulation code has probably clobbered the
                 size to be zero bytes.  */
	      if (input_section->_raw_size == 0)
		input_section->_raw_size = sizeof (Elf32_External_RegInfo);

	      if (! bfd_get_section_contents (input_bfd, input_section,
					      (PTR) &ext,
					      (file_ptr) 0,
					      (bfd_size_type) sizeof ext))
		return false;

	      bfd_mips_elf32_swap_reginfo_in (input_bfd, &ext, &sub);

	      reginfo.ri_gprmask |= sub.ri_gprmask;
	      reginfo.ri_cprmask[0] |= sub.ri_cprmask[0];
	      reginfo.ri_cprmask[1] |= sub.ri_cprmask[1];
	      reginfo.ri_cprmask[2] |= sub.ri_cprmask[2];
	      reginfo.ri_cprmask[3] |= sub.ri_cprmask[3];

	      /* ri_gp_value is set by the function
		 mips_elf32_section_processing when the section is
		 finally written out.  */

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &= ~SEC_HAS_CONTENTS;
	    }

	  /* Size has been set in mips_elf_always_size_sections  */
	  BFD_ASSERT(o->_raw_size == sizeof (Elf32_External_RegInfo));

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;

	  reginfo_sec = o;
	}

      if (strcmp (o->name, ".mdebug") == 0)
	{
	  struct extsym_info einfo;
	  bfd_vma last;

	  /* We have found the .mdebug section in the output file.
	     Look through all the link_orders comprising it and merge
	     the information together.  */
	  symhdr->magic = swap->sym_magic;
	  /* FIXME: What should the version stamp be?  */
	  symhdr->vstamp = 0;
	  symhdr->ilineMax = 0;
	  symhdr->cbLine = 0;
	  symhdr->idnMax = 0;
	  symhdr->ipdMax = 0;
	  symhdr->isymMax = 0;
	  symhdr->ioptMax = 0;
	  symhdr->iauxMax = 0;
	  symhdr->issMax = 0;
	  symhdr->issExtMax = 0;
	  symhdr->ifdMax = 0;
	  symhdr->crfd = 0;
	  symhdr->iextMax = 0;

	  /* We accumulate the debugging information itself in the
	     debug_info structure.  */
	  debug.line = NULL;
	  debug.external_dnr = NULL;
	  debug.external_pdr = NULL;
	  debug.external_sym = NULL;
	  debug.external_opt = NULL;
	  debug.external_aux = NULL;
	  debug.ss = NULL;
	  debug.ssext = debug.ssext_end = NULL;
	  debug.external_fdr = NULL;
	  debug.external_rfd = NULL;
	  debug.external_ext = debug.external_ext_end = NULL;

	  mdebug_handle = bfd_ecoff_debug_init (abfd, &debug, swap, info);
	  if (mdebug_handle == (PTR) NULL)
	    return false;

	  esym.jmptbl = 0;
	  esym.cobol_main = 0;
	  esym.weakext = 0;
	  esym.reserved = 0;
	  esym.ifd = ifdNil;
	  esym.asym.iss = issNil;
	  esym.asym.st = stLocal;
	  esym.asym.reserved = 0;
	  esym.asym.index = indexNil;
	  last = 0;
	  for (i = 0; i < sizeof (secname) / sizeof (secname[0]); i++)
	    {
	      esym.asym.sc = sc[i];
	      s = bfd_get_section_by_name (abfd, secname[i]);
	      if (s != NULL)
		{
		  esym.asym.value = s->vma;
		  last = s->vma + s->_raw_size;
		}
	      else
		esym.asym.value = last;
	      if (!bfd_ecoff_debug_one_external (abfd, &debug, swap,
						 secname[i], &esym))
		return false;
	    }

	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      const struct ecoff_debug_swap *input_swap;
	      struct ecoff_debug_info input_debug;
	      char *eraw_src;
	      char *eraw_end;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_data_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      if (bfd_get_flavour (input_bfd) != bfd_target_elf_flavour
		  || (get_elf_backend_data (input_bfd)
		      ->elf_backend_ecoff_debug_swap) == NULL)
		{
		  /* I don't know what a non MIPS ELF bfd would be
		     doing with a .mdebug section, but I don't really
		     want to deal with it.  */
		  continue;
		}

	      input_swap = (get_elf_backend_data (input_bfd)
			    ->elf_backend_ecoff_debug_swap);

	      BFD_ASSERT (p->size == input_section->_raw_size);

	      /* The ECOFF linking code expects that we have already
		 read in the debugging information and set up an
		 ecoff_debug_info structure, so we do that now.  */
	      if (! _bfd_mips_elf_read_ecoff_info (input_bfd, input_section,
						   &input_debug))
		return false;

	      if (! (bfd_ecoff_debug_accumulate
		     (mdebug_handle, abfd, &debug, swap, input_bfd,
		      &input_debug, input_swap, info)))
		return false;

	      /* Loop through the external symbols.  For each one with
		 interesting information, try to find the symbol in
		 the linker global hash table and save the information
		 for the output external symbols.  */
	      eraw_src = input_debug.external_ext;
	      eraw_end = (eraw_src
			  + (input_debug.symbolic_header.iextMax
			     * input_swap->external_ext_size));
	      for (;
		   eraw_src < eraw_end;
		   eraw_src += input_swap->external_ext_size)
		{
		  EXTR ext;
		  const char *name;
		  struct mips_elf_link_hash_entry *h;

		  (*input_swap->swap_ext_in) (input_bfd, (PTR) eraw_src, &ext);
		  if (ext.asym.sc == scNil
		      || ext.asym.sc == scUndefined
		      || ext.asym.sc == scSUndefined)
		    continue;

		  name = input_debug.ssext + ext.asym.iss;
		  h = mips_elf_link_hash_lookup (mips_elf_hash_table (info),
						 name, false, false, true);
		  if (h == NULL || h->esym.ifd != -2)
		    continue;

		  if (ext.ifd != -1)
		    {
		      BFD_ASSERT (ext.ifd
				  < input_debug.symbolic_header.ifdMax);
		      ext.ifd = input_debug.ifdmap[ext.ifd];
		    }

		  h->esym = ext;
		}

	      /* Free up the information we just read.  */
	      free (input_debug.line);
	      free (input_debug.external_dnr);
	      free (input_debug.external_pdr);
	      free (input_debug.external_sym);
	      free (input_debug.external_opt);
	      free (input_debug.external_aux);
	      free (input_debug.ss);
	      free (input_debug.ssext);
	      free (input_debug.external_fdr);
	      free (input_debug.external_rfd);
	      free (input_debug.external_ext);

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &= ~SEC_HAS_CONTENTS;
	    }

	  if (SGI_COMPAT (abfd) && info->shared)
	    {
	      /* Create .rtproc section.  */
	      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
	      if (rtproc_sec == NULL)
		{
		  flagword flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED | SEC_READONLY);

		  rtproc_sec = bfd_make_section (abfd, ".rtproc");
		  if (rtproc_sec == NULL
		      || ! bfd_set_section_flags (abfd, rtproc_sec, flags)
		      || ! bfd_set_section_alignment (abfd, rtproc_sec, 4))
		    return false;
		}

	      if (! mips_elf_create_procedure_table (mdebug_handle, abfd,
						     info, rtproc_sec, &debug))
		return false;
	    }

	  /* Build the external symbol information.  */
	  einfo.abfd = abfd;
	  einfo.info = info;
	  einfo.debug = &debug;
	  einfo.swap = swap;
	  einfo.failed = false;
	  mips_elf_link_hash_traverse (mips_elf_hash_table (info),
				       mips_elf_output_extsym,
				       (PTR) &einfo);
	  if (einfo.failed)
	    return false;

	  /* Set the size of the .mdebug section.  */
	  o->_raw_size = bfd_ecoff_debug_size (abfd, &debug, swap);

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;

	  mdebug_sec = o;
	}

      if (strncmp (o->name, ".gptab.", sizeof ".gptab." - 1) == 0)
	{
	  const char *subname;
	  unsigned int c;
	  Elf32_gptab *tab;
	  Elf32_External_gptab *ext_tab;
	  unsigned int j;

	  /* The .gptab.sdata and .gptab.sbss sections hold
	     information describing how the small data area would
	     change depending upon the -G switch.  These sections
	     not used in executables files.  */
	  if (! info->relocateable)
	    {
	      for (p = o->link_order_head;
		   p != (struct bfd_link_order *) NULL;
		   p = p->next)
		{
		  asection *input_section;

		  if (p->type != bfd_indirect_link_order)
		    {
		      if (p->type == bfd_data_link_order)
			continue;
		      abort ();
		    }

		  input_section = p->u.indirect.section;

		  /* Hack: reset the SEC_HAS_CONTENTS flag so that
		     elf_link_input_bfd ignores this section.  */
		  input_section->flags &= ~SEC_HAS_CONTENTS;
		}

	      /* Skip this section later on (I don't think this
		 currently matters, but someday it might).  */
	      o->link_order_head = (struct bfd_link_order *) NULL;

	      /* Really remove the section.  */
	      for (secpp = &abfd->sections;
		   *secpp != o;
		   secpp = &(*secpp)->next)
		;
	      bfd_section_list_remove (abfd, secpp);
	      --abfd->section_count;

	      continue;
	    }

	  /* There is one gptab for initialized data, and one for
	     uninitialized data.  */
	  if (strcmp (o->name, ".gptab.sdata") == 0)
	    gptab_data_sec = o;
	  else if (strcmp (o->name, ".gptab.sbss") == 0)
	    gptab_bss_sec = o;
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: illegal section name `%s'"),
		 bfd_get_filename (abfd), o->name);
	      bfd_set_error (bfd_error_nonrepresentable_section);
	      return false;
	    }

	  /* The linker script always combines .gptab.data and
	     .gptab.sdata into .gptab.sdata, and likewise for
	     .gptab.bss and .gptab.sbss.  It is possible that there is
	     no .sdata or .sbss section in the output file, in which
	     case we must change the name of the output section.  */
	  subname = o->name + sizeof ".gptab" - 1;
	  if (bfd_get_section_by_name (abfd, subname) == NULL)
	    {
	      if (o == gptab_data_sec)
		o->name = ".gptab.data";
	      else
		o->name = ".gptab.bss";
	      subname = o->name + sizeof ".gptab" - 1;
	      BFD_ASSERT (bfd_get_section_by_name (abfd, subname) != NULL);
	    }

	  /* Set up the first entry.  */
	  c = 1;
	  amt = c * sizeof (Elf32_gptab);
	  tab = (Elf32_gptab *) bfd_malloc (amt);
	  if (tab == NULL)
	    return false;
	  tab[0].gt_header.gt_current_g_value = elf_gp_size (abfd);
	  tab[0].gt_header.gt_unused = 0;

	  /* Combine the input sections.  */
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      bfd_size_type size;
	      unsigned long last;
	      bfd_size_type gpentry;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_data_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      /* Combine the gptab entries for this input section one
		 by one.  We know that the input gptab entries are
		 sorted by ascending -G value.  */
	      size = bfd_section_size (input_bfd, input_section);
	      last = 0;
	      for (gpentry = sizeof (Elf32_External_gptab);
		   gpentry < size;
		   gpentry += sizeof (Elf32_External_gptab))
		{
		  Elf32_External_gptab ext_gptab;
		  Elf32_gptab int_gptab;
		  unsigned long val;
		  unsigned long add;
		  boolean exact;
		  unsigned int look;

		  if (! (bfd_get_section_contents
			 (input_bfd, input_section, (PTR) &ext_gptab,
			  (file_ptr) gpentry,
			  (bfd_size_type) sizeof (Elf32_External_gptab))))
		    {
		      free (tab);
		      return false;
		    }

		  bfd_mips_elf32_swap_gptab_in (input_bfd, &ext_gptab,
						&int_gptab);
		  val = int_gptab.gt_entry.gt_g_value;
		  add = int_gptab.gt_entry.gt_bytes - last;

		  exact = false;
		  for (look = 1; look < c; look++)
		    {
		      if (tab[look].gt_entry.gt_g_value >= val)
			tab[look].gt_entry.gt_bytes += add;

		      if (tab[look].gt_entry.gt_g_value == val)
			exact = true;
		    }

		  if (! exact)
		    {
		      Elf32_gptab *new_tab;
		      unsigned int max;

		      /* We need a new table entry.  */
		      amt = (bfd_size_type) (c + 1) * sizeof (Elf32_gptab);
		      new_tab = (Elf32_gptab *) bfd_realloc ((PTR) tab, amt);
		      if (new_tab == NULL)
			{
			  free (tab);
			  return false;
			}
		      tab = new_tab;
		      tab[c].gt_entry.gt_g_value = val;
		      tab[c].gt_entry.gt_bytes = add;

		      /* Merge in the size for the next smallest -G
			 value, since that will be implied by this new
			 value.  */
		      max = 0;
		      for (look = 1; look < c; look++)
			{
			  if (tab[look].gt_entry.gt_g_value < val
			      && (max == 0
				  || (tab[look].gt_entry.gt_g_value
				      > tab[max].gt_entry.gt_g_value)))
			    max = look;
			}
		      if (max != 0)
			tab[c].gt_entry.gt_bytes +=
			  tab[max].gt_entry.gt_bytes;

		      ++c;
		    }

		  last = int_gptab.gt_entry.gt_bytes;
		}

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &= ~SEC_HAS_CONTENTS;
	    }

	  /* The table must be sorted by -G value.  */
	  if (c > 2)
	    qsort (tab + 1, c - 1, sizeof (tab[0]), gptab_compare);

	  /* Swap out the table.  */
	  amt = (bfd_size_type) c * sizeof (Elf32_External_gptab);
	  ext_tab = (Elf32_External_gptab *) bfd_alloc (abfd, amt);
	  if (ext_tab == NULL)
	    {
	      free (tab);
	      return false;
	    }

	  for (j = 0; j < c; j++)
	    bfd_mips_elf32_swap_gptab_out (abfd, tab + j, ext_tab + j);
	  free (tab);

	  o->_raw_size = c * sizeof (Elf32_External_gptab);
	  o->contents = (bfd_byte *) ext_tab;

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;
	}
    }

  /* Invoke the regular ELF backend linker to do all the work.  */
  if (ABI_64_P (abfd))
    {
#ifdef BFD64
      if (!bfd_elf64_bfd_final_link (abfd, info))
	return false;
#else
      abort ();
      return false;
#endif /* BFD64 */
    }
  else if (!bfd_elf32_bfd_final_link (abfd, info))
    return false;

  /* Now write out the computed sections.  */

  if (reginfo_sec != (asection *) NULL)
    {
      Elf32_External_RegInfo ext;

      bfd_mips_elf32_swap_reginfo_out (abfd, &reginfo, &ext);
      if (! bfd_set_section_contents (abfd, reginfo_sec, (PTR) &ext,
				      (file_ptr) 0, (bfd_size_type) sizeof ext))
	return false;
    }

  if (mdebug_sec != (asection *) NULL)
    {
      BFD_ASSERT (abfd->output_has_begun);
      if (! bfd_ecoff_write_accumulated_debug (mdebug_handle, abfd, &debug,
					       swap, info,
					       mdebug_sec->filepos))
	return false;

      bfd_ecoff_debug_free (mdebug_handle, abfd, &debug, swap, info);
    }

  if (gptab_data_sec != (asection *) NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_data_sec,
				      gptab_data_sec->contents,
				      (file_ptr) 0,
				      gptab_data_sec->_raw_size))
	return false;
    }

  if (gptab_bss_sec != (asection *) NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_bss_sec,
				      gptab_bss_sec->contents,
				      (file_ptr) 0,
				      gptab_bss_sec->_raw_size))
	return false;
    }

  if (SGI_COMPAT (abfd))
    {
      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
      if (rtproc_sec != NULL)
	{
	  if (! bfd_set_section_contents (abfd, rtproc_sec,
					  rtproc_sec->contents,
					  (file_ptr) 0,
					  rtproc_sec->_raw_size))
	    return false;
	}
    }

  return true;
}

/* This function is called via qsort() to sort the dynamic relocation
   entries by increasing r_symndx value.  */

static int
sort_dynamic_relocs (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
{
  const Elf32_External_Rel *ext_reloc1 = (const Elf32_External_Rel *) arg1;
  const Elf32_External_Rel *ext_reloc2 = (const Elf32_External_Rel *) arg2;

  Elf_Internal_Rel int_reloc1;
  Elf_Internal_Rel int_reloc2;

  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, ext_reloc1, &int_reloc1);
  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, ext_reloc2, &int_reloc2);

  return (ELF32_R_SYM (int_reloc1.r_info) - ELF32_R_SYM (int_reloc2.r_info));
}

/* Returns the GOT section for ABFD.  */

static asection *
mips_elf_got_section (abfd)
     bfd *abfd;
{
  return bfd_get_section_by_name (abfd, ".got");
}

/* Returns the GOT information associated with the link indicated by
   INFO.  If SGOTP is non-NULL, it is filled in with the GOT
   section.  */

static struct mips_got_info *
mips_elf_got_info (abfd, sgotp)
     bfd *abfd;
     asection **sgotp;
{
  asection *sgot;
  struct mips_got_info *g;

  sgot = mips_elf_got_section (abfd);
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);

  if (sgotp)
    *sgotp = sgot;
  return g;
}

/* Return whether a relocation is against a local symbol.  */

static boolean
mips_elf_local_relocation_p (input_bfd, relocation, local_sections,
			     check_forced)
     bfd *input_bfd;
     const Elf_Internal_Rela *relocation;
     asection **local_sections;
     boolean check_forced;
{
  unsigned long r_symndx;
  Elf_Internal_Shdr *symtab_hdr;
  struct mips_elf_link_hash_entry *h;
  size_t extsymoff;

  r_symndx = ELF32_R_SYM (relocation->r_info);
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  extsymoff = (elf_bad_symtab (input_bfd)) ? 0 : symtab_hdr->sh_info;

  if (r_symndx < extsymoff)
    return true;
  if (elf_bad_symtab (input_bfd) && local_sections[r_symndx] != NULL)
    return true;

  if (check_forced)
    {
      /* Look up the hash table to check whether the symbol
 	 was forced local.  */
      h = (struct mips_elf_link_hash_entry *)
	elf_sym_hashes (input_bfd) [r_symndx - extsymoff];
      /* Find the real hash-table entry for this symbol.  */
      while (h->root.root.type == bfd_link_hash_indirect
 	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;
      if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
	return true;
    }

  return false;
}

/* Sign-extend VALUE, which has the indicated number of BITS.  */

static bfd_vma
mips_elf_sign_extend (value, bits)
     bfd_vma value;
     int bits;
{
  if (value & ((bfd_vma) 1 << (bits - 1)))
    /* VALUE is negative.  */
    value |= ((bfd_vma) - 1) << bits;

  return value;
}

/* Return non-zero if the indicated VALUE has overflowed the maximum
   range expressable by a signed number with the indicated number of
   BITS.  */

static boolean
mips_elf_overflow_p (value, bits)
     bfd_vma value;
     int bits;
{
  bfd_signed_vma svalue = (bfd_signed_vma) value;

  if (svalue > (1 << (bits - 1)) - 1)
    /* The value is too big.  */
    return true;
  else if (svalue < -(1 << (bits - 1)))
    /* The value is too small.  */
    return true;

  /* All is well.  */
  return false;
}

/* Calculate the %high function.  */

static bfd_vma
mips_elf_high (value)
     bfd_vma value;
{
  return ((value + (bfd_vma) 0x8000) >> 16) & 0xffff;
}

/* Calculate the %higher function.  */

static bfd_vma
mips_elf_higher (value)
     bfd_vma value ATTRIBUTE_UNUSED;
{
#ifdef BFD64
  return ((value + (bfd_vma) 0x80008000) >> 32) & 0xffff;
#else
  abort ();
  return (bfd_vma) -1;
#endif
}

/* Calculate the %highest function.  */

static bfd_vma
mips_elf_highest (value)
     bfd_vma value ATTRIBUTE_UNUSED;
{
#ifdef BFD64
  return ((value + (bfd_vma) 0x800080008000) >> 48) & 0xffff;
#else
  abort ();
  return (bfd_vma) -1;
#endif
}

/* Returns the GOT index for the global symbol indicated by H.  */

static bfd_vma
mips_elf_global_got_index (abfd, h)
     bfd *abfd;
     struct elf_link_hash_entry *h;
{
  bfd_vma index;
  asection *sgot;
  struct mips_got_info *g;

  g = mips_elf_got_info (abfd, &sgot);

  /* Once we determine the global GOT entry with the lowest dynamic
     symbol table index, we must put all dynamic symbols with greater
     indices into the GOT.  That makes it easy to calculate the GOT
     offset.  */
  BFD_ASSERT (h->dynindx >= g->global_gotsym->dynindx);
  index = ((h->dynindx - g->global_gotsym->dynindx + g->local_gotno)
	   * MIPS_ELF_GOT_SIZE (abfd));
  BFD_ASSERT (index < sgot->_raw_size);

  return index;
}

/* Returns the offset for the entry at the INDEXth position
   in the GOT.  */

static bfd_vma
mips_elf_got_offset_from_index (dynobj, output_bfd, index)
     bfd *dynobj;
     bfd *output_bfd;
     bfd_vma index;
{
  asection *sgot;
  bfd_vma gp;

  sgot = mips_elf_got_section (dynobj);
  gp = _bfd_get_gp_value (output_bfd);
  return (sgot->output_section->vma + sgot->output_offset + index -
	  gp);
}

/* If H is a symbol that needs a global GOT entry, but has a dynamic
   symbol table index lower than any we've seen to date, record it for
   posterity.  */

static boolean
mips_elf_record_global_got_symbol (h, info, g)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
     struct mips_got_info *g ATTRIBUTE_UNUSED;
{
  /* A global symbol in the GOT must also be in the dynamic symbol
     table.  */
  if (h->dynindx == -1
      && !bfd_elf32_link_record_dynamic_symbol (info, h))
    return false;

  /* If we've already marked this entry as needing GOT space, we don't
     need to do it again.  */
  if (h->got.offset != (bfd_vma) -1)
    return true;

  /* By setting this to a value other than -1, we are indicating that
     there needs to be a GOT entry for H.  Avoid using zero, as the
     generic ELF copy_indirect_symbol tests for <= 0.  */
  h->got.offset = 1;

  return true;
}

/* This structure is passed to mips_elf_sort_hash_table_f when sorting
   the dynamic symbols.  */

struct mips_elf_hash_sort_data
{
  /* The symbol in the global GOT with the lowest dynamic symbol table
     index.  */
  struct elf_link_hash_entry *low;
  /* The least dynamic symbol table index corresponding to a symbol
     with a GOT entry.  */
  long min_got_dynindx;
  /* The greatest dynamic symbol table index not corresponding to a
     symbol without a GOT entry.  */
  long max_non_got_dynindx;
};

/* If H needs a GOT entry, assign it the highest available dynamic
   index.  Otherwise, assign it the lowest available dynamic
   index.  */

static boolean
mips_elf_sort_hash_table_f (h, data)
     struct mips_elf_link_hash_entry *h;
     PTR data;
{
  struct mips_elf_hash_sort_data *hsd
    = (struct mips_elf_hash_sort_data *) data;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

  /* Symbols without dynamic symbol table entries aren't interesting
     at all.  */
  if (h->root.dynindx == -1)
    return true;

  if (h->root.got.offset != 1)
    h->root.dynindx = hsd->max_non_got_dynindx++;
  else
    {
      h->root.dynindx = --hsd->min_got_dynindx;
      hsd->low = (struct elf_link_hash_entry *) h;
    }

  return true;
}

/* Sort the dynamic symbol table so that symbols that need GOT entries
   appear towards the end.  This reduces the amount of GOT space
   required.  MAX_LOCAL is used to set the number of local symbols
   known to be in the dynamic symbol table.  During
   mips_elf_size_dynamic_sections, this value is 1.  Afterward, the
   section symbols are added and the count is higher.  */

static boolean
mips_elf_sort_hash_table (info, max_local)
     struct bfd_link_info *info;
     unsigned long max_local;
{
  struct mips_elf_hash_sort_data hsd;
  struct mips_got_info *g;
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  hsd.low = NULL;
  hsd.min_got_dynindx = elf_hash_table (info)->dynsymcount;
  hsd.max_non_got_dynindx = max_local;
  mips_elf_link_hash_traverse (((struct mips_elf_link_hash_table *)
				elf_hash_table (info)),
			       mips_elf_sort_hash_table_f,
			       &hsd);

  /* There should have been enough room in the symbol table to
     accomodate both the GOT and non-GOT symbols.  */
  BFD_ASSERT (hsd.max_non_got_dynindx <= hsd.min_got_dynindx);

  /* Now we know which dynamic symbol has the lowest dynamic symbol
     table index in the GOT.  */
  g = mips_elf_got_info (dynobj, NULL);
  g->global_gotsym = hsd.low;

  return true;
}

/* Create a local GOT entry for VALUE.  Return the index of the entry,
   or -1 if it could not be created.  */

static bfd_vma
mips_elf_create_local_got_entry (abfd, g, sgot, value)
     bfd *abfd;
     struct mips_got_info *g;
     asection *sgot;
     bfd_vma value;
{
  if (g->assigned_gotno >= g->local_gotno)
    {
      /* We didn't allocate enough space in the GOT.  */
      (*_bfd_error_handler)
	(_("not enough GOT space for local GOT entries"));
      bfd_set_error (bfd_error_bad_value);
      return (bfd_vma) -1;
    }

  MIPS_ELF_PUT_WORD (abfd, value,
		     (sgot->contents
		      + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno));
  return MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno++;
}

/* Returns the GOT offset at which the indicated address can be found.
   If there is not yet a GOT entry for this value, create one.  Returns
   -1 if no satisfactory GOT offset can be found.  */

static bfd_vma
mips_elf_local_got_index (abfd, info, value)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
{
  asection *sgot;
  struct mips_got_info *g;
  bfd_byte *entry;

  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we already have an appropriate entry.  */
  for (entry = (sgot->contents
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
       entry != sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
       entry += MIPS_ELF_GOT_SIZE (abfd))
    {
      bfd_vma address = MIPS_ELF_GET_WORD (abfd, entry);
      if (address == value)
	return entry - sgot->contents;
    }

  return mips_elf_create_local_got_entry (abfd, g, sgot, value);
}

/* Find a GOT entry that is within 32KB of the VALUE.  These entries
   are supposed to be placed at small offsets in the GOT, i.e.,
   within 32KB of GP.  Return the index into the GOT for this page,
   and store the offset from this entry to the desired address in
   OFFSETP, if it is non-NULL.  */

static bfd_vma
mips_elf_got_page (abfd, info, value, offsetp)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
     bfd_vma *offsetp;
{
  asection *sgot;
  struct mips_got_info *g;
  bfd_byte *entry;
  bfd_byte *last_entry;
  bfd_vma index = 0;
  bfd_vma address;

  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we aleady have an appropriate entry.  */
  last_entry = sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
  for (entry = (sgot->contents
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
       entry != last_entry;
       entry += MIPS_ELF_GOT_SIZE (abfd))
    {
      address = MIPS_ELF_GET_WORD (abfd, entry);

      if (!mips_elf_overflow_p (value - address, 16))
	{
	  /* This entry will serve as the page pointer.  We can add a
	     16-bit number to it to get the actual address.  */
	  index = entry - sgot->contents;
	  break;
	}
    }

  /* If we didn't have an appropriate entry, we create one now.  */
  if (entry == last_entry)
    index = mips_elf_create_local_got_entry (abfd, g, sgot, value);

  if (offsetp)
    {
      address = MIPS_ELF_GET_WORD (abfd, entry);
      *offsetp = value - address;
    }

  return index;
}

/* Find a GOT entry whose higher-order 16 bits are the same as those
   for value.  Return the index into the GOT for this entry.  */

static bfd_vma
mips_elf_got16_entry (abfd, info, value, external)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
     boolean external;
{
  asection *sgot;
  struct mips_got_info *g;
  bfd_byte *entry;
  bfd_byte *last_entry;
  bfd_vma index = 0;
  bfd_vma address;

  if (! external)
    {
      /* Although the ABI says that it is "the high-order 16 bits" that we
	 want, it is really the %high value.  The complete value is
	 calculated with a `addiu' of a LO16 relocation, just as with a
	 HI16/LO16 pair.  */
      value = mips_elf_high (value) << 16;
    }

  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we already have an appropriate entry.  */
  last_entry = sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
  for (entry = (sgot->contents
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
       entry != last_entry;
       entry += MIPS_ELF_GOT_SIZE (abfd))
    {
      address = MIPS_ELF_GET_WORD (abfd, entry);
      if (address == value)
	{
	  /* This entry has the right high-order 16 bits, and the low-order
	     16 bits are set to zero.  */
	  index = entry - sgot->contents;
	  break;
	}
    }

  /* If we didn't have an appropriate entry, we create one now.  */
  if (entry == last_entry)
    index = mips_elf_create_local_got_entry (abfd, g, sgot, value);

  return index;
}

/* Returns the first relocation of type r_type found, beginning with
   RELOCATION.  RELEND is one-past-the-end of the relocation table.  */

static const Elf_Internal_Rela *
mips_elf_next_relocation (r_type, relocation, relend)
     unsigned int r_type;
     const Elf_Internal_Rela *relocation;
     const Elf_Internal_Rela *relend;
{
  /* According to the MIPS ELF ABI, the R_MIPS_LO16 relocation must be
     immediately following.  However, for the IRIX6 ABI, the next
     relocation may be a composed relocation consisting of several
     relocations for the same address.  In that case, the R_MIPS_LO16
     relocation may occur as one of these.  We permit a similar
     extension in general, as that is useful for GCC.  */
  while (relocation < relend)
    {
      if (ELF32_R_TYPE (relocation->r_info) == r_type)
	return relocation;

      ++relocation;
    }

  /* We didn't find it.  */
  bfd_set_error (bfd_error_bad_value);
  return NULL;
}

/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL
   is the original relocation, which is now being transformed into a
   dynamic relocation.  The ADDENDP is adjusted if necessary; the
   caller should store the result in place of the original addend.  */

static boolean
mips_elf_create_dynamic_relocation (output_bfd, info, rel, h, sec,
				    symbol, addendp, input_section)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const Elf_Internal_Rela *rel;
     struct mips_elf_link_hash_entry *h;
     asection *sec;
     bfd_vma symbol;
     bfd_vma *addendp;
     asection *input_section;
{
  Elf_Internal_Rel outrel;
  boolean skip;
  asection *sreloc;
  bfd *dynobj;
  int r_type;

  r_type = ELF32_R_TYPE (rel->r_info);
  dynobj = elf_hash_table (info)->dynobj;
  sreloc
    = bfd_get_section_by_name (dynobj,
			       MIPS_ELF_REL_DYN_SECTION_NAME (output_bfd));
  BFD_ASSERT (sreloc != NULL);
  BFD_ASSERT (sreloc->contents != NULL);
  BFD_ASSERT (sreloc->reloc_count * MIPS_ELF_REL_SIZE (output_bfd)
	      < sreloc->_raw_size);

  skip = false;
  outrel.r_offset =
    _bfd_elf_section_offset (output_bfd, info, input_section, rel->r_offset);
  if (outrel.r_offset == (bfd_vma) -1)
    skip = true;
  /* FIXME: For -2 runtime relocation needs to be skipped, but
     properly resolved statically and installed.  */
  BFD_ASSERT (outrel.r_offset != (bfd_vma) -2);

  /* If we've decided to skip this relocation, just output an empty
     record.  Note that R_MIPS_NONE == 0, so that this call to memset
     is a way of setting R_TYPE to R_MIPS_NONE.  */
  if (skip)
    memset (&outrel, 0, sizeof (outrel));
  else
    {
      long indx;
      bfd_vma section_offset;

      /* We must now calculate the dynamic symbol table index to use
	 in the relocation.  */
      if (h != NULL
	  && (! info->symbolic || (h->root.elf_link_hash_flags
				   & ELF_LINK_HASH_DEF_REGULAR) == 0))
	{
	  indx = h->root.dynindx;
	  /* h->root.dynindx may be -1 if this symbol was marked to
	     become local.  */
	  if (indx == -1)
	    indx = 0;
	}
      else
	{
	  if (sec != NULL && bfd_is_abs_section (sec))
	    indx = 0;
	  else if (sec == NULL || sec->owner == NULL)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  else
	    {
	      indx = elf_section_data (sec->output_section)->dynindx;
	      if (indx == 0)
		abort ();
	    }

	  /* Figure out how far the target of the relocation is from
	     the beginning of its section.  */
	  section_offset = symbol - sec->output_section->vma;
	  /* The relocation we're building is section-relative.
	     Therefore, the original addend must be adjusted by the
	     section offset.  */
	  *addendp += section_offset;
	  /* Now, the relocation is just against the section.  */
	  symbol = sec->output_section->vma;
	}

      /* If the relocation was previously an absolute relocation and
	 this symbol will not be referred to by the relocation, we must
	 adjust it by the value we give it in the dynamic symbol table.
	 Otherwise leave the job up to the dynamic linker.  */
      if (!indx && r_type != R_MIPS_REL32)
	*addendp += symbol;

      /* The relocation is always an REL32 relocation because we don't
	 know where the shared library will wind up at load-time.  */
      outrel.r_info = ELF32_R_INFO (indx, R_MIPS_REL32);

      /* Adjust the output offset of the relocation to reference the
	 correct location in the output file.  */
      outrel.r_offset += (input_section->output_section->vma
			  + input_section->output_offset);
    }

  /* Put the relocation back out.  We have to use the special
     relocation outputter in the 64-bit case since the 64-bit
     relocation format is non-standard.  */
  if (ABI_64_P (output_bfd))
    {
      (*get_elf_backend_data (output_bfd)->s->swap_reloc_out)
	(output_bfd, &outrel,
	 (sreloc->contents
	  + sreloc->reloc_count * sizeof (Elf64_Mips_External_Rel)));
    }
  else
    bfd_elf32_swap_reloc_out (output_bfd, &outrel,
			      (((Elf32_External_Rel *)
				sreloc->contents)
			       + sreloc->reloc_count));

  /* Record the index of the first relocation referencing H.  This
     information is later emitted in the .msym section.  */
  if (h != NULL
      && (h->min_dyn_reloc_index == 0
	  || sreloc->reloc_count < h->min_dyn_reloc_index))
    h->min_dyn_reloc_index = sreloc->reloc_count;

  /* We've now added another relocation.  */
  ++sreloc->reloc_count;

  /* Make sure the output section is writable.  The dynamic linker
     will be writing to it.  */
  elf_section_data (input_section->output_section)->this_hdr.sh_flags
    |= SHF_WRITE;

  /* On IRIX5, make an entry of compact relocation info.  */
  if (! skip && IRIX_COMPAT (output_bfd) == ict_irix5)
    {
      asection *scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
      bfd_byte *cr;

      if (scpt)
	{
	  Elf32_crinfo cptrel;

	  mips_elf_set_cr_format (cptrel, CRF_MIPS_LONG);
	  cptrel.vaddr = (rel->r_offset
			  + input_section->output_section->vma
			  + input_section->output_offset);
	  if (r_type == R_MIPS_REL32)
	    mips_elf_set_cr_type (cptrel, CRT_MIPS_REL32);
	  else
	    mips_elf_set_cr_type (cptrel, CRT_MIPS_WORD);
	  mips_elf_set_cr_dist2to (cptrel, 0);
	  cptrel.konst = *addendp;

	  cr = (scpt->contents
		+ sizeof (Elf32_External_compact_rel));
	  bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
				     ((Elf32_External_crinfo *) cr
				      + scpt->reloc_count));
	  ++scpt->reloc_count;
	}
    }

  return true;
}

/* Calculate the value produced by the RELOCATION (which comes from
   the INPUT_BFD).  The ADDEND is the addend to use for this
   RELOCATION; RELOCATION->R_ADDEND is ignored.

   The result of the relocation calculation is stored in VALUEP.
   REQUIRE_JALXP indicates whether or not the opcode used with this
   relocation must be JALX.

   This function returns bfd_reloc_continue if the caller need take no
   further action regarding this relocation, bfd_reloc_notsupported if
   something goes dramatically wrong, bfd_reloc_overflow if an
   overflow occurs, and bfd_reloc_ok to indicate success.  */

static bfd_reloc_status_type
mips_elf_calculate_relocation (abfd,
			       input_bfd,
			       input_section,
			       info,
			       relocation,
			       addend,
			       howto,
			       local_syms,
			       local_sections,
			       valuep,
			       namep,
			       require_jalxp)
     bfd *abfd;
     bfd *input_bfd;
     asection *input_section;
     struct bfd_link_info *info;
     const Elf_Internal_Rela *relocation;
     bfd_vma addend;
     reloc_howto_type *howto;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
     bfd_vma *valuep;
     const char **namep;
     boolean *require_jalxp;
{
  /* The eventual value we will return.  */
  bfd_vma value;
  /* The address of the symbol against which the relocation is
     occurring.  */
  bfd_vma symbol = 0;
  /* The final GP value to be used for the relocatable, executable, or
     shared object file being produced.  */
  bfd_vma gp = (bfd_vma) - 1;
  /* The place (section offset or address) of the storage unit being
     relocated.  */
  bfd_vma p;
  /* The value of GP used to create the relocatable object.  */
  bfd_vma gp0 = (bfd_vma) - 1;
  /* The offset into the global offset table at which the address of
     the relocation entry symbol, adjusted by the addend, resides
     during execution.  */
  bfd_vma g = (bfd_vma) - 1;
  /* The section in which the symbol referenced by the relocation is
     located.  */
  asection *sec = NULL;
  struct mips_elf_link_hash_entry *h = NULL;
  /* True if the symbol referred to by this relocation is a local
     symbol.  */
  boolean local_p;
  /* True if the symbol referred to by this relocation is "_gp_disp".  */
  boolean gp_disp_p = false;
  Elf_Internal_Shdr *symtab_hdr;
  size_t extsymoff;
  unsigned long r_symndx;
  int r_type;
  /* True if overflow occurred during the calculation of the
     relocation value.  */
  boolean overflowed_p;
  /* True if this relocation refers to a MIPS16 function.  */
  boolean target_is_16_bit_code_p = false;

  /* Parse the relocation.  */
  r_symndx = ELF32_R_SYM (relocation->r_info);
  r_type = ELF32_R_TYPE (relocation->r_info);
  p = (input_section->output_section->vma
       + input_section->output_offset
       + relocation->r_offset);

  /* Assume that there will be no overflow.  */
  overflowed_p = false;

  /* Figure out whether or not the symbol is local, and get the offset
     used in the array of hash table entries.  */
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  local_p = mips_elf_local_relocation_p (input_bfd, relocation,
					 local_sections, false);
  if (! elf_bad_symtab (input_bfd))
    extsymoff = symtab_hdr->sh_info;
  else
    {
      /* The symbol table does not follow the rule that local symbols
	 must come before globals.  */
      extsymoff = 0;
    }

  /* Figure out the value of the symbol.  */
  if (local_p)
    {
      Elf_Internal_Sym *sym;

      sym = local_syms + r_symndx;
      sec = local_sections[r_symndx];

      symbol = sec->output_section->vma + sec->output_offset;
      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
	symbol += sym->st_value;

      /* MIPS16 text labels should be treated as odd.  */
      if (sym->st_other == STO_MIPS16)
	++symbol;

      /* Record the name of this symbol, for our caller.  */
      *namep = bfd_elf_string_from_elf_section (input_bfd,
						symtab_hdr->sh_link,
						sym->st_name);
      if (*namep == '\0')
	*namep = bfd_section_name (input_bfd, sec);

      target_is_16_bit_code_p = (sym->st_other == STO_MIPS16);
    }
  else
    {
      /* For global symbols we look up the symbol in the hash-table.  */
      h = ((struct mips_elf_link_hash_entry *)
	   elf_sym_hashes (input_bfd) [r_symndx - extsymoff]);
      /* Find the real hash-table entry for this symbol.  */
      while (h->root.root.type == bfd_link_hash_indirect
	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

      /* Record the name of this symbol, for our caller.  */
      *namep = h->root.root.root.string;

      /* See if this is the special _gp_disp symbol.  Note that such a
	 symbol must always be a global symbol.  */
      if (strcmp (h->root.root.root.string, "_gp_disp") == 0)
	{
	  /* Relocations against _gp_disp are permitted only with
	     R_MIPS_HI16 and R_MIPS_LO16 relocations.  */
	  if (r_type != R_MIPS_HI16 && r_type != R_MIPS_LO16)
	    return bfd_reloc_notsupported;

	  gp_disp_p = true;
	}
      /* If this symbol is defined, calculate its address.  Note that
	 _gp_disp is a magic symbol, always implicitly defined by the
	 linker, so it's inappropriate to check to see whether or not
	 its defined.  */
      else if ((h->root.root.type == bfd_link_hash_defined
		|| h->root.root.type == bfd_link_hash_defweak)
	       && h->root.root.u.def.section)
	{
	  sec = h->root.root.u.def.section;
	  if (sec->output_section)
	    symbol = (h->root.root.u.def.value
		      + sec->output_section->vma
		      + sec->output_offset);
	  else
	    symbol = h->root.root.u.def.value;
	}
      else if (h->root.root.type == bfd_link_hash_undefweak)
	/* We allow relocations against undefined weak symbols, giving
	   it the value zero, so that you can undefined weak functions
	   and check to see if they exist by looking at their
	   addresses.  */
	symbol = 0;
      else if (info->shared
	       && (!info->symbolic || info->allow_shlib_undefined)
	       && !info->no_undefined
	       && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
	symbol = 0;
      else if (strcmp (h->root.root.root.string, "_DYNAMIC_LINK") == 0 ||
              strcmp (h->root.root.root.string, "_DYNAMIC_LINKING") == 0)
	{
	  /* If this is a dynamic link, we should have created a
	     _DYNAMIC_LINK symbol or _DYNAMIC_LINKING(for normal mips) symbol
	     in in mips_elf_create_dynamic_sections.
	     Otherwise, we should define the symbol with a value of 0.
	     FIXME: It should probably get into the symbol table
	     somehow as well.  */
	  BFD_ASSERT (! info->shared);
	  BFD_ASSERT (bfd_get_section_by_name (abfd, ".dynamic") == NULL);
	  symbol = 0;
	}
      else
	{
	  if (! ((*info->callbacks->undefined_symbol)
		 (info, h->root.root.root.string, input_bfd,
		  input_section, relocation->r_offset,
		  (!info->shared || info->no_undefined
		   || ELF_ST_VISIBILITY (h->root.other)))))
	    return bfd_reloc_undefined;
	  symbol = 0;
	}

      target_is_16_bit_code_p = (h->root.other == STO_MIPS16);
    }

  /* If this is a 32-bit call to a 16-bit function with a stub, we
     need to redirect the call to the stub, unless we're already *in*
     a stub.  */
  if (r_type != R_MIPS16_26 && !info->relocateable
      && ((h != NULL && h->fn_stub != NULL)
	  || (local_p && elf_tdata (input_bfd)->local_stubs != NULL
	      && elf_tdata (input_bfd)->local_stubs[r_symndx] != NULL))
      && !mips_elf_stub_section_p (input_bfd, input_section))
    {
      /* This is a 32-bit call to a 16-bit function.  We should
	 have already noticed that we were going to need the
	 stub.  */
      if (local_p)
	sec = elf_tdata (input_bfd)->local_stubs[r_symndx];
      else
	{
	  BFD_ASSERT (h->need_fn_stub);
	  sec = h->fn_stub;
	}

      symbol = sec->output_section->vma + sec->output_offset;
    }
  /* If this is a 16-bit call to a 32-bit function with a stub, we
     need to redirect the call to the stub.  */
  else if (r_type == R_MIPS16_26 && !info->relocateable
	   && h != NULL
	   && (h->call_stub != NULL || h->call_fp_stub != NULL)
	   && !target_is_16_bit_code_p)
    {
      /* If both call_stub and call_fp_stub are defined, we can figure
	 out which one to use by seeing which one appears in the input
	 file.  */
      if (h->call_stub != NULL && h->call_fp_stub != NULL)
	{
	  asection *o;

	  sec = NULL;
	  for (o = input_bfd->sections; o != NULL; o = o->next)
	    {
	      if (strncmp (bfd_get_section_name (input_bfd, o),
			   CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
		{
		  sec = h->call_fp_stub;
		  break;
		}
	    }
	  if (sec == NULL)
	    sec = h->call_stub;
	}
      else if (h->call_stub != NULL)
	sec = h->call_stub;
      else
	sec = h->call_fp_stub;

      BFD_ASSERT (sec->_raw_size > 0);
      symbol = sec->output_section->vma + sec->output_offset;
    }

  /* Calls from 16-bit code to 32-bit code and vice versa require the
     special jalx instruction.  */
  *require_jalxp = (!info->relocateable
                    && (((r_type == R_MIPS16_26) && !target_is_16_bit_code_p)
                        || ((r_type == R_MIPS_26) && target_is_16_bit_code_p)));

  local_p = mips_elf_local_relocation_p (input_bfd, relocation,
					 local_sections, true);

  /* If we haven't already determined the GOT offset, or the GP value,
     and we're going to need it, get it now.  */
  switch (r_type)
    {
    case R_MIPS_CALL16:
    case R_MIPS_GOT16:
    case R_MIPS_GOT_DISP:
    case R_MIPS_GOT_HI16:
    case R_MIPS_CALL_HI16:
    case R_MIPS_GOT_LO16:
    case R_MIPS_CALL_LO16:
      /* Find the index into the GOT where this value is located.  */
      if (!local_p)
	{
	  BFD_ASSERT (addend == 0);
	  g = mips_elf_global_got_index
	    (elf_hash_table (info)->dynobj,
	     (struct elf_link_hash_entry *) h);
	  if (! elf_hash_table(info)->dynamic_sections_created
	      || (info->shared
		  && (info->symbolic || h->root.dynindx == -1)
		  && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	    {
	      /* This is a static link or a -Bsymbolic link.  The
		 symbol is defined locally, or was forced to be local.
		 We must initialize this entry in the GOT.  */
	      asection *sgot = mips_elf_got_section(elf_hash_table
						    (info)->dynobj);
	      MIPS_ELF_PUT_WORD (elf_hash_table (info)->dynobj,
				 symbol + addend, sgot->contents + g);
	    }
	}
      else if (r_type == R_MIPS_GOT16 || r_type == R_MIPS_CALL16)
	/* There's no need to create a local GOT entry here; the
	   calculation for a local GOT16 entry does not involve G.  */
	break;
      else
	{
	  g = mips_elf_local_got_index (abfd, info, symbol + addend);
	  if (g == (bfd_vma) -1)
	    return bfd_reloc_outofrange;
	}

      /* Convert GOT indices to actual offsets.  */
      g = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					  abfd, g);
      break;

    case R_MIPS_HI16:
    case R_MIPS_LO16:
    case R_MIPS16_GPREL:
    case R_MIPS_GPREL16:
    case R_MIPS_GPREL32:
    case R_MIPS_LITERAL:
      gp0 = _bfd_get_gp_value (input_bfd);
      gp = _bfd_get_gp_value (abfd);
      break;

    default:
      break;
    }

  /* Figure out what kind of relocation is being performed.  */
  switch (r_type)
    {
    case R_MIPS_NONE:
      return bfd_reloc_continue;

    case R_MIPS_16:
      value = symbol + mips_elf_sign_extend (addend, 16);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_32:
    case R_MIPS_REL32:
    case R_MIPS_64:
      if ((info->shared
	   || (elf_hash_table (info)->dynamic_sections_created
	       && h != NULL
	       && ((h->root.elf_link_hash_flags
		    & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
	       && ((h->root.elf_link_hash_flags
		    & ELF_LINK_HASH_DEF_REGULAR) == 0)))
	  && r_symndx != 0
	  && (input_section->flags & SEC_ALLOC) != 0)
	{
	  /* If we're creating a shared library, or this relocation is
	     against a symbol in a shared library, then we can't know
	     where the symbol will end up.  So, we create a relocation
	     record in the output, and leave the job up to the dynamic
	     linker.  */
	  value = addend;
	  if (!mips_elf_create_dynamic_relocation (abfd,
						   info,
						   relocation,
						   h,
						   sec,
						   symbol,
						   &value,
						   input_section))
	    return bfd_reloc_undefined;
	}
      else
	{
	  if (r_type != R_MIPS_REL32)
	    value = symbol + addend;
	  else
	    value = addend;
	}
      value &= howto->dst_mask;
      break;

    case R_MIPS_PC32:
    case R_MIPS_PC64:
    case R_MIPS_GNU_REL_LO16:
      value = symbol + addend - p;
      value &= howto->dst_mask;
      break;
d866 4
a869 5
    case R_MIPS_GNU_REL16_S2:
      value = symbol + mips_elf_sign_extend (addend << 2, 18) - p;
      overflowed_p = mips_elf_overflow_p (value, 18);
      value = (value >> 2) & howto->dst_mask;
      break;
d871 5
a875 9
    case R_MIPS_GNU_REL_HI16:
      /* Instead of subtracting 'p' here, we should be subtracting the
	 equivalent value for the LO part of the reloc, since the value
	 here is relative to that address.  Because that's not easy to do,
	 we adjust 'addend' in _bfd_mips_elf_relocate_section().  See also
	 the comment there for more information.  */
      value = mips_elf_high (addend + symbol - p);
      value &= howto->dst_mask;
      break;
d877 3
a879 13
    case R_MIPS16_26:
      /* The calculation for R_MIPS16_26 is just the same as for an
	 R_MIPS_26.  It's only the storage of the relocated field into
	 the output file that's different.  That's handled in
	 mips_elf_perform_relocation.  So, we just fall through to the
	 R_MIPS_26 case here.  */
    case R_MIPS_26:
      if (local_p)
	value = (((addend << 2) | ((p + 4) & 0xf0000000)) + symbol) >> 2;
      else
	value = (mips_elf_sign_extend (addend << 2, 28) + symbol) >> 2;
      value &= howto->dst_mask;
      break;
d881 1
a881 177
    case R_MIPS_HI16:
      if (!gp_disp_p)
	{
	  value = mips_elf_high (addend + symbol);
	  value &= howto->dst_mask;
	}
      else
	{
	  value = mips_elf_high (addend + gp - p);
	  overflowed_p = mips_elf_overflow_p (value, 16);
	}
      break;

    case R_MIPS_LO16:
      if (!gp_disp_p)
	value = (symbol + addend) & howto->dst_mask;
      else
	{
	  value = addend + gp - p + 4;
	  /* The MIPS ABI requires checking the R_MIPS_LO16 relocation
	     for overflow.  But, on, say, Irix 5, relocations against
	     _gp_disp are normally generated from the .cpload
	     pseudo-op.  It generates code that normally looks like
	     this:

	       lui    $gp,%hi(_gp_disp)
	       addiu  $gp,$gp,%lo(_gp_disp)
	       addu   $gp,$gp,$t9

	     Here $t9 holds the address of the function being called,
	     as required by the MIPS ELF ABI.  The R_MIPS_LO16
	     relocation can easily overflow in this situation, but the
	     R_MIPS_HI16 relocation will handle the overflow.
	     Therefore, we consider this a bug in the MIPS ABI, and do
	     not check for overflow here.  */
	}
      break;

    case R_MIPS_LITERAL:
      /* Because we don't merge literal sections, we can handle this
	 just like R_MIPS_GPREL16.  In the long run, we should merge
	 shared literals, and then we will need to additional work
	 here.  */

      /* Fall through.  */

    case R_MIPS16_GPREL:
      /* The R_MIPS16_GPREL performs the same calculation as
	 R_MIPS_GPREL16, but stores the relocated bits in a different
	 order.  We don't need to do anything special here; the
	 differences are handled in mips_elf_perform_relocation.  */
    case R_MIPS_GPREL16:
      if (local_p)
	value = mips_elf_sign_extend (addend, 16) + symbol + gp0 - gp;
      else
	value = mips_elf_sign_extend (addend, 16) + symbol - gp;
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_GOT16:
    case R_MIPS_CALL16:
      if (local_p)
	{
	  boolean forced;

	  /* The special case is when the symbol is forced to be local.  We
	     need the full address in the GOT since no R_MIPS_LO16 relocation
	     follows.  */
	  forced = ! mips_elf_local_relocation_p (input_bfd, relocation,
						  local_sections, false);
	  value = mips_elf_got16_entry (abfd, info, symbol + addend, forced);
	  if (value == (bfd_vma) -1)
	    return bfd_reloc_outofrange;
	  value
	    = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					      abfd,
					      value);
	  overflowed_p = mips_elf_overflow_p (value, 16);
	  break;
	}

      /* Fall through.  */

    case R_MIPS_GOT_DISP:
      value = g;
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_GPREL32:
      value = (addend + symbol + gp0 - gp) & howto->dst_mask;
      break;

    case R_MIPS_PC16:
      value = mips_elf_sign_extend (addend, 16) + symbol - p;
      overflowed_p = mips_elf_overflow_p (value, 16);
      value = (bfd_vma) ((bfd_signed_vma) value / 4);
      break;

    case R_MIPS_GOT_HI16:
    case R_MIPS_CALL_HI16:
      /* We're allowed to handle these two relocations identically.
	 The dynamic linker is allowed to handle the CALL relocations
	 differently by creating a lazy evaluation stub.  */
      value = g;
      value = mips_elf_high (value);
      value &= howto->dst_mask;
      break;

    case R_MIPS_GOT_LO16:
    case R_MIPS_CALL_LO16:
      value = g & howto->dst_mask;
      break;

    case R_MIPS_GOT_PAGE:
      value = mips_elf_got_page (abfd, info, symbol + addend, NULL);
      if (value == (bfd_vma) -1)
	return bfd_reloc_outofrange;
      value = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					      abfd,
					      value);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_GOT_OFST:
      mips_elf_got_page (abfd, info, symbol + addend, &value);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_SUB:
      value = symbol - addend;
      value &= howto->dst_mask;
      break;

    case R_MIPS_HIGHER:
      value = mips_elf_higher (addend + symbol);
      value &= howto->dst_mask;
      break;

    case R_MIPS_HIGHEST:
      value = mips_elf_highest (addend + symbol);
      value &= howto->dst_mask;
      break;

    case R_MIPS_SCN_DISP:
      value = symbol + addend - sec->output_offset;
      value &= howto->dst_mask;
      break;

    case R_MIPS_PJUMP:
    case R_MIPS_JALR:
      /* Both of these may be ignored.  R_MIPS_JALR is an optimization
	 hint; we could improve performance by honoring that hint.  */
      return bfd_reloc_continue;

    case R_MIPS_GNU_VTINHERIT:
    case R_MIPS_GNU_VTENTRY:
      /* We don't do anything with these at present.  */
      return bfd_reloc_continue;

    default:
      /* An unrecognized relocation type.  */
      return bfd_reloc_notsupported;
    }

  /* Store the VALUE for our caller.  */
  *valuep = value;
  return overflowed_p ? bfd_reloc_overflow : bfd_reloc_ok;
}

/* Obtain the field relocated by RELOCATION.  */

static bfd_vma
mips_elf_obtain_contents (howto, relocation, input_bfd, contents)
     reloc_howto_type *howto;
     const Elf_Internal_Rela *relocation;
     bfd *input_bfd;
     bfd_byte *contents;
d883 4
a886 2
  bfd_vma x;
  bfd_byte *location = contents + relocation->r_offset;
d888 1
a888 2
  /* Obtain the bytes.  */
  x = bfd_get (((bfd_vma)(8 * bfd_get_reloc_size (howto))), input_bfd, location);
d890 1
a890 6
  if ((ELF32_R_TYPE (relocation->r_info) == R_MIPS16_26
       || ELF32_R_TYPE (relocation->r_info) == R_MIPS16_GPREL)
      && bfd_little_endian (input_bfd))
    /* The two 16-bit words will be reversed on a little-endian
       system.  See mips_elf_perform_relocation for more details.  */
    x = (((x & 0xffff) << 16) | ((x & 0xffff0000) >> 16));
d892 7
a898 21
  return x;
}

/* It has been determined that the result of the RELOCATION is the
   VALUE.  Use HOWTO to place VALUE into the output file at the
   appropriate position.  The SECTION is the section to which the
   relocation applies.  If REQUIRE_JALX is true, then the opcode used
   for the relocation must be either JAL or JALX, and it is
   unconditionally converted to JALX.

   Returns false if anything goes wrong.  */

static boolean
mips_elf_perform_relocation (info, howto, relocation, value,
			     input_bfd, input_section,
			     contents, require_jalx)
     struct bfd_link_info *info;
     reloc_howto_type *howto;
     const Elf_Internal_Rela *relocation;
     bfd_vma value;
     bfd *input_bfd;
a899 179
     bfd_byte *contents;
     boolean require_jalx;
{
  bfd_vma x;
  bfd_byte *location;
  int r_type = ELF32_R_TYPE (relocation->r_info);

  /* Figure out where the relocation is occurring.  */
  location = contents + relocation->r_offset;

  /* Obtain the current value.  */
  x = mips_elf_obtain_contents (howto, relocation, input_bfd, contents);

  /* Clear the field we are setting.  */
  x &= ~howto->dst_mask;

  /* If this is the R_MIPS16_26 relocation, we must store the
     value in a funny way.  */
  if (r_type == R_MIPS16_26)
    {
      /* R_MIPS16_26 is used for the mips16 jal and jalx instructions.
	 Most mips16 instructions are 16 bits, but these instructions
	 are 32 bits.

	 The format of these instructions is:

	 +--------------+--------------------------------+
	 !     JALX     ! X!   Imm 20:16  !   Imm 25:21  !
	 +--------------+--------------------------------+
	 !	  	  Immediate  15:0		    !
	 +-----------------------------------------------+

	 JALX is the 5-bit value 00011.  X is 0 for jal, 1 for jalx.
	 Note that the immediate value in the first word is swapped.

	 When producing a relocateable object file, R_MIPS16_26 is
	 handled mostly like R_MIPS_26.  In particular, the addend is
	 stored as a straight 26-bit value in a 32-bit instruction.
	 (gas makes life simpler for itself by never adjusting a
	 R_MIPS16_26 reloc to be against a section, so the addend is
	 always zero).  However, the 32 bit instruction is stored as 2
	 16-bit values, rather than a single 32-bit value.  In a
	 big-endian file, the result is the same; in a little-endian
	 file, the two 16-bit halves of the 32 bit value are swapped.
	 This is so that a disassembler can recognize the jal
	 instruction.

	 When doing a final link, R_MIPS16_26 is treated as a 32 bit
	 instruction stored as two 16-bit values.  The addend A is the
	 contents of the targ26 field.  The calculation is the same as
	 R_MIPS_26.  When storing the calculated value, reorder the
	 immediate value as shown above, and don't forget to store the
	 value as two 16-bit values.

	 To put it in MIPS ABI terms, the relocation field is T-targ26-16,
	 defined as

	 big-endian:
	 +--------+----------------------+
	 |        |                      |
	 |        |    targ26-16         |
	 |31    26|25                   0|
	 +--------+----------------------+

	 little-endian:
	 +----------+------+-------------+
	 |          |      |             |
	 |  sub1    |      |     sub2    |
	 |0        9|10  15|16         31|
	 +----------+--------------------+
	 where targ26-16 is sub1 followed by sub2 (i.e., the addend field A is
	 ((sub1 << 16) | sub2)).

	 When producing a relocateable object file, the calculation is
	 (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
	 When producing a fully linked file, the calculation is
	 let R = (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
	 ((R & 0x1f0000) << 5) | ((R & 0x3e00000) >> 5) | (R & 0xffff)  */

      if (!info->relocateable)
	/* Shuffle the bits according to the formula above.  */
	value = (((value & 0x1f0000) << 5)
		 | ((value & 0x3e00000) >> 5)
		 | (value & 0xffff));
    }
  else if (r_type == R_MIPS16_GPREL)
    {
      /* R_MIPS16_GPREL is used for GP-relative addressing in mips16
	 mode.  A typical instruction will have a format like this:

	 +--------------+--------------------------------+
	 !    EXTEND    !     Imm 10:5    !   Imm 15:11  !
	 +--------------+--------------------------------+
	 !    Major     !   rx   !   ry   !   Imm  4:0   !
	 +--------------+--------------------------------+

	 EXTEND is the five bit value 11110.  Major is the instruction
	 opcode.

	 This is handled exactly like R_MIPS_GPREL16, except that the
	 addend is retrieved and stored as shown in this diagram; that
	 is, the Imm fields above replace the V-rel16 field.

         All we need to do here is shuffle the bits appropriately.  As
	 above, the two 16-bit halves must be swapped on a
	 little-endian system.  */
      value = (((value & 0x7e0) << 16)
	       | ((value & 0xf800) << 5)
	       | (value & 0x1f));
    }

  /* Set the field.  */
  x |= (value & howto->dst_mask);

  /* If required, turn JAL into JALX.  */
  if (require_jalx)
    {
      boolean ok;
      bfd_vma opcode = x >> 26;
      bfd_vma jalx_opcode;

      /* Check to see if the opcode is already JAL or JALX.  */
      if (r_type == R_MIPS16_26)
	{
	  ok = ((opcode == 0x6) || (opcode == 0x7));
	  jalx_opcode = 0x7;
	}
      else
	{
	  ok = ((opcode == 0x3) || (opcode == 0x1d));
	  jalx_opcode = 0x1d;
	}

      /* If the opcode is not JAL or JALX, there's a problem.  */
      if (!ok)
	{
	  (*_bfd_error_handler)
	    (_("%s: %s+0x%lx: jump to stub routine which is not jal"),
	     bfd_archive_filename (input_bfd),
	     input_section->name,
	     (unsigned long) relocation->r_offset);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}

      /* Make this the JALX opcode.  */
      x = (x & ~(0x3f << 26)) | (jalx_opcode << 26);
    }

  /* Swap the high- and low-order 16 bits on little-endian systems
     when doing a MIPS16 relocation.  */
  if ((r_type == R_MIPS16_GPREL || r_type == R_MIPS16_26)
      && bfd_little_endian (input_bfd))
    x = (((x & 0xffff) << 16) | ((x & 0xffff0000) >> 16));

  /* Put the value into the output.  */
  bfd_put (8 * bfd_get_reloc_size (howto), input_bfd, x, location);
  return true;
}

/* Returns true if SECTION is a MIPS16 stub section.  */

static boolean
mips_elf_stub_section_p (abfd, section)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
{
  const char *name = bfd_get_section_name (abfd, section);

  return (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0
	  || strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
	  || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0);
}

/* Relocate a MIPS ELF section.  */

boolean
_bfd_mips_elf_relocate_section (output_bfd, info, input_bfd, input_section,
				contents, relocs, local_syms, local_sections)
d901 1
a901 7
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d903 3
a905 19
  Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *relend;
  bfd_vma addend = 0;
  boolean use_saved_addend_p = false;
  struct elf_backend_data *bed;

  bed = get_elf_backend_data (output_bfd);
  relend = relocs + input_section->reloc_count * bed->s->int_rels_per_ext_rel;
  for (rel = relocs; rel < relend; ++rel)
    {
      const char *name;
      bfd_vma value;
      reloc_howto_type *howto;
      boolean require_jalx;
      /* True if the relocation is a RELA relocation, rather than a
         REL relocation.  */
      boolean rela_relocation_p = true;
      unsigned int r_type = ELF32_R_TYPE (rel->r_info);
      const char * msg = (const char *) NULL;
d907 5
a911 580
      /* Find the relocation howto for this relocation.  */
      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
	{
	  /* Some 32-bit code uses R_MIPS_64.  In particular, people use
	     64-bit code, but make sure all their addresses are in the
	     lowermost or uppermost 32-bit section of the 64-bit address
	     space.  Thus, when they use an R_MIPS_64 they mean what is
	     usually meant by R_MIPS_32, with the exception that the
	     stored value is sign-extended to 64 bits.  */
	  howto = elf_mips_howto_table_rel + R_MIPS_32;

	  /* On big-endian systems, we need to lie about the position
	     of the reloc.  */
	  if (bfd_big_endian (input_bfd))
	    rel->r_offset += 4;
	}
      else
	howto = mips_rtype_to_howto (r_type);

      if (!use_saved_addend_p)
	{
	  Elf_Internal_Shdr *rel_hdr;

	  /* If these relocations were originally of the REL variety,
	     we must pull the addend out of the field that will be
	     relocated.  Otherwise, we simply use the contents of the
	     RELA relocation.  To determine which flavor or relocation
	     this is, we depend on the fact that the INPUT_SECTION's
	     REL_HDR is read before its REL_HDR2.  */
	  rel_hdr = &elf_section_data (input_section)->rel_hdr;
	  if ((size_t) (rel - relocs)
	      >= (NUM_SHDR_ENTRIES (rel_hdr) * bed->s->int_rels_per_ext_rel))
	    rel_hdr = elf_section_data (input_section)->rel_hdr2;
	  if (rel_hdr->sh_entsize == MIPS_ELF_REL_SIZE (input_bfd))
	    {
	      /* Note that this is a REL relocation.  */
	      rela_relocation_p = false;

	      /* Get the addend, which is stored in the input file.  */
	      addend = mips_elf_obtain_contents (howto,
						 rel,
						 input_bfd,
						 contents);
	      addend &= howto->src_mask;

	      /* For some kinds of relocations, the ADDEND is a
		 combination of the addend stored in two different
		 relocations.   */
	      if (r_type == R_MIPS_HI16
		  || r_type == R_MIPS_GNU_REL_HI16
		  || (r_type == R_MIPS_GOT16
		      && mips_elf_local_relocation_p (input_bfd, rel,
						      local_sections, false)))
		{
		  bfd_vma l;
		  const Elf_Internal_Rela *lo16_relocation;
		  reloc_howto_type *lo16_howto;
		  unsigned int lo;

		  /* The combined value is the sum of the HI16 addend,
		     left-shifted by sixteen bits, and the LO16
		     addend, sign extended.  (Usually, the code does
		     a `lui' of the HI16 value, and then an `addiu' of
		     the LO16 value.)

		     Scan ahead to find a matching LO16 relocation.  */
		  if (r_type == R_MIPS_GNU_REL_HI16)
		    lo = R_MIPS_GNU_REL_LO16;
		  else
		    lo = R_MIPS_LO16;
		  lo16_relocation
		    = mips_elf_next_relocation (lo, rel, relend);
		  if (lo16_relocation == NULL)
		    return false;

		  /* Obtain the addend kept there.  */
		  lo16_howto = mips_rtype_to_howto (lo);
		  l = mips_elf_obtain_contents (lo16_howto,
						lo16_relocation,
						input_bfd, contents);
		  l &= lo16_howto->src_mask;
		  l = mips_elf_sign_extend (l, 16);

		  addend <<= 16;

		  /* Compute the combined addend.  */
		  addend += l;

		  /* If PC-relative, subtract the difference between the
		     address of the LO part of the reloc and the address of
		     the HI part.  The relocation is relative to the LO
		     part, but mips_elf_calculate_relocation() doesn't know
		     it address or the difference from the HI part, so
		     we subtract that difference here.  See also the
		     comment in mips_elf_calculate_relocation().  */
		  if (r_type == R_MIPS_GNU_REL_HI16)
		    addend -= (lo16_relocation->r_offset - rel->r_offset);
		}
	      else if (r_type == R_MIPS16_GPREL)
		{
		  /* The addend is scrambled in the object file.  See
		     mips_elf_perform_relocation for details on the
		     format.  */
		  addend = (((addend & 0x1f0000) >> 5)
			    | ((addend & 0x7e00000) >> 16)
			    | (addend & 0x1f));
		}
	    }
	  else
	    addend = rel->r_addend;
	}

      if (info->relocateable)
	{
	  Elf_Internal_Sym *sym;
	  unsigned long r_symndx;

	  if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd)
	      && bfd_big_endian (input_bfd))
	    rel->r_offset -= 4;

	  /* Since we're just relocating, all we need to do is copy
	     the relocations back out to the object file, unless
	     they're against a section symbol, in which case we need
	     to adjust by the section offset, or unless they're GP
	     relative in which case we need to adjust by the amount
	     that we're adjusting GP in this relocateable object.  */

	  if (!mips_elf_local_relocation_p (input_bfd, rel, local_sections,
					    false))
	    /* There's nothing to do for non-local relocations.  */
	    continue;

	  if (r_type == R_MIPS16_GPREL
	      || r_type == R_MIPS_GPREL16
	      || r_type == R_MIPS_GPREL32
	      || r_type == R_MIPS_LITERAL)
	    addend -= (_bfd_get_gp_value (output_bfd)
		       - _bfd_get_gp_value (input_bfd));
	  else if (r_type == R_MIPS_26 || r_type == R_MIPS16_26
		   || r_type == R_MIPS_GNU_REL16_S2)
	    /* The addend is stored without its two least
	       significant bits (which are always zero.)  In a
	       non-relocateable link, calculate_relocation will do
	       this shift; here, we must do it ourselves.  */
	    addend <<= 2;

	  r_symndx = ELF32_R_SYM (rel->r_info);
	  sym = local_syms + r_symndx;
	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    /* Adjust the addend appropriately.  */
	    addend += local_sections[r_symndx]->output_offset;

	  /* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16,
	     then we only want to write out the high-order 16 bits.
	     The subsequent R_MIPS_LO16 will handle the low-order bits.  */
	  if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16
	      || r_type == R_MIPS_GNU_REL_HI16)
	    addend = mips_elf_high (addend);
	  /* If the relocation is for an R_MIPS_26 relocation, then
	     the two low-order bits are not stored in the object file;
	     they are implicitly zero.  */
	  else if (r_type == R_MIPS_26 || r_type == R_MIPS16_26
		   || r_type == R_MIPS_GNU_REL16_S2)
	    addend >>= 2;

	  if (rela_relocation_p)
	    /* If this is a RELA relocation, just update the addend.
	       We have to cast away constness for REL.  */
	    rel->r_addend = addend;
	  else
	    {
	      /* Otherwise, we have to write the value back out.  Note
		 that we use the source mask, rather than the
		 destination mask because the place to which we are
		 writing will be source of the addend in the final
		 link.  */
	      addend &= howto->src_mask;

	      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
		/* See the comment above about using R_MIPS_64 in the 32-bit
		   ABI.  Here, we need to update the addend.  It would be
		   possible to get away with just using the R_MIPS_32 reloc
		   but for endianness.  */
		{
		  bfd_vma sign_bits;
		  bfd_vma low_bits;
		  bfd_vma high_bits;

		  if (addend & ((bfd_vma) 1 << 31))
#ifdef BFD64
		    sign_bits = ((bfd_vma) 1 << 32) - 1;
#else
		    sign_bits = -1;
#endif
		  else
		    sign_bits = 0;

		  /* If we don't know that we have a 64-bit type,
		     do two separate stores.  */
		  if (bfd_big_endian (input_bfd))
		    {
		      /* Store the sign-bits (which are most significant)
			 first.  */
		      low_bits = sign_bits;
		      high_bits = addend;
		    }
		  else
		    {
		      low_bits = addend;
		      high_bits = sign_bits;
		    }
		  bfd_put_32 (input_bfd, low_bits,
			      contents + rel->r_offset);
		  bfd_put_32 (input_bfd, high_bits,
			      contents + rel->r_offset + 4);
		  continue;
		}

	      if (!mips_elf_perform_relocation (info, howto, rel, addend,
						input_bfd, input_section,
						contents, false))
		return false;
	    }

	  /* Go on to the next relocation.  */
	  continue;
	}

      /* In the N32 and 64-bit ABIs there may be multiple consecutive
	 relocations for the same offset.  In that case we are
	 supposed to treat the output of each relocation as the addend
	 for the next.  */
      if (rel + 1 < relend
	  && rel->r_offset == rel[1].r_offset
	  && ELF32_R_TYPE (rel[1].r_info) != R_MIPS_NONE)
	use_saved_addend_p = true;
      else
	use_saved_addend_p = false;

      /* Figure out what value we are supposed to relocate.  */
      switch (mips_elf_calculate_relocation (output_bfd,
					     input_bfd,
					     input_section,
					     info,
					     rel,
					     addend,
					     howto,
					     local_syms,
					     local_sections,
					     &value,
					     &name,
					     &require_jalx))
	{
	case bfd_reloc_continue:
	  /* There's nothing to do.  */
	  continue;

	case bfd_reloc_undefined:
	  /* mips_elf_calculate_relocation already called the
	     undefined_symbol callback.  There's no real point in
	     trying to perform the relocation at this point, so we
	     just skip ahead to the next relocation.  */
	  continue;

	case bfd_reloc_notsupported:
	  msg = _("internal error: unsupported relocation error");
	  info->callbacks->warning
	    (info, msg, name, input_bfd, input_section, rel->r_offset);
	  return false;

	case bfd_reloc_overflow:
	  if (use_saved_addend_p)
	    /* Ignore overflow until we reach the last relocation for
	       a given location.  */
	    ;
	  else
	    {
	      BFD_ASSERT (name != NULL);
	      if (! ((*info->callbacks->reloc_overflow)
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
		return false;
	    }
	  break;

	case bfd_reloc_ok:
	  break;

	default:
	  abort ();
	  break;
	}

      /* If we've got another relocation for the address, keep going
	 until we reach the last one.  */
      if (use_saved_addend_p)
	{
	  addend = value;
	  continue;
	}

      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
	/* See the comment above about using R_MIPS_64 in the 32-bit
	   ABI.  Until now, we've been using the HOWTO for R_MIPS_32;
	   that calculated the right value.  Now, however, we
	   sign-extend the 32-bit result to 64-bits, and store it as a
	   64-bit value.  We are especially generous here in that we
	   go to extreme lengths to support this usage on systems with
	   only a 32-bit VMA.  */
	{
	  bfd_vma sign_bits;
	  bfd_vma low_bits;
	  bfd_vma high_bits;

	  if (value & ((bfd_vma) 1 << 31))
#ifdef BFD64
	    sign_bits = ((bfd_vma) 1 << 32) - 1;
#else
	    sign_bits = -1;
#endif
	  else
	    sign_bits = 0;

	  /* If we don't know that we have a 64-bit type,
	     do two separate stores.  */
	  if (bfd_big_endian (input_bfd))
	    {
	      /* Undo what we did above.  */
	      rel->r_offset -= 4;
	      /* Store the sign-bits (which are most significant)
		 first.  */
	      low_bits = sign_bits;
	      high_bits = value;
	    }
	  else
	    {
	      low_bits = value;
	      high_bits = sign_bits;
	    }
	  bfd_put_32 (input_bfd, low_bits,
		      contents + rel->r_offset);
	  bfd_put_32 (input_bfd, high_bits,
		      contents + rel->r_offset + 4);
	  continue;
	}

      /* Actually perform the relocation.  */
      if (!mips_elf_perform_relocation (info, howto, rel, value, input_bfd,
					input_section, contents,
					require_jalx))
	return false;
    }

  return true;
}

/* This hook function is called before the linker writes out a global
   symbol.  We mark symbols as small common if appropriate.  This is
   also where we undo the increment of the value for a mips16 symbol.  */

boolean
_bfd_mips_elf_link_output_symbol_hook (abfd, info, name, sym, input_sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
     Elf_Internal_Sym *sym;
     asection *input_sec;
{
  /* If we see a common symbol, which implies a relocatable link, then
     if a symbol was small common in an input file, mark it as small
     common in the output file.  */
  if (sym->st_shndx == SHN_COMMON
      && strcmp (input_sec->name, ".scommon") == 0)
    sym->st_shndx = SHN_MIPS_SCOMMON;

  if (sym->st_other == STO_MIPS16
      && (sym->st_value & 1) != 0)
    --sym->st_value;

  return true;
}

/* Functions for the dynamic linker.  */

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER(abfd) 		\
   (ABI_N32_P (abfd) ? "/usr/lib32/libc.so.1" 	\
    : ABI_64_P (abfd) ? "/usr/lib64/libc.so.1" 	\
    : "/usr/lib/libc.so.1")

/* Create dynamic sections when linking against a dynamic object.  */

boolean
_bfd_mips_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  struct elf_link_hash_entry *h;
  flagword flags;
  register asection *s;
  const char * const *namep;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED | SEC_READONLY);

  /* Mips ABI requests the .dynamic section to be read only.  */
  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s != NULL)
    {
      if (! bfd_set_section_flags (abfd, s, flags))
	return false;
    }

  /* We need to create .got section.  */
  if (! mips_elf_create_got_section (abfd, info))
    return false;

  /* Create the .msym section on IRIX6.  It is used by the dynamic
     linker to speed up dynamic relocations, and to avoid computing
     the ELF hash for symbols.  */
  if (IRIX_COMPAT (abfd) == ict_irix6
      && !mips_elf_create_msym_section (abfd))
    return false;

  /* Create .stub section.  */
  if (bfd_get_section_by_name (abfd,
			       MIPS_ELF_STUB_SECTION_NAME (abfd)) == NULL)
    {
      s = bfd_make_section (abfd, MIPS_ELF_STUB_SECTION_NAME (abfd));
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_CODE)
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return false;
    }

  if ((IRIX_COMPAT (abfd) == ict_irix5 || IRIX_COMPAT (abfd) == ict_none)
      && !info->shared
      && bfd_get_section_by_name (abfd, ".rld_map") == NULL)
    {
      s = bfd_make_section (abfd, ".rld_map");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags &~ (flagword) SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return false;
    }

  /* On IRIX5, we adjust add some additional symbols and change the
     alignments of several sections.  There is no ABI documentation
     indicating that this is necessary on IRIX6, nor any evidence that
     the linker takes such action.  */
  if (IRIX_COMPAT (abfd) == ict_irix5)
    {
      for (namep = mips_elf_dynsym_rtproc_names; *namep != NULL; namep++)
	{
	  h = NULL;
	  if (! (_bfd_generic_link_add_one_symbol
		 (info, abfd, *namep, BSF_GLOBAL, bfd_und_section_ptr,
		  (bfd_vma) 0, (const char *) NULL, false,
		  get_elf_backend_data (abfd)->collect,
		  (struct bfd_link_hash_entry **) &h)))
	    return false;
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  h->type = STT_SECTION;

	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      /* We need to create a .compact_rel section.  */
      if (SGI_COMPAT (abfd))
	{
	  if (!mips_elf_create_compact_rel_section (abfd, info))
	    return false;
	}

      /* Change aligments of some sections.  */
      s = bfd_get_section_by_name (abfd, ".hash");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".dynsym");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".dynstr");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".reginfo");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
      s = bfd_get_section_by_name (abfd, ".dynamic");
      if (s != NULL)
	bfd_set_section_alignment (abfd, s, 4);
    }

  if (!info->shared)
    {
      h = NULL;
      if (SGI_COMPAT (abfd))
	{
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, "_DYNAMIC_LINK", BSF_GLOBAL, bfd_abs_section_ptr,
		 (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect,
		 (struct bfd_link_hash_entry **) &h)))
	    return false;
	}
      else
	{
	  /* For normal mips it is _DYNAMIC_LINKING.  */
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, "_DYNAMIC_LINKING", BSF_GLOBAL,
		 bfd_abs_section_ptr, (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect,
		 (struct bfd_link_hash_entry **) &h)))
	    return false;
	}
      h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_SECTION;

      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	return false;

      if (! mips_elf_hash_table (info)->use_rld_obj_head)
	{
	  /* __rld_map is a four byte word located in the .data section
	     and is filled in by the rtld to contain a pointer to
	     the _r_debug structure. Its symbol value will be set in
	     mips_elf_finish_dynamic_symbol.  */
	  s = bfd_get_section_by_name (abfd, ".rld_map");
	  BFD_ASSERT (s != NULL);

	  h = NULL;
	  if (SGI_COMPAT (abfd))
	    {
	      if (!(_bfd_generic_link_add_one_symbol
		    (info, abfd, "__rld_map", BSF_GLOBAL, s,
		     (bfd_vma) 0, (const char *) NULL, false,
		     get_elf_backend_data (abfd)->collect,
		     (struct bfd_link_hash_entry **) &h)))
		return false;
	    }
	  else
	    {
	      /* For normal mips the symbol is __RLD_MAP.  */
	      if (!(_bfd_generic_link_add_one_symbol
		    (info, abfd, "__RLD_MAP", BSF_GLOBAL, s,
		     (bfd_vma) 0, (const char *) NULL, false,
		     get_elf_backend_data (abfd)->collect,
		     (struct bfd_link_hash_entry **) &h)))
		return false;
	    }
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  h->type = STT_OBJECT;

	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}
    }

  return true;
}

/* Create the .compact_rel section.  */

static boolean
mips_elf_create_compact_rel_section (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
{
  flagword flags;
  register asection *s;

  if (bfd_get_section_by_name (abfd, ".compact_rel") == NULL)
d913 2
a914 11
      flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED
	       | SEC_READONLY);

      s = bfd_make_section (abfd, ".compact_rel");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags)
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return false;

      s->_raw_size = sizeof (Elf32_External_compact_rel);
d917 1
a917 2
  return true;
}
d919 4
a922 1
/* Create the .got section to hold the global offset table.  */
d924 2
a925 10
static boolean
mips_elf_create_got_section (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  flagword flags;
  register asection *s;
  struct elf_link_hash_entry *h;
  struct mips_got_info *g;
  bfd_size_type amt;
d927 7
a933 3
  /* This function may be called more than once.  */
  if (mips_elf_got_section (abfd))
    return true;
d935 4
a938 2
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
d940 3
a942 35
  s = bfd_make_section (abfd, ".got");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags)
      || ! bfd_set_section_alignment (abfd, s, 4))
    return false;

  /* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the
     linker script because we don't want to define the symbol if we
     are not creating a global offset table.  */
  h = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
	  (bfd_vma) 0, (const char *) NULL, false,
	  get_elf_backend_data (abfd)->collect,
	  (struct bfd_link_hash_entry **) &h)))
    return false;
  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  if (info->shared
      && ! bfd_elf32_link_record_dynamic_symbol (info, h))
    return false;

  /* The first several global offset table entries are reserved.  */
  s->_raw_size = MIPS_RESERVED_GOTNO * MIPS_ELF_GOT_SIZE (abfd);

  amt = sizeof (struct mips_got_info);
  g = (struct mips_got_info *) bfd_alloc (abfd, amt);
  if (g == NULL)
    return false;
  g->global_gotsym = NULL;
  g->local_gotno = MIPS_RESERVED_GOTNO;
  g->assigned_gotno = MIPS_RESERVED_GOTNO;
  if (elf_section_data (s) == NULL)
d944 3
a946 8
      amt = sizeof (struct bfd_elf_section_data);
      s->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
      if (elf_section_data (s) == NULL)
	return false;
    }
  elf_section_data (s)->tdata = (PTR) g;
  elf_section_data (s)->this_hdr.sh_flags
    |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
d948 4
a951 26
  return true;
}

/* Returns the .msym section for ABFD, creating it if it does not
   already exist.  Returns NULL to indicate error.  */

static asection *
mips_elf_create_msym_section (abfd)
     bfd *abfd;
{
  asection *s;

  s = bfd_get_section_by_name (abfd, MIPS_ELF_MSYM_SECTION_NAME (abfd));
  if (!s)
    {
      s = bfd_make_section (abfd, MIPS_ELF_MSYM_SECTION_NAME (abfd));
      if (!s
	  || !bfd_set_section_flags (abfd, s,
				     SEC_ALLOC
				     | SEC_LOAD
				     | SEC_HAS_CONTENTS
				     | SEC_LINKER_CREATED
				     | SEC_READONLY)
	  || !bfd_set_section_alignment (abfd, s,
					 MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return NULL;
d954 3
a956 2
  return s;
}
d958 2
a959 1
/* Add room for N relocations to the .rel.dyn section in ABFD.  */
d961 8
a968 6
static void
mips_elf_allocate_dynamic_relocations (abfd, n)
     bfd *abfd;
     unsigned int n;
{
  asection *s;
d970 2
a971 2
  s = bfd_get_section_by_name (abfd, MIPS_ELF_REL_DYN_SECTION_NAME (abfd));
  BFD_ASSERT (s != NULL);
d973 1
a973 7
  if (s->_raw_size == 0)
    {
      /* Make room for a null element.  */
      s->_raw_size += MIPS_ELF_REL_SIZE (abfd);
      ++s->reloc_count;
    }
  s->_raw_size += n * MIPS_ELF_REL_SIZE (abfd);
d976 3
a978 2
/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table.  */
d980 3
a982 2
boolean
_bfd_mips_elf_check_relocs (abfd, info, sec, relocs)
d984 6
a989 3
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d991 1
a991 11
  const char *name;
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct mips_got_info *g;
  size_t extsymoff;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *sreloc;
  struct elf_backend_data *bed;
d993 1
a993 12
  if (info->relocateable)
    return true;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;

  /* Check for the mips16 stub sections.  */

  name = bfd_get_section_name (abfd, sec);
  if (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0)
d995 1
a995 1
      unsigned long r_symndx;
d997 2
a998 7
      /* Look at the relocation information to figure out which symbol
         this is for.  */

      r_symndx = ELF32_R_SYM (relocs->r_info);

      if (r_symndx < extsymoff
	  || sym_hashes[r_symndx - extsymoff] == NULL)
d1000 4
a1003 1
	  asection *o;
d1005 5
a1009 7
	  /* This stub is for a local symbol.  This stub will only be
             needed if there is some relocation in this BFD, other
             than a 16 bit function call, which refers to this symbol.  */
	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      Elf_Internal_Rela *sec_relocs;
	      const Elf_Internal_Rela *r, *rend;
d1011 5
a1015 23
	      /* We can ignore stub sections when looking for relocs.  */
	      if ((o->flags & SEC_RELOC) == 0
		  || o->reloc_count == 0
		  || strncmp (bfd_get_section_name (abfd, o), FN_STUB,
			      sizeof FN_STUB - 1) == 0
		  || strncmp (bfd_get_section_name (abfd, o), CALL_STUB,
			      sizeof CALL_STUB - 1) == 0
		  || strncmp (bfd_get_section_name (abfd, o), CALL_FP_STUB,
			      sizeof CALL_FP_STUB - 1) == 0)
		continue;

	      sec_relocs = (_bfd_elf32_link_read_relocs
			    (abfd, o, (PTR) NULL,
			     (Elf_Internal_Rela *) NULL,
			     info->keep_memory));
	      if (sec_relocs == NULL)
		return false;

	      rend = sec_relocs + o->reloc_count;
	      for (r = sec_relocs; r < rend; r++)
		if (ELF32_R_SYM (r->r_info) == r_symndx
		    && ELF32_R_TYPE (r->r_info) != R_MIPS16_26)
		  break;
d1017 5
a1021 2
	      if (! info->keep_memory)
		free (sec_relocs);
d1023 6
a1028 3
	      if (r < rend)
		break;
	    }
d1030 3
a1032 10
	  if (o == NULL)
	    {
	      /* There is no non-call reloc for this stub, so we do
                 not need it.  Since this function is called before
                 the linker maps input sections to output sections, we
                 can easily discard it by setting the SEC_EXCLUDE
                 flag.  */
	      sec->flags |= SEC_EXCLUDE;
	      return true;
	    }
d1034 1
a1034 3
	  /* Record this stub in an array of local symbol stubs for
             this BFD.  */
	  if (elf_tdata (abfd)->local_stubs == NULL)
d1036 3
a1038 13
	      unsigned long symcount;
	      asection **n;
	      bfd_size_type amt;

	      if (elf_bad_symtab (abfd))
		symcount = NUM_SHDR_ENTRIES (symtab_hdr);
	      else
		symcount = symtab_hdr->sh_info;
	      amt = symcount * sizeof (asection *);
	      n = (asection **) bfd_zalloc (abfd, amt);
	      if (n == NULL)
		return false;
	      elf_tdata (abfd)->local_stubs = n;
d1041 3
a1043 6
	  elf_tdata (abfd)->local_stubs[r_symndx] = sec;

	  /* We don't need to set mips16_stubs_seen in this case.
             That flag is used to see whether we need to look through
             the global symbol table for stubs.  We don't need to set
             it here, because we just have a local stub.  */
a1044 3
      else
	{
	  struct mips_elf_link_hash_entry *h;
d1046 1
a1046 8
	  h = ((struct mips_elf_link_hash_entry *)
	       sym_hashes[r_symndx - extsymoff]);

	  /* H is the symbol this stub is for.  */

	  h->fn_stub = sec;
	  mips_elf_hash_table (info)->mips16_stubs_seen = true;
	}
d1048 1
a1048 2
  else if (strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
	   || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
d1050 2
a1051 3
      unsigned long r_symndx;
      struct mips_elf_link_hash_entry *h;
      asection **loc;
d1053 1
a1053 2
      /* Look at the relocation information to figure out which symbol
         this is for.  */
d1055 3
a1057 1
      r_symndx = ELF32_R_SYM (relocs->r_info);
d1059 4
a1062 12
      if (r_symndx < extsymoff
	  || sym_hashes[r_symndx - extsymoff] == NULL)
	{
	  /* This stub was actually built for a static symbol defined
	     in the same file.  We assume that all static symbols in
	     mips16 code are themselves mips16, so we can simply
	     discard this stub.  Since this function is called before
	     the linker maps input sections to output sections, we can
	     easily discard it by setting the SEC_EXCLUDE flag.  */
	  sec->flags |= SEC_EXCLUDE;
	  return true;
	}
d1064 2
a1065 2
      h = ((struct mips_elf_link_hash_entry *)
	   sym_hashes[r_symndx - extsymoff]);
d1067 4
a1070 1
      /* H is the symbol this stub is for.  */
d1072 4
a1075 4
      if (strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
	loc = &h->call_fp_stub;
      else
	loc = &h->call_stub;
d1077 10
a1086 13
      /* If we already have an appropriate stub for this function, we
	 don't need another one, so we can discard this one.  Since
	 this function is called before the linker maps input sections
	 to output sections, we can easily discard it by setting the
	 SEC_EXCLUDE flag.  We can also discard this section if we
	 happen to already know that this is a mips16 function; it is
	 not necessary to check this here, as it is checked later, but
	 it is slightly faster to check now.  */
      if (*loc != NULL || h->root.other == STO_MIPS16)
	{
	  sec->flags |= SEC_EXCLUDE;
	  return true;
	}
d1088 2
a1089 3
      *loc = sec;
      mips_elf_hash_table (info)->mips16_stubs_seen = true;
    }
d1091 16
a1106 1
  if (dynobj == NULL)
d1108 2
a1109 2
      sgot = NULL;
      g = NULL;
a1110 255
  else
    {
      sgot = mips_elf_got_section (dynobj);
      if (sgot == NULL)
	g = NULL;
      else
	{
	  BFD_ASSERT (elf_section_data (sgot) != NULL);
	  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	  BFD_ASSERT (g != NULL);
	}
    }

  sreloc = NULL;
  bed = get_elf_backend_data (abfd);
  rel_end = relocs + sec->reloc_count * bed->s->int_rels_per_ext_rel;
  for (rel = relocs; rel < rel_end; ++rel)
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);

      if (r_symndx < extsymoff)
	h = NULL;
      else if (r_symndx >= extsymoff + NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler)
	    (_("%s: Malformed reloc detected for section %s"),
	     bfd_archive_filename (abfd), name);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
      else
	{
	  h = sym_hashes[r_symndx - extsymoff];

	  /* This may be an indirect symbol created because of a version.  */
	  if (h != NULL)
	    {
	      while (h->root.type == bfd_link_hash_indirect)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
	}

      /* Some relocs require a global offset table.  */
      if (dynobj == NULL || sgot == NULL)
	{
	  switch (r_type)
	    {
	    case R_MIPS_GOT16:
	    case R_MIPS_CALL16:
	    case R_MIPS_CALL_HI16:
	    case R_MIPS_CALL_LO16:
	    case R_MIPS_GOT_HI16:
	    case R_MIPS_GOT_LO16:
	    case R_MIPS_GOT_PAGE:
	    case R_MIPS_GOT_OFST:
	    case R_MIPS_GOT_DISP:
	      if (dynobj == NULL)
		elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! mips_elf_create_got_section (dynobj, info))
		return false;
	      g = mips_elf_got_info (dynobj, &sgot);
	      break;

	    case R_MIPS_32:
	    case R_MIPS_REL32:
	    case R_MIPS_64:
	      if (dynobj == NULL
		  && (info->shared || h != NULL)
		  && (sec->flags & SEC_ALLOC) != 0)
		elf_hash_table (info)->dynobj = dynobj = abfd;
	      break;

	    default:
	      break;
	    }
	}

      if (!h && (r_type == R_MIPS_CALL_LO16
		 || r_type == R_MIPS_GOT_LO16
		 || r_type == R_MIPS_GOT_DISP))
	{
	  /* We may need a local GOT entry for this relocation.  We
	     don't count R_MIPS_GOT_PAGE because we can estimate the
	     maximum number of pages needed by looking at the size of
	     the segment.  Similar comments apply to R_MIPS_GOT16 and
	     R_MIPS_CALL16.  We don't count R_MIPS_GOT_HI16, or
	     R_MIPS_CALL_HI16 because these are always followed by an
	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.

	     This estimation is very conservative since we can merge
	     duplicate entries in the GOT.  In order to be less
	     conservative, we could actually build the GOT here,
	     rather than in relocate_section.  */
	  g->local_gotno++;
	  sgot->_raw_size += MIPS_ELF_GOT_SIZE (dynobj);
	}

      switch (r_type)
	{
	case R_MIPS_CALL16:
	  if (h == NULL)
	    {
	      (*_bfd_error_handler)
		(_("%s: CALL16 reloc at 0x%lx not against global symbol"),
		 bfd_archive_filename (abfd), (unsigned long) rel->r_offset);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  /* Fall through.  */

	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	  if (h != NULL)
	    {
	      /* This symbol requires a global offset table entry.  */
	      if (!mips_elf_record_global_got_symbol (h, info, g))
		return false;

	      /* We need a stub, not a plt entry for the undefined
		 function.  But we record it as if it needs plt.  See
		 elf_adjust_dynamic_symbol in elflink.h.  */
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->type = STT_FUNC;
	    }
	  break;

	case R_MIPS_GOT16:
	case R_MIPS_GOT_HI16:
	case R_MIPS_GOT_LO16:
	case R_MIPS_GOT_DISP:
	  /* This symbol requires a global offset table entry.  */
	  if (h && !mips_elf_record_global_got_symbol (h, info, g))
	    return false;
	  break;

	case R_MIPS_32:
	case R_MIPS_REL32:
	case R_MIPS_64:
	  if ((info->shared || h != NULL)
	      && (sec->flags & SEC_ALLOC) != 0)
	    {
	      if (sreloc == NULL)
		{
		  const char *dname = MIPS_ELF_REL_DYN_SECTION_NAME (dynobj);

		  sreloc = bfd_get_section_by_name (dynobj, dname);
		  if (sreloc == NULL)
		    {
		      sreloc = bfd_make_section (dynobj, dname);
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (dynobj, sreloc,
						      (SEC_ALLOC
						       | SEC_LOAD
						       | SEC_HAS_CONTENTS
						       | SEC_IN_MEMORY
						       | SEC_LINKER_CREATED
						       | SEC_READONLY))
			  || ! bfd_set_section_alignment (dynobj, sreloc,
							  4))
			return false;
		    }
		}
#define MIPS_READONLY_SECTION (SEC_ALLOC | SEC_LOAD | SEC_READONLY)
	      if (info->shared)
		{
		  /* When creating a shared object, we must copy these
		     reloc types into the output file as R_MIPS_REL32
		     relocs.  We make room for this reloc in the
		     .rel.dyn reloc section.  */
		  mips_elf_allocate_dynamic_relocations (dynobj, 1);
		  if ((sec->flags & MIPS_READONLY_SECTION)
		      == MIPS_READONLY_SECTION)
		    /* We tell the dynamic linker that there are
		       relocations against the text segment.  */
		    info->flags |= DF_TEXTREL;
		}
	      else
		{
		  struct mips_elf_link_hash_entry *hmips;

		  /* We only need to copy this reloc if the symbol is
                     defined in a dynamic object.  */
		  hmips = (struct mips_elf_link_hash_entry *) h;
		  ++hmips->possibly_dynamic_relocs;
		  if ((sec->flags & MIPS_READONLY_SECTION)
		      == MIPS_READONLY_SECTION)
		    /* We need it to tell the dynamic linker if there
		       are relocations against the text segment.  */
		    hmips->readonly_reloc = true;
		}

	      /* Even though we don't directly need a GOT entry for
		 this symbol, a symbol must have a dynamic symbol
		 table index greater that DT_MIPS_GOTSYM if there are
		 dynamic relocations against it.  */
	      if (h != NULL
		  && !mips_elf_record_global_got_symbol (h, info, g))
		return false;
	    }

	  if (SGI_COMPAT (abfd))
	    mips_elf_hash_table (info)->compact_rel_size +=
	      sizeof (Elf32_External_crinfo);
	  break;

	case R_MIPS_26:
	case R_MIPS_GPREL16:
	case R_MIPS_LITERAL:
	case R_MIPS_GPREL32:
	  if (SGI_COMPAT (abfd))
	    mips_elf_hash_table (info)->compact_rel_size +=
	      sizeof (Elf32_External_crinfo);
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_MIPS_GNU_VTINHERIT:
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return false;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_MIPS_GNU_VTENTRY:
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_offset))
	    return false;
	  break;

	default:
	  break;
	}

      /* We must not create a stub for a symbol that has relocations
         related to taking the function's address.  */
      switch (r_type)
	{
	default:
	  if (h != NULL)
	    {
	      struct mips_elf_link_hash_entry *mh;

	      mh = (struct mips_elf_link_hash_entry *) h;
	      mh->no_fn_stub = true;
	    }
	  break;
	case R_MIPS_CALL16:
	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	  break;
	}
d1112 6
a1117 13
      /* If this reloc is not a 16 bit call, and it has a global
         symbol, then we will need the fn_stub if there is one.
         References from a stub section do not count.  */
      if (h != NULL
	  && r_type != R_MIPS16_26
	  && strncmp (bfd_get_section_name (abfd, sec), FN_STUB,
		      sizeof FN_STUB - 1) != 0
	  && strncmp (bfd_get_section_name (abfd, sec), CALL_STUB,
		      sizeof CALL_STUB - 1) != 0
	  && strncmp (bfd_get_section_name (abfd, sec), CALL_FP_STUB,
		      sizeof CALL_FP_STUB - 1) != 0)
	{
	  struct mips_elf_link_hash_entry *mh;
d1119 1
a1119 6
	  mh = (struct mips_elf_link_hash_entry *) h;
	  mh->need_fn_stub = true;
	}
    }

  return true;
d1122 2
a1123 2
/* Return the section that should be marked against GC for a given
   relocation.  */
d1125 4
a1128 7
asection *
_bfd_mips_elf_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d1130 11
a1140 1
  /* ??? Do mips16 stub sections need to be handled special?  */
d1142 5
a1146 1
  if (h != NULL)
d1148 1
a1148 1
      switch (ELF32_R_TYPE (rel->r_info))
d1150 1
a1150 3
	case R_MIPS_GNU_VTINHERIT:
	case R_MIPS_GNU_VTENTRY:
	  break;
d1152 2
a1153 2
	default:
	  switch (h->root.type)
d1155 2
a1156 8
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
d1161 2
a1162 1
  else
d1164 4
a1167 1
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
a1169 44
  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

boolean
_bfd_mips_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
#if 0
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_MIPS_GOT16:
      case R_MIPS_CALL16:
      case R_MIPS_CALL_HI16:
      case R_MIPS_CALL_LO16:
      case R_MIPS_GOT_HI16:
      case R_MIPS_GOT_LO16:
	/* ??? It would seem that the existing MIPS code does no sort
	   of reference counting or whatnot on its GOT and PLT entries,
	   so it is not possible to garbage collect them at this time.  */
	break;

      default:
	break;
      }
#endif

d1173 5
a1177 4
/* Copy data from a MIPS ELF indirect symbol to its direct symbol,
   hiding the old indirect symbol.  Process additional relocation
   information.  Also called for weakdefs, in which case we just let
   _bfd_elf_link_hash_copy_indirect copy the flags for us.  */
d1179 7
a1185 3
static void
_bfd_mips_elf_copy_indirect_symbol (dir, ind)
     struct elf_link_hash_entry *dir, *ind;
d1187 2
a1188 57
  struct mips_elf_link_hash_entry *dirmips, *indmips;

  _bfd_elf_link_hash_copy_indirect (dir, ind);

  if (ind->root.type != bfd_link_hash_indirect)
    return;

  dirmips = (struct mips_elf_link_hash_entry *) dir;
  indmips = (struct mips_elf_link_hash_entry *) ind;
  dirmips->possibly_dynamic_relocs += indmips->possibly_dynamic_relocs;
  if (indmips->readonly_reloc)
    dirmips->readonly_reloc = true;
  if (dirmips->min_dyn_reloc_index == 0
      || (indmips->min_dyn_reloc_index != 0
	  && indmips->min_dyn_reloc_index < dirmips->min_dyn_reloc_index))
    dirmips->min_dyn_reloc_index = indmips->min_dyn_reloc_index;
  if (indmips->no_fn_stub)
    dirmips->no_fn_stub = true;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

boolean
_bfd_mips_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  bfd *dynobj;
  struct mips_elf_link_hash_entry *hmips;
  asection *s;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
		  || h->weakdef != NULL
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));

  /* If this symbol is defined in a dynamic object, we need to copy
     any R_MIPS_32 or R_MIPS_REL32 relocs against it into the output
     file.  */
  hmips = (struct mips_elf_link_hash_entry *) h;
  if (! info->relocateable
      && hmips->possibly_dynamic_relocs != 0
      && (h->root.type == bfd_link_hash_defweak
	  || (h->elf_link_hash_flags
	      & ELF_LINK_HASH_DEF_REGULAR) == 0))
d1190 2
a1191 6
      mips_elf_allocate_dynamic_relocations (dynobj,
					     hmips->possibly_dynamic_relocs);
      if (hmips->readonly_reloc)
	/* We tell the dynamic linker that there are relocations
	   against the text segment.  */
	info->flags |= DF_TEXTREL;
d1194 4
a1197 3
  /* For a function, create a stub, if allowed.  */
  if (! hmips->no_fn_stub
      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d1199 7
a1205 8
      if (! elf_hash_table (info)->dynamic_sections_created)
	return true;

      /* If this symbol is not defined in a regular file, then set
	 the symbol to the stub location.  This is required to make
	 function pointers compare as equal between the normal
	 executable and the shared library.  */
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1207 3
a1209 17
	  /* We need .stub section.  */
	  s = bfd_get_section_by_name (dynobj,
				       MIPS_ELF_STUB_SECTION_NAME (dynobj));
	  BFD_ASSERT (s != NULL);

	  h->root.u.def.section = s;
	  h->root.u.def.value = s->_raw_size;

	  /* XXX Write this stub address somewhere.  */
	  h->plt.offset = s->_raw_size;

	  /* Make room for this stub code.  */
	  s->_raw_size += MIPS_FUNCTION_STUB_SIZE;

	  /* The last half word of the stub will be filled with the index
	     of this symbol in .dynsym section.  */
	  return true;
a1211 8
  else if ((h->type == STT_FUNC)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
    {
      /* This will set the entry for this symbol in the GOT to 0, and
         the dynamic linker will take care of this.  */
      h->root.u.def.value = 0;
      return true;
    }
d1213 1
a1213 16
  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      return true;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  return true;
d1216 5
a1220 3
/* This function is called after all the input files have been read,
   and the input sections have been assigned to output sections.  We
   check for any mips16 stub sections that we can discard.  */
d1222 8
a1229 5
static boolean mips_elf_check_mips16_stubs
  PARAMS ((struct mips_elf_link_hash_entry *, PTR));

boolean
_bfd_mips_elf_always_size_sections (output_bfd, info)
d1231 1
a1231 1
     struct bfd_link_info *info;
d1233 3
a1235 1
  asection *ri;
d1237 7
a1243 30
  /* The .reginfo section has a fixed size.  */
  ri = bfd_get_section_by_name (output_bfd, ".reginfo");
  if (ri != NULL)
    bfd_set_section_size (output_bfd, ri,
			  (bfd_size_type) sizeof (Elf32_External_RegInfo));

  if (info->relocateable
      || ! mips_elf_hash_table (info)->mips16_stubs_seen)
    return true;

  mips_elf_link_hash_traverse (mips_elf_hash_table (info),
			       mips_elf_check_mips16_stubs,
			       (PTR) NULL);

  return true;
}

/* Check the mips16 stubs for a particular symbol, and see if we can
   discard them.  */

static boolean
mips_elf_check_mips16_stubs (h, data)
     struct mips_elf_link_hash_entry *h;
     PTR data ATTRIBUTE_UNUSED;
{
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

  if (h->fn_stub != NULL
      && ! h->need_fn_stub)
d1245 2
a1246 8
      /* We don't need the fn_stub; the only references to this symbol
         are 16 bit calls.  Clobber the size to 0 to prevent it from
         being included in the link.  */
      h->fn_stub->_raw_size = 0;
      h->fn_stub->_cooked_size = 0;
      h->fn_stub->flags &= ~SEC_RELOC;
      h->fn_stub->reloc_count = 0;
      h->fn_stub->flags |= SEC_EXCLUDE;
d1249 3
a1251 2
  if (h->call_stub != NULL
      && h->root.other == STO_MIPS16)
d1253 2
a1254 8
      /* We don't need the call_stub; this is a 16 bit function, so
         calls from other 16 bit functions are OK.  Clobber the size
         to 0 to prevent it from being included in the link.  */
      h->call_stub->_raw_size = 0;
      h->call_stub->_cooked_size = 0;
      h->call_stub->flags &= ~SEC_RELOC;
      h->call_stub->reloc_count = 0;
      h->call_stub->flags |= SEC_EXCLUDE;
d1257 4
a1260 12
  if (h->call_fp_stub != NULL
      && h->root.other == STO_MIPS16)
    {
      /* We don't need the call_stub; this is a 16 bit function, so
         calls from other 16 bit functions are OK.  Clobber the size
         to 0 to prevent it from being included in the link.  */
      h->call_fp_stub->_raw_size = 0;
      h->call_fp_stub->_cooked_size = 0;
      h->call_fp_stub->flags &= ~SEC_RELOC;
      h->call_fp_stub->reloc_count = 0;
      h->call_fp_stub->flags |= SEC_EXCLUDE;
    }
d1262 3
a1264 1
  return true;
d1267 6
a1272 1
/* Set the sizes of the dynamic sections.  */
d1274 8
a1281 2
boolean
_bfd_mips_elf_size_dynamic_sections (output_bfd, info)
d1283 1
a1283 1
     struct bfd_link_info *info;
d1285 3
a1287 4
  bfd *dynobj;
  asection *s;
  boolean reltext;
  struct mips_got_info *g = NULL;
d1289 7
a1295 4
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
d1297 3
a1299 10
      /* Set the contents of the .interp section to the interpreter.  */
      if (! info->shared)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size
	    = strlen (ELF_DYNAMIC_INTERPRETER (output_bfd)) + 1;
	  s->contents
	    = (bfd_byte *) ELF_DYNAMIC_INTERPRETER (output_bfd);
	}
d1302 1
a1302 5
  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  reltext = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
d1304 2
a1305 155
      const char *name;
      boolean strip;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      strip = false;

      if (strncmp (name, ".rel", 4) == 0)
	{
	  if (s->_raw_size == 0)
	    {
	      /* We only strip the section if the output section name
                 has the same name.  Otherwise, there might be several
                 input sections for this output section.  FIXME: This
                 code is probably not needed these days anyhow, since
                 the linker now does not create empty output sections.  */
	      if (s->output_section != NULL
		  && strcmp (name,
			     bfd_get_section_name (s->output_section->owner,
						   s->output_section)) == 0)
		strip = true;
	    }
	  else
	    {
	      const char *outname;
	      asection *target;

	      /* If this relocation section applies to a read only
                 section, then we probably need a DT_TEXTREL entry.
                 If the relocation section is .rel.dyn, we always
                 assert a DT_TEXTREL entry rather than testing whether
                 there exists a relocation to a read only section or
                 not.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 4);
	      if ((target != NULL
		   && (target->flags & SEC_READONLY) != 0
		   && (target->flags & SEC_ALLOC) != 0)
		  || strcmp (outname,
			     MIPS_ELF_REL_DYN_SECTION_NAME (output_bfd)) == 0)
		reltext = true;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      if (strcmp (name,
			  MIPS_ELF_REL_DYN_SECTION_NAME (output_bfd)) != 0)
		s->reloc_count = 0;
	    }
	}
      else if (strncmp (name, ".got", 4) == 0)
	{
	  int i;
	  bfd_size_type loadable_size = 0;
	  bfd_size_type local_gotno;
	  bfd *sub;

	  BFD_ASSERT (elf_section_data (s) != NULL);
	  g = (struct mips_got_info *) elf_section_data (s)->tdata;
	  BFD_ASSERT (g != NULL);

	  /* Calculate the total loadable size of the output.  That
	     will give us the maximum number of GOT_PAGE entries
	     required.  */
	  for (sub = info->input_bfds; sub; sub = sub->link_next)
	    {
	      asection *subsection;

	      for (subsection = sub->sections;
		   subsection;
		   subsection = subsection->next)
		{
		  if ((subsection->flags & SEC_ALLOC) == 0)
		    continue;
		  loadable_size += ((subsection->_raw_size + 0xf)
				    &~ (bfd_size_type) 0xf);
		}
	    }
	  loadable_size += MIPS_FUNCTION_STUB_SIZE;

	  /* Assume there are two loadable segments consisting of
	     contiguous sections.  Is 5 enough?  */
	  local_gotno = (loadable_size >> 16) + 5;
	  if (IRIX_COMPAT (output_bfd) == ict_irix6)
	    /* It's possible we will need GOT_PAGE entries as well as
	       GOT16 entries.  Often, these will be able to share GOT
	       entries, but not always.  */
	    local_gotno *= 2;

	  g->local_gotno += local_gotno;
	  s->_raw_size += local_gotno * MIPS_ELF_GOT_SIZE (dynobj);

	  /* There has to be a global GOT entry for every symbol with
	     a dynamic symbol table index of DT_MIPS_GOTSYM or
	     higher.  Therefore, it make sense to put those symbols
	     that need GOT entries at the end of the symbol table.  We
	     do that here.  */
 	  if (!mips_elf_sort_hash_table (info, 1))
 	    return false;

	  if (g->global_gotsym != NULL)
	    i = elf_hash_table (info)->dynsymcount - g->global_gotsym->dynindx;
	  else
	    /* If there are no global symbols, or none requiring
	       relocations, then GLOBAL_GOTSYM will be NULL.  */
	    i = 0;
	  g->global_gotno = i;
	  s->_raw_size += i * MIPS_ELF_GOT_SIZE (dynobj);
	}
      else if (strcmp (name, MIPS_ELF_STUB_SECTION_NAME (output_bfd)) == 0)
	{
	  /* Irix rld assumes that the function stub isn't at the end
	     of .text section. So put a dummy. XXX  */
	  s->_raw_size += MIPS_FUNCTION_STUB_SIZE;
	}
      else if (! info->shared
	       && ! mips_elf_hash_table (info)->use_rld_obj_head
	       && strncmp (name, ".rld_map", 8) == 0)
	{
	  /* We add a room for __rld_map. It will be filled in by the
	     rtld to contain a pointer to the _r_debug structure.  */
	  s->_raw_size += 4;
	}
      else if (SGI_COMPAT (output_bfd)
	       && strncmp (name, ".compact_rel", 12) == 0)
	s->_raw_size += mips_elf_hash_table (info)->compact_rel_size;
      else if (strcmp (name, MIPS_ELF_MSYM_SECTION_NAME (output_bfd))
	       == 0)
	s->_raw_size = (sizeof (Elf32_External_Msym)
			* (elf_hash_table (info)->dynsymcount
			   + bfd_count_sections (output_bfd)));
      else if (strncmp (name, ".init", 5) != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (strip)
	{
	  _bfd_strip_section_from_output (info, s);
	  continue;
	}

      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
d1307 1
a1307 2

  if (elf_hash_table (info)->dynamic_sections_created)
d1309 2
a1310 51
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_mips_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (! info->shared)
	{
	  /* SGI object has the equivalence of DT_DEBUG in the
	     DT_MIPS_RLD_MAP entry.  */
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_MAP, 0))
	    return false;
	  if (!SGI_COMPAT (output_bfd))
	    {
	      if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
		return false;
	    }
	}
      else
	{
	  /* Shared libraries on traditional mips have DT_DEBUG.  */
	  if (!SGI_COMPAT (output_bfd))
	    {
	      if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
		return false;
	    }
	}

      if (reltext && SGI_COMPAT (output_bfd))
	info->flags |= DF_TEXTREL;

      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_TEXTREL, 0))
	    return false;
	}

      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTGOT, 0))
	return false;

      if (bfd_get_section_by_name (dynobj,
				   MIPS_ELF_REL_DYN_SECTION_NAME (dynobj)))
	{
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_REL, 0))
	    return false;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELSZ, 0))
	    return false;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELENT, 0))
	    return false;
	}
d1312 5
a1316 5
      if (SGI_COMPAT (output_bfd))
	{
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICTNO, 0))
	    return false;
	}
d1318 3
a1320 5
      if (SGI_COMPAT (output_bfd))
	{
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLISTNO, 0))
	    return false;
	}
d1322 13
a1334 4
      if (bfd_get_section_by_name (dynobj, ".conflict") != NULL)
	{
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICT, 0))
	    return false;
d1336 4
a1339 2
	  s = bfd_get_section_by_name (dynobj, ".liblist");
	  BFD_ASSERT (s != NULL);
d1341 2
a1342 3
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLIST, 0))
	    return false;
	}
d1344 2
a1345 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_VERSION, 0))
	return false;
d1347 7
a1353 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_FLAGS, 0))
	return false;
d1355 2
a1356 5
#if 0
      /* Time stamps in executable files are a bad idea.  */
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_TIME_STAMP, 0))
	return false;
#endif
d1358 6
a1363 4
#if 0 /* FIXME  */
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_ICHECKSUM, 0))
	return false;
#endif
d1365 1
a1365 4
#if 0 /* FIXME  */
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_IVERSION, 0))
	return false;
#endif
d1367 2
a1368 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_BASE_ADDRESS, 0))
	return false;
d1370 2
a1371 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LOCAL_GOTNO, 0))
	return false;
d1373 3
a1375 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_SYMTABNO, 0))
	return false;
d1377 15
a1391 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_UNREFEXTNO, 0))
	return false;
d1393 4
a1396 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_GOTSYM, 0))
	return false;
d1398 7
a1404 3
      if (IRIX_COMPAT (dynobj) == ict_irix5
	  && ! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_HIPAGENO, 0))
	return false;
d1406 10
a1415 5
      if (IRIX_COMPAT (dynobj) == ict_irix6
	  && (bfd_get_section_by_name
	      (dynobj, MIPS_ELF_OPTIONS_SECTION_NAME (dynobj)))
	  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_OPTIONS, 0))
	return false;
d1417 1
a1417 7
      if (bfd_get_section_by_name (dynobj,
				   MIPS_ELF_MSYM_SECTION_NAME (dynobj))
	  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_MSYM, 0))
	return false;
    }

  return true;
d1420 1
a1420 2
/* If NAME is one of the special IRIX6 symbols defined by the linker,
   adjust it appropriately now.  */
d1422 3
a1424 2
static void
mips_elf_irix6_finish_dynamic_symbol (abfd, name, sym)
d1426 6
a1431 2
     const char *name;
     Elf_Internal_Sym *sym;
d1433 7
a1439 18
  /* The linker script takes care of providing names and values for
     these, but we must place them into the right sections.  */
  static const char* const text_section_symbols[] = {
    "_ftext",
    "_etext",
    "__dso_displacement",
    "__elf_header",
    "__program_header_table",
    NULL
  };

  static const char* const data_section_symbols[] = {
    "_fdata",
    "_edata",
    "_end",
    "_fbss",
    NULL
  };
d1441 3
a1443 2
  const char* const *p;
  int i;
d1445 6
a1450 15
  for (i = 0; i < 2; ++i)
    for (p = (i == 0) ? text_section_symbols : data_section_symbols;
	 *p;
	 ++p)
      if (strcmp (*p, name) == 0)
	{
	  /* All of these symbols are given type STT_SECTION by the
	     IRIX6 linker.  */
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);

	  /* The IRIX linker puts these symbols in special sections.  */
	  if (i == 0)
	    sym->st_shndx = SHN_MIPS_TEXT;
	  else
	    sym->st_shndx = SHN_MIPS_DATA;
d1452 1
a1452 2
	  break;
	}
d1455 1
a1455 2
/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */
d1457 8
a1464 2
boolean
_bfd_mips_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
d1466 1
a1466 3
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d1468 17
a1484 11
  bfd *dynobj;
  bfd_vma gval;
  asection *sgot;
  asection *smsym;
  struct mips_got_info *g;
  const char *name;
  struct mips_elf_link_hash_entry *mh;

  dynobj = elf_hash_table (info)->dynobj;
  gval = sym->st_value;
  mh = (struct mips_elf_link_hash_entry *) h;
d1486 3
a1488 1
  if (h->plt.offset != (bfd_vma) -1)
d1490 40
a1529 18
      asection *s;
      bfd_byte *p;
      bfd_byte stub[MIPS_FUNCTION_STUB_SIZE];

      /* This symbol has a stub.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1);

      s = bfd_get_section_by_name (dynobj,
				   MIPS_ELF_STUB_SECTION_NAME (dynobj));
      BFD_ASSERT (s != NULL);

      /* Fill the stub.  */
      p = stub;
      bfd_put_32 (output_bfd, (bfd_vma) STUB_LW (output_bfd), p);
      p += 4;
      bfd_put_32 (output_bfd, (bfd_vma) STUB_MOVE (output_bfd), p);
      p += 4;
d1531 1
a1531 3
      /* FIXME: Can h->dynindex be more than 64K?  */
      if (h->dynindx & 0xffff0000)
	return false;
d1533 4
a1536 17
      bfd_put_32 (output_bfd, (bfd_vma) STUB_JALR, p);
      p += 4;
      bfd_put_32 (output_bfd, (bfd_vma) STUB_LI16 (output_bfd) + h->dynindx, p);

      BFD_ASSERT (h->plt.offset <= s->_raw_size);
      memcpy (s->contents + h->plt.offset, stub, MIPS_FUNCTION_STUB_SIZE);

      /* Mark the symbol as undefined.  plt.offset != -1 occurs
	 only for the referenced symbol.  */
      sym->st_shndx = SHN_UNDEF;

      /* The run-time linker uses the st_value field of the symbol
	 to reset the global offset table entry for this external
	 to its stub address when unlinking a shared object.  */
      gval = s->output_section->vma + s->output_offset + h->plt.offset;
      sym->st_value = gval;
    }
d1538 24
a1561 2
  BFD_ASSERT (h->dynindx != -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0);
d1563 1
a1563 13
  sgot = mips_elf_got_section (dynobj);
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);

  /* Run through the global symbol table, creating GOT entries for all
     the symbols that need them.  */
  if (g->global_gotsym != NULL
      && h->dynindx >= g->global_gotsym->dynindx)
    {
      bfd_vma offset;
      bfd_vma value;
d1565 6
a1570 18
      if (sym->st_value)
	value = sym->st_value;
      else
	{
	  /* For an entity defined in a shared object, this will be
	     NULL.  (For functions in shared objects for
	     which we have created stubs, ST_VALUE will be non-NULL.
	     That's because such the functions are now no longer defined
	     in a shared object.)  */

	  if (info->shared && h->root.type == bfd_link_hash_undefined)
	    value = 0;
	  else
	    value = h->root.u.def.value;
	}
      offset = mips_elf_global_got_index (dynobj, h);
      MIPS_ELF_PUT_WORD (output_bfd, value, sgot->contents + offset);
    }
d1572 1
a1572 4
  /* Create a .msym entry, if appropriate.  */
  smsym = bfd_get_section_by_name (dynobj,
				   MIPS_ELF_MSYM_SECTION_NAME (dynobj));
  if (smsym)
d1574 2
a1575 9
      Elf32_Internal_Msym msym;

      msym.ms_hash_value = bfd_elf_hash (h->root.root.string);
      /* It is undocumented what the `1' indicates, but IRIX6 uses
	 this value.  */
      msym.ms_info = ELF32_MS_INFO (mh->min_dyn_reloc_index, 1);
      bfd_mips_elf_swap_msym_out
	(dynobj, &msym,
	 ((Elf32_External_Msym *) smsym->contents) + h->dynindx);
d1578 1
a1578 7
  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  name = h->root.root.string;
  if (strcmp (name, "_DYNAMIC") == 0
      || strcmp (name, "_GLOBAL_OFFSET_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;
  else if (strcmp (name, "_DYNAMIC_LINK") == 0
	   || strcmp (name, "_DYNAMIC_LINKING") == 0)
d1580 3
a1582 35
      sym->st_shndx = SHN_ABS;
      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
      sym->st_value = 1;
    }
  else if (strcmp (name, "_gp_disp") == 0)
    {
      sym->st_shndx = SHN_ABS;
      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
      sym->st_value = elf_gp (output_bfd);
    }
  else if (SGI_COMPAT (output_bfd))
    {
      if (strcmp (name, mips_elf_dynsym_rtproc_names[0]) == 0
	  || strcmp (name, mips_elf_dynsym_rtproc_names[1]) == 0)
	{
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_other = STO_PROTECTED;
	  sym->st_value = 0;
	  sym->st_shndx = SHN_MIPS_DATA;
	}
      else if (strcmp (name, mips_elf_dynsym_rtproc_names[2]) == 0)
	{
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_other = STO_PROTECTED;
	  sym->st_value = mips_elf_hash_table (info)->procedure_count;
	  sym->st_shndx = SHN_ABS;
	}
      else if (sym->st_shndx != SHN_UNDEF && sym->st_shndx != SHN_ABS)
	{
	  if (h->type == STT_FUNC)
	    sym->st_shndx = SHN_MIPS_TEXT;
	  else if (h->type == STT_OBJECT)
	    sym->st_shndx = SHN_MIPS_DATA;
	}
    }
d1584 8
a1591 3
  /* Handle the IRIX6-specific symbols.  */
  if (IRIX_COMPAT (output_bfd) == ict_irix6)
    mips_elf_irix6_finish_dynamic_symbol (output_bfd, name, sym);
d1593 18
a1610 23
  if (! info->shared)
    {
      if (! mips_elf_hash_table (info)->use_rld_obj_head
	  && (strcmp (name, "__rld_map") == 0
	      || strcmp (name, "__RLD_MAP") == 0))
	{
	  asection *s = bfd_get_section_by_name (dynobj, ".rld_map");
	  BFD_ASSERT (s != NULL);
	  sym->st_value = s->output_section->vma + s->output_offset;
	  bfd_put_32 (output_bfd, (bfd_vma) 0, s->contents);
	  if (mips_elf_hash_table (info)->rld_value == 0)
	    mips_elf_hash_table (info)->rld_value = sym->st_value;
	}
      else if (mips_elf_hash_table (info)->use_rld_obj_head
	       && strcmp (name, "__rld_obj_head") == 0)
	{
	  /* IRIX6 does not use a .rld_map section.  */
	  if (IRIX_COMPAT (output_bfd) == ict_irix5
              || IRIX_COMPAT (output_bfd) == ict_none)
	    BFD_ASSERT (bfd_get_section_by_name (dynobj, ".rld_map")
			!= NULL);
	  mips_elf_hash_table (info)->rld_value = sym->st_value;
	}
a1611 7

  /* If this is a mips16 symbol, force the value to be even.  */
  if (sym->st_other == STO_MIPS16
      && (sym->st_value & 1) != 0)
    --sym->st_value;

  return true;
d1614 1
a1614 1
/* Finish up the dynamic sections.  */
d1616 4
a1619 4
boolean
_bfd_mips_elf_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d1621 1
a1621 13
  bfd *dynobj;
  asection *sdyn;
  asection *sgot;
  struct mips_got_info *g;

  dynobj = elf_hash_table (info)->dynobj;

  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  sgot = mips_elf_got_section (dynobj);
  if (sgot == NULL)
    g = NULL;
  else
d1623 31
a1653 3
      BFD_ASSERT (elf_section_data (sgot) != NULL);
      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
      BFD_ASSERT (g != NULL);
d1655 1
d1657 1
a1657 3
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd_byte *b;
d1659 7
a1665 2
      BFD_ASSERT (sdyn != NULL);
      BFD_ASSERT (g != NULL);
d1667 2
a1668 9
      for (b = sdyn->contents;
	   b < sdyn->contents + sdyn->_raw_size;
	   b += MIPS_ELF_DYN_SIZE (dynobj))
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  size_t elemsize;
	  asection *s;
	  boolean swap_out_p;
d1670 9
a1678 2
	  /* Read in the current dynamic entry.  */
	  (*get_elf_backend_data (dynobj)->s->swap_dyn_in) (dynobj, b, &dyn);
d1680 1
a1680 2
	  /* Assume that we're going to modify it and write it out.  */
	  swap_out_p = true;
d1682 10
a1691 9
	  switch (dyn.d_tag)
	    {
	    case DT_RELENT:
	      s = (bfd_get_section_by_name
		   (dynobj,
		    MIPS_ELF_REL_DYN_SECTION_NAME (dynobj)));
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = MIPS_ELF_REL_SIZE (dynobj);
	      break;
d1693 9
a1701 5
	    case DT_STRSZ:
	      /* Rewrite DT_STRSZ.  */
	      dyn.d_un.d_val =
		_bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
	      break;
d1703 14
a1716 13
	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;
	    case DT_MIPS_CONFLICT:
	      name = ".conflict";
	      goto get_vma;
	    case DT_MIPS_LIBLIST:
	      name = ".liblist";
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      break;
d1718 5
a1722 3
	    case DT_MIPS_RLD_VERSION:
	      dyn.d_un.d_val = 1; /* XXX */
	      break;
d1724 5
a1728 3
	    case DT_MIPS_FLAGS:
	      dyn.d_un.d_val = RHF_NOTPOT; /* XXX */
	      break;
d1730 2
a1731 20
	    case DT_MIPS_CONFLICTNO:
	      name = ".conflict";
	      elemsize = sizeof (Elf32_Conflict);
	      goto set_elemno;

	    case DT_MIPS_LIBLISTNO:
	      name = ".liblist";
	      elemsize = sizeof (Elf32_Lib);
	    set_elemno:
	      s = bfd_get_section_by_name (output_bfd, name);
	      if (s != NULL)
		{
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val = s->_cooked_size / elemsize;
		  else
		    dyn.d_un.d_val = s->_raw_size / elemsize;
		}
	      else
		dyn.d_un.d_val = 0;
	      break;
d1733 2
a1734 3
	    case DT_MIPS_TIME_STAMP:
	      time ((time_t *) &dyn.d_un.d_val);
	      break;
d1736 4
a1739 4
	    case DT_MIPS_ICHECKSUM:
	      /* XXX FIXME: */
	      swap_out_p = false;
	      break;
d1741 7
a1747 4
	    case DT_MIPS_IVERSION:
	      /* XXX FIXME: */
	      swap_out_p = false;
	      break;
d1749 3
a1751 170
	    case DT_MIPS_BASE_ADDRESS:
	      s = output_bfd->sections;
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma & ~(bfd_vma) 0xffff;
	      break;

	    case DT_MIPS_LOCAL_GOTNO:
	      dyn.d_un.d_val = g->local_gotno;
	      break;

	    case DT_MIPS_UNREFEXTNO:
	      /* The index into the dynamic symbol table which is the
		 entry of the first external symbol that is not
		 referenced within the same object.  */
	      dyn.d_un.d_val = bfd_count_sections (output_bfd) + 1;
	      break;

	    case DT_MIPS_GOTSYM:
	      if (g->global_gotsym)
		{
		  dyn.d_un.d_val = g->global_gotsym->dynindx;
		  break;
		}
	      /* In case if we don't have global got symbols we default
		 to setting DT_MIPS_GOTSYM to the same value as
		 DT_MIPS_SYMTABNO, so we just fall through.  */

	    case DT_MIPS_SYMTABNO:
	      name = ".dynsym";
	      elemsize = MIPS_ELF_SYM_SIZE (output_bfd);
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);

	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size / elemsize;
	      else
		dyn.d_un.d_val = s->_raw_size / elemsize;
	      break;

	    case DT_MIPS_HIPAGENO:
	      dyn.d_un.d_val = g->local_gotno - MIPS_RESERVED_GOTNO;
	      break;

	    case DT_MIPS_RLD_MAP:
	      dyn.d_un.d_ptr = mips_elf_hash_table (info)->rld_value;
	      break;

	    case DT_MIPS_OPTIONS:
	      s = (bfd_get_section_by_name
		   (output_bfd, MIPS_ELF_OPTIONS_SECTION_NAME (output_bfd)));
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    case DT_MIPS_MSYM:
	      s = (bfd_get_section_by_name
		   (output_bfd, MIPS_ELF_MSYM_SECTION_NAME (output_bfd)));
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    default:
	      swap_out_p = false;
	      break;
	    }

	  if (swap_out_p)
	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out)
	      (dynobj, &dyn, b);
	}
    }

  /* The first entry of the global offset table will be filled at
     runtime. The second entry will be used by some runtime loaders.
     This isn't the case of Irix rld.  */
  if (sgot != NULL && sgot->_raw_size > 0)
    {
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0, sgot->contents);
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000,
			 sgot->contents + MIPS_ELF_GOT_SIZE (output_bfd));
    }

  if (sgot != NULL)
    elf_section_data (sgot->output_section)->this_hdr.sh_entsize
      = MIPS_ELF_GOT_SIZE (output_bfd);

  {
    asection *smsym;
    asection *s;
    Elf32_compact_rel cpt;

    /* ??? The section symbols for the output sections were set up in
       _bfd_elf_final_link.  SGI sets the STT_NOTYPE attribute for these
       symbols.  Should we do so?  */

    smsym = bfd_get_section_by_name (dynobj,
				     MIPS_ELF_MSYM_SECTION_NAME (dynobj));
    if (smsym != NULL)
      {
	Elf32_Internal_Msym msym;

	msym.ms_hash_value = 0;
	msym.ms_info = ELF32_MS_INFO (0, 1);

	for (s = output_bfd->sections; s != NULL; s = s->next)
	  {
	    long dynindx = elf_section_data (s)->dynindx;

	    bfd_mips_elf_swap_msym_out
	      (output_bfd, &msym,
	       (((Elf32_External_Msym *) smsym->contents)
		+ dynindx));
	  }
      }

    if (SGI_COMPAT (output_bfd))
      {
	/* Write .compact_rel section out.  */
	s = bfd_get_section_by_name (dynobj, ".compact_rel");
	if (s != NULL)
	  {
	    cpt.id1 = 1;
	    cpt.num = s->reloc_count;
	    cpt.id2 = 2;
	    cpt.offset = (s->output_section->filepos
			  + sizeof (Elf32_External_compact_rel));
	    cpt.reserved0 = 0;
	    cpt.reserved1 = 0;
	    bfd_elf32_swap_compact_rel_out (output_bfd, &cpt,
					    ((Elf32_External_compact_rel *)
					     s->contents));

	    /* Clean up a dummy stub function entry in .text.  */
	    s = bfd_get_section_by_name (dynobj,
					 MIPS_ELF_STUB_SECTION_NAME (dynobj));
	    if (s != NULL)
	      {
		file_ptr dummy_offset;

		BFD_ASSERT (s->_raw_size >= MIPS_FUNCTION_STUB_SIZE);
		dummy_offset = s->_raw_size - MIPS_FUNCTION_STUB_SIZE;
		memset (s->contents + dummy_offset, 0,
			MIPS_FUNCTION_STUB_SIZE);
	      }
	  }
      }

    /* We need to sort the entries of the dynamic relocation section.  */

    if (!ABI_64_P (output_bfd))
      {
	asection *reldyn;

	reldyn = bfd_get_section_by_name (dynobj,
					  MIPS_ELF_REL_DYN_SECTION_NAME (dynobj));
	if (reldyn != NULL && reldyn->reloc_count > 2)
	  {
	    reldyn_sorting_bfd = output_bfd;
	    qsort ((Elf32_External_Rel *) reldyn->contents + 1,
		   (size_t) reldyn->reloc_count - 1,
		   sizeof (Elf32_External_Rel), sort_dynamic_relocs);
	  }
      }

    /* Clean up a first relocation in .rel.dyn.  */
    s = bfd_get_section_by_name (dynobj,
				 MIPS_ELF_REL_DYN_SECTION_NAME (dynobj));
    if (s != NULL && s->_raw_size > 0)
      memset (s->contents, 0, MIPS_ELF_REL_SIZE (dynobj));
  }

  return true;
d1754 1
a1754 1
/* Support for core dump NOTE sections */
d1756 1
a1756 1
_bfd_elf32_mips_grok_prstatus (abfd, note)
d1788 1
a1788 1
_bfd_elf32_mips_grok_psinfo (abfd, note)
d1822 1
a1822 1
_bfd_elf32_mips_discard_info (abfd, cookie, info)
d1886 1
a1886 1
_bfd_elf32_mips_ignore_discarded_relocs (sec)
d1895 1
a1895 1
_bfd_elf32_mips_write_section (output_bfd, sec, contents)
d1926 13
d2033 4
a2036 4
       reloc section.  The longword will be the address in the data
       section which must be relocated.  It is followed by the name
       of the target section NUL-padded or truncated to 8
       characters.  */
d2070 6
a2075 7
	   * For some reason, in certain programs, the symbol will
	   * not be in the hash table.  It seems to happen when you
	   * declare a static table of pointers to const external structures.
	   * In this case, the relocs are relative to data, not
	   * text, so just treating it like an undefined link
	   * should be sufficient.
	   */
d2084 2
a2085 3
       * Set the low bit of the relocation offset if it's a MIPS64 reloc.
       * Relocations will always be on (at least) 32-bit boundaries.
       */
a2112 187
/* This is almost identical to bfd_generic_get_... except that some
   MIPS relocations need to be handled specially.  Sigh.  */

static bfd_byte *
elf32_mips_get_relocated_section_contents (abfd, link_info, link_order, data,
					   relocateable, symbols)
     bfd *abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     boolean relocateable;
     asymbol **symbols;
{
  /* Get enough memory to hold the stuff */
  bfd *input_bfd = link_order->u.indirect.section->owner;
  asection *input_section = link_order->u.indirect.section;

  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
  arelent **reloc_vector = NULL;
  long reloc_count;

  if (reloc_size < 0)
    goto error_return;

  reloc_vector = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
  if (reloc_vector == NULL && reloc_size != 0)
    goto error_return;

  /* read in the section */
  if (!bfd_get_section_contents (input_bfd,
				 input_section,
				 (PTR) data,
				 (file_ptr) 0,
				 input_section->_raw_size))
    goto error_return;

  /* We're not relaxing the section, so just copy the size info */
  input_section->_cooked_size = input_section->_raw_size;
  input_section->reloc_done = true;

  reloc_count = bfd_canonicalize_reloc (input_bfd,
					input_section,
					reloc_vector,
					symbols);
  if (reloc_count < 0)
    goto error_return;

  if (reloc_count > 0)
    {
      arelent **parent;
      /* for mips */
      int gp_found;
      bfd_vma gp = 0x12345678;	/* initialize just to shut gcc up */

      {
	struct bfd_hash_entry *h;
	struct bfd_link_hash_entry *lh;
	/* Skip all this stuff if we aren't mixing formats.  */
	if (abfd && input_bfd
	    && abfd->xvec == input_bfd->xvec)
	  lh = 0;
	else
	  {
	    h = bfd_hash_lookup (&link_info->hash->table, "_gp", false, false);
	    lh = (struct bfd_link_hash_entry *) h;
	  }
      lookup:
	if (lh)
	  {
	    switch (lh->type)
	      {
	      case bfd_link_hash_undefined:
	      case bfd_link_hash_undefweak:
	      case bfd_link_hash_common:
		gp_found = 0;
		break;
	      case bfd_link_hash_defined:
	      case bfd_link_hash_defweak:
		gp_found = 1;
		gp = lh->u.def.value;
		break;
	      case bfd_link_hash_indirect:
	      case bfd_link_hash_warning:
		lh = lh->u.i.link;
		/* @@@@FIXME  ignoring warning for now */
		goto lookup;
	      case bfd_link_hash_new:
	      default:
		abort ();
	      }
	  }
	else
	  gp_found = 0;
      }
      /* end mips */
      for (parent = reloc_vector; *parent != (arelent *) NULL;
	   parent++)
	{
	  char *error_message = (char *) NULL;
	  bfd_reloc_status_type r;

	  /* Specific to MIPS: Deal with relocation types that require
	     knowing the gp of the output bfd.  */
	  asymbol *sym = *(*parent)->sym_ptr_ptr;
	  if (bfd_is_abs_section (sym->section) && abfd)
	    {
	      /* The special_function wouldn't get called anyways.  */
	    }
	  else if (!gp_found)
	    {
	      /* The gp isn't there; let the special function code
		 fall over on its own.  */
	    }
	  else if ((*parent)->howto->special_function
		   == _bfd_mips_elf_gprel16_reloc)
	    {
	      /* bypass special_function call */
	      r = gprel16_with_gp (input_bfd, sym, *parent, input_section,
				   relocateable, (PTR) data, gp);
	      goto skip_bfd_perform_relocation;
	    }
	  /* end mips specific stuff */

	  r = bfd_perform_relocation (input_bfd,
				      *parent,
				      (PTR) data,
				      input_section,
				      relocateable ? abfd : (bfd *) NULL,
				      &error_message);
	skip_bfd_perform_relocation:

	  if (relocateable)
	    {
	      asection *os = input_section->output_section;

	      /* A partial link, so keep the relocs */
	      os->orelocation[os->reloc_count] = *parent;
	      os->reloc_count++;
	    }

	  if (r != bfd_reloc_ok)
	    {
	      switch (r)
		{
		case bfd_reloc_undefined:
		  if (!((*link_info->callbacks->undefined_symbol)
			(link_info, bfd_asymbol_name (*(*parent)->sym_ptr_ptr),
			 input_bfd, input_section, (*parent)->address,
			 true)))
		    goto error_return;
		  break;
		case bfd_reloc_dangerous:
		  BFD_ASSERT (error_message != (char *) NULL);
		  if (!((*link_info->callbacks->reloc_dangerous)
			(link_info, error_message, input_bfd, input_section,
			 (*parent)->address)))
		    goto error_return;
		  break;
		case bfd_reloc_overflow:
		  if (!((*link_info->callbacks->reloc_overflow)
			(link_info, bfd_asymbol_name (*(*parent)->sym_ptr_ptr),
			 (*parent)->howto->name, (*parent)->addend,
			 input_bfd, input_section, (*parent)->address)))
		    goto error_return;
		  break;
		case bfd_reloc_outofrange:
		default:
		  abort ();
		  break;
		}

	    }
	}
    }
  if (reloc_vector != NULL)
    free (reloc_vector);
  return data;

error_return:
  if (reloc_vector != NULL)
    free (reloc_vector);
  return NULL;
}

#define bfd_elf32_bfd_get_relocated_section_contents \
  elf32_mips_get_relocated_section_contents

d2168 1
a2168 1
#define elf_backend_object_p		_bfd_mips_elf_object_p
d2202 2
a2203 2
#define elf_backend_grok_prstatus	_bfd_elf32_mips_grok_prstatus
#define elf_backend_grok_psinfo		_bfd_elf32_mips_grok_psinfo
d2213 1
a2213 1
#define elf_backend_discard_info	_bfd_elf32_mips_discard_info
d2215 4
a2218 3
					_bfd_elf32_mips_ignore_discarded_relocs
#define elf_backend_write_section	_bfd_elf32_mips_write_section

d2223 2
d2255 1
a2255 1
/* Include the target file again for this target */
@


1.147
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d4782 3
d6095 3
d8798 3
@


1.146
log
@	Support arbitrary length fill patterns.
	* linker.c (bfd_new_link_order): Zero all fields with bfd_zalloc.
	(_bfd_default_link_order): Remove bfd_fill_link_order code.
	Call default_data_link_order.
	(default_fill_link_order): Delete.
	(default_data_link_order): New function.
	* elf32-mips.c (_bfd_mips_elf_final_link): Replace occurrences
	of bfd_fill_link_order with bfd_data_link_order.
	* elf64-alpha.c (elf64_alpha_final_link): Likewise.
	* elf64-mips.c (mips_elf64_final_link): Likewise.
@
text
@d6372 3
@


1.145
log
@2002-02-08  Eric Christopher  <echristo@@redhat.com>

	From Rainer Orth  <ro@@TechFak.Uni-Bielefeld.DE>

	* elf32-mips.c (_bfd_mips_elf_fake_sections): Don't create .rela
	sections for the O32 ABI.
@
text
@d5274 1
a5274 1
		  if (p->type == bfd_fill_link_order)
d5401 1
a5401 1
		  if (p->type == bfd_fill_link_order)
d5557 1
a5557 1
		      if (p->type == bfd_fill_link_order)
d5637 1
a5637 1
		  if (p->type == bfd_fill_link_order)
@


1.145.2.1
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a6371 3
  /* FIXME: For -2 runtime relocation needs to be skipped, but
     properly resolved statically and installed.  */
  BFD_ASSERT (outrel.r_offset != (bfd_vma) -2);
@


1.145.2.2
log
@Merge from mainline.
@
text
@a4781 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

a6091 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

a8791 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

@


1.145.2.3
log
@2002-05-11  Daniel Jacobowitz  <drow@@mvista.com>

        Merge from mainline (to elf32-mips.c):
        2002-05-03  H.J. Lu  (hjl@@gnu.org)

        * elfxx-mips.c (mips_elf_link_hash_entry): Add forced_local.
        (mips_elf_link_hash_newfunc): Initialize forced_local to false.
        (mips_elf_record_global_got_symbol): Call _bfd_mips_elf_hide_symbol
        to hide a global symbol.
        (_bfd_mips_elf_hide_symbol): Return if forced_local is true. Set
        forced_local to true.
@
text
@a107 3

  /* Are we forced local?  .*/
  boolean forced_local;
a4530 1
      ret->forced_local = false;
a4545 1

a4546 4
  if (h->forced_local)
    return;
  h->forced_local = true;

d6050 3
a6052 12
  if (h->dynindx == -1)
    {
      switch (ELF_ST_VISIBILITY (h->other))
	{
	case STV_INTERNAL:
	case STV_HIDDEN:
	  _bfd_mips_elf_hide_symbol (info, h, true);
	  break;
	}
      if (!bfd_elf32_link_record_dynamic_symbol (info, h))
	return false;
    }
@


1.144
log
@2002-02-08  Chris Demetriou  <cgd@@broadcom.com>

        * elf32-arm.h: Fix formatting of _("...").
        * elf32-d10v.c: Likewise.
        * elf32-m68k.c: Likewise.
        * elf32-mips.c: Likewise.
@
text
@d3586 10
a3595 2
     kinds of relocations, so we set up the second header here.  */
  if ((sec->flags & SEC_RELOC) != 0)
@


1.143
log
@2002-02-06  H.J. Lu  (hjl@@gnu.org)

	* elf32-mips.c (_bfd_mips_elf_merge_private_bfd_data): Update
	the mach and ISA fields if necessary.
@
text
@d3283 1
a3283 1
    fprintf (file, _ (" [mips5]"));
d3285 1
a3285 1
    fprintf (file, _ (" [mips32]"));
d3287 1
a3287 1
    fprintf (file, _ (" [mips64]"));
@


1.142
log
@Replace 'return false' with a return of a bfd_reloc_ error code.
@
text
@d3172 14
a3186 1

@


1.141
log
@2002-01-29  Chris Demetriou  <cgd@@broadcom.com>
            Mitch Lichtenberg  <mpl@@broadcom.com>

        * bfd-in.h (bfd_mips_elf32_create_embedded_relocs): New prototype.
        * elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): New function
        to handle 32-bit ELF embedded reloc (ld --embedded-relocs)
        generation.
        * bfd-in2.h: Regenerate.
@
text
@d6791 1
a6791 1
	    return false;
d6851 1
a6851 1
	    return false;
d6972 1
a6972 1
	    return false;
d7016 1
a7016 1
	return false;
@


1.140
log
@2002-01-29  Chris Demetriou  <cgd@@broadcom.com>

        * elf32-mips.c: Add additional comments about HI16 relocation
        processing.
        (_bfd_mips_elf_hi16_reloc): Don't subtract address here for
        pc-relative relocations.  (Reverts change made on 2001-10-31.)
        (_bfd_mips_elf_lo16_reloc): Subtract address of LO16 part here
        for pc-relative relocations.
        (mips_elf_calculate_relocation): Add a comment about a kludge
        in the R_MIPS_GNU_REL_HI16 handling.
        (_bfd_mips_elf_relocate_section): Implement that kludge;
        adjust pc-relative HI16 relocation for difference in HI16 and
        LO16 addresses, since it can't easily be done in
        mips_elf_calculate_relocation.
@
text
@d9852 175
@


1.139
log
@	* elf-bfd.h (elf_backend_data <elf_backend_hide_symbol>): Add
	boolean param.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Adjust call to
	elf_backend_hide_symbol.
	(elf_fix_symbol_flags): Likewise.
	(elf_link_assign_sym_version): Likewise. Use bfd_malloc rather
	than bfd_alloc.
	* elf.c (_bfd_elf_link_hash_hide_symbol): Add "force_local" param.
	Set ELF_LINK_FORCED_LOCAL and call _bfd_elf_strtab_delref.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	(clobber_millicode_symbols): Adjust to suit new hide_symbol.
	* elf32-cris.c (elf_cris_hide_symbol): Add "force_local" param
	and adjust to suit.
	* elf32-mips.c (_bfd_mips_elf_hide_symbol): Likewise, and call
	_bfd_elf_link_hash_hide_symbol rather than duplicating code.
	* elfxx-ia64.c (elfNN_ia64_hash_hide_symbol): Likewise.
@
text
@d1643 4
a1646 2
   actual relocation when we see the LO16.  MIPS ELF requires that the
   LO16 immediately follow the HI16.  As a GNU extension, we permit an
d1649 5
a1653 1
   itself.  */
a1735 2
  if (reloc_entry->howto->pc_relative)
    relocation -= reloc_entry->address;
d1801 6
d6877 5
d7408 10
@


1.138
log
@2002-01-17  Eric Christopher  <echristo@@redhat.com>

	* elf32-mips.c (mips_elf_calculate_relocation): Fix typo.
@
text
@d214 1
a214 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d4506 1
a4506 1
_bfd_mips_elf_hide_symbol (info, entry)
d4509 1
d4520 1
a4520 4
  h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
  h->root.plt.offset = (bfd_vma) -1;
  if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->root.dynindx = -1;
@


1.137
log
@	* elf-bfd.h (elf_backend_data <elf_backend_section_from_bfd_section>):
	Remove "Elf_Internal_Shdr *" param.
	(_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-mips.c (_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-m32r.c (_bfd_m32r_elf_section_from_bfd_section): Ditto.
	* elf32-v850.c (v850_elf_section_from_bfd_section): Ditto.
	* elf64-mmix.c (mmix_elf_section_from_bfd_section): Ditto.
	* elfxx-ia64.c (elfNN_hpux_backend_section_from_bfd_section): Ditto.
	* elf.c (_bfd_elf_section_from_bfd_section): Allow backend
	function to override special sections.  Remove hdr arg from
	backend call, and don't loop.
@
text
@d6737 2
a6738 2
		    && (((r_type == R_MIPS16_26) != target_is_16_bit_code_p
			 || ((r_type == R_MIPS_26) == target_is_16_bit_code_p))));
@


1.136
log
@2002-01-16  Eric Christopher  <echristo@@redhat.com>

	* elf32-mips.c (mips_elf_calculate_relocation): Set require_jalxp
	on R_MIPS_26 and target is 16bit. Add R_MIPS16_GPREL to list of
	relocations requiring gp0 and gp.
@
text
@d3588 1
a3588 1
_bfd_mips_elf_section_from_bfd_section (abfd, hdr, sec, retval)
a3589 1
     Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
@


1.135
log
@	* section.c (bfd_section_init): Remove unnecessary initialisations.
	(bfd_section_list_clear): New function.
	(bfd_section_list_remove, bfd_section_list_insert): New macros.
	(_bfd_strip_section_from_output): Use them.
	* coffcode.h (coff_set_alignment_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_final_link): Likewise.
	* elf64-mips.c (mips_elf64_final_link): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.
	* bfd-in2.h: Regenerate.

	* netbsd-core.c (netbsd_core_file_p): Use bfd_make_section_anyway
	rather than doing our own section handling.  Clean up after errors
	with bfd_release and bfd_section_list_clear.  Handle unexpected
	flags.
	* aoutf1.h (sunos4_core_file_p): Likewise.
	* aix386-core.c (aix386_core_file_p): Likewise.
	* cisco-core.c (cisco_core_file_validate): Likewise.
	* ptrace-core.c (ptrace_unix_core_file_p): Likewise.
	* trad-core.c (trad_unix_core_file_p): Likewise.

	* hppabsd-core.c (hppabsd_core_core_file_p):  Clean up after errors
	with bfd_release and bfd_section_list_clear.
	* hpux-core.c (hpux_core_core_file_p): Likewise.
	* irix-core.c (irix_core_core_file_p): Likewise.
	* lynx-core.c (lynx_core_file_p): Likewise.
	* osf-core.c (osf_core_core_file_p): Likewise.
	* rs6000-core.c (rs6000coff_core_p): Likewise.
	* sco5-core.c (sco5_core_file_p): Likewise.
@
text
@d6738 2
a6739 1
		    && ((r_type == R_MIPS16_26) != target_is_16_bit_code_p));
d6794 1
d9763 1
a9763 1
      
@


1.134
log
@	* elf32-mips.c (_bfd_mips_elf_lo16_reloc): Simplify, and perform
	sign extension adjustments without conditionals.
@
text
@d5180 1
a5180 1
	    *secpp = (*secpp)->next;
d5550 1
a5550 1
	      *secpp = (*secpp)->next;
@


1.133
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf-bfd.h (_bfd_elf_copy_private_bfd_data): New. Prototype.
	(_bfd_mips_elf_copy_private_bfd_data): Removed.

	* elf.c (_bfd_elf_copy_private_bfd_data): New. Copy e_flags in
	the ELF header.

	* elf32-i370.c (??_elf_copy_private_bfd_data): Removed.
	(bfd_elf??_bfd_copy_private_bfd_data): Removed.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-ia64.c: Likewise.

	* elf64-mips.c (bfd_elf64_bfd_copy_private_bfd_data): Removed.

	* elfxx-target.h (bfd_elfNN_bfd_copy_private_bfd_data): Defined
	to _bfd_elf_copy_private_bfd_data.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d1789 5
a1793 2
	  vallo = (bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address)
		   & 0xffff);
d1797 6
a1802 10
	  /* The low order 16 bits are always treated as a signed
	     value.  Therefore, a negative value in the low order bits
	     requires an adjustment in the high order bits.  We need
	     to make this adjustment in two ways: once for the bits we
	     took from the data, and once for the bits we are putting
	     back in to the data.  */
	  if ((vallo & 0x8000) != 0)
	    val -= 0x10000;
	  if ((val & 0x8000) != 0)
	    val += 0x10000;
d1804 2
a1805 1
	  insn = (insn &~ (bfd_vma) 0xffff) | ((val >> 16) & 0xffff);
@


1.132
log
@	* elf32-mips.c (_bfd_mips_elf_relocate_section): Formatting.
	* elf64-mips.c: Add most of the fixes and tweaks done in elf32-mips.c
	over the last months. Add some code for mips16 handling.
	(mips_elf64_check_mips16_stubs): New function.
	(mips_elf64_stub_section_p): Likewise.
	(mips_elf64_calculate_relocation): Change interface to support mips16.
	(mips_elf64_perform_relocation): Likewise.
@
text
@a3038 21
/* Copy backend specific data from one object module to another */

boolean
_bfd_mips_elf_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || (elf_elfheader (obfd)->e_flags
		  == elf_elfheader (ibfd)->e_flags));

  elf_gp (obfd) = elf_gp (ibfd);
  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = true;
  return true;
}

a10126 2
#define bfd_elf32_bfd_copy_private_bfd_data \
					_bfd_mips_elf_copy_private_bfd_data
@


1.131
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d7538 1
a7538 1
						input_bfd,  input_section,
@


1.130
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d2958 1
a2958 1
       i < elf_elfheader (abfd)->e_shnum;
d8542 1
a8542 7
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
@


1.129
log
@	* config.bfd: Remove trailing blanks.
	* elf32-mips.c (gprel16_with_gp): Remove superfluous casts.
	* strings.c (get_char): Initialize value.
	* config/tc-mips.c (mips_cpreturn_offset): Better comment.
	(load_register): Better error message. Cast away signedness
	mismatches. Add casts needed for varargs.
	(load_address): Replace checks of HAVE_64BIT_ADDRESS with dbl.
	Remove superfluous casts.
	(macro): Cast away signedness mismatches. Remove superfluous casts.
	(s_cpload): Fix wrong comment.
	(s_mips_weakext): Standardize output message.
	(get_number): Likewise.
@
text
@d6361 4
a6364 23

  /* We begin by assuming that the offset for the dynamic relocation
     is the same as for the original relocation.  We'll adjust this
     later to reflect the correct output offsets.  */
  if (elf_section_data (input_section)->stab_info == NULL)
    outrel.r_offset = rel->r_offset;
  else
    {
      /* Except that in a stab section things are more complex.
	 Because we compress stab information, the offset given in the
	 relocation may not be the one we want; we must let the stabs
	 machinery tell us the offset.  */
      outrel.r_offset
	= (_bfd_stab_section_offset
	   (output_bfd, &elf_hash_table (info)->stab_info,
	    input_section,
	    &elf_section_data (input_section)->stab_info,
	    rel->r_offset));
      /* If we didn't need the relocation at all, this value will be
	 -1.  */
      if (outrel.r_offset == (bfd_vma) -1)
	skip = true;
    }
@


1.128
log
@	* elf32-mips.c (NEWABI_P): New define.
	(USE_REL): Remove, replaced by
	(elf_backend_may_use_rel_p): New define.
	(elf_backend_may_use_rela_p): Likewise.
	(elf_backend_default_use_rela_p): Likewise.
	(elf_mips_howto_table): Rename to elf_mips_howto_table_rel.
	Fix some relocation definitions.
	(elf_mips_howto_table_rela): New RELA relocation definitions for
	NewABI support.
	(mips32_64bit_reloc): Use the renamed elf_mips_howto_table_rel.
	(bfd_elf32_bfd_reloc_type_lookup): Likewise.
	(mips_rtype_to_howto): Likewise.
	(_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_mips_elf_object_p): Typo.
	(elf_backend_sign_extend_vma): Reordered together with many other
	defines nearby to resemble the order of declaration in the header
	file.
@
text
@d2097 2
a2098 2
  insn = (insn &~ (bfd_vma) 0xffff) | (val & 0xffff);
  bfd_put_32 (abfd, (bfd_vma) insn, (bfd_byte *) data + reloc_entry->address);
@


1.127
log
@	* coff-mips.c (mips_bfd_reloc_type_lookup): Replace
	BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
	* pe-mips.c (mips_bfd_reloc_type_lookup): Likewise.
	* elf32-mips.c (mips_reloc_map): Likewise. Replace
	BFD_RELOC_MIPS_GPREL32 by BFD_RELOC_GPREL32.
	* elf64-mips.c (mips_reloc_map): Likewise.
	* reloc.c (BFD_RELOC_MIPS_GPREL): Remove.
	(BFD_RELOC_MIPS_GPREL32): Remove.
	* config/tc-mips.c (macro_build): Replace BFD_RELOC_MIPS_GPREL
	by BFD_RELOC_GPREL16.
	(load_address): Likewise.
	(macro): Likewise.
	(md_apply_fix): Likewise. Replace BFD_RELOC_MIPS_GPREL32 by
	BFD_RELOC_GPREL32.
	(s_gpword): Replace BFD_RELOC_MIPS_GPREL32 by BFD_RELOC_GPREL32.
	(tc_gen_reloc): Replace BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
	*config/tc-mips.h: Replace BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
@
text
@d272 2
a494 2
#define USE_REL	1		/* MIPS uses REL relocations instead of RELA */

d497 450
a946 1
#define MINUS_ONE	(((bfd_vma)0) - 1)
d948 1
a948 1
static reloc_howto_type elf_mips_howto_table[] =
d968 1
a968 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d972 1
a972 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d975 3
a977 3
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d990 2
a991 2
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
d1005 2
a1006 2
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
d1018 2
a1019 2
	 			/* This needs complex overflow
				   detection, because the upper four
d1023 3
a1025 3
	 true,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
d1028 1
d1037 1
a1037 1
	 _bfd_mips_elf_hi16_reloc,	/* special_function */
d1039 3
a1041 3
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d1052 1
a1052 1
	 _bfd_mips_elf_lo16_reloc,	/* special_function */
d1054 3
a1056 3
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d1069 3
a1071 3
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d1084 3
a1086 3
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d1090 1
d1098 1
a1098 1
	 _bfd_mips_elf_got16_reloc,	/* special_function */
d1101 2
a1102 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d1115 3
a1117 3
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d1121 1
d1132 2
a1133 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d1146 2
a1147 2
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
d1151 3
a1153 5
    /* The remaining relocs are defined on Irix 5, although they are
       not defined by the ABI.  */
    EMPTY_HOWTO (13),
    EMPTY_HOWTO (14),
    EMPTY_HOWTO (15),
d1165 2
a1166 2
	 true,			/* partial_inplace */
	 0x000007c0,		/* src_mask */
d1171 1
a1171 2
  /* FIXME: This is not handled correctly; a special function is
     needed to put the most significant bit in the right place.  */
d1179 1
a1179 1
	 bfd_elf_generic_reloc,	/* special_function */
d1181 2
a1182 2
	 true,			/* partial_inplace */
	 0x000007c4,		/* src_mask */
d1186 1
a1186 1
  /* A 64 bit relocation.  */
d1194 1
a1194 1
	 mips32_64bit_reloc,	/* special_function */
d1196 2
a1197 2
	 true,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
d1202 1
d1212 2
a1213 2
	 true,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
d1218 1
d1228 2
a1229 2
	 true,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
d1234 1
d1244 2
a1245 2
	 true,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
d1250 1
d1260 2
a1261 2
	 true,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
d1266 1
d1276 2
a1277 2
	 true,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
d1281 2
a1282 1
  /* 64 bit subtraction.  Used in the N32 ABI.  */
d1292 2
a1293 2
	 true,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
d1297 48
a1344 4
  /* Used to cause the linker to insert and delete instructions?  */
  EMPTY_HOWTO (R_MIPS_INSERT_A),
  EMPTY_HOWTO (R_MIPS_INSERT_B),
  EMPTY_HOWTO (R_MIPS_DELETE),
d1354 1
a1354 1
	 bfd_elf_generic_reloc,	/* special_function */
d1356 3
a1358 3
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d1369 1
a1369 1
	 bfd_elf_generic_reloc,	/* special_function */
d1371 3
a1373 3
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d1377 1
d1387 2
a1388 2
	 true,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
d1393 1
d1403 2
a1404 2
	 true,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
d1408 3
a1410 2
  /* Section displacement.  */
  HOWTO (R_MIPS_SCN_DISP,       /* type */
d1418 3
a1420 3
	 "R_MIPS_SCN_DISP",     /* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
d1424 15
a1438 1
  EMPTY_HOWTO (R_MIPS_REL16),
d1441 16
a1456 1
  EMPTY_HOWTO (R_MIPS_RELGOT),
d1462 2
a1463 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d1470 2
a1471 2
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
d2250 1
a2250 1
  reloc32.howto = &elf_mips_howto_table[R_MIPS_32];
d2543 1
a2543 1
	return &elf_mips_howto_table[(int) mips_reloc_map[i].elf_reloc_val];
d2557 1
a2557 1
	return &elf_mips_howto_table[(int) R_MIPS_32];
d2620 1
a2620 1
      return &elf_mips_howto_table[r_type];
d2865 1
a2865 1
  /* Irix 5 and 6 is broken.  Object file symbol tables are not always
d7356 1
a7356 1
	  howto = elf_mips_howto_table + R_MIPS_32;
a10102 4
#define TARGET_LITTLE_SYM		bfd_elf32_littlemips_vec
#define TARGET_LITTLE_NAME		"elf32-littlemips"
#define TARGET_BIG_SYM			bfd_elf32_bigmips_vec
#define TARGET_BIG_NAME			"elf32-bigmips"
a10112 1
#define elf_backend_sign_extend_vma	true
d10117 2
a10122 8
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_additional_program_headers \
					_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
#define elf_backend_final_write_processing \
					_bfd_mips_elf_final_write_processing
#define elf_backend_ecoff_debug_swap	&mips_elf32_ecoff_debug_swap
d10124 2
a10135 2
#define elf_backend_link_output_symbol_hook \
					_bfd_mips_elf_link_output_symbol_hook
d10140 5
a10146 4

#define elf_backend_got_header_size	(4*MIPS_RESERVED_GOTNO)
#define elf_backend_plt_header_size	0

a10148 1

d10152 8
d10180 7
d10189 2
a10190 3
/* Support for traditional mips targets */

#define INCLUDED_TARGET_FILE            /* More a type of flag */
@


1.126
log
@2001-11-11  Daniel Jacobowitz  <drow@@mvista.com>

	* bfd-in.h (bfd_elf32_discard_info): Add prototype.
	(bfd_elf64_discard_info): Likewise.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_reloc_cookie): New.
	(struct elf_backend_data): Add elf_backend_discard_info,
	elf_backend_ignore_discarded_relocs, and elf_backend_write_section.
	(_bfd_elf32_reloc_symbol_deleted_p): Add prototype.
	(_bfd_elf64_reloc_symbol_deleted_p): Likewise.
	* elf32-mips.c (_bfd_elf32_mips_discard_info): New.
	(_bfd_elf32_mips_ignore_discarded_relocs): New.
	(_bfd_elf32_mips_write_section): New.
	(elf_backend_discard_info): Define.
	(elf_backend_ignore_discarded_relocs): Define.
	(elf_backend_write_section): Define.
	* elfcode.h (elf_bfd_discard_info): Define.
	(elf_reloc_symbol_deleted_p): Define.
	* elflink.h (elf_link_input_bfd): Check
	elf_section_ignore_discarded_relocs.  Call
	bed->elf_backend_write_section if available.
	(elf_reloc_symbol_deleted_p): New.
	(elf_bfd_discard_info): New.
	(elf_section_ignore_discarded_relocs): New.
	* elfxx-target.h (elf_backend_discard_info): Define.
	(elf_backend_ignore_discarded_relocs): Define.
	(elf_backend_write_section): Define.
	(elfNN_bed): Add elf_backend_discard_info,
	elf_backend_ignore_discarded_relocs, and
	elf_backend_write_section.
	* libbfd-in.h (_bfd_discard_section_stabs): Add prototype.
	* libbfd.h: Regenerate.
	* stabs.c (_bfd_discard_section_stabs): New.

2001-11-11  Daniel Jacobowitz  <drow@@mvista.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): New.
	(struct ld_emulation_xfer_struct): Use it.
@
text
@d1984 1
a1984 1
  { BFD_RELOC_MIPS_GPREL, R_MIPS_GPREL16 },
d1989 1
a1989 1
  { BFD_RELOC_MIPS_GPREL32, R_MIPS_GPREL32 },
@


1.125
log
@2001-11-11  H.J. Lu <hjl@@gnu.org>

	* elf32-mips.c (_bfd_mips_elf_finish_dynamic_sections): Call
	_bfd_elf_strtab_size instead of _bfd_stringtab_size.

	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Change
	dynstr type to `struct elf_strtab_hash *'.
@
text
@d222 6
d9235 108
d9632 5
@


1.124
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d8932 1
a8932 1
		_bfd_stringtab_size (elf_hash_table (info)->dynstr);
@


1.123
log
@2001-11-02  H.J. Lu  <hjl@@gnu.org>

	* elf32-mips.c (mips_elf_calculate_relocation): Don't create
	dynamic relocation for symbols defined in regular objects when
	creating executables.
@
text
@d6328 1
@


1.122
log
@[ bfd/ChangeLog ]
2001-10-31  Chris Demetriou  <cgd@@demetriou.com>

	* elf32-mips.c (_bfd_mips_elf_hi16_reloc): Handle PC-relative
	relocations properly.

[ gas/ChangeLog ]
2001-10-31  Chris Demetriou  <cgd@@broadcom.com>

	* config/tc-mips.c (HAVE_32BIT_ADDRESSES): If compiling embedded
	PIC code, assume pointers the same size as GPRs.
	(macro): In M_LA_AB handling for embedded PIC code, support
	"la $treg,foo-bar($breg)".  In load/store handling
	(label ld_st) support "<op> $treg,<sym>-<local_sym>($breg)"
	which is used by the compiler for switch statements.
	In load/store double multi-instruction macro handling
	(label ldd_std) add a comment that no special handling
	is currently done for embedded PIC.
	(mips_ip): In 'o' (16-bit offset) case, only accept 16
	bit offsets.

[ gas/testsuite/ChangeLog ]
2001-10-31  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/empic.s: Undo damage inflicted on 2000-12-02.
	* gas/mips/empic.d: Likewise.
	* gas/mips/elempic.d: Likewise (it was copied into other files).
	* gas/mips/telempic.d: Likewise.
	* gas/mips/tempic.d: Likewise.

	* gas/mips/empic2.s: New test to check new 'la' and 'lw' (and
	related ops) syntax, test loads with large offsets.
	* gas/mips/emcic2.d: Likewise.
	* gas/mips/mips.exp: Run the new test on ELF platforms.
@
text
@d6324 4
a6327 2
	       && ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
		   != 0)))
@


1.121
log
@2001-10-23  H.J. Lu <hjl@@gnu.org>

	* elf32-mips.c (_bfd_mips_elf_modify_segment_map): Check
	m != NULL before accessing it.
@
text
@d1193 2
@


1.120
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Test ind->root.type
	rather than ind->weakdef.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
@
text
@d3513 1
a3513 1
      if (IRIX_COMPAT (abfd) == ict_none)
@


1.119
log
@	* elf32-mips.c (elf_mips_howto_table): Fix some relocation howtos
	according to the MIPS/SGI ELF64 ABI Draft.
	(mips_elf_sort_hash_table): Typo.
@
text
@d8088 1
a8088 1
  if (dir == ind->weakdef)
@


1.118
log
@Fix a comment typo in last commit.
@
text
@d532 1
a532 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d547 1
a547 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d685 1
a685 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d738 1
a738 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d753 1
a753 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d768 1
a768 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d783 1
a783 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d828 1
a828 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d852 1
a852 1
	 0,			/* src_mask */
d867 1
a867 1
	 0,			/* src_mask */
d911 1
a911 1
	 false,			/* partial_inplace */
d5588 1
a5588 1
  /* There shoud have been enough room in the symbol table to
@


1.117
log
@	* elf32-mips.c (_bfd_mips_elf_copy_indirect_symbol): Bail out after
	copying flags if this is a weakdef.
@
text
@d8078 1
a8078 1
   _bfd_elf_link_hach_copy_indirect copy the flags for us.  */
@


1.116
log
@	* elf32-mips.c (mips_elf_record_global_got_symbol): Set got.offset
	to 1 rather than 0 to avoid confusing copy_indirect_symbol.
	(mips_elf_sort_hash_table_f): Compare got.offset against 1.
@
text
@d8077 2
a8078 1
   information.  */
d8087 3
@


1.115
log
@Fix compile time warnings
@
text
@d5505 1
a5505 1
  /* If we've already marked this entry as need GOT space, we don't
d5507 1
a5507 1
  if (h->got.offset != (bfd_vma) - 1)
d5511 3
a5513 2
     there needs to be a GOT entry for H.  */
  h->got.offset = 0;
d5551 1
a5551 1
  if (h->root.got.offset != 0)
@


1.114
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d326 1
a326 1
   ? (abort (), false)							\
d6565 1
a6565 1
  x = bfd_get (8 * bfd_get_reloc_size (howto), input_bfd, location);
d6984 1
d6986 3
d7110 1
d7112 3
@


1.113
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d2602 1
a2602 1
	 bfd_get_filename (ibfd));
d2612 1
a2612 1
	 bfd_get_filename (ibfd));
d2641 1
a2641 1
		bfd_get_filename (ibfd), new_isa, old_isa);
d2650 1
a2650 1
	     bfd_get_filename (ibfd),
d2673 1
a2673 1
	     bfd_get_filename (ibfd),
d2687 1
a2687 1
	 bfd_get_filename (ibfd), (unsigned long) new_flags,
d6734 1
a6734 1
	     bfd_get_filename (input_bfd),
d7723 3
a7725 9
	  if (abfd->my_archive)
	    (*_bfd_error_handler)
	      (_("%s(%s) Malformed reloc detected for section %s"),
	       bfd_get_filename (abfd->my_archive),
	       bfd_get_filename (abfd), name);
	  else
	    (*_bfd_error_handler)
	      (_("%s: Malformed reloc detected for section %s"),
	       bfd_get_filename (abfd), name);
d7803 1
a7803 1
		 bfd_get_filename (abfd), (unsigned long) rel->r_offset);
@


1.112
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d6145 3
a6147 1
      else if (info->shared && !info->symbolic && !info->no_undefined
@


1.111
log
@	* elf32-mips.c (mips_elf_calculate_relocation): Fix overflow handling
	of R_MIPS_PC16.

	* config/tc-mips.c (append_insn): Handle BFD_RELOC_16_PCREL.
	(macro_build): Use BFD_RELOC_16_PCREL_S2 only for embedded
	PIC, BFD_RELOC_16_PCREL for the rest.
	(mips_ip): Likewise.
        (md_pcrel_from): return the right offset for the differently shifted
        pcrel relocs.
	(md_apply_fix): Handle BFD_RELOC_16_PCREL.

	* gas/mips/beq.d: Check branches to external labels.
	* gas/mips/beq.s: Likewise.
	* gas/mips/bge.d: Likewise.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.d: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.d: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.d: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/elempic.d: Switch from R_MIPS_GNU_REL16_S2 to R_MIPS_PC16.
	* gas/mips/empic.d: Likewise.
	* gas/mips/empic.s: Likewise.
	* gas/mips/telempic.d: Likewise.
	* gas/mips/tempic.d: Likewise.
@
text
@d135 1
a135 1
static INLINE int elf_mips_mach PARAMS ((flagword));
d319 4
a322 4
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val) \
  (ABI_64_P (elf_hash_table (info)->dynobj)	   \
   ? bfd_elf64_add_dynamic_entry (info, tag, val)  \
   : bfd_elf32_add_dynamic_entry (info, tag, val))
d324 4
a327 4
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val) \
  (ABI_64_P (elf_hash_table (info)->dynobj)	   \
   ? (abort (), false)                             \
   : bfd_elf32_add_dynamic_entry (info, tag, val))
d1198 1
a1198 1
  n = (struct mips_hi16 *) bfd_malloc (sizeof *n);
d1266 2
a1267 2
	  insn = (insn & ~0xffff) | ((val >> 16) & 0xffff);
	  bfd_put_32 (abfd, insn, l->addr);
d1390 1
a1390 1
	  register CONST char *name;
d1558 2
a1559 2
  insn = (insn & ~0xffff) | (val & 0xffff);
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);
d1674 1
a1674 1
  bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
d1724 1
a1724 1
  bfd_put_32 (abfd, val, (bfd_byte *) data + addr);
d1818 3
a1820 3
	      (((extend & 0x1f) << 11)
	       | (extend & 0x7e0)
	       | (insn & 0x1f)),
d1828 3
a1830 3
	      ((extend & 0xf800)
	       | ((final >> 11) & 0x1f)
	       | (final & 0x7e0)),
d1833 2
a1834 2
	      ((insn & 0xffe0)
	       | (final & 0x1f)),
d1868 1
a1868 1
static INLINE int
d1967 1
a1967 1
static CONST struct elf_reloc_map mips_reloc_map[] =
d2136 6
a2141 6
  in->ri_gprmask = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_gprmask);
  in->ri_cprmask[0] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[0]);
  in->ri_cprmask[1] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[1]);
  in->ri_cprmask[2] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[2]);
  in->ri_cprmask[3] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[3]);
  in->ri_gp_value = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_gp_value);
d2150 6
a2155 12
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_gprmask,
		(bfd_byte *) ex->ri_gprmask);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[0],
		(bfd_byte *) ex->ri_cprmask[0]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[1],
		(bfd_byte *) ex->ri_cprmask[1]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[2],
		(bfd_byte *) ex->ri_cprmask[2]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[3],
		(bfd_byte *) ex->ri_cprmask[3]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_gp_value,
		(bfd_byte *) ex->ri_gp_value);
d2170 7
a2176 7
  in->ri_gprmask = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_gprmask);
  in->ri_pad = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_pad);
  in->ri_cprmask[0] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[0]);
  in->ri_cprmask[1] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[1]);
  in->ri_cprmask[2] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[2]);
  in->ri_cprmask[3] = bfd_h_get_32 (abfd, (bfd_byte *) ex->ri_cprmask[3]);
  in->ri_gp_value = bfd_h_get_64 (abfd, (bfd_byte *) ex->ri_gp_value);
d2185 7
a2191 14
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_gprmask,
		(bfd_byte *) ex->ri_gprmask);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_pad,
		(bfd_byte *) ex->ri_pad);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[0],
		(bfd_byte *) ex->ri_cprmask[0]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[1],
		(bfd_byte *) ex->ri_cprmask[1]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[2],
		(bfd_byte *) ex->ri_cprmask[2]);
  bfd_h_put_32 (abfd, (bfd_vma) in->ri_cprmask[3],
		(bfd_byte *) ex->ri_cprmask[3]);
  bfd_h_put_64 (abfd, (bfd_vma) in->ri_gp_value,
		(bfd_byte *) ex->ri_gp_value);
d2203 2
a2204 2
  in->gt_entry.gt_g_value = bfd_h_get_32 (abfd, ex->gt_entry.gt_g_value);
  in->gt_entry.gt_bytes = bfd_h_get_32 (abfd, ex->gt_entry.gt_bytes);
d2213 2
a2214 4
  bfd_h_put_32 (abfd, (bfd_vma) in->gt_entry.gt_g_value,
		ex->gt_entry.gt_g_value);
  bfd_h_put_32 (abfd, (bfd_vma) in->gt_entry.gt_bytes,
		ex->gt_entry.gt_bytes);
d2223 6
a2228 6
  bfd_h_put_32 (abfd, (bfd_vma) in->id1, ex->id1);
  bfd_h_put_32 (abfd, (bfd_vma) in->num, ex->num);
  bfd_h_put_32 (abfd, (bfd_vma) in->id2, ex->id2);
  bfd_h_put_32 (abfd, (bfd_vma) in->offset, ex->offset);
  bfd_h_put_32 (abfd, (bfd_vma) in->reserved0, ex->reserved0);
  bfd_h_put_32 (abfd, (bfd_vma) in->reserved1, ex->reserved1);
d2243 3
a2245 3
  bfd_h_put_32 (abfd, (bfd_vma) l, ex->info);
  bfd_h_put_32 (abfd, (bfd_vma) in->konst, ex->konst);
  bfd_h_put_32 (abfd, (bfd_vma) in->vaddr, ex->vaddr);
d2256 4
a2259 4
  in->kind = bfd_h_get_8 (abfd, ex->kind);
  in->size = bfd_h_get_8 (abfd, ex->size);
  in->section = bfd_h_get_16 (abfd, ex->section);
  in->info = bfd_h_get_32 (abfd, ex->info);
d2270 4
a2273 4
  bfd_h_put_8 (abfd, in->kind, ex->kind);
  bfd_h_put_8 (abfd, in->size, ex->size);
  bfd_h_put_16 (abfd, in->section, ex->section);
  bfd_h_put_32 (abfd, in->info, ex->info);
d2284 2
a2285 2
  in->ms_hash_value = bfd_h_get_32 (abfd, ex->ms_hash_value);
  in->ms_info = bfd_h_get_32 (abfd, ex->ms_info);
d2296 2
a2297 2
  bfd_h_put_32 (abfd, in->ms_hash_value, ex->ms_hash_value);
  bfd_h_put_32 (abfd, in->ms_info, ex->ms_info);
d2867 2
a2868 1
				      (file_ptr) 0, sizeof ext))
d3049 1
d3053 1
a3053 2
      esd->rel_hdr2
	= (Elf_Internal_Shdr *) bfd_zalloc (abfd, sizeof (Elf_Internal_Shdr));
d3107 2
a3108 2
	  section->used_by_bfd =
	    (PTR) bfd_zalloc (abfd, sizeof (struct bfd_elf_section_data));
d3127 1
a3127 1
      memcpy (c + offset, location, count);
d3154 1
a3154 1
		    SEEK_SET) == -1)
d3156 2
a3157 2
      bfd_h_put_32 (abfd, (bfd_vma) elf_gp (abfd), buf);
      if (bfd_write (buf, (bfd_size_type) 1, (bfd_size_type) 4, abfd) != 4)
d3193 1
a3193 1
			     SEEK_SET) == -1)
d3195 2
a3196 2
	      bfd_h_put_64 (abfd, elf_gp (abfd), buf);
	      if (bfd_write (buf, 1, 8, abfd) != 8)
d3208 1
a3208 1
			    SEEK_SET) == -1)
d3210 2
a3211 2
	      bfd_h_put_32 (abfd, elf_gp (abfd), buf);
	      if (bfd_write (buf, 1, 4, abfd) != 4)
d3390 1
d3402 2
a3403 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
a3428 2
      asection *s;

d3447 2
a3448 2
	  options_segment = bfd_zalloc (abfd,
					sizeof (struct elf_segment_map));
d3473 2
a3474 1
		  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
d3564 2
a3565 2
	  n = ((struct elf_segment_map *)
	       bfd_zalloc (abfd, sizeof *n + (c - 1) * sizeof (asection *)));
d3622 7
a3628 7
  /* ecoff_put_off was defined in ecoffswap.h.  */
  ecoff_put_off (abfd, in->adr, (bfd_byte *) ex->p_adr);
  bfd_h_put_32 (abfd, in->regmask, (bfd_byte *) ex->p_regmask);
  bfd_h_put_32 (abfd, in->regoffset, (bfd_byte *) ex->p_regoffset);
  bfd_h_put_32 (abfd, in->fregmask, (bfd_byte *) ex->p_fregmask);
  bfd_h_put_32 (abfd, in->fregoffset, (bfd_byte *) ex->p_fregoffset);
  bfd_h_put_32 (abfd, in->frameoffset, (bfd_byte *) ex->p_frameoffset);
d3630 2
a3631 2
  bfd_h_put_16 (abfd, in->framereg, (bfd_byte *) ex->p_framereg);
  bfd_h_put_16 (abfd, in->pcreg, (bfd_byte *) ex->p_pcreg);
d3633 1
a3633 1
  bfd_h_put_32 (abfd, in->irpss, (bfd_byte *) ex->p_irpss);
d3635 1
a3635 1
  ecoff_put_off (abfd, in->exception_info, (bfd_byte *) ex->p_exception_info);
d3655 1
a3655 1
  ext_hdr = (char *) bfd_malloc ((size_t) swap->external_hdr_size);
d3674 2
a3675 1
      debug->ptr = (type) bfd_malloc ((size_t) (size * symhdr->count));	\
d3679 1
a3679 2
	  || (bfd_read (debug->ptr, size, symhdr->count,		\
			abfd) != size * symhdr->count))			\
d3775 1
a3775 1
				     ABI_64_P (abfd) ? 8 : 0,
d3801 1
d3803 1
a3803 2
	  fi = ((struct mips_elf_find_line *)
		bfd_zalloc (abfd, sizeof (struct mips_elf_find_line)));
d3817 2
a3818 4
	  fi->d.fdr = ((struct fdr *)
		       bfd_alloc (abfd,
				  (fi->d.symbolic_header.ifdMax *
				   sizeof (struct fdr))));
d4019 1
d4021 1
a4021 2
  ret = ((struct mips_elf_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct mips_elf_link_hash_table)));
d4089 1
d4091 1
a4091 1
	  elf_text_section = bfd_zalloc (abfd, sizeof (asection));
d4095 2
a4096 1
	  elf_text_symbol = bfd_zalloc (abfd, sizeof (asymbol));
d4130 1
d4132 1
a4132 1
	  elf_data_section = bfd_zalloc (abfd, sizeof (asection));
d4136 2
a4137 1
	  elf_data_symbol = bfd_zalloc (abfd, sizeof (asymbol));
d4423 2
a4424 1
  unsigned long size, count;
d4457 2
a4458 1
      sv = (char **) bfd_malloc (sizeof (char *) * count);
d4479 1
a4479 1
      for (i = 0; i < count; i++, rp++)
d4520 1
a4520 1
  ecoff_put_off (abfd, (bfd_vma) -1, (bfd_byte *) (erp + count)->p_adr);
a4591 1
  bfd_vma last;
d4593 3
a4595 1
  static const char * const name[] =
d4744 1
a4744 1
					      sizeof ext))
d4777 1
d4826 1
a4826 1
	  for (i = 0; i < 8; i++)
d4829 1
a4829 1
	      s = bfd_get_section_by_name (abfd, name[i]);
d4838 1
a4838 1
						 name[i], &esym))
d4995 1
a4995 1
	  unsigned int i;
a5002 2
	      asection **secpp;

d5071 2
a5072 1
	  tab = (Elf32_gptab *) bfd_malloc (c * sizeof (Elf32_gptab));
d5117 2
a5118 1
			  gpentry, sizeof (Elf32_External_gptab))))
d5145 2
a5146 3
		      new_tab = ((Elf32_gptab *)
				 bfd_realloc ((PTR) tab,
					      (c + 1) * sizeof (Elf32_gptab)));
d5188 2
a5189 2
	  ext_tab = ((Elf32_External_gptab *)
		     bfd_alloc (abfd, c * sizeof (Elf32_External_gptab)));
d5196 2
a5197 2
	  for (i = 0; i < c; i++)
	    bfd_mips_elf32_swap_gptab_out (abfd, tab + i, ext_tab + i);
d5231 1
a5231 1
				      (file_ptr) 0, sizeof ext))
d6799 1
a6799 1
      int r_type = ELF32_R_TYPE (rel->r_info);
d6859 1
a6859 1
		  int lo;
d7229 1
a7229 1
	  || ! bfd_set_section_flags (abfd, s, flags & ~SEC_READONLY)
d7392 1
d7428 2
a7429 2
  g = (struct mips_got_info *) bfd_alloc (abfd,
					  sizeof (struct mips_got_info));
d7437 2
a7438 2
      s->used_by_bfd =
	(PTR) bfd_zalloc (abfd, sizeof (struct bfd_elf_section_data));
d7601 1
d7607 2
a7608 2
	      n = (asection **) bfd_zalloc (abfd,
					    symcount * sizeof (asection *));
d7711 1
a7711 1
      int r_type;
d7846 1
a7846 1
		  const char *name = MIPS_ELF_REL_DYN_SECTION_NAME (dynobj);
d7848 1
a7848 1
		  sreloc = bfd_get_section_by_name (dynobj, name);
d7851 1
a7851 1
		      sreloc = bfd_make_section (dynobj, name);
d8130 1
a8130 1
	  || (h->elf_link_hash_flags 
d8217 2
a8218 1
    bfd_set_section_size (output_bfd, ri, sizeof (Elf32_External_RegInfo));
d8395 2
a8396 1
		  loadable_size += (subsection->_raw_size + 0xf) & ~0xf;
d8696 1
a8696 1
      bfd_put_32 (output_bfd, STUB_LW (output_bfd), p);
d8698 1
a8698 1
      bfd_put_32 (output_bfd, STUB_MOVE (output_bfd), p);
d8705 1
a8705 1
      bfd_put_32 (output_bfd, STUB_JALR, p);
d8707 1
a8707 1
      bfd_put_32 (output_bfd, STUB_LI16 (output_bfd) + h->dynindx, p);
d8981 1
a8981 1
	      dyn.d_un.d_ptr = s->vma & ~(0xffff);
d9157 1
a9157 1
  int raw_size;
d9239 1
a9239 1
  reloc_vector = (arelent **) bfd_malloc (reloc_size);
d9247 1
a9247 1
				 0,
@


1.110
log
@2001-08-31  H.J. Lu  <hjl@@gnu.org>

	* elf32-mips.c (_bfd_mips_elf_check_relocs): Report filename
	with bad relocation.
@
text
@d6483 1
a6484 1
      overflowed_p = mips_elf_overflow_p (value, 16);
@


1.109
log
@2001-08-31  Eric Christopher  <echristo@@redhat.com>
	    Jason Eckhardt  <jle@@redhat.com>

	* bfd/archures.c: Add mipsisa32 and mipsisa64. Remove mips32,
	mips32_4k and mips64.
	* bfd/aoutx.h: Remove bfd_mach_mips32, bfd_mach_mips32_4k,
	bfd_mach_mips64.  Add bfd_mach_mipsisa32, bfd_mach_mipsisa64.
	* bfd/cpu-mips.c: Ditto.
	* bfd/elf32-mips.c (_bfd_mips_elf_final_write_processing): Ditto.
	* bfd/bfd-in2.h: Regenerate.
@
text
@d7727 9
a7735 2
	  (*_bfd_error_handler)
	    (_("Malformed reloc detected for section %s"), name);
@


1.108
log
@2001-08-30  H.J. Lu  <hjl@@gnu.org>

	* elf32-mips.c (mips_elf_calculate_relocation): Revert the last
	2 changes.
	(_bfd_mips_elf_adjust_dynamic_symbol): Allocate dynamic
	relocations for weak definitions.
@
text
@a1888 3
    case E_MIPS_MACH_MIPS32_4K:
      return bfd_mach_mips32_4k;

d1917 1
a1917 1
	  return bfd_mach_mips32;
d1921 1
a1921 1
	  return bfd_mach_mips64;
d2412 2
a2413 2
    case bfd_mach_mips32:
      val = E_MIPS_ARCH_32;
d2416 2
a2417 2
    case bfd_mach_mips32_4k:
      val = E_MIPS_ARCH_32 | E_MIPS_MACH_MIPS32_4K;
d2420 2
a2421 2
    case bfd_mach_mips5:
      val = E_MIPS_ARCH_5;
d2424 1
a2424 1
    case bfd_mach_mips64:
a2425 5
      break;

    case bfd_mach_mips_sb1:
      val = E_MIPS_ARCH_64 | E_MIPS_MACH_SB1;
      break;
@


1.107
log
@2001-08-30  H.J. Lu  <hjl@@gnu.org>

	* elf32-mips.c (mips_elf_calculate_relocation): Don't create
	dynamic relocation for undefined weak symbols when creating
	executables. Check h->root.root.type, instead of h->root.type.
@
text
@d6335 2
a6336 4
	       && h->root.root.type != bfd_link_hash_undefweak
	       && (h->root.root.type == bfd_link_hash_defweak
		   || (h->root.elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d8136 3
a8138 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
@


1.106
log
@2001-08-27  H.J. Lu  <hjl@@gnu.org>

	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add more
	sanity check.
	(mips_elf_calculate_relocation): Create dynamic relocation for
	symbols with weak definition or the ELF_LINK_HASH_DEF_REGULAR
	bit is not set.
@
text
@d6335 2
a6336 1
	       && (h->root.type == bfd_link_hash_defweak
@


1.105
log
@2001-08-27  H.J. Lu  <hjl@@gnu.org>

	* elf32-mips.c (_bfd_mips_elf_hide_symbol): Add prototype.
	(_bfd_mips_elf_copy_indirect_symbol): Likewise.
	(_bfd_elf32_mips_grok_prstatus): Likewise.
	(_bfd_elf32_mips_grok_psinfo): Likewise.
	(_bfd_mips_elf_hide_symbol): Make it static and cast to
	`struct mips_elf_link_hash_entry *'.
	(_bfd_mips_elf_copy_indirect_symbol): Make it static.
@
text
@d5833 2
d6335 3
a6337 2
	       && ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
		   != 0)))
@


1.104
log
@	* elf32-mips.c (elf_mips_abi_name): Return the right ABI string for
	E_MIPS_ABI_O64 and E_MIPS_ABI_EABI64
@
text
@d213 9
d4011 2
a4012 2
void
_bfd_mips_elf_hide_symbol (info, h)
d4014 1
a4014 1
     struct mips_elf_link_hash_entry *h;
d4019 2
d8079 1
a8079 1
void
d9184 2
a9185 1
static boolean _bfd_elf32_mips_grok_psinfo (abfd, note)
@


1.103
log
@2001-07-04  H.J. Lu  <hjl@@gnu.org>

	* bfd/elf32-mips.c (_bfd_mips_elf_final_write_processing):
	Handle bfd_mach_mips4400, bfd_mach_mips4600 and
	bfd_mach_mips5000.
@
text
@a1930 5
  if (ABI_N32_P (abfd))
    return "N32";
  else if (ABI_64_P (abfd))
    return "64";

d1935 6
a1940 1
      return "none";
@


1.102
log
@	* elfcore.h (elf_core_file_p): Call bfd_section_from_phdr directly
	instead of _bfd_elfcore_section_from_phdr.
	* elf-bfd.h (_bfd_elfcore_section_from_phdr): Remove.
	* elf.c (_bfd_elfcore_section_from_phdr): Remove.
	(_bfd_elfcore_make_pseudosection): Expedite tail-call.
	(elfcore_grok_prstatus): Likewise.
	(elfcore_grok_lwpstatus): Likewise.
	(bfd_get_elf_phdr_upper_bound): Likewise.
	(elfcore_make_note_pseudosection): Formatting.
	(_bfd_elfcore_strndup): Formatting.
	* elf32-mips.c (mips_elf_sym_is_global): Formatting.
	(_bfd_elf32_mips_grok_prstatus): Expedite tail-call.
@
text
@d2378 2
d2399 1
@


1.101
log
@	* elf-bfd.h: Add prototypes for _bfd_elfcore_make_pseudosection
	and _bfd_elfcore_strndup.
	(struct elf_backend_data): Add elf_backend_grok_prstatus
	and elf_backend_grok_psinfo.
	* elf.c (_bfd_elfcore_make_pseudosection): New function.
	(elfcore_grok_prstatus): Use it.
	(elfcore_make_note_pseudosection): Likewise.
	(elfcore_strndup):  Rename to...
	(_bfd_elfcore_strndup): Here, and make global.
	(elfcore_grok_psinfo): Use _bfd_elfcore_strndup.
	(elfcore_grok_note): Call elf_backend_grok_prstatus
	and elf_backend_grok_psinfo if available.
	* elf32-mips.c (_bfd_elf32_mips_grok_prstatus): New function.
	(_bfd_elf32_mips_grok_psinfo): New function.
	(elf_backend_grok_prstatus): Define.
	(elf_backend_grok_psinfo): Define.
	* elfxx-target.h (elf_backend_grok_prstatus): Default to NULL.
	(elf_backend_grok_psinfo): Likewise.
	(elfNN_bed): Include elf_backend_grok_prstatus and
	elf_backend_grok_psinfo.
@
text
@d2320 2
a2321 2
  if (SGI_COMPAT(abfd))
    return (sym->flags & BSF_SECTION_SYM) == 0 ? true : false;
d2324 2
a2325 2
            || bfd_is_und_section (bfd_get_section (sym))
            || bfd_is_com_section (bfd_get_section (sym)));
d9166 2
a9167 5
  if (! _bfd_elfcore_make_pseudosection (abfd, ".reg",
					 raw_size, note->descpos + offset))
    return false;

  return true;
@


1.100
log
@2001-06-17  H.J. Lu  <hjl@@gnu.org>

	* elf32-mips.c (mips_elf_link_hash_entry): Add a new field,
	readonly_reloc, to record if a relocation in the .rel.dyn
	section is against a read-only section.
	(mips_elf_link_hash_newfunc): Initialize the readonly_reloc
	field to false.
	(_bfd_mips_elf_check_relocs): Record if there is a relocation
	in the .rel.dyn section against a read-only section by setting
	DF_TEXTREL or readonly_reloc.
	(_bfd_mips_elf_copy_indirect_symbol): Copy readonly_reloc if
	it is true.
	(_bfd_mips_elf_adjust_dynamic_symbol): Record DF_TEXTREL if
	there is a relocation in the .rel.dyn section against a
	read-only section.
	(_bfd_mips_elf_size_dynamic_sections): Set DT_TEXTREL if
	DF_TEXTREL is set.
@
text
@d9137 67
d9491 2
@


1.99
log
@	* elflink.h: Whitespace changes.
	(elf_link_read_relocs_from_section): Use "unsigned int" iterator
	rather than "unsigned char".
	(elf_link_output_relocs): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_reloc_link_order): LIkewise.
	* elf.c: s/CONST/const/.  Whitespace changes.
	* elf32-mips.c: Formatting fix.

	* Makefile.am (SOURCE_HFILES): Include xcoff-target.h, remove xcoff.h.
	* Makefile.in: Regenerate.
	* po/Make-in: Remove trailing tab.
@
text
@d79 4
d3987 1
d7856 1
d7858 12
a7869 5
		/* When creating a shared object, we must copy these
		   reloc types into the output file as R_MIPS_REL32
		   relocs.  We make room for this reloc in the
		   .rel.dyn reloc section.  */
		mips_elf_allocate_dynamic_relocations (dynobj, 1);
d7878 5
d8076 2
d8121 8
a8128 2
    mips_elf_allocate_dynamic_relocations (dynobj,
					   hmips->possibly_dynamic_relocs);
d8488 1
d8490 3
a8495 1
	  info->flags |= DF_TEXTREL;
@


1.98
log
@2001-06-07  H.J. Lu  <hjl@@gnu.org>

	* elf32-mips.c (_bfd_mips_elf_object_p): Set the bad symtab
	for SGI only.

	* config.bfd: Remove ecoff from Linux/mips.
@
text
@d252 1
a253 1

@


1.97
log
@Add MIPS r12k support
@
text
@d2334 2
a2335 1
  elf_bad_symtab (abfd) = true;
@


1.96
log
@Replace sh_size/sh_entsize with NUM_SHDR_ENTRIES
@
text
@d2393 2
d8337 1
a8337 1
	  struct _bfd *sub;
@


1.95
log
@Remove extraneous character in first line.
@
text
@d3074 1
a3074 1
     bfd *abfd;
d6825 1
a6825 2
	      >= (rel_hdr->sh_size / rel_hdr->sh_entsize
		  * bed->s->int_rels_per_ext_rel))
d7594 1
a7594 1
		symcount = symtab_hdr->sh_size / symtab_hdr->sh_entsize;
d7709 1
a7709 1
      else if (r_symndx >= extsymoff + (symtab_hdr->sh_size / symtab_hdr->sh_entsize))
@


1.94
log
@	* ecoff.c (bfd_debug_section): Fix initialization.
	* elf.c (_bfd_elf_slurp_version_tables): Change maxidx to unsigned, it
	is always a positive integer. Cast away sign mismatch.
	* elf32-mips.c: Fix misleading comment and typo.
	(_bfd_mips_elf_section_from_bfd_section): Remove unused attribute, use
	correct data type.
	* elflink.c: Fix typo.
	(_bfd_elf_create_dynamic_sections): Remove superfluous initialization.
	* ecoffswap.h (ecoff_swap_fdr_in): Cast away sign mismatch.
@
text
@d1 1
a1 1
l/* MIPS-specific support for 32-bit ELF
@


1.93
log
@2000-04-27  H.J. Lu  <hjl@@gnu.org>

	* elf.c (_bfd_elf_link_hash_hide_symbol): Set dynindx to -1
	only for ELF_LINK_FORCED_LOCAL.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	* elf32-mips.c (_bfd_mips_elf_hide_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_hide_symbol): Likewise.

	* elflink.h (elf_fix_symbol_flags): Set ELF_LINK_FORCED_LOCAL
	if the symbol has hidden or internal visibility.
@
text
@d1 1
a1 1
/* MIPS-specific support for 32-bit ELF
d542 1
a542 1
  /* 26 bit branch address.  */
d1670 1
a1670 1
   generated when addreses are 64 bits.  The upper 32 bits are a simle
d3074 2
a3075 2
     bfd *abfd ATTRIBUTE_UNUSED;
     Elf32_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
@


1.92
log
@Add OpenRISC support
@
text
@d4005 2
a4006 1
  h->root.dynindx = -1;
@


1.91
log
@2001-04-05  Steven J. Hill  <sjhill@@cotw.com>

	* config.bfd (mips*el*-*-linux-gnu*): Use traditional little
	endian MIPS ELF target.
	* config.bfd (mips*-*-linux-gnu*): Use traditional big endian
	MIPS ELF target.

	* configure.in (bfd_elf64_tradbigmips_vec): New. Traditional
	64bit big endian MIPS ELF target.
	(bfd_elf64_tradlittlemips_vec): New. Traditional 64bit little
	endian MIPS ELF target.
	* configure: Regenerated.

	* elf32-mips.c (IRIX_COMPAT): Handle traditional 64bit and
	little endian targets.
	(mips_elf_sym_is_global): Handle traditional targets.

	* elf64-mips.c (bfd_elf64_tradbigmips_vec): New. Traditional
	64bit big endian MIPS ELF target.
	(bfd_elf64_tradlittlemips_vec): New. Traditional 64bit little
	endian MIPS ELF target.

	* targets.c: (_bfd_target_vector): Add bfd_elf64_tradbigmips_vec
	and bfd_elf64_tradlittlemips_vec.
@
text
@d212 1
d215 1
d239 1
a239 1

d246 6
a251 1

@


1.90
log
@2001-03-21  Diego Novillo  <dnovillo@@redhat.com>

	(_bfd_mips_elf_relocate_section): Give a better error message when
	a relocation is not recognized.
@
text
@d211 3
d231 1
a231 2
/* Nonzero if ABFD is using the 64-bit ABI.  FIXME: This is never
   true, yet.  */
d239 4
a242 1
  (abfd->xvec == &bfd_elf32_tradbigmips_vec ? ict_none : \
d2309 6
a2314 1
  return (sym->flags & BSF_SECTION_SYM) == 0 ? true : false;
@


1.89
log
@Update copyright notices
@
text
@d6774 1
d7029 4
a7032 2
	  abort ();
	  break;
@


1.88
log
@Apply several patches from Maciej W. Rozycki
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 97, 98, 99, 2000
@


1.87
log
@Fix formatting.
@
text
@d83 6
d202 1
a202 1
	   bfd_vma, bfd_vma *, asection *, boolean local_p));
d540 1
a540 1
				   bits must match the PC.  */
d3964 1
d4340 10
a4349 6
      /* Set type and value for a symbol with a function stub.  */
      h->esym.asym.st = stProc;
      sec = h->root.root.u.def.section;
      if (sec == NULL)
	h->esym.asym.value = 0;
      else
d4351 5
a4355 5
	  output_section = sec->output_section;
	  if (output_section != NULL)
	    h->esym.asym.value = (h->root.plt.offset
				  + sec->output_offset
				  + output_section->vma);
d4357 9
a4365 2
	    h->esym.asym.value = 0;
	}
d4367 1
a4367 1
      h->esym.ifd = 0;
d4369 1
d5770 1
a5770 1
				    symbol, addendp, input_section, local_p)
a5778 1
     boolean local_p;
d5863 1
a5863 1
	  *addendp += symbol - sec->output_section->vma;
d5868 5
a5872 4
      /* If the relocation is against a local symbol was previously an
	 absolute relocation, we must adjust it by the value we give
	 it in the dynamic symbol table.  */
      if (local_p && r_type != R_MIPS_REL32)
d6247 1
a6247 1
      else if (r_type == R_MIPS_GOT16)
d6310 1
a6310 1
						   input_section, local_p))
d6342 1
a6342 1
      /* The calculation for R_MIPS_26 is just the same as for an
d6349 1
a6349 1
	value = (((addend << 2) | (p & 0xf0000000)) + symbol) >> 2;
d6415 1
a6437 1
    case R_MIPS_CALL16:
d6642 1
a6642 1
	 (((A < 2) | (P & 0xf0000000) + S) >> 2)
d6644 1
a6644 1
	 let R = (((A < 2) | (P & 0xf0000000) + S) >> 2)
d7750 4
a7753 4
	     the segment.  Similar comments apply to R_MIPS_GOT16.  We
	     don't count R_MIPS_GOT_HI16, or R_MIPS_CALL_HI16 because
	     these are always followed by an R_MIPS_GOT_LO16 or
	     R_MIPS_CALL_LO16.
d7885 19
d8039 2
d8081 3
a8083 2
  /* For a function, create a stub, if needed.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
@


1.87.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
@


1.87.2.2
log
@Merge from mainline.
@
text
@a82 6
  /* We must not create a stub for a symbol that has relocations
     related to taking the function's address, i.e. any but
     R_MIPS_CALL*16 ones -- see "MIPS ABI Supplement, 3rd Edition",
     p. 4-20.  */
  boolean no_fn_stub;

d196 1
a196 1
	   bfd_vma, bfd_vma *, asection *));
a204 5
extern const bfd_target bfd_elf32_tradlittlemips_vec;
#ifdef BFD64
extern const bfd_target bfd_elf64_tradbigmips_vec;
extern const bfd_target bfd_elf64_tradlittlemips_vec;
#endif
d222 2
a223 1
/* Nonzero if ABFD is using the 64-bit ABI. */
d229 1
a229 8
#ifdef BFD64
#define IRIX_COMPAT(abfd) \
  (((abfd->xvec == &bfd_elf64_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf64_tradlittlemips_vec) || \
    (abfd->xvec == &bfd_elf32_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf32_tradlittlemips_vec)) ? ict_none : \
  ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5))
#else
d231 1
a231 2
  (((abfd->xvec == &bfd_elf32_tradbigmips_vec) || \
    (abfd->xvec == &bfd_elf32_tradlittlemips_vec)) ? ict_none : \
a232 1
#endif
d235 1
d524 1
a524 1
  /* 26 bit jump address.  */
d534 1
a534 1
				   bits must match the PC + 4.  */
d1652 1
a1652 1
   generated when addresses are 64 bits.  The upper 32 bits are a simple
d2298 1
a2298 6
  if (SGI_COMPAT(abfd))
    return (sym->flags & BSF_SECTION_SYM) == 0 ? true : false;
  else
    return ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
            || bfd_is_und_section (bfd_get_section (sym))
            || bfd_is_com_section (bfd_get_section (sym)));
a2369 2
    case bfd_mach_mips10000:
    case bfd_mach_mips12000:
d3052 1
a3052 1
     Elf_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
a3957 1
      ret->no_fn_stub = false;
d3981 1
a3981 2
  if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->root.dynindx = -1;
d4333 6
a4338 4
      struct mips_elf_link_hash_entry *hd = h;
      boolean no_fn_stub = h->no_fn_stub;

      while (hd->root.root.type == bfd_link_hash_indirect)
d4340 7
a4346 2
	  hd = (struct mips_elf_link_hash_entry *)h->root.root.u.i.link;
	  no_fn_stub = no_fn_stub || hd->no_fn_stub;
a4347 18

      if (!no_fn_stub)
	{
	  /* Set type and value for a symbol with a function stub.  */
	  h->esym.asym.st = stProc;
	  sec = hd->root.root.u.def.section;
	  if (sec == NULL)
	    h->esym.asym.value = 0;
	  else
	    {
	      output_section = sec->output_section;
	      if (output_section != NULL)
		h->esym.asym.value = (hd->root.plt.offset
				      + sec->output_offset
				      + output_section->vma);
	      else
		h->esym.asym.value = 0;
	    }
d4349 1
a4349 1
	  h->esym.ifd = 0;
a4350 1
	}
d5751 1
a5751 1
				    symbol, addendp, input_section)
d5760 1
d5845 1
a5845 1
	  *addendp += section_offset;
d5850 4
a5853 5
      /* If the relocation was previously an absolute relocation and
	 this symbol will not be referred to by the relocation, we must
	 adjust it by the value we give it in the dynamic symbol table.
	 Otherwise leave the job up to the dynamic linker.  */
      if (!indx && r_type != R_MIPS_REL32)
d6228 1
a6228 1
      else if (r_type == R_MIPS_GOT16 || r_type == R_MIPS_CALL16)
d6291 1
a6291 1
						   input_section))
d6323 1
a6323 1
      /* The calculation for R_MIPS16_26 is just the same as for an
d6330 1
a6330 1
	value = (((addend << 2) | ((p + 4) & 0xf0000000)) + symbol) >> 2;
a6395 1
    case R_MIPS_CALL16:
d6418 1
d6623 1
a6623 1
	 (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
d6625 1
a6625 1
	 let R = (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
a6754 1
      const char * msg = (const char *) NULL;
d6787 2
a6788 1
	      >= (NUM_SHDR_ENTRIES (rel_hdr) * bed->s->int_rels_per_ext_rel))
d7009 2
a7010 4
	  msg = _("internal error: unsupported relocation error");
	  info->callbacks->warning
	    (info, msg, name, input_bfd, input_section, rel->r_offset);
	  return false;
d7555 1
a7555 1
		symcount = NUM_SHDR_ENTRIES (symtab_hdr);
d7670 1
a7670 1
      else if (r_symndx >= extsymoff + NUM_SHDR_ENTRIES (symtab_hdr))
d7731 4
a7734 4
	     the segment.  Similar comments apply to R_MIPS_GOT16 and
	     R_MIPS_CALL16.  We don't count R_MIPS_GOT_HI16, or
	     R_MIPS_CALL_HI16 because these are always followed by an
	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.
a7865 19
      /* We must not create a stub for a symbol that has relocations
         related to taking the function's address.  */
      switch (r_type)
	{
	default:
	  if (h != NULL)
	    {
	      struct mips_elf_link_hash_entry *mh;

	      mh = (struct mips_elf_link_hash_entry *) h;
	      mh->no_fn_stub = true;
	    }
	  break;
	case R_MIPS_CALL16:
	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	  break;
	}

a8000 2
  if (indmips->no_fn_stub)
    dirmips->no_fn_stub = true;
d8041 2
a8042 3
  /* For a function, create a stub, if allowed.  */
  if (! hmips->no_fn_stub
      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d8274 1
a8274 1
	  bfd *sub;
@


1.86
log
@Pass dwarf2_find_line_info as last parameter to invocation of
_bfd_dwarf2_find_nearest_line.
@
text
@d52 2
a53 1
struct mips_got_info {
d68 2
a69 1
struct mips_elf_link_hash_entry {
d326 2
a327 1
static const char * const mips_elf_dynsym_sec_names[] = {
d351 2
a352 1
static const char * const mips_elf_dynsym_rtproc_names[] = {
d362 2
a363 1
typedef struct {
d372 2
a373 1
typedef struct {
d382 2
a383 1
typedef struct {
d392 2
a393 1
typedef struct {
d401 2
a402 1
typedef struct {
d408 2
a409 1
typedef struct {
d462 2
a463 1
static reloc_howto_type elf_mips_howto_table[] = {
d1081 2
a1082 1
struct mips_hi16 {
d1939 2
a1940 1
static CONST struct elf_reloc_map mips_reloc_map[] = {
d3507 2
a3508 1
	  static const char *sec_names[] = {
d3727 2
a3728 1
struct mips_elf_find_line {
d3881 2
a3882 1
struct mips_elf_link_hash_table {
d4176 2
a4177 1
struct extsym_info {
d4552 2
a4553 1
  static const char * const name[] = {
d4557 2
a4558 1
  static const int sc[] = {
d5477 2
a5478 1
struct mips_elf_hash_sort_data {
a6632 1

@


1.85
log
@Generalize DWARF2 and COFF support.
@
text
@d3739 2
a3740 1
				     ABI_64_P (abfd) ? 8 : 0, NULL))
@


1.84
log
@2000-12-06  Ulf Carlsson  <ulfc@@engr.sgi.com>

	From  Ralf Baechle  <ralf@@gnu.org>

	* elf32-mips.c (elf32_mips_merge_private_bfd_data): Always permit
	BFDs containing no sections or empty .text, .data or .bss sections
	to be merged, regardless of their flags.
@
text
@d3739 1
a3739 1
				     ABI_64_P (abfd) ? 8 : 0))
@


1.83
log
@Add MIPS SB1 machine
@
text
@d2500 2
d2539 21
@


1.82
log
@Add MIPS V and MIPS 64 machine numbers
@
text
@d1849 3
d2374 4
@


1.81
log
@Add MIPS32 as a seperate MIPS architecture
@
text
@d1813 2
d1817 2
d1869 4
d1876 4
d2364 8
d2679 2
d2683 2
@


1.80
log
@2000-11-28  Kazu Hirata  <kazu@@hxi.com>

	* elf32-mips.c: Fix formatting.
@
text
@d1813 2
d1842 2
a1843 2
    case E_MIPS_MACH_MIPS32:
      return bfd_mach_mips4K;
d1864 4
d2345 6
a2350 2
    case bfd_mach_mips4K:
      val = E_MIPS_ARCH_2 | E_MIPS_MACH_MIPS32;
d2550 6
a2555 7
	  /* Don't warn about mixing -mips1 and -mips2 code, or mixing -mips3
	     and -mips4 code.  They will normally use the same data sizes and
	     calling conventions.  */

	  if ((new_isa == 1 || new_isa == 2)
	      ? (old_isa != 1 && old_isa != 2)
	      : (old_isa == 1 || old_isa == 2))
d2659 2
@


1.79
log
@2000-10-13  Ulf Carlsson  <ulfc@@engr.sgi.com>

	From  Ralf Baechle  <ralf@@gnu.org>

	* elf32-mips.c (mips_elf_create_dynamic_relocation): New argument
	local_p.  Add symbol value only for non-R_MIPS_REL32 relocations
	against local symbols.
	(_bfd_mips_elf_finish_dynamic_sections): Undo patch from 2000-10-01.
@
text
@d2 2
a3 1
   Copyright 1993, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d52 1
a52 2
struct mips_got_info
{
d67 1
a67 2
struct mips_elf_link_hash_entry
{
d74 1
a74 1
     this symbol.  */ 
d113 1
a113 1
static void bfd_mips_elf_swap_msym_in 
d143 1
a143 1
static asection *mips_elf_create_msym_section 
d145 1
a145 1
static void mips_elf_irix6_finish_dynamic_symbol 
d158 1
a158 1
static boolean mips_elf_record_global_got_symbol 
d164 1
a164 1
  PARAMS ((unsigned int, const Elf_Internal_Rela *, 
d174 1
a174 1
  PARAMS ((struct bfd_link_info *, reloc_howto_type *, 
d178 1
a178 1
static boolean mips_elf_sort_hash_table_f 
d180 1
a180 1
static boolean mips_elf_sort_hash_table 
d183 1
a183 1
static struct mips_got_info *mips_elf_got_info 
d187 1
a187 1
static bfd_vma mips_elf_create_local_got_entry 
d189 1
a189 1
static bfd_vma mips_elf_got16_entry 
d191 1
a191 1
static boolean mips_elf_create_dynamic_relocation 
d195 1
a195 1
static void mips_elf_allocate_dynamic_relocations 
d197 1
a197 1
static boolean mips_elf_stub_section_p 
d226 1
a226 1
   executables or "normal" MIPS ELF ABI executables. */
d324 1
a324 2
static const char * const mips_elf_dynsym_sec_names[] =
{
d348 1
a348 2
static const char * const mips_elf_dynsym_rtproc_names[] =
{
d358 1
a358 2
typedef struct
{
d367 1
a367 2
typedef struct
{
d376 1
a376 2
typedef struct
{
d378 1
a378 1
  unsigned int rtype : 4;	/* Relocation types. See below. */
d385 1
a385 2
typedef struct
{
d387 1
a387 1
  unsigned int rtype : 4;	/* Relocation types. See below. */
d393 1
a393 2
typedef struct
{
d399 1
a399 2
typedef struct
{
d452 1
a452 2
static reloc_howto_type elf_mips_howto_table[] =
{
d879 1
a879 1
  /* Protected jump conversion.  This is an optimization hint.  No 
d1070 1
a1070 2
struct mips_hi16
{
d1223 1
a1223 1
	  insn = (insn &~ 0xffff) | ((val >> 16) & 0xffff);
d1515 1
a1515 1
  insn = (insn &~ 0xffff) | (val & 0xffff);
d1868 1
a1868 1
/* Return printable name for ABI. */
d1870 1
a1870 1
static INLINE char*
d1880 1
a1880 1
      
d1906 1
a1906 2
static CONST struct elf_reloc_map mips_reloc_map[] =
{
a2251 1

a2258 1
/*ARGSUSED*/
a2287 1
/*ARGSUSED*/
d2344 1
a2344 1
  elf_elfheader (abfd)->e_flags &= ~ (EF_MIPS_ARCH | EF_MIPS_MACH);
d2416 1
a2416 1
/* Function to keep MIPS specific file flags like as EF_MIPS_PIC. */
d2480 1
a2480 1
      elf_elfheader (obfd)->e_ident[EI_CLASS] 
d2524 1
a2524 1
  /* Compare the ISA's. */
d2534 2
a2535 2
	 Some combinations of machines are ok, if the isa's match. */
      if (! new_mach 
d2565 2
a2566 2
      new_flags &= ~ (EF_MIPS_ARCH | EF_MIPS_MACH);
      old_flags &= ~ (EF_MIPS_ARCH | EF_MIPS_MACH);
d2572 1
a2572 1
      || (elf_elfheader (ibfd)->e_ident[EI_CLASS] 
d2575 1
a2575 1
      /* Only error if both are set (to different values). */
d2577 1
a2577 1
	  || (elf_elfheader (ibfd)->e_ident[EI_CLASS] 
d2623 1
a2623 1
  fprintf (file, _ ("private flags = %lx:"), elf_elfheader (abfd)->e_flags);
d2626 1
a2626 1
    fprintf (file, _ (" [abi=O32]"));
d2628 1
a2628 1
    fprintf (file, _ (" [abi=O64]"));
d2630 1
a2630 1
    fprintf (file, _ (" [abi=EABI32]"));
d2632 1
a2632 1
    fprintf (file, _ (" [abi=EABI64]"));
d2634 1
a2634 1
    fprintf (file, _ (" [abi unknown]"));
d2636 1
a2636 1
    fprintf (file, _ (" [abi=N32]"));
d2638 1
a2638 1
    fprintf (file, _ (" [abi=64]"));
d2640 1
a2640 1
    fprintf (file, _ (" [no abi set]"));
d2643 1
a2643 1
    fprintf (file, _ (" [mips1]"));
d2645 1
a2645 1
    fprintf (file, _ (" [mips2]"));
d2647 1
a2647 1
    fprintf (file, _ (" [mips3]"));
d2649 1
a2649 1
    fprintf (file, _ (" [mips4]"));
d2651 1
a2651 1
    fprintf (file, _ (" [unknown ISA]"));
d2654 1
a2654 1
    fprintf (file, _ (" [32bitmode]"));
d2656 1
a2656 1
    fprintf (file, _ (" [not 32bitmode]"));
d2877 6
a2882 6
        {
          if ((abfd->flags & DYNAMIC) != 0)
            hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
          else
            hdr->sh_entsize = 1;
        }
d2884 1
a2884 1
        hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
d2891 2
a2892 2
      if ( SGI_COMPAT(abfd))
        hdr->sh_entsize = 0;
d2954 1
a2954 1
      esd->rel_hdr2 
d3110 1
a3110 1
			     SEEK_SET) == -1)
a3160 1

d3271 1
a3271 1
      && bfd_get_section_by_name (abfd, 
d3343 1
a3343 1
	  for (pm = &elf_tdata (abfd)->segment_map; 
d3349 1
a3349 1
	  options_segment = bfd_zalloc (abfd, 
d3419 1
a3419 1
	     sometimes for the dynamic linker. */
d3429 3
a3431 2
	  static const char *sec_names[] =
	  { ".dynamic", ".dynstr", ".dynsym", ".hash" };
d3508 1
a3508 1
#define cbRPDR sizeof(RPDR)
d3553 1
a3553 1
  memset (debug, 0, sizeof(*debug));
a3631 1
/*ARGSUSED*/
d3648 1
a3648 2
struct mips_elf_find_line
{
d3673 1
a3673 1
				     line_ptr, 
d3800 1
a3800 2
struct mips_elf_link_hash_table
{
d3812 1
a3812 1
     entry is set to the address of __rld_obj_head as in Irix 5. */
d3816 1
a3816 1
  /* This is set if we see any mips16 stub sections. */
d3886 1
a3886 1
_bfd_mips_elf_hide_symbol(info, h)
a3942 1
/*ARGSUSED*/
d4073 1
a4073 1
      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d4094 1
a4094 2
struct extsym_info
{
d4155 1
a4155 1
	      || h->root.root.type == bfd_link_hash_undefweak)
d4469 8
a4476 5
  static const char * const name[] =
      { ".text", ".init", ".fini", ".data",
          ".rodata", ".sdata", ".sbss", ".bss" };
  static const int sc[] = { scText, scInit, scFini, scData,
                          scRData, scSData, scSBss, scBss };
d4505 1
a4505 1
      if (!mips_elf_sort_hash_table (info, (info->shared 
d4508 1
a4508 1
        return false;
d4532 1
a4532 1
		p->u.indirect.section->flags &=~ SEC_HAS_CONTENTS;
d4536 1
a4536 1
	    
d4559 1
a4559 1
	    if (o->vma < lo 
d4633 1
a4633 1
	      input_section->flags &=~ SEC_HAS_CONTENTS;
d4687 25
a4711 25
          esym.jmptbl = 0;
          esym.cobol_main = 0;
          esym.weakext = 0;
          esym.reserved = 0;
          esym.ifd = ifdNil;
          esym.asym.iss = issNil;
          esym.asym.st = stLocal;
          esym.asym.reserved = 0;
          esym.asym.index = indexNil;
          last = 0;
          for (i = 0; i < 8; i++)
            {
              esym.asym.sc = sc[i];
              s = bfd_get_section_by_name (abfd, name[i]);
              if (s != NULL)
                {
                  esym.asym.value = s->vma;
                  last = s->vma + s->_raw_size;
                }
              else
                esym.asym.value = last;
              if (!bfd_ecoff_debug_one_external (abfd, &debug, swap,
                                                 name[i], &esym))
                return false;
            }
d4814 1
a4814 1
	      input_section->flags &=~ SEC_HAS_CONTENTS;
d4893 1
a4893 1
		  input_section->flags &=~ SEC_HAS_CONTENTS;
d5052 1
a5052 1
	      input_section->flags &=~ SEC_HAS_CONTENTS;
d5156 3
a5158 3
sort_dynamic_relocs (arg1,arg2)
        const PTR arg1;
        const PTR arg2;
d5166 2
a5167 2
  bfd_elf32_swap_reloc_in(reldyn_sorting_bfd, ext_reloc1, &int_reloc1);
  bfd_elf32_swap_reloc_in(reldyn_sorting_bfd, ext_reloc2, &int_reloc2);
d5169 1
a5169 1
  return (ELF32_R_SYM(int_reloc1.r_info) - ELF32_R_SYM(int_reloc2.r_info));
d5182 1
a5182 1
   INFO.  If SGOTP is non-NULL, it is filled in with the GOT 
d5216 1
a5216 1
  struct mips_elf_link_hash_entry* h;
d5230 1
a5230 1
       /* Look up the hash table to check whether the symbol
d5232 4
a5235 4
       h = (struct mips_elf_link_hash_entry *)
 	  elf_sym_hashes (input_bfd) [r_symndx - extsymoff];
       /* Find the real hash-table entry for this symbol.  */
       while (h->root.root.type == bfd_link_hash_indirect
d5237 3
a5239 3
         h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;
       if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
         return true;
d5252 1
a5252 1
  if (value & ((bfd_vma)1 << (bits - 1)))
d5254 2
a5255 2
    value |= ((bfd_vma) - 1) << bits;      
  
d5276 1
a5276 1
    
d5306 1
a5306 1
static bfd_vma 
d5320 1
a5320 1
static bfd_vma 
d5336 1
a5336 1
  index = ((h->dynindx - g->global_gotsym->dynindx + g->local_gotno) 
d5357 1
a5357 1
  return (sgot->output_section->vma + sgot->output_offset + index - 
d5376 1
a5376 1
  
d5391 2
a5392 3
     
struct mips_elf_hash_sort_data
{
d5405 1
a5405 1
   index.  Otherwise, assign it the lowest available dynamic 
d5413 1
a5413 1
  struct mips_elf_hash_sort_data *hsd 
d5453 3
a5455 3
  mips_elf_link_hash_traverse (((struct mips_elf_link_hash_table *) 
				elf_hash_table (info)), 
			       mips_elf_sort_hash_table_f, 
d5490 1
a5490 1
		     (sgot->contents 
d5512 2
a5513 2
  for (entry = (sgot->contents 
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO); 
d5549 1
a5549 1
  for (entry = (sgot->contents 
d5608 1
a5608 1
  for (entry = (sgot->contents 
d5684 1
a5684 1
  sreloc 
d5703 1
a5703 1
      outrel.r_offset 
d5735 1
a5735 1
		indx = 0;
d5763 4
a5766 4
      
      /* If the relocation is against a local symbol was previously an absolute
	 relocation, we must adjust it by the value we give it in the dynamic
	 symbol table.  */
d5787 1
a5787 1
	 (sreloc->contents 
d5799 1
a5799 1
      && (h->min_dyn_reloc_index == 0 
d5814 1
a5814 1
      asection* scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
d5858 1
a5858 1
mips_elf_calculate_relocation (abfd, 
d5869 1
a5869 1
			       require_jalxp) 
d5903 1
a5903 1
  struct mips_elf_link_hash_entry* h = NULL;
d5922 1
a5922 1
  p = (input_section->output_section->vma 
d5942 1
a5942 1
      
d5971 1
a5971 1
      h = ((struct mips_elf_link_hash_entry *) 
d5977 1
a5977 1
      
d6002 1
a6002 1
	    symbol = (h->root.root.u.def.value 
d6021 1
a6021 1
	     _DYNAMIC_LINK symbol or _DYNAMIC_LINKING(for normal mips) symbol 
d6043 1
a6043 1
  
d6069 1
a6069 1
	   && h != NULL 
d6125 1
a6125 1
	  g = mips_elf_global_got_index 
d6127 1
a6127 1
	     (struct elf_link_hash_entry*) h);
d6157 1
a6157 1
      
d6198 2
a6199 2
	  if (!mips_elf_create_dynamic_relocation (abfd, 
						   info, 
d6308 1
a6308 1
      
d6313 1
a6313 1
	  
d6322 1
a6322 1
	  value 
d6372 1
a6372 1
      
d6392 1
a6392 1
      
d6455 1
a6455 1
			     input_bfd, input_section, 
d6494 1
a6494 1
	 
d6519 1
a6519 1
	 
d6526 1
a6526 1
	 
d6535 1
a6535 1
	 
d6544 2
a6545 2
	value = (((value & 0x1f0000) << 5) 
		 | ((value & 0x3e00000) >> 5) 
d6547 1
a6547 1
      
d6559 1
a6559 1
	 
d6562 1
a6562 1
	 
d6565 1
a6565 1
	 is, the Imm fields above replace the V-rel16 field.  
d6618 1
a6618 1
  
d6675 1
a6675 1
	     64-bit code, but make sure all their addresses are in the 
d6685 1
a6685 1
	      rel->r_offset += 4;
d6711 1
a6711 1
	      addend = mips_elf_obtain_contents (howto, 
d6735 1
a6735 1
		     the LO16 value.)  
d6742 2
a6743 2
		  lo16_relocation 
		    = mips_elf_next_relocation (lo, rel, relend); 
d6795 1
a6795 1
	  if (r_type == R_MIPS16_GPREL 
d6814 1
a6814 1
	  
d6850 1
a6850 1
		  
d6855 1
a6855 1
		  
d6870 1
a6870 1
		  bfd_put_32 (input_bfd, low_bits, 
d6872 1
a6872 1
		  bfd_put_32 (input_bfd, high_bits, 
d6878 1
a6878 1
						input_bfd,  input_section, 
d6891 1
a6891 1
      if (rel + 1 < relend 
d6899 1
a6899 1
      switch (mips_elf_calculate_relocation (output_bfd, 
d6992 1
a6992 1
	  bfd_put_32 (input_bfd, low_bits, 
d6994 1
a6994 1
	  bfd_put_32 (input_bfd, high_bits, 
d7000 1
a7000 1
      if (!mips_elf_perform_relocation (info, howto, rel, value, input_bfd, 
a7012 1
/*ARGSIGNORED*/
d7078 1
a7078 1
  
d7080 1
a7080 1
  if (bfd_get_section_by_name (abfd, 
d7118 1
a7118 1
	  h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d7128 2
a7129 2
        {
          if (!mips_elf_create_compact_rel_section (abfd, info))
d7131 1
a7131 1
        }
d7155 6
a7160 6
        {
          if (!(_bfd_generic_link_add_one_symbol
	     (info, abfd, "_DYNAMIC_LINK", BSF_GLOBAL, bfd_abs_section_ptr,
	      (bfd_vma) 0, (const char *) NULL, false,
	      get_elf_backend_data (abfd)->collect,
	      (struct bfd_link_hash_entry **) &h)))
d7162 1
a7162 1
        }
d7164 10
a7173 10
        {
          /* For normal mips it is _DYNAMIC_LINKING. */
          if (!(_bfd_generic_link_add_one_symbol
                (info, abfd, "_DYNAMIC_LINKING", BSF_GLOBAL, 
                 bfd_abs_section_ptr, (bfd_vma) 0, (const char *) NULL, false,
                 get_elf_backend_data (abfd)->collect,
                 (struct bfd_link_hash_entry **) &h)))
            return false;
        }
      h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d7190 20
a7209 20
          if (SGI_COMPAT (abfd))
            {
              if (!(_bfd_generic_link_add_one_symbol
		 (info, abfd, "__rld_map", BSF_GLOBAL, s,
		  (bfd_vma) 0, (const char *) NULL, false,
		  get_elf_backend_data (abfd)->collect,
		  (struct bfd_link_hash_entry **) &h)))
	        return false;
            }
          else
            {
              /* For normal mips the symbol is __RLD_MAP. */
              if (!(_bfd_generic_link_add_one_symbol
                    (info, abfd, "__RLD_MAP", BSF_GLOBAL, s,
                     (bfd_vma) 0, (const char *) NULL, false,
                     get_elf_backend_data (abfd)->collect,
                     (struct bfd_link_hash_entry **) &h)))
                return false;
            }
	  h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d7249 1
a7249 1
/* Create the .got section to hold the global offset table. */
d7284 1
a7284 1
  h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d7310 1
a7310 1
  elf_section_data (s)->this_hdr.sh_flags 
d7326 1
a7326 1
  if (!s) 
d7330 1
a7330 1
	  || !bfd_set_section_flags (abfd, s, 
d7334 1
a7334 1
				     | SEC_LINKER_CREATED 
d7355 1
a7355 1
  
d7358 1
a7358 1
      /* Make room for a null element. */
d7463 1
a7463 1
             this BFD. */
d7739 1
a7739 1
	     
d7783 1
a7783 1
         References from a stub section do not count. */
d7887 1
a7887 1
        break;
d7914 1
a7914 1
          && indmips->min_dyn_reloc_index < dirmips->min_dyn_reloc_index))
d7953 1
a7953 1
    mips_elf_allocate_dynamic_relocations (dynobj, 
d7956 1
a7956 1
  /* For a function, create a stub, if needed. */
d7969 1
a7969 1
	  s = bfd_get_section_by_name (dynobj, 
d7988 1
a7988 1
           && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
d7991 1
a7991 1
         the dynamic linker will take care of this. */
a8046 1
/*ARGSUSED*/
d8060 1
a8060 1
      h->fn_stub->flags &= ~ SEC_RELOC;
d8073 1
a8073 1
      h->call_stub->flags &= ~ SEC_RELOC;
d8086 1
a8086 1
      h->call_fp_stub->flags &= ~ SEC_RELOC;
d8116 1
a8116 1
	  s->_raw_size 
d8118 1
a8118 1
	  s->contents 
d8173 1
a8173 1
		  || strcmp (outname, 
d8179 1
a8179 1
	      if (strcmp (name, 
d8187 3
a8189 3
 	  bfd_size_type loadable_size = 0;
 	  bfd_size_type local_gotno;
 	  struct _bfd *sub;
d8191 1
a8191 1
 	  BFD_ASSERT (elf_section_data (s) != NULL);
d8193 1
a8193 1
 	  BFD_ASSERT (g != NULL);
d8195 21
a8215 21
 	  /* Calculate the total loadable size of the output.  That
 	     will give us the maximum number of GOT_PAGE entries
 	     required.  */
 	  for (sub = info->input_bfds; sub; sub = sub->link_next)
 	    {
 	      asection *subsection;
 
 	      for (subsection = sub->sections; 
 		   subsection; 
 		   subsection = subsection->next)
 		{
 		  if ((subsection->flags & SEC_ALLOC) == 0)
 		    continue;
 		  loadable_size += (subsection->_raw_size + 0xf) & ~0xf;
 		}
 	    }
 	  loadable_size += MIPS_FUNCTION_STUB_SIZE;

 	  /* Assume there are two loadable segments consisting of
 	     contiguous sections.  Is 5 enough?  */
 	  local_gotno = (loadable_size >> 16) + 5;
d8222 2
a8223 2
 	  g->local_gotno += local_gotno;
 	  s->_raw_size += local_gotno * MIPS_ELF_GOT_SIZE (dynobj);
d8225 5
a8229 5
 	  /* There has to be a global GOT entry for every symbol with
 	     a dynamic symbol table index of DT_MIPS_GOTSYM or
 	     higher.  Therefore, it make sense to put those symbols
 	     that need GOT entries at the end of the symbol table.  We
 	     do that here.  */
d8261 1
a8261 1
	s->_raw_size = (sizeof (Elf32_External_Msym) 
d8294 10
a8303 10
          /* SGI object has the equivalence of DT_DEBUG in the
             DT_MIPS_RLD_MAP entry.  */
          if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_MAP, 0))
            return false;
          if (!SGI_COMPAT (output_bfd))
            {
              if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
                return false;
            }
        }
d8305 9
a8313 9
        {
          /* Shared libraries on traditional mips have DT_DEBUG. */
          if (!SGI_COMPAT (output_bfd))
            {
              if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
                return false;
            }
        }
      if (reltext && SGI_COMPAT(output_bfd))
d8337 2
a8338 2
        {
          if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICTNO, 0))
d8340 1
a8340 1
        }
d8343 2
a8344 2
        {
          if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLISTNO, 0))
d8346 1
a8346 1
        }
d8402 1
a8402 1
	  && (bfd_get_section_by_name 
d8407 1
a8407 1
      if (bfd_get_section_by_name (dynobj, 
d8448 1
a8448 1
    for (p = (i == 0) ? text_section_symbols : data_section_symbols; 
d8456 1
a8456 1
	  
d8462 1
a8462 1
	  
d8499 1
a8499 1
      s = bfd_get_section_by_name (dynobj, 
d8505 1
a8505 1
      bfd_put_32 (output_bfd, STUB_LW(output_bfd), p);
d8507 1
a8507 1
      bfd_put_32 (output_bfd, STUB_MOVE(output_bfd), p);
d8516 1
a8516 1
      bfd_put_32 (output_bfd, STUB_LI16(output_bfd) + h->dynindx, p);
d8552 12
a8563 12
        {
          /* For an entity defined in a shared object, this will be
             NULL.  (For functions in shared objects for
             which we have created stubs, ST_VALUE will be non-NULL.
             That's because such the functions are now no longer defined
             in a shared object.)  */

          if (info->shared && h->root.type == bfd_link_hash_undefined)
            value = 0;
          else
            value = h->root.u.def.value;
        }
d8569 1
a8569 1
  smsym = bfd_get_section_by_name (dynobj, 
d8579 1
a8579 1
      bfd_mips_elf_swap_msym_out 
d8590 1
a8590 1
           || strcmp (name, "_DYNAMIC_LINKING") == 0)
d8605 1
a8605 1
	       || strcmp (name, mips_elf_dynsym_rtproc_names[1]) == 0)
d8651 1
a8651 1
	    BFD_ASSERT (bfd_get_section_by_name (dynobj, ".rld_map") 
d8710 1
a8710 1
	  
d8717 1
a8717 1
	      s = (bfd_get_section_by_name 
d8770 1
a8770 1
		    dyn.d_un.d_val = 0;
d8835 1
a8835 1
	      s = (bfd_get_section_by_name 
d8841 1
a8841 1
	      s = (bfd_get_section_by_name 
d8852 1
a8852 1
	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out) 
d8859 1
a8859 1
     This isn't the case of Irix rld. */
d8863 1
a8863 1
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000, 
d8880 1
a8880 1
    smsym = bfd_get_section_by_name (dynobj, 
d8893 1
a8893 1
	    bfd_mips_elf_swap_msym_out 
d8918 1
a8918 1
	    s = bfd_get_section_by_name (dynobj, 
d8936 1
a8936 1
            asection *reldyn;
d8938 9
a8946 9
            reldyn = bfd_get_section_by_name (dynobj,
                                     MIPS_ELF_REL_DYN_SECTION_NAME (dynobj));
            if (reldyn != NULL && reldyn->reloc_count > 2)
              {
                reldyn_sorting_bfd = output_bfd;
                qsort ((Elf32_External_Rel *) reldyn->contents + 1,
                       (size_t) reldyn->reloc_count - 1,
                       sizeof (Elf32_External_Rel), sort_dynamic_relocs);
              }
d8950 1
a8950 1
    s = bfd_get_section_by_name (dynobj, 
d9142 1
d9148 1
a9148 2
static const struct ecoff_debug_swap mips_elf32_ecoff_debug_swap =
{
@


1.78
log
@2000-10-01  Ulf Carlsson  <ulfc@@engr.sgi.com>

	From  Ralf Baechle  <ralf@@gnu.org>

	* elf32-mips.c (_bfd_mips_elf_finish_dynamic_sections): Mark gld
	produces binaries with got[1] = 0x80000001 to differenciate them
	for the dynamic linker from the broken binaries produced by old
	versions.
@
text
@d195 1
a195 1
	   bfd_vma, bfd_vma *, asection *));
d5683 1
a5683 1
				    symbol, addendp, input_section)
d5692 1
d5782 4
a5785 4
      /* If the relocation was previously an absolute relocation, we
	 must adjust it by the value we give it in the dynamic symbol
	 table.  */
      if (r_type != R_MIPS_REL32)
d6223 1
a6223 1
						   input_section))
d8883 1
a8883 1
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000001, 
@


1.77
log
@Add support for the MIPS32
@
text
@d8882 1
a8882 1
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000, 
@


1.76
log
@2000-07-23  Ulf Carlsson  <ulfc@@engr.sgi.com>

	* elf32-mips.c (_bfd_mips_elf_check_relocs): Use abfd instead
	of dynobj for SGI_COMPAT checks.
@
text
@d1851 3
d2352 4
@


1.75
log
@Detect and report corrupt relocs
@
text
@d7760 1
a7760 1
	  if (SGI_COMPAT (dynobj))
d7769 1
a7769 1
	  if (SGI_COMPAT (dynobj))
@


1.74
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* elf32-arm.h (elf32_arm_size_dynamic_sections): Also set
	DF_TEXTREL if DT_TEXTREL is set.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Likewise.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Likewise.
	* elf32-mips.c (_bfd_mips_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Likewise.
	* elf64-ia64.c (elf64_ia64_size_dynamic_sections): Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.

	* bfd/elflink.h (NAME(bfd_elf,size_dynamic_sections)): Also
	set DF_SYMBOLIC for symbolic link. Also set DT_RUNPATH if
	DT_RPATH is set.
	Set the DT_FLAGS and DT_FLAGS_1 entries if necessary.
@
text
@d7596 7
@


1.73
log
@2000-07-18  Ulf Carlsson  <ulfc@@engr.sgi.com>

	* elf32-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Add
	paranthesis in if statement.
@
text
@d8322 1
@


1.72
log
@2000-07-17  Koundinya K  <kk@@ddeorg.soft.net>

	Enable the support for Traditional MIPS.
	* elf32-mips.c (IRIX_COMPAT): Recognize bfd_elf32_tradbigmips_vecand
	return ict_none appropriately for traditional mips targets.
	(STUB_LW): Change 0x8f998000 to 0x8f998010 for traditional mips.
	(STUB_MOVE): Conditionalize for traditonal mips.
	(STUB_LI16): Likewise.
	(_bfd_mips_elf_modify_segment_map): Conditionalize to avoid making
	room for RTPROC header.
	(_bfd_mips_elf_modify_segment_map): For a normal mips executable set
	the permission for the PT_DYNAMIC as read, write and execute.
	(mips_elf_calculate_relocation): Check for the symbol _DYNAMIC_LINKING
	for traditonal mips.
	(_bfd_mips_elf_create_dynamic_sections): Add the symbol
	_DYNAMIC_LINKING for traditonal mips.
	(_bfd_mips_elf_create_dynamic_sections): Add the symbol __RLD_MAP
	in case of traditonal mips.
	(_bfd_mips_elf_adjust_dynamic_symbol): Create a stub only if a PLT
	entry is required. For a function if PLT is not required then set the
	corresponding hash table entry to 0.
	(_bfd_mips_elf_size_dynamic_sections): Add DT_DEBUG entry for
	traditonal mips.
	(_bfd_mips_elf_finish_dynamic_symbol): for a undefined symbol in a
	shared object set the value to 0.
	(_bfd_mips_elf_finish_dynamic_symbol): Check for the symbol
	_DYNAMIC_LINKING for traditonal mips.
	(_bfd_mips_elf_finish_dynamic_symbol): Check for the symbol __RLD_MAP
	for traditonal mips.
@
text
@d7102 1
a7102 1
  if (IRIX_COMPAT (abfd) == ict_irix5 || IRIX_COMPAT (abfd) == ict_none
d8639 2
a8640 1
	  && strcmp (name, "__rld_map") == 0 || strcmp (name, "__RLD_MAP") == 0)
@


1.71
log
@The MIPS thinks that addresses are signed.  Sign extend MIPS ECOFF
addresses.
@
text
@d8 2
d203 2
d226 2
a227 3
/* What version of Irix we are trying to be compatible with.  FIXME:
   At the moment, we never generate "normal" MIPS ELF ABI executables;
   we always use some version of Irix.  */
d230 2
a231 1
  ((ABI_N32_P (abfd) || ABI_64_P (abfd)) ? ict_irix6 : ict_irix5)
d309 6
a314 4
   : 0x8f998000)		/* lw t9,0x8000(gp) */
#define STUB_MOVE 0x03e07825	/* move t7,ra */
#define STUB_JALR 0x0320f809	/* jal t9 */
#define STUB_LI16 0x34180000	/* ori t8,zero,0 */
d2884 7
a2890 2
      if (SGI_COMPAT (abfd) && (abfd->flags & DYNAMIC) != 0)
	hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
d2892 1
a2892 1
	hdr->sh_entsize = 1;
d2899 2
a2900 1
      hdr->sh_entsize = 0;
a3272 3
  if (!SGI_COMPAT (abfd))
    return 0;

a3301 3
  if (! SGI_COMPAT (abfd))
    return true;

d3371 1
a3371 5
      /* If there are .dynamic and .mdebug sections, we make a room
	 for the RTPROC header.  FIXME: Rewrite without section names.  */
      if (bfd_get_section_by_name (abfd, ".interp") == NULL
	  && bfd_get_section_by_name (abfd, ".dynamic") != NULL
	  && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
d3373 5
a3377 4
	  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	    if (m->p_type == PT_MIPS_RTPROC)
	      break;
	  if (m == NULL)
d3379 3
a3381 1
	      m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
d3383 4
a3386 1
		return false;
d3388 1
a3388 1
	      m->p_type = PT_MIPS_RTPROC;
d3390 12
a3401 12
	      s = bfd_get_section_by_name (abfd, ".rtproc");
	      if (s == NULL)
		{
		  m->count = 0;
		  m->p_flags = 0;
		  m->p_flags_valid = 1;
		}
	      else
		{
		  m->count = 1;
		  m->sections[0] = s;
		}
d3403 6
a3408 6
	      /* We want to put it after the DYNAMIC segment.  */
	      pm = &elf_tdata (abfd)->segment_map;
	      while (*pm != NULL && (*pm)->p_type != PT_DYNAMIC)
		pm = &(*pm)->next;
	      if (*pm != NULL)
		pm = &(*pm)->next;
d3410 3
a3412 2
	      m->next = *pm;
	      *pm = m;
a3414 1

d3418 2
a3419 1
      for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL; pm = &(*pm)->next)
d3423 12
d3436 1
a3436 2
	  && m->count == 1
	  && strcmp (m->sections[0]->name, ".dynamic") == 0)
d3468 2
a3469 2
		     + (s->_cooked_size != 0 ? s->_cooked_size : s->_raw_size))
		    <= high))
d3486 1
a3486 2
			  s->_cooked_size : s->_raw_size))
		      <= high))
d4167 2
a4168 3
      if (SGI_COMPAT (einfo->abfd)
	  && (h->root.root.type == bfd_link_hash_undefined
	      || h->root.root.type == bfd_link_hash_undefweak))
d4478 9
d4535 1
a4535 1
  if (IRIX_COMPAT (abfd) == ict_irix5)
d4697 25
a4721 39
	  if (SGI_COMPAT (abfd))
	    {
	      asection *s;
	      EXTR esym;
	      bfd_vma last;
	      unsigned int i;
	      static const char * const name[] =
		{ ".text", ".init", ".fini", ".data",
		    ".rodata", ".sdata", ".sbss", ".bss" };
	      static const int sc[] = { scText, scInit, scFini, scData,
					  scRData, scSData, scSBss, scBss };

	      esym.jmptbl = 0;
	      esym.cobol_main = 0;
	      esym.weakext = 0;
	      esym.reserved = 0;
	      esym.ifd = ifdNil;
	      esym.asym.iss = issNil;
	      esym.asym.st = stLocal;
	      esym.asym.reserved = 0;
	      esym.asym.index = indexNil;
	      last = 0;
	      for (i = 0; i < 8; i++)
		{
		  esym.asym.sc = sc[i];
		  s = bfd_get_section_by_name (abfd, name[i]);
		  if (s != NULL)
		    {
		      esym.asym.value = s->vma;
		      last = s->vma + s->_raw_size;
		    }
		  else
		    esym.asym.value = last;

		  if (! bfd_ecoff_debug_one_external (abfd, &debug, swap,
						      name[i], &esym))
		    return false;
		}
	    }
d6027 2
a6028 1
      else if (strcmp (h->root.root.root.string, "_DYNAMIC_LINK") == 0)
d6031 2
a6032 1
	     _DYNAMIC_LINK symbol in mips_elf_create_dynamic_sections.
d7102 1
a7102 1
  if (IRIX_COMPAT (abfd) == ict_irix5
d7138 5
a7142 2
      if (! mips_elf_create_compact_rel_section (abfd, info))
	return false;
d7165 3
a7167 1
      if (! (_bfd_generic_link_add_one_symbol
d7172 12
a7183 1
	return false;
d7201 3
a7203 1
	  if (! (_bfd_generic_link_add_one_symbol
d7208 12
a7219 1
	    return false;
d7961 1
a7961 2
  if (h->type == STT_FUNC
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d7991 8
d8299 20
a8318 13
	  if (SGI_COMPAT (output_bfd))
	    {
	      /* SGI object has the equivalence of DT_DEBUG in the
		 DT_MIPS_RLD_MAP entry.  */
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_MAP, 0))
		return false;
	    }
	  else
	    if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
	      return false;
	}

      if (reltext)
d8340 5
a8344 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICTNO, 0))
	return false;
d8346 5
a8350 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLISTNO, 0))
	return false;
d8511 1
a8511 1
      bfd_put_32 (output_bfd, STUB_MOVE, p);
d8520 1
a8520 1
      bfd_put_32 (output_bfd, STUB_LI16 + h->dynindx, p);
d8556 12
a8567 7
	/* For an entity defined in a shared object, this will be
	   NULL.  (For functions in shared objects for
	   which we have created stubs, ST_VALUE will be non-NULL.
	   That's because such the functions are now no longer defined
	   in a shared object.)  */
	value = h->root.u.def.value;

d8593 2
a8594 1
  else if (strcmp (name, "_DYNAMIC_LINK") == 0)
d8600 6
d8608 1
a8608 7
      if (strcmp (name, "_gp_disp") == 0)
	{
	  sym->st_shndx = SHN_ABS;
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_value = elf_gp (output_bfd);
	}
      else if (strcmp (name, mips_elf_dynsym_rtproc_names[0]) == 0
d8636 1
a8636 2
  if (SGI_COMPAT (output_bfd)
      && ! info->shared)
d8639 1
a8639 1
	  && strcmp (name, "__rld_map") == 0)
d8652 2
a8653 1
	  if (IRIX_COMPAT (output_bfd) == ict_irix5)
@


1.70
log
@2000-07-09  Koundinya K  <kk@@ddeorg.soft.net>

        * elf32-mips.c (sort_dynamic_relocs): New Function.
        (_bfd_mips_elf_finish_dynamic_sections): Call sort_dynamic_relocs
	via qsort to sort the dynamic relocations in increasing r_symndx
	value.
@
text
@d43 1
a43 1
#define ECOFF_32
@


1.69
log
@2000-07-03  Ulf Carlsson  <ulfc@@engr.sgi.com>

	* elf32-mips.c: Include elf32-target.h again for the traditional
	MIPS targets.
@
text
@d198 2
d209 3
d5149 20
d8863 17
@


1.68
log
@2000-06-20  Maciej W. Rozycki  <macro@@ds2.pg.gda.pl>

	* elf32-mips.c (_bfd_mips_elf_copy_indirect_symbol): New function.
	(elf_backend_copy_indirect_symbol): Map to the new function.
@
text
@d9153 17
@


1.67
log
@2000-06-20  Ulf Carlsson  <ulfc@@engr.sgi.com>

	* elf-bfd.h (struct elf_obj_tdata): Define per BFD Irix 5 virtual
	sections elf_{text,data}_{section,symbol}.
	* elf32-mips.c: mips_elf_{text,data}_{section,symbol}{,_ptr}: Remove.
	(_bfd_mips_elf_hide_symbol): New function.
	(elf_backend_hide_symbol): Map to the new function.
	(_bfd_mips_elf_add_symbol_hook): Change to use new per BFD
	definitions of mips_elf_{text,data}_{section,symbol}.
	(mips_elf_local_relocation_p): Try to find the direct symbol
	based on new check_forced argument.
	(mips_elf_calculate_relocation): Use new version of
	mips_elf_local_relocation_p.
	(mips_elf_relocate_section): Likewise.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_sort_hash_table): Only assert that have enough GOT
	space.
	(mips_elf_got16_entry): Match all 32 bits to the existing GOT
	entry if the relocation based on the new external argument.
	(mips_elf_create_dynamic_relocation): Assert that we have a
	section contents allocated where we can swap out the dynamic
	relocations.
	(mips_elf_calculate_relocation): Find the real hash-table entry
	correctly by using h->root.root.type.  Only create a dynamic
	relocation entry if the symbol is defined in a shared library.
	Create an external GOT entry for the GOT16 relocation if the
	symbol was forced local.
	(_bfd_mips_elf_finish_dynamic_symbol): Don't assert there is a
	dynamic index if the symbol was forced local.

2000-06-20  Maciej W. Rozycki  <macro@@ds2.pg.gda.pl>

	* elf32-mips.c: Fix typos in comments.
@
text
@a946 1

d7832 21
d9132 3
@


1.66
log
@2000-06-17  Ulf Carlsson  <ulfc@@engr.sgi.com>

	* elf32-mips.c (mips_elf_calculate_relocation): Explicitly write
	GOT entries if we're doing a static link or -Bsymbolic link.
@
text
@d185 1
a185 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, asection **));
d189 1
a189 1
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma));
a3170 12
/* The Irix 5 support uses two virtual sections, which represent
   text/data symbols defined in dynamic objects.  */
static asection mips_elf_text_section;
static asection *mips_elf_text_section_ptr;
static asymbol mips_elf_text_symbol;
static asymbol *mips_elf_text_symbol_ptr;

static asection mips_elf_data_section;
static asection *mips_elf_data_section_ptr;
static asymbol mips_elf_data_symbol;
static asymbol *mips_elf_data_symbol_ptr;

d3873 21
d3968 1
a3968 1
      if (mips_elf_text_section_ptr == NULL)
d3970 11
d3982 14
a3995 10
	  mips_elf_text_section.name = ".text";
	  mips_elf_text_section.flags = SEC_NO_FLAGS;
	  mips_elf_text_section.output_section = NULL;
	  mips_elf_text_section.symbol = &mips_elf_text_symbol;
	  mips_elf_text_section.symbol_ptr_ptr = &mips_elf_text_symbol_ptr;
	  mips_elf_text_symbol.name = ".text";
	  mips_elf_text_symbol.flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  mips_elf_text_symbol.section = &mips_elf_text_section;
	  mips_elf_text_symbol_ptr = &mips_elf_text_symbol;
	  mips_elf_text_section_ptr = &mips_elf_text_section;
d4000 1
a4000 1
      *secp = mips_elf_text_section_ptr;
d4007 1
a4007 1
      if (mips_elf_data_section_ptr == NULL)
d4009 11
d4021 14
a4034 10
	  mips_elf_data_section.name = ".data";
	  mips_elf_data_section.flags = SEC_NO_FLAGS;
	  mips_elf_data_section.output_section = NULL;
	  mips_elf_data_section.symbol = &mips_elf_data_symbol;
	  mips_elf_data_section.symbol_ptr_ptr = &mips_elf_data_symbol_ptr;
	  mips_elf_data_symbol.name = ".data";
	  mips_elf_data_symbol.flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  mips_elf_data_symbol.section = &mips_elf_data_section;
	  mips_elf_data_symbol_ptr = &mips_elf_data_symbol;
	  mips_elf_data_section_ptr = &mips_elf_data_section;
d4039 1
a4039 1
      *secp = mips_elf_data_section_ptr;
d5180 2
a5181 1
mips_elf_local_relocation_p (input_bfd, relocation, local_sections)
d5185 1
d5189 2
d5194 8
a5201 3
  if (! elf_bad_symtab (input_bfd))
    return r_symndx < symtab_hdr->sh_info;
  else
d5203 10
a5212 3
      /* The symbol table does not follow the rule that local symbols
	 must come before globals.  */
      return local_sections[r_symndx] != NULL;
d5214 2
d5434 1
a5434 1
  BFD_ASSERT (hsd.min_got_dynindx == hsd.max_non_got_dynindx);
d5556 1
a5556 1
mips_elf_got16_entry (abfd, info, value)
d5560 1
d5569 9
a5577 5
  /* Although the ABI says that it is "the high-order 16 bits" that we
     want, it is really the %high value.  The complete value is
     calculated with a `addiu' of a LO16 relocation, just as with a
     HI16/LO16 pair.  */
  value = mips_elf_high (value) << 16;
d5588 1
a5588 1
      if ((address & 0xffff0000) == value)
d5590 2
a5591 1
	  /* This entry has the right high-order 16 bits.  */
d5634 1
a5634 1
   dyanmic relocation.  The ADDENDP is adjusted if necessary; the
d5661 1
d5688 1
a5688 1
  /* If we've decided to skip this relocation, just output an emtpy
d5705 4
a5708 1
	  BFD_ASSERT (indx != -1);
d5906 1
a5906 1
					 local_sections);
d5947 2
a5948 2
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
d6078 3
d6159 2
a6160 2
	       && ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
		   == 0)))
d6283 8
a6290 1
	  value = mips_elf_got16_entry (abfd, info, symbol + addend);
d6695 1
a6695 1
						      local_sections)))
d6761 2
a6762 1
	  if (!mips_elf_local_relocation_p (input_bfd, rel, local_sections))
a7832 1

d8427 2
a8428 1
  BFD_ASSERT (h->dynindx != -1);
d9112 2
@


1.65
log
@2000-05-23  H.J. Lu  <hjl@@gnu.org>

	* elf32-mips.c (mips_elf_calculate_relocation): Check
	h->root.other not h->other.

	* elf32-ppc.c (ppc_elf_relocate_section): Fix a typo.
@
text
@d6029 13
@


1.64
log
@2000-05-23  H.J. Lu  <hjl@@gnu.org>

	* elf32-i386.c (elf_i386_relocate_section): Don't allow the
	undefined symbol with the non-default visibility attributes.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ia64.c (elf64_ia64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d5921 1
a5921 1
	       && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d5940 1
a5940 1
		   || ELF_ST_VISIBILITY (h->other)))))
@


1.63
log
@Use bfd_generic_verify_endian_match() and fix it to only check when endianness
is known.
@
text
@d5920 2
a5921 1
      else if (info->shared && !info->symbolic && !info->no_undefined)
d5939 2
a5940 1
		  (!info->shared || info->no_undefined))))
@


1.62
log
@Remove U suffix from constants for K&R compilers.
Fix a couple of 64 bit nits.
@
text
@d2463 2
a2464 15
  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      const char *msg;

      if (bfd_big_endian (ibfd))
	msg = _("%s: compiled for a big endian system and target is little endian");
      else
	msg = _("%s: compiled for a little endian system and target is big endian");

      (*_bfd_error_handler) (msg, bfd_get_filename (ibfd));

      bfd_set_error (bfd_error_wrong_format);
      return false;
    }
@


1.61
log
@Fit 64-bit nits.
@
text
@d6742 2
a6743 2
		  if (addend & 0x80000000u)
		    sign_bits = 0xffffffffu;
d6862 2
a6863 2
	  if (value & 0x80000000u)
	    sign_bits = 0xffffffffu;
@


1.60
log
@* elf32-mips.c (_bfd_mips_elf_relocate_section): Do proper
sign-extension and big-endian compensation for
R_MIPS_64 even in ld -r.
@
text
@d1523 1
a1523 1
  if (val >= 0x8000 && val < 0xffff8000)
@


1.60.2.1
log
@Merge from mainline
@
text
@d5933 1
a5933 2
      else if (info->shared && !info->symbolic && !info->no_undefined
	       && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d5951 1
a5951 2
		  (!info->shared || info->no_undefined
		   || ELF_ST_VISIBILITY (h->other)))))
@


1.60.2.2
log
@Merge changes from mainline to make elf64-alpha build again
@
text
@d5934 1
a5934 1
	       && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
d5953 1
a5953 1
		   || ELF_ST_VISIBILITY (h->root.other)))))
@


1.59
log
@In bfd/:
	* elf32-mips.c (mips_elf_next_relocation): Rename from
	mips_elf_next_lo16_relocation, and generalize to look
	for any relocation type.
	(elf_mips_howto_table): Make R_MIPS_PC16 pcrel_offset.
	(elf_mips_gnu_rel_hi16): Howto for R_MIPS_GNU_REL_HI16.
	(elf_mips_gnu_rel_lo16): Howto for R_MIPS_GNU_REL_LO16.
	(elf_mips_gnu_rel16_s2): Howto for R_MIPS_GNU_REL16_S2.
	(elf_mips_gnu_pcrel64): Howto for R_MIPS_PC64.
	(elf_mips_gnu_pcrel32): Howto for R_MIPS_PC32.
	(bfd_elf32_bfd_reloc_type_lookup): Add new relocs.
	(mips_rtype_to_howto): Likewise.
	(mips_elf_calculate_relocation): Handle new relocs.
	(_bfd_mips_elf_relocate_section): REL_HI16/REL_LO16 relocs
	are paired.  The addend for R_MIPS_GNU_REL16_S2
	is shifted right two bits.
In gas/:
	* config/tc-mips.c (mips_ip): Don't put stuff in .rodata
	when embedded-pic.

	* config/tc-mips.c (SWITCH_TABLE): The ELF embedded-pic
 	implementation doesn't have special handling for switch
 	statements.
	(macro_build): Allow for code in sections other than .text.
	(macro): Likewise.
	(mips_ip): Likewise.
	(md_apply_fix): Do pc-relative relocation madness for MIPS ELF.
  	Don't perform relocs if we will be outputting them.
	(tc_gen_reloc): For ELF, just use fx_addnumber for pc-relative
 	relocations.  Allow BFD_RELOC_16_PCREL_S2 relocs when
 	embedded-pic.
In gas/testsuite/:
	* gas/mips/empic.d: New file.
	* gas/mips/empic.s: New file.
	* gas/mips/mips16-e.d: New file.
	* gas/mips/mips16-e.s: New file.
	* gas/mips/mips16-f.d: New file.
	* gas/mips/mips16-f.s: New file.
	* gas/mips/mips.exp: Add empic, mips16-e.  Add mips16-f as an
	expected failure.
In include/elf:
	* mips.h: Add R_MIPS_GNU_REL_HI16, R_MIPS_GNU_REL_LO16,
 	R_MIPS_GNU_REL16_S2, R_MIPS_PC64 and R_MIPS_PC32 relocation
 	numbers.
@
text
@d6671 4
d6731 37
d6862 2
a6863 2
	  if (value & 0x80000000)
	    sign_bits = 0xffffffff;
d6867 2
a6868 2
	  /* If only a 32-bit VMA is available do two separate
	     stores.  */
@


1.58
log
@Fix building with --enable-targets=all
@
text
@d162 3
a164 2
static const Elf_Internal_Rela *mips_elf_next_lo16_relocation
  PARAMS ((const Elf_Internal_Rela *, const Elf_Internal_Rela *));
d618 1
a618 1
	 false),		/* pcrel_offset */
d948 81
d1967 10
d2000 15
d5554 1
a5554 1
/* Returns the first R_MIPS_LO16 relocation found, beginning with
d5558 2
a5559 1
mips_elf_next_lo16_relocation (relocation, relend)
d5571 1
a5571 1
      if (ELF32_R_TYPE (relocation->r_info) == R_MIPS_LO16)
d6117 18
d6613 1
d6621 1
d6629 5
a6633 2
		     Scan ahead to find a matching R_MIPS_LO16
		     relocation.  */
d6635 1
a6635 1
		    = mips_elf_next_lo16_relocation (rel, relend); 
d6640 1
a6640 1
		  lo16_howto = mips_rtype_to_howto (R_MIPS_LO16);
d6688 2
a6689 1
	  else if (r_type == R_MIPS_26 || r_type == R_MIPS16_26)
d6705 2
a6706 1
	  if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16)
d6711 2
a6712 1
	  else if (r_type == R_MIPS_26 || r_type == R_MIPS16_26)
d6717 1
a6717 1
               We have to cast away constness for REL.  */
d6768 1
a6768 1
             undefined_symbol callback.  There's no real point in
@


1.57
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d111 1
d114 1
d2120 1
a2120 1

d2132 1
a2132 1

d5365 1
a5365 1
  bfd_vma index;
d5414 1
a5414 1
  bfd_vma index;
d6420 1
a6420 1
  bfd_vma addend;
@


1.56
log
@	* section.c (_bfd_strip_section_from_output): Add info parameter.
	If it passed as non-NULL, use it to check whether any input BFD
	has an input section which uses this output section.  Change all
	callers.
	* bfd-in2.h: Rebuild.

	* bfd-in.h: Move declarations of bfd_get_elf_phdr_upper_bound and
	bfd_get_elf_phdrs in from bfd-in2.h, correcting patch of
	1999-11-29.
	* bfd-in2.h: Rebuild.
@
text
@d5838 6
a5843 4
	  (*info->callbacks->undefined_symbol)
	    (info, h->root.root.root.string, input_bfd,
	     input_section, relocation->r_offset);
	  return bfd_reloc_undefined;
d8720 2
a8721 1
			 input_bfd, input_section, (*parent)->address)))
@


1.55
log
@	* elf32-mips.c (mips_elf_calculate_relocation): Divide R_MIPS_PC16
	value by 4 before storing it back in the field.  From
	Koundinya. K <kk@@ddeorg.soft.net>.
@
text
@d7923 1
a7923 1
	  _bfd_strip_section_from_output (s);
@


1.54
log
@        * elf-bfd.h (struct elf_backend_data): Reorder collect and
        type_change_ok; add sign_extend_vma.
        * elf32-mips.c (elf_backend_sign_extend_vma): Define.
        * elfcode.h (elf_swap_symbol_in): Mind be->sign_extend_vma.
        (elf_swap_shdr_in, elf_swap_phdr_in): Likewise.
        * elfxx-target.h (elf_backend_sign_extend_vma): Default.
        (elfNN_bed): Follow struture changes.
@
text
@d6106 1
@


1.53
log
@* elf32-mips.c (mips_elf_calculate_relocation): R_MIPS_LITERAL
relocs also need the GP value.
(_bfd_mips_elf_relocate_section): Handle unpaired LO16 relocs
properly.  Handle sign-extension for R_MIPS_64 correctly.  Correct
the GP value for R_MIPS_LITERAL relocs too.  Handle
R_MIPS_64 relocs properly on big-endian MIPS.
(mips_elf_sign_extend): Behave properly with 'long long'.
(mips_elf_highest): Correct typo.
@
text
@d8812 1
@


1.52
log
@* elf32-mips.c (mips_elf_relocate_hi16): Unused, delete.
(mips_elf_relocate_got_local): Unused, delete.
(mips_elf_relocate_global_got): Unused, delete.
@
text
@d5072 1
a5072 1
  if (value & (1 << (bits - 1)))
d5131 1
a5131 1
  return ((value + (bfd_vma) 0x800080008000) > 48) & 0xffff;
d5949 1
a6415 1
  bfd_vma last_hi16_addend;
a6416 1
  boolean last_hi16_addend_valid_p = false;
d6434 14
a6447 7
	/* Some 32-bit code uses R_MIPS_64.  In particular, people use
	   64-bit code, but make sure all their addresses are in the 
	   lowermost or uppermost 32-bit section of the 64-bit address
	   space.  Thus, when they use an R_MIPS_64 they mean what is
	   usually meant by R_MIPS_32, with the exception that the
	   stored value is sign-extended to 64 bits.  */
	howto = elf_mips_howto_table + R_MIPS_32;
a6510 3
		  /* Save the high-order bit for later.  When we
		     encounter the R_MIPS_LO16 relocation we will need
		     them again.  */
a6511 2
		  last_hi16_addend = addend;
		  last_hi16_addend_valid_p = true;
a6515 10
	      else if (r_type == R_MIPS_LO16) 
		{
		  /* Used the saved HI16 addend.  */
		  if (!last_hi16_addend_valid_p)
		    {
		      bfd_set_error (bfd_error_bad_value);
		      return false;
		    }
		  addend |= last_hi16_addend;
		}
d6548 2
a6549 1
	      || r_type == R_MIPS_GPREL32)
a6677 9
#ifdef BFD64
	  /* Just sign-extend the value, and then fall through to the
	     normal case, using the R_MIPS_64 howto.  That will store
	     the 64-bit value into a 64-bit area.  */
	  value = mips_elf_sign_extend (value, 64);
	  howto = elf_mips_howto_table + R_MIPS_64;
#else /* !BFD64 */
	  /* In the 32-bit VMA case, we must handle sign-extension and
	     endianness manually.  */
d6691 2
a6707 1
#endif /* !BFD64 */
@


1.51
log
@	* elf32-mips.c (_bfd_mips_elf_check_relocs): Don't allocate local
	GOT entries for GOT16 relocations; they're not required.
@
text
@a126 8
static void mips_elf_relocate_hi16
  PARAMS ((bfd *, Elf_Internal_Rela *, Elf_Internal_Rela *, bfd_byte *,
	   bfd_vma));
static boolean mips_elf_relocate_got_local
  PARAMS ((bfd *, bfd *, asection *, Elf_Internal_Rela *,
	   Elf_Internal_Rela *, bfd_byte *, bfd_vma));
static void mips_elf_relocate_global_got
   PARAMS ((bfd *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));
a5007 118
}

/* Handle a MIPS ELF HI16 reloc.  */

static void
mips_elf_relocate_hi16 (input_bfd, relhi, rello, contents, addend)
     bfd *input_bfd;
     Elf_Internal_Rela *relhi;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma addend;
{
  bfd_vma insn;
  bfd_vma addlo;

  insn = bfd_get_32 (input_bfd, contents + relhi->r_offset);

  addlo = bfd_get_32 (input_bfd, contents + rello->r_offset);
  addlo &= 0xffff;

  addend += ((insn & 0xffff) << 16) + addlo;

  if ((addlo & 0x8000) != 0)
    addend -= 0x10000;
  if ((addend & 0x8000) != 0)
    addend += 0x10000;

  bfd_put_32 (input_bfd,
	      (insn & 0xffff0000) | ((addend >> 16) & 0xffff),
	      contents + relhi->r_offset);
}

/* Handle a MIPS ELF local GOT16 reloc.  */

static boolean
mips_elf_relocate_got_local (output_bfd, input_bfd, sgot, relhi, rello,
			     contents, addend)
     bfd *output_bfd;
     bfd *input_bfd;
     asection *sgot;
     Elf_Internal_Rela *relhi;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma addend;
{
  unsigned int assigned_gotno;
  unsigned int i;
  bfd_vma insn;
  bfd_vma addlo;
  bfd_vma address;
  bfd_vma hipage;
  bfd_byte *got_contents;
  struct mips_got_info *g;

  insn = bfd_get_32 (input_bfd, contents + relhi->r_offset);

  addlo = bfd_get_32 (input_bfd, contents + rello->r_offset);
  addlo &= 0xffff;

  addend += ((insn & 0xffff) << 16) + addlo;

  if ((addlo & 0x8000) != 0)
    addend -= 0x10000;
  if ((addend & 0x8000) != 0)
    addend += 0x10000;

  /* Get a got entry representing requested hipage.  */
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);

  assigned_gotno = g->assigned_gotno;
  got_contents = sgot->contents;
  hipage = addend & 0xffff0000;

  for (i = MIPS_RESERVED_GOTNO; i < assigned_gotno; i++)
    {
      address = bfd_get_32 (input_bfd, got_contents + i * 4);
      if (hipage == (address & 0xffff0000))
	break;
    }

  if (i == assigned_gotno)
    {
      if (assigned_gotno >= g->local_gotno)
	{
	  (*_bfd_error_handler)
	    (_("more got entries are needed for hipage relocations"));
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}

      bfd_put_32 (input_bfd, hipage, got_contents + assigned_gotno * 4);
      ++g->assigned_gotno;
    }

  i = - ELF_MIPS_GP_OFFSET (output_bfd) + i * 4;
  bfd_put_32 (input_bfd, (insn & 0xffff0000) | (i & 0xffff),
	      contents + relhi->r_offset);

  return true;
}

/* Handle MIPS ELF CALL16 reloc and global GOT16 reloc.  */

static void
mips_elf_relocate_global_got (input_bfd, rel, contents, offset)
     bfd *input_bfd;
     Elf_Internal_Rela *rel;
     bfd_byte *contents;
     bfd_vma offset;
{
  bfd_vma insn;

  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
  bfd_put_32 (input_bfd,
	      (insn & 0xffff0000) | (offset & 0xffff),
	      contents + rel->r_offset);
@


1.50
log
@	* elf32-mips.c (_bfd_mips_elf_add_symbol_hook): Set BSF_DYNAMIC
	for special section symbols.
	* elflink.h (elf_merge_symbol): If we have no old BFD, check
	BSF_DYNAMIC on the section symbol to see whether the old BFD is
	dynamic.
@
text
@d7459 1
a7459 2
		 || r_type == R_MIPS_GOT_DISP
		 || r_type == R_MIPS_GOT16))
d7464 4
a7467 3
	     the segment.  We don't count R_MIPS_GOT_HI16, or
	     R_MIPS_CALL_HI16 because these are always followed by an
	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.
d8006 1
a8006 1
 	     contiguous sections.  Is 5 enough? */
d8008 6
@


1.49
log
@	* elf32-mips.c (mips_elf_calculate_relocation): Fix unfortunate
	coincidence of variable names between old and new code.
@
text
@d3880 1
a3880 1
	  mips_elf_text_symbol.flags = BSF_SECTION_SYM;
d3904 1
a3904 1
	  mips_elf_data_symbol.flags = BSF_SECTION_SYM;
@


1.48
log
@	* elf32-mips.c (_bfd_mips_elf_size_dynamic_sections): Always
	output DT_MIPS_GOTSYM.
	(_bfd_mips_elf_finish_dynamic_sections): Use the same value as
 	DT_MIPS_SYMTABNO if there are no global GOT symbols.
@
text
@d5950 1
a5950 1
	relocation = 0;
d5960 1
a5960 1
	  relocation = 0;
@


1.47
log
@	* elf32-mips.c (mips_elf_create_dynamic_relocation): Change
	prototype.  Handle local symbols.  Add commentary.
	(mips_elf_calculate_relocation): Adjust accordingly.
	(_bfd_mips_elf_check_relocs): Handle local symbols in R_MIPS_32
	relocations.
@
text
@d7560 1
a7560 1
		 table index greater that DT_GOTSYM if there are
d8166 1
a8166 2
      if (g != NULL && g->global_gotsym != NULL
	  && ! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_GOTSYM, 0))
d8561 17
a8587 11
	      break;

	    case DT_MIPS_UNREFEXTNO:
	      /* The index into the dynamic symbol table which is the
		 entry of the first external symbol that is not
		 referenced within the same object.  */
	      dyn.d_un.d_val = bfd_count_sections (output_bfd) + 1;
	      break;

	    case DT_MIPS_GOTSYM:
	      dyn.d_un.d_val = g->global_gotsym->dynindx;
@


1.46
log
@	* elf32-mips.c (elf_mips_howto_table): Fix src_mask for
	R_MIPS_GOT16 and R_MIPS_CALL16.
	(mips_elf_got16_entry): Use mips_elf_high to calculate the value
	to use wheen looking for a preexisting GOT entry.
@
text
@d195 1
a195 1
static unsigned int mips_elf_create_dynamic_relocation 
d197 2
a198 1
	   long, bfd_vma, asection *));
d5545 1
a5545 1
  value = mips_elf_high (value);
d5598 8
a5605 8
/* Create a rel.dyn relocation for the dynamic linker to resolve.  The
   relocatin is against the symbol with the dynamic symbol table index
   DYNINDX.  REL is the original relocation, which is now being made
   dynamic.  */

static unsigned int
mips_elf_create_dynamic_relocation (output_bfd, info, rel, dynindx,
				    addend, input_section)
d5609 4
a5612 2
     long dynindx;
     bfd_vma addend;
d5630 3
a5632 7
  /* The symbol for the relocation is the same as it was for the
     original relocation.  */
  outrel.r_info = ELF32_R_INFO (dynindx, R_MIPS_REL32);

  /* The offset for the dynamic relocation is the same as for the
     original relocation, adjusted by the offset at which the original
     section is output.  */
d5637 13
a5649 8
      bfd_vma off;

      off = (_bfd_stab_section_offset
	     (output_bfd, &elf_hash_table (info)->stab_info,
	      input_section,
	      &elf_section_data (input_section)->stab_info,
	      rel->r_offset));
      if (off == (bfd_vma) -1)
a5650 1
      outrel.r_offset = off;
a5651 2
  outrel.r_offset += (input_section->output_section->vma
		      + input_section->output_offset);
d5654 2
a5655 1
     record.  */
d5658 29
d5688 30
d5730 9
d5765 1
a5765 1
	  cptrel.konst = addend;
d5776 1
a5776 1
  return sreloc->reloc_count - 1;
d6097 22
a6118 21
      /* If we're creating a shared library, or this relocation is
	 against a symbol in a shared library, then we can't know
	 where the symbol will end up.  So, we create a relocation
	 record in the output, and leave the job up to the dynamic
	 linker.  */
      if (info->shared || !sec->output_section)
	{
	  unsigned int reloc_index;

	  BFD_ASSERT (h != NULL);
	  reloc_index 
	    = mips_elf_create_dynamic_relocation (abfd, 
						  info, 
						  relocation,
						  h->root.dynindx,
						  addend,
						  input_section);
	  if (h->min_dyn_reloc_index == 0
	      || reloc_index < h->min_dyn_reloc_index)
	    h->min_dyn_reloc_index = reloc_index;
	  value = symbol + addend;
d7562 2
a7563 1
	      if (!mips_elf_record_global_got_symbol (h, info, g))
@


1.45
log
@	* elf32-mips.c (mips_elf_got16_entry): Don't multiply GOT index by
	the size of a GOT entry here.
	(mips_elf_calculate_relocation): Don't create a local GOT entry
	for the symbol in a GOT16 relocation; just for it's high-order bit
	(_bfd_mips_elf_relocate_section): Fix thinko.
@
text
@d605 1
a605 1
	 0,			/* src_mask */
d635 1
a635 1
	 0,			/* src_mask */
d5540 5
a5544 1
  value &= 0xffff0000;
@


1.44
log
@	* elf32-mips.c (_bfd_mips_elf_relocate_section): Tweak HI16/LO16
	handling for REL relocations.  And only left-shift R_MIPS26
	relocation addends where necessary.
@
text
@d5554 1
a5554 1
	  index = MIPS_ELF_GOT_SIZE (abfd) * (entry - sgot->contents);
d5974 1
a5974 1
      if (h)
d5981 4
a6605 6
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  sym = local_syms + r_symndx;
	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    /* Adjust the addend appropriately.  */
	    addend += local_sections[r_symndx]->output_offset;
	  
d6611 1
a6611 1
	  else if (r_type == R_MIPS16_26 || r_type == R_MIPS16_26)
d6618 6
@


1.43
log
@	* elf32-mips.c (mips_elf_next_lo16_addend): Rename to ...
	(mips_elf_next_lo16_relocation): Don't compute the addend here.
	Just return the relocation found.
	(mips_elf_relocate_section): Pull the LO16 addend out of the
	section itself when using REL relocations.
@
text
@d6531 7
a6537 1
		  /* Scan ahead to find a matching R_MIPS_LO16
d6550 1
d6560 1
a6560 1
		  addend |= l;
a6580 5
	      else if (r_type == R_MIPS16_26 
		       || r_type == R_MIPS16_26)
		/* The addend is stored without its two least
		   significant bits (which are always zero.)  */
		addend <<= 2;
d6613 6
@


1.42
log
@	* elf32-mips.c (mips_elf_calculate_relocation): Restore
	_DYNAMIC_LINK handling and handling of undefined symbols in shared
	libraries.
@
text
@d168 2
a169 2
static boolean mips_elf_next_lo16_addend
  PARAMS ((const Elf_Internal_Rela *, const Elf_Internal_Rela *, bfd_vma *));
d5566 2
a5567 3
/* Sets *ADDENDP to the addend for the first R_MIPS_LO16 relocation
   found, beginning with RELOCATION.  RELEND is one-past-the-end of
   the relocation table.  */
d5569 2
a5570 2
static boolean
mips_elf_next_lo16_addend (relocation, relend, addendp)
a5572 1
     bfd_vma *addendp;
d5583 1
a5583 4
	{
	  *addendp = relocation->r_addend;
	  return true;
	}
d5590 1
a5590 1
  return false;
d6527 4
d6533 3
a6535 3
		  bfd_vma l;
		  
		  if (!mips_elf_next_lo16_addend (rel, relend, &l))
d6538 7
d6616 1
a6616 1
	    addend >>= 16;
@


1.41
log
@Fix typo
@
text
@d5880 13
@


1.40
log
@	* elf32-mips.c (_bfd_mips_elf_relocate_section): Handle R_MIPS_26
	and R_MIPS16_26 relocations correctly when relocating.
	(_bfd_mips_elf_check_relocs): Don't assume that R_MIPS_CALL_HI16
	and R_MIPS_CALL_LO16 are for global symbols.
@
text
@d6559 1
a6559 1
		addend << 2;
@


1.39
log
@Fix typo
@
text
@d6555 5
d6598 5
d7386 5
a7390 9
	  /* This symbol requires a global offset table entry.  */
	  if (!mips_elf_record_global_got_symbol (h, info, g))
	    return false;

	  /* We need a stub, not a plt entry for the undefined
	     function.  But we record it as if it needs plt.  See
	     elf_adjust_dynamic_symbol in elflink.h.  */
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	  h->type = STT_FUNC;
d7392 6
@


1.38
log
@	* elf32-mips.c (_bfd_mips_elf_final_link): Handle the case where
	there are no global symbols requiring GOT entries.
	(_bfd_mips_elf_size_dynamic_sections): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_finish_dynamic_sections): Likewise.
@
text
@d7777 1
a7777 1
  struct mips_got_info *g;
d8047 2
a8048 1
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_GOTSYM, 0))
d8463 1
a8463 4
	      if (g->global_gotsym != NULL)
		dyn.d_un.d_val = g->global_gotsym->dynindx;
	      else
		dyn.d_un.d_val = 0;
@


1.37
log
@	* elf32-mips.c (mips_elf_calculate_relocation): Undefined weak
	symbols are considered to have the value zero.
	(_bfd_mips_elf_relocate_section): Don't try to perform a
	relocation for an undefined symbol.
	(_bfd_mips_elf_check_relocs): Allocate locate GOT space for local
	GOT16 relocations.
@
text
@d4366 4
a4369 3
      BFD_ASSERT ((elf_hash_table (info)->dynsymcount
		   - g->global_gotsym->dynindx)
		  <= g->global_gotno);
d7900 6
a7905 1
 	  i = elf_hash_table (info)->dynsymcount - g->global_gotsym->dynindx;
d8195 2
a8196 1
  if (h->dynindx >= g->global_gotsym->dynindx)
d8462 4
a8465 1
	      dyn.d_un.d_val = g->global_gotsym->dynindx;
@


1.36
log
@        * elf32-mips.c (_bfd_mips_elf_final_link): Only re-sort dynsyms if
        dynamic_sections_created.
@
text
@d5873 6
d6646 4
a6649 2
             undefined_symbol callback.  */
	  break;
d7342 2
a7343 1
		 || r_type == R_MIPS_GOT_DISP))
d7346 5
a7350 5
	     don't count R_MIPS_HI16 or R_MIPS_GOT16 relocations
	     because they are always followed by a R_MIPS_LO16
	     relocation for the value.  We don't R_MIPS_GOT_PAGE
	     because we can estimate the maximum number of pages
	     needed by looking at the size of the segment.
@


1.35
log
@        * elf32-mips.c (mips_info_to_howto_rel): Split out switch to ...
        (mips_rtype_to_howto): ... new function.
        (_bfd_mips_elf_relocate_section): Use it.
@
text
@d4344 1
a4344 1
  if (elf_hash_table (info)->dynobj)
@


1.34
log
@	* elf32-mips.c (_bfd_mips_elf_relocate_section): Fix typo.
@
text
@d101 2
d1895 3
a1897 5
static void
mips_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf32_Internal_Rel *dst;
a1898 3
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
d1902 1
a1902 1
      cache_ptr->howto = &elf_mips16_jump_howto;
d1905 1
a1905 1
      cache_ptr->howto = &elf_mips16_gprel_howto;
d1908 1
a1908 1
      cache_ptr->howto = &elf_mips_gnu_vtinherit_howto;
d1911 1
a1911 1
      cache_ptr->howto = &elf_mips_gnu_vtentry_howto;
d1916 1
a1916 1
      cache_ptr->howto = &elf_mips_howto_table[r_type];
d1919 14
d6475 1
a6475 1
	howto = elf_mips_howto_table + r_type;
@


1.33
log
@	* elf32-mips.c (mips_elf_calculate_relocation): Get the GP value
	when looking at a R_MIPS_GOT16 relocation.
@
text
@d6604 1
a6604 1
	  && r_type != R_MIPS_NONE)
@


1.32
log
@Fix typo in last change.
@
text
@d5941 1
@


1.31
log
@	* elf32-mips.c (_bfd_mips_elf_final_link): Restore setting of GP
 	removed in previous change.
	(_bfd_mips_elf_relocate_section): Adjust GP relative relocations
 	in relocateable output.
@
text
@d6554 1
a6554 1
	    /* A non-local relocation is never against a section.  */
d6560 2
a6561 10
	    {
	      /* Adjust the addend appropriately.  */
	      addend += local_sections[r_symndx]->output_offset;

	      /* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16,
	     then we only want to write out the high-order 16 bits.
	     The subsequent R_MIPS_LO16 will handle the low-order bits.  */
	      if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16)
		addend >>= 16;
	    }
d6568 6
@


1.30
log
@	* elflink.h (elf_link_adjust_relocs): New function.
	(elf_bfd_final_link): Use it.
	(elf_link_input_bfd): Deal with the fact that there can be
	two relocation sections for a single section.
	(elf_reloc_link_order): Likewise.

	* elf32-mips.c (_bfd_mips_elf_final_link): Don't set GP for
	a relocateable object.
	(_bfd_mips_elf_relocate_section): Handle relocateable links.
@
text
@d4391 14
d6547 5
a6551 3
	     the relocations back out to the object file, unless they're 
	     against a section symbol, in which case we need to adjust 
	     by the section offset.  */
d6559 4
a6562 2
	  if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
	    continue;
d6564 1
a6564 4
	  /* Adjust the addend appropriately.  */
	  addend += local_sections[r_symndx]->output_offset;

	  /* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16,
d6567 9
a6575 2
	  if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16)
	    addend >>= 16;
@


1.29
log
@	* elf32-mips.c (mips_elf_local_relocation_p): New static
	function.
	(mips_elf_next_lo16_addend): Call bfd_set_error on failure.
	(mips_elf_calculate_relocation): Use mips_elf_local_relocation_p.
	Always set *require_jalxp.
	(mips_elf_stub_section_p): Mark abfd parameter as unused.
	(_bfd_mips_elf_relocate_section): Only look for LO16 following
	GOT16 if the GOT16 is against a local symbol.  Don't return false
	for an undefined symbol.  If there is an overflow, assert that we
	have a name.
@
text
@a4390 14
      else if (info->relocateable)
	{
	  bfd_vma lo;

	  /* Find the GP-relative section with the lowest offset.  */
	  lo = (bfd_vma) -1;
	  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
	    if (o->vma < lo 
		&& (elf_section_data (o)->this_hdr.sh_flags & SHF_MIPS_GPREL))
	      lo = o->vma;

	  /* And calculate GP relative to that.  */
	  elf_gp (abfd) = lo + ELF_MIPS_GP_OFFSET (abfd);
	}
d6418 1
a6418 1
  const Elf_Internal_Rela *rel;
d6434 4
d6440 1
a6440 2
      if (ELF32_R_TYPE (rel->r_info) == R_MIPS_64
	  && !ABI_64_P (output_bfd))
d6449 1
a6449 1
	howto = elf_mips_howto_table + ELF32_R_TYPE (rel->r_info);
d6468 2
a6469 1
	      int r_type = ELF32_R_TYPE (rel->r_info);
d6471 1
d6527 50
d6583 1
a6583 1
	  && ELF32_R_TYPE (rel[1].r_info) != R_MIPS_NONE)
d6646 1
a6646 2
      if (ELF32_R_TYPE (rel->r_info) == R_MIPS_64
	  && !ABI_64_P (output_bfd))
@


1.28
log
@	* elf32-mips.c (_bfd_mips_elf_modify_segment_map): Don't require
	a PT_PHDR program headers.
	(_bfd_mips_elf_final_link): Don't assume there are going to be
	section symbols when we're not building a shared object.
	(_bfd_mips_elf_check_relocs): Make sure we have a GOT when
	we need one.
@
text
@d187 2
d5155 23
d5582 1
d5783 2
a5784 1
  /* Figure out whether or not the symbol is local.  */
d5786 5
a5790 1
  if (elf_bad_symtab (input_bfd))
a5794 6
      local_p = local_sections[r_symndx] != NULL;
    }
  else
    {
      extsymoff = symtab_hdr->sh_info;
      local_p = r_symndx < extsymoff;
d5933 2
a5934 3
  if (!info->relocateable
      && ((r_type == R_MIPS16_26) != target_is_16_bit_code_p))
    *require_jalxp = true;
d6408 1
a6408 1
     bfd *abfd;
d6490 4
a6493 1
	      if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16)
d6516 4
a6519 1
		    return false;
d6566 3
a6568 1
	  return false;
d6579 8
a6586 6
	  else if (!name
		   || ! ((*info->callbacks->reloc_overflow)
			 (info, name, howto->name, (bfd_vma) 0,
			  input_bfd, input_section, rel->r_offset)))
	    return false;
	  
@


1.27
log
@	* elf32-mips.c (mips_elf_stub_section_p): New function.
	(mips_elf_calculate_relocation): Handle MIPS16 stub functions.
	(mips_elf_relocate_section): Adjust calling sequence for
	mips_elf_calculate_relocation and mips_elf_perform_relocation.
	(mips_elf_perform_relocation): Turn `jal' into `jalx' where
	required.
@
text
@d3248 8
a3255 2
	  for (m = elf_tdata (abfd)->segment_map; m; m = m->next)
	    if (m->p_type == PT_PHDR)
a3257 4
	  /* There should always be a program header table.  */
	  if (m == NULL)
	    return false;

d3260 1
a3260 1
	  options_segment->next = m->next;
d3266 1
a3266 1
	  m->next = options_segment;
a4330 1

d4337 9
a4345 1
      if (!mips_elf_sort_hash_table (info, bfd_count_sections (abfd) + 1))
d5543 1
a5543 1
     relo!scation may occur as one of these.  We permit a similar
d7202 3
@


1.26
log
@	* elf32-mips.c (mips_elf_obtain_contents): Swap 16-bit halves of
	things relocated by R_MIPS16_GPREL.
	(mips_elf_perform_relocation): Likewise.
@
text
@d171 2
a172 1
	   Elf_Internal_Sym *, asection **, bfd_vma *, const char **));
d175 1
a175 1
static void mips_elf_perform_relocation
d178 1
a178 1
	   bfd *, bfd_byte *));
d196 2
d5668 2
d5687 2
a5688 1
			       namep) 
d5700 1
d5735 2
d5785 2
d5835 60
d5897 6
d6194 3
a6196 1
   relocatin applies.
d6200 1
a6200 1
static void
d6202 2
a6203 1
			     input_bfd, contents)
d6209 1
d6211 1
d6215 1
d6228 1
a6228 1
  if (ELF32_R_TYPE (relocation->r_info) == R_MIPS16_26)
d6296 1
a6296 1
  else if (ELF32_R_TYPE (relocation->r_info) == R_MIPS16_GPREL)
d6325 35
d6362 1
a6362 2
  if ((ELF32_R_TYPE (relocation->r_info) == R_MIPS16_GPREL
       || ELF32_R_TYPE (relocation->r_info) == R_MIPS16_26)
d6368 15
d6414 1
d6519 2
a6520 1
					     &name))
d6613 4
a6616 2
      mips_elf_perform_relocation (info, howto, rel, value, input_bfd, 
				   contents);
@


1.25
log
@        * elf32-mips.c (struct mips_got_info): Add global_gotno.
        (_bfd_mips_elf_size_dynamic_sections): Set it.
        (_bfd_mips_elf_final_link): Re-sort; verify the got did not grow.
        (mips_elf_sort_hash_table): Set max_non_got_dynindex based off
        new argument max_local.
@
text
@d6104 2
a6105 1
  if (ELF32_R_TYPE (relocation->r_info) == R_MIPS16_26
a6211 12
      /* Perform the relocation.  */
      x |= (value & howto->dst_mask);

      /* Swap the high- and low-order 16 bits on little-endian
         systems.  */
      if (bfd_little_endian (input_bfd))
	x = (((x & 0xffff) << 16)
	     | ((x & 0xffff0000) >> 16));

      /* Store the value.  */
      bfd_put_32 (input_bfd, x, location);
      return;
d6231 3
a6233 1
         All we need to do here is shuffle the bits appropriately.  */
d6242 7
@


1.24
log
@	* elf32-mips.c (mips_elf_obtain_contents): Swap the 16-bit
	subwords when handling an R_MIPS16_26 relocation.
	(mips_elf_perform_relocation): Don't be paranoid abour right-shift
	semantics.
@
text
@d54 2
d182 1
a182 1
  PARAMS ((struct bfd_link_info *));
d4322 24
d5331 4
a5334 1
   required.  */
d5337 1
a5337 1
mips_elf_sort_hash_table (info)
d5339 1
d5349 1
a5349 1
  hsd.max_non_got_dynindx = 1;
d7635 1
a7635 1
 	  if (!mips_elf_sort_hash_table (info))
d7639 1
@


1.23
log
@	* elf32-mips.c (elf_mips16_gprel_howto): Adjust src_mask and
	dst_mask to match reality.
	(_bfd_mips_elf_calculate_relocation): Handle R_MIPS16_GPREL.
	(mips_elf_obtain_contents): Use bfd_get.
	(mips_elf_perform_relocation): Handle R_MIPS16_GPREL.
	(mips_elf_relocate_section): Likewise.
@
text
@d5887 1
a5887 1
	 the output file that's different.  That's handle in
d6074 6
d6188 1
a6188 1
	     | (((x & 0xffff0000) >> 16) & 0xffff));
@


1.22
log
@	* elf32-mips.c (mips_elf_calculate_relocation): Handle R_MIPS16_26.
	(mips_elf_relocate_section): Adjust calling sequence for
	mips_elf_perform_relocation.
	(mips_elf_perform_relocation): Take additional argument.  Handle
	R_MIPS16_26.  Use bfd_put for convenience.
@
text
@d926 1
a926 4
/* The reloc used for the mips16 gprel instruction.  The src_mask and
   dsk_mask for this howto do not reflect the actual instruction, in
   which the value is not contiguous; the masks are for the
   convenience of the relocate_section routine.  */
d938 2
a939 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d5944 5
a6048 5
    case R_MIPS16_GPREL:
      /* These relocations, used for MIPS16, are not clearly
	 documented anywhere.  What do they do?  */
      return bfd_reloc_notsupported;

d6071 2
a6072 30
  switch (bfd_get_reloc_size (howto))
    {
    case 0:
      x = 0;
      break;

    case 1:
      x = bfd_get_8 (input_bfd, location);
      break;

    case 2:
      x = bfd_get_16 (input_bfd, location);
      break;

    case 4:
      x = bfd_get_32 (input_bfd, location);
      break;

    case 8:
#ifdef BFD64
      x = bfd_get_64 (input_bfd, location);
#else
      abort ();
#endif
      break;

    default:
      abort ();
      break;
    }
d6188 23
d6315 9
@


1.21
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): New.
	(struct elf_link_hash_table): Add dynlocal.
	(_bfd_elf_link_lookup_local_dynindx): Prototype.
	(_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_renumber_dynsyms): Prototype.
	(_bfd_elf,link_record_local_dynamic_symbol): Prototype.
	* elfcode.h (elf_link_record_local_dynamic_symbol): New alias.
	* elflink.c (_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_lookup_local_dynindx): New function.
	(elf_link_renumber_hash_table_dynsyms): New function.
	(_bfd_elf_link_renumber_dynsyms): New function.
	* elflink.h (elf_link_record_local_dynamic_symbol): New function.
	(struct elf_assign_sym_version_info): Delete removed_dynamic.
	(bfd_elf,size_dynamic_sections): Use _bfd_strip_section_from_output
	instead of elf_link_remove_section_and_adjust_dynindices.
	Remove removed_dynamic code.  Use _bfd_elf_link_renumber_dynsyms.
	(elf_link_assign_sym_version): Remove removed_dynamic code.
	(elf_link_renumber_dynsyms): Delete.
	(elf_bfd_final_link): Install section and local symbols into .dynsym.
	* elf32-m68k.c (elf_m68k_adjust_dynindx): Delete.
	(elf_m68k_size_dynamic_sections): Don't set section dynindicies.
	(elf_m68k_finish_dynamic_sections): Don't write section dynsyms.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-sparc.c: Similarly.
@
text
@d173 2
a174 1
  PARAMS ((reloc_howto_type *, const Elf_Internal_Rela *, bfd_vma,
d5887 6
d5932 1
a5932 1
	     relocation can easily overlfow in this situation, but the
a6046 1
    case R_MIPS16_26:
d6116 3
a6118 1
mips_elf_perform_relocation (howto, relocation, value, input_bfd, contents)
d6126 4
a6129 1
  bfd_byte *location = contents + relocation->r_offset;
d6137 71
a6207 13
  /* Set the field.  */
  x |= (value & howto->dst_mask);

  /* Put the value into the output.  */
  switch (bfd_get_reloc_size (howto))
    {
    case 0:
      x = 0;
      break;

    case 1:
      bfd_put_8 (input_bfd, x, location);
      break;
d6209 5
a6213 3
    case 2:
      bfd_put_16 (input_bfd, x, location);
      break;
d6215 1
a6215 1
    case 4:
d6217 2
a6218 1
      break;
d6220 2
a6221 7
    case 8:
#ifdef BFD64
      bfd_put_64 (input_bfd, x, location);
#else
      abort ();
#endif
      break;
d6223 2
a6224 4
    default:
      abort ();
      break;
    }
d6444 1
a6444 1
      mips_elf_perform_relocation (howto, rel, value, input_bfd, 
@


1.20
log
@	* elf32-mips.c (mips_elf_calculate_relocation): Do not complain
	when _gp_disp is undefined.  Do not check R_MIPS_LO16 for overflow
	when the relocation is against _gp_disp.
@
text
@a7695 26
  /* If we use dynamic linking, we generate a section symbol for each
     output section.  These are local symbols, which means that they
     must come first in the dynamic symbol table.
     That means we must increment the dynamic symbol index of every
     other dynamic symbol.  */
  {
    unsigned int c, i;

    c = 0;
    if (elf_hash_table (info)->dynamic_sections_created)
      {
	c = bfd_count_sections (output_bfd);
	elf_link_hash_traverse (elf_hash_table (info),
				_bfd_elf_link_adjust_dynindx,
				(PTR) &c);
	elf_hash_table (info)->dynsymcount += c;

	for (i = 1, s = output_bfd->sections; s != NULL; s = s->next, i++)
	  {
	    elf_section_data (s)->dynindx = i;
	    /* These symbols will have no names, so we don't need to
	       fiddle with dynstr_index.  */
	  }
      }
  }

a8139 1
    asection *sdynsym;
a8141 1
    Elf_Internal_Sym sym;
d8144 3
a8146 2
    /* Set up the section symbols for the output sections. SGI sets
       the STT_NOTYPE attribute for these symbols.  Should we do so?  */
a8147 1
    sdynsym = bfd_get_section_by_name (dynobj, ".dynsym");
d8150 1
a8150 1
    if (sdynsym != NULL)
a8153 5
	sym.st_size = 0;
	sym.st_name = 0;
	sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	sym.st_other = 0;

d8159 1
a8159 2
	    int indx;
	    long dynindx;
d8161 4
a8164 18
	    sym.st_value = s->vma;

	    indx = elf_section_data (s)->this_idx;
	    BFD_ASSERT (indx > 0);
	    sym.st_shndx = indx;
		
	    dynindx  = elf_section_data (s)->dynindx;

	    (*get_elf_backend_data (output_bfd)->s->swap_symbol_out)
	      (output_bfd, &sym, 
	       sdynsym->contents 
	       + (dynindx * MIPS_ELF_SYM_SIZE (output_bfd)));
		
	    if (smsym)
	      bfd_mips_elf_swap_msym_out 
		(output_bfd, &msym,
		 (((Elf32_External_Msym *) smsym->contents)
		  + dynindx));
a8165 5

	/* Set the sh_info field of the output .dynsym section to
	       the index of the first global symbol.  */
	elf_section_data (sdynsym->output_section)->this_hdr.sh_info =
	  bfd_count_sections (output_bfd) + 1;
@


1.19
log
@	* dwarf2.c (read_attribute): Support DW_FORM_ref8.
	* elf32-mips.c (mips_elf_link_hash_entry): Change mips_32_relocs
	to possibly_dynamic_relocs.  Adjust usage throughout code.
	(elf_mips_howto_table): Handle R_MIPS_64 correctly.
	(elf_mips_ctor64_howto): Likewise.
	(mips_elf_calculate_relocation): Handle R_MIPS_64 like R_MIPS_32.
	Adjust indentation.
	(mips_elf_relocate_section): Handle R_MIPS_64 in 32-bit mode.
	(_bfd_mips_elf_check_relocs): Handle R_MIPS_64 like R_MIPS_32.
	Use MIPS_ELF_GOT_SIZE to calculate the size of GOT entries.
	* elf64-mips.c (elf_backend_may_use_rel_p): Define.
@
text
@d5773 7
a5779 5

      /* If this symbol is defined, calculate its address.  */
      if ((h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
	  && h->root.root.u.def.section)
d5913 16
a5928 1
	  overflowed_p = mips_elf_overflow_p (value, 16);
@


1.18
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d70 3
a72 2
  /* Number of MIPS_32 or MIPS_REL32 relocs against this symbol.  */
  unsigned int mips_32_relocs;
d682 1
a682 4
  /* A 64 bit relocation.  This is used in 32 bit ELF when addresses
     are 64 bits long; the upper 32 bits are simply a sign extension.
     The fields of the howto should be the same as for R_MIPS_32,
     other than the type, name, and special_function.  */
d685 2
a686 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
d693 2
a694 2
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
d3767 1
a3767 1
      ret->mips_32_relocs = 0;
d5851 1
d5864 5
a5868 5
						   info, 
						   relocation,
						   h->root.dynindx,
						   addend,
						   input_section);
d5876 1
a5876 1
	  if (r_type == R_MIPS_32)
a5976 4
    case R_MIPS_64:
      value = (symbol + addend) & howto->dst_mask;
      break;

d6176 11
a6186 1
      howto = elf_mips_howto_table + ELF32_R_TYPE (rel->r_info);
d6311 50
d6949 1
d6977 1
a6977 1
	  sgot->_raw_size += 4;
d7018 1
d7056 1
a7056 1
		  ++hmips->mips_32_relocs;
d7249 1
a7249 1
      && hmips->mips_32_relocs != 0
d7251 2
a7252 1
    mips_elf_allocate_dynamic_relocations (dynobj, hmips->mips_32_relocs);
@


1.17
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d645 3
a647 3
    { 13 },
    { 14 },
    { 15 },
d790 3
a792 3
  { R_MIPS_INSERT_A },
  { R_MIPS_INSERT_B },
  { R_MIPS_DELETE },
d869 4
a872 4
  { R_MIPS_REL16 },
  { R_MIPS_ADD_IMMEDIATE },
  { R_MIPS_PJUMP },
  { R_MIPS_RELGOT },
d1007 1
a1007 1
     bfd *abfd;
d1610 1
a1610 1
     bfd *abfd;
d1613 1
a1613 1
     PTR data;
d1616 1
a1616 1
     char **error_message;
d2146 1
a2146 1
     bfd *abfd;
d2177 1
a2177 1
     boolean linker;
d2862 2
a2863 2
     bfd *abfd;
     Elf32_Internal_Shdr *hdr;
d3824 1
a3824 1
     flagword *flagsp;
d5168 1
a5168 1
     bfd_vma value;
d5182 1
a5182 1
     bfd_vma value;
d5243 1
a5243 1
     struct mips_got_info *g;
d6194 1
a6194 1
	  if (rel - relocs 
d6321 3
a6323 3
     bfd *abfd;
     struct bfd_link_info *info;
     const char *name;
d6503 1
a6503 1
     struct bfd_link_info *info;
d7070 1
a7070 1
     struct bfd_link_info *info;
d7118 4
a7121 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d7284 1
a7284 1
     PTR data;
d7655 1
a7655 1
     bfd *abfd;
@


1.16
log
@Fix typo in previous change.
@
text
@a120 2
static struct bfd_link_hash_table *mips_elf_link_hash_table_create
  PARAMS ((bfd *));
d278 2
a279 2
   : (abort (), false)                             \
   ? bfd_elf32_add_dynamic_entry (info, tag, val))
a5227 1
  char *error_message;
d5476 1
a5476 1
      if (address & 0xffff0000 == value)
d5748 1
a5748 1
      if (*namep = '\0')
a6167 1
  boolean next_relocation_for_same_address_p = false;
a6177 1
      int result;
a7627 1
    struct mips_got_info *g;
@


1.15
log
@	* libbfd.c (bfd_put_8): Make it of type `void'.
	* bfd-in2.h: Regenerated.
	* elf32-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Conditionalize
	for 32-bit hosts.
	(_bfd_mips_elf_final_link): Likewise.
@
text
@d280 2
a281 2
   ? bfd_elf64_add_dynamic_entry (info, tag, val)  \
   : (abort (), false))
@


1.14
log
@	* elf-bfd.h (_bfd_mips_elf_section_from_shdr): Constify.
	(_bfd_mips_elf_create_dynamic_sections): New function.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_finish_dynamic_sections): Likewise.
	(_bfd_mips_elf_gc_mark_hook): Likewise.
	(_bfd_mips_elf_gc_sweep_hook): Likewise.
	(_bfd_mips_elf_always_size_sections): Likewise.
	(_bfd_mips_elf_size_dynamic_sections): Likewise.
	(_bfd_mips_elf_check_relocs): Likewise.
	(_bfd_mips_elf_link_hash_table_create): Likewise.
	(_bfd_mips_elf_print_private_data): Likewise.
	(_bfd_mips_elf_link_output_symbol_hook): Likewise.
	(_bfd_mips_elf_final_link): Likewise.
	(_bfd_mips_elf_additional_program_headers): Likewise.
	(_bfd_mips_elf_modify_segment_map): Likewise.
	(_bfd_mips_elf_relocate_section): Likewise.
	* elf32-mips.c (mips_elf32_object_p): Move contents into
	_bfd_mips_elf_object_p.
	(mips_elf_additional_program_headers): Rename to
	_bfd_mips_elf_additional_program_headers.
	(mips_elf_modify_segment_map): Rename to
	_bfd_mips_elf_modify_segment_map.
	(elf_mips_abi_name): Change prototype.
	(mips_elf32_section_from_shdr): Merge into
	_bfd_mips_elf_section_from_shdr.
	(mips_elf32_section_processing): Merge into
	_bfd_mips_elf_section_processing.
	(mips_elf_final_link): Rename to _bfd_mips_elf_final_link.  Invoke
	the right back-end ELF linker.
	(mips_elf_relocate_section): Rename to
	_bfd_mips_elf_relocate_section.  Clean up.  Adjust for 64-bit code.
	(mips_elf_link_output_symbol_hook): Rename to
	_bfd_mips_elf_link_output_symbol_hook.
	(mips_elf_create_dynamic_section): Rename to
	_bfd_mips_elf_create_dynamic_section.
	(mips_elf_check_relocs): Rename to _bfd_mips_elf_check_relocs.
	Adjust for 64-bit code.  Use mips_elf_got_section.
	(mips_elf_adjust_dynamic_symbol): Rename to
	_bfd_mips_elf_adjust_dynamic_symbol.  Use
	mips_elf_allocate_dynamic_relocations.
	(mips_elf_finish_dynamic_symbol): Rename to
	_bfd_mips_elf_finish_dynamic_symbol.  Use mips_elf_got_section.
	Adjust for 64-bit code.
	(mips_elf_finish_dynamic_sections): Rename to
	_bfd_mips_elf_finish_dynamic_sections.  Adjust for 64-bit code.
	(mips_elf_always_size_sections): Rename to
	_bfd_mips_elf_always_size_sections.
	(mips_elf_add_symbol_hook): Rename to
	_bfd_mips_elf_add_symbol_hook.
	(mips_elf_next_lo16_addend): Constify.
	(mips_elf_calculate_relocation): Likewise.
	(mips_elf_obtain_contents): Likewise.
	(mips_elf_perform_relocation): Likewise.
	(mips_elf_create_dynamic_relocation): Likewise.
	(mips_elf_allocate_dynamic_relocations): New function.
	(MIPS_ELF_REL_DYN_SECTION_NAME): New macro.
	(MIPS_ELF_REL_SIZE): Likewise.
	(MIPS_ELF_DYN_SIZE): Likewise.
	(MIPS_ELF_GOT_SIZE): Likewise.
	(MIPS_ELF_SYM_SIZE): Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Likewise.
	(MIPS_ELF_GET_WORD): Likewise.
	(MIPS_ELF_PUT_WORD): Likewise.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	(STUB_LW): Conditionalize for 64-bit value.
	(elf_mips_howto_table): Add R_MIPS_HIGHER and R_MIPS_HIGHEST
	entries.
	(_bfd_mips_elf_merge_private_bfd_data): Merge e_ident[EI_CLASS].
	Check it for inconsistency.
	(_bfd_mips_elf_print_private_bfd_data): Print ABI=64 for 64-bit
	ABI.
	(_bfd_mips_elf_fake_sections): Remove duplicate handling of
	.msym.
	(mips_elf_global_got_index): Use MIPS_ELF_GOT_SIZE.
	(mips_elf_got_offset_from_index): Use misp_elf_got_section.
	(mips_elf_create_local_got_entry): Use MIPS_ELF_GOT_SIZE.
	(mips_elf_local_got_index): Likewise.
	(mips_elf_got_page): Likewise.
	(mips_elf_got_info): Likewise.
	(mips_elf_create_dynamic_relocation): Handle 32-bit/64-bit split.
	(ELF_DYNAMIC_INTERPRETER): Handle 64-bit code.
	(mips_elf_create_dynamic_sections): Use MIPS_ELF_LOG_FILE_ALIGN,
	instead of constant `2'.
	(mips_elf_create_got_section): Tidy.  Use MIPS_ELF_GOT_SIZE.
	(mips_elf_create_msym_section): Use MIPS_ELF_LOG_FILE_ALIGN.
	(mips_elf_size_dynamic_sections): Use
	MIPS_ELF_REL_DYN_SECTION_NAME, MIPS_ELF_GOT_SIZE,
	MIPS_ELF_ADD_DYNAMIC_ENTRY.  Remove #if 0'd code.
	Adjust all releveant entries in elf backend table.
	* elf64-mips.c (mips_elf64_section_from_shdr): Remove.
	(mips_elf64_section_processing): Likewise.
	Adjust elf backend entries to use _bfd_mips_elf variants now
	publicly available.
@
text
@d272 1
d277 6
d4901 7
a4907 3
  if (!(ABI_64_P (abfd) 
	? bfd_elf64_bfd_final_link (abfd, info)
	: bfd_elf32_bfd_final_link (abfd, info)))
d4909 4
@


1.13
log
@	* dwarf2.c (parse_comp_unit): Add ABBREV_LENGTH parameter.
	(_bfd_dwarf2_find_nearest_line): Add ADDR_SIZE parameter.
	* elf.c (_bfd_elf_find_nearest_line): Pass it.
	* elf32-arm.h (elf32_arm_find_nearest_line): Likewise.
	* elf32-mips.c (ABI_64_P): New macro.
	(IRIX_COMPAT): We are IRIX6-compatible if ABI_64_P.
	(_bfd_mips_elf_find_nearest_line): Adjust call to
	_bfd_dwarf2_find_nearest_line.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Update prototype.
	* libbfd.h: Regenerated.
@
text
@d6 2
a110 1
static boolean mips_elf32_object_p PARAMS ((bfd *));
a113 2
static int mips_elf_additional_program_headers PARAMS ((bfd *));
static boolean mips_elf_modify_segment_map PARAMS ((bfd *));
d116 1
a116 5
static INLINE char* elf_mips_abi_name PARAMS ((flagword));
static boolean mips_elf32_section_from_shdr
  PARAMS ((bfd *, Elf32_Internal_Shdr *, char *));
static boolean mips_elf32_section_processing
  PARAMS ((bfd *, Elf32_Internal_Shdr *));
a123 2
static boolean mips_elf_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
a135 8
static boolean mips_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static boolean mips_elf_link_output_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *));
static boolean mips_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
a139 17
static boolean mips_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static boolean mips_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static boolean mips_elf_always_size_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static boolean mips_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
d166 1
a166 1
  PARAMS ((Elf_Internal_Rela *, Elf_Internal_Rela *, bfd_vma *));
d169 2
a170 3
	   Elf_Internal_Rela *, bfd_vma, reloc_howto_type *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **,
	   bfd_vma *, const char **));
d172 1
a172 1
  PARAMS ((reloc_howto_type *, Elf_Internal_Rela *, bfd *, bfd_byte *));
d174 1
a174 1
  PARAMS ((reloc_howto_type *, Elf_Internal_Rela *, bfd_vma,
d189 1
a189 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf32_Internal_Rela *,
d191 2
d238 39
d283 5
a287 3
#define STUB_LW(abfd)					\
  (SGI_COMPAT (abfd)					\
   ? 0x8f998010			/* lw t9,0x8010(gp) */	\
d789 29
a817 4
  /* Get the higher values of a 64 bit addend.  Presumably not used in
     32 bit ELF.  */
  { R_MIPS_HIGHER },
  { R_MIPS_HIGHEST },
d1779 1
a1779 1
/* Return printable name for ABI from flagword. */
d1782 2
a1783 2
elf_mips_abi_name (flags)
     flagword flags;
d1785 8
d2154 1
a2154 12
  bfd_default_set_arch_mach (abfd, bfd_arch_mips,
			     elf_mips_mach (elf_elfheader (abfd)->e_flags));
  return true;
}

/* Set the right machine number for a 32-bit MIPS ELF file.  */

static boolean
mips_elf32_object_p (abfd)
     bfd *abfd;
{
  /* Irix 5 is broken.  Object file symbol tables are not always
d2159 3
a2161 1
  return _bfd_mips_elf_object_p (abfd);
d2370 2
d2459 5
a2463 2
  /* Compare ABI's */
  if ((new_flags & EF_MIPS_ABI) != (old_flags & EF_MIPS_ABI))
d2466 3
a2468 2
      if ((new_flags & EF_MIPS_ABI)
	  && (old_flags & EF_MIPS_ABI))
d2473 2
a2474 2
	     elf_mips_abi_name (new_flags),
	     elf_mips_abi_name (old_flags));
d2500 1
a2500 1
static boolean
d2525 1
a2525 1
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI2))
d2527 2
d2564 1
a2564 1
     const char *name;
a2647 14
  return true;
}

/* Handle a 32-bit MIPS ELF specific section.  */

static boolean
mips_elf32_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     char *name;
{
  if (! _bfd_mips_elf_section_from_shdr (abfd, hdr, name))
    return false;

d2691 12
a2702 1
	  if (intopt.kind == ODK_REGINFO)
a2740 6
  else if (strcmp (name, MIPS_ELF_MSYM_SECTION_NAME (abfd)) == 0)
    {
      hdr->sh_type = SHT_MIPS_MSYM;
      hdr->sh_entsize = 8;
      /* FIXME: Set the sh_info field.  */
    }
a2929 51
  if (hdr->bfd_section != NULL)
    {
      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);

      if (strcmp (name, ".sdata") == 0
	  || strcmp (name, ".lit8") == 0
	  || strcmp (name, ".lit4") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".sbss") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_NOBITS;
	}
      else if (strcmp (name, MIPS_ELF_SRDATA_SECTION_NAME (abfd)) == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".compact_rel") == 0)
	{
	  hdr->sh_flags = 0;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".rtproc") == 0)
	{
	  if (hdr->sh_addralign != 0 && hdr->sh_entsize == 0)
	    {
	      unsigned int adjust;

	      adjust = hdr->sh_size % hdr->sh_addralign;
	      if (adjust != 0)
		hdr->sh_size += hdr->sh_addralign - adjust;
	    }
	}
    }

  return true;
}

/* Work over a section just before writing it out.  We update the GP
   value in the SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS sections based
   on the value we are using.  */

static boolean
mips_elf32_section_processing (abfd, hdr)
     bfd *abfd;
     Elf32_Internal_Shdr *hdr;
{
d2970 16
a2985 1
	  if (intopt.kind == ODK_REGINFO)
d3004 40
a3043 1
  return _bfd_mips_elf_section_processing (abfd, hdr);
d3045 1
d3154 2
a3155 2
static int
mips_elf_additional_program_headers (abfd)
d3186 2
a3187 2
static boolean
mips_elf_modify_segment_map (abfd)
d3777 2
a3778 2
static struct bfd_link_hash_table *
mips_elf_link_hash_table_create (abfd)
d3813 2
a3814 2
static boolean
mips_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
d4291 2
a4292 2
static boolean
mips_elf_final_link (abfd, info)
d4894 4
a4897 2
  if (! bfd_elf32_bfd_final_link (abfd, info))
    return false;
d5197 2
a5198 1
  index = (h->dynindx - g->global_gotsym->dynindx + g->local_gotno) * 4;
d5217 1
a5217 1
  sgot = bfd_get_section_by_name (dynobj, ".got");
d5348 4
a5351 2
  bfd_put_32 (abfd, value, sgot->contents + 4 * g->assigned_gotno);
  return 4 * g->assigned_gotno++;
d5371 4
a5374 3
  for (entry = sgot->contents + 4 * MIPS_RESERVED_GOTNO; 
       entry != sgot->contents + 4 * g->assigned_gotno;
       entry += 4)
d5376 1
a5376 2
      bfd_vma address = bfd_get_32 (abfd, entry);

d5407 3
a5409 2
  last_entry = sgot->contents + 4 * g->assigned_gotno;
  for (entry = sgot->contents + 4 * MIPS_RESERVED_GOTNO; 
d5411 1
a5411 1
       entry += 4)
d5413 2
a5414 1
      address = bfd_get_32 (abfd, entry);
d5430 1
a5430 1
      address = bfd_get_32 (abfd, entry);
d5457 3
a5459 2
  last_entry = sgot->contents + 4 * g->assigned_gotno;
  for (entry = sgot->contents + 4 * MIPS_RESERVED_GOTNO; 
d5461 1
a5461 1
       entry += 4)
d5463 1
a5463 1
      address = bfd_get_32 (abfd, entry);
d5467 1
a5467 1
	  index = 4 * (entry - sgot->contents);
d5485 2
a5486 2
     Elf_Internal_Rela *relocation;
     Elf_Internal_Rela *relend;
d5520 1
a5520 1
     Elf_Internal_Rela *rel;
d5533 3
a5535 1
  sreloc = bfd_get_section_by_name (dynobj, ".rel.dyn");
d5570 12
a5581 4
  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
			    (((Elf32_External_Rel *)
			      sreloc->contents)
			     + sreloc->reloc_count));
a5640 1
			       relend,
d5649 1
a5649 1
     Elf_Internal_Rela *relocation;
a5651 1
     Elf_Internal_Rela *relend;
d5678 2
a5679 1
  unsigned long r_symndx;
d5681 1
d5685 1
d5687 2
d6037 1
a6037 1
     Elf_Internal_Rela *relocation;
d6088 1
a6088 1
     Elf_Internal_Rela *relocation;
d6140 3
a6142 3
static boolean
mips_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
d6152 2
a6153 9
  Elf_Internal_Shdr *symtab_hdr;
  size_t locsymcount;
  size_t extsymoff;
  asection *sgot, *sreloc, *scpt;
  bfd *dynobj;
  bfd_vma gp;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  struct mips_got_info *g;
d6159 1
d6161 2
a6162 25
  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  sgot = NULL;
  sreloc = NULL;
  if (dynobj == NULL || ! SGI_COMPAT (output_bfd))
    scpt = NULL;
  else
    scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
  g = NULL;

  if (elf_bad_symtab (input_bfd))
    {
      locsymcount = symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
      extsymoff = 0;
    }
  else
    {
      locsymcount = symtab_hdr->sh_info;
      extsymoff = symtab_hdr->sh_info;
    }

  gp = _bfd_get_gp_value (output_bfd);
  relend = relocs + input_section->reloc_count;
  
d6184 3
a6186 1
	  if (rel - relocs >= rel_hdr->sh_size / rel_hdr->sh_entsize)
d6188 1
a6188 1
	  if (rel_hdr->sh_entsize == sizeof (Elf32_External_Rel))
d6236 3
a6238 1
      if (rel + 1 < relend && rel->r_offset == (rel + 1)->r_offset)
a6250 1
					     relend,
d6309 2
a6310 2
static boolean
mips_elf_link_output_symbol_hook (abfd, info, name, sym, input_sec)
d6336 4
a6339 2
#define ELF_DYNAMIC_INTERPRETER(abfd) \
   (ABI_N32_P (abfd) ? "/usr/lib32/libc.so.1" : "/usr/lib/libc.so.1")
d6343 2
a6344 2
static boolean
mips_elf_create_dynamic_sections (abfd, info)
d6382 2
a6383 1
	  || ! bfd_set_section_alignment (abfd, s, 2))
d6394 2
a6395 1
	  || ! bfd_set_section_alignment (abfd, s, 2))
d6506 2
a6507 1
	  || ! bfd_set_section_alignment (abfd, s, 2))
d6529 1
a6529 1
  if (bfd_get_section_by_name (abfd, ".got") != NULL)
d6560 1
a6560 1
  s->_raw_size = MIPS_RESERVED_GOTNO * 4;
d6603 2
a6604 1
	  || !bfd_set_section_alignment (abfd, s, 2))
d6611 21
d6635 2
a6636 2
static boolean
mips_elf_check_relocs (abfd, info, sec, relocs)
d6652 1
d6737 1
a6737 1
		symcount = symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
d6827 1
a6827 1
      sgot = bfd_get_section_by_name (dynobj, ".got");
d6839 3
a6841 3

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
d6957 1
a6957 1
		  const char *name = ".rel.dyn";
d6977 5
a6981 13
		{
		  /* When creating a shared object, we must copy these
		     reloc types into the output file as R_MIPS_REL32
		     relocs.  We make room for this reloc in the
		     .rel.dyn reloc section */
		  if (sreloc->_raw_size == 0)
		    {
		      /* Add a null element. */
		      sreloc->_raw_size += sizeof (Elf32_External_Rel);
		      ++sreloc->reloc_count;
		    }
		  sreloc->_raw_size += sizeof (Elf32_External_Rel);
		}
d7000 1
a7000 1
	  if (SGI_COMPAT (abfd))
a7002 1

d7009 1
a7009 1
	  if (SGI_COMPAT (abfd))
d7057 2
a7058 2
static asection *
mips_elf_gc_mark_hook (abfd, info, rel, h, sym)
d7106 2
a7107 2
static boolean
mips_elf_gc_sweep_hook (abfd, info, sec, relocs)
d7155 2
a7156 2
static boolean
mips_elf_adjust_dynamic_symbol (info, h)
d7184 1
a7184 12
    {
      s = bfd_get_section_by_name (dynobj, ".rel.dyn");
      BFD_ASSERT (s != NULL);

      if (s->_raw_size == 0)
	{
	  /* Make room for a null element. */
	  s->_raw_size += sizeof (Elf32_External_Rel);
	  ++s->reloc_count;
	}
      s->_raw_size += hmips->mips_32_relocs * sizeof (Elf32_External_Rel);
    }
d7244 2
a7245 2
static boolean
mips_elf_always_size_sections (output_bfd, info)
d7320 2
a7321 2
static boolean
mips_elf_size_dynamic_sections (output_bfd, info)
d7397 2
a7398 1
		  || strcmp (outname, ".rel.dyn") == 0)
d7403 2
a7404 1
	      if (strcmp (name, ".rel.dyn") != 0)
d7441 1
a7441 1
 	  s->_raw_size += local_gotno * 4;
d7452 1
a7452 1
	  s->_raw_size += i * 4;
d7510 1
a7510 1
	      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_RLD_MAP, 0))
d7514 1
a7514 1
	    if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
d7520 1
a7520 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
d7524 1
a7524 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0))
d7527 2
a7528 1
      if (bfd_get_section_by_name (dynobj, ".rel.dyn"))
d7530 1
a7530 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_REL, 0))
d7533 1
a7533 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELSZ, 0))
d7536 1
a7536 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELENT, 0))
d7540 1
a7540 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_CONFLICTNO, 0))
d7543 1
a7543 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_LIBLISTNO, 0))
d7548 1
a7548 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_CONFLICT, 0))
d7554 1
a7554 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_LIBLIST, 0))
d7558 1
a7558 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_RLD_VERSION, 0))
d7561 1
a7561 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_FLAGS, 0))
d7566 1
a7566 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_TIME_STAMP, 0))
d7571 1
a7571 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_ICHECKSUM, 0))
d7576 1
a7576 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_IVERSION, 0))
d7580 1
a7580 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_BASE_ADDRESS, 0))
d7583 1
a7583 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_LOCAL_GOTNO, 0))
d7586 1
a7586 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_SYMTABNO, 0))
d7589 1
a7589 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_UNREFEXTNO, 0))
d7592 1
a7592 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_GOTSYM, 0))
d7596 1
a7596 1
	  && ! bfd_elf32_add_dynamic_entry (info, DT_MIPS_HIPAGENO, 0))
d7602 1
a7602 1
	  && !bfd_elf32_add_dynamic_entry (info, DT_MIPS_OPTIONS, 0))
d7607 1
a7607 1
	  && !bfd_elf32_add_dynamic_entry (info, DT_MIPS_MSYM, 0))
d7623 5
a7627 7
#if 0
	/* We no longer try to restrict the set of sections which get
           dynamic symbol table entries, since it fails if we have
           other random sections which need dynamic relocations.  */
	const char * const *namep;
	bfd_size_type strindex;
	struct bfd_strtab_hash *dynstr;
d7629 1
a7629 1
	if (SGI_COMPAT (output_bfd))
d7631 3
a7633 39
	    c = SIZEOF_MIPS_DYNSYM_SECNAMES - 1;
	    elf_link_hash_traverse (elf_hash_table (info),
				    mips_elf_adjust_dynindx,
				    (PTR) &c);
	    elf_hash_table (info)->dynsymcount += c;

	    dynstr = elf_hash_table (info)->dynstr;
	    BFD_ASSERT (dynstr != NULL);

	    for (i = 1, namep = mips_elf_dynsym_sec_names;
		 *namep != NULL;
		 i++, namep++)
	      {
		s = bfd_get_section_by_name (output_bfd, *namep);
		if (s != NULL)
		  elf_section_data (s)->dynindx = i;

		strindex = _bfd_stringtab_add (dynstr, *namep, true, false);
		if (strindex == (bfd_size_type) -1)
		  return false;

		mips_elf_hash_table (info)->dynsym_sec_strindex[i] = strindex;
	      }
	  }
	else
#endif /* 0 */
	  {
	    c = bfd_count_sections (output_bfd);
	    elf_link_hash_traverse (elf_hash_table (info),
				    _bfd_elf_link_adjust_dynindx,
				    (PTR) &c);
	    elf_hash_table (info)->dynsymcount += c;

	    for (i = 1, s = output_bfd->sections; s != NULL; s = s->next, i++)
	      {
		elf_section_data (s)->dynindx = i;
		/* These symbols will have no names, so we don't need to
		   fiddle with dynstr_index.  */
	      }
d7695 2
a7696 2
static boolean
mips_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
d7759 1
a7759 1
  sgot = bfd_get_section_by_name (dynobj, ".got");
d7783 1
a7783 1
      bfd_put_32 (output_bfd, value, sgot->contents + offset);
d7883 2
a7884 2
static boolean
mips_elf_finish_dynamic_sections (output_bfd, info)
d7897 1
a7897 1
  sgot = bfd_get_section_by_name (dynobj, ".got");
d7909 1
a7909 1
      Elf32_External_Dyn *dyncon, *dynconend;
d7914 3
a7916 3
      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
      for (; dyncon < dynconend; dyncon++)
d7922 1
d7924 5
a7928 1
	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
a7931 3
	    default:
	      break;

d7933 3
a7935 1
	      s = bfd_get_section_by_name (dynobj, ".rel.dyn");
d7937 1
a7937 2
	      dyn.d_un.d_val = sizeof (Elf32_External_Rel);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a7943 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a7957 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a7961 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a7965 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a7986 2

	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a7990 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d7995 1
d8000 1
a8006 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8010 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d8015 1
a8015 1
	      elemsize = sizeof (Elf32_External_Sym);
a8022 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8029 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8033 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8037 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8041 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
a8047 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d8054 4
a8057 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d8060 4
d8072 3
a8074 2
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0x80000000, sgot->contents + 4);
d8078 2
a8079 1
    elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
d8096 1
a8096 57
#if 0
	const char *name;
	const char * const * namep = mips_elf_dynsym_sec_names;
	unsigned int i;
	bfd_vma last;
	long dindx;

	/* We no longer try to restrict the set of sections which get
           dynamic symbol table entries, since it fails if we have
           other random sections which need dynamic relocations.  */
	if (SGI_COMPAT (output_bfd))
	  {
	    sym.st_size = 0;
	    sym.st_name = 0;
	    sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_NOTYPE);
	    sym.st_other = 0;

	    i = 0;
	    last = 0;
	    dindx = 0;
	    while ((name = *namep++) != NULL)
	      {
		s = bfd_get_section_by_name (output_bfd, name);
		if (s != NULL)
		  {
		    sym.st_value = s->vma;
		    dindx = elf_section_data (s)->dynindx;
		    last = s->vma + s->_raw_size;
		  }
		else
		  {
		    sym.st_value = last;
		    dindx++;
		  }

		sym.st_shndx = (i < MIPS_TEXT_DYNSYM_SECNO
				? SHN_MIPS_TEXT
				: SHN_MIPS_DATA);
		++i;
		sym.st_name =
		  mips_elf_hash_table (info)->dynsym_sec_strindex[dindx];

		bfd_elf32_swap_symbol_out (output_bfd, &sym,
					   (((Elf32_External_Sym *)
					     sdynsym->contents)
					    + dindx));
	      }

	    /* Set the sh_info field of the output .dynsym section to
	       the index of the first global symbol.  */
	    elf_section_data (sdynsym->output_section)->this_hdr.sh_info =
	      SIZEOF_MIPS_DYNSYM_SECNAMES;
	  }
	else
#endif /* 0 */
	  {
	    Elf32_Internal_Msym msym;
d8098 4
a8101 4
	    sym.st_size = 0;
	    sym.st_name = 0;
	    sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	    sym.st_other = 0;
d8103 2
a8104 2
	    msym.ms_hash_value = 0;
	    msym.ms_info = ELF32_MS_INFO (0, 1);
d8106 4
a8109 4
	    for (s = output_bfd->sections; s != NULL; s = s->next)
	      {
		int indx;
		long dynindx;
d8111 1
a8111 1
		sym.st_value = s->vma;
d8113 3
a8115 3
		indx = elf_section_data (s)->this_idx;
		BFD_ASSERT (indx > 0);
		sym.st_shndx = indx;
d8117 1
a8117 1
		dynindx  = elf_section_data (s)->dynindx;
d8119 4
a8122 4
		bfd_elf32_swap_symbol_out 
		  (output_bfd, &sym,
		   (((Elf32_External_Sym *) sdynsym->contents)
		    + dynindx));
d8124 6
a8129 6
		if (smsym)
		  bfd_mips_elf_swap_msym_out 
		    (output_bfd, &msym,
		     (((Elf32_External_Msym *) smsym->contents)
		      + dynindx));
	      }
d8131 1
a8131 1
	    /* Set the sh_info field of the output .dynsym section to
d8133 2
a8134 3
	    elf_section_data (sdynsym->output_section)->this_hdr.sh_info =
	      bfd_count_sections (output_bfd) + 1;
	  }
d8170 2
a8171 1
    s = bfd_get_section_by_name (dynobj, ".rel.dyn");
d8173 1
a8173 1
      memset (s->contents, 0, sizeof (Elf32_External_Rel));
d8424 2
a8425 2
#define elf_backend_object_p		mips_elf32_object_p
#define elf_backend_section_from_shdr	mips_elf32_section_from_shdr
d8429 1
a8429 1
#define elf_backend_section_processing	mips_elf32_section_processing
d8432 2
a8433 2
					mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	mips_elf_modify_segment_map
d8437 22
d8465 2
a8466 2
					mips_elf_link_hash_table_create
#define bfd_elf32_bfd_final_link	mips_elf_final_link
a8473 23
#define elf_backend_add_symbol_hook	mips_elf_add_symbol_hook
#define elf_backend_create_dynamic_sections \
					mips_elf_create_dynamic_sections
#define elf_backend_check_relocs	mips_elf_check_relocs
#define elf_backend_adjust_dynamic_symbol \
					mips_elf_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
					mips_elf_always_size_sections
#define elf_backend_size_dynamic_sections \
					mips_elf_size_dynamic_sections
#define elf_backend_relocate_section	mips_elf_relocate_section
#define elf_backend_link_output_symbol_hook \
					mips_elf_link_output_symbol_hook
#define elf_backend_finish_dynamic_symbol \
					mips_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					mips_elf_finish_dynamic_sections
#define elf_backend_gc_mark_hook	mips_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	mips_elf_gc_sweep_hook

#define elf_backend_got_header_size	(4*MIPS_RESERVED_GOTNO)
#define elf_backend_plt_header_size	0

@


1.12
log
@	* elf-bfd.h (bfd_elf_section_data): Add rel_count and rel_count2
	fields.
	(_bfd_elf_init_reloc_shdr): New function.
	* elf.c (_bfd_elf_new_section_hook): Use bfd_zalloc, rather than
	bfd_alloc followed by memset.
	(_bfd_elf_init_reloc_shdr): New function, split out from ...
	(elf_fake_sections): Here.
	(assign_section_numbers): Assign section numbers for the second
	relocation section, if required.
	* elflink.h (elf_link_output_relocs): New function.
	(elf_link_size_reloc_section): Likewise.
	(elf_bfd_final_link): Use elf_link_size_reloc_section.
	(elf_link_input_bfd): Use elf_link_output_relocs.
	* elf32-mips.c (_bfd_mips_elf_fake_sections): Use
	_bfd_elf_init_reloc_shdr to initialize rel_hdr2.
@
text
@d238 5
d248 1
a248 1
  (ABI_N32_P (abfd) ? ict_irix6 : ict_irix5)
d3525 2
a3526 1
				     line_ptr))
@


1.11
log
@	* elf32-mips.c (mips_elf_got_info): Move declaration before
	prototypes.  Change global_gotsym to be a pointer to a hash entry,
	rather than a number index.
	(mips_elf_link_hash_entry): Move declaration before prototypes.
	(mips_elf_irix6_finish_dynamic_symbol): New function.
	(mips_elf_sign_extend): Likewise.
	(mips_elf_high): Likewise.
	(mips_elf_higher): Likewise.
	(mips_elf_highest): Likewise.
	(mips_elf_global_got_index): Likewise.
	(mips_elf_local_got_index): Likewise.
	(mips_elf_got_offset_from_index): Likeiwse.
	(mips_elf_record_global_got_symbol): Likewise.
	(mips_elf_got_page): Likewise.
	(mips_elf_next_lo16_addend): Likewise.
	(mips_elf_calculate_relocation): Likewise.
	(mips_elf_obtain_contents): Likewise.
	(mips_elf_perform_relocation): Likewise.
	(mips_elf_assign_gp): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_sort_hash_table): Likewise.
	(mips_elf_got_section): Likewise.
	(mips_elf_got_info): Likewise.
	(mips_elf_create_local_got_entry): Likewise.
	(mips_elf_got16_entry): Likewise.
	(mips_elf_create_dynamic_relocation): Likewise.
	(elf_mips_howto_table): Add description of R_MIPS_SCN_DISP.
	(mips_elf_final_gp): Use mips_elf_assign_gp.
	(_bfd_mips_elf_symbol_processing): Don't move SHN_COMMON symbols
	into SHN_SCOMMON automatically on IRIX6.
	(mips_elf_add_symbol_hook): Likewise.
	(mips_elf_relocate_section): Rewrite, using
	mips_elf_calculate_relocation and mips_elf_perform_relocation.
	(mips_elf_create_dynamic_section): Use MIPS_ELF_STUB_SECTION_NAME.
	Don't deal with .rld_map on IRIX6.
	(mips_elf_create_got_section): Adjust use of global_gotsym.  Set
	section flags appropriately for .got.
	(mips_elf_check_relocs): Handle IRIX6 relocations making use of
	the got.  Call mips_elf_record_global_got_symbol and allocate
	local got space appropriately.
	(mips_elf_size_dynamic_sections): Use bfd_byte *, not unsigned
	char *.  Rework calculation of GOT size.  Sort dynamic symbol
	table entries so entries that do not require GOT entries appear at
	the beginning.  Don't use DT_MIPS_HIPAGENO on IRIX6.  Remove dead
	code dealing with DT_INIT and DT_FINI.  Remove fiddling with
	global_gotsym.
	(mips_elf_finish_dynamic_symbol): Adjust creation of global GOT
	entries.
	(mips_elf_finish_dynamic_symbol): Use
	mips_elf_irix6_finish_dynamic_symbol.
	(mips_elf_finish_dynamic_sections): Correct off-by-one error
	setting DT_MIPS_UNREFEXTNO.  Adjust setting of DT_MIPS_GOTSYM for
	change to global_gotsym.  Set DT_MIPS_OPTIONS on IRIX6.
@
text
@d2791 17
@


1.10
log
@	* elf32-mips.c (mips_elf_final_link): Don't set CPIC when doing a
	relocateable link.  From Ralf Baechle <ralf@@uni-koblenz.de>.
@
text
@d44 48
d179 45
a249 13
/* This structure is used to hold .got information when linking.  It
   is stored in the tdata field of the bfd_elf_section_data structure.  */

struct mips_got_info
{
  /* The symbol index of the first global .got symbol.  */
  unsigned long global_gotsym;
  /* The number of local .got entries.  */
  unsigned int local_gotno;
  /* The number of local .got entries we have used.  */
  unsigned int assigned_gotno;
};

a593 1
  /* FIXME: This is not handled correctly.  */
a679 1
  /* FIXME: Not handled correctly.  */
a694 1
  /* FIXME: Not handled correctly.  */
a709 1
  /* FIXME: Not handled correctly.  */
a724 1
  /* FIXME: Not handled correctly.  */
a739 1
  /* FIXME: Not handled correctly.  */
a754 1
  /* FIXME: Not handled correctly.  */
a779 1
  /* FIXME: Not handled correctly.  */
a794 1
  /* FIXME: Not handled correctly.  */
d809 15
a823 1
  { R_MIPS_SCN_DISP },
d1193 51
d1276 1
a1276 1
      else
d1278 3
a1280 34
	  unsigned int count;
	  asymbol **sym;
	  unsigned int i;

	  count = bfd_get_symcount (output_bfd);
	  sym = bfd_get_outsymbols (output_bfd);

	  if (sym == (asymbol **) NULL)
	    i = count;
	  else
	    {
	      for (i = 0; i < count; i++, sym++)
		{
		  register CONST char *name;

		  name = bfd_asymbol_name (*sym);
		  if (*name == '_' && strcmp (name, "_gp") == 0)
		    {
		      *pgp = bfd_asymbol_value (*sym);
		      _bfd_set_gp_value (output_bfd, *pgp);
		      break;
		    }
		}
	    }

	  if (i >= count)
	    {
	      /* Only get the error once.  */
	      *pgp = 4;
	      _bfd_set_gp_value (output_bfd, *pgp);
	      *error_message =
		(char *) _("GP relative relocation when _gp not defined");
	      return bfd_reloc_dangerous;
	    }
d3053 3
a3055 2
	 treated as SHN_MIPS_SCOMMON symbols.  */
      if (asym->value > elf_gp_size (abfd))
a3626 34
/* The MIPS ELF linker needs additional information for each symbol in
   the global hash table.  */

struct mips_elf_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* External symbol information.  */
  EXTR esym;

  /* Number of MIPS_32 or MIPS_REL32 relocs against this symbol.  */
  unsigned int mips_32_relocs;

  /* The index of the first dynamic relocation (in the .rel.dyn
     section) against this symbol.  */
  unsigned int min_dyn_reloc_index;

  /* If there is a stub that 32 bit functions should use to call this
     16 bit function, this points to the section containing the stub.  */
  asection *fn_stub;

  /* Whether we need the fn_stub; this is set if this symbol appears
     in any relocs other than a 16 bit call.  */
  boolean need_fn_stub;

  /* If there is a stub that 16 bit functions should use to call this
     32 bit function, this points to the section containing the stub.  */
  asection *call_stub;

  /* This is like the call_stub field, but it is used if the function
     being called returns a floating point value.  */
  asection *call_fp_stub;
};

d3777 2
a3778 1
      if (sym->st_size > elf_gp_size (abfd))
d5012 1
a5012 1
/* Relocate a MIPS ELF section.  */
d5014 3
a5016 11
static boolean
mips_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d5018 2
a5019 9
  Elf_Internal_Shdr *symtab_hdr;
  size_t locsymcount;
  size_t extsymoff;
  asection *sgot, *sreloc, *scpt;
  bfd *dynobj;
  bfd_vma gp;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  struct mips_got_info *g;
d5021 3
a5023 2
  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
d5025 7
a5031 7
  sgot = NULL;
  sreloc = NULL;
  if (dynobj == NULL || ! SGI_COMPAT (output_bfd))
    scpt = NULL;
  else
    scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
  g = NULL;
d5033 5
a5037 10
  if (elf_bad_symtab (input_bfd))
    {
      locsymcount = symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
      extsymoff = 0;
    }
  else
    {
      locsymcount = symtab_hdr->sh_info;
      extsymoff = symtab_hdr->sh_info;
    }
d5039 4
a5042 1
  gp = _bfd_get_gp_value (output_bfd);
d5044 1
a5044 14
  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      bfd_vma addend;
      struct elf_link_hash_entry *h;
      asection *sec;
      Elf_Internal_Sym *sym;
      struct mips_elf_link_hash_entry *mh;
      int other;
      bfd_reloc_status_type r;
d5046 11
a5056 17
      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type == R_MIPS_GNU_VTINHERIT
	  || r_type == R_MIPS_GNU_VTENTRY)
	continue;
      if ((r_type < 0 || r_type >= (int) R_MIPS_max)
	  && r_type != R_MIPS16_26
	  && r_type != R_MIPS16_GPREL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
      if (r_type == R_MIPS16_26)
	howto = &elf_mips16_jump_howto;
      else if (r_type == R_MIPS16_GPREL)
	howto = &elf_mips16_gprel_howto;
      else
	howto = elf_mips_howto_table + r_type;
d5058 3
a5060 18
      if (dynobj != NULL
	  && (r_type == R_MIPS_CALL16
	      || r_type == R_MIPS_GOT16
	      || r_type == R_MIPS_CALL_HI16
	      || r_type == R_MIPS_CALL_LO16
	      || r_type == R_MIPS_GOT_HI16
	      || r_type == R_MIPS_GOT_LO16))
	{
	  /* We need the .got section.  */
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	      BFD_ASSERT (elf_section_data (sgot) != NULL);
	      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	      BFD_ASSERT (g != NULL);
	    }
	}
d5062 6
a5067 1
      r_symndx = ELF32_R_SYM (rel->r_info);
d5069 10
a5078 20
      /* Mix in the change in GP address for a GP relative reloc.  */
      if (r_type != R_MIPS_GPREL16
	  && r_type != R_MIPS_LITERAL
	  && r_type != R_MIPS_GPREL32
	  && r_type != R_MIPS16_GPREL)
	addend = 0;
      else
	{
	  if (gp == 0)
	    {
	      if (! ((*info->callbacks->reloc_dangerous)
		     (info,
		      _("GP relative relocation when GP not defined"),
		      input_bfd, input_section,
		      rel->r_offset)))
		return false;
	      /* Only give the error once per link.  */
	      gp = 4;
	      _bfd_set_gp_value (output_bfd, gp);
	    }
d5080 1
a5080 30
	  if (r_symndx < extsymoff
	      || (elf_bad_symtab (input_bfd)
		  && local_sections[r_symndx] != NULL))
	    {
	      /* This is a relocation against a section.  The current
		 addend in the instruction is the difference between
		 INPUT_SECTION->vma and the GP value of INPUT_BFD.  We
		 must change this to be the difference between the
		 final definition (which will end up in RELOCATION)
		 and the GP value of OUTPUT_BFD (which is in GP).  */
	      addend = elf_gp (input_bfd) - gp;
	    }
	  else if (! info->relocateable)
	    {
	      /* We are doing a final link.  The current addend in the
		 instruction is simply the desired offset into the
		 symbol (normally zero).  We want the instruction to
		 hold the difference between the final definition of
		 the symbol (which will end up in RELOCATION) and the
		 GP value of OUTPUT_BFD (which is in GP).  */
	      addend = - gp;
	    }
	  else
	    {
	      /* We are generating relocateable output, and we aren't
		 going to define this symbol, so we just leave the
		 instruction alone.  */
	      addend = 0;
	    }
	}
d5082 6
a5087 21
      h = NULL;
      sym = NULL;
      sec = NULL;
      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx >= locsymcount
	      || (elf_bad_symtab (input_bfd)
		  && local_sections[r_symndx] == NULL))
	    r = bfd_reloc_ok;
	  else
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
		r = bfd_reloc_ok;
	      else
		{
		  sec = local_sections[r_symndx];
d5089 1
a5089 19
		  /* It would be logical to add sym->st_value here,
		     but Irix 5 sometimes generates a garbage symbol
		     value.  */
		  addend += sec->output_offset;

		  /* If this is HI16 or GOT16 with an associated LO16,
		     adjust the addend accordingly.  Otherwise, just
		     relocate.  */
		  if (r_type == R_MIPS_64 && bfd_big_endian (input_bfd))
		    r = _bfd_relocate_contents (howto, input_bfd,
						addend,
						contents + rel->r_offset + 4);
		  else if (r_type != R_MIPS_HI16 && r_type != R_MIPS_GOT16)
		    r = _bfd_relocate_contents (howto, input_bfd,
						addend,
						contents + rel->r_offset);
		  else
		    {
		      Elf_Internal_Rela *lorel;
d5091 690
a5780 29
		      /* As a GNU extension, permit an arbitrary
			 number of R_MIPS_HI16 relocs before the
			 R_MIPS_LO16 reloc.  This permits gcc to emit
			 the HI and LO relocs itself.  */
		      if (r_type == R_MIPS_GOT16)
			lorel = rel + 1;
		      else
			{
			  for (lorel = rel + 1;
			       (lorel < relend
				&& (ELF32_R_TYPE (lorel->r_info)
				    == R_MIPS_HI16));
			       lorel++)
			    ;
			}
		      if (lorel < relend
			  && ELF32_R_TYPE (lorel->r_info) == R_MIPS_LO16)
			{
			  mips_elf_relocate_hi16 (input_bfd, rel, lorel,
						  contents, addend);
			  r = bfd_reloc_ok;
			}
		      else
			r = _bfd_relocate_contents (howto, input_bfd,
						    addend,
						    contents + rel->r_offset);
		    }
		}
	    }
d5784 2
a5785 27
	  bfd_vma relocation;
	  boolean local;
	  boolean undefined_error;

	  /* This is a final link.  */
	  undefined_error = false;
	  sym = NULL;
	  if (r_symndx < extsymoff
	      || (elf_bad_symtab (input_bfd)
		  && local_sections[r_symndx] != NULL))
	    {
	      local = true;
	      sym = local_syms + r_symndx;
	      sec = local_sections[r_symndx];
	      relocation = (sec->output_section->vma
			    + sec->output_offset);

	      /* It would be logical to always add sym->st_value here,
		 but Irix 5 sometimes generates a garbage symbol
		 value.  */
	      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
		relocation += sym->st_value;

	      /* mips16 text labels should be treated as odd.  */
	      if (sym->st_other == STO_MIPS16)
		++relocation;
	    }
d5787 147
a5933 2
	    {
	      long indx;
d5935 5
a5939 73
	      local = false;
	      indx = r_symndx - extsymoff;
	      h = elf_sym_hashes (input_bfd)[indx];
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	      if (strcmp (h->root.root.string, "_gp_disp") == 0)
		{
		  if (gp == 0)
		    {
		      if (! ((*info->callbacks->reloc_dangerous)
			     (info,
			      _("_gp_disp used when GP not defined"),
			      input_bfd, input_section,
			      rel->r_offset)))
			return false;
		      /* Only give the error once per link.  */
		      gp = 4;
		      _bfd_set_gp_value (output_bfd, gp);
		      relocation = 0;
		    }
		  else
		    {
		      sec = input_section;
		      if (sec->output_section != NULL)
			relocation = (gp
				      - (rel->r_offset
					 + sec->output_section->vma
					 + sec->output_offset));
		      else
			relocation = gp - rel->r_offset;
		      if (r_type == R_MIPS_LO16)
			relocation += 4;
		    }
		}
	      else if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		{
		  sec = h->root.u.def.section;
		  if (sec->output_section == NULL)
		    relocation = 0;
		  else
		    relocation = (h->root.u.def.value
				  + sec->output_section->vma
				  + sec->output_offset);
		}
	      else if (h->root.type == bfd_link_hash_undefweak)
		relocation = 0;
	      else if (info->shared && !info->symbolic && !info->no_undefined)
		relocation = 0;
	      else if (strcmp (h->root.root.string, "_DYNAMIC_LINK") == 0)
		{
		  /* If this is a dynamic link, we should have created
                     a _DYNAMIC_LINK symbol in
                     mips_elf_create_dynamic_sections.  Otherwise, we
                     should define the symbol with a value of 0.
                     FIXME: It should probably get into the symbol
                     table somehow as well.  */
		  BFD_ASSERT (! info->shared);
		  BFD_ASSERT (bfd_get_section_by_name (output_bfd,
						       ".dynamic") == NULL);
		  relocation = 0;
		}
	      else
		{
		  if (! ((*info->callbacks->undefined_symbol)
			 (info, h->root.root.string, input_bfd,
			  input_section, rel->r_offset)))
		    return false;
		  undefined_error = true;
		  relocation = 0;
		}
	    }
d5941 4
a5944 7
	  mh = (struct mips_elf_link_hash_entry *) h;
	  if (h != NULL)
	    other = h->other;
	  else if (sym != NULL)
	    other = sym->st_other;
	  else
	    other = 0;
d5946 4
a5949 27
	  /* If this function has an fn_stub, then it is a mips16
	     function which needs a stub if it is called by a 32 bit
	     function.  If this reloc is anything other than a 16 bit
	     call, redirect the reloc to the stub.  We don't redirect
	     relocs from other stub functions.  */
	  if (r_type != R_MIPS16_26
	      && ((mh != NULL
		   && mh->fn_stub != NULL)
		  || (mh == NULL
		      && elf_tdata (input_bfd)->local_stubs != NULL
		      && elf_tdata (input_bfd)->local_stubs[r_symndx] != NULL))
	      && strncmp (bfd_get_section_name (input_bfd, input_section),
			  FN_STUB, sizeof FN_STUB - 1) != 0
	      && strncmp (bfd_get_section_name (input_bfd, input_section),
			  CALL_STUB, sizeof CALL_STUB - 1) != 0
	      && strncmp (bfd_get_section_name (input_bfd, input_section),
			  CALL_FP_STUB, sizeof CALL_FP_STUB - 1) != 0)
	    {
	      if (mh != NULL)
		{
		  BFD_ASSERT (mh->need_fn_stub);
		  relocation = (mh->fn_stub->output_section->vma
				+ mh->fn_stub->output_offset);
		}
	      else
		{
		  asection *fn_stub;
d5951 1
a5951 4
		  fn_stub = elf_tdata (input_bfd)->local_stubs[r_symndx];
		  relocation = (fn_stub->output_section->vma
				+ fn_stub->output_offset);
		}
d5953 9
a5961 3
	      /* RELOCATION now points to 32 bit code.  */
	      other = 0;
	    }
d5963 5
a5967 17
	  /* If this function has a call_stub, then it is called by a
             mips16 function; the call needs to go through a stub if
             this function is a 32 bit function.  If this reloc is a
             16 bit call, and the symbol is not a 16 bit function,
             then redirect the reloc to the stub.  Note that we don't
             need to worry about calling the function through a
             function pointer; such calls are handled by routing
             through a special mips16 routine.  We don't have to check
             whether this call is from a stub; it can't be, because a
             stub contains 32 bit code, and hence can not have a 16
             bit reloc.  */
	  if (r_type == R_MIPS16_26
	      && mh != NULL
	      && (mh->call_stub != NULL || mh->call_fp_stub != NULL)
	      && other != STO_MIPS16)
	    {
	      asection *stub;
d5969 3
a5971 6
	      /* If both call_stub and call_fp_stub are defined, we
                 can figure out which one to use by seeing which one
                 appears in the input file.  */
	      if (mh->call_stub != NULL && mh->call_fp_stub != NULL)
		{
		  asection *o;
d5973 3
a5975 17
		  stub = NULL;
		  for (o = input_bfd->sections; o != NULL; o = o->next)
		    {
		      if (strncmp (bfd_get_section_name (input_bfd, o),
				   CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
			{
			  stub = mh->call_fp_stub;
			  break;
			}
		    }
		  if (stub == NULL)
		    stub = mh->call_stub;
		}
	      else if (mh->call_stub != NULL)
		stub = mh->call_stub;
	      else
		stub = mh->call_fp_stub;
d5977 3
a5979 3
	      BFD_ASSERT (stub->_raw_size > 0);
	      relocation = stub->output_section->vma + stub->output_offset;
	    }
d5981 7
a5987 3
	  if (r_type == R_MIPS_HI16)
	    {
	      Elf_Internal_Rela *lorel;
d5989 4
a5992 49
	      /* As a GNU extension, permit an arbitrary number of
		 R_MIPS_HI16 relocs before the R_MIPS_LO16 reloc.
		 This permits gcc to emit the HI and LO relocs itself.  */
	      for (lorel = rel + 1;
		   (lorel < relend
		    && ELF32_R_TYPE (lorel->r_info) == R_MIPS_HI16);
		   lorel++)
		;
	      if (lorel < relend
		  && ELF32_R_TYPE (lorel->r_info) == R_MIPS_LO16)
		{
		  mips_elf_relocate_hi16 (input_bfd, rel, lorel,
					  contents, relocation + addend);
		  r = bfd_reloc_ok;
		}
	      else
		r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					      contents, rel->r_offset,
					      relocation, addend);
	    }
	  else if (r_type == R_MIPS_GOT16 && local)
	    {
	      /* GOT16 must also have an associated LO16 in the local
		 case.  In this case, the addend is extracted and the
		 section in which the referenced object is determined.
		 Then the final address of the object is computed and
		 the GOT entry for the hipage (an aligned 64kb chunk)
		 is added to .got section if needed.  The offset field
		 of the GOT16-relocated instruction is replaced by the
		 index of this GOT entry for the hipage.  */
	      if ((rel + 1) < relend
		  && ELF32_R_TYPE ((rel + 1)->r_info) == R_MIPS_LO16)
		{
		  if (! mips_elf_relocate_got_local (output_bfd, input_bfd,
						     sgot, rel, rel + 1,
						     contents,
						     relocation + addend))
		    return false;
		  r = bfd_reloc_ok;
		}
	      else
		r = bfd_reloc_outofrange;
	    }
	  else if (r_type == R_MIPS_CALL16
		   || r_type == R_MIPS_GOT16
		   || r_type == R_MIPS_CALL_LO16
		   || r_type == R_MIPS_GOT_LO16)
	    {
	      bfd_vma offset;
d5994 2
a5995 19
	      /* This symbol must be registered as a global symbol
		 having the corresponding got entry.  */
	      BFD_ASSERT (h->got.offset != (bfd_vma) -1);

	      offset = (h->dynindx - g->global_gotsym + g->local_gotno) * 4;
	      BFD_ASSERT (g->local_gotno <= offset
			  && offset < sgot->_raw_size);
	      bfd_put_32 (output_bfd, relocation + addend,
			  sgot->contents + offset);
	      offset = (sgot->output_section->vma + sgot->output_offset
			+ offset - gp);
	      mips_elf_relocate_global_got (input_bfd, rel, contents,
					    offset);
	      r = bfd_reloc_ok;
	    }
	  else if (r_type == R_MIPS_CALL_HI16
		   || r_type == R_MIPS_GOT_HI16)
	    {
	      bfd_vma offset;
d5997 4
a6000 35
	      /* This must be a global symbol with a got entry.  The
                 next reloc must be the corresponding LO16 reloc.  */
	      BFD_ASSERT (h != NULL && h->got.offset != (bfd_vma) -1);
	      BFD_ASSERT ((rel + 1) < relend);
	      BFD_ASSERT ((int) ELF32_R_TYPE ((rel + 1)->r_info)
			  == (r_type == R_MIPS_CALL_HI16
			      ? (int) R_MIPS_CALL_LO16
			      : (int) R_MIPS_GOT_LO16));

	      offset = (h->dynindx - g->global_gotsym + g->local_gotno) * 4;
	      BFD_ASSERT (g->local_gotno <= offset
			  && offset < sgot->_raw_size);
	      bfd_put_32 (output_bfd, relocation + addend,
			  sgot->contents + offset);
	      offset = (sgot->output_section->vma + sgot->output_offset
			+ offset - gp);
	      mips_elf_relocate_hi16 (input_bfd, rel, rel + 1, contents,
				      offset);
	      r = bfd_reloc_ok;
	    }
	  else if (r_type == R_MIPS_REL32
		   || r_type == R_MIPS_32)
	    {
	      Elf_Internal_Rel outrel;
	      Elf32_crinfo cptrel;
	      bfd_byte *cr;

	      if ((info->shared
		   || (elf_hash_table (info)->dynamic_sections_created
		       && h != NULL
		       && ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
			   == 0)))
		  && (input_section->flags & SEC_ALLOC) != 0)
		{
		  boolean skip;
d6002 1
a6002 8
		  /* When generating a shared object, these
		     relocations are copied into the output file to be
		     resolved at run time.  */
		  if (sreloc == NULL)
		    {
		      sreloc = bfd_get_section_by_name (dynobj, ".rel.dyn");
		      BFD_ASSERT (sreloc != NULL);
		    }
d6004 10
a6013 1
		  skip = false;
d6015 2
a6016 5
		  if (elf_section_data (input_section)->stab_info == NULL)
		    outrel.r_offset = rel->r_offset;
		  else
		    {
		      bfd_vma off;
d6018 2
a6019 9
		      off = (_bfd_stab_section_offset
			     (output_bfd, &elf_hash_table (info)->stab_info,
			      input_section,
			      &elf_section_data (input_section)->stab_info,
			      rel->r_offset));
		      if (off == (bfd_vma) -1)
			skip = true;
		      outrel.r_offset = off;
		    }
d6021 2
a6022 2
		  outrel.r_offset += (input_section->output_section->vma
				      + input_section->output_offset);
d6024 6
a6029 1
		  addend = bfd_get_32 (input_bfd, contents + rel->r_offset);
d6031 3
a6033 14
		  if (skip)
		    memset (&outrel, 0, sizeof outrel);
		  else if (h != NULL
			   && (! info->symbolic
			       || (h->elf_link_hash_flags
				   & ELF_LINK_HASH_DEF_REGULAR) == 0))
		    {
		      BFD_ASSERT (h->dynindx != -1);
		      outrel.r_info = ELF32_R_INFO (h->dynindx, R_MIPS_REL32);
		      sec = input_section;
		    }
		  else
		    {
		      long indx;
d6035 3
a6037 19
		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
		      if (sec != NULL && bfd_is_abs_section (sec))
			indx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return false;
			}
		      else
			{
			  asection *osec;
d6039 3
a6041 5
			  osec = sec->output_section;
			  indx = elf_section_data (osec)->dynindx;
			  if (indx == 0)
			    abort ();
			}
d6043 7
a6049 3
		      outrel.r_info = ELF32_R_INFO (indx, R_MIPS_REL32);
		      addend += relocation;
		    }
d6051 5
a6055 2
		  if (! skip)
		    bfd_put_32 (output_bfd, addend, contents + rel->r_offset);
d6057 1
a6057 5
		  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
					     (((Elf32_External_Rel *)
					       sreloc->contents)
					      + sreloc->reloc_count));
		  ++sreloc->reloc_count;
d6059 26
a6084 4
		  if (! skip && SGI_COMPAT (output_bfd))
		    {
		      if (scpt == NULL)
			continue;
d6086 2
a6087 19
		      /* Make an entry of compact relocation info.  */
		      mips_elf_set_cr_format (cptrel, CRF_MIPS_LONG);
		      cptrel.vaddr = (rel->r_offset
				      + input_section->output_section->vma
				      + input_section->output_offset);
		      if (r_type == R_MIPS_REL32)
			mips_elf_set_cr_type (cptrel, CRT_MIPS_REL32);
		      else
			mips_elf_set_cr_type (cptrel, CRT_MIPS_WORD);
		      mips_elf_set_cr_dist2to (cptrel, 0);
		      cptrel.konst = addend;

		      cr = (scpt->contents
			    + sizeof (Elf32_External_compact_rel));
		      bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
						 ((Elf32_External_crinfo *) cr
						  + scpt->reloc_count));
		      ++scpt->reloc_count;
		    }
d6089 7
a6095 13
		  /* This reloc will be computed at runtime, so
		     there's no need to do anything now.  */
		  continue;
		}
	      else
		r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					      contents, rel->r_offset,
					      relocation, addend);
	    }
	  else if (r_type == R_MIPS_64)
	    {
	      bfd_size_type addr;
	      unsigned long val;
d6097 10
a6106 20
	      /* Do a 32 bit relocation, and sign extend to 64 bits.  */
	      addr = rel->r_offset;
	      if (bfd_big_endian (input_bfd))
		addr += 4;
	      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents, addr, relocation,
					    addend);
	      val = bfd_get_32 (input_bfd, contents + addr);
	      if ((val & 0x80000000) != 0)
		val = 0xffffffff;
	      else
		val = 0;
	      addr = rel->r_offset;
	      if (bfd_little_endian (input_bfd))
		addr += 4;
	      bfd_put_32 (input_bfd, val, contents + addr);
	    }
	  else if (r_type == R_MIPS_26 && other == STO_MIPS16)
	    {
	      unsigned long insn;
d6108 9
a6116 28
	      /* This is a jump to a mips16 routine from a mips32
                 routine.  We need to change jal into jalx.  */
	      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      if (((insn >> 26) & 0x3f) != 0x3
		  && ((insn >> 26) & 0x3f) != 0x1d)
		{
		  (*_bfd_error_handler)
		    (_("%s: %s+0x%lx: jump to mips16 routine which is not jal"),
		     bfd_get_filename (input_bfd),
		     input_section->name,
		     (unsigned long) rel->r_offset);
		  bfd_set_error (bfd_error_bad_value);
		  return false;
		}
	      insn = (insn & 0x3ffffff) | (0x1d << 26);
	      bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
	      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents, rel->r_offset,
					    relocation, addend);
	    }
	  else if (r_type == R_MIPS16_26)
	    {
	      /* It's easiest to do the normal relocation, and then
                 dig out the instruction and swap the first word the
                 way the mips16 expects it.  If this is little endian,
                 though, we need to swap the two words first, and then
                 swap them back again later, so that the address looks
                 right.  */
d6118 2
a6119 3
	      if (bfd_little_endian (input_bfd))
		{
		  unsigned long insn;
d6121 3
a6123 4
		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  insn = ((insn >> 16) & 0xffff) | ((insn & 0xffff) << 16);
		  bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
		}
d6125 23
a6147 4
	      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents, rel->r_offset,
					    relocation, addend);
	      if (r == bfd_reloc_ok)
d6149 6
a6154 1
		  unsigned long insn;
d6156 6
a6161 6
		  if (bfd_little_endian (input_bfd))
		    {
		      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		      insn = ((insn >> 16) & 0xffff) | ((insn & 0xffff) << 16);
		      bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
		    }
d6163 2
a6164 9
		  insn = bfd_get_16 (input_bfd, contents + rel->r_offset);
		  insn = ((insn & 0xfc00)
			  | ((insn & 0x1f) << 5)
			  | ((insn & 0x3e0) >> 5));
		  /* If this is a jump to a 32 bit routine, then make
		     it jalx.  */
		  if (other != STO_MIPS16)
		    insn |= 0x400;
		  bfd_put_16 (input_bfd, insn, contents + rel->r_offset);
d6166 1
a6166 13
	    }
	  else if (r_type == R_MIPS16_GPREL)
	    {
	      unsigned short extend, insn;
	      bfd_byte buf[4];
	      unsigned long final;

	      /* Extract the addend into buf, run the regular reloc,
                 and stuff the resulting value back into the
                 instructions.  */
	      if (rel->r_offset > input_section->_raw_size)
		r = bfd_reloc_outofrange;
	      else
d6168 4
a6171 21
		  extend = bfd_get_16 (input_bfd, contents + rel->r_offset);
		  insn = bfd_get_16 (input_bfd, contents + rel->r_offset + 2);
		  bfd_put_32 (input_bfd,
			      (((extend & 0x1f) << 11)
			       | (extend & 0x7e0)
			       | (insn & 0x1f)),
			      buf);
		  r = _bfd_final_link_relocate (howto, input_bfd,
						input_section, buf,
						(bfd_vma) 0, relocation,
						addend);
		  final = bfd_get_32 (input_bfd, buf);
		  bfd_put_16 (input_bfd,
			      ((extend & 0xf800)
			       | ((final >> 11) & 0x1f)
			       | (final & 0x7e0)),
			      contents + rel->r_offset);
		  bfd_put_16 (input_bfd,
			      ((insn & 0xffe0)
			       | (final & 0x1f)),
			      contents + rel->r_offset + 2);
d6175 29
a6203 28
	    r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					  contents, rel->r_offset,
					  relocation, addend);

	  /* The jal instruction can only jump to an address which is
             divisible by 4, and it can only jump to an address with
             the same upper 4 bits as the PC.  */
	  if (r == bfd_reloc_ok
	      && (r_type == R_MIPS16_26 || r_type == R_MIPS_26))
	    {
	      bfd_vma addr;
              bfd_vma pc;
              bfd_vma target;

              pc = ((input_section->output_section->vma
                     + input_section->output_offset
                     + rel->r_offset)
                    & 0xf0000000);
              target = bfd_get_32 (input_bfd, contents + rel->r_offset)
			& (howto->dst_mask);
              addr = (target << 2) + pc;
	      if (other == STO_MIPS16)
		addr &= ~ (bfd_vma) 1;
	      if ((addr & 3) != 0
		  || ((addr & 0xf0000000)
                      != pc))
		r = bfd_reloc_overflow;
	    }
d6205 2
a6206 24
	  /* Don't bother to report a relocation overflow for a call
             to a weak undefined symbol with a value of zero.  This
             permits us to use
	         if (!f) f();
	     even if we aren't in range to call address zero.  */
	  if (r == bfd_reloc_overflow
	      && (r_type == R_MIPS16_26 || r_type == R_MIPS_26)
	      && relocation + addend == 0
	      && h != NULL
	      && h->root.type == bfd_link_hash_undefweak)
	    r = bfd_reloc_ok;

	  /* If we've already issued an error for an undefined symbol,
             don't issue another useless error.  */
	  if (undefined_error
	      && (r == bfd_reloc_undefined || r == bfd_reloc_overflow))
	    r = bfd_reloc_ok;

	  if (SGI_COMPAT (output_bfd)
	      && scpt != NULL
	      && (input_section->flags & SEC_ALLOC) != 0)
	    {
	      Elf32_crinfo cptrel;
	      bfd_byte *cr;
d6208 3
a6210 5
	      /* Make an entry of compact relocation info.  */
	      mips_elf_set_cr_format (cptrel, CRF_MIPS_LONG);
	      cptrel.vaddr = (rel->r_offset
			      + input_section->output_section->vma
			      + input_section->output_offset);
d6212 12
a6223 13
	      switch (r_type)
		{
		case R_MIPS_26:
		  mips_elf_set_cr_type (cptrel, CRT_MIPS_JMPAD);
		  /* XXX How should we set dist2to in this case. */
		  mips_elf_set_cr_dist2to (cptrel, 8);
		  cptrel.konst = addend + relocation;
		  cr = scpt->contents + sizeof (Elf32_External_compact_rel);
		  bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
					     ((Elf32_External_crinfo *) cr
					      + scpt->reloc_count));
		  ++scpt->reloc_count;
		  break;
d6225 2
a6226 12
		case R_MIPS_GPREL16:
		case R_MIPS_LITERAL:
		case R_MIPS_GPREL32:
		  mips_elf_set_cr_type (cptrel, CRT_MIPS_GPHI_LO);
		  cptrel.konst = gp - cptrel.vaddr;
		  mips_elf_set_cr_dist2to (cptrel, 4);
		  cr = scpt->contents + sizeof (Elf32_External_compact_rel);
		  bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
					     ((Elf32_External_crinfo *) cr
					      + scpt->reloc_count));
		  ++scpt->reloc_count;
		  break;
d6228 3
a6230 4
		default:
		  break;
		}
	    }
d6233 3
a6235 1
      if (r != bfd_reloc_ok)
d6237 3
a6239 8
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;
d6241 3
a6243 20
		if (h != NULL)
		  name = h->root.root.string;
		else
		  {
		    name = bfd_elf_string_from_elf_section (input_bfd,
							    symtab_hdr->sh_link,
							    sym->st_name);
		    if (name == NULL)
		      return false;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rel->r_offset)))
		  return false;
	      }
	      break;
	    }
	}
d6319 2
a6320 1
  if (bfd_get_section_by_name (abfd, ".stub") == NULL)
d6322 1
a6322 1
      s = bfd_make_section (abfd, ".stub");
d6324 1
a6324 1
	  || ! bfd_set_section_flags (abfd, s, flags)
d6329 1
a6329 1
  if (SGI_COMPAT (abfd)
d6506 1
a6506 1
  g->global_gotsym = 0;
d6517 2
d6761 1
d6765 1
d6784 1
a6784 1
	  switch (ELF32_R_TYPE (rel->r_info))
d6796 1
a6796 5
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	      BFD_ASSERT (elf_section_data (sgot) != NULL);
	      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	      BFD_ASSERT (g != NULL);
d6812 20
a6831 1
      switch (ELF32_R_TYPE (rel->r_info))
a6833 4
	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	  /* This symbol requires a global offset table entry.  */

d6842 1
d6844 5
a6848 20
	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return false;
	    }

	  if (h->got.offset != (bfd_vma) -1)
	    {
	      /* We have already allocated space in the .got.  */
	      break;
	    }

	  /* Note the index of the first global got symbol in .dynsym.  */
	  if (g->global_gotsym == 0
	      || g->global_gotsym > (unsigned long) h->dynindx)
	    g->global_gotsym = h->dynindx;

	  /* Make this symbol to have the corresponding got entry.  */
	  h->got.offset = 0;
d6861 1
d6863 2
a6864 25

	  if (h != NULL)
	    {
	      /* Make sure this symbol is output as a dynamic symbol.  */
	      if (h->dynindx == -1)
		{
		  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		    return false;
		}

	      if (h->got.offset != (bfd_vma) -1)
		{
		  /* We have already allocated space in the .got.  */
		  break;
		}
	      /* Note the index of the first global got symbol in
                 .dynsym.  */
	      if (g->global_gotsym == 0
		  || g->global_gotsym > (unsigned long) h->dynindx)
		g->global_gotsym = h->dynindx;

	      /* Make this symbol to be the global got symbol.  */
	      h->got.offset = 0;
	    }

d6916 7
d6962 1
a6962 1
	  && ELF32_R_TYPE (rel->r_info) != R_MIPS16_26
a7264 1
  asection *sgot;
d7280 1
a7280 1
	    = (unsigned char *) ELF_DYNAMIC_INTERPRETER (output_bfd);
a7283 32
  /* Recompute the size of .got for local entires (reserved and
     hipages) if needed.  To estimate it, get the upper bound of total
     size of loadable sections.  */
  sgot = bfd_get_section_by_name (dynobj, ".got");

  if (sgot != NULL)
    {
      bfd_size_type loadable_size = 0;
      bfd_size_type local_gotno;
      struct _bfd *sub;

      BFD_ASSERT (elf_section_data (sgot) != NULL);
      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
      BFD_ASSERT (g != NULL);

      for (sub = info->input_bfds; sub; sub = sub->link_next)
	for (s = sub->sections; s != NULL; s = s->next)
	  {
	    if ((s->flags & SEC_ALLOC) == 0)
	      continue;
	    loadable_size += (s->_raw_size + 0xf) & ~0xf;
	  }

      loadable_size += MIPS_FUNCTION_STUB_SIZE;

      /* Assume there are two loadable segments consisting of
	 contiguous sections.  Is 5 enough? */
      local_gotno = (loadable_size >> 16) + 5 + MIPS_RESERVED_GOTNO;
      g->local_gotno = local_gotno;
      sgot->_raw_size += local_gotno * 4;
    }

d7346 3
d7350 1
a7350 1
	  BFD_ASSERT (elf_section_data (s) != NULL);
d7352 33
a7384 1
	  BFD_ASSERT (g != NULL);
d7386 1
a7386 4
	  /* Fix the size of .got section for the correspondence of
	     global symbols and got entries. This adds some useless
	     got entries. Is this required by ABI really?  */
	  i = elf_hash_table (info)->dynsymcount - g->global_gotsym;
d7529 2
a7530 1
      if (! bfd_elf32_add_dynamic_entry (info, DT_MIPS_HIPAGENO, 0))
d7533 5
a7537 9
#if 0 /* (SGI_COMPAT) */
      if (! bfd_get_section_by_name (dynobj, ".init"))
	if (! bfd_elf32_add_dynamic_entry (info, DT_INIT, 0))
	  return false;

      if (! bfd_get_section_by_name (dynobj, ".fini"))
	if (! bfd_elf32_add_dynamic_entry (info, DT_FINI, 0))
	  return false;
#endif
a7607 14

    if (sgot != NULL)
      {
	BFD_ASSERT (elf_section_data (sgot) != NULL);
	g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
	BFD_ASSERT (g != NULL);

	/* If there are no global got symbols, fake the last symbol so
	   for safety.  */
	if (g->global_gotsym)
	  g->global_gotsym += c;
	else
	  g->global_gotsym = elf_hash_table (info)->dynsymcount - 1;
      }
d7613 51
d7737 3
a7739 1
  if ((unsigned long) h->dynindx >= g->global_gotsym)
d7741 12
a7752 1
      bfd_size_type offset;
d7754 2
a7755 9
      /* This symbol has an entry in the global offset table.  Set its
	 value to the corresponding got entry, if needed.  */
      if (h->got.offset == (bfd_vma) -1)
	{
	  offset = (h->dynindx - g->global_gotsym + g->local_gotno) * 4;
	  BFD_ASSERT (g->local_gotno * 4 <= offset
		      && offset < sgot->_raw_size);
	  bfd_put_32 (output_bfd, gval, sgot->contents + offset);
	}
d7817 4
d8003 4
a8006 5
#if 0
	      dyn.d_un.d_val = SIZEOF_MIPS_DYNSYM_SECNAMES;
#else
	      dyn.d_un.d_val = bfd_count_sections (output_bfd);
#endif
d8011 1
a8011 1
	      dyn.d_un.d_val = g->global_gotsym;
d8022 7
@


1.9
log
@	* elf32-mips.c (MIPS_ELF_SRDATA_SECTION_NAME): New macro.
	(MIPS_ELF_OPTIONS_SECTION_NAME): Likewise.
	(MIPS_ELF_STUB_SECTION_NAME): Likewise.
	(_bfd_mips_elf_section_from_shdr): Use them.
	(_bfd_mips_elf_fake_sections): Likewise.  Add .srdata to the list
	of GP-relative sections.
	(_bfd_mips_elf_set_section_contents): Use them.
	(_bfd_mips_elf_section_processing): Share code between .sdata and
	.lit4/.lit8 sections.  Set appropriate flags for .srdata.
	(mips_elf_additional_program_headers): Add handling for
	PT_MIPS_OPTIONS segment on IRIX6.
	(mips_elf_modify_segment_map): Likeiwse.
	(mips_elf_final_link): Set EF_MIPS_CPIC when required by the ABI.
	Include the options sections on IRIX6.  Don't look for GP-relative
	sections by name; use SHF_MIPS_GPREL instead.
	(ELF_DYNAMIC_INTERPRETER): Adjust to use /usr/lib32/libc.so.1 for
	the N32 ABI.
	(mips_elf_create_dynamic_sections): Don't muck about with section
	alignments and such on IRIX6.
	(mips_elf_adjust_dynamic_symbol): Use MIPS_ELF_STUB_SECTION_NAME.
	(mips_elf_size_dynamic_sections): Likewise. Adjust to handle the
	fact that ELF_DYNAMIC_INTERPRETER is no longer a constant.  Use
	bfd_zalloc rather than bfd_alloc and memset.
	(mips_elf_finish_dynamic_symbol): Use MIPS_ELF_STUB_SECTION_NAME.
	Don't assert the existence of .rld_map on IRIX6.
	(mips_elf_finish_dynamic_sections): Use MIPS_ELF_STUB_SECTION_NAME.
@
text
@d4178 3
a4180 1
  if (!info->shared && elf_elfheader (abfd)->e_flags & EF_MIPS_PIC)
a4183 1
      
@


1.8
log
@	* elf32-mips.c (mips_elf_adjust_dynindx): Remove.
	(mips_elf_size_dynamic_sections): Use _bfd_elf_link_adjust_dynindx
	instead.
@
text
@d173 11
d2463 1
a2463 2
      if (strcmp (name, ".options") != 0
	  && strcmp (name, ".MIPS.options") != 0)
d2640 1
d2657 1
a2657 2
  else if (strcmp (name, ".options") == 0
	   || strcmp (name, ".MIPS.options") == 0)
d2727 1
a2727 2
  if (strcmp (section->name, ".options") == 0
      || strcmp (section->name, ".MIPS.options") == 0)
d2774 3
a2776 1
      if (strcmp (name, ".sdata") == 0)
d2786 1
a2786 2
      else if (strcmp (name, ".lit8") == 0
	       || strcmp (name, ".lit4") == 0)
d2788 1
a2788 1
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
d2994 1
a2994 1
  int ret;
d2996 2
a2997 4
  ret = 0;

  if (! SGI_COMPAT (abfd))
    return ret;
d2999 1
d3001 2
a3002 5
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      /* We need a PT_MIPS_REGINFO segment.  */
      ++ret;
    }
d3004 11
a3014 6
  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL
      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
    {
      /* We need a PT_MIPS_RTPROC segment.  */
      ++ret;
    }
d3061 5
a3065 5
  /* If there are .dynamic and .mdebug sections, we make a room for
     the RTPROC header.  FIXME: Rewrite without section names.  */
  if (bfd_get_section_by_name (abfd, ".interp") == NULL
      && bfd_get_section_by_name (abfd, ".dynamic") != NULL
      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
d3067 4
a3070 2
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	if (m->p_type == PT_MIPS_RTPROC)
d3072 2
a3073 1
      if (m == NULL)
d3075 7
a3081 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
d3085 9
a3093 24
	  m->p_type = PT_MIPS_RTPROC;

	  s = bfd_get_section_by_name (abfd, ".rtproc");
	  if (s == NULL)
	    {
	      m->count = 0;
	      m->p_flags = 0;
	      m->p_flags_valid = 1;
	    }
	  else
	    {
	      m->count = 1;
	      m->sections[0] = s;
	    }

	  /* We want to put it after the DYNAMIC segment.  */
	  pm = &elf_tdata (abfd)->segment_map;
	  while (*pm != NULL && (*pm)->p_type != PT_DYNAMIC)
	    pm = &(*pm)->next;
	  if (*pm != NULL)
	    pm = &(*pm)->next;

	  m->next = *pm;
	  *pm = m;
d3096 1
a3096 10

  /* On Irix 5, the PT_DYNAMIC segment includes the .dynamic, .dynstr,
     .dynsym, and .hash sections, and everything in between.  */
  for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL; pm = &(*pm)->next)
    if ((*pm)->p_type == PT_DYNAMIC)
      break;
  m = *pm;
  if (m != NULL
      && m->count == 1
      && strcmp (m->sections[0]->name, ".dynamic") == 0)
d3098 5
a3102 9
      static const char *sec_names[] =
	{ ".dynamic", ".dynstr", ".dynsym", ".hash" };
      bfd_vma low, high;
      unsigned int i, c;
      struct elf_segment_map *n;

      low = 0xffffffff;
      high = 0;
      for (i = 0; i < sizeof sec_names / sizeof sec_names[0]; i++)
d3104 4
a3107 2
	  s = bfd_get_section_by_name (abfd, sec_names[i]);
	  if (s != NULL && (s->flags & SEC_LOAD) != 0)
d3109 18
a3126 1
	      bfd_size_type sz;
d3128 9
a3136 7
	      if (low > s->vma)
		low = s->vma;
	      sz = s->_cooked_size;
	      if (sz == 0)
		sz = s->_raw_size;
	      if (high < s->vma + sz)
		high = s->vma + sz;
d3140 25
a3164 8
      c = 0;
      for (s = abfd->sections; s != NULL; s = s->next)
	if ((s->flags & SEC_LOAD) != 0
	    && s->vma >= low
	    && ((s->vma
		 + (s->_cooked_size != 0 ? s->_cooked_size : s->_raw_size))
		<= high))
	  ++c;
d3166 25
a3190 6
      n = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof *n + (c - 1) * sizeof (asection *)));
      if (n == NULL)
	return false;
      *n = *m;
      n->count = c;
d3192 2
a3193 8
      i = 0;
      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  if ((s->flags & SEC_LOAD) != 0
	      && s->vma >= low
	      && ((s->vma
		   + (s->_cooked_size != 0 ? s->_cooked_size : s->_raw_size))
		  <= high))
d3195 10
a3204 2
	      n->sections[i] = s;
	      ++i;
d3206 2
a3208 2

      *pm = n;
d4175 29
a4203 15
  /* Drop the .options section, since it has special semantics which I
     haven't bothered to figure out.  */
  for (secpp = &abfd->sections; *secpp != NULL; secpp = &(*secpp)->next)
    {
      if (strcmp ((*secpp)->name, ".options") == 0)
	{
	  for (p = (*secpp)->link_order_head; p != NULL; p = p->next)
	    if (p->type == bfd_indirect_link_order)
	      p->u.indirect.section->flags &=~ SEC_HAS_CONTENTS;
	  (*secpp)->link_order_head = NULL;
	  *secpp = (*secpp)->next;
	  --abfd->section_count;
	  break;
	}
    }
d4220 1
a4220 1
	  /* Make up a value.  */
d4223 5
a4227 8
	    {
	      if (o->vma < lo
		  && (strcmp (o->name, ".sbss") == 0
		      || strcmp (o->name, ".sdata") == 0
		      || strcmp (o->name, ".lit4") == 0
		      || strcmp (o->name, ".lit8") == 0))
		lo = o->vma;
	    }
d5880 2
a5881 1
#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"
d5938 5
a5942 1
  if (SGI_COMPAT (abfd))
d6749 2
a6750 1
	  s = bfd_get_section_by_name (dynobj, ".stub");
d6890 4
a6893 2
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
d7002 1
a7002 1
      else if (strncmp (name, ".stub", 5) == 0)
d7037 1
a7037 1
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
a7042 1
      memset (s->contents, 0, s->_raw_size);
d7275 2
a7276 1
      s = bfd_get_section_by_name (dynobj, ".stub");
d7406 4
a7409 2
	  asection *s = bfd_get_section_by_name (dynobj, ".rld_map");
	  BFD_ASSERT (s != NULL);
d7748 2
a7749 1
	    s = bfd_get_section_by_name (dynobj, ".stub");
@


1.7
log
@	* elf32-mips.c (mips_elf_swap_msym_in): New function.
	(mips_elf_swap_msym_out): New function.
	(mips_elf_create_msym_section): Likewise.
	(MIPS_ELF_MSYM_SECTION_NAME): New macro.
	(_bfd_mips_elf_final_write_processing): Set sh_link for .msym.
	(_bfd_mips_elf_section_from_shdr): Reject an SHT_MIPS_MSYM
	section not named .msym.
	(_bfd_mips_elf_fake_sections): Use MIPS_ELF_MSYM_SECTION_NAME, not
	.msym directly.  Set appropriate attributes for the .msym
	section.
	(mips_elf_link_hash_entry): Add min_dyn_reloc_index field.
	(mips_elf_link_hash_newfunc): Clear it.
	(mips_elf_create_dynamic_sections): Create the .msym section
	on IRIX6.
	(mips_elf_size_dynamic_sections):  Allocate space for the
	.msym section.  Add a DT_MIPS_MSYM entry.
	(mips_elf_finish_dynamic_symbol): Write out a .msym entry for
	the symbol.
	(mips_elf_finish_dynamic_sections): Assign a value for
	DT_MIPS_MSYM.  Add .msym entries for the section symbols as well.
@
text
@a94 2
static boolean mips_elf_adjust_dynindx
  PARAMS ((struct elf_link_hash_entry *, PTR));
d7143 1
a7143 1
				    mips_elf_adjust_dynindx,
a7170 15
  return true;
}

/* Increment the index of a dynamic symbol by a given amount.  Called
   via elf_link_hash_traverse.  */

static boolean
mips_elf_adjust_dynindx (h, cparg)
     struct elf_link_hash_entry *h;
     PTR cparg;
{
  unsigned int *cp = (unsigned int *) cparg;

  if (h->dynindx != -1)
    h->dynindx += *cp;
@


1.6
log
@	* elf32-mips.c (irix_compat_t): New enumeration.
	(ABI_N32_P): New macro.
	(IRIX_COMPAT): Likewise.
	(SGI_COMPAT): Implement in terms of IRIX_COMPAT.
	(mips_elf_relocate_section): Fix typo.
@
text
@d56 4
d131 2
d172 3
d1944 25
d2079 1
d2419 1
a2419 1
      if (strcmp (name, ".msym") != 0)
d2584 1
a2584 1
  else if (strcmp (name, ".msym") == 0)
d2671 6
d3485 4
d3584 1
d5849 7
d6054 27
d6951 5
d7087 5
d7204 1
d7207 1
d7211 1
d7278 16
d7540 6
d7564 1
d7573 2
d7633 2
d7640 3
d7646 1
d7653 2
d7656 10
a7665 4
		bfd_elf32_swap_symbol_out (output_bfd, &sym,
					   (((Elf32_External_Sym *)
					     sdynsym->contents)
					    + elf_section_data (s)->dynindx));
@


1.5
log
@	* elf32-mips.c (mips_elf32_section_processing): Permit a
	SHT_MIPS_REGINFO section to have a size of 0.
@
text
@d128 1
a128 3
/* This is true for Irix 5 executables, false for normal MIPS ELF ABI
   executables.  FIXME: At the moment, we default to always generating
   Irix 5 executables.  */
d130 22
a151 1
#define SGI_COMPAT(abfd) (1)
d5660 1
a5660 1
	  if (SGI_COMPAT (abfd)
@


1.4
log
@	* elf32-mips.c (_bfd_mips_elf_print_private_data): Recognize
	the N32 ABI.
@
text
@d2753 2
a2754 1
  if (hdr->sh_type == SHT_MIPS_REGINFO)
@


1.3
log
@	* elf32-mips.c (elf_mips_howto_table): Add R_MIPS_JALR.
	* elf64-mips.c (mips_elf64_howto_table_rel): Likewise.
	(mips_elf64_howto_table_rela): Likewise.
@
text
@d2312 2
@


1.2
log
@	* reloc.c (BFD_RELOC_MIPS_SUB): New relocation.
	(BFD_RELOC_MIPS_GOT_PAGE): Likewise.
	(BFD_RELOC_MIPS_GOT_OFST): Likewise.
	(BFD_RELOC_MIPS_GOT_DISP): Likewise.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* elf32-mips.c (mips_info_to_howto_rela): New function.
	(USE_REL): Adjust for new conventions.
	(MINUS_ONE): New macro.
	(elf_mips_howto_table): Add R_MIPS_SUB.
	(mips_r): Add entries for MIPS_SUB, MIPS_GOT_PAGE, MIPS_GOT_OFST,
	and MIPS_GOT_DISP.
	(mips_elf_final_write_processing): Set sh_link, not sh_info, for a
	.MIPS.content section.
	(_bfd_mips_elf_fake_sections): Treat all sections that begin
	with .MIPS.content as .MIPS.content sections.  Set
	SHF_MNIPS_NOSTRIP for such section.
	(elf_info_to_howto): Define to mips_info_to_howto_rela.
	* elf64-mips.c (mips_r):  Add entries for MIPS_SUB, MIPS_GOT_PAGE,
	MIPS_GOT_OFST, and MIPS_GOT_DISP.
@
text
@d705 17
a721 1
  { R_MIPS_RELGOT }
@


1.1
log
@Initial revision
@
text
@d50 2
d302 4
d643 15
a657 2
  /* 64 bit subtraction.  Presumably not used in 32 bit ELF.  */
  { R_MIPS_SUB },
d1629 5
a1633 1
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 }
d1677 1
a1677 1
/* Given a MIPS reloc type, fill in an arelent structure.  */
d1718 17
d2035 1
a2035 1
	  (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
d2570 1
a2570 1
  else if (strcmp (name, ".MIPS.content") == 0)
d2573 1
d7787 1
a7787 1
#define elf_info_to_howto		0
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

