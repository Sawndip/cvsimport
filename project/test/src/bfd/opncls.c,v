head	1.85;
access;
symbols
	sid-snapshot-20180601:1.85
	sid-snapshot-20180501:1.85
	sid-snapshot-20180401:1.85
	sid-snapshot-20180301:1.85
	sid-snapshot-20180201:1.85
	sid-snapshot-20180101:1.85
	sid-snapshot-20171201:1.85
	sid-snapshot-20171101:1.85
	sid-snapshot-20171001:1.85
	sid-snapshot-20170901:1.85
	sid-snapshot-20170801:1.85
	sid-snapshot-20170701:1.85
	sid-snapshot-20170601:1.85
	sid-snapshot-20170501:1.85
	sid-snapshot-20170401:1.85
	sid-snapshot-20170301:1.85
	sid-snapshot-20170201:1.85
	sid-snapshot-20170101:1.85
	sid-snapshot-20161201:1.85
	sid-snapshot-20161101:1.85
	sid-snapshot-20160901:1.85
	sid-snapshot-20160801:1.85
	sid-snapshot-20160701:1.85
	sid-snapshot-20160601:1.85
	sid-snapshot-20160501:1.85
	sid-snapshot-20160401:1.85
	sid-snapshot-20160301:1.85
	sid-snapshot-20160201:1.85
	sid-snapshot-20160101:1.85
	sid-snapshot-20151201:1.85
	sid-snapshot-20151101:1.85
	sid-snapshot-20151001:1.85
	sid-snapshot-20150901:1.85
	sid-snapshot-20150801:1.85
	sid-snapshot-20150701:1.85
	sid-snapshot-20150601:1.85
	sid-snapshot-20150501:1.85
	sid-snapshot-20150401:1.85
	sid-snapshot-20150301:1.85
	sid-snapshot-20150201:1.85
	sid-snapshot-20150101:1.85
	sid-snapshot-20141201:1.85
	sid-snapshot-20141101:1.85
	sid-snapshot-20141001:1.85
	sid-snapshot-20140901:1.85
	sid-snapshot-20140801:1.85
	sid-snapshot-20140701:1.85
	sid-snapshot-20140601:1.85
	sid-snapshot-20140501:1.85
	sid-snapshot-20140401:1.85
	sid-snapshot-20140301:1.85
	sid-snapshot-20140201:1.85
	sid-snapshot-20140101:1.85
	sid-snapshot-20131201:1.85
	sid-snapshot-20131101:1.85
	sid-snapshot-20131001:1.82
	binutils-2_24-branch:1.82.0.2
	binutils-2_24-branchpoint:1.82
	binutils-2_21_1:1.66.2.1
	sid-snapshot-20130901:1.82
	gdb_7_6_1-2013-08-30-release:1.79
	sid-snapshot-20130801:1.82
	sid-snapshot-20130701:1.82
	sid-snapshot-20130601:1.82
	sid-snapshot-20130501:1.81
	gdb_7_6-2013-04-26-release:1.79
	sid-snapshot-20130401:1.80
	binutils-2_23_2:1.69.4.1
	gdb_7_6-branch:1.79.0.2
	gdb_7_6-2013-03-12-branchpoint:1.79
	sid-snapshot-20130301:1.79
	sid-snapshot-20130201:1.79
	sid-snapshot-20130101:1.76
	sid-snapshot-20121201:1.76
	gdb_7_5_1-2012-11-29-release:1.69
	binutils-2_23_1:1.69
	sid-snapshot-20121101:1.73
	binutils-2_23:1.69
	sid-snapshot-20121001:1.73
	sid-snapshot-20120901:1.73
	gdb_7_5-2012-08-17-release:1.69
	sid-snapshot-20120801:1.69
	binutils-2_23-branch:1.69.0.4
	binutils-2_23-branchpoint:1.69
	gdb_7_5-branch:1.69.0.2
	gdb_7_5-2012-07-18-branchpoint:1.69
	sid-snapshot-20120701:1.69
	sid-snapshot-20120601:1.69
	sid-snapshot-20120501:1.68
	binutils-2_22_branch:1.68.0.6
	gdb_7_4_1-2012-04-26-release:1.68
	sid-snapshot-20120401:1.68
	sid-snapshot-20120301:1.68
	sid-snapshot-20120201:1.68
	gdb_7_4-2012-01-24-release:1.68
	sid-snapshot-20120101:1.68
	gdb_7_4-branch:1.68.0.4
	gdb_7_4-2011-12-13-branchpoint:1.68
	sid-snapshot-20111201:1.68
	binutils-2_22:1.68
	sid-snapshot-20111101:1.68
	sid-snapshot-20111001:1.68
	binutils-2_22-branch:1.68.0.2
	binutils-2_22-branchpoint:1.68
	gdb_7_3_1-2011-09-04-release:1.66
	sid-snapshot-20110901:1.68
	sid-snapshot-20110801:1.68
	gdb_7_3-2011-07-26-release:1.66
	sid-snapshot-20110701:1.68
	sid-snapshot-20110601:1.67
	sid-snapshot-20110501:1.67
	gdb_7_3-branch:1.66.0.4
	gdb_7_3-2011-04-01-branchpoint:1.66
	sid-snapshot-20110401:1.66
	sid-snapshot-20110301:1.66
	sid-snapshot-20110201:1.66
	sid-snapshot-20110101:1.66
	binutils-2_21:1.66
	sid-snapshot-20101201:1.66
	binutils-2_21-branch:1.66.0.2
	binutils-2_21-branchpoint:1.66
	sid-snapshot-20101101:1.66
	sid-snapshot-20101001:1.64
	binutils-2_20_1:1.57.2.3
	gdb_7_2-2010-09-02-release:1.64
	sid-snapshot-20100901:1.64
	sid-snapshot-20100801:1.64
	gdb_7_2-branch:1.64.0.2
	gdb_7_2-2010-07-07-branchpoint:1.64
	sid-snapshot-20100701:1.64
	sid-snapshot-20100601:1.64
	sid-snapshot-20100501:1.63
	sid-snapshot-20100401:1.63
	gdb_7_1-2010-03-18-release:1.63
	sid-snapshot-20100301:1.63
	gdb_7_1-branch:1.63.0.2
	gdb_7_1-2010-02-18-branchpoint:1.63
	sid-snapshot-20100201:1.63
	sid-snapshot-20100101:1.63
	gdb_7_0_1-2009-12-22-release:1.58
	sid-snapshot-20091201:1.60
	sid-snapshot-20091101:1.60
	binutils-2_20:1.57.2.2
	gdb_7_0-2009-10-06-release:1.58
	sid-snapshot-20091001:1.58
	gdb_7_0-branch:1.58.0.2
	gdb_7_0-2009-09-16-branchpoint:1.58
	arc-sim-20090309:1.51
	binutils-arc-20081103-branch:1.53.0.12
	binutils-arc-20081103-branchpoint:1.53
	binutils-2_20-branch:1.57.0.2
	binutils-2_20-branchpoint:1.57
	sid-snapshot-20090901:1.56
	sid-snapshot-20090801:1.55
	msnyder-checkpoint-072509-branch:1.55.0.4
	msnyder-checkpoint-072509-branchpoint:1.55
	sid-snapshot-20090701:1.55
	dje-cgen-play1-branch:1.55.0.2
	dje-cgen-play1-branchpoint:1.55
	sid-snapshot-20090601:1.53
	sid-snapshot-20090501:1.53
	sid-snapshot-20090401:1.53
	arc-20081103-branch:1.53.0.10
	arc-20081103-branchpoint:1.53
	arc-insight_6_8-branch:1.51.0.6
	arc-insight_6_8-branchpoint:1.51
	insight_6_8-branch:1.51.0.4
	insight_6_8-branchpoint:1.51
	sid-snapshot-20090301:1.53
	binutils-2_19_1:1.53
	sid-snapshot-20090201:1.53
	sid-snapshot-20090101:1.53
	reverse-20081226-branch:1.53.0.8
	reverse-20081226-branchpoint:1.53
	sid-snapshot-20081201:1.53
	multiprocess-20081120-branch:1.53.0.6
	multiprocess-20081120-branchpoint:1.53
	sid-snapshot-20081101:1.53
	binutils-2_19:1.53
	sid-snapshot-20081001:1.53
	reverse-20080930-branch:1.53.0.4
	reverse-20080930-branchpoint:1.53
	binutils-2_19-branch:1.53.0.2
	binutils-2_19-branchpoint:1.53
	sid-snapshot-20080901:1.53
	sid-snapshot-20080801:1.52
	reverse-20080717-branch:1.52.0.4
	reverse-20080717-branchpoint:1.52
	sid-snapshot-20080701:1.52
	msnyder-reverse-20080609-branch:1.52.0.2
	msnyder-reverse-20080609-branchpoint:1.52
	drow-reverse-20070409-branch:1.45.0.2
	drow-reverse-20070409-branchpoint:1.45
	sid-snapshot-20080601:1.52
	sid-snapshot-20080501:1.52
	sid-snapshot-20080403:1.52
	sid-snapshot-20080401:1.52
	gdb_6_8-2008-03-27-release:1.51
	sid-snapshot-20080301:1.51
	gdb_6_8-branch:1.51.0.2
	gdb_6_8-2008-02-26-branchpoint:1.51
	sid-snapshot-20080201:1.51
	sid-snapshot-20080101:1.51
	sid-snapshot-20071201:1.51
	sid-snapshot-20071101:1.50
	gdb_6_7_1-2007-10-29-release:1.49
	gdb_6_7-2007-10-10-release:1.49
	sid-snapshot-20071001:1.50
	gdb_6_7-branch:1.49.0.2
	gdb_6_7-2007-09-07-branchpoint:1.49
	binutils-2_18:1.48
	binutils-2_18-branch:1.48.0.2
	binutils-2_18-branchpoint:1.48
	insight_6_6-20070208-release:1.44
	binutils-csl-coldfire-4_1-32:1.42
	binutils-csl-sourcerygxx-4_1-32:1.42
	gdb_6_6-2006-12-18-release:1.44
	binutils-csl-innovasic-fido-3_4_4-33:1.42
	binutils-csl-sourcerygxx-3_4_4-32:1.30
	binutils-csl-coldfire-4_1-30:1.42
	binutils-csl-sourcerygxx-4_1-30:1.42
	binutils-csl-coldfire-4_1-28:1.42
	binutils-csl-sourcerygxx-4_1-29:1.42
	binutils-csl-sourcerygxx-4_1-28:1.42
	gdb_6_6-branch:1.44.0.2
	gdb_6_6-2006-11-15-branchpoint:1.44
	binutils-csl-arm-2006q3-27:1.42
	binutils-csl-sourcerygxx-4_1-27:1.42
	binutils-csl-arm-2006q3-26:1.42
	binutils-csl-sourcerygxx-4_1-26:1.42
	binutils-csl-sourcerygxx-4_1-25:1.42
	binutils-csl-sourcerygxx-4_1-24:1.42
	binutils-csl-sourcerygxx-4_1-23:1.42
	insight_6_5-20061003-release:1.43
	gdb-csl-symbian-6_4_50_20060226-12:1.41
	binutils-csl-sourcerygxx-4_1-21:1.42
	binutils-csl-arm-2006q3-21:1.42
	binutils-csl-sourcerygxx-4_1-22:1.42
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.42
	binutils-csl-sourcerygxx-4_1-20:1.42
	binutils-csl-arm-2006q3-19:1.42
	binutils-csl-sourcerygxx-4_1-19:1.42
	binutils-csl-sourcerygxx-4_1-18:1.42
	binutils-csl-renesas-4_1-9:1.42
	gdb-csl-sourcerygxx-3_4_4-25:1.41
	binutils-csl-sourcerygxx-3_4_4-25:1.30
	nickrob-async-20060828-mergepoint:1.44
	gdb-csl-symbian-6_4_50_20060226-11:1.41
	binutils-csl-renesas-4_1-8:1.42
	binutils-csl-renesas-4_1-7:1.42
	binutils-csl-renesas-4_1-6:1.42
	gdb-csl-sourcerygxx-4_1-17:1.41
	binutils-csl-sourcerygxx-4_1-17:1.42
	gdb-csl-20060226-branch-local-2:1.41
	gdb-csl-sourcerygxx-4_1-14:1.41
	binutils-csl-sourcerygxx-4_1-14:1.42
	binutils-csl-sourcerygxx-4_1-15:1.42
	gdb-csl-sourcerygxx-4_1-13:1.41
	binutils-csl-sourcerygxx-4_1-13:1.42
	binutils-2_17:1.42
	gdb-csl-sourcerygxx-4_1-12:1.41
	binutils-csl-sourcerygxx-4_1-12:1.42
	gdb-csl-sourcerygxx-3_4_4-21:1.41
	binutils-csl-sourcerygxx-3_4_4-21:1.42
	gdb_6_5-20060621-release:1.43
	binutils-csl-wrs-linux-3_4_4-24:1.30
	binutils-csl-wrs-linux-3_4_4-23:1.30
	gdb-csl-sourcerygxx-4_1-9:1.41
	binutils-csl-sourcerygxx-4_1-9:1.42
	gdb-csl-sourcerygxx-4_1-8:1.41
	binutils-csl-sourcerygxx-4_1-8:1.42
	gdb-csl-sourcerygxx-4_1-7:1.41
	binutils-csl-sourcerygxx-4_1-7:1.42
	gdb-csl-arm-2006q1-6:1.41
	binutils-csl-arm-2006q1-6:1.42
	gdb-csl-sourcerygxx-4_1-6:1.41
	binutils-csl-sourcerygxx-4_1-6:1.42
	binutils-csl-wrs-linux-3_4_4-22:1.30
	gdb-csl-symbian-6_4_50_20060226-10:1.41
	gdb-csl-symbian-6_4_50_20060226-9:1.41
	gdb-csl-symbian-6_4_50_20060226-8:1.41
	gdb-csl-coldfire-4_1-11:1.41
	binutils-csl-coldfire-4_1-11:1.42
	gdb-csl-sourcerygxx-3_4_4-19:1.41
	binutils-csl-sourcerygxx-3_4_4-19:1.42
	gdb-csl-coldfire-4_1-10:1.41
	gdb_6_5-branch:1.43.0.6
	gdb_6_5-2006-05-14-branchpoint:1.43
	binutils-csl-coldfire-4_1-10:1.42
	gdb-csl-sourcerygxx-4_1-5:1.41
	binutils-csl-sourcerygxx-4_1-5:1.42
	nickrob-async-20060513-branch:1.43.0.4
	nickrob-async-20060513-branchpoint:1.43
	gdb-csl-sourcerygxx-4_1-4:1.41
	binutils-csl-sourcerygxx-4_1-4:1.42
	msnyder-reverse-20060502-branch:1.43.0.2
	msnyder-reverse-20060502-branchpoint:1.43
	binutils-csl-wrs-linux-3_4_4-21:1.30
	gdb-csl-morpho-4_1-4:1.41
	binutils-csl-morpho-4_1-4:1.42
	gdb-csl-sourcerygxx-3_4_4-17:1.41
	binutils-csl-sourcerygxx-3_4_4-17:1.42
	binutils-csl-wrs-linux-3_4_4-20:1.30
	readline_5_1-import-branch:1.42.0.8
	readline_5_1-import-branchpoint:1.42
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.41
	binutils-2_17-branch:1.42.0.6
	binutils-2_17-branchpoint:1.42
	gdb-csl-symbian-20060226-branch:1.41.0.10
	gdb-csl-symbian-20060226-branchpoint:1.41
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.41
	msnyder-reverse-20060331-branch:1.42.0.4
	msnyder-reverse-20060331-branchpoint:1.42
	binutils-csl-2_17-branch:1.42.0.2
	binutils-csl-2_17-branchpoint:1.42
	gdb-csl-available-20060303-branch:1.41.0.8
	gdb-csl-available-20060303-branchpoint:1.41
	gdb-csl-20060226-branch:1.41.0.6
	gdb-csl-20060226-branchpoint:1.41
	gdb_6_4-20051202-release:1.40.4.1
	msnyder-fork-checkpoint-branch:1.41.0.4
	msnyder-fork-checkpoint-branchpoint:1.41
	gdb-csl-gxxpro-6_3-branch:1.41.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.41
	gdb_6_4-branch:1.40.0.4
	gdb_6_4-2005-11-01-branchpoint:1.40
	gdb-csl-arm-20051020-branch:1.40.0.2
	gdb-csl-arm-20051020-branchpoint:1.40
	binutils-csl-gxxpro-3_4-branch:1.30.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.30
	binutils-2_16_1:1.30
	msnyder-tracepoint-checkpoint-branch:1.33.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.33
	gdb-csl-arm-20050325-2005-q1b:1.30
	binutils-csl-arm-2005q1b:1.30
	binutils-2_16:1.30
	gdb-csl-arm-20050325-2005-q1a:1.30
	binutils-csl-arm-2005q1a:1.30
	csl-arm-20050325-branch:1.30.0.6
	csl-arm-20050325-branchpoint:1.30
	binutils-csl-arm-2005q1-branch:1.30.0.4
	binutils-csl-arm-2005q1-branchpoint:1.30
	binutils-2_16-branch:1.30.0.2
	binutils-2_16-branchpoint:1.30
	csl-arm-2004-q3d:1.26
	gdb_6_3-20041109-release:1.25
	gdb_6_3-branch:1.25.0.2
	gdb_6_3-20041019-branchpoint:1.25
	csl-arm-2004-q3:1.24
	drow_intercu-merge-20040921:1.24
	drow_intercu-merge-20040915:1.24
	jimb-gdb_6_2-e500-branch:1.24.0.6
	jimb-gdb_6_2-e500-branchpoint:1.24
	gdb_6_2-20040730-release:1.24
	gdb_6_2-branch:1.24.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.24
	gdb_6_1_1-20040616-release:1.21
	binutils-2_15:1.21
	binutils-2_15-branchpoint:1.21
	csl-arm-2004-q1a:1.23
	csl-arm-2004-q1:1.21
	gdb_6_1-2004-04-05-release:1.21
	drow_intercu-merge-20040402:1.21
	drow_intercu-merge-20040327:1.21
	ezannoni_pie-20040323-branch:1.21.0.14
	ezannoni_pie-20040323-branchpoint:1.21
	cagney_tramp-20040321-mergepoint:1.21
	cagney_tramp-20040309-branch:1.21.0.12
	cagney_tramp-20040309-branchpoint:1.21
	gdb_6_1-branch:1.21.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.21
	drow_intercu-20040221-branch:1.21.0.8
	drow_intercu-20040221-branchpoint:1.21
	binutils-2_15-branch:1.21.0.6
	cagney_bfdfile-20040213-branch:1.21.0.4
	cagney_bfdfile-20040213-branchpoint:1.21
	drow-cplus-merge-20040208:1.21
	carlton_dictionary-20040126-merge:1.21
	cagney_bigcore-20040122-branch:1.21.0.2
	cagney_bigcore-20040122-branchpoint:1.21
	drow-cplus-merge-20040113:1.20
	csl-arm-2003-q4:1.20
	drow-cplus-merge-20031224:1.20
	drow-cplus-merge-20031220:1.20
	carlton_dictionary-20031215-merge:1.20
	drow-cplus-merge-20031214:1.20
	carlton-dictionary-20031111-merge:1.19
	gdb_6_0-2003-10-04-release:1.16
	kettenis_sparc-20030918-branch:1.18.0.6
	kettenis_sparc-20030918-branchpoint:1.18
	carlton_dictionary-20030917-merge:1.18
	ezannoni_pie-20030916-branchpoint:1.18
	ezannoni_pie-20030916-branch:1.18.0.4
	cagney_x86i386-20030821-branch:1.18.0.2
	cagney_x86i386-20030821-branchpoint:1.18
	carlton_dictionary-20030805-merge:1.18
	carlton_dictionary-20030627-merge:1.17
	gdb_6_0-branch:1.16.0.4
	gdb_6_0-2003-06-23-branchpoint:1.16
	jimb-ppc64-linux-20030613-branch:1.16.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.16
	binutils-2_14:1.15
	cagney_convert-20030606-branch:1.15.0.18
	cagney_convert-20030606-branchpoint:1.15
	cagney_writestrings-20030508-branch:1.15.0.16
	cagney_writestrings-20030508-branchpoint:1.15
	jimb-ppc64-linux-20030528-branch:1.15.0.14
	jimb-ppc64-linux-20030528-branchpoint:1.15
	carlton_dictionary-20030523-merge:1.15
	cagney_fileio-20030521-branch:1.15.0.12
	cagney_fileio-20030521-branchpoint:1.15
	kettenis_i386newframe-20030517-mergepoint:1.15
	jimb-ppc64-linux-20030509-branch:1.15.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.15
	kettenis_i386newframe-20030504-mergepoint:1.15
	carlton_dictionary-20030430-merge:1.15
	binutils-2_14-branch:1.15.0.8
	binutils-2_14-branchpoint:1.15
	kettenis_i386newframe-20030419-branch:1.15.0.6
	kettenis_i386newframe-20030419-branchpoint:1.15
	carlton_dictionary-20030416-merge:1.15
	cagney_frameaddr-20030409-mergepoint:1.15
	kettenis_i386newframe-20030406-branch:1.15.0.4
	kettenis_i386newframe-20030406-branchpoint:1.15
	cagney_frameaddr-20030403-branchpoint:1.15
	cagney_frameaddr-20030403-branch:1.15.0.2
	cagney_framebase-20030330-mergepoint:1.14
	cagney_framebase-20030326-branch:1.14.0.12
	cagney_framebase-20030326-branchpoint:1.14
	cagney_lazyid-20030317-branch:1.14.0.10
	cagney_lazyid-20030317-branchpoint:1.14
	kettenis-i386newframe-20030316-mergepoint:1.14
	offbyone-20030313-branch:1.14.0.8
	offbyone-20030313-branchpoint:1.14
	kettenis-i386newframe-20030308-branch:1.14.0.6
	kettenis-i386newframe-20030308-branchpoint:1.14
	carlton_dictionary-20030305-merge:1.14
	cagney_offbyone-20030303-branch:1.14.0.4
	cagney_offbyone-20030303-branchpoint:1.14
	carlton_dictionary-20030207-merge:1.14
	interps-20030202-branch:1.14.0.2
	interps-20030202-branchpoint:1.14
	cagney-unwind-20030108-branch:1.12.0.2
	cagney-unwind-20030108-branchpoint:1.12
	binutils-2_13_2_1:1.10
	binutils-2_13_2:1.10
	carlton_dictionary-20021223-merge:1.12
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.11
	binutils-2_13_1:1.10
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.10.0.14
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.12
	carlton_dictionary-20020920-branchpoint:1.10
	sid-20020905-branchpoint:1.10
	sid-20020905-branch:1.10.0.10
	gdb_5_3-branch:1.10.0.8
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.6
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.4
	readline_4_3-import-branchpoint:1.10
	binutils-2_13:1.10
	gdb_5_2_1-2002-07-23-release:1.6
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	kseitz_interps-20020528-branch:1.9.0.6
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.4
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.6.2.2
	jimb-macro-020506-branch:1.9.0.2
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.6
	binutils-2_12:1.6
	gdb_5_2-branch:1.6.0.4
	gdb_5_2-2002-03-03-branchpoint:1.6
	binutils-2_12-branch:1.6.0.2
	binutils-2_12-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.2
	binutils-2_10_1:1.1.1.1.2.1
	binutils-2_10:1.1.1.1.2.1
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.85
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.85
date	2013.10.09.15.50.39;	author tromey;	state Exp;
branches;
next	1.84;

1.84
date	2013.10.09.14.26.26;	author tromey;	state Exp;
branches;
next	1.83;

1.83
date	2013.10.08.19.56.14;	author tromey;	state Exp;
branches;
next	1.82;

1.82
date	2013.05.29.14.58.35;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2013.04.17.14.16.01;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2013.03.14.20.11.11;	author tromey;	state Exp;
branches;
next	1.79;

1.79
date	2013.01.26.02.08.01;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2013.01.14.13.14.08;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2013.01.10.20.03.54;	author hjl;	state Exp;
branches;
next	1.76;

1.76
date	2012.11.09.08.29.29;	author hjl;	state Exp;
branches;
next	1.75;

1.75
date	2012.11.07.00.55.04;	author hjl;	state Exp;
branches;
next	1.74;

1.74
date	2012.11.06.09.31.12;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2012.08.20.14.32.31;	author tromey;	state Exp;
branches;
next	1.72;

1.72
date	2012.08.09.06.25.53;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2012.08.07.13.47.15;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2012.08.03.20.09.53;	author tromey;	state Exp;
branches;
next	1.69;

1.69
date	2012.05.29.14.23.33;	author tromey;	state Exp;
branches
	1.69.4.1;
next	1.68;

1.68
date	2011.06.27.08.41.00;	author gingold;	state Exp;
branches;
next	1.67;

1.67
date	2011.04.17.23.15.12;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2010.10.25.07.02.19;	author amodra;	state Exp;
branches
	1.66.2.1;
next	1.65;

1.65
date	2010.10.25.06.14.30;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2010.05.26.07.37.36;	author gingold;	state Exp;
branches;
next	1.63;

1.63
date	2009.12.15.16.59.19;	author hjl;	state Exp;
branches;
next	1.62;

1.62
date	2009.12.15.02.02.39;	author dougkwan;	state Exp;
branches;
next	1.61;

1.61
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2009.10.20.00.49.31;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.16.07.14.43;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2009.09.09.21.38.58;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2009.08.16.17.32.35;	author devans;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.12.12.04.19;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.11.00.41.03;	author ppluzhnikov;	state Exp;
branches;
next	1.53;

1.53
date	2008.08.23.08.08.58;	author schwab;	state Exp;
branches;
next	1.52;

1.52
date	2008.03.28.06.49.44;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.15.05.20.30;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2007.09.14.07.54.10;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.09.14.22.03;	author jkratoch;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.24.19.58.06;	author msnyder;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2006.12.15.04.13.34;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.25.17.46.15;	author hjl;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.03.16.06.11;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.05.21.24.23;	author bwilson;	state Exp;
branches
	1.40.4.1;
next	1.39;

1.39
date	2005.07.05.09.44.19;	author jakub;	state Exp;
branches;
next	1.38;

1.38
date	2005.06.09.07.30.19;	author mmitchel;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.08.03.51.32;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2005.06.08.03.16.48;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2005.06.08.00.00.05;	author mmitchel;	state Exp;
branches;
next	1.34;

1.34
date	2005.06.07.22.53.32;	author mmitchel;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.04.15.53.36;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.04.07.19.34;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.03.01.05.02;	author hjl;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.07.10.32.38;	author jakub;	state Exp;
branches
	1.30.6.1;
next	1.29;

1.29
date	2005.02.23.03.49.41;	author bje;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.20.14.59.07;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.31.23.13.28;	author bje;	state Exp;
branches;
next	1.26;

1.26
date	2004.10.24.18.45.38;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.10.13.58.05;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.24.04.46.25;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.23.00.22.57;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.21.17.05.12;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.21.11.17.53;	author nickc;	state Exp;
branches
	1.21.8.1;
next	1.20;

1.20
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.20.14.38.39;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.29.10.06.39;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.27.08.01.28;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.12.07.23.30;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.31.18.13.25;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.31.10.04.16;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.27.23.40.39;	author aoliva;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.06.09.03.06;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.17.02.33.42;	author amodra;	state Exp;
branches
	1.10.12.1
	1.10.14.1;
next	1.9;

1.9
date	2002.05.04.01.31.08;	author amodra;	state Exp;
branches
	1.9.4.1
	1.9.6.1;
next	1.8;

1.8
date	2002.04.26.13.43.10;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.15.14.32.28;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.17.00.40.53;	author amodra;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.09.18.09.57.25;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.14.06.12.07;	author amodra;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.05.26.07.32.26;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.69.4.1
date	2013.01.21.13.48.37;	author amodra;	state Exp;
branches;
next	;

1.66.2.1
date	2011.04.27.07.17.41;	author amodra;	state Exp;
branches;
next	;

1.57.2.1
date	2009.09.09.21.40.19;	author nickc;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2009.10.16.10.02.44;	author gingold;	state Exp;
branches;
next	1.57.2.3;

1.57.2.3
date	2009.10.20.08.40.36;	author amodra;	state Exp;
branches;
next	;

1.48.2.1
date	2007.10.12.14.10.28;	author drow;	state Exp;
branches;
next	;

1.40.4.1
date	2005.11.03.19.53.30;	author drow;	state Exp;
branches;
next	;

1.30.6.1
date	2005.06.07.22.56.33;	author mmitchel;	state Exp;
branches;
next	1.30.6.2;

1.30.6.2
date	2005.06.08.00.04.04;	author mmitchel;	state Exp;
branches;
next	1.30.6.3;

1.30.6.3
date	2005.06.08.03.46.19;	author mmitchel;	state Exp;
branches;
next	1.30.6.4;

1.30.6.4
date	2005.06.09.07.39.08;	author mmitchel;	state Exp;
branches;
next	;

1.21.8.1
date	2004.09.16.17.00.36;	author drow;	state Exp;
branches;
next	;

1.10.12.1
date	2002.10.11.22.22.50;	author carlton;	state Exp;
branches;
next	1.10.12.2;

1.10.12.2
date	2002.12.23.19.37.56;	author carlton;	state Exp;
branches;
next	1.10.12.3;

1.10.12.3
date	2003.02.07.19.17.40;	author carlton;	state Exp;
branches;
next	1.10.12.4;

1.10.12.4
date	2003.04.16.19.56.46;	author carlton;	state Exp;
branches;
next	1.10.12.5;

1.10.12.5
date	2003.06.27.21.49.29;	author carlton;	state Exp;
branches;
next	1.10.12.6;

1.10.12.6
date	2003.08.05.17.12.55;	author carlton;	state Exp;
branches;
next	1.10.12.7;

1.10.12.7
date	2003.11.11.23.50.28;	author carlton;	state Exp;
branches;
next	1.10.12.8;

1.10.12.8
date	2003.12.15.23.59.51;	author carlton;	state Exp;
branches;
next	1.10.12.9;

1.10.12.9
date	2004.01.26.19.11.10;	author carlton;	state Exp;
branches;
next	;

1.10.14.1
date	2002.10.26.17.12.00;	author drow;	state Exp;
branches;
next	1.10.14.2;

1.10.14.2
date	2003.12.14.20.26.50;	author drow;	state Exp;
branches;
next	1.10.14.3;

1.10.14.3
date	2004.02.09.19.43.25;	author drow;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.21.15.56.26;	author cagney;	state Exp;
branches;
next	;

1.9.6.1
date	2002.06.20.01.31.05;	author kseitz;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2002.11.03.22.01.37;	author ezannoni;	state Exp;
branches;
next	;

1.6.2.1
date	2002.04.27.08.30.15;	author amodra;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.05.09.11.50.34;	author amodra;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.05.26.07.38.31;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.85
log
@	* opncls.c (get_alt_debug_link_info_shim): Update type of 'len'.
@
text
@/* opncls.c -- open and close a BFD.
   Copyright 1990-2013 Free Software Foundation, Inc.

   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "objalloc.h"
#include "libbfd.h"
#include "libiberty.h"

#ifndef S_IXUSR
#define S_IXUSR 0100	/* Execute by owner.  */
#endif
#ifndef S_IXGRP
#define S_IXGRP 0010	/* Execute by group.  */
#endif
#ifndef S_IXOTH
#define S_IXOTH 0001	/* Execute by others.  */
#endif

/* Counters used to initialize the bfd identifier.  */

static unsigned int bfd_id_counter = 0;
static unsigned int bfd_reserved_id_counter = 0;

/*
CODE_FRAGMENT
.{* Set to N to open the next N BFDs using an alternate id space.  *}
.extern unsigned int bfd_use_reserved_id;
*/
unsigned int bfd_use_reserved_id = 0;

/* fdopen is a loser -- we should use stdio exclusively.  Unfortunately
   if we do that we can't use fcntl.  */

/* Return a new BFD.  All BFD's are allocated through this routine.  */

bfd *
_bfd_new_bfd (void)
{
  bfd *nbfd;

  nbfd = (bfd *) bfd_zmalloc (sizeof (bfd));
  if (nbfd == NULL)
    return NULL;

  if (bfd_use_reserved_id)
    {
      nbfd->id = --bfd_reserved_id_counter;
      --bfd_use_reserved_id;
    }
  else
    nbfd->id = bfd_id_counter++;

  nbfd->memory = objalloc_create ();
  if (nbfd->memory == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      free (nbfd);
      return NULL;
    }

  nbfd->arch_info = &bfd_default_arch_struct;

  nbfd->direction = no_direction;
  nbfd->iostream = NULL;
  nbfd->where = 0;
  if (!bfd_hash_table_init_n (& nbfd->section_htab, bfd_section_hash_newfunc,
			      sizeof (struct section_hash_entry), 13))
    {
      free (nbfd);
      return NULL;
    }
  nbfd->sections = NULL;
  nbfd->section_last = NULL;
  nbfd->format = bfd_unknown;
  nbfd->my_archive = NULL;
  nbfd->origin = 0;
  nbfd->opened_once = FALSE;
  nbfd->output_has_begun = FALSE;
  nbfd->section_count = 0;
  nbfd->usrdata = NULL;
  nbfd->cacheable = FALSE;
  nbfd->flags = BFD_NO_FLAGS;
  nbfd->mtime_set = FALSE;

  return nbfd;
}

static const struct bfd_iovec opncls_iovec;

/* Allocate a new BFD as a member of archive OBFD.  */

bfd *
_bfd_new_bfd_contained_in (bfd *obfd)
{
  bfd *nbfd;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;
  nbfd->xvec = obfd->xvec;
  nbfd->iovec = obfd->iovec;
  if (obfd->iovec == &opncls_iovec)
    nbfd->iostream = obfd->iostream;
  nbfd->my_archive = obfd;
  nbfd->direction = read_direction;
  nbfd->target_defaulted = obfd->target_defaulted;
  return nbfd;
}

/* Delete a BFD.  */

static void
_bfd_delete_bfd (bfd *abfd)
{
  if (abfd->memory)
    {
      bfd_hash_table_free (&abfd->section_htab);
      objalloc_free ((struct objalloc *) abfd->memory);
    }

  free (abfd->arelt_data);
  free (abfd);
}

/* Free objalloc memory.  */

bfd_boolean
_bfd_free_cached_info (bfd *abfd)
{
  if (abfd->memory)
    {
      bfd_hash_table_free (&abfd->section_htab);
      objalloc_free ((struct objalloc *) abfd->memory);

      abfd->sections = NULL;
      abfd->section_last = NULL;
      abfd->outsymbols = NULL;
      abfd->tdata.any = NULL;
      abfd->usrdata = NULL;
      abfd->memory = NULL;
    }

  return TRUE;
}

/*
SECTION
	Opening and closing BFDs

SUBSECTION
	Functions for opening and closing
*/

/*
FUNCTION
	bfd_fopen

SYNOPSIS
	bfd *bfd_fopen (const char *filename, const char *target,
                        const char *mode, int fd);

DESCRIPTION
	Open the file @@var{filename} with the target @@var{target}.
	Return a pointer to the created BFD.  If @@var{fd} is not -1,
	then <<fdopen>> is used to open the file; otherwise, <<fopen>>
	is used.  @@var{mode} is passed directly to <<fopen>> or
	<<fdopen>>.

	Calls <<bfd_find_target>>, so @@var{target} is interpreted as by
	that function.

	The new BFD is marked as cacheable iff @@var{fd} is -1.

	If <<NULL>> is returned then an error has occured.   Possible errors
	are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> or
	<<system_call>> error.

	On error, @@var{fd} is always closed.
*/

bfd *
bfd_fopen (const char *filename, const char *target, const char *mode, int fd)
{
  bfd *nbfd;
  const bfd_target *target_vec;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    {
      if (fd != -1)
	close (fd);
      return NULL;
    }

  target_vec = bfd_find_target (target, nbfd);
  if (target_vec == NULL)
    {
      if (fd != -1)
	close (fd);
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

#ifdef HAVE_FDOPEN
  if (fd != -1)
    nbfd->iostream = fdopen (fd, mode);
  else
#endif
    nbfd->iostream = real_fopen (filename, mode);
  if (nbfd->iostream == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  /* OK, put everything where it belongs.  */
  nbfd->filename = filename;

  /* Figure out whether the user is opening the file for reading,
     writing, or both, by looking at the MODE argument.  */
  if ((mode[0] == 'r' || mode[0] == 'w' || mode[0] == 'a')
      && mode[1] == '+')
    nbfd->direction = both_direction;
  else if (mode[0] == 'r')
    nbfd->direction = read_direction;
  else
    nbfd->direction = write_direction;

  if (! bfd_cache_init (nbfd))
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }
  nbfd->opened_once = TRUE;

  /* If we opened the file by name, mark it cacheable; we can close it
     and reopen it later.  However, if a file descriptor was provided,
     then it may have been opened with special flags that make it
     unsafe to close and reopen the file.  */
  if (fd == -1)
    (void) bfd_set_cacheable (nbfd, TRUE);

  return nbfd;
}

/*
FUNCTION
	bfd_openr

SYNOPSIS
	bfd *bfd_openr (const char *filename, const char *target);

DESCRIPTION
	Open the file @@var{filename} (using <<fopen>>) with the target
	@@var{target}.  Return a pointer to the created BFD.

	Calls <<bfd_find_target>>, so @@var{target} is interpreted as by
	that function.

	If <<NULL>> is returned then an error has occured.   Possible errors
	are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> or
	<<system_call>> error.
*/

bfd *
bfd_openr (const char *filename, const char *target)
{
  return bfd_fopen (filename, target, FOPEN_RB, -1);
}

/* Don't try to `optimize' this function:

   o - We lock using stack space so that interrupting the locking
       won't cause a storage leak.
   o - We open the file stream last, since we don't want to have to
       close it if anything goes wrong.  Closing the stream means closing
       the file descriptor too, even though we didn't open it.  */
/*
FUNCTION
	bfd_fdopenr

SYNOPSIS
	bfd *bfd_fdopenr (const char *filename, const char *target, int fd);

DESCRIPTION
	<<bfd_fdopenr>> is to <<bfd_fopenr>> much like <<fdopen>> is to
	<<fopen>>.  It opens a BFD on a file already described by the
	@@var{fd} supplied.

	When the file is later <<bfd_close>>d, the file descriptor will
	be closed.  If the caller desires that this file descriptor be
	cached by BFD (opened as needed, closed as needed to free
	descriptors for other opens), with the supplied @@var{fd} used as
	an initial file descriptor (but subject to closure at any time),
	call bfd_set_cacheable(bfd, 1) on the returned BFD.  The default
	is to assume no caching; the file descriptor will remain open
	until <<bfd_close>>, and will not be affected by BFD operations
	on other files.

	Possible errors are <<bfd_error_no_memory>>,
	<<bfd_error_invalid_target>> and <<bfd_error_system_call>>.

	On error, @@var{fd} is closed.
*/

bfd *
bfd_fdopenr (const char *filename, const char *target, int fd)
{
  const char *mode;
#if defined(HAVE_FCNTL) && defined(F_GETFL)
  int fdflags;
#endif

#if ! defined(HAVE_FCNTL) || ! defined(F_GETFL)
  mode = FOPEN_RUB; /* Assume full access.  */
#else
  fdflags = fcntl (fd, F_GETFL, NULL);
  if (fdflags == -1)
    {
      int save = errno;

      close (fd);
      errno = save;
      bfd_set_error (bfd_error_system_call);
      return NULL;
    }

  /* (O_ACCMODE) parens are to avoid Ultrix header file bug.  */
  switch (fdflags & (O_ACCMODE))
    {
    case O_RDONLY: mode = FOPEN_RB; break;
    case O_WRONLY: mode = FOPEN_RUB; break;
    case O_RDWR:   mode = FOPEN_RUB; break;
    default: abort ();
    }
#endif

  return bfd_fopen (filename, target, mode, fd);
}

/*
FUNCTION
	bfd_openstreamr

SYNOPSIS
	bfd *bfd_openstreamr (const char *, const char *, void *);

DESCRIPTION

	Open a BFD for read access on an existing stdio stream.  When
	the BFD is passed to <<bfd_close>>, the stream will be closed.
*/

bfd *
bfd_openstreamr (const char *filename, const char *target, void *streamarg)
{
  FILE *stream = (FILE *) streamarg;
  bfd *nbfd;
  const bfd_target *target_vec;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;

  target_vec = bfd_find_target (target, nbfd);
  if (target_vec == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  nbfd->iostream = stream;
  nbfd->filename = filename;
  nbfd->direction = read_direction;

  if (! bfd_cache_init (nbfd))
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  return nbfd;
}

/*
FUNCTION
	bfd_openr_iovec

SYNOPSIS
        bfd *bfd_openr_iovec (const char *filename, const char *target,
                              void *(*open_func) (struct bfd *nbfd,
                                                  void *open_closure),
                              void *open_closure,
                              file_ptr (*pread_func) (struct bfd *nbfd,
                                                      void *stream,
                                                      void *buf,
                                                      file_ptr nbytes,
                                                      file_ptr offset),
                              int (*close_func) (struct bfd *nbfd,
                                                 void *stream),
			      int (*stat_func) (struct bfd *abfd,
					        void *stream,
					        struct stat *sb));

DESCRIPTION

        Create and return a BFD backed by a read-only @@var{stream}.
        The @@var{stream} is created using @@var{open_func}, accessed using
        @@var{pread_func} and destroyed using @@var{close_func}.

	Calls <<bfd_find_target>>, so @@var{target} is interpreted as by
	that function.

	Calls @@var{open_func} (which can call <<bfd_zalloc>> and
	<<bfd_get_filename>>) to obtain the read-only stream backing
	the BFD.  @@var{open_func} either succeeds returning the
	non-<<NULL>> @@var{stream}, or fails returning <<NULL>>
	(setting <<bfd_error>>).

	Calls @@var{pread_func} to request @@var{nbytes} of data from
	@@var{stream} starting at @@var{offset} (e.g., via a call to
	<<bfd_read>>).  @@var{pread_func} either succeeds returning the
	number of bytes read (which can be less than @@var{nbytes} when
	end-of-file), or fails returning -1 (setting <<bfd_error>>).

	Calls @@var{close_func} when the BFD is later closed using
	<<bfd_close>>.  @@var{close_func} either succeeds returning 0, or
	fails returning -1 (setting <<bfd_error>>).

	Calls @@var{stat_func} to fill in a stat structure for bfd_stat,
	bfd_get_size, and bfd_get_mtime calls.  @@var{stat_func} returns 0
	on success, or returns -1 on failure (setting <<bfd_error>>).

	If <<bfd_openr_iovec>> returns <<NULL>> then an error has
	occurred.  Possible errors are <<bfd_error_no_memory>>,
	<<bfd_error_invalid_target>> and <<bfd_error_system_call>>.

*/

struct opncls
{
  void *stream;
  file_ptr (*pread) (struct bfd *abfd, void *stream, void *buf,
		     file_ptr nbytes, file_ptr offset);
  int (*close) (struct bfd *abfd, void *stream);
  int (*stat) (struct bfd *abfd, void *stream, struct stat *sb);
  file_ptr where;
};

static file_ptr
opncls_btell (struct bfd *abfd)
{
  struct opncls *vec = (struct opncls *) abfd->iostream;
  return vec->where;
}

static int
opncls_bseek (struct bfd *abfd, file_ptr offset, int whence)
{
  struct opncls *vec = (struct opncls *) abfd->iostream;
  switch (whence)
    {
    case SEEK_SET: vec->where = offset; break;
    case SEEK_CUR: vec->where += offset; break;
    case SEEK_END: return -1;
    }
  return 0;
}

static file_ptr
opncls_bread (struct bfd *abfd, void *buf, file_ptr nbytes)
{
  struct opncls *vec = (struct opncls *) abfd->iostream;
  file_ptr nread = (vec->pread) (abfd, vec->stream, buf, nbytes, vec->where);
  if (nread < 0)
    return nread;
  vec->where += nread;
  return nread;
}

static file_ptr
opncls_bwrite (struct bfd *abfd ATTRIBUTE_UNUSED,
	      const void *where ATTRIBUTE_UNUSED,
	      file_ptr nbytes ATTRIBUTE_UNUSED)
{
  return -1;
}

static int
opncls_bclose (struct bfd *abfd)
{
  struct opncls *vec = (struct opncls *) abfd->iostream;
  /* Since the VEC's memory is bound to the bfd deleting the bfd will
     free it.  */
  int status = 0;
  if (vec->close != NULL)
    status = (vec->close) (abfd, vec->stream);
  abfd->iostream = NULL;
  return status;
}

static int
opncls_bflush (struct bfd *abfd ATTRIBUTE_UNUSED)
{
  return 0;
}

static int
opncls_bstat (struct bfd *abfd, struct stat *sb)
{
  struct opncls *vec = (struct opncls *) abfd->iostream;

  memset (sb, 0, sizeof (*sb));
  if (vec->stat == NULL)
    return 0;

  return (vec->stat) (abfd, vec->stream, sb);
}

static void *
opncls_bmmap (struct bfd *abfd ATTRIBUTE_UNUSED,
	      void *addr ATTRIBUTE_UNUSED,
	      bfd_size_type len ATTRIBUTE_UNUSED,
	      int prot ATTRIBUTE_UNUSED,
	      int flags ATTRIBUTE_UNUSED,
	      file_ptr offset ATTRIBUTE_UNUSED,
              void **map_addr ATTRIBUTE_UNUSED,
              bfd_size_type *map_len ATTRIBUTE_UNUSED)
{
  return (void *) -1;
}

static const struct bfd_iovec opncls_iovec = {
  &opncls_bread, &opncls_bwrite, &opncls_btell, &opncls_bseek,
  &opncls_bclose, &opncls_bflush, &opncls_bstat, &opncls_bmmap
};

bfd *
bfd_openr_iovec (const char *filename, const char *target,
		 void *(*open_p) (struct bfd *, void *),
		 void *open_closure,
		 file_ptr (*pread_p) (struct bfd *, void *, void *,
				      file_ptr, file_ptr),
		 int (*close_p) (struct bfd *, void *),
		 int (*stat_p) (struct bfd *, void *, struct stat *))
{
  bfd *nbfd;
  const bfd_target *target_vec;
  struct opncls *vec;
  void *stream;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;

  target_vec = bfd_find_target (target, nbfd);
  if (target_vec == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  nbfd->filename = filename;
  nbfd->direction = read_direction;

  /* `open_p (...)' would get expanded by an the open(2) syscall macro.  */
  stream = (*open_p) (nbfd, open_closure);
  if (stream == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  vec = (struct opncls *) bfd_zalloc (nbfd, sizeof (struct opncls));
  vec->stream = stream;
  vec->pread = pread_p;
  vec->close = close_p;
  vec->stat = stat_p;

  nbfd->iovec = &opncls_iovec;
  nbfd->iostream = vec;

  return nbfd;
}

/* bfd_openw -- open for writing.
   Returns a pointer to a freshly-allocated BFD on success, or NULL.

   See comment by bfd_fdopenr before you try to modify this function.  */

/*
FUNCTION
	bfd_openw

SYNOPSIS
	bfd *bfd_openw (const char *filename, const char *target);

DESCRIPTION
	Create a BFD, associated with file @@var{filename}, using the
	file format @@var{target}, and return a pointer to it.

	Possible errors are <<bfd_error_system_call>>, <<bfd_error_no_memory>>,
	<<bfd_error_invalid_target>>.
*/

bfd *
bfd_openw (const char *filename, const char *target)
{
  bfd *nbfd;
  const bfd_target *target_vec;

  /* nbfd has to point to head of malloc'ed block so that bfd_close may
     reclaim it correctly.  */
  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;

  target_vec = bfd_find_target (target, nbfd);
  if (target_vec == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  nbfd->filename = filename;
  nbfd->direction = write_direction;

  if (bfd_open_file (nbfd) == NULL)
    {
      /* File not writeable, etc.  */
      bfd_set_error (bfd_error_system_call);
      _bfd_delete_bfd (nbfd);
      return NULL;
  }

  return nbfd;
}

static inline void
_maybe_make_executable (bfd * abfd)
{
  /* If the file was open for writing and is now executable,
     make it so.  */
  if (abfd->direction == write_direction
      && (abfd->flags & (EXEC_P | DYNAMIC)) != 0)
    {
      struct stat buf;

      if (stat (abfd->filename, &buf) == 0
	  /* Do not attempt to change non-regular files.  This is
	     here especially for configure scripts and kernel builds
	     which run tests with "ld [...] -o /dev/null".  */
	  && S_ISREG(buf.st_mode))
	{
	  unsigned int mask = umask (0);

	  umask (mask);
	  chmod (abfd->filename,
		 (0777
		  & (buf.st_mode | ((S_IXUSR | S_IXGRP | S_IXOTH) &~ mask))));
	}
    }
}

/*

FUNCTION
	bfd_close

SYNOPSIS
	bfd_boolean bfd_close (bfd *abfd);

DESCRIPTION

	Close a BFD. If the BFD was open for writing, then pending
	operations are completed and the file written out and closed.
	If the created file is executable, then <<chmod>> is called
	to mark it as such.

	All memory attached to the BFD is released.

	The file descriptor associated with the BFD is closed (even
	if it was passed in to BFD by <<bfd_fdopenr>>).

RETURNS
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
*/


bfd_boolean
bfd_close (bfd *abfd)
{
  bfd_boolean ret;

  if (bfd_write_p (abfd))
    {
      if (! BFD_SEND_FMT (abfd, _bfd_write_contents, (abfd)))
	return FALSE;
    }

  if (! BFD_SEND (abfd, _close_and_cleanup, (abfd)))
    return FALSE;

  ret = abfd->iovec->bclose (abfd) == 0;

  if (ret)
    _maybe_make_executable (abfd);

  _bfd_delete_bfd (abfd);

  return ret;
}

/*
FUNCTION
	bfd_close_all_done

SYNOPSIS
	bfd_boolean bfd_close_all_done (bfd *);

DESCRIPTION
	Close a BFD.  Differs from <<bfd_close>> since it does not
	complete any pending operations.  This routine would be used
	if the application had just used BFD for swapping and didn't
	want to use any of the writing code.

	If the created file is executable, then <<chmod>> is called
	to mark it as such.

	All memory attached to the BFD is released.

RETURNS
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
*/

bfd_boolean
bfd_close_all_done (bfd *abfd)
{
  bfd_boolean ret;

  ret = bfd_cache_close (abfd);

  if (ret)
    _maybe_make_executable (abfd);

  _bfd_delete_bfd (abfd);

  return ret;
}

/*
FUNCTION
	bfd_create

SYNOPSIS
	bfd *bfd_create (const char *filename, bfd *templ);

DESCRIPTION
	Create a new BFD in the manner of <<bfd_openw>>, but without
	opening a file. The new BFD takes the target from the target
	used by @@var{templ}. The format is always set to <<bfd_object>>.
*/

bfd *
bfd_create (const char *filename, bfd *templ)
{
  bfd *nbfd;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;
  nbfd->filename = filename;
  if (templ)
    nbfd->xvec = templ->xvec;
  nbfd->direction = no_direction;
  bfd_set_format (nbfd, bfd_object);

  return nbfd;
}

/*
FUNCTION
	bfd_make_writable

SYNOPSIS
	bfd_boolean bfd_make_writable (bfd *abfd);

DESCRIPTION
	Takes a BFD as created by <<bfd_create>> and converts it
	into one like as returned by <<bfd_openw>>.  It does this
	by converting the BFD to BFD_IN_MEMORY.  It's assumed that
	you will call <<bfd_make_readable>> on this bfd later.

RETURNS
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
*/

bfd_boolean
bfd_make_writable (bfd *abfd)
{
  struct bfd_in_memory *bim;

  if (abfd->direction != no_direction)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  bim = (struct bfd_in_memory *) bfd_malloc (sizeof (struct bfd_in_memory));
  if (bim == NULL)
    return FALSE;	/* bfd_error already set.  */
  abfd->iostream = bim;
  /* bfd_bwrite will grow these as needed.  */
  bim->size = 0;
  bim->buffer = 0;

  abfd->flags |= BFD_IN_MEMORY;
  abfd->iovec = &_bfd_memory_iovec;
  abfd->origin = 0;
  abfd->direction = write_direction;
  abfd->where = 0;

  return TRUE;
}

/*
FUNCTION
	bfd_make_readable

SYNOPSIS
	bfd_boolean bfd_make_readable (bfd *abfd);

DESCRIPTION
	Takes a BFD as created by <<bfd_create>> and
	<<bfd_make_writable>> and converts it into one like as
	returned by <<bfd_openr>>.  It does this by writing the
	contents out to the memory buffer, then reversing the
	direction.

RETURNS
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.  */

bfd_boolean
bfd_make_readable (bfd *abfd)
{
  if (abfd->direction != write_direction || !(abfd->flags & BFD_IN_MEMORY))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  if (! BFD_SEND_FMT (abfd, _bfd_write_contents, (abfd)))
    return FALSE;

  if (! BFD_SEND (abfd, _close_and_cleanup, (abfd)))
    return FALSE;

  abfd->arch_info = &bfd_default_arch_struct;

  abfd->where = 0;
  abfd->format = bfd_unknown;
  abfd->my_archive = NULL;
  abfd->origin = 0;
  abfd->opened_once = FALSE;
  abfd->output_has_begun = FALSE;
  abfd->section_count = 0;
  abfd->usrdata = NULL;
  abfd->cacheable = FALSE;
  abfd->flags |= BFD_IN_MEMORY;
  abfd->mtime_set = FALSE;

  abfd->target_defaulted = TRUE;
  abfd->direction = read_direction;
  abfd->sections = 0;
  abfd->symcount = 0;
  abfd->outsymbols = 0;
  abfd->tdata.any = 0;

  bfd_section_list_clear (abfd);
  bfd_check_format (abfd, bfd_object);

  return TRUE;
}

/*
FUNCTION
	bfd_alloc

SYNOPSIS
	void *bfd_alloc (bfd *abfd, bfd_size_type wanted);

DESCRIPTION
	Allocate a block of @@var{wanted} bytes of memory attached to
	<<abfd>> and return a pointer to it.
*/

void *
bfd_alloc (bfd *abfd, bfd_size_type size)
{
  void *ret;

  if (size != (unsigned long) size)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  ret = objalloc_alloc ((struct objalloc *) abfd->memory, (unsigned long) size);
  if (ret == NULL)
    bfd_set_error (bfd_error_no_memory);
  return ret;
}

/*
INTERNAL_FUNCTION
	bfd_alloc2

SYNOPSIS
	void *bfd_alloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size);

DESCRIPTION
	Allocate a block of @@var{nmemb} elements of @@var{size} bytes each
	of memory attached to <<abfd>> and return a pointer to it.
*/

void *
bfd_alloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size)
{
  void *ret;

  if ((nmemb | size) >= HALF_BFD_SIZE_TYPE
      && size != 0
      && nmemb > ~(bfd_size_type) 0 / size)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  size *= nmemb;

  if (size != (unsigned long) size)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  ret = objalloc_alloc ((struct objalloc *) abfd->memory, (unsigned long) size);
  if (ret == NULL)
    bfd_set_error (bfd_error_no_memory);
  return ret;
}

/*
FUNCTION
	bfd_zalloc

SYNOPSIS
	void *bfd_zalloc (bfd *abfd, bfd_size_type wanted);

DESCRIPTION
	Allocate a block of @@var{wanted} bytes of zeroed memory
	attached to <<abfd>> and return a pointer to it.
*/

void *
bfd_zalloc (bfd *abfd, bfd_size_type size)
{
  void *res;

  res = bfd_alloc (abfd, size);
  if (res)
    memset (res, 0, (size_t) size);
  return res;
}

/*
INTERNAL_FUNCTION
	bfd_zalloc2

SYNOPSIS
	void *bfd_zalloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size);

DESCRIPTION
	Allocate a block of @@var{nmemb} elements of @@var{size} bytes each
	of zeroed memory attached to <<abfd>> and return a pointer to it.
*/

void *
bfd_zalloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size)
{
  void *res;

  if ((nmemb | size) >= HALF_BFD_SIZE_TYPE
      && size != 0
      && nmemb > ~(bfd_size_type) 0 / size)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  size *= nmemb;

  res = bfd_alloc (abfd, size);
  if (res)
    memset (res, 0, (size_t) size);
  return res;
}

/* Free a block allocated for a BFD.
   Note:  Also frees all more recently allocated blocks!  */

void
bfd_release (bfd *abfd, void *block)
{
  objalloc_free_block ((struct objalloc *) abfd->memory, block);
}


/*
   GNU Extension: separate debug-info files

   The idea here is that a special section called .gnu_debuglink might be
   embedded in a binary file, which indicates that some *other* file
   contains the real debugging information. This special section contains a
   filename and CRC32 checksum, which we read and resolve to another file,
   if it exists.

   This facilitates "optional" provision of debugging information, without
   having to provide two complete copies of every binary object (with and
   without debug symbols).  */

#define GNU_DEBUGLINK		".gnu_debuglink"
#define GNU_DEBUGALTLINK	".gnu_debugaltlink"

/*
FUNCTION
	bfd_calc_gnu_debuglink_crc32

SYNOPSIS
	unsigned long bfd_calc_gnu_debuglink_crc32
	  (unsigned long crc, const unsigned char *buf, bfd_size_type len);

DESCRIPTION
	Computes a CRC value as used in the .gnu_debuglink section.
	Advances the previously computed @@var{crc} value by computing
	and adding in the crc32 for @@var{len} bytes of @@var{buf}.

RETURNS
	Return the updated CRC32 value.
*/

unsigned long
bfd_calc_gnu_debuglink_crc32 (unsigned long crc,
			      const unsigned char *buf,
			      bfd_size_type len)
{
  static const unsigned long crc32_table[256] =
    {
      0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
      0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
      0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
      0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
      0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
      0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
      0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
      0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
      0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
      0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
      0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
      0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
      0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
      0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
      0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
      0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
      0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
      0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
      0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
      0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
      0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
      0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
      0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
      0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
      0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
      0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
      0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
      0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
      0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
      0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
      0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
      0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
      0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
      0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
      0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
      0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
      0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
      0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
      0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
      0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
      0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
      0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
      0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
      0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
      0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
      0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
      0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
      0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
      0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
      0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
      0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
      0x2d02ef8d
    };
  const unsigned char *end;

  crc = ~crc & 0xffffffff;
  for (end = buf + len; buf < end; ++ buf)
    crc = crc32_table[(crc ^ *buf) & 0xff] ^ (crc >> 8);
  return ~crc & 0xffffffff;
}


/*
FUNCTION
	bfd_get_debug_link_info

SYNOPSIS
	char *bfd_get_debug_link_info (bfd *abfd, unsigned long *crc32_out);

DESCRIPTION
	fetch the filename and CRC32 value for any separate debuginfo
	associated with @@var{abfd}. Return NULL if no such info found,
	otherwise return filename and update @@var{crc32_out}.  The
	returned filename is allocated with @@code{malloc}; freeing it
	is the responsibility of the caller.
*/

char *
bfd_get_debug_link_info (bfd *abfd, unsigned long *crc32_out)
{
  asection *sect;
  unsigned long crc32;
  bfd_byte *contents;
  int crc_offset;
  char *name;

  BFD_ASSERT (abfd);
  BFD_ASSERT (crc32_out);

  sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);

  if (sect == NULL)
    return NULL;

  if (!bfd_malloc_and_get_section (abfd, sect, &contents))
    {
      if (contents != NULL)
	free (contents);
      return NULL;
    }

  /* Crc value is stored after the filename, aligned up to 4 bytes.  */
  name = (char *) contents;
  crc_offset = strlen (name) + 1;
  crc_offset = (crc_offset + 3) & ~3;

  crc32 = bfd_get_32 (abfd, contents + crc_offset);

  *crc32_out = crc32;
  return name;
}

/*
FUNCTION
	bfd_get_alt_debug_link_info

SYNOPSIS
	char *bfd_get_alt_debug_link_info (bfd * abfd,
					   bfd_size_type *buildid_len,
			                   bfd_byte **buildid_out);

DESCRIPTION
	Fetch the filename and BuildID value for any alternate debuginfo
	associated with @@var{abfd}.  Return NULL if no such info found,
	otherwise return filename and update @@var{buildid_len} and
	@@var{buildid_out}.  The returned filename and build_id are
	allocated with @@code{malloc}; freeing them is the
	responsibility of the caller.
*/

char *
bfd_get_alt_debug_link_info (bfd * abfd, bfd_size_type *buildid_len,
			     bfd_byte **buildid_out)
{
  asection *sect;
  bfd_byte *contents;
  int buildid_offset;
  char *name;

  BFD_ASSERT (abfd);
  BFD_ASSERT (buildid_len);
  BFD_ASSERT (buildid_out);

  sect = bfd_get_section_by_name (abfd, GNU_DEBUGALTLINK);

  if (sect == NULL)
    return NULL;

  if (!bfd_malloc_and_get_section (abfd, sect, & contents))
    {
      if (contents != NULL)
	free (contents);
      return NULL;
    }

  /* BuildID value is stored after the filename.  */
  name = (char *) contents;
  buildid_offset = strlen (name) + 1;

  *buildid_len = bfd_get_section_size (sect) - buildid_offset;
  *buildid_out = bfd_malloc (*buildid_len);
  memcpy (*buildid_out, contents + buildid_offset, *buildid_len);

  return name;
}

/*
INTERNAL_FUNCTION
	separate_debug_file_exists

SYNOPSIS
	bfd_boolean separate_debug_file_exists
	  (char *name, unsigned long crc32);

DESCRIPTION
	Checks to see if @@var{name} is a file and if its contents
	match @@var{crc32}.
*/

static bfd_boolean
separate_debug_file_exists (const char *name, const unsigned long crc)
{
  static unsigned char buffer [8 * 1024];
  unsigned long file_crc = 0;
  FILE *f;
  bfd_size_type count;

  BFD_ASSERT (name);

  f = real_fopen (name, FOPEN_RB);
  if (f == NULL)
    return FALSE;

  while ((count = fread (buffer, 1, sizeof (buffer), f)) > 0)
    file_crc = bfd_calc_gnu_debuglink_crc32 (file_crc, buffer, count);

  fclose (f);

  return crc == file_crc;
}

/*
INTERNAL_FUNCTION
	separate_alt_debug_file_exists

SYNOPSIS
	bfd_boolean separate_alt_debug_file_exists
	  (char *name, unsigned long crc32);

DESCRIPTION
	Checks to see if @@var{name} is a file and if its BuildID
	matches @@var{buildid}.
*/

static bfd_boolean
separate_alt_debug_file_exists (const char *name,
				const unsigned long buildid ATTRIBUTE_UNUSED)
{
  FILE *f;

  BFD_ASSERT (name);

  f = real_fopen (name, FOPEN_RB);
  if (f == NULL)
    return FALSE;

  /* FIXME: Add code to check buildid.  */

  fclose (f);

  return TRUE;
}

/*
INTERNAL_FUNCTION
	find_separate_debug_file

SYNOPSIS
	char *find_separate_debug_file (bfd *abfd);

DESCRIPTION
	Searches @@var{abfd} for a section called @@var{section_name} which
	is expected to contain a reference to a file containing separate
	debugging information.  The function scans various locations in
	the filesystem, including the file tree rooted at
	@@var{debug_file_directory}, and returns the first matching
	filename that it finds.  If @@var{check_crc} is TRUE then the
	contents of the file must also match the CRC value contained in
	@@var{section_name}.  Returns NULL if no valid file could be found.
*/

typedef char *      (* get_func_type) (bfd *, unsigned long *);
typedef bfd_boolean (* check_func_type) (const char *, const unsigned long);

static char *
find_separate_debug_file (bfd *           abfd,
			  const char *    debug_file_directory,
			  get_func_type   get_func,
			  check_func_type check_func)
{
  char *base;
  char *dir;
  char *debugfile;
  char *canon_dir;
  unsigned long crc32;
  size_t dirlen;
  size_t canon_dirlen;

  BFD_ASSERT (abfd);
  if (debug_file_directory == NULL)
    debug_file_directory = ".";

  /* BFD may have been opened from a stream.  */
  if (abfd->filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  base = get_func (abfd, & crc32);
    
  if (base == NULL)
    return NULL;

  if (base[0] == '\0')
    {
      free (base);
      bfd_set_error (bfd_error_no_debug_section);
      return NULL;
    }

  for (dirlen = strlen (abfd->filename); dirlen > 0; dirlen--)
    if (IS_DIR_SEPARATOR (abfd->filename[dirlen - 1]))
      break;

  dir = (char *) bfd_malloc (dirlen + 1);
  if (dir == NULL)
    {
      free (base);
      return NULL;
    }
  memcpy (dir, abfd->filename, dirlen);
  dir[dirlen] = '\0';

  /* Compute the canonical name of the bfd object with all symbolic links
     resolved, for use in the global debugfile directory.  */
  canon_dir = lrealpath (abfd->filename);
  for (canon_dirlen = strlen (canon_dir); canon_dirlen > 0; canon_dirlen--)
    if (IS_DIR_SEPARATOR (canon_dir[canon_dirlen - 1]))
      break;
  canon_dir[canon_dirlen] = '\0';

  debugfile = (char *)
      bfd_malloc (strlen (debug_file_directory) + 1
                  + (canon_dirlen > dirlen ? canon_dirlen : dirlen)
                  + strlen (".debug/")
                  + strlen (base)
                  + 1);
  if (debugfile == NULL)
    goto found; /* Actually this returns NULL.  */

  /* First try in the same directory as the original file:  */
  strcpy (debugfile, dir);
  strcat (debugfile, base);

  if (check_func (debugfile, crc32))
    goto found;

  /* Then try in a subdirectory called .debug.  */
  strcpy (debugfile, dir);
  strcat (debugfile, ".debug/");
  strcat (debugfile, base);

  if (check_func (debugfile, crc32))
    goto found;

  /* Then try in the global debugfile directory.  */
  strcpy (debugfile, debug_file_directory);
  dirlen = strlen (debug_file_directory) - 1;
  if (dirlen > 0
      && debug_file_directory[dirlen] != '/'
      && canon_dir[0] != '/')
    strcat (debugfile, "/");
  strcat (debugfile, canon_dir);
  strcat (debugfile, base);

  if (check_func (debugfile, crc32))
    goto found;

  /* Failed to find the file.  */
  free (debugfile);
  debugfile = NULL;

 found:
  free (base);
  free (dir);
  free (canon_dir);
  return debugfile;
}


/*
FUNCTION
	bfd_follow_gnu_debuglink

SYNOPSIS
	char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);

DESCRIPTION

	Takes a BFD and searches it for a .gnu_debuglink section.  If this
	section is found, it examines the section for the name and checksum
	of a '.debug' file containing auxiliary debugging information.  It
	then searches the filesystem for this .debug file in some standard
	locations, including the directory tree rooted at @@var{dir}, and if
	found returns the full filename.

	If @@var{dir} is NULL, it will search a default path configured into
	libbfd at build time.  [XXX this feature is not currently
	implemented].

RETURNS
	<<NULL>> on any errors or failure to locate the .debug file,
	otherwise a pointer to a heap-allocated string containing the
	filename.  The caller is responsible for freeing this string.
*/

char *
bfd_follow_gnu_debuglink (bfd *abfd, const char *dir)
{
  return find_separate_debug_file (abfd, dir,
				   bfd_get_debug_link_info,
				   separate_debug_file_exists);
}

/* Helper for bfd_follow_gnu_debugaltlink.  It just pretends to return
   a CRC.  .gnu_debugaltlink supplies a build-id, which is different,
   but this is ok because separate_alt_debug_file_exists ignores the
   CRC anyway.  */

static char *
get_alt_debug_link_info_shim (bfd * abfd, unsigned long *crc32_out)
{
  bfd_size_type len;
  bfd_byte *buildid = NULL;
  char *result = bfd_get_alt_debug_link_info (abfd, &len, &buildid);

  *crc32_out = 0;
  free (buildid);

  return result;
}

/*
FUNCTION
	bfd_follow_gnu_debugaltlink

SYNOPSIS
	char *bfd_follow_gnu_debugaltlink (bfd *abfd, const char *dir);

DESCRIPTION

	Takes a BFD and searches it for a .gnu_debugaltlink section.  If this
	section is found, it examines the section for the name of a file
	containing auxiliary debugging information.  It	then searches the
	filesystem for this file in a set of standard locations, including
	the directory tree rooted at @@var{dir}, and if found returns the
	full filename.

	If @@var{dir} is NULL, it will search a default path configured into
	libbfd at build time.  [FIXME: This feature is not currently
	implemented].

RETURNS
	<<NULL>> on any errors or failure to locate the debug file,
	otherwise a pointer to a heap-allocated string containing the
	filename.  The caller is responsible for freeing this string.
*/

char *
bfd_follow_gnu_debugaltlink (bfd *abfd, const char *dir)
{
  return find_separate_debug_file (abfd, dir,
				   get_alt_debug_link_info_shim,
				   separate_alt_debug_file_exists);
}

/*
FUNCTION
	bfd_create_gnu_debuglink_section

SYNOPSIS
	struct bfd_section *bfd_create_gnu_debuglink_section
	  (bfd *abfd, const char *filename);

DESCRIPTION

	Takes a @@var{BFD} and adds a .gnu_debuglink section to it.  The section is sized
	to be big enough to contain a link to the specified @@var{filename}.

RETURNS
	A pointer to the new section is returned if all is ok.  Otherwise <<NULL>> is
	returned and bfd_error is set.
*/

asection *
bfd_create_gnu_debuglink_section (bfd *abfd, const char *filename)
{
  asection *sect;
  bfd_size_type debuglink_size;
  flagword flags;

  if (abfd == NULL || filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  /* Strip off any path components in filename.  */
  filename = lbasename (filename);

  sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);
  if (sect)
    {
      /* Section already exists.  */
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING;
  sect = bfd_make_section_with_flags (abfd, GNU_DEBUGLINK, flags);
  if (sect == NULL)
    return NULL;

  debuglink_size = strlen (filename) + 1;
  debuglink_size += 3;
  debuglink_size &= ~3;
  debuglink_size += 4;

  if (! bfd_set_section_size (abfd, sect, debuglink_size))
    /* XXX Should we delete the section from the bfd ?  */
    return NULL;

  return sect;
}


/*
FUNCTION
	bfd_fill_in_gnu_debuglink_section

SYNOPSIS
	bfd_boolean bfd_fill_in_gnu_debuglink_section
	  (bfd *abfd, struct bfd_section *sect, const char *filename);

DESCRIPTION

	Takes a @@var{BFD} and containing a .gnu_debuglink section @@var{SECT}
	and fills in the contents of the section to contain a link to the
	specified @@var{filename}.  The filename should be relative to the
	current directory.

RETURNS
	<<TRUE>> is returned if all is ok.  Otherwise <<FALSE>> is returned
	and bfd_error is set.
*/

bfd_boolean
bfd_fill_in_gnu_debuglink_section (bfd *abfd,
				   struct bfd_section *sect,
				   const char *filename)
{
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char * contents;
  bfd_size_type crc_offset;
  FILE * handle;
  static unsigned char buffer[8 * 1024];
  size_t count;
  size_t filelen;

  if (abfd == NULL || sect == NULL || filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Make sure that we can read the file.
     XXX - Should we attempt to locate the debug info file using the same
     algorithm as gdb ?  At the moment, since we are creating the
     .gnu_debuglink section, we insist upon the user providing us with a
     correct-for-section-creation-time path, but this need not conform to
     the gdb location algorithm.  */
  handle = real_fopen (filename, FOPEN_RB);
  if (handle == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      return FALSE;
    }

  crc32 = 0;
  while ((count = fread (buffer, 1, sizeof buffer, handle)) > 0)
    crc32 = bfd_calc_gnu_debuglink_crc32 (crc32, buffer, count);
  fclose (handle);

  /* Strip off any path components in filename,
     now that we no longer need them.  */
  filename = lbasename (filename);

  filelen = strlen (filename);
  debuglink_size = filelen + 1;
  debuglink_size += 3;
  debuglink_size &= ~3;
  debuglink_size += 4;

  contents = (char *) bfd_malloc (debuglink_size);
  if (contents == NULL)
    {
      /* XXX Should we delete the section from the bfd ?  */
      return FALSE;
    }

  crc_offset = debuglink_size - 4;
  memcpy (contents, filename, filelen);
  memset (contents + filelen, 0, crc_offset - filelen);

  bfd_put_32 (abfd, crc32, contents + crc_offset);

  if (! bfd_set_section_contents (abfd, sect, contents, 0, debuglink_size))
    {
      /* XXX Should we delete the section from the bfd ?  */
      free (contents);
      return FALSE;
    }

  return TRUE;
}
@


1.84
log
@bfd
	* bfd-in2.h: Rebuild.
	* opncls.c (bfd_get_alt_debug_link_info): Change type of
	buildid_len to bfd_size_type.
gdb
	* dwarf2read.c (dwarf2_get_dwz_file): Update for type change in
	bfd_get_alt_debug_link_info.
@
text
@d1483 1
a1483 1
  size_t len;
@


1.83
log
@fix PR symtab/15597

This patch fixes gdb PR symtab/15597.

The bug is that the .gnu_debugaltlink section includes the build-id of
the alt file, but gdb does not use it.

This patch fixes the problem by changing gdb to do what it ought to
always have done: verify the build id of the file found using the
filename in .gnu_debugaltlink; and if that does not match, try to find
the correct debug file using the build-id and debug-file-directory.

This patch touches BFD.  Previously, gdb had its own code for parsing
.gnu_debugaltlink; I changed it to use the BFD functions after those
were introduced.  However, the BFD functions are incorrect -- they
assume that .gnu_debugaltlink is formatted like .gnu_debuglink.
However, it it is not.  Instead, it consists of a file name followed
by the build-id -- no alignment, and the build-id is not a CRC.

Fixing this properly is a bit of a pain.  But, because
separate_alt_debug_file_exists just has a FIXME for the build-id case,
I did not fix it properly.  Instead I introduced a hack.  This leaves
BFD working just as well as it did before my patch.

I'm willing to do something better here but I could use some guidance
as to what.  It seems that the build-id code in BFD is largely punted
on.

FWIW gdb is the only user of bfd_get_alt_debug_link_info outside of
BFD itself.

I moved the build-id logic out of elfread.c and into a new file.
This seemed cleanest to me.

Writing a test case was a bit of a pain.  I added a couple new
features to the DWARF assembler to handle this.

Built and regtested on x86-64 Fedora 18.

	* bfd-in2.h: Rebuild.
	* opncls.c (bfd_get_alt_debug_link_info): Add buildid_len
	parameter.  Change type of buildid_out.  Update.
	(get_alt_debug_link_info_shim): New function.
	(bfd_follow_gnu_debuglink): Use it.

	* Makefile.in (SFILES): Add build-id.c.
	(HFILES_NO_SRCDIR): Add build-id.h.
	* build-id.c: New file, largely from elfread.c.  Modified
	most functions.
	* build-id.h: New file.
	* dwarf2read.c (dwarf2_get_dwz_file): Update for change to
	bfd_get_alt_debug_link_info.  Verify dwz file's build-id.
	Search for dwz file using build-id.
	* elfread.c (build_id_bfd_get, build_id_verify)
	(build_id_to_debug_filename, find_separate_debug_file): Remove.

	* gdb.dwarf2/dwzbuildid.exp: New file.
	* lib/dwarf.exp (Dwarf::_section): Add "flags" and "type"
	parameters.
	(Dwarf::_defer_output): Change "section" parameter to
	"section_spec"; update.
	(Dwarf::gnu_debugaltlink, Dwarf::_note, Dwarf::build_id): New
	procs.
@
text
@d1197 2
a1198 1
	char *bfd_get_alt_debug_link_info (bfd * abfd, size_t *buildid_len,
d1211 1
a1211 1
bfd_get_alt_debug_link_info (bfd * abfd, size_t *buildid_len,
@


1.82
log
@	* dwarf2.c (struct dwarf2_debug): Add fields for handling
	alternate debug info source.
	(dwarf_debug_sections): Add entries for alternate .debug_str and
	.debug_info sections.
	(dwarf_debug_section_enum): Likewise.
	(read_alt_indirect_string): New function.  Handles a
	DW_FORM_GNU_strp_alt attribute.
	(read_alt_indirect_ref): New function.  Handles a
	DW_FORM_GNU_ref_alt attribute.
	(read_attribute_value): Process DW_FORM_GNU_ref_alt and
	DW_FORM_GNU_strp_alt.
	(find_abstract_instance_name): Handle DW_FORM_GNU_ref_alt
	attributes.
	(_bfd_dwarf2_cleanup_debug_info): Free alternate debug info
	sources.
	* opncls.c (GNU_DEBUGALTLINK): Define.
	(bfd_get_alt_debug_link_info): New function.
	(separate_alt_debug_file_exists): New function.
	(find_separate_debug_file): Add parameters for fetch and check
	functions.
	(bfd_follow_gnu_debugaltlink): New function.
	* bfd-in2.h: Regenerate.
@
text
@d1197 2
a1198 1
	char *bfd_get_alt_debug_link_info (bfd *abfd, unsigned long *crc32_out);
d1203 4
a1206 3
	otherwise return filename and update @@var{buildid_out}.  The
	returned filename is allocated with @@code{malloc}; freeing it
	is the responsibility of the caller.
d1210 2
a1211 1
bfd_get_alt_debug_link_info (bfd * abfd, unsigned long * buildid_out)
d1219 1
d1234 1
a1234 1
  /* BuildID value is stored after the filename, aligned up to 4 bytes.  */
a1236 1
  buildid_offset = (buildid_offset + 3) & ~3;
d1238 3
a1240 1
  * buildid_out = bfd_get_32 (abfd, contents + buildid_offset);
d1474 18
d1522 1
a1522 1
				   bfd_get_alt_debug_link_info,
@


1.81
log
@	* coffcode.h: Added a cast to void when a bfd_set_section_*()
	macro's return value is ignored.
	* elf32-hppa.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* mach-o.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* peicode.h: Likewise.
	* elf32-m32r.c: Check return value of bfd_set_section_*().
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* vms-alpha.c: Likewise.
@
text
@d1051 4
a1054 2
   without debug symbols).
*/
a1055 1
#define GNU_DEBUGLINK	".gnu_debuglink"
d1193 48
d1275 31
d1315 8
a1322 6
	Searches @@var{abfd} for a reference to separate debugging
	information, scans various locations in the filesystem, including
	the file tree rooted at @@var{debug_file_directory}, and returns a
	filename of such debugging information if the file is found and has
	matching CRC32.  Returns NULL if no reference to debugging file
	exists, or file cannot be found.
d1325 3
d1329 4
a1332 1
find_separate_debug_file (bfd *abfd, const char *debug_file_directory)
d1353 2
a1354 1
  base = bfd_get_debug_link_info (abfd, & crc32);
d1393 1
a1393 6
    {
      free (base);
      free (dir);
      free (canon_dir);
      return NULL;
    }
d1399 2
a1400 7
  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (base);
      free (dir);
      free (canon_dir);
      return debugfile;
    }
d1407 2
a1408 7
  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (base);
      free (dir);
      free (canon_dir);
      return debugfile;
    }
d1420 2
a1421 7
  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (base);
      free (dir);
      free (canon_dir);
      return debugfile;
    }
d1423 1
d1425 3
d1431 1
a1431 1
  return NULL;
d1464 37
a1500 1
  return find_separate_debug_file (abfd, dir);
@


1.80
log
@gdb
	* symfile.c (get_debug_link_info): Remove.
	(find_separate_debug_file_by_debuglink): Use
	bfd_get_debug_link_info.
bfd
	* opncls.c (bfd_get_debug_link_info): Rename from
	get_debug_link_info.  Export.  Update comment.
	(find_separate_debug_file): Update.
	* bfd-in2.h: Rebuild.
@
text
@d2 1
a2 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012, 2013
   Free Software Foundation, Inc.
d256 1
d262 1
a262 1
    bfd_set_cacheable (nbfd, TRUE);
@


1.79
log
@	* bfd.c (struct bfd_preserve, bfd_preserve_save, bfd_preserve_restore,
	bfd_preserve_finish): Move to..
	* format.c: ..here, splitting out..
	(bfd_reinit): ..this.  New function.
	(bfd_check_format_matches): Use bfd_preserve_save/restore to
	keep bfd state for a match.
	* elfcode.h (elf_object_p): Don't use bfd_preserve_save/restore.
	* elfcore.h (elf_core_file_p): Likewise.
	* mach-o.c (bfd_mach_o_header_p): Likewise.
	* pef.c (bfd_pef_object_p, bfd_pef_xlib_object_p): Likewise.
	* xsym.c (bfd_sym_object_p): Likewise.
	* mmo.c (mmo_scan): Clear abfd->symcount.
	* opncls.c (_bfd_new_bfd): Use a smaller section hash table.
	* section.c (bfd_section_list_clear): Clear section_htab.count.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012
d1143 2
a1144 2
INTERNAL_FUNCTION
	get_debug_link_info
d1147 1
a1147 1
	char *get_debug_link_info (bfd *abfd, unsigned long *crc32_out);
d1152 3
a1154 1
	otherwise return filename and update @@var{crc32_out}.
d1157 2
a1158 2
static char *
get_debug_link_info (bfd *abfd, unsigned long *crc32_out)
d1266 1
a1266 1
  base = get_debug_link_info (abfd, & crc32);
@


1.78
log
@	PR binutils/14813
	* bfdio.c (struct bfd_iovec <bclose>): Revert 2012-11-06.
	(memory_bclose): Likewise.  Return 0 on success.
	* cache.c (cache_bclose): Likewise.
	* opncls.c (opncls_bclose, bfd_close): Likewise.
	* vms-lib.c (vms_lib_bclose): Likewise.
	* libbfd.h: Regenerate.
@
text
@d89 1
a89 1
			      sizeof (struct section_hash_entry), 251))
@


1.77
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d511 1
a511 1
static bfd_boolean
d521 1
a521 1
  return status == 0;
d726 1
a726 1
  ret = abfd->iovec->bclose (abfd);
@


1.76
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@d189 1
a189 1
	<<fdopen>>. 
d225 1
a225 1
  
d244 1
a244 1
  if ((mode[0] == 'r' || mode[0] == 'w' || mode[0] == 'a') 
@


1.75
log
@Change return type of bclose to bfd_boolean

	PR binutils/14813
	* bfdio.c (bfd_iovec): Change return type of bclose to
	bfd_boolean.
	(memory_bclose): Change return type to bfd_boolean.
	* cache.c (cache_bclose): Likewise.
	* opncls.c (opncls_bclose): Likewise.  Return TRUE on success.
	* vms-lib.c (vms_lib_bclose): Likewise.  Return TRUE.
	* libbfd.h: Regenerated.
@
text
@d1138 1
a1138 1
  return ~crc & 0xffffffff;;
@


1.74
log
@	PR binutils/14567
	* opncls.c (opncls_iovec): Forward declare.
	(_bfd_new_bfd_contained_in): If using opncls_iovec, copy iostream
	to new bfd.
@
text
@d511 1
a511 1
static int
d521 1
a521 1
  return status;
@


1.73
log
@	* vms-lib.c (_bfd_vms_lib_get_module): Use bfd_zmalloc for
	areltdata.
	* opncls.c (_bfd_delete_bfd): Free arelt_data.
	* mach-o.c (bfd_mach_o_fat_member_init): Use bfd_zmalloc for
	areltdata.
	* ecoff.c (_bfd_ecoff_slurp_armap): Use free for mapdata.
	* coff-rs6000.c (_bfd_xcoff_read_ar_hdr): Use bfd_zmalloc for
	areltdata.
	(xcoff_write_archive_contents_old): Likewise.
	(xcoff_write_archive_contents_big): Likewise.
	* archive64.c (bfd_elf64_archive_slurp_armap): Use free for
	areltdata.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Use bfd_zmalloc and
	free for areltdata.
	(_bfd_get_elt_at_filepos): Likewise.  Clear n_nfd->arelt_data on
	failure.
	(do_slurp_bsd_armap): Use bfd_zmalloc and free for areltdata.
	(do_slurp_coff_armap): Likewise.
	(_bfd_slurp_extended_name_table): Likewise.
	(bfd_slurp_bsd_armap_f2): Likewise.  Don't leak 'mapdata'.
@
text
@d110 2
d124 2
@


1.72
log
@	* archive.c (SECTION Archives): Update documentation.
	(_bfd_delete_archive_data): Remove.
	(_bfd_add_bfd_to_archive_cache): Set 'parent_cache' and 'key'.
	(archive_close_worker, _bfd_archive_close_and_cleanup): New
	functions.
	* libbfd-in.h (struct areltdata <parent_cache, key>): New fields.
	(_bfd_delete_archive_data): Don't declare.
	(_bfd_archive_close_and_cleanup): Declare.
	(_bfd_generic_close_and_cleanup): Redefine.
	* libbfd.h: Rebuild.
	* opncls.c (_bfd_delete_bfd): Don't call _bfd_delete_archive_data.
	(bfd_close): Don't close nested thin archives here.
@
text
@d139 1
@


1.71
log
@	* config/tc-i386.c (lex_got): Provide implementation for PE
	format.

	* gas/i386/secrel.s: Add test of <symbol>@@SECREL32.
	* gas/i386/secrel.d: Add expected disassembly.

	* scripttempl/pe.sc (R_TLS): Add .tls$AAA and .tls$ZZZ.
	* scripttempl/pep.sc (R_TLS): Add .tls$AAA and .tls$ZZZ.

	* archive.c (_bfd_delete_archive_data): New function.
	* libbfd-in.h (_bfd_delete_archive_data): Declare.
	* libbfd.h: Rebuild.
	* opncls.c (_bfd_delete_bfd): Call _bfd_delete_archive_data.
@
text
@a132 3
  if (abfd->format == bfd_archive)
    _bfd_delete_archive_data (abfd);

a710 2
  bfd *nbfd;
  bfd *next;
a717 7
  /* Close nested archives (if this bfd is a thin archive).  */
  for (nbfd = abfd->nested_archives; nbfd; nbfd = next)
    {
      next = nbfd->archive_next;
      bfd_close (nbfd);
    }

@


1.70
log
@	* opncls.c (_bfd_delete_bfd): Now static.
	* libbfd-in.h (_bfd_delete_bfd): Don't declare.
	* libbfd.h: Rebuild.
@
text
@d133 3
d141 1
@


1.69
log
@bfd/
	* opncls.c (bfd_fopen): Always close fd on failure.
	(bfd_fdopenr): Likewise.
gdb/
	* symfile.c (symfile_bfd_open): Don't close desc if bfd_fopen
	fails.
	* solib.c (solib_bfd_fopen): Don't close fd if bfd_fopen fails.
	* exec.c (exec_file_attach): Don't close scratch_chan if bfd_fopen
	fails.
	* dwarf2read.c (try_open_dwo_file): Don't close fd if bfd_fopen
	fails.
@
text
@d130 1
a130 1
void
@


1.69.4.1
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@a109 2
static const struct bfd_iovec opncls_iovec;

a121 2
  if (obfd->iovec == &opncls_iovec)
    nbfd->iostream = obfd->iostream;
d729 1
a729 1
  ret = abfd->iovec->bclose (abfd) == 0;
@


1.68
log
@2011-06-27  Tristan Gingold  <gingold@@adacore.com>

	* cache.c: Include bfd_stdint.h.
	(cache_bmmap): Change profile.  Return region start and size.
	* bfdio.c (struct bfd_iovec): Change bmmap profile.
	(bfd_mmap): Change profile and adjust.   Update comment.
	(memory_bmmap): Change profile.
	* opncls.c (opncls_bmmap): Change profile.
	* vms-lib.c (vms_lib_bmmap): Likewise.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d193 2
d205 5
a209 1
    return NULL;
d214 2
d318 2
d336 4
@


1.67
log
@	PR ld/12365
	PR ld/12672
bfd/
	* bfd.c (BFD_PLUGIN): Define.
	(BFD_FLAGS_SAVED, BFD_FLAGS_FOR_BFD_USE_MASK): Add BFD_PLUGIN.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_output_extsym): Strip undefined plugin syms.
	* opncls.c (bfd_make_readable): Don't lose original bfd flags.
ld/
	* ldfile.c (ldfile_try_open_bfd): Don't attempt any plugin action
	when no_more_claiming.
	* ldmain.c (add_archive_element): Likewise.
	(multiple_definition): Remove plugin_multiple_definition call.
	(notice): Remove plugin_notice call.
	* ldlang.c (lang_list_insert_after, void lang_list_remove_tail): Move.
	Delete prototype.
	(plugin_insert): New static var.
	(open_input_bfds): Only rescan libs after plugin insert point.
	(lang_gc_sections): Omit plugin claimed files.
	(lang_process): Set plugin_insert.  Only rescan when plugin adds
	objects.
	* plugin.h (no_more_claiming): Declare.
	(plugin_notice, plugin_multiple_definition): Don't declare.
	* plugin.c: Formatting.
	(orig_notice_all, orig_allow_multiple_defs, orig_callbacks,
	plugin_callbacks): New static vars.
	(no_more_claiming): Make global.
	(plugin_cached_allow_multiple_defs): Delete.
	(plugin_get_ir_dummy_bfd): Set SEC_EXCLUDE on dummy .text section,
	use newer bfd_make_section variant.  Make COMMON section too.
	Error handling.  Correct setting of gp size.
	(asymbol_from_plugin_symbol): Properly cast last arg of concat.
	(message): Likewise for ACONCAT.
	(asymbol_from_plugin_symbol): Use our COMMON section.
	(get_symbols): When report_plugin_symbols, show visibility too.
	(init_non_ironly_hash): Move.  Don't test non_ironly_hash.
	(plugin_load_plugins): Save state of linker callbacks, set up to
	call plugin_notice instead.  Call init_non_ironly_hash here.
	(plugin_call_all_symbols_read): Set plugin_multiple_definition in
	plugin callbacks.
	(plugin_notice): Rewrite.
	(plugin_multiple_definition): Make static, call original callback.
ld/testsuite/
	* ld-plugin/plugin-7.d: Adjust for plugin changes.
	* ld-plugin/plugin-8.d: Likewise.
	* ld-plugin/plugin.exp: Pass --verbose=2 for visibility test, and
	compare ld output to..
	* ld-plugin/plugin-12.d: New.
@
text
@d528 3
a530 1
	      file_ptr offset ATTRIBUTE_UNUSED)
@


1.66
log
@	* opncls.c (bfd_alloc, bfd_zalloc): Don't mark internal.
	* libbfd-in.h (bfd_alloc, bfd_zalloc): Don't declare here.
	* libbfd.h: Regenerate
	* bfd-in2.h: Regenerate.
@
text
@d878 1
a878 1
  abfd->flags = BFD_IN_MEMORY;
@


1.66.2.1
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@d878 1
a878 1
  abfd->flags |= BFD_IN_MEMORY;
@


1.65
log
@	* opncls.c (_bfd_id_counter): Rename to bfd_id_counter.
	(bfd_reserved_id_counter, bfd_use_reserved_id): New vars.
	(_bfd_new_bfd): Use negative id when bfd_use_reserved_id.
	(bfd_create): Doc fix.
	* bfd-in2.h: Regenerate.
@
text
@d895 1
a895 1
INTERNAL_FUNCTION
d963 1
a963 1
INTERNAL_FUNCTION
@


1.64
log
@2010-05-25  Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c: Declare and define _bfd_memory_iovec.
	(bfd_bread): Move code for BFD_IN_MEMORY...
	(bfd_bwrite): ... Ditto ...
	(bfd_tell): ... Ditto ...
	(bfd_flush): ... Ditto ...
	(bfd_stat): ... Ditto ...
	(bfd_seek): ... Ditto ...
	(bfd_get_size): ... Ditto ...
	(bfd_mmap): ... Ditto ...
	(memory_bread): ... to these new functions.
	(memory_bwrite): Ditto.
	(memory_btell): Ditto.
	(memory_bseek): Ditto.
	(memory_bflush): Ditto.
	(memory_bstat): Ditto.
	(memory_bmmap): Ditto.
	(memory_bclose): New function.
	* peicode.h (pe_ILF_build_a_bfd): Use BFD_IN_MEMORY.
	* xcofflink.c (bfd_xcoff_link_generate_rtinit): Ditto.
	* opncls.c (bfd_close): Do not handle BFD_IN_MEMORY case.
	(bfd_make_writable): Use _bfd_memory_iovec.
	* elfcode.h (bfd_from_remote_memory): Use _bfd_memory_iovec.
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Use
	_bfd_memory_iovec.
	(alpha_ecoff_openr_next_archived_file): Use proxy_origin
	instead of origin.
	* libbfd.h: Regenerate.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d41 1
a41 1
/* Counter used to initialize the bfd identifier.  */
d43 9
a51 1
static unsigned int _bfd_id_counter = 0;
d67 7
a73 1
  nbfd->id = _bfd_id_counter++;
d770 1
a770 1
	used by @@var{template}. The format is always set to <<bfd_object>>.
@


1.63
log
@2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* opncls.c (bfd_opnr_iovec): Replace _XXX with XXX_P in
	parameters.

	* tekhex.c (pass_over): Replace eof with is_eof.
@
text
@d699 1
a699 14
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    {
      /* FIXME: cagney/2004-02-15: Need to implement a BFD_IN_MEMORY io
	 vector.
	 Until that's done, at least don't leak memory.  */
      struct bfd_in_memory *bim = (struct bfd_in_memory *) abfd->iostream;

      if (bim->buffer != NULL)
	free (bim->buffer);
      free (bim);
      ret = TRUE;
    }
  else
    ret = abfd->iovec->bclose (abfd);
d813 2
a852 1

@


1.62
log
@2009-12-14  Doug Kwan  <dougkwan@@google.com>

bfd/ChangeLog:

	* opncls.c (bfd_opnr_iovec): Rename parameters to avoid shawdowed
	variable warnings.
	* bfd-in2.h: Regnenerate.

include/ChangeLog:

	* bfdlink.h (struct bfd_link_callbacks): Rename function parameters
	to avoid shadowed variable warnings.
	* dis-asm.h (struct disassemble_info): Ditto.
	(disassemble_init_for_target): Ditto.
	(init_disassemble_info): Ditto.
@
text
@d526 1
a526 1
		 void *(*_open) (struct bfd *, void *),
d528 4
a531 4
		 file_ptr (*_pread) (struct bfd *, void *, void *, file_ptr,
				    file_ptr),
		 int (*_close) (struct bfd *, void *),
		 int (*_stat) (struct bfd *, void *, struct stat *))
d552 2
a553 2
  /* `open (...)' would get expanded by an the open(2) syscall macro.  */
  stream = (*_open) (nbfd, open_closure);
d562 3
a564 3
  vec->pread = _pread;
  vec->close = _close;
  vec->stat = _stat;
@


1.61
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d379 2
a380 2
                              void *(*open) (struct bfd *nbfd,
                                             void *open_closure),
d382 10
a391 10
                              file_ptr (*pread) (struct bfd *nbfd,
                                                 void *stream,
                                                 void *buf,
                                                 file_ptr nbytes,
                                                 file_ptr offset),
                              int (*close) (struct bfd *nbfd,
                                            void *stream),
			      int (*stat) (struct bfd *abfd,
					   void *stream,
					   struct stat *sb));
d396 2
a397 2
        The @@var{stream} is created using @@var{open}, accessed using
        @@var{pread} and destroyed using @@var{close}.
d402 1
a402 1
	Calls @@var{open} (which can call <<bfd_zalloc>> and
d404 1
a404 1
	the BFD.  @@var{open} either succeeds returning the
d408 1
a408 1
	Calls @@var{pread} to request @@var{nbytes} of data from
d410 1
a410 1
	<<bfd_read>>).  @@var{pread} either succeeds returning the
d414 2
a415 2
	Calls @@var{close} when the BFD is later closed using
	<<bfd_close>>.  @@var{close} either succeeds returning 0, or
d418 2
a419 2
	Calls @@var{stat} to fill in a stat structure for bfd_stat,
	bfd_get_size, and bfd_get_mtime calls.  @@var{stat} returns 0
@


1.60
log
@	PR binutils/10802
	* opncls.c (_maybe_make_executable): Make DYNAMIC files executable.
@
text
@d526 1
a526 2
		 void *(*open) (struct bfd *nbfd,
				void *open_closure),
d528 4
a531 10
		 file_ptr (*pread) (struct bfd *abfd,
				    void *stream,
				    void *buf,
				    file_ptr nbytes,
				    file_ptr offset),
		 int (*close) (struct bfd *nbfd,
			       void *stream),
		 int (*stat) (struct bfd *abfd,
			      void *stream,
			      struct stat *sb))
d553 1
a553 1
  stream = (*open) (nbfd, open_closure);
d562 3
a564 3
  vec->pread = pread;
  vec->close = close;
  vec->stat = stat;
d1230 1
a1230 1
  char *basename;
d1249 2
a1250 2
  basename = get_debug_link_info (abfd, & crc32);
  if (basename == NULL)
d1253 1
a1253 1
  if (basename[0] == '\0')
d1255 1
a1255 1
      free (basename);
d1267 1
a1267 1
      free (basename);
d1285 1
a1285 1
                  + strlen (basename)
d1289 1
a1289 1
      free (basename);
d1297 1
a1297 1
  strcat (debugfile, basename);
d1301 1
a1301 1
      free (basename);
d1310 1
a1310 1
  strcat (debugfile, basename);
d1314 1
a1314 1
      free (basename);
d1328 1
a1328 1
  strcat (debugfile, basename);
d1332 1
a1332 1
      free (basename);
d1339 1
a1339 1
  free (basename);
@


1.59
log
@	PR binutils/10785
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Don't bfd_alloc
	bim and bim->buffer.  bfd_malloc instead.
	* peicode.h (pe_ILF_build_a_bfd): Similarly.
	(ILF_DATA_SIZE): Don't include bim.
	* opncls.c (bfd_close): Test bim->buffer non-NULL before freeing.
@
text
@d638 1
a638 1
      && abfd->flags & EXEC_P)
@


1.58
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d712 3
a714 1
      free (bim->buffer);
@


1.57
log
@update copyright dates
@
text
@d55 1
a55 1
  nbfd = bfd_zmalloc (sizeof (bfd));
d345 1
a345 1
  FILE *stream = streamarg;
d441 1
a441 1
  struct opncls *vec = abfd->iostream;
d448 1
a448 1
  struct opncls *vec = abfd->iostream;
d461 1
a461 1
  struct opncls *vec = abfd->iostream;
d480 1
a480 1
  struct opncls *vec = abfd->iostream;
d499 1
a499 1
  struct opncls *vec = abfd->iostream;
d567 1
a567 1
  vec = bfd_zalloc (nbfd, sizeof (struct opncls));
d711 1
a711 1
      struct bfd_in_memory *bim = abfd->iostream;
d822 1
a822 1
  bim = bfd_malloc (sizeof (struct bfd_in_memory));
d920 1
a920 1
  ret = objalloc_alloc (abfd->memory, (unsigned long) size);
d959 1
a959 1
  ret = objalloc_alloc (abfd->memory, (unsigned long) size);
d1269 1
a1269 1
  dir = bfd_malloc (dirlen + 1);
d1286 6
a1291 5
  debugfile = bfd_malloc (strlen (debug_file_directory) + 1
			  + (canon_dirlen > dirlen ? canon_dirlen : dirlen)
			  + strlen (".debug/")
			  + strlen (basename)
			  + 1);
d1511 1
a1511 1
  contents = bfd_malloc (debuglink_size);
@


1.57.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d55 1
a55 1
  nbfd = (bfd *) bfd_zmalloc (sizeof (bfd));
d345 1
a345 1
  FILE *stream = (FILE *) streamarg;
d441 1
a441 1
  struct opncls *vec = (struct opncls *) abfd->iostream;
d448 1
a448 1
  struct opncls *vec = (struct opncls *) abfd->iostream;
d461 1
a461 1
  struct opncls *vec = (struct opncls *) abfd->iostream;
d480 1
a480 1
  struct opncls *vec = (struct opncls *) abfd->iostream;
d499 1
a499 1
  struct opncls *vec = (struct opncls *) abfd->iostream;
d567 1
a567 1
  vec = (struct opncls *) bfd_zalloc (nbfd, sizeof (struct opncls));
d711 1
a711 1
      struct bfd_in_memory *bim = (struct bfd_in_memory *) abfd->iostream;
d822 1
a822 1
  bim = (struct bfd_in_memory *) bfd_malloc (sizeof (struct bfd_in_memory));
d920 1
a920 1
  ret = objalloc_alloc ((struct objalloc *) abfd->memory, (unsigned long) size);
d959 1
a959 1
  ret = objalloc_alloc ((struct objalloc *) abfd->memory, (unsigned long) size);
d1269 1
a1269 1
  dir = (char *) bfd_malloc (dirlen + 1);
d1286 5
a1290 6
  debugfile = (char *)
      bfd_malloc (strlen (debug_file_directory) + 1
                  + (canon_dirlen > dirlen ? canon_dirlen : dirlen)
                  + strlen (".debug/")
                  + strlen (basename)
                  + 1);
d1510 1
a1510 1
  contents = (char *) bfd_malloc (debuglink_size);
@


1.57.2.2
log
@2009-10-16  Alan Modra  <amodra@@bigpond.net.au>

	PR binutils/10785
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Don't bfd_alloc
	bim and bim->buffer.  bfd_malloc instead.
	* peicode.h (pe_ILF_build_a_bfd): Similarly.
	(ILF_DATA_SIZE): Don't include bim.
	* opncls.c (bfd_close): Test bim->buffer non-NULL before freeing.
@
text
@d712 1
a712 3

      if (bim->buffer != NULL)
	free (bim->buffer);
@


1.57.2.3
log
@	PR binutils/10802
	* opncls.c (_maybe_make_executable): Make DYNAMIC files executable.
@
text
@d638 1
a638 1
      && (abfd->flags & (EXEC_P | DYNAMIC)) != 0)
@


1.56
log
@	* opncls.c (bfd_close): Until BFD_IN_MEMORY has an iovec,
	at least don't leak memory.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.55
log
@* opncls.c (_maybe_make_executable): New function.  Gives execute
        permission to an executable bfd that was opened for writing
        provided that it is a regular file.  Replaces common code found in...
        (bfd_close): here and ...
        (bfd_close_all_done): here.
@
text
@d706 11
a716 3
  /* FIXME: cagney/2004-02-15: Need to implement a BFD_IN_MEMORY io
     vector.  */
  if (!(abfd->flags & BFD_IN_MEMORY))
a717 2
  else
    ret = TRUE;
@


1.54
log
@2009-06-10  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* bfd-in2.h: bfd_mmap prototype
	* bfdio.c (bfd_mmap): New function.
	* libbfd.h (bfd_iovec): Add bmmap.
	* cache.c (cache_bmap): New function.
	(cache_iovec): Initialize bmmap member.
	* opencls.c (opncls_bmmap): New function.
	(opncls_iovec): Initialize bmmap member.
@
text
@d632 26
d713 2
a714 18
  /* If the file was open for writing and is now executable,
     make it so.  */
  if (ret
      && abfd->direction == write_direction
      && abfd->flags & EXEC_P)
    {
      struct stat buf;

      if (stat (abfd->filename, &buf) == 0)
	{
	  unsigned int mask = umask (0);

	  umask (mask);
	  chmod (abfd->filename,
		 (0777
		  & (buf.st_mode | ((S_IXUSR | S_IXGRP | S_IXOTH) &~ mask))));
	}
    }
d750 2
a751 18
  /* If the file was open for writing and is now executable,
     make it so.  */
  if (ret
      && abfd->direction == write_direction
      && abfd->flags & EXEC_P)
    {
      struct stat buf;

      if (stat (abfd->filename, &buf) == 0)
	{
	  unsigned int mask = umask (0);

	  umask (mask);
	  chmod (abfd->filename,
		 (0777
		  & (buf.st_mode | ((S_IXUSR | S_IXGRP | S_IXOTH) &~ mask))));
	}
    }
@


1.53
log
@(find_separate_debug_file): Use the canonical
absolute name of the bfd object for finding the debug file in
the global debugfile directory.
@
text
@d508 11
d521 1
a521 1
  &opncls_bclose, &opncls_bflush, &opncls_bstat
@


1.52
log
@Add support for thin archives.
    * bfd/archive.c (_bfd_find_nested_archive): New function.
    (get_extended_arelt_filename): Add origin parameter.
    (_bfd_generic_read_ar_hdr_mag): Deal with extended name
    combined with a file offset.
    (append_relative_path): New function.
    (_bfd_get_elt_at_filepos): Deal with external members and
    nested archives.
    (bfd_generic_openr_next_archived_file): Thin archives.
    (bfd_generic_archive_p): Recognize new magic string.
    (adjust_relative_path): New function.
    (_bfd_construct_extended_name_table): Construct extended
    names for thin archive members.
    (_bfd_write_archive_contents): Emit new magic string, skip
    copying files for thin archives.
    * bfd/bfd-in.h (bfd_is_thin_archive): New macro.
    * bfd/bfd.c (struct bfd): New fields for thin archives.
    * bfd/libbfd-in.h (struct areltdata): New field for thin archives.
    * bfd/opncls.c (bfd_close): Delete BFDs for nested archives.
    * binutils/ar.c (make_thin_archive): New global flag.
    (map_over_members): Deal with full pathnames in thin archives.
    (usage, main): Add 'T' option for building thin archives.
    (replace_members): Pass thin archive flag to ar_emul_append.
    * binutils/arsup.c (ar_open): Initialize new flag.
    * binutils/binemul.c (ar_emul_append): Add new parameter for
    flattening nested archives.
    (do_ar_emul_default_append): New function.
    (ar_emul_default_append): Factored out recursive code.
    * binutils/binemul.h (ar_emul_default_append): Add new parameter.
    (struct bin_emulation_xfer_struct): New parameter for ar_append.
    * binutils/dlltool.c (gen_lib_file): Initialize thin archive flag.
    * binutils/emul_aix.c (ar_emul_aix_internal): Add new flatten
    parameter, currently unimplemented.
    All callers changed.
    * binutils/objcopy.c (copy_archive): Preserve thin archive flag.
    * binutils/doc/binutils.texi: Update ar documentation.
    * binutils/testsuite/binutils-all/ar.exp: Add thin archive tests.
    * include/aout/ar.h (ARMAGT): New magic string for thin archives.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007
d1227 1
a1228 1
  int i;
d1230 1
d1267 8
d1276 1
a1276 1
			  + dirlen
d1284 1
d1296 1
d1309 1
d1315 4
a1318 4
  i = strlen (debug_file_directory) - 1;
  if (i > 0
      && debug_file_directory[i] != '/'
      && dir[0] != '/')
d1320 1
a1320 1
  strcat (debugfile, dir);
d1327 1
d1334 1
@


1.51
log
@	PR 5328
	* opncls.c (separate_debug_file_exists): Use fopen/fread
	rather than open/read and open in binary mode.
@
text
@d650 2
d659 7
@


1.50
log
@	* opncls.c (find_separate_debug_file): Ensure bfd_set_error has
	been called on all error return paths.
	(bfd_fill_in_gnu_debuglink_section): Use bfd_malloc, not malloc.
	Clear padding after filename
@
text
@d1178 1
a1178 1
  int fd;
d1183 2
a1184 2
  fd = open (name, O_RDONLY);
  if (fd < 0)
d1187 1
a1187 1
  while ((count = read (fd, buffer, sizeof (buffer))) > 0)
d1190 1
a1190 1
  close (fd);
@


1.49
log
@	* opncls.c (bfd_openr_iovec): Fix the OPEN parameter macro expansion.
@
text
@d1220 1
d1227 5
a1231 2
  if (! abfd->filename)
    return NULL;
d1237 1
a1237 1
  if (strlen (basename) < 1)
d1240 1
d1244 5
a1248 1
  dir = strdup (abfd->filename);
d1254 2
a1255 6
  BFD_ASSERT (strlen (dir) != 0);

  /* Strip off filename part.  */
  for (i = strlen (dir) - 1; i >= 0; i--)
    if (IS_DIR_SEPARATOR (dir[i]))
      break;
d1257 5
a1261 8
  dir[i + 1] = '\0';
  BFD_ASSERT (dir[i] == '/' || dir[0] == '\0');

  debugfile = malloc (strlen (debug_file_directory) + 1
		      + strlen (dir)
		      + strlen (".debug/")
		      + strlen (basename)
		      + 1);
d1440 1
d1470 2
a1471 1
  debuglink_size = strlen (filename) + 1;
d1476 1
a1476 1
  contents = malloc (debuglink_size);
a1479 1
      bfd_set_error (bfd_error_no_memory);
a1482 1
  strcpy (contents, filename);
d1484 2
@


1.48
log
@2007-07-23  Michael Snyder  <msnyder@@access-company.com>

	* opncls.c (bfd_make_writable): Check return from bfd_malloc.
@
text
@d548 2
a549 1
  stream = open (nbfd, open_closure);
@


1.48.2.1
log
@	* opncls.c (find_separate_debug_file): Ensure bfd_set_error has
	been called on all error return paths.
	(bfd_fill_in_gnu_debuglink_section): Use bfd_malloc, not malloc.
	Clear padding after filename
@
text
@a1218 1
  size_t dirlen;
d1225 2
a1226 5
  if (abfd->filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }
d1232 1
a1232 1
  if (basename[0] == '\0')
a1234 1
      bfd_set_error (bfd_error_no_debug_section);
d1238 1
a1238 5
  for (dirlen = strlen (abfd->filename); dirlen > 0; dirlen--)
    if (IS_DIR_SEPARATOR (abfd->filename[dirlen - 1]))
      break;

  dir = bfd_malloc (dirlen + 1);
d1244 6
a1249 2
  memcpy (dir, abfd->filename, dirlen);
  dir[dirlen] = '\0';
d1251 8
a1258 5
  debugfile = bfd_malloc (strlen (debug_file_directory) + 1
			  + dirlen
			  + strlen (".debug/")
			  + strlen (basename)
			  + 1);
a1436 1
  size_t filelen;
d1466 1
a1466 2
  filelen = strlen (filename);
  debuglink_size = filelen + 1;
d1471 1
a1471 1
  contents = bfd_malloc (debuglink_size);
d1475 1
d1479 1
a1480 2
  memcpy (contents, filename, filelen);
  memset (contents + filelen, 0, crc_offset - filelen);
@


1.47
log
@Switch sources over to use the GPL version 3
@
text
@d802 2
@


1.46
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d22 2
a23 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.45
log
@bfd/
	* opncls.c (bfd_openr_iovec): Add "stat" parameter.
	(struct opncls): Add "stat" field.
	(opncls_bstat): Call vec->stat.
	* bfd-in2.h: Regenerate.
	* elf32-spu.c (spu_elf_open_builtin_lib): Adjust.
gdb/
	* spu-linux-nat.c (spu_bfd_iovec_stat): New function.
	(spu_bfd_open): Adjust bfd_openr_iovec call.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006
d24 1
a25 1
#include "sysdep.h"
@


1.44
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d387 4
a390 1
                                            void *stream));
d417 4
d433 1
d496 1
a496 1
opncls_bstat (struct bfd *abfd ATTRIBUTE_UNUSED, struct stat *sb)
d498 2
d501 4
a504 1
  return 0;
d523 4
a526 1
			       void *stream))
d558 1
@


1.43
log
@2006-04-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2467
	* elf.c (_bfd_elf_close_and_cleanup): Check elf_tdata (abfd)
	is NULL first.

	* elf32-arm.c (elf32_arm_close_and_cleanup): Check if
	abfd->sections is NULL.
	(elf32_arm_bfd_free_cached_info): New.
	(bfd_elf32_bfd_free_cached_info): Defined.

	* elfxx-target.h (bfd_elfNN_bfd_free_cached_info): Default it
	to _bfd_free_cached_info.

	* libbfd-in.h (_bfd_free_cached_info): New.
	* libbfd: Regenerated.

	* opncls.c (_bfd_delete_bfd): Check if abfd->memory is NULL.
	(_bfd_free_cached_info): New.
@
text
@d1348 1
d1367 2
a1368 1
  sect = bfd_make_section (abfd, GNU_DEBUGLINK);
a1371 6
  if (! bfd_set_section_flags (abfd, sect,
			       SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING))
    /* XXX Should we delete the section from the bfd ?  */
    return NULL;


@


1.42
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d118 5
a122 2
  bfd_hash_table_free (&abfd->section_htab);
  objalloc_free ((struct objalloc *) abfd->memory);
d126 21
@


1.41
log
@	* configure.in: Check for fopen64.
	* libbfd-in.h (real_fopen): New prototype.
	* configure, config.in, libbfd.h: Regenerated.
	* bfdio.c (real_fopen): New function.
	* opncls.c (bfd_fopen, bfd_fill_in_gnu_debuglink_section): Use it.
	* cache.c (bfd_open_file): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005
d74 1
a74 1
			      251))
@


1.40
log
@        * archive.c: Add missing SUBSECTION for documentation.
        * bfd.c: Likewise.
        * cache.c: Likewise.
        * corefile.c: Likewise.
        * format.c: Likewise.
        * init.c: Likewise.
        * libbfd.c: Likewise.
        * opncls.c: Likewise.
        * elf.c: Remove blank line after SECTION heading.
        * reloc.c: Change "howto manager" SECTION to a SUBSECTION.
@
text
@d178 1
a178 1
    nbfd->iostream = fopen (filename, mode);
d1410 1
a1410 1
  handle = fopen (filename, FOPEN_RB);
@


1.40.4.1
log
@	* configure.in: Check for fopen64.
	* libbfd-in.h (real_fopen): New prototype.
	* configure, config.in, libbfd.h: Regenerated.
	* bfdio.c (real_fopen): New function.
	* opncls.c (bfd_fopen, bfd_fill_in_gnu_debuglink_section): Use it.
	* cache.c (bfd_open_file): Likewise.
@
text
@d178 1
a178 1
    nbfd->iostream = real_fopen (filename, mode);
d1410 1
a1410 1
  handle = real_fopen (filename, FOPEN_RB);
@


1.39
log
@	* libbfd-in.h (bfd_malloc2, bfd_realloc2, bfd_zmalloc2, bfd_alloc2,
	bfd_zalloc2): New prototypes.
	* bfd-in.h (HALF_BFD_SIZE_TYPE): Define.
	* libbfd.c (bfd_malloc2, bfd_realloc2, bfd_zmalloc2): New functions.
	* opncls.c (bfd_alloc2, bfd_zalloc2): New functions.
	* elf.c (bfd_elf_get_elf_syms, setup_group, assign_section_numbers,
	elf_map_symbols, map_sections_to_segments,
	assign_file_positions_for_segments, copy_private_bfd_data,
	swap_out_syms, _bfd_elf_slurp_version_tables): Use bfd_*alloc2
	where appropriate.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.

	* elf.c (_bfd_elf_print_private_bfd_data): Don't crash on bogus
	verdef or verneed section.
	(_bfd_elf_slurp_version_tables): Handle corrupt verdef and/or
	verneed sections gracefully.
	* elfxx-sparc.c (_bfd_sparc_elf_info_to_howto_ptr): Don't crash on
	bogus relocation values.
	* elf64-ppc.c (ppc64_elf_info_to_howto): Likewise.
	* elf64-s390.c (elf_s390_info_to_howto): Likewise.
	* elf32-s390.c (elf_s390_info_to_howto): Likewise.
	* elf64-x86-64.c (elf64_x86_64_info_to_howto): Likewise.
	* elfxx-ia64.c (lookup_howto): Likewise.
@
text
@d127 2
@


1.38
log
@	* opncls.c (bfd_fopen): Mark returned BFD as cacheable if FD == -1.
@
text
@d861 39
d921 33
@


1.37
log
@	* opncls.c (bfd_fdopenr): Don't set bfd_error unconditionally.
@
text
@d147 2
d203 6
@


1.36
log
@	* opncls.c (bfd_fopen): Don't set bfd_error unconditionally.
@
text
@a270 1
  bfd_set_error (bfd_error_system_call);
d276 4
a279 1
    return NULL;
@


1.35
log
@	* opncls.c (bfd_fdopenr): Add missing break statements.
@
text
@a157 2
  bfd_set_error (bfd_error_system_call);

d177 1
@


1.34
log
@	* opncls.c (bfd_fopen): New API.
	(bfd_openr): Use it.
	(bfd_fdopenr): Likewise.
	* bfd-in2.h: Regenerated.
@
text
@d283 3
a285 3
    case O_RDONLY: mode = FOPEN_RB;
    case O_WRONLY: mode = FOPEN_RUB;
    case O_RDWR:   mode = FOPEN_RUB;
@


1.33
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d131 1
a131 1
	bfd_openr
d134 2
a135 1
	bfd *bfd_openr (const char *filename, const char *target);
d138 5
a142 2
	Open the file @@var{filename} (using <<fopen>>) with the target
	@@var{target}.  Return a pointer to the created BFD.
d153 1
a153 1
bfd_openr (const char *filename, const char *target)
d158 2
d170 12
d183 1
a184 1
  nbfd->direction = read_direction;
d186 11
a196 1
  if (bfd_open_file (nbfd) == NULL)
a197 2
      /* File didn't exist, or some such.  */
      bfd_set_error (bfd_error_system_call);
d201 1
d206 25
d267 2
a268 2
  bfd *nbfd;
  const bfd_target *target_vec;
d270 1
d274 1
a274 1
  fdflags = O_RDWR;			/* Assume full access.  */
a276 1
#endif
a279 14
  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;

  target_vec = bfd_find_target (target, nbfd);
  if (target_vec == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

#ifndef HAVE_FDOPEN
  nbfd->iostream = fopen (filename, FOPEN_RB);
#else
d283 3
a285 3
    case O_RDONLY: nbfd->iostream = fdopen (fd, FOPEN_RB);   break;
    case O_WRONLY: nbfd->iostream = fdopen (fd, FOPEN_RUB);  break;
    case O_RDWR:   nbfd->iostream = fdopen (fd, FOPEN_RUB);  break;
d290 1
a290 29
  if (nbfd->iostream == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  /* OK, put everything where it belongs.  */
  nbfd->filename = filename;

  /* As a special case we allow a FD open for read/write to
     be written through, although doing so requires that we end
     the previous clause with a preposition.  */
  /* (O_ACCMODE) parens are to avoid Ultrix header file bug.  */
  switch (fdflags & (O_ACCMODE))
    {
    case O_RDONLY: nbfd->direction = read_direction; break;
    case O_WRONLY: nbfd->direction = write_direction; break;
    case O_RDWR: nbfd->direction = both_direction; break;
    default: abort ();
    }

  if (! bfd_cache_init (nbfd))
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }
  nbfd->opened_once = TRUE;

  return nbfd;
@


1.32
log
@Update the FSF address in the copyright/GPL notice
@
text
@d22 1
a22 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.31
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@d22 1
a22 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.30
log
@	* opncls.c (opncls_bread, opncls_bclose): Fix if pread resp.
	close is a function like macro in system headers.
@
text
@d80 1
a80 1
  nbfd->section_tail = &nbfd->sections;
@


1.30.6.1
log
@	* bfd/opncls.c (bfd_fopen): New API.
	(bfd_openr): Use it.
	(bfd_fdopenr): Likewise.
	* bfd/bfd-in2.h: Regenerated.
@
text
@d131 1
a131 1
	bfd_fopen
d134 1
a134 2
	bfd *bfd_fopen (const char *filename, const char *target,
                        const char *mode, int fd);
d137 2
a138 5
	Open the file @@var{filename} with the target @@var{target}.
	Return a pointer to the created BFD.  If @@var{fd} is not -1,
	then <<fdopen>> is used to open the file; otherwise, <<fopen>>
	is used.  @@var{mode} is passed directly to <<fopen>> or
	<<fdopen>>. 
d149 1
a149 1
bfd_fopen (const char *filename, const char *target, const char *mode, int fd)
a153 2
  bfd_set_error (bfd_error_system_call);

a163 12
  
#ifdef HAVE_FDOPEN
  if (fd != -1)
    nbfd->iostream = fdopen (fd, mode);
  else
#endif
    nbfd->iostream = fopen (filename, mode);
  if (nbfd->iostream == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }
a164 1
  /* OK, put everything where it belongs.  */
d166 1
d168 1
a168 11
  /* Figure out whether the user is opening the file for reading,
     writing, or both, by looking at the MODE argument.  */
  if ((mode[0] == 'r' || mode[0] == 'w' || mode[0] == 'a') 
      && mode[1] == '+')
    nbfd->direction = both_direction;
  else if (mode[0] == 'r')
    nbfd->direction = read_direction;
  else
    nbfd->direction = write_direction;

  if (! bfd_cache_init (nbfd))
d170 2
a174 1
  nbfd->opened_once = TRUE;
a178 25
/*
FUNCTION
	bfd_openr

SYNOPSIS
	bfd *bfd_openr (const char *filename, const char *target);

DESCRIPTION
	Open the file @@var{filename} (using <<fopen>>) with the target
	@@var{target}.  Return a pointer to the created BFD.

	Calls <<bfd_find_target>>, so @@var{target} is interpreted as by
	that function.

	If <<NULL>> is returned then an error has occured.   Possible errors
	are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> or
	<<system_call>> error.
*/

bfd *
bfd_openr (const char *filename, const char *target)
{
  return bfd_fopen (filename, target, FOPEN_RB, -1);
}

d215 2
a216 2
  const char *mode;
#if defined(HAVE_FCNTL) && defined(F_GETFL)
a217 1
#endif
d221 1
a221 1
  mode = FOPEN_RUB; /* Assume full access.  */
d224 1
d228 14
d245 3
a247 3
    case O_RDONLY: mode = FOPEN_RB;
    case O_WRONLY: mode = FOPEN_RUB;
    case O_RDWR:   mode = FOPEN_RUB;
d252 29
a280 1
  return bfd_fopen (filename, target, mode, fd);
@


1.30.6.2
log
@        * opncls.c (bfd_fdopenr): Add missing break statements.
@
text
@d283 3
a285 3
    case O_RDONLY: mode = FOPEN_RB; break;
    case O_WRONLY: mode = FOPEN_RUB; break;
    case O_RDWR:   mode = FOPEN_RUB; break;
@


1.30.6.3
log
@        * opncls.c (bfd_fopen): Don't set bfd_error unconditionally.
@
text
@d158 2
a178 1
      bfd_set_error (bfd_error_system_call);
@


1.30.6.4
log
@	* bfd/opncls.c (bfd_fopen): Mark returned BFD as cacheable if FD == -1.
@
text
@a146 2
	The new BFD is marked as cacheable iff @@var{fd} is -1.

a200 6
  /* If we opened the file by name, mark it cacheable; we can close it
     and reopen it later.  However, if a file descriptor was provided,
     then it may have been opened with special flags that make it
     unsafe to close and reopen the file.  */
  if (fd == -1)
    bfd_set_cacheable (nbfd, TRUE);
@


1.29
log
@	* opncls.c (bfd_zalloc): Document this function.
@
text
@d408 1
a408 1
  file_ptr nread = vec->pread (abfd, vec->stream, buf, nbytes, vec->where);
d431 1
a431 1
    status = vec->close (abfd, vec->stream);
@


1.28
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@a822 1

d840 12
@


1.27
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
d983 1
d1001 2
a1002 1
  crc_offset = strlen (contents) + 1;
d1008 1
a1008 1
  return contents;
d1027 1
a1027 1
  static char buffer [8 * 1024];
d1291 1
a1291 1
  static char buffer[8 * 1024];
@


1.26
log
@	* opncls.c (bfd_close): Return TRUE for BFD_IN_MEMORY.
@
text
@a1191 4
#if 0 /* Disabled until DEBUGDIR can be defined by configure.in.  */
  if (dir == NULL)
    dir = DEBUGDIR;
#endif
@


1.25
log
@	* libbfd-in.h (BFD_ASSERT, BFD_FAIL): Wrap macro body in do while.
	* libbfd.h: Regnerate.
	* elf32-cris.c: Add missing semicolon to BFD_ASSERTs.
	* elf32-frv.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* opncls.c: Likewise.
@
text
@d601 1
a601 1
    ret = 0;
@


1.24
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d862 3
a864 3
/* 
   GNU Extension: separate debug-info files 
   
d892 1
a892 1
*/     
d1095 1
a1095 1
  
d1102 1
a1102 1
  BFD_ASSERT (dir[i] == '/' || dir[0] == '\0')
d1107 1
a1107 1
		      + strlen (basename) 
d1214 1
a1214 1
	returned and bfd_error is set.  
d1231 1
a1231 1
  
d1249 1
a1249 1
  
d1258 1
a1258 1
  
d1280 1
a1280 1
	and bfd_error is set.  
d1323 1
a1323 1
  
@


1.23
log
@2004-04-22  Andrew Cagney  <cagney@@redhat.com>

	* opncls.c (bfd_alloc): Fix type of "wanted" in doco.
@
text
@d3 1
a3 1
   2001, 2002, 2003
d979 1
a979 2
  asection * sect;
  bfd_size_type debuglink_size;
d981 1
a981 1
  char * contents;
a982 1
  bfd_boolean ret;
d992 1
a992 8
  debuglink_size = bfd_section_size (abfd, sect);  

  contents = malloc (debuglink_size);
  if (contents == NULL)
    return NULL;

  ret = bfd_get_section_contents (abfd, sect, contents, 0, debuglink_size);
  if (! ret)
d994 2
a995 1
      free (contents);
@


1.22
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* opncls.c (_bfd_new_bfd_contained_in): Copy "iovec".
	(struct opncls, opncls_btell, opncls_bseek, opncls_bread)
	(opncls_bwrite, opncls_bclose, opncls_bflush)
	(opncls_bstat, opncls_iovec, bfd_openr_iovec): Implement a
	bfd iovec that uses function callbacks.
	(bfd_close): Use the iovec's bclose.
	* cache.c (cache_btell, cache_bseek, cache_bread, cache_bwrite)
	(cache_bclose, cache_bflush, cache_bstat)
	(cache_iovec): New functions and global variable, implement a
	cache "iovec", where applicable set bfd_error.
	(bfd_cache_init, bfd_cache_close): Set/test the bfd's iovec.
	* bfdio.c (struct bfd_iovec): Define.
	(real_read): Delete function.
	(bfd_bread, bfd_bread, bfd_bwrite, bfd_tell, bfd_flush, bfd_stat)
	(bfd_seek, bfd_get_mtime, bfd_get_size): Use the bfd's "iovec",
	assume that bread and bwrite set bfd_error.
	* bfd.c (struct bfd): Add "iovec", update comments.
	* bfd-in2.h, libbfd.h: Re-generate.
@
text
@d816 1
a816 1
	void *bfd_alloc (bfd *abfd, size_t wanted);
@


1.21
log
@Stop indexed move byte instructions from being relaxed.
@
text
@d106 1
d326 177
d596 6
a601 1
  ret = bfd_cache_close (abfd);
@


1.21.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
a105 1
  nbfd->iovec = obfd->iovec;
a324 177

/*
FUNCTION
	bfd_openr_iovec

SYNOPSIS
        bfd *bfd_openr_iovec (const char *filename, const char *target,
                              void *(*open) (struct bfd *nbfd,
                                             void *open_closure),
                              void *open_closure,
                              file_ptr (*pread) (struct bfd *nbfd,
                                                 void *stream,
                                                 void *buf,
                                                 file_ptr nbytes,
                                                 file_ptr offset),
                              int (*close) (struct bfd *nbfd,
                                            void *stream));

DESCRIPTION

        Create and return a BFD backed by a read-only @@var{stream}.
        The @@var{stream} is created using @@var{open}, accessed using
        @@var{pread} and destroyed using @@var{close}.

	Calls <<bfd_find_target>>, so @@var{target} is interpreted as by
	that function.

	Calls @@var{open} (which can call <<bfd_zalloc>> and
	<<bfd_get_filename>>) to obtain the read-only stream backing
	the BFD.  @@var{open} either succeeds returning the
	non-<<NULL>> @@var{stream}, or fails returning <<NULL>>
	(setting <<bfd_error>>).

	Calls @@var{pread} to request @@var{nbytes} of data from
	@@var{stream} starting at @@var{offset} (e.g., via a call to
	<<bfd_read>>).  @@var{pread} either succeeds returning the
	number of bytes read (which can be less than @@var{nbytes} when
	end-of-file), or fails returning -1 (setting <<bfd_error>>).

	Calls @@var{close} when the BFD is later closed using
	<<bfd_close>>.  @@var{close} either succeeds returning 0, or
	fails returning -1 (setting <<bfd_error>>).

	If <<bfd_openr_iovec>> returns <<NULL>> then an error has
	occurred.  Possible errors are <<bfd_error_no_memory>>,
	<<bfd_error_invalid_target>> and <<bfd_error_system_call>>.

*/

struct opncls
{
  void *stream;
  file_ptr (*pread) (struct bfd *abfd, void *stream, void *buf,
		     file_ptr nbytes, file_ptr offset);
  int (*close) (struct bfd *abfd, void *stream);
  file_ptr where;
};

static file_ptr
opncls_btell (struct bfd *abfd)
{
  struct opncls *vec = abfd->iostream;
  return vec->where;
}

static int
opncls_bseek (struct bfd *abfd, file_ptr offset, int whence)
{
  struct opncls *vec = abfd->iostream;
  switch (whence)
    {
    case SEEK_SET: vec->where = offset; break;
    case SEEK_CUR: vec->where += offset; break;
    case SEEK_END: return -1;
    }
  return 0;
}

static file_ptr
opncls_bread (struct bfd *abfd, void *buf, file_ptr nbytes)
{
  struct opncls *vec = abfd->iostream;
  file_ptr nread = vec->pread (abfd, vec->stream, buf, nbytes, vec->where);
  if (nread < 0)
    return nread;
  vec->where += nread;
  return nread;
}

static file_ptr
opncls_bwrite (struct bfd *abfd ATTRIBUTE_UNUSED,
	      const void *where ATTRIBUTE_UNUSED,
	      file_ptr nbytes ATTRIBUTE_UNUSED)
{
  return -1;
}

static int
opncls_bclose (struct bfd *abfd)
{
  struct opncls *vec = abfd->iostream;
  /* Since the VEC's memory is bound to the bfd deleting the bfd will
     free it.  */
  int status = 0;
  if (vec->close != NULL)
    status = vec->close (abfd, vec->stream);
  abfd->iostream = NULL;
  return status;
}

static int
opncls_bflush (struct bfd *abfd ATTRIBUTE_UNUSED)
{
  return 0;
}

static int
opncls_bstat (struct bfd *abfd ATTRIBUTE_UNUSED, struct stat *sb)
{
  memset (sb, 0, sizeof (*sb));
  return 0;
}

static const struct bfd_iovec opncls_iovec = {
  &opncls_bread, &opncls_bwrite, &opncls_btell, &opncls_bseek,
  &opncls_bclose, &opncls_bflush, &opncls_bstat
};

bfd *
bfd_openr_iovec (const char *filename, const char *target,
		 void *(*open) (struct bfd *nbfd,
				void *open_closure),
		 void *open_closure,
		 file_ptr (*pread) (struct bfd *abfd,
				    void *stream,
				    void *buf,
				    file_ptr nbytes,
				    file_ptr offset),
		 int (*close) (struct bfd *nbfd,
			       void *stream))
{
  bfd *nbfd;
  const bfd_target *target_vec;
  struct opncls *vec;
  void *stream;

  nbfd = _bfd_new_bfd ();
  if (nbfd == NULL)
    return NULL;

  target_vec = bfd_find_target (target, nbfd);
  if (target_vec == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  nbfd->filename = filename;
  nbfd->direction = read_direction;

  stream = open (nbfd, open_closure);
  if (stream == NULL)
    {
      _bfd_delete_bfd (nbfd);
      return NULL;
    }

  vec = bfd_zalloc (nbfd, sizeof (struct opncls));
  vec->stream = stream;
  vec->pread = pread;
  vec->close = close;

  nbfd->iovec = &opncls_iovec;
  nbfd->iostream = vec;

  return nbfd;
}
d418 1
a418 6
  /* FIXME: cagney/2004-02-15: Need to implement a BFD_IN_MEMORY io
     vector.  */
  if (!(abfd->flags & BFD_IN_MEMORY))
    ret = abfd->iovec->bclose (abfd);
  else
    ret = 0;
d633 1
a633 1
	void *bfd_alloc (bfd *abfd, bfd_size_type wanted);
d796 2
a797 1
  asection *sect;
d799 1
a799 1
  bfd_byte *contents;
d801 1
d811 8
a818 1
  if (!bfd_malloc_and_get_section (abfd, sect, &contents))
d820 1
a820 2
      if (contents != NULL)
	free (contents);
@


1.20
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d73 1
a73 2
  if (!bfd_hash_table_init_n (&nbfd->section_htab,
			      bfd_section_hash_newfunc,
d925 1
a925 1
  
d998 3
a1000 3
	section is found, examines the section for the name and checksum of
	a '.debug' file containing auxiliary debugging
	information. Searches filesystem for .debug file in some standard
d1002 5
a1006 2
	found returns the full filename. If @@var{dir} is NULL, will search
	default path configured into libbfd at build time.
d1011 1
a1011 1
	filename. The caller is responsible for freeing this string.
d1017 1
a1017 1
#if 0 /* Disabled until DEBUGDIR can be defined by configure.in  */
@


1.19
log
@2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* targets.c: Replace "struct sec" with "struct bfd_section"
	* syms.c, sparclynx.c, section.c, opncls.c: Ditto.
	* libcoff-in.h, libbfd-in.h, elfxx-target.h: Ditto.
	* elf.c, coffgen.c, bfd.c, bfd-in.h, aoutf1.h: Ditto.
	* aout-tic30.c, aout-target.h:
	* bfd-in2.h, libcoff.h, libbfd.h: Regenerate.

Index: binutils/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* coffgrok.h (coff_section): Replace 'struct sec" with "struct
	bfd_section".

Index: gdb/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c: Replace "struct sec" with "struct bfd_section".
	* objfiles.c, linespec.c, blockframe.c, block.c: Ditto.

Index: ld/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* pe-dll.c: Replace "struct sec" with "struct bfd_section".

Index: sim/common/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* sim-base.h: Replace "struct sec" with "struct bfd_section".
@
text
@d204 1
a204 1
	is to assume no cacheing; the file descriptor will remain open
@


1.18
log
@Convert to C90 and a few tweaks.
@
text
@d1027 1
a1027 1
	struct sec *bfd_create_gnu_debuglink_section
d1092 1
a1092 1
	  (bfd *abfd, struct sec *sect, const char *filename);
d1108 1
a1108 1
				   struct sec *sect,
@


1.17
log
@Fix --add-gnu-debuglink
@
text
@d50 1
a50 1
_bfd_new_bfd ()
d54 1
a54 1
  nbfd = (bfd *) bfd_zmalloc ((bfd_size_type) sizeof (bfd));
d60 1
a60 1
  nbfd->memory = (PTR) objalloc_create ();
d80 1
a80 1
  nbfd->sections = (asection *) NULL;
d83 1
a83 1
  nbfd->my_archive = (bfd *) NULL;
d88 1
a88 1
  nbfd->usrdata = (PTR) NULL;
d99 1
a99 2
_bfd_new_bfd_contained_in (obfd)
     bfd *obfd;
d116 1
a116 2
_bfd_delete_bfd (abfd)
     bfd *abfd;
d134 1
a134 1
	bfd *bfd_openr(const char *filename, const char *target);
d149 1
a149 3
bfd_openr (filename, target)
     const char *filename;
     const char *target;
d191 1
a191 1
	bfd *bfd_fdopenr(const char *filename, const char *target, int fd);
d213 1
a213 4
bfd_fdopenr (filename, target, fd)
     const char *filename;
     const char *target;
     int fd;
d240 1
a240 1
  nbfd->iostream = (PTR) fopen (filename, FOPEN_RB);
d245 3
a247 3
    case O_RDONLY: nbfd->iostream = (PTR) fdopen (fd, FOPEN_RB);   break;
    case O_WRONLY: nbfd->iostream = (PTR) fdopen (fd, FOPEN_RUB);  break;
    case O_RDWR:   nbfd->iostream = (PTR) fdopen (fd, FOPEN_RUB);  break;
d288 1
a288 1
	bfd *bfd_openstreamr(const char *, const char *, PTR);
d297 1
a297 4
bfd_openstreamr (filename, target, streamarg)
     const char *filename;
     const char *target;
     PTR streamarg;
d299 1
a299 1
  FILE *stream = (FILE *) streamarg;
d314 1
a314 1
  nbfd->iostream = (PTR) stream;
d337 1
a337 1
	bfd *bfd_openw(const char *filename, const char *target);
d348 1
a348 3
bfd_openw (filename, target)
     const char *filename;
     const char *target;
d406 1
a406 2
bfd_close (abfd)
     bfd *abfd;
d468 1
a468 2
bfd_close_all_done (abfd)
     bfd *abfd;
d503 1
a503 1
	bfd *bfd_create(const char *filename, bfd *templ);
d512 1
a512 3
bfd_create (filename, templ)
     const char *filename;
     bfd *templ;
d546 1
a546 2
bfd_make_writable(abfd)
     bfd *abfd;
d556 2
a557 3
  bim = ((struct bfd_in_memory *)
	 bfd_malloc ((bfd_size_type) sizeof (struct bfd_in_memory)));
  abfd->iostream = (PTR) bim;
d587 1
a587 2
bfd_make_readable(abfd)
     bfd *abfd;
d606 1
a606 1
  abfd->my_archive = (bfd *) NULL;
d611 1
a611 1
  abfd->usrdata = (PTR) NULL;
d634 1
a634 1
	PTR bfd_alloc (bfd *abfd, size_t wanted);
d642 2
a643 4
PTR
bfd_alloc (abfd, size)
     bfd *abfd;
     bfd_size_type size;
d645 1
a645 1
  PTR ret;
d659 2
a660 4
PTR
bfd_zalloc (abfd, size)
     bfd *abfd;
     bfd_size_type size;
d662 1
a662 1
  PTR res;
d674 1
a674 3
bfd_release (abfd, block)
     bfd *abfd;
     PTR block;
a693 4
static char *         get_debug_link_info         PARAMS ((bfd *, unsigned long *));
static bfd_boolean    separate_debug_file_exists  PARAMS ((const char *, const unsigned long));
static char *         find_separate_debug_file    PARAMS ((bfd *, const char *));

d700 2
a701 1
	unsigned long bfd_calc_gnu_debuglink_crc32 (unsigned long crc, const unsigned char *buf, bfd_size_type len);
d713 3
a715 4
bfd_calc_gnu_debuglink_crc32 (crc, buf, len)
     unsigned long crc;
     const unsigned char *buf;
     bfd_size_type len;
d786 1
a786 1
	char * get_debug_link_info (bfd * abfd, unsigned long * crc32_out)
d795 1
a795 3
get_debug_link_info (abfd, crc32_out)
     bfd * abfd;
     unsigned long * crc32_out;
d818 1
a818 2
  ret = bfd_get_section_contents (abfd, sect, contents,
				  (file_ptr)0, debuglink_size);
d829 1
a829 1
  crc32 = bfd_get_32 (abfd, (bfd_byte *) (contents + crc_offset));
d840 2
a841 1
	bfd_boolean separate_debug_file_exists (char * name, unsigned long crc32)
d849 1
a849 3
separate_debug_file_exists (name, crc)
     const char *name;
     const unsigned long crc;
d876 1
a876 1
	char * find_separate_debug_file (bfd *abfd)
d888 1
a888 3
find_separate_debug_file (abfd, debug_file_directory)
     bfd *abfd;
     const char *debug_file_directory;
d994 1
a994 1
	char * bfd_follow_gnu_debuglink(bfd *abfd, const char *dir);
d1013 1
a1013 3
bfd_follow_gnu_debuglink (abfd, dir)
     bfd *abfd;
     const char * dir;
d1027 2
a1028 1
	struct sec * bfd_create_gnu_debuglink_section (bfd * abfd, const char * filename);
d1041 1
a1041 3
bfd_create_gnu_debuglink_section 
    (bfd *        abfd,
     const char * filename)
d1043 2
a1044 2
  asection *      sect;
  bfd_size_type   debuglink_size;
d1091 2
a1092 1
	bfd_boolean bfd_fill_in_gnu_debuglink_section (bfd * abfd, struct sec * sect, const char * filename);
d1107 3
a1109 4
bfd_fill_in_gnu_debuglink_section
    (bfd *        abfd,
     struct sec * sect,
     const char * filename)
d1163 1
a1163 1
  bfd_put_32 (abfd, crc32, (bfd_byte *) (contents + crc_offset));
d1165 1
a1165 2
  if (! bfd_set_section_contents (abfd, sect, contents,
				  (file_ptr)0, debuglink_size))
@


1.16
log
@Add new switch to objcopy: --add-gnu-debuglink=<file>
Allows packages to be shipped in two forms, a stripped executable and debug
info file.
@
text
@d1061 1
a1061 1
	bfd_add_gnu_debuglink
d1064 1
a1064 1
	bfd_boolean bfd_add_gnu_debuglink (bfd * abfd, const char * filename);
d1068 69
a1136 3
	Takes a @@var{BFD} and adds a .gnu_debuglink section containing a link
	to the specified @@var{filename}.  The filename should be relative to
	the current directory.
d1144 4
a1147 3
bfd_add_gnu_debuglink (abfd, filename)
     bfd *abfd;
     const char * filename;
a1148 1
  asection * sect;
d1157 1
a1157 1
  if (abfd == NULL || filename == NULL)
a1184 18
  sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);
  if (sect)
    {
      /* Section already exists.  */
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  sect = bfd_make_section (abfd, GNU_DEBUGLINK);
  if (sect == NULL)
    return FALSE;

  if (! bfd_set_section_flags (abfd, sect,
			       SEC_HAS_CONTENTS | SEC_DEBUGGING))
    /* XXX Should we delete the section from the bfd ?  */
    return FALSE;

  
a1189 4
  if (! bfd_set_section_size (abfd, sect, debuglink_size))
    /* XXX Should we delete the section from the bfd ?  */
    return FALSE;
  
@


1.15
log
@Fix memory leaks
@
text
@a718 1
static unsigned long  calc_crc32                  PARAMS ((unsigned long, const unsigned char *, size_t));
d723 1
d725 2
a726 2
INTERNAL_FUNCTION
	calc_crc32
d729 1
a729 1
	unsigned long calc_crc32 (unsigned long crc, const unsigned char *buf, size_t len);
d732 6
a737 2
	Advance the CRC32 given by @@var{crc} through @@var{len}
	bytes of @@var{buf}. Return the updated CRC32 value.
d740 2
a741 2
static unsigned long
calc_crc32 (crc, buf, len)
d744 1
a744 1
     size_t len;
d815 1
a815 1
	char *get_debug_link_info (bfd *abfd, unsigned long *crc32_out)
d825 2
a826 2
     bfd *abfd;
     unsigned long *crc32_out;
d838 1
a838 1
  sect = bfd_get_section_by_name (abfd, ".gnu_debuglink");
d845 4
a848 1
  contents = xmalloc (debuglink_size);
d887 1
a887 1
  int count;
d896 1
a896 1
    file_crc = calc_crc32 (file_crc, buffer, count);
a939 1

d942 1
d949 6
a954 1
  dir = xstrdup (abfd->filename);
d965 11
a975 5
  debugfile = xmalloc (strlen (debug_file_directory) + 1
		       + strlen (dir)
		       + strlen (".debug/")
		       + strlen (basename) 
		       + 1);
d1057 111
@


1.14
log
@bfd_follow_gnu_debuglink: New function.  Follow the pointer contained inside a
.gnu_debuglink section.
@
text
@d934 1
a934 1
  if (basename == NULL || strlen (basename) < 1)
d936 5
@


1.13
log
@* bfd.c (struct _bfd): Added id field.
* opncls.c (_bfd_id_counter): New static variable.
(_bfd_new_bfd): Use it.
* bfd-in2.h: Rebuilt.
@
text
@d3 1
a3 1
   2001, 2002
d28 1
d702 332
@


1.12
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d39 4
d56 2
@


1.11
log
@	* opncls.c: Formatting.
	(_bfd_new_bfd): Use a smaller section hash table.
@
text
@d78 2
a79 2
  nbfd->opened_once = false;
  nbfd->output_has_begun = false;
d82 1
a82 1
  nbfd->cacheable = false;
d84 1
a84 1
  nbfd->mtime_set = false;
d278 1
a278 1
  nbfd->opened_once = true;
d391 1
a391 1
	boolean bfd_close(bfd *abfd);
d406 1
a406 1
	<<true>> is returned if all is ok, otherwise <<false>>.
d410 1
a410 1
boolean
d414 1
a414 1
  boolean ret;
d419 1
a419 1
	return false;
d423 1
a423 1
    return false;
d456 1
a456 1
	boolean bfd_close_all_done(bfd *);
d470 1
a470 1
	<<true>> is returned if all is ok, otherwise <<false>>.
d473 1
a473 1
boolean
d477 1
a477 1
  boolean ret;
d542 1
a542 1
	boolean bfd_make_writable(bfd *abfd);
d551 1
a551 1
	<<true>> is returned if all is ok, otherwise <<false>>.
d554 1
a554 1
boolean
d563 1
a563 1
      return false;
d577 1
a577 1
  return true;
d585 1
a585 1
	boolean bfd_make_readable(bfd *abfd);
d595 1
a595 1
	<<true>> is returned if all is ok, otherwise <<false>>.  */
d597 1
a597 1
boolean
d604 1
a604 1
      return false;
d608 1
a608 1
    return false;
d611 1
a611 1
    return false;
d620 2
a621 2
  abfd->opened_once = false;
  abfd->output_has_begun = false;
d624 1
a624 1
  abfd->cacheable = false;
d626 1
a626 1
  abfd->mtime_set = false;
d628 1
a628 1
  abfd->target_defaulted = true;
d638 1
a638 1
  return true;
@


1.10
log
@	* opncls.c (bfd_openr): Remove redundant bfd_set_error.
	(bfd_fdopenr): Likewise.
	(bfd_openstreamr): Likewise.
	(bfd_openw): Likewise.
@
text
@d66 3
a68 1
  if (!bfd_hash_table_init (&nbfd->section_htab, bfd_section_hash_newfunc))
d129 1
a129 1
        bfd *bfd_openr(const char *filename, const char *target);
d139 2
a140 1
	are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> or <<system_call>> error.
d185 1
a185 1
         bfd_fdopenr
d188 1
a188 1
         bfd *bfd_fdopenr(const char *filename, const char *target, int fd);
d191 13
a203 14
         <<bfd_fdopenr>> is to <<bfd_fopenr>> much like <<fdopen>> is to <<fopen>>.
	 It opens a BFD on a file already described by the @@var{fd}
	 supplied.

	 When the file is later <<bfd_close>>d, the file descriptor will be closed.

	 If the caller desires that this file descriptor be cached by BFD
	 (opened as needed, closed as needed to free descriptors for
	 other opens), with the supplied @@var{fd} used as an initial
	 file descriptor (but subject to closure at any time), call
	 bfd_set_cacheable(bfd, 1) on the returned BFD.  The default is to
	 assume no cacheing; the file descriptor will remain open until
	 <<bfd_close>>, and will not be affected by BFD operations on other
	 files.
d205 2
a206 1
         Possible errors are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> and <<bfd_error_system_call>>.
d395 4
a398 4
	Close a BFD. If the BFD was open for writing,
	then pending operations are completed and the file written out
	and closed. If the created file is executable, then
	<<chmod>> is called to mark it as such.
d437 1
a437 1
 	  unsigned int mask = umask (0);
d459 4
a462 4
	Close a BFD.  Differs from <<bfd_close>>
	since it does not complete any pending operations.  This
	routine would be used if the application had just used BFD for
	swapping and didn't want to use any of the writing code.
d513 3
a515 4
	Create a new BFD in the manner of
	<<bfd_openw>>, but without opening a file. The new BFD
	takes the target from the target used by @@var{template}. The
	format is always set to <<bfd_object>>.
@


1.10.14.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d66 1
a66 3
  if (!bfd_hash_table_init_n (&nbfd->section_htab,
			      bfd_section_hash_newfunc,
			      251))
d127 1
a127 1
	bfd *bfd_openr(const char *filename, const char *target);
d137 1
a137 2
	are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> or
	<<system_call>> error.
d182 1
a182 1
	bfd_fdopenr
d185 1
a185 1
	bfd *bfd_fdopenr(const char *filename, const char *target, int fd);
d188 14
a201 13
	<<bfd_fdopenr>> is to <<bfd_fopenr>> much like <<fdopen>> is to
	<<fopen>>.  It opens a BFD on a file already described by the
	@@var{fd} supplied.

	When the file is later <<bfd_close>>d, the file descriptor will
	be closed.  If the caller desires that this file descriptor be
	cached by BFD (opened as needed, closed as needed to free
	descriptors for other opens), with the supplied @@var{fd} used as
	an initial file descriptor (but subject to closure at any time),
	call bfd_set_cacheable(bfd, 1) on the returned BFD.  The default
	is to assume no cacheing; the file descriptor will remain open
	until <<bfd_close>>, and will not be affected by BFD operations
	on other files.
d203 1
a203 2
	Possible errors are <<bfd_error_no_memory>>,
	<<bfd_error_invalid_target>> and <<bfd_error_system_call>>.
d392 4
a395 4
	Close a BFD. If the BFD was open for writing, then pending
	operations are completed and the file written out and closed.
	If the created file is executable, then <<chmod>> is called
	to mark it as such.
d434 1
a434 1
	  unsigned int mask = umask (0);
d456 4
a459 4
	Close a BFD.  Differs from <<bfd_close>> since it does not
	complete any pending operations.  This routine would be used
	if the application had just used BFD for swapping and didn't
	want to use any of the writing code.
d510 4
a513 3
	Create a new BFD in the manner of <<bfd_openw>>, but without
	opening a file. The new BFD takes the target from the target
	used by @@var{template}. The format is always set to <<bfd_object>>.
@


1.10.14.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2001, 2002, 2003
a27 1
#include "libiberty.h"
a38 4
/* Counter used to initialize the bfd identifier.  */

static unsigned int _bfd_id_counter = 0;

d45 1
a45 1
_bfd_new_bfd (void)
d49 1
a49 1
  nbfd = bfd_zmalloc (sizeof (bfd));
d53 1
a53 3
  nbfd->id = _bfd_id_counter++;

  nbfd->memory = objalloc_create ();
d73 1
a73 1
  nbfd->sections = NULL;
d76 1
a76 1
  nbfd->my_archive = NULL;
d78 2
a79 2
  nbfd->opened_once = FALSE;
  nbfd->output_has_begun = FALSE;
d81 2
a82 2
  nbfd->usrdata = NULL;
  nbfd->cacheable = FALSE;
d84 1
a84 1
  nbfd->mtime_set = FALSE;
d92 2
a93 1
_bfd_new_bfd_contained_in (bfd *obfd)
d110 2
a111 1
_bfd_delete_bfd (bfd *abfd)
d129 1
a129 1
	bfd *bfd_openr (const char *filename, const char *target);
d144 3
a146 1
bfd_openr (const char *filename, const char *target)
d188 1
a188 1
	bfd *bfd_fdopenr (const char *filename, const char *target, int fd);
d201 1
a201 1
	is to assume no caching; the file descriptor will remain open
d210 4
a213 1
bfd_fdopenr (const char *filename, const char *target, int fd)
d240 1
a240 1
  nbfd->iostream = fopen (filename, FOPEN_RB);
d245 3
a247 3
    case O_RDONLY: nbfd->iostream = fdopen (fd, FOPEN_RB);   break;
    case O_WRONLY: nbfd->iostream = fdopen (fd, FOPEN_RUB);  break;
    case O_RDWR:   nbfd->iostream = fdopen (fd, FOPEN_RUB);  break;
d278 1
a278 1
  nbfd->opened_once = TRUE;
d288 1
a288 1
	bfd *bfd_openstreamr (const char *, const char *, void *);
d297 4
a300 1
bfd_openstreamr (const char *filename, const char *target, void *streamarg)
d302 1
a302 1
  FILE *stream = streamarg;
d317 1
a317 1
  nbfd->iostream = stream;
d340 1
a340 1
	bfd *bfd_openw (const char *filename, const char *target);
d351 3
a353 1
bfd_openw (const char *filename, const char *target)
d391 1
a391 1
	bfd_boolean bfd_close (bfd *abfd);
d406 1
a406 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
d410 3
a412 2
bfd_boolean
bfd_close (bfd *abfd)
d414 1
a414 1
  bfd_boolean ret;
d419 1
a419 1
	return FALSE;
d423 1
a423 1
    return FALSE;
d456 1
a456 1
	bfd_boolean bfd_close_all_done (bfd *);
d470 1
a470 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
d473 3
a475 2
bfd_boolean
bfd_close_all_done (bfd *abfd)
d477 1
a477 1
  bfd_boolean ret;
d510 1
a510 1
	bfd *bfd_create (const char *filename, bfd *templ);
d519 3
a521 1
bfd_create (const char *filename, bfd *templ)
d542 1
a542 1
	bfd_boolean bfd_make_writable (bfd *abfd);
d551 1
a551 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
d554 3
a556 2
bfd_boolean
bfd_make_writable (bfd *abfd)
d563 1
a563 1
      return FALSE;
d566 3
a568 2
  bim = bfd_malloc (sizeof (struct bfd_in_memory));
  abfd->iostream = bim;
d577 1
a577 1
  return TRUE;
d585 1
a585 1
	bfd_boolean bfd_make_readable (bfd *abfd);
d595 1
a595 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.  */
d597 3
a599 2
bfd_boolean
bfd_make_readable (bfd *abfd)
d604 1
a604 1
      return FALSE;
d608 1
a608 1
    return FALSE;
d611 1
a611 1
    return FALSE;
d618 1
a618 1
  abfd->my_archive = NULL;
d620 2
a621 2
  abfd->opened_once = FALSE;
  abfd->output_has_begun = FALSE;
d623 2
a624 2
  abfd->usrdata = NULL;
  abfd->cacheable = FALSE;
d626 1
a626 1
  abfd->mtime_set = FALSE;
d628 1
a628 1
  abfd->target_defaulted = TRUE;
d638 1
a638 1
  return TRUE;
d646 1
a646 1
	void *bfd_alloc (bfd *abfd, size_t wanted);
d654 4
a657 2
void *
bfd_alloc (bfd *abfd, bfd_size_type size)
d659 1
a659 1
  void *ret;
d673 4
a676 2
void *
bfd_zalloc (bfd *abfd, bfd_size_type size)
d678 1
a678 1
  void *res;
d690 3
a692 1
bfd_release (bfd *abfd, void *block)
a694 496
}


/* 
   GNU Extension: separate debug-info files 
   
   The idea here is that a special section called .gnu_debuglink might be
   embedded in a binary file, which indicates that some *other* file
   contains the real debugging information. This special section contains a
   filename and CRC32 checksum, which we read and resolve to another file,
   if it exists.

   This facilitates "optional" provision of debugging information, without
   having to provide two complete copies of every binary object (with and
   without debug symbols).
*/

#define GNU_DEBUGLINK	".gnu_debuglink"
/*
FUNCTION
	bfd_calc_gnu_debuglink_crc32

SYNOPSIS
	unsigned long bfd_calc_gnu_debuglink_crc32
	  (unsigned long crc, const unsigned char *buf, bfd_size_type len);

DESCRIPTION
	Computes a CRC value as used in the .gnu_debuglink section.
	Advances the previously computed @@var{crc} value by computing
	and adding in the crc32 for @@var{len} bytes of @@var{buf}.

RETURNS
	Return the updated CRC32 value.
*/     

unsigned long
bfd_calc_gnu_debuglink_crc32 (unsigned long crc,
			      const unsigned char *buf,
			      bfd_size_type len)
{
  static const unsigned long crc32_table[256] =
    {
      0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
      0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
      0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
      0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
      0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
      0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
      0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
      0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
      0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
      0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
      0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
      0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
      0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
      0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
      0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
      0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
      0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
      0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
      0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
      0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
      0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
      0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
      0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
      0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
      0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
      0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
      0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
      0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
      0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
      0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
      0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
      0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
      0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
      0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
      0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
      0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
      0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
      0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
      0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
      0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
      0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
      0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
      0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
      0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
      0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
      0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
      0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
      0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
      0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
      0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
      0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
      0x2d02ef8d
    };
  const unsigned char *end;

  crc = ~crc & 0xffffffff;
  for (end = buf + len; buf < end; ++ buf)
    crc = crc32_table[(crc ^ *buf) & 0xff] ^ (crc >> 8);
  return ~crc & 0xffffffff;;
}


/*
INTERNAL_FUNCTION
	get_debug_link_info

SYNOPSIS
	char *get_debug_link_info (bfd *abfd, unsigned long *crc32_out);

DESCRIPTION
	fetch the filename and CRC32 value for any separate debuginfo
	associated with @@var{abfd}. Return NULL if no such info found,
	otherwise return filename and update @@var{crc32_out}.
*/

static char *
get_debug_link_info (bfd *abfd, unsigned long *crc32_out)
{
  asection * sect;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char * contents;
  int crc_offset;
  bfd_boolean ret;

  BFD_ASSERT (abfd);
  BFD_ASSERT (crc32_out);

  sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);

  if (sect == NULL)
    return NULL;

  debuglink_size = bfd_section_size (abfd, sect);  

  contents = malloc (debuglink_size);
  if (contents == NULL)
    return NULL;

  ret = bfd_get_section_contents (abfd, sect, contents, 0, debuglink_size);
  if (! ret)
    {
      free (contents);
      return NULL;
    }

  /* Crc value is stored after the filename, aligned up to 4 bytes.  */
  crc_offset = strlen (contents) + 1;
  crc_offset = (crc_offset + 3) & ~3;

  crc32 = bfd_get_32 (abfd, contents + crc_offset);

  *crc32_out = crc32;
  return contents;
}

/*
INTERNAL_FUNCTION
	separate_debug_file_exists

SYNOPSIS
	bfd_boolean separate_debug_file_exists
	  (char *name, unsigned long crc32);

DESCRIPTION
	Checks to see if @@var{name} is a file and if its contents
	match @@var{crc32}.
*/

static bfd_boolean
separate_debug_file_exists (const char *name, const unsigned long crc)
{
  static char buffer [8 * 1024];
  unsigned long file_crc = 0;
  int fd;
  bfd_size_type count;

  BFD_ASSERT (name);

  fd = open (name, O_RDONLY);
  if (fd < 0)
    return FALSE;

  while ((count = read (fd, buffer, sizeof (buffer))) > 0)
    file_crc = bfd_calc_gnu_debuglink_crc32 (file_crc, buffer, count);

  close (fd);

  return crc == file_crc;
}


/*
INTERNAL_FUNCTION
	find_separate_debug_file

SYNOPSIS
	char *find_separate_debug_file (bfd *abfd);

DESCRIPTION
	Searches @@var{abfd} for a reference to separate debugging
	information, scans various locations in the filesystem, including
	the file tree rooted at @@var{debug_file_directory}, and returns a
	filename of such debugging information if the file is found and has
	matching CRC32.  Returns NULL if no reference to debugging file
	exists, or file cannot be found.
*/

static char *
find_separate_debug_file (bfd *abfd, const char *debug_file_directory)
{
  char *basename;
  char *dir;
  char *debugfile;
  unsigned long crc32;
  int i;

  BFD_ASSERT (abfd);
  if (debug_file_directory == NULL)
    debug_file_directory = ".";

  /* BFD may have been opened from a stream.  */
  if (! abfd->filename)
    return NULL;

  basename = get_debug_link_info (abfd, & crc32);
  if (basename == NULL)
    return NULL;

  if (strlen (basename) < 1)
    {
      free (basename);
      return NULL;
    }

  dir = strdup (abfd->filename);
  if (dir == NULL)
    {
      free (basename);
      return NULL;
    }
  BFD_ASSERT (strlen (dir) != 0);
  
  /* Strip off filename part.  */
  for (i = strlen (dir) - 1; i >= 0; i--)
    if (IS_DIR_SEPARATOR (dir[i]))
      break;
  
  dir[i + 1] = '\0';
  BFD_ASSERT (dir[i] == '/' || dir[0] == '\0')

  debugfile = malloc (strlen (debug_file_directory) + 1
		      + strlen (dir)
		      + strlen (".debug/")
		      + strlen (basename) 
		      + 1);
  if (debugfile == NULL)
    {
      free (basename);
      free (dir);
      return NULL;
    }

  /* First try in the same directory as the original file:  */
  strcpy (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  /* Then try in a subdirectory called .debug.  */
  strcpy (debugfile, dir);
  strcat (debugfile, ".debug/");
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  /* Then try in the global debugfile directory.  */
  strcpy (debugfile, debug_file_directory);
  i = strlen (debug_file_directory) - 1;
  if (i > 0
      && debug_file_directory[i] != '/'
      && dir[0] != '/')
    strcat (debugfile, "/");
  strcat (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  free (debugfile);
  free (basename);
  free (dir);
  return NULL;
}


/*
FUNCTION
	bfd_follow_gnu_debuglink

SYNOPSIS
	char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);

DESCRIPTION

	Takes a BFD and searches it for a .gnu_debuglink section.  If this
	section is found, examines the section for the name and checksum of
	a '.debug' file containing auxiliary debugging
	information. Searches filesystem for .debug file in some standard
	locations, including the directory tree rooted at @@var{dir}, and if
	found returns the full filename. If @@var{dir} is NULL, will search
	default path configured into libbfd at build time.

RETURNS
	<<NULL>> on any errors or failure to locate the .debug file,
	otherwise a pointer to a heap-allocated string containing the
	filename. The caller is responsible for freeing this string.
*/

char *
bfd_follow_gnu_debuglink (bfd *abfd, const char *dir)
{
#if 0 /* Disabled until DEBUGDIR can be defined by configure.in  */
  if (dir == NULL)
    dir = DEBUGDIR;
#endif
  return find_separate_debug_file (abfd, dir);
}

/*
FUNCTION
	bfd_create_gnu_debuglink_section

SYNOPSIS
	struct bfd_section *bfd_create_gnu_debuglink_section
	  (bfd *abfd, const char *filename);

DESCRIPTION

	Takes a @@var{BFD} and adds a .gnu_debuglink section to it.  The section is sized
	to be big enough to contain a link to the specified @@var{filename}.

RETURNS
	A pointer to the new section is returned if all is ok.  Otherwise <<NULL>> is
	returned and bfd_error is set.  
*/

asection *
bfd_create_gnu_debuglink_section (bfd *abfd, const char *filename)
{
  asection *sect;
  bfd_size_type debuglink_size;

  if (abfd == NULL || filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  /* Strip off any path components in filename.  */
  filename = lbasename (filename);
  
  sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);
  if (sect)
    {
      /* Section already exists.  */
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  sect = bfd_make_section (abfd, GNU_DEBUGLINK);
  if (sect == NULL)
    return NULL;

  if (! bfd_set_section_flags (abfd, sect,
			       SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING))
    /* XXX Should we delete the section from the bfd ?  */
    return NULL;

  
  debuglink_size = strlen (filename) + 1;
  debuglink_size += 3;
  debuglink_size &= ~3;
  debuglink_size += 4;

  if (! bfd_set_section_size (abfd, sect, debuglink_size))
    /* XXX Should we delete the section from the bfd ?  */
    return NULL;
  
  return sect;
}


/*
FUNCTION
	bfd_fill_in_gnu_debuglink_section

SYNOPSIS
	bfd_boolean bfd_fill_in_gnu_debuglink_section
	  (bfd *abfd, struct bfd_section *sect, const char *filename);

DESCRIPTION

	Takes a @@var{BFD} and containing a .gnu_debuglink section @@var{SECT}
	and fills in the contents of the section to contain a link to the
	specified @@var{filename}.  The filename should be relative to the
	current directory.

RETURNS
	<<TRUE>> is returned if all is ok.  Otherwise <<FALSE>> is returned
	and bfd_error is set.  
*/

bfd_boolean
bfd_fill_in_gnu_debuglink_section (bfd *abfd,
				   struct bfd_section *sect,
				   const char *filename)
{
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char * contents;
  bfd_size_type crc_offset;
  FILE * handle;
  static char buffer[8 * 1024];
  size_t count;

  if (abfd == NULL || sect == NULL || filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Make sure that we can read the file.
     XXX - Should we attempt to locate the debug info file using the same
     algorithm as gdb ?  At the moment, since we are creating the
     .gnu_debuglink section, we insist upon the user providing us with a
     correct-for-section-creation-time path, but this need not conform to
     the gdb location algorithm.  */
  handle = fopen (filename, FOPEN_RB);
  if (handle == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      return FALSE;
    }

  crc32 = 0;
  while ((count = fread (buffer, 1, sizeof buffer, handle)) > 0)
    crc32 = bfd_calc_gnu_debuglink_crc32 (crc32, buffer, count);
  fclose (handle);

  /* Strip off any path components in filename,
     now that we no longer need them.  */
  filename = lbasename (filename);
  
  debuglink_size = strlen (filename) + 1;
  debuglink_size += 3;
  debuglink_size &= ~3;
  debuglink_size += 4;

  contents = malloc (debuglink_size);
  if (contents == NULL)
    {
      /* XXX Should we delete the section from the bfd ?  */
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }

  strcpy (contents, filename);
  crc_offset = debuglink_size - 4;

  bfd_put_32 (abfd, crc32, contents + crc_offset);

  if (! bfd_set_section_contents (abfd, sect, contents, 0, debuglink_size))
    {
      /* XXX Should we delete the section from the bfd ?  */
      free (contents);
      return FALSE;
    }

  return TRUE;
@


1.10.14.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d73 2
a74 1
  if (!bfd_hash_table_init_n (& nbfd->section_htab, bfd_section_hash_newfunc,
d926 1
a926 1

d999 3
a1001 3
	section is found, it examines the section for the name and checksum
	of a '.debug' file containing auxiliary debugging information.  It
	then searches the filesystem for this .debug file in some standard
d1003 2
a1004 5
	found returns the full filename.

	If @@var{dir} is NULL, it will search a default path configured into
	libbfd at build time.  [XXX this feature is not currently
	implemented].
d1009 1
a1009 1
	filename.  The caller is responsible for freeing this string.
d1015 1
a1015 1
#if 0 /* Disabled until DEBUGDIR can be defined by configure.in.  */
@


1.10.12.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d66 1
a66 3
  if (!bfd_hash_table_init_n (&nbfd->section_htab,
			      bfd_section_hash_newfunc,
			      251))
d127 1
a127 1
	bfd *bfd_openr(const char *filename, const char *target);
d137 1
a137 2
	are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> or
	<<system_call>> error.
d182 1
a182 1
	bfd_fdopenr
d185 1
a185 1
	bfd *bfd_fdopenr(const char *filename, const char *target, int fd);
d188 14
a201 13
	<<bfd_fdopenr>> is to <<bfd_fopenr>> much like <<fdopen>> is to
	<<fopen>>.  It opens a BFD on a file already described by the
	@@var{fd} supplied.

	When the file is later <<bfd_close>>d, the file descriptor will
	be closed.  If the caller desires that this file descriptor be
	cached by BFD (opened as needed, closed as needed to free
	descriptors for other opens), with the supplied @@var{fd} used as
	an initial file descriptor (but subject to closure at any time),
	call bfd_set_cacheable(bfd, 1) on the returned BFD.  The default
	is to assume no cacheing; the file descriptor will remain open
	until <<bfd_close>>, and will not be affected by BFD operations
	on other files.
d203 1
a203 2
	Possible errors are <<bfd_error_no_memory>>,
	<<bfd_error_invalid_target>> and <<bfd_error_system_call>>.
d392 4
a395 4
	Close a BFD. If the BFD was open for writing, then pending
	operations are completed and the file written out and closed.
	If the created file is executable, then <<chmod>> is called
	to mark it as such.
d434 1
a434 1
	  unsigned int mask = umask (0);
d456 4
a459 4
	Close a BFD.  Differs from <<bfd_close>> since it does not
	complete any pending operations.  This routine would be used
	if the application had just used BFD for swapping and didn't
	want to use any of the writing code.
d510 4
a513 3
	Create a new BFD in the manner of <<bfd_openw>>, but without
	opening a file. The new BFD takes the target from the target
	used by @@var{template}. The format is always set to <<bfd_object>>.
@


1.10.12.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d78 2
a79 2
  nbfd->opened_once = FALSE;
  nbfd->output_has_begun = FALSE;
d82 1
a82 1
  nbfd->cacheable = FALSE;
d84 1
a84 1
  nbfd->mtime_set = FALSE;
d278 1
a278 1
  nbfd->opened_once = TRUE;
d391 1
a391 1
	bfd_boolean bfd_close (bfd *abfd);
d406 1
a406 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
d410 1
a410 1
bfd_boolean
d414 1
a414 1
  bfd_boolean ret;
d419 1
a419 1
	return FALSE;
d423 1
a423 1
    return FALSE;
d456 1
a456 1
	bfd_boolean bfd_close_all_done (bfd *);
d470 1
a470 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
d473 1
a473 1
bfd_boolean
d477 1
a477 1
  bfd_boolean ret;
d542 1
a542 1
	bfd_boolean bfd_make_writable (bfd *abfd);
d551 1
a551 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.
d554 1
a554 1
bfd_boolean
d563 1
a563 1
      return FALSE;
d577 1
a577 1
  return TRUE;
d585 1
a585 1
	bfd_boolean bfd_make_readable (bfd *abfd);
d595 1
a595 1
	<<TRUE>> is returned if all is ok, otherwise <<FALSE>>.  */
d597 1
a597 1
bfd_boolean
d604 1
a604 1
      return FALSE;
d608 1
a608 1
    return FALSE;
d611 1
a611 1
    return FALSE;
d620 2
a621 2
  abfd->opened_once = FALSE;
  abfd->output_has_begun = FALSE;
d624 1
a624 1
  abfd->cacheable = FALSE;
d626 1
a626 1
  abfd->mtime_set = FALSE;
d628 1
a628 1
  abfd->target_defaulted = TRUE;
d638 1
a638 1
  return TRUE;
@


1.10.12.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   2001, 2002, 2003
a27 1
#include "libiberty.h"
a38 4
/* Counter used to initialize the bfd identifier.  */

static unsigned int _bfd_id_counter = 0;

a52 2
  nbfd->id = _bfd_id_counter++;

a694 332
}


/* 
   GNU Extension: separate debug-info files 
   
   The idea here is that a special section called .gnu_debuglink might be
   embedded in a binary file, which indicates that some *other* file
   contains the real debugging information. This special section contains a
   filename and CRC32 checksum, which we read and resolve to another file,
   if it exists.

   This facilitates "optional" provision of debugging information, without
   having to provide two complete copies of every binary object (with and
   without debug symbols).
*/

static unsigned long  calc_crc32                  PARAMS ((unsigned long, const unsigned char *, size_t));
static char *         get_debug_link_info         PARAMS ((bfd *, unsigned long *));
static bfd_boolean    separate_debug_file_exists  PARAMS ((const char *, const unsigned long));
static char *         find_separate_debug_file    PARAMS ((bfd *, const char *));

/*
INTERNAL_FUNCTION
	calc_crc32

SYNOPSIS
	unsigned long calc_crc32 (unsigned long crc, const unsigned char *buf, size_t len);

DESCRIPTION
	Advance the CRC32 given by @@var{crc} through @@var{len}
	bytes of @@var{buf}. Return the updated CRC32 value.
*/     

static unsigned long
calc_crc32 (crc, buf, len)
     unsigned long crc;
     const unsigned char *buf;
     size_t len;
{
  static const unsigned long crc32_table[256] =
    {
      0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
      0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
      0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
      0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
      0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
      0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
      0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
      0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
      0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
      0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
      0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
      0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
      0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
      0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
      0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
      0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
      0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
      0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
      0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
      0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
      0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
      0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
      0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
      0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
      0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
      0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
      0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
      0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
      0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
      0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
      0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
      0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
      0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
      0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
      0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
      0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
      0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
      0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
      0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
      0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
      0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
      0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
      0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
      0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
      0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
      0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
      0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
      0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
      0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
      0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
      0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
      0x2d02ef8d
    };
  const unsigned char *end;

  crc = ~crc & 0xffffffff;
  for (end = buf + len; buf < end; ++ buf)
    crc = crc32_table[(crc ^ *buf) & 0xff] ^ (crc >> 8);
  return ~crc & 0xffffffff;;
}


/*
INTERNAL_FUNCTION
	get_debug_link_info

SYNOPSIS
	char *get_debug_link_info (bfd *abfd, unsigned long *crc32_out)

DESCRIPTION
	fetch the filename and CRC32 value for any separate debuginfo
	associated with @@var{abfd}. Return NULL if no such info found,
	otherwise return filename and update @@var{crc32_out}.
*/

static char *
get_debug_link_info (abfd, crc32_out)
     bfd *abfd;
     unsigned long *crc32_out;
{
  asection * sect;
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char * contents;
  int crc_offset;
  bfd_boolean ret;

  BFD_ASSERT (abfd);
  BFD_ASSERT (crc32_out);

  sect = bfd_get_section_by_name (abfd, ".gnu_debuglink");

  if (sect == NULL)
    return NULL;

  debuglink_size = bfd_section_size (abfd, sect);  

  contents = xmalloc (debuglink_size);
  ret = bfd_get_section_contents (abfd, sect, contents,
				  (file_ptr)0, debuglink_size);
  if (! ret)
    {
      free (contents);
      return NULL;
    }

  /* Crc value is stored after the filename, aligned up to 4 bytes.  */
  crc_offset = strlen (contents) + 1;
  crc_offset = (crc_offset + 3) & ~3;

  crc32 = bfd_get_32 (abfd, (bfd_byte *) (contents + crc_offset));

  *crc32_out = crc32;
  return contents;
}

/*
INTERNAL_FUNCTION
	separate_debug_file_exists

SYNOPSIS
	bfd_boolean separate_debug_file_exists (char * name, unsigned long crc32)

DESCRIPTION
	Checks to see if @@var{name} is a file and if its contents
	match @@var{crc32}.
*/

static bfd_boolean
separate_debug_file_exists (name, crc)
     const char *name;
     const unsigned long crc;
{
  static char buffer [8 * 1024];
  unsigned long file_crc = 0;
  int fd;
  int count;

  BFD_ASSERT (name);

  fd = open (name, O_RDONLY);
  if (fd < 0)
    return FALSE;

  while ((count = read (fd, buffer, sizeof (buffer))) > 0)
    file_crc = calc_crc32 (file_crc, buffer, count);

  close (fd);

  return crc == file_crc;
}


/*
INTERNAL_FUNCTION
	find_separate_debug_file

SYNOPSIS
	char * find_separate_debug_file (bfd *abfd)

DESCRIPTION
	Searches @@var{abfd} for a reference to separate debugging
	information, scans various locations in the filesystem, including
	the file tree rooted at @@var{debug_file_directory}, and returns a
	filename of such debugging information if the file is found and has
	matching CRC32.  Returns NULL if no reference to debugging file
	exists, or file cannot be found.
*/

static char *
find_separate_debug_file (abfd, debug_file_directory)
     bfd *abfd;
     const char *debug_file_directory;
{
  char *basename;
  char *dir;
  char *debugfile;
  unsigned long crc32;
  int i;

  BFD_ASSERT (abfd);
  if (debug_file_directory == NULL)
    debug_file_directory = ".";

  /* BFD may have been opened from a stream.  */
  if (! abfd->filename)
    return NULL;

  basename = get_debug_link_info (abfd, & crc32);

  if (basename == NULL || strlen (basename) < 1)
    return NULL;

  dir = xstrdup (abfd->filename);
  BFD_ASSERT (strlen (dir) != 0);
  
  /* Strip off filename part.  */
  for (i = strlen (dir) - 1; i >= 0; i--)
    if (IS_DIR_SEPARATOR (dir[i]))
      break;
  
  dir[i + 1] = '\0';
  BFD_ASSERT (dir[i] == '/' || dir[0] == '\0')

  debugfile = xmalloc (strlen (debug_file_directory) + 1
		       + strlen (dir)
		       + strlen (".debug/")
		       + strlen (basename) 
		       + 1);

  /* First try in the same directory as the original file:  */
  strcpy (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  /* Then try in a subdirectory called .debug.  */
  strcpy (debugfile, dir);
  strcat (debugfile, ".debug/");
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  /* Then try in the global debugfile directory.  */
  strcpy (debugfile, debug_file_directory);
  i = strlen (debug_file_directory) - 1;
  if (i > 0
      && debug_file_directory[i] != '/'
      && dir[0] != '/')
    strcat (debugfile, "/");
  strcat (debugfile, dir);
  strcat (debugfile, basename);

  if (separate_debug_file_exists (debugfile, crc32))
    {
      free (basename);
      free (dir);
      return debugfile;
    }

  free (debugfile);
  free (basename);
  free (dir);
  return NULL;
}


/*
FUNCTION
	bfd_follow_gnu_debuglink

SYNOPSIS
	char * bfd_follow_gnu_debuglink(bfd *abfd, const char *dir);

DESCRIPTION

	Takes a BFD and searches it for a .gnu_debuglink section.  If this
	section is found, examines the section for the name and checksum of
	a '.debug' file containing auxiliary debugging
	information. Searches filesystem for .debug file in some standard
	locations, including the directory tree rooted at @@var{dir}, and if
	found returns the full filename. If @@var{dir} is NULL, will search
	default path configured into libbfd at build time.

RETURNS
	<<NULL>> on any errors or failure to locate the .debug file,
	otherwise a pointer to a heap-allocated string containing the
	filename. The caller is responsible for freeing this string.
*/

char *
bfd_follow_gnu_debuglink (abfd, dir)
     bfd *abfd;
     const char * dir;
{
#if 0 /* Disabled until DEBUGDIR can be defined by configure.in  */
  if (dir == NULL)
    dir = DEBUGDIR;
#endif
  return find_separate_debug_file (abfd, dir);
@


1.10.12.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d934 1
a934 1
  if (basename == NULL)
a935 5
  if (strlen (basename) < 1)
    {
      free (basename);
      return NULL;
    }
@


1.10.12.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d719 1
a723 1
#define GNU_DEBUGLINK	".gnu_debuglink"
d725 2
a726 2
FUNCTION
	bfd_calc_gnu_debuglink_crc32
d729 1
a729 1
	unsigned long bfd_calc_gnu_debuglink_crc32 (unsigned long crc, const unsigned char *buf, bfd_size_type len);
d732 2
a733 6
	Computes a CRC value as used in the .gnu_debuglink section.
	Advances the previously computed @@var{crc} value by computing
	and adding in the crc32 for @@var{len} bytes of @@var{buf}.

RETURNS
	Return the updated CRC32 value.
d736 2
a737 2
unsigned long
bfd_calc_gnu_debuglink_crc32 (crc, buf, len)
d740 1
a740 1
     bfd_size_type len;
d811 1
a811 1
	char * get_debug_link_info (bfd * abfd, unsigned long * crc32_out)
d821 2
a822 2
     bfd * abfd;
     unsigned long * crc32_out;
d834 1
a834 1
  sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);
d841 1
a841 4
  contents = malloc (debuglink_size);
  if (contents == NULL)
    return NULL;

d880 1
a880 1
  bfd_size_type count;
d889 1
a889 1
    file_crc = bfd_calc_gnu_debuglink_crc32 (file_crc, buffer, count);
d933 1
a935 1

d942 1
a942 6
  dir = strdup (abfd->filename);
  if (dir == NULL)
    {
      free (basename);
      return NULL;
    }
d953 5
a957 11
  debugfile = malloc (strlen (debug_file_directory) + 1
		      + strlen (dir)
		      + strlen (".debug/")
		      + strlen (basename) 
		      + 1);
  if (debugfile == NULL)
    {
      free (basename);
      free (dir);
      return NULL;
    }
a1038 155
}

/*
FUNCTION
	bfd_create_gnu_debuglink_section

SYNOPSIS
	struct sec * bfd_create_gnu_debuglink_section (bfd * abfd, const char * filename);

DESCRIPTION

	Takes a @@var{BFD} and adds a .gnu_debuglink section to it.  The section is sized
	to be big enough to contain a link to the specified @@var{filename}.

RETURNS
	A pointer to the new section is returned if all is ok.  Otherwise <<NULL>> is
	returned and bfd_error is set.  
*/

asection *
bfd_create_gnu_debuglink_section 
    (bfd *        abfd,
     const char * filename)
{
  asection *      sect;
  bfd_size_type   debuglink_size;

  if (abfd == NULL || filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  /* Strip off any path components in filename.  */
  filename = lbasename (filename);
  
  sect = bfd_get_section_by_name (abfd, GNU_DEBUGLINK);
  if (sect)
    {
      /* Section already exists.  */
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  sect = bfd_make_section (abfd, GNU_DEBUGLINK);
  if (sect == NULL)
    return NULL;

  if (! bfd_set_section_flags (abfd, sect,
			       SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING))
    /* XXX Should we delete the section from the bfd ?  */
    return NULL;

  
  debuglink_size = strlen (filename) + 1;
  debuglink_size += 3;
  debuglink_size &= ~3;
  debuglink_size += 4;

  if (! bfd_set_section_size (abfd, sect, debuglink_size))
    /* XXX Should we delete the section from the bfd ?  */
    return NULL;
  
  return sect;
}


/*
FUNCTION
	bfd_fill_in_gnu_debuglink_section

SYNOPSIS
	bfd_boolean bfd_fill_in_gnu_debuglink_section (bfd * abfd, struct sec * sect, const char * filename);

DESCRIPTION

	Takes a @@var{BFD} and containing a .gnu_debuglink section @@var{SECT}
	and fills in the contents of the section to contain a link to the
	specified @@var{filename}.  The filename should be relative to the
	current directory.

RETURNS
	<<TRUE>> is returned if all is ok.  Otherwise <<FALSE>> is returned
	and bfd_error is set.  
*/

bfd_boolean
bfd_fill_in_gnu_debuglink_section
    (bfd *        abfd,
     struct sec * sect,
     const char * filename)
{
  bfd_size_type debuglink_size;
  unsigned long crc32;
  char * contents;
  bfd_size_type crc_offset;
  FILE * handle;
  static char buffer[8 * 1024];
  size_t count;

  if (abfd == NULL || sect == NULL || filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Make sure that we can read the file.
     XXX - Should we attempt to locate the debug info file using the same
     algorithm as gdb ?  At the moment, since we are creating the
     .gnu_debuglink section, we insist upon the user providing us with a
     correct-for-section-creation-time path, but this need not conform to
     the gdb location algorithm.  */
  handle = fopen (filename, FOPEN_RB);
  if (handle == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      return FALSE;
    }

  crc32 = 0;
  while ((count = fread (buffer, 1, sizeof buffer, handle)) > 0)
    crc32 = bfd_calc_gnu_debuglink_crc32 (crc32, buffer, count);
  fclose (handle);

  /* Strip off any path components in filename,
     now that we no longer need them.  */
  filename = lbasename (filename);
  
  debuglink_size = strlen (filename) + 1;
  debuglink_size += 3;
  debuglink_size &= ~3;
  debuglink_size += 4;

  contents = malloc (debuglink_size);
  if (contents == NULL)
    {
      /* XXX Should we delete the section from the bfd ?  */
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }

  strcpy (contents, filename);
  crc_offset = debuglink_size - 4;

  bfd_put_32 (abfd, crc32, (bfd_byte *) (contents + crc_offset));

  if (! bfd_set_section_contents (abfd, sect, contents,
				  (file_ptr)0, debuglink_size))
    {
      /* XXX Should we delete the section from the bfd ?  */
      free (contents);
      return FALSE;
    }

  return TRUE;
@


1.10.12.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d50 1
a50 1
_bfd_new_bfd (void)
d54 1
a54 1
  nbfd = bfd_zmalloc (sizeof (bfd));
d60 1
a60 1
  nbfd->memory = objalloc_create ();
d80 1
a80 1
  nbfd->sections = NULL;
d83 1
a83 1
  nbfd->my_archive = NULL;
d88 1
a88 1
  nbfd->usrdata = NULL;
d99 2
a100 1
_bfd_new_bfd_contained_in (bfd *obfd)
d117 2
a118 1
_bfd_delete_bfd (bfd *abfd)
d136 1
a136 1
	bfd *bfd_openr (const char *filename, const char *target);
d151 3
a153 1
bfd_openr (const char *filename, const char *target)
d195 1
a195 1
	bfd *bfd_fdopenr (const char *filename, const char *target, int fd);
d217 4
a220 1
bfd_fdopenr (const char *filename, const char *target, int fd)
d247 1
a247 1
  nbfd->iostream = fopen (filename, FOPEN_RB);
d252 3
a254 3
    case O_RDONLY: nbfd->iostream = fdopen (fd, FOPEN_RB);   break;
    case O_WRONLY: nbfd->iostream = fdopen (fd, FOPEN_RUB);  break;
    case O_RDWR:   nbfd->iostream = fdopen (fd, FOPEN_RUB);  break;
d295 1
a295 1
	bfd *bfd_openstreamr (const char *, const char *, void *);
d304 4
a307 1
bfd_openstreamr (const char *filename, const char *target, void *streamarg)
d309 1
a309 1
  FILE *stream = streamarg;
d324 1
a324 1
  nbfd->iostream = stream;
d347 1
a347 1
	bfd *bfd_openw (const char *filename, const char *target);
d358 3
a360 1
bfd_openw (const char *filename, const char *target)
d418 2
a419 1
bfd_close (bfd *abfd)
d481 2
a482 1
bfd_close_all_done (bfd *abfd)
d517 1
a517 1
	bfd *bfd_create (const char *filename, bfd *templ);
d526 3
a528 1
bfd_create (const char *filename, bfd *templ)
d562 2
a563 1
bfd_make_writable (bfd *abfd)
d573 3
a575 2
  bim = bfd_malloc (sizeof (struct bfd_in_memory));
  abfd->iostream = bim;
d605 2
a606 1
bfd_make_readable (bfd *abfd)
d625 1
a625 1
  abfd->my_archive = NULL;
d630 1
a630 1
  abfd->usrdata = NULL;
d653 1
a653 1
	void *bfd_alloc (bfd *abfd, size_t wanted);
d661 4
a664 2
void *
bfd_alloc (bfd *abfd, bfd_size_type size)
d666 1
a666 1
  void *ret;
d680 4
a683 2
void *
bfd_zalloc (bfd *abfd, bfd_size_type size)
d685 1
a685 1
  void *res;
d697 3
a699 1
bfd_release (bfd *abfd, void *block)
d719 4
d729 1
a729 2
	unsigned long bfd_calc_gnu_debuglink_crc32
	  (unsigned long crc, const unsigned char *buf, bfd_size_type len);
d741 4
a744 3
bfd_calc_gnu_debuglink_crc32 (unsigned long crc,
			      const unsigned char *buf,
			      bfd_size_type len)
d815 1
a815 1
	char *get_debug_link_info (bfd *abfd, unsigned long *crc32_out);
d824 3
a826 1
get_debug_link_info (bfd *abfd, unsigned long *crc32_out)
d849 2
a850 1
  ret = bfd_get_section_contents (abfd, sect, contents, 0, debuglink_size);
d861 1
a861 1
  crc32 = bfd_get_32 (abfd, contents + crc_offset);
d872 1
a872 2
	bfd_boolean separate_debug_file_exists
	  (char *name, unsigned long crc32);
d880 3
a882 1
separate_debug_file_exists (const char *name, const unsigned long crc)
d909 1
a909 1
	char *find_separate_debug_file (bfd *abfd);
d921 3
a923 1
find_separate_debug_file (bfd *abfd, const char *debug_file_directory)
d1029 1
a1029 1
	char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);
d1048 3
a1050 1
bfd_follow_gnu_debuglink (bfd *abfd, const char *dir)
d1064 1
a1064 2
	struct sec *bfd_create_gnu_debuglink_section
	  (bfd *abfd, const char *filename);
d1077 3
a1079 1
bfd_create_gnu_debuglink_section (bfd *abfd, const char *filename)
d1081 2
a1082 2
  asection *sect;
  bfd_size_type debuglink_size;
d1129 1
a1129 2
	bfd_boolean bfd_fill_in_gnu_debuglink_section
	  (bfd *abfd, struct sec *sect, const char *filename);
d1144 4
a1147 3
bfd_fill_in_gnu_debuglink_section (bfd *abfd,
				   struct sec *sect,
				   const char *filename)
d1201 1
a1201 1
  bfd_put_32 (abfd, crc32, contents + crc_offset);
d1203 2
a1204 1
  if (! bfd_set_section_contents (abfd, sect, contents, 0, debuglink_size))
@


1.10.12.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1027 1
a1027 1
	struct bfd_section *bfd_create_gnu_debuglink_section
d1092 1
a1092 1
	  (bfd *abfd, struct bfd_section *sect, const char *filename);
d1108 1
a1108 1
				   struct bfd_section *sect,
@


1.10.12.8
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d204 1
a204 1
	is to assume no caching; the file descriptor will remain open
@


1.10.12.9
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d73 2
a74 1
  if (!bfd_hash_table_init_n (& nbfd->section_htab, bfd_section_hash_newfunc,
d926 1
a926 1

d999 3
a1001 3
	section is found, it examines the section for the name and checksum
	of a '.debug' file containing auxiliary debugging information.  It
	then searches the filesystem for this .debug file in some standard
d1003 2
a1004 5
	found returns the full filename.

	If @@var{dir} is NULL, it will search a default path configured into
	libbfd at build time.  [XXX this feature is not currently
	implemented].
d1009 1
a1009 1
	filename.  The caller is responsible for freeing this string.
d1015 1
a1015 1
#if 0 /* Disabled until DEBUGDIR can be defined by configure.in.  */
@


1.9
log
@	* opncls.c (_bfd_new_bfd_contained_in): Check return value of
	_bfd_new_bfd.
@
text
@a154 1
      bfd_set_error (bfd_error_invalid_target);
d222 2
a223 1
  if (fdflags == -1) return NULL;
a231 1
      bfd_set_error (bfd_error_invalid_target);
a309 1
      bfd_set_error (bfd_error_invalid_target);
a353 2

  bfd_set_error (bfd_error_system_call);
@


1.9.4.1
log
@Merge with trunk.
@
text
@d155 1
d223 1
a223 2
  if (fdflags == -1)
    return NULL;
d232 1
d311 1
d356 2
@


1.9.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d155 1
d223 1
a223 2
  if (fdflags == -1)
    return NULL;
d232 1
d311 1
d356 2
@


1.9.6.2
log
@merge from mainline
@
text
@d66 1
a66 3
  if (!bfd_hash_table_init_n (&nbfd->section_htab,
			      bfd_section_hash_newfunc,
			      251))
d127 1
a127 1
	bfd *bfd_openr(const char *filename, const char *target);
d137 1
a137 2
	are <<bfd_error_no_memory>>, <<bfd_error_invalid_target>> or
	<<system_call>> error.
d182 1
a182 1
	bfd_fdopenr
d185 1
a185 1
	bfd *bfd_fdopenr(const char *filename, const char *target, int fd);
d188 14
a201 13
	<<bfd_fdopenr>> is to <<bfd_fopenr>> much like <<fdopen>> is to
	<<fopen>>.  It opens a BFD on a file already described by the
	@@var{fd} supplied.

	When the file is later <<bfd_close>>d, the file descriptor will
	be closed.  If the caller desires that this file descriptor be
	cached by BFD (opened as needed, closed as needed to free
	descriptors for other opens), with the supplied @@var{fd} used as
	an initial file descriptor (but subject to closure at any time),
	call bfd_set_cacheable(bfd, 1) on the returned BFD.  The default
	is to assume no cacheing; the file descriptor will remain open
	until <<bfd_close>>, and will not be affected by BFD operations
	on other files.
d203 1
a203 2
	Possible errors are <<bfd_error_no_memory>>,
	<<bfd_error_invalid_target>> and <<bfd_error_system_call>>.
d392 4
a395 4
	Close a BFD. If the BFD was open for writing, then pending
	operations are completed and the file written out and closed.
	If the created file is executable, then <<chmod>> is called
	to mark it as such.
d434 1
a434 1
	  unsigned int mask = umask (0);
d456 4
a459 4
	Close a BFD.  Differs from <<bfd_close>> since it does not
	complete any pending operations.  This routine would be used
	if the application had just used BFD for swapping and didn't
	want to use any of the writing code.
d510 4
a513 3
	Create a new BFD in the manner of <<bfd_openw>>, but without
	opening a file. The new BFD takes the target from the target
	used by @@var{template}. The format is always set to <<bfd_object>>.
@


1.8
log
@	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
@
text
@d96 2
@


1.7
log
@Write contents if writeable.
@
text
@a616 1
  abfd->sections = (asection *) NULL;
d635 2
a636 1
  bfd_check_format(abfd, bfd_object);
@


1.6
log
@hash bfd sections for fast lookup and create.
bfd/ChangeLog
	* bfd.c (struct _bfd): Add section_htab, section_tail.
	* libbfd-in.h (_bfd_delete_bfd): Declare.
	(bfd_section_hash_newfunc): Declare.
	* opncls.c (_bfd_new_bfd): Free memory on failure.  Init
	section_htab and section_tail.
	(_bfd_delete_bfd): New function.
	(bfd_openr): Use it.
	(bfd_fdopenr): Likewise.
	(bfd_openstreamr): Likewise.
	(bfd_openw): Likewise.
	(bfd_close): Likewise.
	(bfd_close_all_done): Likewise.
	(bfd_release): Comment.
	* section.c (struct section_hash_entry): New.
	(bfd_section_hash_newfunc): New function.
	(section_hash_lookup): Define.
	(bfd_section_init): New function, split out from
	bfd_make_section_anyway.
	(bfd_get_section_by_name): Lookup via hash table.
	(bfd_get_unique_section_name): Likewise.
	(bfd_make_section_old_way): Rewrite to use hash table.
	(bfd_make_section_anyway): Likewise.
	(bfd_make_section): Likewise.  Return NULL for attempts to make
	BFD_{ABS,COM,UND,IND}_SECTION_NAME.
	(_bfd_strip_section_from_output): Adjust section_tail if needed.
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

ld/ChangeLog
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Adjust
	section_tail when fiddling with section list.
	(gld${EMULATION_NAME}_list_options): Ensure sentences aren't
	broken into separate strings to make translation easier.
	* emultempl/mmo.em (mmo_place_orphan): Adjust section_tail when
	fiddling with section list.
	* emultempl/pe.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
@
text
@d3 1
a3 1
   2001
d8 1
a8 1
This file is part of BFD, the Binary File Descriptor library.
d10 13
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a41 3
/* FIXME: This is no longer used.  */
long _bfd_chunksize = -1;

d163 1
a163 1
      /* File didn't exist, or some such */
d178 1
a178 2
       the file descriptor too, even though we didn't open it.
 */
d217 1
a217 1
  fdflags = O_RDWR;			/* Assume full access */
d238 1
a238 1
  /* (O_ACCMODE) parens are to avoid Ultrix header file bug */
d254 1
a254 2
  /* OK, put everything where it belongs */

d260 1
a260 1
  /* (O_ACCMODE) parens are to avoid Ultrix header file bug */
d327 2
a328 2
/** bfd_openw -- open for writing.
  Returns a pointer to a freshly-allocated BFD on success, or NULL.
d330 1
a330 1
  See comment by bfd_fdopenr before you try to modify this function. */
d358 1
a358 2
     reclaim it correctly. */

d375 2
a376 1
      bfd_set_error (bfd_error_system_call);	/* File not writeable, etc */
d415 1
a415 1
  if (!bfd_read_p (abfd))
d427 1
a427 1
     make it so */
d437 1
a469 1

d481 1
a481 1
     make it so */
d491 1
a515 1

d533 1
d569 1
a569 1
  /* bfd_bwrite will grow these as needed */
@


1.6.2.1
log
@	* reloc.c: Move sh relocs to where they belong.
	* libbfd.h, bfd-in2.h: Regenerate.

	Merge from mainline
	2002-04-26  Alan Modra  <amodra@@bigpond.net.au>
	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
	* elflink.h (elf_bfd_final_link): Ensure input bfd class is the
	same as the output before calling elf_link_input_bfd.
	* coffcode.h (coff_compute_section_file_positions): Set
	section_tail after shuffling section list.

	2002-04-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (hppa_type_of_stub): Correct and simplify condition
	under which a plt call stub is used.
	(final_link_relocate): Similarly.
	(allocate_plt_static): Clear h-plabel except when plt entry is
	exclusively used for a plabel.
	(allocate_dynrelocs): Use the above to simplify plt sizing.
	(struct elf32_hppa_link_hash_table): Add has_22bit_branch.
	(elf32_hppa_link_hash_table_create): Init.
	(BL22_RP): Define.
	(hppa_build_one_stub): Use BL22_RP if has_22bit_branch.
	(elf32_hppa_check_relocs): Set has_22bit_branch.
	* elf32-hppa.c (elf32_hppa_check_relocs): Remove debug message.
	(final_link_relocate): Likewise.

	2002-04-20  Alan Modra  <amodra@@bigpond.net.au>
	* archures.c (bfd_arch_info): Add comment on list order.
	(bfd_default_set_arch_mach): Use bfd_lookup_arch.
	* cpu-powerpc.c (bfd_powerpc_archs): Re-order so that the default
	is always at head of list.
	* bfd-in2.h: Regenerate.

	2002-04-16  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.

	2002-04-15  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Check the hash table type.

	2002-04-08  Randolph Chung  <tausq@@debian.org>
	* elf32-hppa.c (hppa_unwind_entry_compare): Move to elf-hppa.h.
	(elf32_hppa_final_link): Split out sorting logic to..
	* elf-hppa.h (elf_hppa_sort_unwind): ..here.
	(elf_hppa_final_link): Call elf_hppa_sort_unwind.
@
text
@d3 1
a3 1
   2001, 2002
d621 1
a639 1
  bfd_section_list_clear (abfd);
@


1.6.2.2
log
@Merge from mainline
@
text
@a98 2
  if (nbfd == NULL)
    return NULL;
@


1.5
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d60 1
d69 5
d75 1
d106 11
a155 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d157 1
d168 1
a168 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d235 1
a235 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d254 1
a254 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d276 1
a276 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d315 1
a315 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d325 1
a325 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d372 1
a372 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d382 1
a382 2
      objalloc_free ((struct objalloc *) nbfd->memory);
      free (nbfd);
d449 1
a449 2
  objalloc_free ((struct objalloc *) abfd->memory);
  free (abfd);
d503 1
a503 2
  objalloc_free ((struct objalloc *) abfd->memory);
  free (abfd);
d690 2
a691 1
/* Free a block allocated for a BFD.  */
@


1.4
log
@Update copyright notices
@
text
@d52 1
a52 1
  nbfd = (bfd *) bfd_zmalloc (sizeof (bfd));
d71 1
a71 1
  nbfd->origin = 0;				
d110 1
a110 1
        bfd *bfd_openr(CONST char *filename, CONST char *target);
d125 2
a126 2
     CONST char *filename;
     CONST char *target;
d172 1
a172 1
         bfd *bfd_fdopenr(CONST char *filename, CONST char *target, int fd);
d195 2
a196 2
     CONST char *filename;
     CONST char *target;
d310 1
a310 1
				
d331 1
a331 1
	bfd *bfd_openw(CONST char *filename, CONST char *target);
d343 2
a344 2
     CONST char *filename;
     CONST char *target;
d432 1
a432 1
 	  int mask = umask (0);
d487 1
a487 1
	  int mask = umask (0);
d506 1
a506 1
	bfd *bfd_create(CONST char *filename, bfd *templ);
d518 1
a518 1
     CONST char *filename;
d563 2
a564 1
  bim = (struct bfd_in_memory *) bfd_malloc (sizeof (struct bfd_in_memory));
d566 1
a566 1
  /* bfd_write will grow these as needed */
d617 1
a617 1
  abfd->origin = 0;				
d654 1
a654 1
     size_t size;
d658 6
d673 1
a673 1
     size_t size;
d679 1
a679 1
    memset (res, 0, size);
@


1.3
log
@Add parens like the comment says.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1997, 2001
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001
@


1.2
log
@(bfd_close_all_done): Mask file perms with 0777 not 0x777.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1997
d251 1
a251 1
  switch (fdflags & O_ACCMODE)
@


1.1
log
@Initial revision
@
text
@d489 1
a489 1
		 (0x777
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@(bfd_close_all_done): Mask file perms with 0777 not 0x777.
@
text
@d489 1
a489 1
		 (0777
@


