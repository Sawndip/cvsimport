head	1.20;
access;
symbols
	sid-snapshot-20180601:1.20
	sid-snapshot-20180501:1.20
	sid-snapshot-20180401:1.20
	sid-snapshot-20180301:1.20
	sid-snapshot-20180201:1.20
	sid-snapshot-20180101:1.20
	sid-snapshot-20171201:1.20
	sid-snapshot-20171101:1.20
	sid-snapshot-20171001:1.20
	sid-snapshot-20170901:1.20
	sid-snapshot-20170801:1.20
	sid-snapshot-20170701:1.20
	sid-snapshot-20170601:1.20
	sid-snapshot-20170501:1.20
	sid-snapshot-20170401:1.20
	sid-snapshot-20170301:1.20
	sid-snapshot-20170201:1.20
	sid-snapshot-20170101:1.20
	sid-snapshot-20161201:1.20
	sid-snapshot-20161101:1.20
	sid-snapshot-20160901:1.20
	sid-snapshot-20160801:1.20
	sid-snapshot-20160701:1.20
	sid-snapshot-20160601:1.20
	sid-snapshot-20160501:1.20
	sid-snapshot-20160401:1.20
	sid-snapshot-20160301:1.20
	sid-snapshot-20160201:1.20
	sid-snapshot-20160101:1.20
	sid-snapshot-20151201:1.20
	sid-snapshot-20151101:1.20
	sid-snapshot-20151001:1.20
	sid-snapshot-20150901:1.20
	sid-snapshot-20150801:1.20
	sid-snapshot-20150701:1.20
	sid-snapshot-20150601:1.20
	sid-snapshot-20150501:1.20
	sid-snapshot-20150401:1.20
	sid-snapshot-20150301:1.20
	sid-snapshot-20150201:1.20
	sid-snapshot-20150101:1.20
	sid-snapshot-20141201:1.20
	sid-snapshot-20141101:1.20
	sid-snapshot-20141001:1.20
	sid-snapshot-20140901:1.20
	sid-snapshot-20140801:1.20
	sid-snapshot-20140701:1.20
	sid-snapshot-20140601:1.20
	sid-snapshot-20140501:1.20
	sid-snapshot-20140401:1.20
	sid-snapshot-20140301:1.20
	sid-snapshot-20140201:1.20
	sid-snapshot-20140101:1.20
	sid-snapshot-20131201:1.20
	sid-snapshot-20131101:1.20
	sid-snapshot-20131001:1.20
	binutils-2_24-branch:1.20.0.56
	binutils-2_24-branchpoint:1.20
	binutils-2_21_1:1.20
	sid-snapshot-20130901:1.20
	gdb_7_6_1-2013-08-30-release:1.20
	sid-snapshot-20130801:1.20
	sid-snapshot-20130701:1.20
	sid-snapshot-20130601:1.20
	sid-snapshot-20130501:1.20
	gdb_7_6-2013-04-26-release:1.20
	sid-snapshot-20130401:1.20
	binutils-2_23_2:1.20
	gdb_7_6-branch:1.20.0.54
	gdb_7_6-2013-03-12-branchpoint:1.20
	sid-snapshot-20130301:1.20
	sid-snapshot-20130201:1.20
	sid-snapshot-20130101:1.20
	sid-snapshot-20121201:1.20
	gdb_7_5_1-2012-11-29-release:1.20
	binutils-2_23_1:1.20
	sid-snapshot-20121101:1.20
	binutils-2_23:1.20
	sid-snapshot-20121001:1.20
	sid-snapshot-20120901:1.20
	gdb_7_5-2012-08-17-release:1.20
	sid-snapshot-20120801:1.20
	binutils-2_23-branch:1.20.0.52
	binutils-2_23-branchpoint:1.20
	gdb_7_5-branch:1.20.0.50
	gdb_7_5-2012-07-18-branchpoint:1.20
	sid-snapshot-20120701:1.20
	sid-snapshot-20120601:1.20
	sid-snapshot-20120501:1.20
	binutils-2_22_branch:1.20.0.48
	gdb_7_4_1-2012-04-26-release:1.20
	sid-snapshot-20120401:1.20
	sid-snapshot-20120301:1.20
	sid-snapshot-20120201:1.20
	gdb_7_4-2012-01-24-release:1.20
	sid-snapshot-20120101:1.20
	gdb_7_4-branch:1.20.0.46
	gdb_7_4-2011-12-13-branchpoint:1.20
	sid-snapshot-20111201:1.20
	binutils-2_22:1.20
	sid-snapshot-20111101:1.20
	sid-snapshot-20111001:1.20
	binutils-2_22-branch:1.20.0.44
	binutils-2_22-branchpoint:1.20
	gdb_7_3_1-2011-09-04-release:1.20
	sid-snapshot-20110901:1.20
	sid-snapshot-20110801:1.20
	gdb_7_3-2011-07-26-release:1.20
	sid-snapshot-20110701:1.20
	sid-snapshot-20110601:1.20
	sid-snapshot-20110501:1.20
	gdb_7_3-branch:1.20.0.42
	gdb_7_3-2011-04-01-branchpoint:1.20
	sid-snapshot-20110401:1.20
	sid-snapshot-20110301:1.20
	sid-snapshot-20110201:1.20
	sid-snapshot-20110101:1.20
	binutils-2_21:1.20
	sid-snapshot-20101201:1.20
	binutils-2_21-branch:1.20.0.40
	binutils-2_21-branchpoint:1.20
	sid-snapshot-20101101:1.20
	sid-snapshot-20101001:1.20
	binutils-2_20_1:1.20
	gdb_7_2-2010-09-02-release:1.20
	sid-snapshot-20100901:1.20
	sid-snapshot-20100801:1.20
	gdb_7_2-branch:1.20.0.38
	gdb_7_2-2010-07-07-branchpoint:1.20
	sid-snapshot-20100701:1.20
	sid-snapshot-20100601:1.20
	sid-snapshot-20100501:1.20
	sid-snapshot-20100401:1.20
	gdb_7_1-2010-03-18-release:1.20
	sid-snapshot-20100301:1.20
	gdb_7_1-branch:1.20.0.36
	gdb_7_1-2010-02-18-branchpoint:1.20
	sid-snapshot-20100201:1.20
	sid-snapshot-20100101:1.20
	gdb_7_0_1-2009-12-22-release:1.20
	sid-snapshot-20091201:1.20
	sid-snapshot-20091101:1.20
	binutils-2_20:1.20
	gdb_7_0-2009-10-06-release:1.20
	sid-snapshot-20091001:1.20
	gdb_7_0-branch:1.20.0.34
	gdb_7_0-2009-09-16-branchpoint:1.20
	arc-sim-20090309:1.20.22.1
	binutils-arc-20081103-branch:1.20.0.32
	binutils-arc-20081103-branchpoint:1.20
	binutils-2_20-branch:1.20.0.30
	binutils-2_20-branchpoint:1.20
	sid-snapshot-20090901:1.20
	sid-snapshot-20090801:1.20
	msnyder-checkpoint-072509-branch:1.20.0.28
	msnyder-checkpoint-072509-branchpoint:1.20
	sid-snapshot-20090701:1.20
	dje-cgen-play1-branch:1.20.0.26
	dje-cgen-play1-branchpoint:1.20
	sid-snapshot-20090601:1.20
	sid-snapshot-20090501:1.20
	sid-snapshot-20090401:1.20
	arc-20081103-branch:1.20.0.24
	arc-20081103-branchpoint:1.20
	arc-insight_6_8-branch:1.20.0.22
	arc-insight_6_8-branchpoint:1.20
	insight_6_8-branch:1.20.0.20
	insight_6_8-branchpoint:1.20
	sid-snapshot-20090301:1.20
	binutils-2_19_1:1.20
	sid-snapshot-20090201:1.20
	sid-snapshot-20090101:1.20
	reverse-20081226-branch:1.20.0.18
	reverse-20081226-branchpoint:1.20
	sid-snapshot-20081201:1.20
	multiprocess-20081120-branch:1.20.0.16
	multiprocess-20081120-branchpoint:1.20
	sid-snapshot-20081101:1.20
	binutils-2_19:1.20
	sid-snapshot-20081001:1.20
	reverse-20080930-branch:1.20.0.14
	reverse-20080930-branchpoint:1.20
	binutils-2_19-branch:1.20.0.12
	binutils-2_19-branchpoint:1.20
	sid-snapshot-20080901:1.20
	sid-snapshot-20080801:1.20
	reverse-20080717-branch:1.20.0.10
	reverse-20080717-branchpoint:1.20
	sid-snapshot-20080701:1.20
	msnyder-reverse-20080609-branch:1.20.0.8
	msnyder-reverse-20080609-branchpoint:1.20
	drow-reverse-20070409-branch:1.18.0.2
	drow-reverse-20070409-branchpoint:1.18
	sid-snapshot-20080601:1.20
	sid-snapshot-20080501:1.20
	sid-snapshot-20080403:1.20
	sid-snapshot-20080401:1.20
	gdb_6_8-2008-03-27-release:1.20
	sid-snapshot-20080301:1.20
	gdb_6_8-branch:1.20.0.6
	gdb_6_8-2008-02-26-branchpoint:1.20
	sid-snapshot-20080201:1.20
	sid-snapshot-20080101:1.20
	sid-snapshot-20071201:1.20
	sid-snapshot-20071101:1.20
	gdb_6_7_1-2007-10-29-release:1.20
	gdb_6_7-2007-10-10-release:1.20
	sid-snapshot-20071001:1.20
	gdb_6_7-branch:1.20.0.4
	gdb_6_7-2007-09-07-branchpoint:1.20
	binutils-2_18:1.20
	binutils-2_18-branch:1.20.0.2
	binutils-2_18-branchpoint:1.20
	insight_6_6-20070208-release:1.17
	binutils-csl-coldfire-4_1-32:1.17
	binutils-csl-sourcerygxx-4_1-32:1.17
	gdb_6_6-2006-12-18-release:1.17
	binutils-csl-innovasic-fido-3_4_4-33:1.17
	binutils-csl-sourcerygxx-3_4_4-32:1.14
	binutils-csl-coldfire-4_1-30:1.17
	binutils-csl-sourcerygxx-4_1-30:1.17
	binutils-csl-coldfire-4_1-28:1.17
	binutils-csl-sourcerygxx-4_1-29:1.17
	binutils-csl-sourcerygxx-4_1-28:1.17
	gdb_6_6-branch:1.17.0.30
	gdb_6_6-2006-11-15-branchpoint:1.17
	binutils-csl-arm-2006q3-27:1.17
	binutils-csl-sourcerygxx-4_1-27:1.17
	binutils-csl-arm-2006q3-26:1.17
	binutils-csl-sourcerygxx-4_1-26:1.17
	binutils-csl-sourcerygxx-4_1-25:1.17
	binutils-csl-sourcerygxx-4_1-24:1.17
	binutils-csl-sourcerygxx-4_1-23:1.17
	insight_6_5-20061003-release:1.17
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	binutils-csl-sourcerygxx-4_1-21:1.17
	binutils-csl-arm-2006q3-21:1.17
	binutils-csl-sourcerygxx-4_1-22:1.17
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.17
	binutils-csl-sourcerygxx-4_1-20:1.17
	binutils-csl-arm-2006q3-19:1.17
	binutils-csl-sourcerygxx-4_1-19:1.17
	binutils-csl-sourcerygxx-4_1-18:1.17
	binutils-csl-renesas-4_1-9:1.17
	gdb-csl-sourcerygxx-3_4_4-25:1.17
	binutils-csl-sourcerygxx-3_4_4-25:1.14
	nickrob-async-20060828-mergepoint:1.17
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	binutils-csl-renesas-4_1-8:1.17
	binutils-csl-renesas-4_1-7:1.17
	binutils-csl-renesas-4_1-6:1.17
	gdb-csl-sourcerygxx-4_1-17:1.17
	binutils-csl-sourcerygxx-4_1-17:1.17
	gdb-csl-20060226-branch-local-2:1.17
	gdb-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-15:1.17
	gdb-csl-sourcerygxx-4_1-13:1.17
	binutils-csl-sourcerygxx-4_1-13:1.17
	binutils-2_17:1.17
	gdb-csl-sourcerygxx-4_1-12:1.17
	binutils-csl-sourcerygxx-4_1-12:1.17
	gdb-csl-sourcerygxx-3_4_4-21:1.17
	binutils-csl-sourcerygxx-3_4_4-21:1.17
	gdb_6_5-20060621-release:1.17
	binutils-csl-wrs-linux-3_4_4-24:1.14
	binutils-csl-wrs-linux-3_4_4-23:1.14
	gdb-csl-sourcerygxx-4_1-9:1.17
	binutils-csl-sourcerygxx-4_1-9:1.17
	gdb-csl-sourcerygxx-4_1-8:1.17
	binutils-csl-sourcerygxx-4_1-8:1.17
	gdb-csl-sourcerygxx-4_1-7:1.17
	binutils-csl-sourcerygxx-4_1-7:1.17
	gdb-csl-arm-2006q1-6:1.17
	binutils-csl-arm-2006q1-6:1.17
	gdb-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-wrs-linux-3_4_4-22:1.14
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	binutils-csl-coldfire-4_1-11:1.17
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	binutils-csl-sourcerygxx-3_4_4-19:1.17
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.17.0.28
	gdb_6_5-2006-05-14-branchpoint:1.17
	binutils-csl-coldfire-4_1-10:1.17
	gdb-csl-sourcerygxx-4_1-5:1.17
	binutils-csl-sourcerygxx-4_1-5:1.17
	nickrob-async-20060513-branch:1.17.0.26
	nickrob-async-20060513-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-4:1.17
	binutils-csl-sourcerygxx-4_1-4:1.17
	msnyder-reverse-20060502-branch:1.17.0.24
	msnyder-reverse-20060502-branchpoint:1.17
	binutils-csl-wrs-linux-3_4_4-21:1.14
	gdb-csl-morpho-4_1-4:1.17
	binutils-csl-morpho-4_1-4:1.17
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-wrs-linux-3_4_4-20:1.14
	readline_5_1-import-branch:1.17.0.22
	readline_5_1-import-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	binutils-2_17-branch:1.17.0.20
	binutils-2_17-branchpoint:1.17
	gdb-csl-symbian-20060226-branch:1.17.0.18
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.17.0.16
	msnyder-reverse-20060331-branchpoint:1.17
	binutils-csl-2_17-branch:1.17.0.14
	binutils-csl-2_17-branchpoint:1.17
	gdb-csl-available-20060303-branch:1.17.0.12
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.10
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.17
	msnyder-fork-checkpoint-branch:1.17.0.8
	msnyder-fork-checkpoint-branchpoint:1.17
	gdb-csl-gxxpro-6_3-branch:1.17.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.17
	gdb_6_4-branch:1.17.0.4
	gdb_6_4-2005-11-01-branchpoint:1.17
	gdb-csl-arm-20051020-branch:1.17.0.2
	gdb-csl-arm-20051020-branchpoint:1.17
	binutils-csl-gxxpro-3_4-branch:1.14.0.70
	binutils-csl-gxxpro-3_4-branchpoint:1.14
	binutils-2_16_1:1.14
	msnyder-tracepoint-checkpoint-branch:1.16.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.16
	gdb-csl-arm-20050325-2005-q1b:1.14
	binutils-csl-arm-2005q1b:1.14
	binutils-2_16:1.14
	gdb-csl-arm-20050325-2005-q1a:1.14
	binutils-csl-arm-2005q1a:1.14
	csl-arm-20050325-branch:1.14.0.68
	csl-arm-20050325-branchpoint:1.14
	binutils-csl-arm-2005q1-branch:1.14.0.66
	binutils-csl-arm-2005q1-branchpoint:1.14
	binutils-2_16-branch:1.14.0.64
	binutils-2_16-branchpoint:1.14
	csl-arm-2004-q3d:1.14
	gdb_6_3-20041109-release:1.14
	gdb_6_3-branch:1.14.0.60
	gdb_6_3-20041019-branchpoint:1.14
	csl-arm-2004-q3:1.14
	drow_intercu-merge-20040921:1.14
	drow_intercu-merge-20040915:1.14
	jimb-gdb_6_2-e500-branch:1.14.0.62
	jimb-gdb_6_2-e500-branchpoint:1.14
	gdb_6_2-20040730-release:1.14
	gdb_6_2-branch:1.14.0.58
	gdb_6_2-2004-07-10-gmt-branchpoint:1.14
	gdb_6_1_1-20040616-release:1.14
	binutils-2_15:1.14
	binutils-2_15-branchpoint:1.14
	csl-arm-2004-q1a:1.14
	csl-arm-2004-q1:1.14
	gdb_6_1-2004-04-05-release:1.14
	drow_intercu-merge-20040402:1.14
	drow_intercu-merge-20040327:1.14
	ezannoni_pie-20040323-branch:1.14.0.56
	ezannoni_pie-20040323-branchpoint:1.14
	cagney_tramp-20040321-mergepoint:1.14
	cagney_tramp-20040309-branch:1.14.0.54
	cagney_tramp-20040309-branchpoint:1.14
	gdb_6_1-branch:1.14.0.52
	gdb_6_1-2004-03-01-gmt-branchpoint:1.14
	drow_intercu-20040221-branch:1.14.0.50
	drow_intercu-20040221-branchpoint:1.14
	binutils-2_15-branch:1.14.0.48
	cagney_bfdfile-20040213-branch:1.14.0.46
	cagney_bfdfile-20040213-branchpoint:1.14
	drow-cplus-merge-20040208:1.14
	carlton_dictionary-20040126-merge:1.14
	cagney_bigcore-20040122-branch:1.14.0.44
	cagney_bigcore-20040122-branchpoint:1.14
	drow-cplus-merge-20040113:1.14
	csl-arm-2003-q4:1.14
	drow-cplus-merge-20031224:1.14
	drow-cplus-merge-20031220:1.14
	carlton_dictionary-20031215-merge:1.14
	drow-cplus-merge-20031214:1.14
	carlton-dictionary-20031111-merge:1.14
	gdb_6_0-2003-10-04-release:1.14
	kettenis_sparc-20030918-branch:1.14.0.42
	kettenis_sparc-20030918-branchpoint:1.14
	carlton_dictionary-20030917-merge:1.14
	ezannoni_pie-20030916-branchpoint:1.14
	ezannoni_pie-20030916-branch:1.14.0.40
	cagney_x86i386-20030821-branch:1.14.0.38
	cagney_x86i386-20030821-branchpoint:1.14
	carlton_dictionary-20030805-merge:1.14
	carlton_dictionary-20030627-merge:1.14
	gdb_6_0-branch:1.14.0.36
	gdb_6_0-2003-06-23-branchpoint:1.14
	jimb-ppc64-linux-20030613-branch:1.14.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.14
	binutils-2_14:1.14
	cagney_convert-20030606-branch:1.14.0.32
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.30
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.26
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.14
	carlton_dictionary-20030430-merge:1.14
	binutils-2_14-branch:1.14.0.22
	binutils-2_14-branchpoint:1.14
	kettenis_i386newframe-20030419-branch:1.14.0.20
	kettenis_i386newframe-20030419-branchpoint:1.14
	carlton_dictionary-20030416-merge:1.14
	cagney_frameaddr-20030409-mergepoint:1.14
	kettenis_i386newframe-20030406-branch:1.14.0.18
	kettenis_i386newframe-20030406-branchpoint:1.14
	cagney_frameaddr-20030403-branchpoint:1.14
	cagney_frameaddr-20030403-branch:1.14.0.16
	cagney_framebase-20030330-mergepoint:1.14
	cagney_framebase-20030326-branch:1.14.0.14
	cagney_framebase-20030326-branchpoint:1.14
	cagney_lazyid-20030317-branch:1.14.0.12
	cagney_lazyid-20030317-branchpoint:1.14
	kettenis-i386newframe-20030316-mergepoint:1.14
	offbyone-20030313-branch:1.14.0.10
	offbyone-20030313-branchpoint:1.14
	kettenis-i386newframe-20030308-branch:1.14.0.8
	kettenis-i386newframe-20030308-branchpoint:1.14
	carlton_dictionary-20030305-merge:1.14
	cagney_offbyone-20030303-branch:1.14.0.6
	cagney_offbyone-20030303-branchpoint:1.14
	carlton_dictionary-20030207-merge:1.14
	interps-20030202-branch:1.14.0.4
	interps-20030202-branchpoint:1.14
	cagney-unwind-20030108-branch:1.14.0.2
	cagney-unwind-20030108-branchpoint:1.14
	binutils-2_13_2_1:1.11
	binutils-2_13_2:1.11
	carlton_dictionary-20021223-merge:1.14
	gdb_5_3-2002-12-12-release:1.11
	carlton_dictionary-20021115-merge:1.12
	binutils-2_13_1:1.11
	kseitz_interps-20021105-merge:1.12
	kseitz_interps-20021103-merge:1.12
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.11.0.14
	drow-cplus-branchpoint:1.11
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.12
	carlton_dictionary-20020920-branchpoint:1.11
	sid-20020905-branchpoint:1.11
	sid-20020905-branch:1.11.0.10
	gdb_5_3-branch:1.11.0.8
	gdb_5_3-2002-09-04-branchpoint:1.11
	kseitz_interps-20020829-merge:1.11
	cagney_sysregs-20020825-branch:1.11.0.6
	cagney_sysregs-20020825-branchpoint:1.11
	readline_4_3-import-branch:1.11.0.4
	readline_4_3-import-branchpoint:1.11
	binutils-2_13:1.11
	gdb_5_2_1-2002-07-23-release:1.10
	binutils-2_13-branchpoint:1.11
	binutils-2_13-branch:1.11.0.2
	kseitz_interps-20020528-branch:1.10.0.10
	kseitz_interps-20020528-branchpoint:1.10
	cagney_regbuf-20020515-branch:1.10.0.8
	cagney_regbuf-20020515-branchpoint:1.10
	binutils-2_12_1:1.10
	jimb-macro-020506-branch:1.10.0.6
	jimb-macro-020506-branchpoint:1.10
	gdb_5_2-2002-04-29-release:1.10
	binutils-2_12:1.10
	gdb_5_2-branch:1.10.0.4
	gdb_5_2-2002-03-03-branchpoint:1.10
	binutils-2_12-branch:1.10.0.2
	binutils-2_12-branchpoint:1.10
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.20
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches
	1.20.22.1
	1.20.32.1;
next	1.19;

1.19
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.26.12.22.59;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.01.11.16.29;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.04.15.53.11;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.04.07.19.22;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.28.11.55.38;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.17.02.59.15;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.03.01.57.09;	author kazu;	state Exp;
branches
	1.11.12.1
	1.11.14.1;
next	1.10;

1.10
date	2001.10.06.06.41.47;	author amodra;	state Exp;
branches
	1.10.8.1
	1.10.10.1;
next	1.9;

1.9
date	2001.10.02.14.28.42;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.18.09.57.23;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.12.23.53.31;	author aoliva;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.09.09.00.58;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.12.15.14.53;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.21.03.58;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.11.21.20.16;	author nickc;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.07.12.10.29.09;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.20.22.1
date	2009.03.09.20.36.03;	author amylaar;	state Exp;
branches;
next	1.20.22.2;

1.20.22.2
date	2009.09.11.04.45.42;	author amylaar;	state Exp;
branches;
next	;

1.20.32.1
date	2009.09.10.15.09.26;	author amylaar;	state Exp;
branches;
next	;

1.11.12.1
date	2002.10.25.23.49.47;	author carlton;	state Exp;
branches;
next	1.11.12.2;

1.11.12.2
date	2002.12.23.19.37.38;	author carlton;	state Exp;
branches;
next	;

1.11.14.1
date	2002.10.26.17.11.57;	author drow;	state Exp;
branches;
next	1.11.14.2;

1.11.14.2
date	2003.12.14.20.26.38;	author drow;	state Exp;
branches;
next	;

1.10.8.1
date	2002.06.15.16.42.36;	author cagney;	state Exp;
branches;
next	;

1.10.10.1
date	2002.06.20.01.30.03;	author kseitz;	state Exp;
branches;
next	1.10.10.2;

1.10.10.2
date	2002.11.03.22.01.35;	author ezannoni;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.23.03.41.09;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Switch sources over to use the GPL version 3
@
text
@/* ARC-specific support for 32-bit ELF
   Copyright 1994, 1995, 1997, 1999, 2001, 2002, 2005, 2007
   Free Software Foundation, Inc.
   Contributed by Doug Evans (dje@@cygnus.com).

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/arc.h"
#include "libiberty.h"

/* Try to minimize the amount of space occupied by relocation tables
   on the ROM (not that the ROM won't be swamped by other ELF overhead).  */

#define USE_REL	1

static bfd_reloc_status_type
arc_elf_b22_pcrel (bfd * abfd,
		   arelent * reloc_entry,
		   asymbol * symbol,
		   void * data,
		   asection * input_section,
		   bfd * output_bfd,
		   char ** error_message)
{
  /* If linking, back up the final symbol address by the address of the
     reloc.  This cannot be accomplished by setting the pcrel_offset
     field to TRUE, as bfd_install_relocation will detect this and refuse
     to install the offset in the first place, but bfd_perform_relocation
     will still insist on removing it.  */
  if (output_bfd == NULL)
    reloc_entry->addend -= reloc_entry->address;

  /* Fall through to the default elf reloc handler.  */
  return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
}

static reloc_howto_type elf_arc_howto_table[] =
{
  /* This reloc does nothing.  */
  HOWTO (R_ARC_NONE,		/* Type.  */
	 0,			/* Rightshift.  */
	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 32,			/* Bitsize.  */
	 FALSE,			/* PC_relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_bitfield, /* Complain_on_overflow.  */
	 bfd_elf_generic_reloc,	/* Special_function.  */
	 "R_ARC_NONE",		/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 0,			/* Src_mask.  */
	 0,			/* Dst_mask.  */
	 FALSE),		/* PCrel_offset.  */

  /* A standard 32 bit relocation.  */
  HOWTO (R_ARC_32,		/* Type.  */
	 0,			/* Rightshift.  */
	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 32,			/* Bitsize.  */
	 FALSE,			/* PC_relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_bitfield, /* Complain_on_overflow.  */
	 bfd_elf_generic_reloc,	/* Special_function.  */
	 "R_ARC_32",		/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 0xffffffff,		/* Src_mask.  */
	 0xffffffff,		/* Dst_mask.  */
	 FALSE),		/* PCrel_offset.  */

  /* A 26 bit absolute branch, right shifted by 2.  */
  HOWTO (R_ARC_B26,		/* Type.  */
	 2,			/* Rightshift.  */
	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 26,			/* Bitsize.  */
	 FALSE,			/* PC_relative.  */
	 0,			/* Bitpos.  */
	 complain_overflow_bitfield, /* Complain_on_overflow.  */
	 bfd_elf_generic_reloc,	/* Special_function.  */
	 "R_ARC_B26",		/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 0x00ffffff,		/* Src_mask.  */
	 0x00ffffff,		/* Dst_mask.  */
	 FALSE),		/* PCrel_offset.  */

  /* A relative 22 bit branch; bits 21-2 are stored in bits 26-7.  */
  HOWTO (R_ARC_B22_PCREL,	/* Type.  */
	 2,			/* Rightshift.  */
	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
	 22,			/* Bitsize.  */
	 TRUE,			/* PC_relative.  */
	 7,			/* Bitpos.  */
	 complain_overflow_signed, /* Complain_on_overflow.  */
	 arc_elf_b22_pcrel,	/* Special_function.  */
	 "R_ARC_B22_PCREL",	/* Name.  */
	 TRUE,			/* Partial_inplace.  */
	 0x07ffff80,		/* Src_mask.  */
	 0x07ffff80,		/* Dst_mask.  */
	 FALSE),		/* PCrel_offset.  */
};

/* Map BFD reloc types to ARC ELF reloc types.  */

struct arc_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char elf_reloc_val;
};

static const struct arc_reloc_map arc_reloc_map[] =
{
  { BFD_RELOC_NONE, R_ARC_NONE, },
  { BFD_RELOC_32, R_ARC_32 },
  { BFD_RELOC_CTOR, R_ARC_32 },
  { BFD_RELOC_ARC_B26, R_ARC_B26 },
  { BFD_RELOC_ARC_B22_PCREL, R_ARC_B22_PCREL },
};

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = ARRAY_SIZE (arc_reloc_map); i--;)
    if (arc_reloc_map[i].bfd_reloc_val == code)
      return elf_arc_howto_table + arc_reloc_map[i].elf_reloc_val;

  return NULL;
}

static reloc_howto_type *
bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (elf_arc_howto_table) / sizeof (elf_arc_howto_table[0]);
       i++)
    if (elf_arc_howto_table[i].name != NULL
	&& strcasecmp (elf_arc_howto_table[i].name, r_name) == 0)
      return &elf_arc_howto_table[i];

  return NULL;
}

/* Set the howto pointer for an ARC ELF reloc.  */

static void
arc_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *cache_ptr,
		       Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_ARC_max);
  cache_ptr->howto = &elf_arc_howto_table[r_type];
}

/* Set the right machine number for an ARC ELF file.  */

static bfd_boolean
arc_elf_object_p (bfd *abfd)
{
  unsigned int mach = bfd_mach_arc_6;

  if (elf_elfheader(abfd)->e_machine == EM_ARC)
    {
      unsigned long arch = elf_elfheader (abfd)->e_flags & EF_ARC_MACH;

      switch (arch)
	{
	case E_ARC_MACH_ARC5:
	  mach = bfd_mach_arc_5;
	  break;
	default:
	case E_ARC_MACH_ARC6:
	  mach = bfd_mach_arc_6;
	  break;
	case E_ARC_MACH_ARC7:
	  mach = bfd_mach_arc_7;
	  break;
	case E_ARC_MACH_ARC8:
	  mach = bfd_mach_arc_8;
	  break;
	}
    }
  return bfd_default_set_arch_mach (abfd, bfd_arch_arc, mach);
}

/* The final processing done just before writing out an ARC ELF object file.
   This gets the ARC architecture right based on the machine number.  */

static void
arc_elf_final_write_processing (bfd *abfd,
				bfd_boolean linker ATTRIBUTE_UNUSED)
{
  unsigned long val;

  switch (bfd_get_mach (abfd))
    {
    case bfd_mach_arc_5:
      val = E_ARC_MACH_ARC5;
      break;
    default:
    case bfd_mach_arc_6:
      val = E_ARC_MACH_ARC6;
      break;
    case bfd_mach_arc_7:
      val = E_ARC_MACH_ARC7;
      break;
    case bfd_mach_arc_8:
      val = E_ARC_MACH_ARC8;
      break;
    }
  elf_elfheader (abfd)->e_flags &=~ EF_ARC_MACH;
  elf_elfheader (abfd)->e_flags |= val;
}

#define TARGET_LITTLE_SYM   bfd_elf32_littlearc_vec
#define TARGET_LITTLE_NAME  "elf32-littlearc"
#define TARGET_BIG_SYM      bfd_elf32_bigarc_vec
#define TARGET_BIG_NAME	    "elf32-bigarc"
#define ELF_ARCH            bfd_arch_arc
#define ELF_MACHINE_CODE    EM_ARC
#define ELF_MAXPAGESIZE     0x1000

#define elf_info_to_howto                   0
#define elf_info_to_howto_rel               arc_info_to_howto_rel
#define elf_backend_object_p                arc_elf_object_p
#define elf_backend_final_write_processing  arc_elf_final_write_processing

#include "elf32-target.h"
@


1.20.32.1
log
@Commit patches for ARCompact support to binutils-arc-20081103-branch .
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2007, 2008, 2009
d28 1
d30 4
a33 14
/* Debug trace for Position independent stuff */
#if 1
#define BFD_DEBUG_PIC(x)
#else
  
#define BFD_DEBUG_PIC(x) (fprintf(stderr,"DEBUG: %d@@%s: ", \
   __LINE__,__PRETTY_FUNCTION__),x)
#endif

/* We must define USE_RELA to get the proper fixups for PC relative
   branches to symbols defined in other object files. The addend is
   used to account for the PC having been incremented before the PC
   relative address is calculated. mlm */
#define USE_RELA
a34 1
/* Handle PC relative relocation */
d36 19
a54 21
arc_elf_b22_pcrel (bfd *abfd ATTRIBUTE_UNUSED,
		   arelent *reloc_entry,
		   asymbol *symbol,
		   void *data ATTRIBUTE_UNUSED,
		   asection *input_section,
		   bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
{
  /* If incremental linking, update the address of the relocation with the
     section offset */


  if (output_bfd != (bfd *) NULL)
    {
      reloc_entry->address += input_section->output_offset;
      if ((symbol->flags & BSF_SECTION_SYM) && symbol->section)
	reloc_entry->addend
	  += ((**(reloc_entry->sym_ptr_ptr)).section)->output_offset;
      return bfd_reloc_ok;
    }
  return bfd_reloc_continue;
a56 205
#define bfd_put32(a,b,c)
static bfd_vma bfd_get_32_me (bfd *, const unsigned char *);
static void bfd_put_32_me (bfd *, bfd_vma, unsigned char *);


static bfd_reloc_status_type arcompact_elf_me_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type arc_unsupported_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_boolean arc_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
static reloc_howto_type * arc_elf_calculate_howto_index
  (enum elf_arc_reloc_type r_type);


#define INIT_SYM_STRING "_init"
#define FINI_SYM_STRING "_fini"

/* The default symbols representing the init and fini dyn values */
char * init_str = INIT_SYM_STRING;
char * fini_str = FINI_SYM_STRING;

/* The ARC linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */
#define bfd_elf32_bfd_link_hash_table_create \
					elf_ARC_link_hash_table_create

struct elf_ARC_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf_ARC_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of reloc6s copied in this section.  */
  bfd_size_type count;
};

/* ARC ELF linker hash entry.  */

struct elf_ARC_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* Number of PC relative relocs copied for this symbol.  */
  struct elf_ARC_pcrel_relocs_copied *pcrel_relocs_copied;
};

/* ARC ELF linker hash table.  */

struct elf_ARC_link_hash_table
{
  struct elf_link_hash_table root;
};

/* Declare this now that the above structures are defined.  */

static bfd_boolean elf_ARC_discard_copies
  (struct elf_ARC_link_hash_entry *, void *);

/* Traverse an ARC ELF linker hash table.  */

#define elf_ARC_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\
    (info)))

/* Get the ARC ELF linker hash table from a link_info structure.  */

#define elf_ARC_hash_table(p) \
  ((struct elf_ARC_link_hash_table *) ((p)->hash))

/* Create an entry in an ARC ELF linker hash table.  */

static struct bfd_hash_entry *
elf_ARC_link_hash_newfunc (struct bfd_hash_entry *entry, 
                           struct bfd_hash_table *table, 
                           const char *string)
{
  struct elf_ARC_link_hash_entry *ret =
    (struct elf_ARC_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct elf_ARC_link_hash_entry *) NULL)
    ret = ((struct elf_ARC_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf_ARC_link_hash_entry)));
  if (ret == (struct elf_ARC_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf_ARC_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct elf_ARC_link_hash_entry *) NULL)
    {
      ret->pcrel_relocs_copied = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create an ARC ELF linker hash table.  */

static struct bfd_link_hash_table *
elf_ARC_link_hash_table_create (bfd * abfd)
{
  struct elf_ARC_link_hash_table *ret;

  ret = ((struct elf_ARC_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf_ARC_link_hash_table)));
  if (ret == (struct elf_ARC_link_hash_table *) NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       elf_ARC_link_hash_newfunc,
				       sizeof (struct elf_ARC_link_hash_entry)))
    {
      bfd_release (abfd, ret);
      return NULL;
    }

  return &ret->root.root;
}

/* This function is called via elf_ARC_link_hash_traverse if we are
   creating a shared object with -Bsymbolic.  It discards the space
   allocated to copy PC relative relocs against symbols which are
   defined in regular objects.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.  */

/*ARGSUSED*/
static bfd_boolean
elf_ARC_discard_copies (struct elf_ARC_link_hash_entry * h,
                        void *ignore ATTRIBUTE_UNUSED)
{
  struct elf_ARC_pcrel_relocs_copied *s;
  
  /* We only discard relocs for symbols defined in a regular object.  */
  if (!h->root.def_regular)
    return TRUE;

  for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
    s->section->size -= 
      s->count * sizeof (Elf32_External_Rela); /* relA */

  return TRUE;
}

/* The HOWTO Array needs to be specified as follows. 
   HOWTO
   {
    type        --- > Relocation Type
    rightshift  --- > Rightshift the value by this amount.
    size        --- > Size 0- byte , 1-short, 2 -long
    bitsize     --- > Exact bitsize. 
    pcrel       --- > PC Relative reloc.
    bitpos      --- > Bit Position. 
    complain_on_overflow ---> What complaint on overflow. 
    function    --- > Any special function to be used . 
    name        --- > Relocation Name.
    partial_inplace--> Addend sits partially in place and in 
                       Reloc Table.
    srcmask       ---> Source Mask 0 for RELA and corresponding 
                       field if USE_REL or partial_inplace
		       is set. 
    dstmask       ---> Destination Mask . Destination field mask.
    pcreloffset   ---> pcrel offset . If a PCREL reloc is created
                       and the assembler leaves an offset in here. 
		       
   }
   If in the backend you need to access the howto array, please
   use the arc_elf_calculate_howto_index function.  All changes in 
   the HOWTO array need a corresponding change in the above mentioned 
   function. The need for this function is the presence of a hole 
   in the ARC ABI. 
*/

#define ARC_RELA_HOWTO(type,rightshift,size,bitsz,pcrel,bitpos , \
function,name,dstmask) \
          \
                       HOWTO( type,rightshift,size,bitsz,pcrel,bitpos,   \
                              complain_overflow_bitfield,function, \
                              name,FALSE,0,dstmask,FALSE)

#define ARCOMPACT_RELA_HOWTO(type,rightshift,size,bitsz,pcrel,bitpos, \
                       function,name,dstmask) \
          \
                       HOWTO( type,rightshift,size,bitsz,pcrel,bitpos,   \
                              complain_overflow_signed,function, \
                              name,FALSE,0,dstmask,FALSE)



#define ARC_UNSUPPORTED_HOWTO(type,name)  \
 ARC_RELA_HOWTO (type ,0 ,2 ,32,FALSE,0,arc_unsupported_reloc,name,0)


d60 14
a73 8
  ARC_RELA_HOWTO (R_ARC_NONE ,0 ,2 ,32,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_NONE",0),
  ARC_RELA_HOWTO (R_ARC_8    ,0 ,0 , 8,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_8" ,0xff),
  ARC_RELA_HOWTO (R_ARC_16   ,0 ,1 ,16,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_16",0xffff),
  ARC_RELA_HOWTO (R_ARC_24   ,0 ,2 ,24,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_24",0xffffff),
d75 14
a88 2
  ARC_RELA_HOWTO (R_ARC_32   ,0 ,2 ,32,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_32",-1),
d90 14
a103 2
  ARC_RELA_HOWTO (R_ARC_B26  ,2 ,2 ,26,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_B26",0xffffff),
d105 13
a117 101
  ARC_RELA_HOWTO (R_ARC_B22_PCREL,2,2,22,TRUE,7,arc_elf_b22_pcrel,
                  "R_ARC_B22_PCREL",0x7ffff80),
  ARC_RELA_HOWTO (R_ARC_H30 ,2 ,2 ,32, FALSE, 0, bfd_elf_generic_reloc,
                  "R_ARC_H30",-1),
  ARC_UNSUPPORTED_HOWTO(R_ARC_N8,"R_ARC_N8"),
  ARC_UNSUPPORTED_HOWTO(R_ARC_N16,"R_ARC_N16"),
  ARC_UNSUPPORTED_HOWTO(R_ARC_N24,"R_ARC_N24"),
  ARC_UNSUPPORTED_HOWTO(R_ARC_N32,"R_ARC_N32"),
  ARC_UNSUPPORTED_HOWTO(R_ARC_SDA,"R_ARC_SDA"),
  ARC_UNSUPPORTED_HOWTO(R_ARC_SECTOFF,"R_ARC_SECTOFF"),

  /* FIXME: Change complaint to complain_overflow_signed.  */
  /* Tangent-A5 relocations.  */
  ARCOMPACT_RELA_HOWTO (R_ARC_S21H_PCREL,1,2,21,TRUE,0,arcompact_elf_me_reloc,
                  "R_ARC_S21H_PCREL",0x7feffc0),
  ARCOMPACT_RELA_HOWTO (R_ARC_S21W_PCREL,2,2,21,TRUE,0,arcompact_elf_me_reloc,
                  "R_ARC_S21W_PCREL",0x7fcffc0),
  ARCOMPACT_RELA_HOWTO (R_ARC_S25H_PCREL,1,2,25,TRUE,0,arcompact_elf_me_reloc,
                  "R_ARC_S25H_PCREL",0x7feffcf),
  ARCOMPACT_RELA_HOWTO (R_ARC_S25W_PCREL,2,2,25,TRUE,0,arcompact_elf_me_reloc,
                        "R_ARC_S25W_PCREL",0x7fcffcf),

  ARCOMPACT_RELA_HOWTO (R_ARC_SDA32,0,2,32,FALSE,0,arcompact_elf_me_reloc,
                        "R_ARC_SDA32",-1),
  ARCOMPACT_RELA_HOWTO (R_ARC_SDA_LDST,0,2,9,FALSE,15,arcompact_elf_me_reloc,
                        "R_ARC_SDA_LDST",0x00ff8000),
  ARCOMPACT_RELA_HOWTO (R_ARC_SDA_LDST1,1,2,10,FALSE,15,arcompact_elf_me_reloc,
                        "R_ARC_SDA_LDST1",0x00ff8000),
  ARCOMPACT_RELA_HOWTO (R_ARC_SDA_LDST2,2,2,11,FALSE,15,arcompact_elf_me_reloc,
                        "R_ARC_SDA_LDST2",0x00ff8000),

  ARCOMPACT_RELA_HOWTO (R_ARC_SDA16_LD,0,2,9,FALSE,0,arcompact_elf_me_reloc,
                        "R_ARC_SDA16_LD",0x01ff),
  ARCOMPACT_RELA_HOWTO (R_ARC_SDA16_LD1,1,2,10,FALSE,0,arcompact_elf_me_reloc,
                        "R_ARC_SDA16_LD1",0x01ff),
  ARCOMPACT_RELA_HOWTO (R_ARC_SDA16_LD2,2,2,11,FALSE,0,arcompact_elf_me_reloc,
                        "R_ARC_SDA16_LD2",0x01ff),

  ARCOMPACT_RELA_HOWTO (R_ARC_S13_PCREL,2,1,13,TRUE,0,arcompact_elf_me_reloc,
                        "R_ARC_S13_PCREL",0x7ff),

  ARC_UNSUPPORTED_HOWTO (R_ARC_W,"R_ARC_W"),

/* 'Middle-endian' (ME) 32-bit word relocations, stored in two half-words.
   The individual half-words are stored in the native endian of the
   machine; this is how all 32-bit instructions and long-words are stored
   in the ARCompact ISA in the executable section.  */

  ARC_RELA_HOWTO (R_ARC_32_ME ,0 ,2 ,32, FALSE, 0, arcompact_elf_me_reloc,
                  "R_ARC_32_ME",-1),
  
  ARC_UNSUPPORTED_HOWTO (R_ARC_N32_ME,"R_ARC_N32_ME"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_ME,"R_ARC_SECTOFF_ME"),

  ARCOMPACT_RELA_HOWTO (R_ARC_SDA32_ME,0,2,32,FALSE,0,arcompact_elf_me_reloc,
                        "R_ARC_SDA32_ME",-1),

  ARC_UNSUPPORTED_HOWTO (R_ARC_W_ME,"R_ARC_W_ME"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_H30_ME,"R_ARC_H30_ME"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_U8,"R_ARC_SECTOFF_U8"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_S9,"R_ARC_SECTOFF_S9"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_U8,"R_AC_SECTOFF_U8"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_U8_1,"R_AC_SECTOFF_U8_1"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_U8_2,"R_ARC_SECTOFF_U8_2"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_S9,"R_AC_SECTOFF_S9"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_S9_1,"R_AC_SECTOFF_S9_1"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_S9_2,"R_AC_SECTOFF_S9_2"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_ME_1,"R_ARC_SECTOFF_ME_1"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_ME_2,"R_ARC_SECTOFF_ME_2"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_1,"R_ARC_SECTOFF_1"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_2,"R_ARC_SECTOFF_2"),
  /* There is a gap here of 5.  */
  #define R_ARC_hole_base 0x2d
  #define R_ARC_reloc_hole_gap 5

  ARC_RELA_HOWTO (R_ARC_PC32, 0, 2, 32, TRUE, 0, arcompact_elf_me_reloc,
                  "R_ARC_PC32",-1),
  /* PC relative was true for this earlier. */
  ARC_RELA_HOWTO (R_ARC_GOTPC32, 0, 2, 32, FALSE, 0, arcompact_elf_me_reloc,
                  "R_ARC_GOTPC32",-1),

  ARC_RELA_HOWTO (R_ARC_PLT32, 0, 2, 32, FALSE, 0, arcompact_elf_me_reloc,
                  "R_ARC_PLT32",-1),

  ARC_RELA_HOWTO (R_ARC_COPY, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_COPY",-1),

  ARC_RELA_HOWTO (R_ARC_GLOB_DAT, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_GLOB_DAT",-1),

  ARC_RELA_HOWTO (R_ARC_JMP_SLOT, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_JMP_SLOT",-1),

  ARC_RELA_HOWTO (R_ARC_RELATIVE, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_RELATIVE",-1),

  ARC_RELA_HOWTO (R_ARC_GOTOFF, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_GOTOFF",-1),

  ARC_RELA_HOWTO (R_ARC_GOTPC, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_GOTPC",-1),
a119 97
/*Indicates whether the value contained in
  the relocation type is signed, usnigned
  or the reclocation type is unsupported.
  0 -> unsigned reloc type
  1 -> signed reloc type
  -1 -> reloc type unsupported*/
short arc_signed_reloc_type[] =
{
  0, // R_ARC_NONE              Reloc Number
  0, // R_ARC_8
  0, // R_ARC_16
  0, // R_ARC_24
  0, // R_ARC_32
  0, // R_ARC_B26
  1, // R_ARC_B22_PCREL          0x6

  0, // R_ARC_H30                0x7
 -1, // R_ARC_N8
 -1, // R_ARC_N16
 -1, // R_ARC_N24
 -1, // R_ARC_N32
 -1, // R_ARC_SDA
 -1, // R_ARC_SECTOFF            0xD

  1, // R_ARC_S21H_PCREL         0xE
  1, // R_ARC_S21W_PCREL
  1, // R_ARC_S25H_PCREL
  1, // R_ARC_S25W_PCREL         0x11

  1, // R_ARC_SDA32              0x12
  1, // R_ARC_SDA_LDST
  1, // R_ARC_SDA_LDST1
  1, // R_ARC_SDA_LDST2          0x15

  1, // R_ARC_SDA16_LD           0x16
  1, // R_ARC_SDA16_LD1
  1, // R_ARC_SDA16_LD2          0x18

  1, // R_ARC_S13_PCREL          0x19

  -1, // R_ARC_W                 0x1A
  0, // R_ARC_32_ME              0x1B
  
  -1, // R_ARC_N32_ME            0x1c
  -1, // R_ARC_SECTOFF_ME        0x1D

  0, // R_ARC_SDA32_ME           0x1E

  -1, // R_ARC_W_ME              0x1F
  -1, // R_ARC_H30_ME
  -1, // R_ARC_SECTOFF_U8
  -1, // R_ARC_SECTOFF_S9
  -1, // R_AC_SECTOFF_U8
  -1, // R_AC_SECTOFF_U8_1
  -1, // R_AC_SECTOFF_U8_2
  -1, // R_AC_SECTOFF_S9
  -1, // R_AC_SECTOFF_S9_1
  -1, // R_AC_SECTOFF_S9_2
  -1, // R_ARC_SECTOFF_ME_1
  -1, // R_ARC_SECTOFF_ME_2
  -1, // R_ARC_SECTOFF_1
  -1, // R_ARC_SECTOFF_2         0x2c

  -1, // R_ARC_hole_base starts here 0x2d
  -1, // 0x2e
  -1, // 0x2f
  -1, // 0x30
  -1, // ends here               0x31

  0, //  R_ARC_PC32              0x32
  0, //  R_ARC_GOTPC32
  0, //  R_ARC_PLT32
  0, //  R_ARC_COPY
  0, //  R_ARC_GLOB_DAT
  0, //  R_ARC_JMP_SLOT
  0, //  R_ARC_RELATIVE
  0, //  R_ARC_GOTOFF
  0, //  R_ARC_GOTPC             0x3a
  0, //  R_ARC_GOT32             0x3b
};



static bfd_reloc_status_type 
arc_unsupported_reloc (bfd * ibfd ATTRIBUTE_UNUSED, 
		       arelent * rel ATTRIBUTE_UNUSED,
		       asymbol * sym ATTRIBUTE_UNUSED, 
		       void *ptr ATTRIBUTE_UNUSED,
		       asection * section ATTRIBUTE_UNUSED, 
		       bfd *obfd ATTRIBUTE_UNUSED, 
		       char ** data ATTRIBUTE_UNUSED
		       )
{
  return bfd_reloc_notsupported;
}


d124 2
a125 2
    enum bfd_reloc_code_real bfd_reloc_val;
    enum elf_arc_reloc_type elf_reloc_val;
d130 1
a130 4
  { BFD_RELOC_NONE, R_ARC_NONE },
  { BFD_RELOC_8, R_ARC_8 },
  { BFD_RELOC_16,R_ARC_16 },
  { BFD_RELOC_24, R_ARC_24 },
a134 24
  { BFD_RELOC_ARC_S21H_PCREL, R_ARC_S21H_PCREL },
  { BFD_RELOC_ARC_S21W_PCREL, R_ARC_S21W_PCREL },
  { BFD_RELOC_ARC_S25H_PCREL, R_ARC_S25H_PCREL },
  { BFD_RELOC_ARC_S25W_PCREL, R_ARC_S25W_PCREL },
  { BFD_RELOC_ARC_S13_PCREL, R_ARC_S13_PCREL },
  { BFD_RELOC_ARC_32_ME, R_ARC_32_ME },
  { BFD_RELOC_ARC_PC32, R_ARC_PC32 },
  { BFD_RELOC_ARC_GOTPC32, R_ARC_GOTPC32 },
  { BFD_RELOC_ARC_COPY , R_ARC_COPY },
  { BFD_RELOC_ARC_JMP_SLOT, R_ARC_JMP_SLOT },
  { BFD_RELOC_ARC_GLOB_DAT, R_ARC_GLOB_DAT },
  { BFD_RELOC_ARC_GOTOFF , R_ARC_GOTOFF },
  { BFD_RELOC_ARC_GOTPC , R_ARC_GOTPC },
  { BFD_RELOC_ARC_PLT32 , R_ARC_PLT32 },

  { BFD_RELOC_ARC_SDA, R_ARC_SDA },
  { BFD_RELOC_ARC_SDA32, R_ARC_SDA32 },
  { BFD_RELOC_ARC_SDA32_ME, R_ARC_SDA32_ME },
  { BFD_RELOC_ARC_SDA_LDST, R_ARC_SDA_LDST },
  { BFD_RELOC_ARC_SDA_LDST1, R_ARC_SDA_LDST1 },
  { BFD_RELOC_ARC_SDA_LDST2, R_ARC_SDA_LDST2 },
  { BFD_RELOC_ARC_SDA16_LD, R_ARC_SDA16_LD },
  { BFD_RELOC_ARC_SDA16_LD1, R_ARC_SDA16_LD1 },
  { BFD_RELOC_ARC_SDA16_LD2, R_ARC_SDA16_LD2 }
d138 1
a138 1
arc_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
d142 4
a145 11
  for (i = 0;
       i < sizeof (arc_reloc_map) / sizeof (struct arc_reloc_map);
       i++)
    {
      if (arc_reloc_map[i].bfd_reloc_val == code)
        { 
          enum elf_arc_reloc_type r_type;
          r_type = arc_reloc_map[i].elf_reloc_val;
          return arc_elf_calculate_howto_index(r_type);
        }
    }
a165 13
/* Calculate the howto index.  */
static reloc_howto_type * 
arc_elf_calculate_howto_index(enum elf_arc_reloc_type r_type)
{
  BFD_ASSERT (r_type < (unsigned int) R_ARC_max);
  BFD_ASSERT ((r_type < (unsigned int) R_ARC_hole_base)
	      || (r_type
		  >= (unsigned int) R_ARC_hole_base + R_ARC_reloc_hole_gap));
  if (r_type > R_ARC_hole_base)
    r_type -= R_ARC_reloc_hole_gap;
  return &elf_arc_howto_table[r_type];

}
d173 1
a173 2
  enum elf_arc_reloc_type r_type;

d176 2
a177 54
  cache_ptr->howto = arc_elf_calculate_howto_index(r_type);
}
 
/* Merge backend specific data from an object file to the output
   object file when linking.  */
static bfd_boolean
arc_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  unsigned short mach_ibfd;
  static unsigned short mach_obfd = EM_NONE;
  
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
	 || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;
  if (bfd_count_sections (ibfd) == 0)
    return TRUE ; /* For the case of empty archive files */
  
  mach_ibfd = elf_elfheader (ibfd)->e_machine;

   /* Check if we have the same endianess.  */
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    {
      _bfd_error_handler (_("\
ERROR: Endian Match failed . Attempting to link %B with binary %s \
of opposite endian-ness"),
			  ibfd, bfd_get_filename (obfd));
      return FALSE;
    }

  if (mach_obfd == EM_NONE)
    {
      mach_obfd = mach_ibfd;
    }
  else
    {
      if((mach_ibfd==EM_ARC && mach_obfd==EM_ARCOMPACT) ||
	 (mach_ibfd==EM_ARCOMPACT && mach_obfd==EM_ARC))
	{
	  _bfd_error_handler (_("\ERROR: Attempting to link an %s binary(%B) \
with a binary incompatible %s binary(%s)"),
			      (mach_ibfd == EM_ARC) ? "A4" : "ARCompact",
			      ibfd,
			      (mach_obfd == EM_ARC) ? "A4" : "ARCompact",
			      bfd_get_filename (obfd));
	  return FALSE;
	}
    }
  
  if (bfd_get_mach (obfd) < bfd_get_mach (ibfd))
    {
      return bfd_set_arch_mach (obfd, bfd_arch_arc, bfd_get_mach(ibfd));
    }
  
  return TRUE;
d185 1
a185 2
  int mach;
  unsigned long arch = elf_elfheader (abfd)->e_flags & EF_ARC_MACH;
d187 1
a187 1
  switch (arch)
d189 18
a206 15
    case E_ARC_MACH_A4:
      mach = bfd_mach_arc_a4;
      break;
    case E_ARC_MACH_A5:
      mach = bfd_mach_arc_a5;
      break;
    case E_ARC_MACH_ARC600:
      mach = bfd_mach_arc_arc600;
      break;
    case E_ARC_MACH_ARC700:
      mach = bfd_mach_arc_arc700;
      break;
    default:
      /* Unknown cpu type.  ??? What to do?  */
      return FALSE;
d208 1
a208 3

  (void) bfd_default_set_arch_mach (abfd, bfd_arch_arc, mach);
  return TRUE;
a217 1
  int mach;
d220 1
a220 1
  switch (mach = bfd_get_mach (abfd))
d222 2
a223 3
    case bfd_mach_arc_a4:
      val = E_ARC_MACH_A4;
      elf_elfheader (abfd)->e_machine = EM_ARC;
d225 3
a227 3
    case bfd_mach_arc_a5:
      val = E_ARC_MACH_A5;
      elf_elfheader (abfd)->e_machine = EM_ARCOMPACT;
d229 2
a230 3
    case bfd_mach_arc_arc600:
      val = E_ARC_MACH_ARC600;
      elf_elfheader (abfd)->e_machine = EM_ARCOMPACT;
d232 2
a233 3
    case bfd_mach_arc_arc700:
      val = E_ARC_MACH_ARC700;
      elf_elfheader (abfd)->e_machine = EM_ARCOMPACT;
a234 2
    default:
      abort();
a235 1

d240 12
a251 2381
/* Handle an ARCompact 'middle-endian' relocation.  */
static bfd_reloc_status_type
arcompact_elf_me_reloc (bfd *abfd , 
                        arelent *reloc_entry,
                        asymbol *symbol_in,
                        void *data, 
                        asection *input_section,
                        bfd *output_bfd,
                        char ** error_message ATTRIBUTE_UNUSED)
{
  unsigned long insn;
#ifdef USE_REL
  unsigned long offset
#endif
  bfd_vma sym_value;
  enum elf_arc_reloc_type r_type;
  bfd_vma addr = reloc_entry->address;
  bfd_byte *hit_data = addr + (bfd_byte *) data;

  r_type = reloc_entry->howto->type;

  if (output_bfd != NULL)
    {
      reloc_entry->address += input_section->output_offset;

      /* In case of relocateable link and if the reloc is against a
         section symbol, the addend needs to be adjusted according to
         where the section symbol winds up in the output section.  */ 

      if ((symbol_in->flags & BSF_SECTION_SYM) && symbol_in->section)
        reloc_entry->addend += symbol_in->section->output_offset;

      return bfd_reloc_ok;
    }

  /* Return an error if the symbol is not defined. An undefined weak
     symbol is considered to have a value of zero (SVR4 ABI, p. 4-27). */ 

  if (symbol_in != NULL && bfd_is_und_section (symbol_in->section) 
      && ((symbol_in->flags & BSF_WEAK) == 0))
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol_in->section))
    sym_value = 0;
  else
    sym_value = (symbol_in->value
                 + symbol_in->section->output_section->vma
                 + symbol_in->section->output_offset);

  sym_value += reloc_entry->addend;

  if (r_type != R_ARC_32_ME) {
     sym_value -= (input_section->output_section->vma
                + input_section->output_offset);
     sym_value -= (reloc_entry->address & ~0x3);
  }

  insn = bfd_get_32_me(abfd, hit_data);

  switch(r_type)
  {
    case R_ARC_S21H_PCREL:
#ifdef USE_REL
      /* Retrieve the offset from the instruction, if any.  */
      /* Extract the first 10 bits from Position 6 to 15 in insn.  */
      offset = ((insn << 16) >> 22) << 10;

      /* Extract the remaining 10 bits from Position 17 to 26 in insn.  */
      offset |= ((insn << 5) >> 22);

      /* Fill in 1 bit to get the 21 bit Offset Value. */
      offset = offset << 1;

      /* Ramana : No addends remain in place. */
      /* sym_value += offset; */

#endif /* USE_REL.  */
      /* Extract the instruction opcode alone from 'insn'. */
      insn = insn & 0xf801003f;
      insn |= ((((sym_value >> 1) & 0x3ff) << 17)
               | (((sym_value >> 1) & 0xffc00) >> 4));
      break;
    case R_ARC_S21W_PCREL:
#ifdef USE_REL
      /* Retrieve the offset from the instruction, if any */
      /* Extract the first 10 bits from Position 6 to 15 in insn */
      offset = ((insn << 16) >> 22) << 9;

      /* Extract the remaining 9 bits from Position 18 to 26 in insn */
      offset |= ((insn << 5) >> 23);

      /* Fill in 2 bits to get the 25 bit Offset Value */
      offset = offset << 2;

      /* No addends remain in place */
      /*       sym_value += offset; */

#endif /* USE_REL. */
      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf803003f;

      insn |= ((((sym_value >> 2) & 0x1ff) << 18)
               | (((sym_value >> 2) & 0x7fe00) >> 3));
      break;
    case R_ARC_S25H_PCREL:
#ifdef USE_REL
      /* Retrieve the offset from the instruction, if any */
      /* Extract the high 4 bits from Position 0 to 3 in insn */
      offset = ((insn << 28) >> 28) << 10;

      /* Extract the next 10 bits from Position 6 to 15 in insn */
      offset |= ((insn << 16) >> 22);
      offset = offset << 10;

      /* Extract the remaining 10 bits from Position 17 to 26 in insn */
      offset |= ((insn << 5) >> 22);

      /* Fill in 1 bit to get the 25 bit Offset Value */
      offset = offset << 1;

      /* Ramana : No addends remain in place. */
      /* sym_value += offset; */


#endif /* USE_REL. */
      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf8010030;

      insn |= ((((sym_value >> 1) & 0x3ff) << 17)
               | (((sym_value >> 1) & 0xffc00) >> 4)
               | (((sym_value >> 1) & 0xf00000) >> 20));
      break;
    case R_ARC_PLT32:
      break;
    case R_ARC_S25W_PCREL:
#ifdef USE_REL
      /* Retrieve the offset from the instruction, if any */
      /* Extract the high 4 bits from Position 0 to 3 in insn */
      offset = ((insn << 28) >> 28) << 10;

      /* Extract the next 10 bits from Position 6 to 15 in insn */
      offset |= ((insn << 16) >> 22);
      offset = offset << 9;

      /* Extract the remaining 9 bits from Position 18 to 26 in insn */
      offset |= ((insn << 5) >> 23);

      /* Fill in 2 bits to get the 25 bit Offset Value */
      offset = offset << 2;

      /* Ramana : No addends remain in place */
      /*      sym_value += offset; */

#endif    /* USE_REL. */
      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf8030030;

      insn |= ((((sym_value >> 2) & 0x1ff) << 18)
               | (((sym_value >> 2) & 0x7fe00) >> 3)
               | (((sym_value >> 2) & 0x780000) >> 19));
      break;
    case R_ARC_S13_PCREL:
#ifdef USE_REL
      /* Retrieve the offset from the instruction, if any */
      /* Extract the 11 bits from Position 0 to 10 in insn */
      offset = (insn << 5) >> 21;

      /* Fill in 2 bits to get the 13 bit Offset Value */
      offset = offset << 2;

      /* No addends remain in place */
      /*      sym_value += offset; */
#endif
      /* Extract the instruction opcode alone from 'insn' */
      insn = (insn & 0xf800ffff);
     insn |= ((sym_value >> 2) & 0x7ff) << 16;
      break;
  case R_ARC_GOTPC32:
  case R_ARC_32_ME:
      insn = sym_value;
      break;
  default:
    return bfd_reloc_notsupported;
    break;
  }

  /* Middle-Endian Instruction Encoding only for executable code */
  /* FIXME:: I am still not sure about this. Ramana . */
  if (input_section && (input_section->flags & SEC_CODE))
    bfd_put_32_me(abfd, insn, hit_data);
  else
    bfd_put_32(abfd, insn, hit_data);

  return bfd_reloc_ok;
}

static bfd_vma
bfd_get_32_me (bfd * abfd,const unsigned char * data)
{
  bfd_vma value = 0;

  if (bfd_big_endian(abfd)) { 
    value = bfd_get_32 (abfd, data);
  }
  else {
    value = ((bfd_get_8 (abfd, data) & 255) << 16);
    value |= ((bfd_get_8 (abfd, data + 1) & 255) << 24);
    value |= (bfd_get_8 (abfd, data + 2) & 255);
    value |= ((bfd_get_8 (abfd, data + 3) & 255) << 8);
  }
 
  return value;
}
 
static void
bfd_put_32_me (bfd *abfd, bfd_vma value,unsigned char *data)
{
  bfd_put_16 (abfd, (value & 0xffff0000) >> 16, data);
  bfd_put_16 (abfd, value & 0xffff, data + 2);
}


/* ******************************************
 * PIC-related routines for the arc backend 
 * ******************************************/

/* This will be overridden by the interpreter specified in
   the linker specs */
#define ELF_DYNAMIC_INTERPRETER  "/sbin/ld-uClibc.so"

/* size of one plt entry */
#define PLT_ENTRY_SIZE  12

/* The zeroth entry in the absolute plt entry */
static const bfd_byte elf_arc_abs_plt0_entry [2 * PLT_ENTRY_SIZE] = 
  { 
    0x00, 0x16,			/* ld %r11, [0] */
    0x0b, 0x70,
    0x00, 0x00, 
    0x00, 0x00,
    0x00, 0x16,			/* ld %r10, [0] */
    0x0a, 0x70,			/*  */
    0,0,
    0,0,
    0x20, 0x20,			/* j [%r10] */
    0x80, 0x02,			/* ---"---- */
    0x00, 0x00,			/* pad */
    0x00, 0x00			/* pad */
  };

/* Contents of the subsequent entries in the absolute plt */
static const bfd_byte elf_arc_abs_pltn_entry [PLT_ENTRY_SIZE] = 
  { 
    0x30, 0x27,			/* ld %r12, [%pc,func@@gotpc] */
    0x8c, 0x7f,			/* ------ " " -------------- */
    0x00, 0x00,			/* ------ " " -------------- */
    0x00, 0x00,			/* ------ " " -------------- */
    0x20, 0x7c, 		/* j_s.d [%r12]              */ 
    0xef, 0x74,			/* mov_s %r12, %pcl          */
  };

/* The zeroth entry in the pic plt entry */
static const bfd_byte elf_arc_pic_plt0_entry [2 * PLT_ENTRY_SIZE] = 
  { 
    0x30, 0x27,			/* ld %r11, [pcl,0] : 0 to be replaced by _DYNAMIC@@GOTPC+4 */
    0x8b, 0x7f,
    0x00, 0x00, 
    0x00, 0x00,
    0x30, 0x27,			/* ld %r10, [pcl,0] : 0 to be replaced by -DYNAMIC@@GOTPC+8  */
    0x8a, 0x7f,			/*  */
    0,0,
    0,0,
    0x20, 0x20,			/* j [%r10] */
    0x80, 0x02,			/* ---"---- */
    0x00, 0x00,			/* pad */
    0x00, 0x00			/* pad */
  };

/* Contents of the subsequent entries in the pic plt */
static const bfd_byte elf_arc_pic_pltn_entry [PLT_ENTRY_SIZE] = 
  { 
    0x30, 0x27,			/* ld %r12, [%pc,func@@got]   */
    0x8c, 0x7f,			/* ------ " " -------------- */
    0x00, 0x00,			/* ------ " " -------------- */
    0x00, 0x00,			/* ------ " " -------------- */
    0x20, 0x7c, 		/* j_s.d [%r12]              */ 
    0xef, 0x74,			/* mov_s %r12, %pcl          */
  };


/* Function: arc_plugin_one_reloc
 * Brief   : Fill in the relocated value of the symbol into an insn
 *           depending on the relocation type. The instruction is 
 *           assumed to have been read in the correct format (ME / LE/ BE)
 * Args    : 1. insn              : the original insn into which the relocated
 *                                  value has to be filled in.  
 *           2. rel               : the relocation entry.  
 *           3. value             : the value to be plugged in the insn.  
 *           4. overflow_detected : Pointer to short to indicate relocation
 *                                  overflows.
 *           5. symbol_defined    : bool value representing if the symbol
 *                                  definition is present.  
 * Returns : the insn with the relocated value plugged in.
 */
static unsigned long
arc_plugin_one_reloc (unsigned long insn, Elf_Internal_Rela *rel,
                      int value,
                      short *overflow_detected, bfd_boolean symbol_defined
		      )
{
  unsigned long offset;
  long long check_overfl_pos,check_overfl_neg;
  reloc_howto_type *howto;
  enum elf_arc_reloc_type r_type;

  r_type           = ELF32_R_TYPE (rel->r_info);
  howto            = arc_elf_calculate_howto_index(r_type);

  if (arc_signed_reloc_type [howto->type] == 1)
    {
      check_overfl_pos = (long long)1 << (howto->bitsize-1);
      check_overfl_neg = -check_overfl_pos;
      if ((value >= check_overfl_pos) || (check_overfl_neg > value))
	*overflow_detected = 1;
    }
  else
    {
      check_overfl_pos = (long long)1 << (howto->bitsize);
      check_overfl_neg = 0;
      if ((unsigned int) value >= check_overfl_pos)
	*overflow_detected = 1;
    }

    if (*overflow_detected
      && symbol_defined == TRUE)
    {
      (*_bfd_error_handler ) ("Error: Overflow detected in relocation value;");
      if (howto->pc_relative)
	(*_bfd_error_handler) ("Relocation value should be between %lld and %lld whereas it  %d",
			     check_overfl_pos - 1, (signed long long) check_overfl_neg,
			      value);
      else
	(*_bfd_error_handler) ("Relocation value should be between %lld and %lld whereas it  %ld",
			       check_overfl_pos - 1, (signed long long) check_overfl_neg,
			       (unsigned int) value);

      bfd_set_error (bfd_error_bad_value);
      *overflow_detected = 1;
      return 0;
    }
  else
    *overflow_detected = 0;
  
  switch(r_type)
  {
    case R_ARC_B26:
	/* Retrieve the offset from the instruction, if any */
	/* Extract the last 24 bits from Position 0 to 23 in insn */

      offset = insn & 0x00ffffff;
      /* Fill in 2 bit to get the 26 bit Offset Value */
      offset = offset << 2;


      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xff000000;
      /* With the addend now being in the addend table, there is no 
       * need to use this 
       */
      /* Ramana : No longer required since
       * addends no longer exist in place 
       */
      /*      value += offset; */
      insn |= ((value >> 2) & (~0xff000000));
      break;
	
    case R_ARC_B22_PCREL:
	/* Retrieve the offset from the instruction, if any */
	/* Extract the first 10 bits from Position 6 to 15 in insn */
	offset = ((insn << 5) >> 12);
	
	/* Fill in 2 bit to get the 22 bit Offset Value */
	offset = offset << 2;
	
	/* Extract the instruction opcode alone from 'insn' */
	insn = insn & 0xf800007f;
	
	/* Ramana: All addends exist in the relocation table. Ignore
	 *  the in place addend 
	 */
	/*value += offset; */
	
	insn |= ((value >> 2) << 7) & (~0xf800007f);
	
	break;
	
    case R_ARC_S21H_PCREL:
      /* Retrieve the offset from the instruction, if any */
      /* Extract the first 10 bits from Position 6 to 15 in insn */
      offset = ((insn << 16) >> 22) << 10;

      /* Extract the remaining 10 bits from Position 17 to 26 in insn */
      offset |= ((insn << 5) >> 22);

      /* Fill in 1 bit to get the 21 bit Offset Value */
      offset = offset << 1;

      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf801003f;


      
      /* Ramana: All addends exist in the relocation table. Ignore
       *  the in place addend 
       */
      /*value += offset; */
      

      insn |= ((((value >> 1) & 0x3ff) << 17)
               | (((value >> 1) & 0xffc00) >> 4));
      break;
    case R_ARC_S21W_PCREL:
      /* Retrieve the offset from the instruction, if any */
      /* Extract the first 10 bits from Position 6 to 15 in insn */
      offset = ((insn << 16) >> 22) << 9;

      /* Extract the remaining 9 bits from Position 18 to 26 in insn */
      offset |= ((insn << 5) >> 23);

      /* Fill in 2 bits to get the 25 bit Offset Value */
      offset = offset << 2;

      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf803003f;

      /* Ramana: All addends exist in the relocation table. Ignore
       *  the in place addend 
       */
      
      /*value += offset;*/


      insn |= ((((value >> 2) & 0x1ff) << 18)
               | (((value >> 2) & 0x7fe00) >> 3));
      break;
    case R_ARC_S25H_PCREL:
      /* Retrieve the offset from the instruction, if any */
      /* Extract the high 4 bits from Position 0 to 3 in insn */
      offset = ((insn << 28) >> 28) << 10;

      /* Extract the next 10 bits from Position 6 to 15 in insn */
      offset |= ((insn << 16) >> 22);
      offset = offset << 10;

      /* Extract the remaining 10 bits from Position 17 to 26 in insn */
      offset |= ((insn << 5) >> 22);

      /* Fill in 1 bit to get the 25 bit Offset Value */
      offset = offset << 1;

      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf8010030;

      /* Ramana: All addends exist in the relocation table. Ignore
       *  the in place addend 
       */
      
      /* value += offset; */

      insn |= ((((value >> 1) & 0x3ff) << 17)
               | (((value >> 1) & 0xffc00) >> 4)
               | (((value >> 1) & 0xf00000) >> 20));
      break;
  case R_ARC_PLT32:
    BFD_DEBUG_PIC (fprintf(stderr,"plt for %x value=0x%x\n",insn,value));
    /*
      Relocations of the type R_ARC_PLT32 are for the BLcc
      instructions. However the BL instruction takes a 25-bit relative
      displacement while the BLcc instruction takes a 21-bit relative
      displacement. We are using bit-17 to distinguish between these two
      cases and handle them differently.
    */

    if (insn
	& ((insn & 0x08000000) ? 0x00020000 : 0x00010000)) /* Non-conditional */
      {
	insn = insn & 0xf8030030;
	insn |= (((value >> 2) & 0x780000) >> 19);
      }
    else /* Conditional */
      {
	insn = insn & 0xf803003f;
      }
    
    insn |= ((((value >> 2) & 0x1ff) << 18)
	     | (((value >> 2) & 0x7fe00) >> 3));
    break;
  case R_ARC_S25W_PCREL:

       /* Retrieve the offset from the instruction, if any */ 	 
       /* Extract the high 4 bits from Position 0 to 3 in insn */ 	 
       offset = ((insn << 28) >> 28) << 10; 	 
  	 
       /* Extract the next 10 bits from Position 6 to 15 in insn */ 	 
       offset |= ((insn << 16) >> 22); 	 
       offset = offset << 9; 	 
  	 
       /* Extract the remaining 9 bits from Position 18 to 26 in insn */ 	 
       offset |= ((insn << 5) >> 23); 	 
  	 
       /* Fill in 2 bits to get the 25 bit Offset Value */ 	 
       offset = offset << 2;
      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf8030030;
      /* Ramana: All addends exist in the relocation table. Ignore
       *  the in place addend 
       */
      
      /* value += offset; 	 */

      insn |= ((((value >> 2) & 0x1ff) << 18)
               | (((value >> 2) & 0x7fe00) >> 3)
               | (((value >> 2) & 0x780000) >> 19));
      break;
    case R_ARC_S13_PCREL:
      /* Retrieve the offset from the instruction, if any */
      /* Extract the 11 bits from Position 0 to 10 in insn */
      offset = (insn << 5) >> 21;

      /* Fill in 2 bits to get the 13 bit Offset Value */
      offset = offset << 2;

      /* Extract the instruction opcode alone from 'insn' */
      insn = (insn & 0xf800ffff);

      /* Ramana: All addends exist in the relocation table. Ignore
       *  the in place addend 
       */
      
      /* value += offset; */

      insn |= ((value >> 2) & 0x7ff) << 16;
      break;

  case R_ARC_32:
  case R_ARC_GOTPC:
  case R_ARC_GOTOFF:
  case R_ARC_GOTPC32:
  case R_ARC_32_ME:
  case R_ARC_PC32:
      insn = value;
      
  case R_ARC_8:
  case R_ARC_16:
  case R_ARC_24:
    /* One would have to OR the value here since 
       insn would contain the bits read in correctly. */

    
    insn |= value ;
      break;

  case R_ARC_SDA32_ME:
    insn |= value;
    break;
 
  case R_ARC_SDA_LDST2:
    value >>= 1;
  case R_ARC_SDA_LDST1:
    value >>= 1;
  case R_ARC_SDA_LDST:
    value &= 0x1ff;
    insn |= ( ((value & 0xff) << 16)  | ((value >> 8) << 15));
    break;

  case R_ARC_SDA16_LD:
    /* FIXME: The 16-bit insns shd not come in as higher bits of a 32-bit word */
    insn |= (value & 0x1ff) <<16;
    break;

  case R_ARC_SDA16_LD1:
    /* FIXME: The 16-bit insns shd not come in as higher bits of a 32-bit word */
    insn |= ((value >> 1) & 0x1ff ) <<16;
    break;

  case R_ARC_SDA16_LD2:
    /* FIXME: The 16-bit insns shd not come in as higher bits of a 32-bit word */
    insn |= ((value >> 2) & 0x1ff) <<16;
    break;
    
    


  default:
    /* FIXME:: This should go away once the HOWTO Array 
       is used for this purpose. 
    */
    fprintf(stderr, "Unsupported reloc used : %s (value = %d)\n", (arc_elf_calculate_howto_index(r_type))->name, value);
    break;
  }
  
  return insn;
}

/* Function : elf_arc_check_relocs
 * Brief    : Check the relocation entries and take any special
 *           actions, depending on the relocation type if needed.
 * Args     : 1. abfd   : The input bfd
 *            2. info   : link information
 *	      3. sec    : section being relocated
 *	      4. relocs : the list of relocations.
 * Returns  : True/False as the return status.
 */
static bfd_boolean
elf_arc_check_relocs (bfd *abfd, 
                      struct bfd_link_info *info, 
                      asection *sec, 
                      const Elf_Internal_Rela *relocs)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *srelgot;
  asection *sreloc;

  if (info->relocatable)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_offsets = elf_local_got_offsets (abfd);

  sgot = NULL;
  srelgot = NULL;
  sreloc = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      BFD_DEBUG_PIC (fprintf(stderr,"Processing reloc #%d in %s\n",
			     rel-relocs,__PRETTY_FUNCTION__));

      r_symndx = ELF32_R_SYM (rel->r_info);

      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];

      /* Some relocs require a global offset table.  */
      if (dynobj == NULL)
	{
	  switch (ELF32_R_TYPE (rel->r_info))
	    {
	    case R_ARC_GOTPC32:
	    case R_ARC_GOTOFF:
	    case R_ARC_GOTPC:
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfd_elf_create_got_section (dynobj, info))
		return FALSE;
	      break;

	    default:
	      break;
	    }
	}

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_ARC_GOTPC32:
	  /* This symbol requires a global offset table entry.  */

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (srelgot == NULL
	      && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot
		    = bfd_make_section_with_flags (dynobj, ".rela.got",
						   SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY);
		  if (srelgot == NULL
		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		    return FALSE;
		}
	    }

	  if (h != NULL)
	    {
	      if (h->got.offset != (bfd_vma) -1)
		{
		  BFD_DEBUG_PIC(fprintf(stderr, "got entry stab entry already done%d\n",r_symndx));

		  /* We have already allocated space in the .got.  */
		  break;
		}


	      h->got.offset = sgot->size;
	      BFD_DEBUG_PIC(fprintf(stderr, "got entry stab entry %d got offset=0x%x\n",r_symndx,
				    h->got.offset));

	      /* Make sure this symbol is output as a dynamic symbol.  */
	      if (h->dynindx == -1)
		{
		  if (! bfd_elf_link_record_dynamic_symbol (info, h))
		    return FALSE;
		}

	      BFD_DEBUG_PIC(fprintf (stderr, "Got raw size increased\n"));
	      srelgot->size += sizeof (Elf32_External_Rela);
	    }
	  else
	    {
     	      /* This is a global offset table entry for a local
                 symbol.  */
	      if (local_got_offsets == NULL)
		{
		  size_t size;
		  register unsigned int i;

		  size = symtab_hdr->sh_info * sizeof (bfd_vma);
		  local_got_offsets = (bfd_vma *) bfd_alloc (abfd, size);
		  if (local_got_offsets == NULL)
		    return FALSE;
		  elf_local_got_offsets (abfd) = local_got_offsets;
		  for (i = 0; i < symtab_hdr->sh_info; i++)
		    local_got_offsets[i] = (bfd_vma) -1;
		}
	      if (local_got_offsets[r_symndx] != (bfd_vma) -1)
		{
		  BFD_DEBUG_PIC(fprintf(stderr, "got entry stab entry already done%d\n",r_symndx));

		  /* We have already allocated space in the .got.  */
		  break;
		}

	      BFD_DEBUG_PIC(fprintf(stderr, "got entry stab entry %d\n",r_symndx));

	      
	      local_got_offsets[r_symndx] = sgot->size;

	      if (info->shared)
		{
		  /* If we are generating a shared object, we need to
                     output a R_ARC_RELATIVE reloc so that the dynamic
                     linker can adjust this GOT entry.  */
		  srelgot->size += sizeof (Elf32_External_Rela);
		}
	    }
	  
	  BFD_DEBUG_PIC(fprintf (stderr, "Got raw size increased\n"));

	  sgot->size += 4;

	  break;

	case R_ARC_PLT32:
	  /* This symbol requires a procedure linkage table entry.  We
             actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code which is
             never referenced by a dynamic object, in which case we
             don't need to generate a procedure linkage table entry
             after all.  */

	  /* If this is a local symbol, we resolve it directly without
             creating a procedure linkage table entry.  */
	  if (h == NULL)
	    continue;

	  h->needs_plt = 1;

	  break;

	case R_ARC_32:
	case R_ARC_32_ME:
	case R_ARC_PC32:
	  /* If we are creating a shared library, and this is a reloc
             against a global symbol, or a non PC relative reloc
             against a local symbol, then we need to copy the reloc
             into the shared library.  However, if we are linking with
             -Bsymbolic, we do not need to copy a reloc against a
             global symbol which is defined in an object we are
             including in the link (i.e., DEF_REGULAR is set).  At
             this point we have not seen all the input files, so it is
             possible that DEF_REGULAR is not set now but will be set
             later (it is never cleared).  We account for that
             possibility below by storing information in the
             pcrel_relocs_copied field of the hash table entry.  */
	  if (info->shared
	      && (ELF32_R_TYPE (rel->r_info) != R_ARC_PC32
		  || (h != NULL
		      && (!info->symbolic || !h->def_regular))))
	    {
	      /* When creating a shared object, we must copy these
                 reloc types into the output file.  We create a reloc
                 section in dynobj and make room for this reloc.  */
	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      sreloc
			= bfd_make_section_with_flags (dynobj, name, flags);
		      if (sreloc == NULL
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
			return FALSE;
		    }
		}

	      sreloc->size += sizeof (Elf32_External_Rela);

	      /* If we are linking with -Bsymbolic, and this is a
                 global symbol, we count the number of PC relative
                 relocations we have entered for this symbol, so that
                 we can discard them again if the symbol is later
                 defined by a regular object.  Note that this function
                 is only called if we are using an elf_ARC linker
                 hash table, which means that h is really a pointer to
                 an elf_ARC_link_hash_entry.  */
	      if (h != NULL && info->symbolic
		  && ELF32_R_TYPE (rel->r_info) == R_ARC_PC32)
		{
		  struct elf_ARC_link_hash_entry *eh;
		  struct elf_ARC_pcrel_relocs_copied *p;

		  eh = (struct elf_ARC_link_hash_entry *) h;

		  for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
		    if (p->section == sreloc)
		      break;

		  if (p == NULL)
		    {
		      p = ((struct elf_ARC_pcrel_relocs_copied *)
			   bfd_alloc (dynobj, sizeof *p));
		      if (p == NULL)
			return FALSE;
		      p->next = eh->pcrel_relocs_copied;
		      eh->pcrel_relocs_copied = p;
		      p->section = sreloc;
		      p->count = 0;
		    }

		  ++p->count;
		}
	    }

	  break;

	default:
	  break;
	}

    }

  return TRUE;
}


/* Relocate an arc ELF section.  */
/* Function : elf_arc_relocate_section
 * Brief    : Relocate an arc section, by handling all the relocations
 *           appearing in that section.
 * Args     : output_bfd    : The bfd being written to. 
 *            info          : Link information.
 *            input_bfd     : The input bfd.
 *            input_section : The section being relocated.
 *            contents      : contents of the section being relocated.
 *            relocs        : List of relocations in the section.
 *            local_syms    : is a pointer to the swapped in local symbols.
 *            local_section : is an array giving the section in the input file
 *                            corresponding to the st_shndx field of each 
 *                            local symbol.
 * Returns  :  
 */
static bfd_boolean
elf_arc_relocate_section (bfd *output_bfd, 
                          struct bfd_link_info *info, 
                          bfd *input_bfd, 
                          asection *input_section,
			  bfd_byte * contents, 
                          Elf_Internal_Rela *relocs, 
                          Elf_Internal_Sym *local_syms, 
                          asection **local_sections)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  asection *sgot;
  asection *splt;
  asection *sreloc;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  short overflow_detected=0;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);

  sgot = NULL;
  splt = NULL;
  sreloc = NULL;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      enum elf_arc_reloc_type r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sec;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      bfd_boolean symbol_defined = TRUE;

      /* Distance of the relocation slot in the insn .This value is used for 
	 handling relative relocations. */
      long offset_in_insn = 0;

      /* The insn bytes */
      unsigned long insn;


      r_type = ELF32_R_TYPE (rel->r_info);
      
      if (r_type >= (int) R_ARC_max)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      howto = arc_elf_calculate_howto_index(r_type);

      BFD_DEBUG_PIC (fprintf(stderr,"Reloc type=%s in %s\n",
			     howto->name,
			     __PRETTY_FUNCTION__));

      r_symndx = ELF32_R_SYM (rel->r_info);


      if (info->relocatable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */

	  /* Checks if this is a local symbol 
	   * and thus the reloc might (will??) be against a section symbol.
	   */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];

		  /* for RELA relocs.Just adjust the addend 
		     value in the relocation entry.  */
		  rel->r_addend += sec->output_offset + sym->st_value;

		  BFD_DEBUG_PIC(fprintf (stderr, "local symbols reloc \
(section=%d %s) seen in %s\n", \
					 r_symndx,\
					 local_sections[r_symndx]->name, \
					 __PRETTY_FUNCTION__)); 
		}
	    }

	  continue;
	}

      /* This is a final link.  */
      h = NULL;
      sym = NULL;
      sec = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* This is a local symbol */
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);

	  /* Mergeable section handling */
	  if ((sec->flags & SEC_MERGE)
	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      asection *msec;
	      msec = sec;
	      rel->r_addend = _bfd_elf_rel_local_sym (output_bfd, sym, 
						      &msec, rel->r_addend);
 	      rel->r_addend -= relocation;
	      rel->r_addend += msec->output_section->vma + msec->output_offset;
	    }
	  
	  relocation += rel->r_addend; 
	}
      else
	{
	  /* Global symbols */
	  
	  /* get the symbol's entry in the symtab */
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* if we have encountered a definition for this symbol */
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      if (r_type == R_ARC_GOTPC
		  || (r_type == R_ARC_PLT32
		      && h->plt.offset != (bfd_vma) -1)
		  || (r_type == R_ARC_GOTPC32
		      && elf_hash_table (info)->dynamic_sections_created
		      && (! info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || !h->def_regular))
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || !h->def_regular)
		      && (r_type == R_ARC_32
			  || r_type == R_ARC_PC32)
		      && (input_section->flags & SEC_ALLOC) != 0))
		{
		  /* In these cases, we don't need the relocation
                     value.  We check specially because in some
                     obscure cases sec->output_section will be NULL.  */
		  relocation = 0;
		}
	      else if (sec->output_section == NULL)
		{
		  (*_bfd_error_handler)
		    ("%s: warning: unresolvable relocation against symbol `%s' from %s section",
		     bfd_get_filename (input_bfd), h->root.root.string,
		     bfd_get_section_name (input_bfd, input_section));
		  relocation = 0;
		}
	    else if (0 && r_type == R_ARC_SDA16_LD2) /* FIXME: delete this piece of code */
	      {
		  relocation = (h->root.u.def.value
				+ sec->output_offset);
		  /* add the addend since the arc has RELA relocations */
		  relocation += rel->r_addend;
	      }
	      else
		{
		  relocation = (h->root.u.def.value
				+ sec->output_section->vma
				+ sec->output_offset);
		  /* add the addend since the arc has RELA relocations */
		  relocation += rel->r_addend;
		}
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else if (info->shared && !info->symbolic)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string,
		      input_bfd, input_section, rel->r_offset, TRUE)))
		return FALSE;
	      symbol_defined = FALSE;
	      relocation = 0;
	    }
	}
      BFD_DEBUG_PIC ( fprintf (stderr, "Relocation = %d (%x)\n", relocation, relocation));


      switch (r_type)
	{
	case R_ARC_GOTPC32:
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_DEBUG_PIC (fprintf (stderr, "made got\n"));
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (h != NULL)
	    {
	      bfd_vma off;

	      off = h->got.offset;
	      BFD_ASSERT (off != (bfd_vma) -1);

	      if (! elf_hash_table (info)->dynamic_sections_created
		  || (info->shared
		      && (info->symbolic || h->dynindx == -1)
		      && h->def_regular))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 4, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_32 (output_bfd, relocation,
				  sgot->contents + off);
		      h->got.offset |= 1;
		    }
		}

	      relocation = sgot->output_section->vma + sgot->output_offset + off;
	      BFD_DEBUG_PIC(fprintf(stderr, "OFFSET=0x%x output_offset=%x (1)\n", off, sgot->output_offset));
	    }
	  else
	    {
	      bfd_vma off;

	      BFD_ASSERT (local_got_offsets != NULL
			  && local_got_offsets[r_symndx] != (bfd_vma) -1);

	      off = local_got_offsets[r_symndx];

	      /* The offset must always be a multiple of 4.  We use
                 the least significant bit to record whether we have
                 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_32 (output_bfd, relocation,
			      sgot->contents + off);

		  if (info->shared)
		    {
		      asection *srelgot;
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;		      

		      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
		      BFD_ASSERT (srelgot != NULL);

		      outrel.r_offset = (sgot->output_section->vma
					 + sgot->output_offset
					 + off);
		      /* RELA relocs */
		      outrel.r_addend = 0; //PBB??

		      outrel.r_info = ELF32_R_INFO (0, R_ARC_RELATIVE);
		      loc = srelgot->contents;
		      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela); /* relA */
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }

		  local_got_offsets[r_symndx] |= 1;
		}

	      relocation = sgot->output_section->vma + sgot->output_offset + off;
	      BFD_DEBUG_PIC(fprintf(stderr, "OFFSET=0x%x (2)\n", off));
	    }

	  BFD_DEBUG_PIC(fprintf(stderr, "RELOCATION =%x\n",relocation));
	  /* the data in GOT32 relocs is 4 bytes into the insn */
	  offset_in_insn = 4;

	  break;

	case R_ARC_GOTOFF:
	  /* Relocation is relative to the start of the global offset
	     table.  */

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  /* Note that sgot->output_offset is not involved in this
	     calculation.  We always want the start of .got.  If we
	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
	     permitted by the ABI, we might have to change this
	     calculation.  */
	  BFD_DEBUG_PIC(fprintf(stderr,"GOTOFF relocation = %x. Subtracting %x\n",relocation, sgot->output_section->vma));
	  relocation -= sgot->output_section->vma;

	  break;

	case R_ARC_GOTPC:
	  /* Use global offset table as symbol value.  */

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  relocation = sgot->output_section->vma;
	  
	  offset_in_insn = 4;
	  break;

	case R_ARC_PLT32:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLT32 reloc again a local symbol directly,
             without using the procedure linkage table.  */
	  if (h == NULL)
	    break;

	  if (h->plt.offset == (bfd_vma) -1)
	    {
	      /* We didn't make a PLT entry for this symbol.  This
                 happens when statically linking PIC code, or when
                 using -Bsymbolic.  */
	      break;
	    }

	  if (splt == NULL)
	    {
	      splt = bfd_get_section_by_name (dynobj, ".plt");
	      BFD_ASSERT (splt != NULL);
	    }

	  relocation = (splt->output_section->vma
			+ splt->output_offset
			+ h->plt.offset);

	  break;

	case R_ARC_32:
	case R_ARC_32_ME:
	case R_ARC_PC32:
	  if (info->shared
	      && (r_type != R_ARC_PC32
		  || (h != NULL
		      && h->dynindx != -1
		      && (!info->symbolic || !h->def_regular))))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip, relocate;
	      bfd_byte *loc;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);

		  BFD_ASSERT (sreloc != NULL);
		}

	      skip = FALSE;

	      outrel.r_offset = _bfd_elf_section_offset (output_bfd, 
							 info, 
							 input_section,
							 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1)
		  skip = TRUE;
	      	      
	      outrel.r_addend = rel->r_addend;
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);

	      if (skip)
		{
		  memset (&outrel, 0, sizeof outrel);
		  relocate = FALSE;
		}
	      else if (r_type == R_ARC_PC32)
		{
		  BFD_ASSERT (h != NULL && h->dynindx != -1);
		  if ((input_section->flags & SEC_ALLOC) != 0)
		    relocate = FALSE;
		  else
		    relocate = TRUE;
		  outrel.r_info = ELF32_R_INFO (h->dynindx, R_ARC_PC32);
		}
	      else
		{
		  /* h->dynindx may be -1 if this symbol was marked to
                     become local.  */
		  if (h == NULL
		      || ((info->symbolic || h->dynindx == -1)
			  && h->def_regular))
		    {
		      relocate = TRUE;
		      /* outrel.r_addend = 0; */
		      outrel.r_info = ELF32_R_INFO (0, R_ARC_RELATIVE);
		    }
		  else
		    {
		      BFD_ASSERT (h->dynindx != -1);
		      if ((input_section->flags & SEC_ALLOC) != 0)
			relocate = FALSE;
		      else
			relocate = TRUE;
		      outrel.r_info = ELF32_R_INFO (h->dynindx, R_ARC_32);
		    }
		}

	      BFD_ASSERT(sreloc->contents != 0);

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela); /* relA */

	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      /* If this reloc is against an external symbol, we do
		 not want to fiddle with the addend.  Otherwise, we
		 need to include the symbol value so that it becomes
		 an addend for the dynamic reloc.  */
	      if (! relocate)
		continue;
	    }

	  /* PLT32 has to be w.r.t the instruction's start */
	  offset_in_insn = 0;
	  break;

	case R_ARC_B22_PCREL:
	  /* 'offset_in_insn' in case of the A4 is from the instruction in
	     the delay slot of the branch instruction hence the -4 offset.  */
 	  offset_in_insn = -4;
	  break;

	case R_ARC_SDA32_ME:

	case R_ARC_SDA_LDST:
	case R_ARC_SDA_LDST1:
	case R_ARC_SDA_LDST2:

	case R_ARC_SDA16_LD:
	case R_ARC_SDA16_LD1:
	case R_ARC_SDA16_LD2:
	  {
	    /* Get the base of .sdata section */
	    struct elf_link_hash_entry *h;
	    
	    h = elf_link_hash_lookup (elf_hash_table (info), "__SDATA_BEGIN__",
				      FALSE, FALSE, TRUE);
	    
	    if (h->root.type == bfd_link_hash_undefined)
	    {
	      (*_bfd_error_handler)("Error: Linker symbol __SDATA_BEGIN__ not found");
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }

	    /* Subtract the address of __SDATA_BEGIN__ from the relocation value */
	    ///	    fprintf (stderr, "relocation BEFORE = 0x%x SDATA_BEGIN = 0x%x\n", relocation, h->root.u.def.value);
	    relocation -= (h->root.u.def.value + h->root.u.def.section->output_section->vma);
	    //	    fprintf (stderr, "relocation AFTER = 0x%x SDATA_BEGIN = 0x%x\n", relocation, h->root.u.def.value);
	    break;
	  }
	default:
	  /* FIXME: Putting in a random dummy relocation value for the time being */
	  //	  fprintf (stderr, "In %s, relocation = 0x%x,  r_type = %d\n", __PRETTY_FUNCTION__, relocation, r_type);
	  break;
	}


      /* get the insn bytes here */
      if(elf_elfheader(input_bfd)->e_machine == EM_ARC)
	insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
      else
	if(input_section && (input_section->flags & SEC_CODE))
	  insn = bfd_get_32_me (input_bfd, contents + rel->r_offset);
	else
	  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
      
      BFD_DEBUG_PIC(fprintf(stderr, "relocation before the pc relative stuff @@offset 0x%x= %d[0x%x]\n", 
			    rel->r_offset,relocation, relocation));

      BFD_DEBUG_PIC(fprintf(stderr,"addend = 0x%x\n",rel->r_addend));

      /* For branches we need to find the offset from pcl rounded down to 4 byte boundary.Hence the (& ~3) */
      if (howto->pc_relative || r_type==R_ARC_PLT32 || r_type==R_ARC_GOTPC || r_type==R_ARC_GOTPC32)
	{
	  relocation -= (((input_section->output_section->vma + input_section->output_offset + rel->r_offset) & ~3) - offset_in_insn );
	}
#if 0
      else if (r_type==R_ARC_GOTPC32)
	{
	  relocation -= (input_section->output_section->vma + 
			 input_section->output_offset + rel->r_offset 
			 - offset_in_insn );
	}
#endif



      BFD_DEBUG_PIC(fprintf(stderr, "relocation AFTER the pc relative handling = %d[0x%x]\n", relocation, relocation));

      /* What does the modified insn look like */
      insn = arc_plugin_one_reloc (insn, rel, relocation,
				   &overflow_detected, symbol_defined);

      if (overflow_detected)
	{
	  if(h)
	    (*_bfd_error_handler) ("Global symbol: \"%s\".", h->root.root.string);
	  else
	    (*_bfd_error_handler) ("Local symbol: \"%s\".", local_sections[r_symndx]->name);
	  (*_bfd_error_handler) ("\nRelocation type is:%s \nFileName:%s \
                             \nSection Name:%s\
                             \nOffset in Section:%ld", howto->name, bfd_get_filename (input_bfd),
			     bfd_get_section_name (input_bfd, input_section),
			     rel->r_offset);

	  return FALSE;
	}
      
      BFD_DEBUG_PIC (fprintf (stderr, "Relocation = %d [0x%x]\n", (int)relocation, (unsigned)relocation));

      /* now write back into the section, with middle endian encoding
	 only for executable section */
      if(elf_elfheader(input_bfd)->e_machine == EM_ARC)
	bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
      else
	if (input_section && (input_section->flags & SEC_CODE))
	  bfd_put_32_me (input_bfd, insn, contents + rel->r_offset);
	else
	  bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

      r = bfd_reloc_ok;
      

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = h->root.root.string;
		else
		  {
		    name = bfd_elf_string_from_elf_section (input_bfd,
							    symtab_hdr->sh_link,
							    sym->st_name);
		    if (name == NULL)
		      return FALSE;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, (h ? &h->root : NULL), name, howto->name,
			(bfd_vma) 0, input_bfd, input_section, rel->r_offset)))
		  return FALSE;
	      }
	      break;
	    }
	}
      
    }
  
  return TRUE;
}


/* Function :  elf_arc_finish_dynamic_symbol
 * Brief    :  Finish up dynamic symbol handling.  We set the
 *           contents of various dynamic sections here.  
 * Args     :  output_bfd : 
 *             info       :
 *             h          :
 *             sym        :
 * Returns  : True/False as the return status.
 */
static bfd_boolean
elf_arc_finish_dynamic_symbol (bfd *output_bfd, 
                               struct bfd_link_info *info, 
                               struct elf_link_hash_entry *h, 
                               Elf_Internal_Sym *sym)
{
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection *splt;
      asection *sgot;
      asection *srel;
      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */

      BFD_ASSERT (h->dynindx != -1);

      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
      srel = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);

      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first TWO entries in the procedure linkage table are reserved.  */
      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 2;


      /* Get the offset into the .got table of the entry that
	 corresponds to this function.  Each .got entry is 4 bytes.
	 The first three are reserved.  */
      got_offset = (plt_index + 3) * 4;

      /* Fill in the entry in the procedure linkage table.  */
      if (! info->shared)
	{
	  memcpy (splt->contents + h->plt.offset, elf_arc_abs_pltn_entry,
		  PLT_ENTRY_SIZE);

	  /* fill in the limm in the plt entry to make it jump through its corresponding *(gotentry) */
	  bfd_put_32_me (output_bfd,
			 (sgot-> output_section->vma + sgot->output_offset + got_offset)
			 -(splt->output_section->vma + splt->output_offset + h->plt.offset),
			 splt->contents + h->plt.offset + 4);



	}
      else
	{
	  memcpy (splt->contents + h->plt.offset, elf_arc_pic_pltn_entry,
		  PLT_ENTRY_SIZE);

	  /* fill in the limm in the plt entry to make it jump through its corresponding *(gotentry) */
	  bfd_put_32_me (output_bfd,
			 (sgot-> output_section->vma + sgot->output_offset + got_offset)
			 -(splt->output_section->vma + splt->output_offset + h->plt.offset),
			 splt->contents + h->plt.offset + 4);


	}


      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd,
		  (splt->output_section->vma
		   + splt->output_offset),
		  sgot->contents + got_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + got_offset);
      /* RELA relocs */
      rel.r_addend = 0;
      rel.r_info = ELF32_R_INFO (h->dynindx, R_ARC_JMP_SLOT);

      loc = srel->contents;
      loc += plt_index * sizeof (Elf32_External_Rela); /* relA */

      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);

      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}

    }

  if (h->got.offset != (bfd_vma) -1)
    {
      asection *sgot;
      asection *srel;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */

      sgot = bfd_get_section_by_name (dynobj, ".got");
      srel = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srel != NULL);

      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + (h->got.offset &~ 1));

      /* If this is a -Bsymbolic link, and the symbol is defined
	 locally, we just want to emit a RELATIVE reloc.  Likewise if
	 the symbol was forced to be local because of a version file.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (info->shared
	  && (info->symbolic || h->dynindx == -1)
	  && h->def_regular)
	{
	  rel.r_addend = 0;
	  rel.r_info = ELF32_R_INFO (0, R_ARC_RELATIVE);
	}
      else
	{
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
	  /* RELA relocs */
	  rel.r_addend = 0;
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_ARC_GLOB_DAT);
	}

      loc = srel->contents;
      loc += srel->reloc_count++ * sizeof (Elf32_External_Rela);/* relA */
      
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
    }

  if (h->needs_copy)
    {
      asection *s;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol needs a copy reloc.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));

      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rela.bss");
      BFD_ASSERT (s != NULL);
      
      rel.r_addend = 0;
      rel.r_offset = (h->root.u.def.value
		      + h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset);
      rel.r_info = ELF32_R_INFO (h->dynindx, R_ARC_COPY);

      loc =  s->contents;
      loc += s->reloc_count++ * sizeof (Elf32_External_Rela); /* relA */
      
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || strcmp (h->root.root.string, "__DYNAMIC") == 0
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}


/* Function :  elf_arc_finish_dynamic_sections
 * Brief    :  Finish up the dynamic sections handling.  
 * Args     :  output_bfd : 
 *             info       :
 *             h          :
 *             sym        :
 * Returns  : True/False as the return status.
 */
static bfd_boolean
elf_arc_finish_dynamic_sections (bfd *output_bfd,struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sgot;
  asection *sdyn;
  asection *sec_ptr;
  char * oldname;

  dynobj = elf_hash_table (info)->dynobj;

  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      asection *splt;
      Elf32_External_Dyn *dyncon, *dynconend;

      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  asection *s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_INIT:
	      oldname = INIT_SYM_STRING;
	      name = init_str;
	      goto get_sym;

	    case DT_FINI:
	      oldname = FINI_SYM_STRING;
	      name = fini_str;
	      goto get_sym;

	    get_sym:
	      {
		struct elf_link_hash_entry *h;

		h = elf_link_hash_lookup (elf_hash_table (info), name,
					  FALSE, FALSE, TRUE);
		if (h != NULL
		    && (h->root.type == bfd_link_hash_defined
			|| h->root.type == bfd_link_hash_defweak))
		  {
		    dyn.d_un.d_val = h->root.u.def.value;
		    sec_ptr = h->root.u.def.section;
		    if (sec_ptr->output_section != NULL)
		      dyn.d_un.d_val += (sec_ptr->output_section->vma
					 + sec_ptr->output_offset);
		    else
		      {
			/* The symbol is imported from another shared
			   library and does not apply to this one.  */
			dyn.d_un.d_val = 0;
		      }

		    bfd_elf32_swap_dyn_out (dynobj, &dyn, dyncon);
		  }
		else
		  {
		    (*_bfd_error_handler)
		      ("warning: specified init/fini symbol %s not found.Defaulting to address of symbol %s", 
		       name, oldname);

		    /* restore the default name */
		    name = oldname;

		    h = elf_link_hash_lookup (elf_hash_table (info), name,
					      FALSE, FALSE, TRUE);
		    if (h != NULL
			&& (h->root.type == bfd_link_hash_defined
			    || h->root.type == bfd_link_hash_defweak))
		      {
			dyn.d_un.d_val = h->root.u.def.value;
			sec_ptr = h->root.u.def.section;
			if (sec_ptr->output_section != NULL)
			  dyn.d_un.d_val += (sec_ptr->output_section->vma
					     + sec_ptr->output_offset);
			else
			  {
			    /* The symbol is imported from another shared
			       library and does not apply to this one.  */
			    dyn.d_un.d_val = 0;
			  }
			
			bfd_elf32_swap_dyn_out (dynobj, &dyn, dyncon);
		      }
		
		  }

	      }
	      break;
	      
	    case DT_PLTGOT:
	      name = ".plt";
	      goto get_vma;
	    case DT_JMPREL:
	      name = ".rela.plt";
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_RELASZ:
	      /* My reading of the SVR4 ABI indicates that the
		 procedure linkage table relocs (DT_JMPREL) should be
		 included in the overall relocs (DT_REL).  This is
		 what Solaris does.  However, UnixWare can not handle
		 that case.  Therefore, we override the DT_RELASZ entry
		 here to make it not include the JMPREL relocs.  Since
		 the linker script arranges for .rela.plt to follow all
		 other relocation sections, we don't have to worry
		 about changing the DT_REL entry.  */
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      if (s != NULL)
		dyn.d_un.d_val -= s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	    }
	}

      /* Fill in the first entry in the procedure linkage table.  */
      if (splt->size > 0)
	{
	  if (info->shared)
	    {
	      memcpy (splt->contents, elf_arc_pic_plt0_entry, 2 * PLT_ENTRY_SIZE);
	      
	      /* fill in the _DYNAMIC@@GOTPC+4 and  
		 _DYNAMIC@@GOTPC+8 at PLT0+4 and PLT0+12 */
	      bfd_put_32_me (output_bfd,
			     ( sgot->output_section->vma + sgot->output_offset + 4 )
			     -(splt->output_section->vma + splt->output_offset ),
			     splt->contents + 4);
	      bfd_put_32_me (output_bfd,
			     (sgot->output_section->vma + sgot->output_offset + 8)
			     -(splt->output_section->vma + splt->output_offset +8),
			     splt->contents + 12);
	      
	      /* put got base at plt0+12 */
	      bfd_put_32 (output_bfd,
			  (sgot->output_section->vma + sgot->output_offset),
			  splt->contents + 20);
	    }
	  else
	    {
	      memcpy (splt->contents, elf_arc_abs_plt0_entry, 2 * PLT_ENTRY_SIZE);

	      /* in the executable, fill in the exact got addresses
		 for the module id ptr (gotbase+4) and the dl resolve
		 routine (gotbase+8) in the middle endian format */
	      bfd_put_32_me (output_bfd,
			     sgot->output_section->vma + sgot->output_offset + 4,
			     splt->contents + 4);
	      bfd_put_32_me (output_bfd,
			     sgot->output_section->vma + sgot->output_offset + 8,
			     splt->contents + 12);

	      /* put got base at plt0+12 */
	      bfd_put_32 (output_bfd,
			  (sgot->output_section->vma + sgot->output_offset),
			  splt->contents + 20);

	    }


	}

      /* UnixWare sets the entsize of .plt to 4, although that doesn't
	 really seem like the right value.  */
      elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;

    }


  /* Fill in the first three entries in the global offset table.  */
  if (sgot)
  {
  if (sgot->size > 0)
    {
      if (sdyn == NULL)
	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
	bfd_put_32 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
    }

  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
  }

  return TRUE;
}

/* Desc : Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf_arc_adjust_dynamic_symbol (struct bfd_link_info *info, 
                               struct elf_link_hash_entry *h)
{
  bfd *dynobj;
  asection *s;
  unsigned int power_of_two;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic && h->ref_regular && !h->def_regular)));

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC || h->needs_plt)
    {
      if (!info->shared && !h->def_dynamic && !h->ref_dynamic)
	{
	  /* This case can occur if we saw a PLT32 reloc in an input
             file, but the symbol was never referred to by a dynamic
             object.  In such a case, we don't actually need to build
             a procedure linkage table, and we can just do a PC32
             reloc instead.  */
	  BFD_ASSERT (h->needs_plt);
	  return TRUE;
	}

      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
          || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (s->size == 0)
	{
	  s->size += 2 *PLT_ENTRY_SIZE;
	  BFD_DEBUG_PIC (fprintf (stderr, "first plt entry at %d\n", s->size));
	}
      else
	{
	  BFD_DEBUG_PIC (fprintf (stderr, "Next plt entry at %d\n", (int)s->size));
	}
  
      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.  This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (!info->shared && !h->def_regular)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = s->size;
	}

      h->plt.offset = s->size;

      /* Make room for this entry.  */
      s->size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */

      s = bfd_get_section_by_name (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->size += 4;

      /* We also need to make an entry in the .rela.plt section.  */
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->size += sizeof (Elf32_External_Rela);

      return TRUE;
	}
      else
 	{
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	  return TRUE;
	}
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  s = bfd_get_section_by_name (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);

  /* We must generate a R_ARC_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      asection *srel;

      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf32_External_Rela);
      h->needs_copy = 1;
    }

  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf_arc_size_dynamic_sections (bfd *output_bfd, 
                               struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd_boolean reltext;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      struct elf_link_hash_entry *h;
      
      /* Set the contents of the .interp section to the interpreter.  */
      if (! info->shared)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}

      /* Add some entries to the .dynamic section.  We fill in some of the
	 values later, in elf_bfd_final_link, but we must add the entries
	 now so that we know the final size of the .dynamic section.  */
      /* Checking if the .init section is present. We also create DT_INIT / DT_FINE
       * entries if the init_str has been changed by the user 
       */
      h =  elf_link_hash_lookup (elf_hash_table (info), "init", FALSE,
				FALSE, FALSE);
      if ((h != NULL
	   && (h->ref_regular || h->def_regular))
	  || (strcmp (init_str, INIT_SYM_STRING) != 0))	      
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_INIT, 0))
		return FALSE;
	}
      h =  elf_link_hash_lookup (elf_hash_table (info), "fini", FALSE,
				 FALSE, FALSE);
      if ((h != NULL
	   && (h->ref_regular || h->def_regular))
	  || (strcmp (fini_str, FINI_SYM_STRING) != 0))	      
		      
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_FINI, 0))
		return FALSE;
	}

    }
  else
    {
      /* We may have created entries in the .rela.got section.
         However, if we are not creating the dynamic sections, we will
         not actually use these entries.  Reset the size of .rela.got,
         which will cause it to get stripped from the output file
         below.  */
      s = bfd_get_section_by_name (dynobj, ".rela.got");
      if (s != NULL)
	s->size = 0;
    }

  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared && info->symbolic)
    elf_ARC_link_hash_traverse (elf_ARC_hash_table (info),
				 elf_ARC_discard_copies,
				 (void *) NULL);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = FALSE;
  relocs = FALSE;
  reltext = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      bfd_boolean strip;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      strip = FALSE;

      if (strcmp (name, ".plt") == 0)
	{
	  if (s->size == 0)
	    {
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = TRUE;
	    }
	}
      else if (strncmp (name, ".rela", 5) == 0)
	{
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rela.bss and
		 .rela.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = TRUE;
	    }
	  else
	    {
	      asection *target;

	      /* Remember whether there are any reloc sections other
                 than .rela.plt.  */
	      if (strcmp (name, ".rela.plt") != 0)
		{
		  const char *outname;

		  relocs = TRUE;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  The entries in the .rela.plt section
		     really apply to the .got section, which we
		     created ourselves and so know is not readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 4);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = TRUE;
		}

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (strncmp (name, ".got", 4) != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (strip)
	{
          s->flags |= SEC_EXCLUDE;
	  continue;
	}

      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_arc_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (! info->shared)
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_DEBUG, 0))
		return FALSE;
	}

      if (plt)
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0)
		|| ! _bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)
		|| ! _bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
		|| ! _bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))
		return FALSE;
	}

      if (relocs)
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_RELA, 0)
		|| ! _bfd_elf_add_dynamic_entry (info, DT_RELASZ, 0)
		|| ! _bfd_elf_add_dynamic_entry (info, DT_RELENT,
						  sizeof (Elf32_External_Rela)))
		return FALSE;
	}

      if (reltext)
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_TEXTREL, 0))
		return FALSE;
	}
    }

  return TRUE;
}

#define TARGET_LITTLE_SYM	bfd_elf32_littlearc_vec
#define TARGET_LITTLE_NAME	"elf32-littlearc"
#define TARGET_BIG_SYM		bfd_elf32_bigarc_vec
#define TARGET_BIG_NAME		"elf32-bigarc"
#define ELF_ARCH		bfd_arch_arc
#define ELF_MACHINE_CODE	EM_ARC
#define ELF_MACHINE_ALT1	EM_ARCOMPACT
#define ELF_MAXPAGESIZE		0x1000

#define elf_info_to_howto                    arc_info_to_howto_rel
#define elf_info_to_howto_rel                arc_info_to_howto_rel
#define bfd_elf32_bfd_merge_private_bfd_data arc_elf_merge_private_bfd_data
#define bfd_elf32_bfd_reloc_type_lookup      arc_elf32_bfd_reloc_type_lookup

#define elf_backend_object_p                 arc_elf_object_p
#define elf_backend_final_write_processing   arc_elf_final_write_processing
#define elf_backend_relocate_section         elf_arc_relocate_section
#define elf_backend_check_relocs             elf_arc_check_relocs
#define elf_backend_adjust_dynamic_symbol    elf_arc_adjust_dynamic_symbol

#define elf_backend_finish_dynamic_sections  elf_arc_finish_dynamic_sections

#define elf_backend_finish_dynamic_symbol    elf_arc_finish_dynamic_symbol

#define elf_backend_create_dynamic_sections  _bfd_elf_create_dynamic_sections

#define elf_backend_size_dynamic_sections    elf_arc_size_dynamic_sections

#define elf_backend_want_got_plt 1
#define elf_backend_plt_readonly 1
#define elf_backend_want_plt_sym 0
#define elf_backend_got_header_size 12
@


1.20.22.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@a5 7
   Sources derived from work done by Sankhya Technologies (www.sankhya.com)

   Cleaned up , Comments and Position Independent Code support added by
   Saurabh Verma (saurabh.verma@@codito.com)
   Ramana Radhakrishnan(ramana.radhakrishnan@@codito.com)


d28 4
d33 1
a33 14
  /* ****************************************************************
   * NOTE: The pic related work starts after the comment marked as 
   * ~~~~~~        "* PIC-related routines for the arc backend "
   * ****************************************************************/
#define BFD_DEBUG_PIC(x)
  
/* #define BFD_DEBUG_PIC(x) (fprintf(stderr,"DEBUG: %d@@%s: ", \
   __LINE__,__PRETTY_FUNCTION__),x) */

/* We must define USE_RELA to get the proper fixups for PC relative
   branches to symbols defined in other object files. The addend is
   used to account for the PC having been incremented before the PC
   relative address is calculated. mlm */
#define USE_RELA
a34 1
/* Handle PC relative relocation */
d36 19
a54 21
arc_elf_b22_pcrel (bfd *abfd ATTRIBUTE_UNUSED,
		   arelent *reloc_entry,
		   asymbol *symbol,
		   void *data ATTRIBUTE_UNUSED,
		   asection *input_section,
		   bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
{
  /* If incremental linking, update the address of the relocation with the
     section offset */


  if (output_bfd != (bfd *) NULL)
    {
      reloc_entry->address += input_section->output_offset;
      if ((symbol->flags & BSF_SECTION_SYM) && symbol->section)
	reloc_entry->addend
	  += ((**(reloc_entry->sym_ptr_ptr)).section)->output_offset;
      return bfd_reloc_ok;
    }
  return bfd_reloc_continue;
a56 205
#define bfd_put32(a,b,c)
static bfd_vma bfd_get_32_me (bfd *, const unsigned char *);
static void bfd_put_32_me (bfd *, bfd_vma, unsigned char *);


static bfd_reloc_status_type arcompact_elf_me_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type arc_unsupported_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_boolean arc_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
static reloc_howto_type * arc_elf_calculate_howto_index
  (enum elf_arc_reloc_type r_type);


#define INIT_SYM_STRING "init"
#define FINI_SYM_STRING "fini"

/* The default symbols representing the init and fini dyn values */
char * init_str = INIT_SYM_STRING;
char * fini_str = FINI_SYM_STRING;

/* The ARC linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */
#define bfd_elf32_bfd_link_hash_table_create \
					elf_ARC_link_hash_table_create

struct elf_ARC_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf_ARC_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
  bfd_size_type count;
};

/* ARC ELF linker hash entry.  */

struct elf_ARC_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* Number of PC relative relocs copied for this symbol.  */
  struct elf_ARC_pcrel_relocs_copied *pcrel_relocs_copied;
};

/* ARC ELF linker hash table.  */

struct elf_ARC_link_hash_table
{
  struct elf_link_hash_table root;
};

/* Declare this now that the above structures are defined.  */

static bfd_boolean elf_ARC_discard_copies
  (struct elf_ARC_link_hash_entry *, void *);

/* Traverse an ARC ELF linker hash table.  */

#define elf_ARC_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\
    (info)))

/* Get the ARC ELF linker hash table from a link_info structure.  */

#define elf_ARC_hash_table(p) \
  ((struct elf_ARC_link_hash_table *) ((p)->hash))

/* Create an entry in an ARC ELF linker hash table.  */

static struct bfd_hash_entry *
elf_ARC_link_hash_newfunc (struct bfd_hash_entry *entry, 
                           struct bfd_hash_table *table, 
                           const char *string)
{
  struct elf_ARC_link_hash_entry *ret =
    (struct elf_ARC_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct elf_ARC_link_hash_entry *) NULL)
    ret = ((struct elf_ARC_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf_ARC_link_hash_entry)));
  if (ret == (struct elf_ARC_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf_ARC_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct elf_ARC_link_hash_entry *) NULL)
    {
      ret->pcrel_relocs_copied = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create an ARC ELF linker hash table.  */

static struct bfd_link_hash_table *
elf_ARC_link_hash_table_create (bfd * abfd)
{
  struct elf_ARC_link_hash_table *ret;

  ret = ((struct elf_ARC_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf_ARC_link_hash_table)));
  if (ret == (struct elf_ARC_link_hash_table *) NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       elf_ARC_link_hash_newfunc,
				       sizeof (struct elf_ARC_link_hash_entry)))
    {
      bfd_release (abfd, ret);
      return NULL;
    }

  return &ret->root.root;
}

/* This function is called via elf_ARC_link_hash_traverse if we are
   creating a shared object with -Bsymbolic.  It discards the space
   allocated to copy PC relative relocs against symbols which are
   defined in regular objects.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.  */

/*ARGSUSED*/
static bfd_boolean
elf_ARC_discard_copies (struct elf_ARC_link_hash_entry * h,
                        void *ignore ATTRIBUTE_UNUSED)
{
  struct elf_ARC_pcrel_relocs_copied *s;
  
  /* We only discard relocs for symbols defined in a regular object.  */
  if (!h->root.def_regular)
    return TRUE;

  for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
    s->section->size -= 
      s->count * sizeof (Elf32_External_Rela); /* relA */

  return TRUE;
}

/* The HOWTO Array needs to be specified as follows. 
   HOWTO
   {
    type        --- > Relocation Type
    rightshift  --- > Rightshift the value by this amount.
    size        --- > Size 0- byte , 1-short, 2 -long
    bitsize     --- > Exact bitsize. 
    pcrel       --- > PC Relative reloc.
    bitpos      --- > Bit Position. 
    complain_on_overflow ---> What complaint on overflow. 
    function    --- > Any special function to be used . 
    name        --- > Relocation Name.
    partial_inplace--> Addend sits partially in place and in 
                       Reloc Table.
    srcmask       ---> Source Mask 0 for RELA and corresponding 
                       field if USE_REL or partial_inplace
		       is set. 
    dstmask       ---> Destination Mask . Destination field mask.
    pcreloffset   ---> pcrel offset . If a PCREL reloc is created
                       and the assembler leaves an offset in here. 
		       
   }
   If in the backend you need to access the howto array, please
   use the arc_elf_calculate_howto_index function.  All changes in 
   the HOWTO array need a corresponding change in the above mentioned 
   function. The need for this function is the presence of a hole 
   in the ARC ABI. 
*/

#define ARC_RELA_HOWTO(type,rightshift,size,bitsz,pcrel,bitpos , \
function,name,dstmask) \
          \
                       HOWTO( type,rightshift,size,bitsz,pcrel,bitpos,   \
                              complain_overflow_bitfield,function, \
                              name,FALSE,0,dstmask,FALSE)

#define ARCOMPACT_RELA_HOWTO(type,rightshift,size,bitsz,pcrel,bitpos, \
                       function,name,dstmask) \
          \
                       HOWTO( type,rightshift,size,bitsz,pcrel,bitpos,   \
                              complain_overflow_signed,function, \
                              name,FALSE,0,dstmask,FALSE)



#define ARC_UNSUPPORTED_HOWTO(type,name)  \
 ARC_RELA_HOWTO (type ,0 ,2 ,32,FALSE,0,arc_unsupported_reloc,name,0)


d60 14
a73 8
  ARC_RELA_HOWTO (R_ARC_NONE ,0 ,2 ,32,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_NONE",0),
  ARC_RELA_HOWTO (R_ARC_8    ,0 ,0 , 8,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_8" ,0xff),
  ARC_RELA_HOWTO (R_ARC_16   ,0 ,1 ,16,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_16",0xffff),
  ARC_RELA_HOWTO (R_ARC_24   ,0 ,2 ,24,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_24",0xffffff),
d75 14
a88 2
  ARC_RELA_HOWTO (R_ARC_32   ,0 ,2 ,32,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_32",-1),
d90 14
a103 2
  ARC_RELA_HOWTO (R_ARC_B26  ,2 ,2 ,26,FALSE,0,bfd_elf_generic_reloc,
                  "R_ARC_B26",0xffffff),
d105 13
a117 182
  ARC_RELA_HOWTO (R_ARC_B22_PCREL,2,2,22,TRUE,7,arc_elf_b22_pcrel,
                  "R_ARC_B22_PCREL",0x7ffff80),
  ARC_RELA_HOWTO (R_ARC_H30 ,2 ,2 ,32, FALSE, 0, bfd_elf_generic_reloc,
                  "R_ARC_H30",-1),
  ARC_UNSUPPORTED_HOWTO(R_ARC_N8,"R_ARC_N8"),
  ARC_UNSUPPORTED_HOWTO(R_ARC_N16,"R_ARC_N16"),
  ARC_UNSUPPORTED_HOWTO(R_ARC_N24,"R_ARC_N24"),
  ARC_UNSUPPORTED_HOWTO(R_ARC_N32,"R_ARC_N32"),
  ARC_UNSUPPORTED_HOWTO(R_ARC_SDA,"R_ARC_SDA"),
  ARC_UNSUPPORTED_HOWTO(R_ARC_SECTOFF,"R_ARC_SECTOFF"),

  /* FIXME: Change complaint to complain_overflow_signed.  */
  /* Tangent-A5 relocations.  */
  ARCOMPACT_RELA_HOWTO (R_ARC_S21H_PCREL,1,2,21,TRUE,0,arcompact_elf_me_reloc,
                  "R_ARC_S21H_PCREL",0x7feffc0),
  ARCOMPACT_RELA_HOWTO (R_ARC_S21W_PCREL,2,2,21,TRUE,0,arcompact_elf_me_reloc,
                  "R_ARC_S21W_PCREL",0x7fcffc0),
  ARCOMPACT_RELA_HOWTO (R_ARC_S25H_PCREL,1,2,25,TRUE,0,arcompact_elf_me_reloc,
                  "R_ARC_S25H_PCREL",0x7feffcf),
  ARCOMPACT_RELA_HOWTO (R_ARC_S25W_PCREL,2,2,25,TRUE,0,arcompact_elf_me_reloc,
                        "R_ARC_S25W_PCREL",0x7fcffcf),

  ARCOMPACT_RELA_HOWTO (R_ARC_SDA32,0,2,32,FALSE,0,arcompact_elf_me_reloc,
                        "R_ARC_SDA32",-1),
  ARCOMPACT_RELA_HOWTO (R_ARC_SDA_LDST,0,2,9,FALSE,15,arcompact_elf_me_reloc,
                        "R_ARC_SDA_LDST",0x00ff8000),
  ARCOMPACT_RELA_HOWTO (R_ARC_SDA_LDST1,1,2,10,FALSE,15,arcompact_elf_me_reloc,
                        "R_ARC_SDA_LDST1",0x00ff8000),
  ARCOMPACT_RELA_HOWTO (R_ARC_SDA_LDST2,2,2,11,FALSE,15,arcompact_elf_me_reloc,
                        "R_ARC_SDA_LDST2",0x00ff8000),

  ARCOMPACT_RELA_HOWTO (R_ARC_SDA16_LD,0,2,9,FALSE,0,arcompact_elf_me_reloc,
                        "R_ARC_SDA16_LD",0x01ff),
  ARCOMPACT_RELA_HOWTO (R_ARC_SDA16_LD1,1,2,10,FALSE,0,arcompact_elf_me_reloc,
                        "R_ARC_SDA16_LD1",0x01ff),
  ARCOMPACT_RELA_HOWTO (R_ARC_SDA16_LD2,2,2,11,FALSE,0,arcompact_elf_me_reloc,
                        "R_ARC_SDA16_LD2",0x01ff),

  ARCOMPACT_RELA_HOWTO (R_ARC_S13_PCREL,2,1,13,TRUE,0,arcompact_elf_me_reloc,
                        "R_ARC_S13_PCREL",0x7ff),

  ARC_UNSUPPORTED_HOWTO (R_ARC_W,"R_ARC_W"),

/* 'Middle-endian' (ME) 32-bit word relocations, stored in two half-words.
   The individual half-words are stored in the native endian of the
   machine; this is how all 32-bit instructions and long-words are stored
   in the ARCompact ISA in the executable section.  */

  ARC_RELA_HOWTO (R_ARC_32_ME ,0 ,2 ,32, FALSE, 0, arcompact_elf_me_reloc,
                  "R_ARC_32_ME",-1),
  
  ARC_UNSUPPORTED_HOWTO (R_ARC_N32_ME,"R_ARC_N32_ME"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_ME,"R_ARC_SECTOFF_ME"),

  ARCOMPACT_RELA_HOWTO (R_ARC_SDA32_ME,0,2,32,FALSE,0,arcompact_elf_me_reloc,
                        "R_ARC_SDA32_ME",-1),

  ARC_UNSUPPORTED_HOWTO (R_ARC_W_ME,"R_ARC_W_ME"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_H30_ME,"R_ARC_H30_ME"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_U8,"R_ARC_SECTOFF_U8"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_S9,"R_ARC_SECTOFF_S9"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_U8,"R_AC_SECTOFF_U8"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_U8_1,"R_AC_SECTOFF_U8_1"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_U8_2,"R_ARC_SECTOFF_U8_2"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_S9,"R_AC_SECTOFF_S9"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_S9_1,"R_AC_SECTOFF_S9_1"),
  ARC_UNSUPPORTED_HOWTO (R_AC_SECTOFF_S9_2,"R_AC_SECTOFF_S9_2"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_ME_1,"R_ARC_SECTOFF_ME_1"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_ME_2,"R_ARC_SECTOFF_ME_2"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_1,"R_ARC_SECTOFF_1"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SECTOFF_2,"R_ARC_SECTOFF_2"),
  /* There is a gap here of 5.  */
  #define R_ARC_hole_base 0x2d
  #define R_ARC_reloc_hole_gap 5

  ARC_RELA_HOWTO (R_ARC_PC32, 0, 2, 32, FALSE, 0, arcompact_elf_me_reloc,
                  "R_ARC_PC32",-1),
  /* PC relative was true for this earlier. */
  ARC_RELA_HOWTO (R_ARC_GOTPC32, 0, 2, 32, FALSE, 0, arcompact_elf_me_reloc,
                  "R_ARC_GOTPC32",-1),

  ARC_RELA_HOWTO (R_ARC_PLT32, 0, 2, 32, FALSE, 0, arcompact_elf_me_reloc,
                  "R_ARC_PLT32",-1),

  ARC_RELA_HOWTO (R_ARC_COPY, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_COPY",-1),

  ARC_RELA_HOWTO (R_ARC_GLOB_DAT, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_GLOB_DAT",-1),

  ARC_RELA_HOWTO (R_ARC_JMP_SLOT, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_JMP_SLOT",-1),

  ARC_RELA_HOWTO (R_ARC_RELATIVE, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_RELATIVE",-1),

  ARC_RELA_HOWTO (R_ARC_GOTOFF, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_GOTOFF",-1),

  ARC_RELA_HOWTO (R_ARC_GOTPC, 0, 2, 32, FALSE,0 , arcompact_elf_me_reloc,
                  "R_ARC_GOTPC",-1),
};

/*Indicates whether the value contained in
  the relocation type is signed, usnigned
  or the reclocation type is unsupported.
  0 -> unsigned reloc type
  1 -> signed reloc type
  -1 -> reloc type unsupported*/
short arc_signed_reloc_type[] =
{
  0, // R_ARC_NONE              Reloc Number
  0, // R_ARC_8
  0, // R_ARC_16
  0, // R_ARC_24
  0, // R_ARC_32
  0, // R_ARC_B26
  1, // R_ARC_B22_PCREL          0x6

  0, // R_ARC_H30                0x7
 -1, // R_ARC_N8
 -1, // R_ARC_N16
 -1, // R_ARC_N24
 -1, // R_ARC_N32
 -1, // R_ARC_SDA
 -1, // R_ARC_SECTOFF            0xD

  1, // R_ARC_S21H_PCREL         0xE
  1, // R_ARC_S21W_PCREL
  1, // R_ARC_S25H_PCREL
  1, // R_ARC_S25W_PCREL         0x11

  1, // R_ARC_SDA32              0x12
  1, // R_ARC_SDA_LDST
  1, // R_ARC_SDA_LDST1
  1, // R_ARC_SDA_LDST2          0x15

  1, // R_ARC_SDA16_LD           0x16
  1, // R_ARC_SDA16_LD1
  1, // R_ARC_SDA16_LD2          0x18

  1, // R_ARC_S13_PCREL          0x19

  -1, // R_ARC_W                 0x1A
  0, // R_ARC_32_ME              0x1B
  
  -1, // R_ARC_N32_ME            0x1c
  -1, // R_ARC_SECTOFF_ME        0x1D

  0, // R_ARC_SDA32_ME           0x1E

  -1, // R_ARC_W_ME              0x1F
  -1, // R_ARC_H30_ME
  -1, // R_ARC_SECTOFF_U8
  -1, // R_ARC_SECTOFF_S9
  -1, // R_AC_SECTOFF_U8
  -1, // R_AC_SECTOFF_U8_1
  -1, // R_AC_SECTOFF_U8_2
  -1, // R_AC_SECTOFF_S9
  -1, // R_AC_SECTOFF_S9_1
  -1, // R_AC_SECTOFF_S9_2
  -1, // R_ARC_SECTOFF_ME_1
  -1, // R_ARC_SECTOFF_ME_2
  -1, // R_ARC_SECTOFF_1
  -1, // R_ARC_SECTOFF_2         0x2c

  -1, // R_ARC_hole_base starts here 0x2d
  -1, // 0x2e
  -1, // 0x2f
  -1, // 0x30
  -1, // ends here               0x31

  0, //  R_ARC_PC32              0x32
  0, //  R_ARC_GOTPC32
  0, //  R_ARC_PLT32
  0, //  R_ARC_COPY
  0, //  R_ARC_GLOB_DAT
  0, //  R_ARC_JMP_SLOT
  0, //  R_ARC_RELATIVE
  0, //  R_ARC_GOTOFF
  0, //  R_ARC_GOTPC             0x3a
  0, //  R_ARC_GOT32             0x3b
a119 16


static bfd_reloc_status_type 
arc_unsupported_reloc (bfd * ibfd ATTRIBUTE_UNUSED, 
		       arelent * rel ATTRIBUTE_UNUSED,
		       asymbol * sym ATTRIBUTE_UNUSED, 
		       void *ptr ATTRIBUTE_UNUSED,
		       asection * section ATTRIBUTE_UNUSED, 
		       bfd *obfd ATTRIBUTE_UNUSED, 
		       char ** data ATTRIBUTE_UNUSED
		       )
{
  return bfd_reloc_notsupported;
}


d124 2
a125 2
    enum bfd_reloc_code_real bfd_reloc_val;
    enum elf_arc_reloc_type elf_reloc_val;
d130 1
a130 4
  { BFD_RELOC_NONE, R_ARC_NONE },
  { BFD_RELOC_8, R_ARC_8 },
  { BFD_RELOC_16,R_ARC_16 },
  { BFD_RELOC_24, R_ARC_24 },
a134 24
  { BFD_RELOC_ARC_S21H_PCREL, R_ARC_S21H_PCREL },
  { BFD_RELOC_ARC_S21W_PCREL, R_ARC_S21W_PCREL },
  { BFD_RELOC_ARC_S25H_PCREL, R_ARC_S25H_PCREL },
  { BFD_RELOC_ARC_S25W_PCREL, R_ARC_S25W_PCREL },
  { BFD_RELOC_ARC_S13_PCREL, R_ARC_S13_PCREL },
  { BFD_RELOC_ARC_32_ME, R_ARC_32_ME },
  { BFD_RELOC_ARC_PC32, R_ARC_PC32 },
  { BFD_RELOC_ARC_GOTPC32, R_ARC_GOTPC32 },
  { BFD_RELOC_ARC_COPY , R_ARC_COPY },
  { BFD_RELOC_ARC_JMP_SLOT, R_ARC_JMP_SLOT },
  { BFD_RELOC_ARC_GLOB_DAT, R_ARC_GLOB_DAT },
  { BFD_RELOC_ARC_GOTOFF , R_ARC_GOTOFF },
  { BFD_RELOC_ARC_GOTPC , R_ARC_GOTPC },
  { BFD_RELOC_ARC_PLT32 , R_ARC_PLT32 },

  { BFD_RELOC_ARC_SDA, R_ARC_SDA },
  { BFD_RELOC_ARC_SDA32, R_ARC_SDA32 },
  { BFD_RELOC_ARC_SDA32_ME, R_ARC_SDA32_ME },
  { BFD_RELOC_ARC_SDA_LDST, R_ARC_SDA_LDST },
  { BFD_RELOC_ARC_SDA_LDST1, R_ARC_SDA_LDST1 },
  { BFD_RELOC_ARC_SDA_LDST2, R_ARC_SDA_LDST2 },
  { BFD_RELOC_ARC_SDA16_LD, R_ARC_SDA16_LD },
  { BFD_RELOC_ARC_SDA16_LD1, R_ARC_SDA16_LD1 },
  { BFD_RELOC_ARC_SDA16_LD2, R_ARC_SDA16_LD2 }
d138 1
a138 1
arc_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
d142 4
a145 11
  for (i = 0;
       i < sizeof (arc_reloc_map) / sizeof (struct arc_reloc_map);
       i++)
    {
      if (arc_reloc_map[i].bfd_reloc_val == code)
        { 
          enum elf_arc_reloc_type r_type;
          r_type = arc_reloc_map[i].elf_reloc_val;
          return arc_elf_calculate_howto_index(r_type);
        }
    }
a165 13
/* Calculate the howto index.  */
static reloc_howto_type * 
arc_elf_calculate_howto_index(enum elf_arc_reloc_type r_type)
{
  BFD_ASSERT (r_type < (unsigned int) R_ARC_max);
  BFD_ASSERT ((r_type < (unsigned int) R_ARC_hole_base)
	      || (r_type
		  >= (unsigned int) R_ARC_hole_base + R_ARC_reloc_hole_gap));
  if (r_type > R_ARC_hole_base)
    r_type -= R_ARC_reloc_hole_gap;
  return &elf_arc_howto_table[r_type];

}
d173 1
a173 2
  enum elf_arc_reloc_type r_type;

d176 2
a177 54
  cache_ptr->howto = arc_elf_calculate_howto_index(r_type);
}
 
/* Merge backend specific data from an object file to the output
   object file when linking.  */
static bfd_boolean
arc_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  unsigned short mach_ibfd;
  static unsigned short mach_obfd = EM_NONE;
  
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
	 || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;
  if (bfd_count_sections (ibfd) == 0)
    return TRUE ; /* For the case of empty archive files */
  
  mach_ibfd = elf_elfheader (ibfd)->e_machine;

   /* Check if we have the same endianess.  */
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    {
      _bfd_error_handler (_("\
ERROR: Endian Match failed . Attempting to link %B with binary %s \
of opposite endian-ness"),
			  ibfd, bfd_get_filename (obfd));
      return FALSE;
    }

  if (mach_obfd == EM_NONE)
    {
      mach_obfd = mach_ibfd;
    }
  else
    {
      if((mach_ibfd==EM_ARC && mach_obfd==EM_ARCOMPACT) ||
	 (mach_ibfd==EM_ARCOMPACT && mach_obfd==EM_ARC))
	{
	  _bfd_error_handler (_("\ERROR: Attempting to link an %s binary(%B) \
with a binary incompatible %s binary(%s)"),
			      (mach_ibfd == EM_ARC) ? "A4" : "ARCompact",
			      ibfd,
			      (mach_obfd == EM_ARC) ? "A4" : "ARCompact",
			      bfd_get_filename (obfd));
	  return FALSE;
	}
    }
  
  if (bfd_get_mach (obfd) < bfd_get_mach (ibfd))
    {
      return bfd_set_arch_mach (obfd, bfd_arch_arc, bfd_get_mach(ibfd));
    }
  
  return TRUE;
d185 1
a185 2
  int mach;
  unsigned long arch = elf_elfheader (abfd)->e_flags & EF_ARC_MACH;
d187 1
a187 1
  switch (arch)
d189 18
a206 15
    case E_ARC_MACH_A4:
      mach = bfd_mach_arc_a4;
      break;
    case E_ARC_MACH_A5:
      mach = bfd_mach_arc_a5;
      break;
    case E_ARC_MACH_ARC600:
      mach = bfd_mach_arc_arc600;
      break;
    case E_ARC_MACH_ARC700:
      mach = bfd_mach_arc_arc700;
      break;
    default:
      /* Unknown cpu type.  ??? What to do?  */
      return FALSE;
d208 1
a208 3

  (void) bfd_default_set_arch_mach (abfd, bfd_arch_arc, mach);
  return TRUE;
a217 1
  int mach;
d220 1
a220 1
  switch (mach = bfd_get_mach (abfd))
d222 2
a223 3
    case bfd_mach_arc_a4:
      val = E_ARC_MACH_A4;
      elf_elfheader (abfd)->e_machine = EM_ARC;
d225 3
a227 3
    case bfd_mach_arc_a5:
      val = E_ARC_MACH_A5;
      elf_elfheader (abfd)->e_machine = EM_ARCOMPACT;
d229 2
a230 3
    case bfd_mach_arc_arc600:
      val = E_ARC_MACH_ARC600;
      elf_elfheader (abfd)->e_machine = EM_ARCOMPACT;
d232 2
a233 3
    case bfd_mach_arc_arc700:
      val = E_ARC_MACH_ARC700;
      elf_elfheader (abfd)->e_machine = EM_ARCOMPACT;
a234 2
    default:
      abort();
a235 1

d240 12
a251 2434
/* Handle an ARCompact 'middle-endian' relocation.  */
static bfd_reloc_status_type
arcompact_elf_me_reloc (bfd *abfd , 
                        arelent *reloc_entry,
                        asymbol *symbol_in,
                        void *data, 
                        asection *input_section,
                        bfd *output_bfd,
                        char ** error_message ATTRIBUTE_UNUSED)
{
  unsigned long insn;
#ifdef USE_REL
  unsigned long offset
#endif
  bfd_vma sym_value;
  enum elf_arc_reloc_type r_type;
  bfd_vma addr = reloc_entry->address;
  bfd_byte *hit_data = addr + (bfd_byte *) data;

  r_type = reloc_entry->howto->type;

  if (output_bfd != NULL)
    {
      reloc_entry->address += input_section->output_offset;

      /* In case of relocateable link and if the reloc is against a
         section symbol, the addend needs to be adjusted according to
         where the section symbol winds up in the output section.  */ 

      if ((symbol_in->flags & BSF_SECTION_SYM) && symbol_in->section)
        reloc_entry->addend += symbol_in->section->output_offset;

      return bfd_reloc_ok;
    }

  /* Return an error if the symbol is not defined. An undefined weak
     symbol is considered to have a value of zero (SVR4 ABI, p. 4-27). */ 

  if (symbol_in != NULL && bfd_is_und_section (symbol_in->section) 
      && ((symbol_in->flags & BSF_WEAK) == 0))
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol_in->section))
    sym_value = 0;
  else
    sym_value = (symbol_in->value
                 + symbol_in->section->output_section->vma
                 + symbol_in->section->output_offset);

  sym_value += reloc_entry->addend;

  if (r_type != R_ARC_32_ME) {
     sym_value -= (input_section->output_section->vma
                + input_section->output_offset);
     sym_value -= (reloc_entry->address & ~0x3);
  }

  insn = bfd_get_32_me(abfd, hit_data);

  switch(r_type)
  {
    case R_ARC_S21H_PCREL:
#ifdef USE_REL
      /* Retrieve the offset from the instruction, if any.  */
      /* Extract the first 10 bits from Position 6 to 15 in insn.  */
      offset = ((insn << 16) >> 22) << 10;

      /* Extract the remaining 10 bits from Position 17 to 26 in insn.  */
      offset |= ((insn << 5) >> 22);

      /* Fill in 1 bit to get the 21 bit Offset Value. */
      offset = offset << 1;

      /* Ramana : No addends remain in place. */
      /* sym_value += offset; */

#endif /* USE_REL.  */
      /* Extract the instruction opcode alone from 'insn'. */
      insn = insn & 0xf801003f;
      insn |= ((((sym_value >> 1) & 0x3ff) << 17)
               | (((sym_value >> 1) & 0xffc00) >> 4));
      break;
    case R_ARC_S21W_PCREL:
#ifdef USE_REL
      /* Retrieve the offset from the instruction, if any */
      /* Extract the first 10 bits from Position 6 to 15 in insn */
      offset = ((insn << 16) >> 22) << 9;

      /* Extract the remaining 9 bits from Position 18 to 26 in insn */
      offset |= ((insn << 5) >> 23);

      /* Fill in 2 bits to get the 25 bit Offset Value */
      offset = offset << 2;

      /* No addends remain in place */
      /*       sym_value += offset; */

#endif /* USE_REL. */
      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf803003f;

      insn |= ((((sym_value >> 2) & 0x1ff) << 18)
               | (((sym_value >> 2) & 0x7fe00) >> 3));
      break;
    case R_ARC_S25H_PCREL:
#ifdef USE_REL
      /* Retrieve the offset from the instruction, if any */
      /* Extract the high 4 bits from Position 0 to 3 in insn */
      offset = ((insn << 28) >> 28) << 10;

      /* Extract the next 10 bits from Position 6 to 15 in insn */
      offset |= ((insn << 16) >> 22);
      offset = offset << 10;

      /* Extract the remaining 10 bits from Position 17 to 26 in insn */
      offset |= ((insn << 5) >> 22);

      /* Fill in 1 bit to get the 25 bit Offset Value */
      offset = offset << 1;

      /* Ramana : No addends remain in place. */
      /* sym_value += offset; */


#endif /* USE_REL. */
      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf8010030;

      insn |= ((((sym_value >> 1) & 0x3ff) << 17)
               | (((sym_value >> 1) & 0xffc00) >> 4)
               | (((sym_value >> 1) & 0xf00000) >> 20));
      break;
    case R_ARC_PLT32:
      break;
    case R_ARC_S25W_PCREL:
#ifdef USE_REL
      /* Retrieve the offset from the instruction, if any */
      /* Extract the high 4 bits from Position 0 to 3 in insn */
      offset = ((insn << 28) >> 28) << 10;

      /* Extract the next 10 bits from Position 6 to 15 in insn */
      offset |= ((insn << 16) >> 22);
      offset = offset << 9;

      /* Extract the remaining 9 bits from Position 18 to 26 in insn */
      offset |= ((insn << 5) >> 23);

      /* Fill in 2 bits to get the 25 bit Offset Value */
      offset = offset << 2;

      /* Ramana : No addends remain in place */
      /*      sym_value += offset; */

#endif    /* USE_REL. */
      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf8030030;

      insn |= ((((sym_value >> 2) & 0x1ff) << 18)
               | (((sym_value >> 2) & 0x7fe00) >> 3)
               | (((sym_value >> 2) & 0x780000) >> 19));
      break;
    case R_ARC_S13_PCREL:
#ifdef USE_REL
      /* Retrieve the offset from the instruction, if any */
      /* Extract the 11 bits from Position 0 to 10 in insn */
      offset = (insn << 5) >> 21;

      /* Fill in 2 bits to get the 13 bit Offset Value */
      offset = offset << 2;

      /* No addends remain in place */
      /*      sym_value += offset; */
#endif
      /* Extract the instruction opcode alone from 'insn' */
      insn = (insn & 0xf800ffff);
     insn |= ((sym_value >> 2) & 0x7ff) << 16;
      break;
  case R_ARC_GOTPC32:
  case R_ARC_32_ME:
      insn = sym_value;
      break;
  default:
    return bfd_reloc_notsupported;
    break;
  }

  /* Middle-Endian Instruction Encoding only for executable code */
  /* FIXME:: I am still not sure about this. Ramana . */
  if (input_section && (input_section->flags & SEC_CODE))
    bfd_put_32_me(abfd, insn, hit_data);
  else
    bfd_put_32(abfd, insn, hit_data);

  return bfd_reloc_ok;
}

static bfd_vma
bfd_get_32_me (bfd * abfd,const unsigned char * data)
{
  bfd_vma value = 0;

  if (bfd_big_endian(abfd)) { 
    value = bfd_get_32 (abfd, data);
  }
  else {
    value = ((bfd_get_8 (abfd, data) & 255) << 16);
    value |= ((bfd_get_8 (abfd, data + 1) & 255) << 24);
    value |= (bfd_get_8 (abfd, data + 2) & 255);
    value |= ((bfd_get_8 (abfd, data + 3) & 255) << 8);
  }
 
  return value;
}
 
static void
bfd_put_32_me (bfd *abfd, bfd_vma value,unsigned char *data)
{
  bfd_put_16 (abfd, (value & 0xffff0000) >> 16, data);
  bfd_put_16 (abfd, value & 0xffff, data + 2);
}


/* ******************************************
 * PIC-related routines for the arc backend 
 * ******************************************/

/* This will be overridden by the interpreter specified in
   the linker specs */
#define ELF_DYNAMIC_INTERPRETER  "/sbin/ld-uClibc.so"

/* size of one plt entry */
#define PLT_ENTRY_SIZE  12

/* The zeroth entry in the absolute plt entry */
static const bfd_byte elf_arc_abs_plt0_entry [2 * PLT_ENTRY_SIZE] = 
  { 
    0x00, 0x16,			/* ld %r11, [0] */
    0x0b, 0x70,
    0x00, 0x00, 
    0x00, 0x00,
    0x00, 0x16,			/* ld %r10, [0] */
    0x0a, 0x70,			/*  */
    0,0,
    0,0,
    0x20, 0x20,			/* j [%r10] */
    0x80, 0x02,			/* ---"---- */
    0x00, 0x00,			/* pad */
    0x00, 0x00			/* pad */
  };

/* Contents of the subsequent entries in the absolute plt */
static const bfd_byte elf_arc_abs_pltn_entry [PLT_ENTRY_SIZE] = 
  { 
    0x30, 0x27,			/* ld %r12, [%pc,func@@gotpc] */
    0x8c, 0x7f,			/* ------ " " -------------- */
    0x00, 0x00,			/* ------ " " -------------- */
    0x00, 0x00,			/* ------ " " -------------- */
    0x20, 0x7c, 		/* j_s.d [%r12]              */ 
    0xef, 0x74,			/* mov_s %r12, %pcl          */
  };

/* The zeroth entry in the pic plt entry */
static const bfd_byte elf_arc_pic_plt0_entry [2 * PLT_ENTRY_SIZE] = 
  { 
    0x30, 0x27,			/* ld %r11, [pcl,0] : 0 to be replaced by _DYNAMIC@@GOTPC+4 */
    0x8b, 0x7f,
    0x00, 0x00, 
    0x00, 0x00,
    0x30, 0x27,			/* ld %r10, [pcl,0] : 0 to be replaced by -DYNAMIC@@GOTPC+8  */
    0x8a, 0x7f,			/*  */
    0,0,
    0,0,
    0x20, 0x20,			/* j [%r10] */
    0x80, 0x02,			/* ---"---- */
    0x00, 0x00,			/* pad */
    0x00, 0x00			/* pad */
  };

/* Contents of the subsequent entries in the pic plt */
static const bfd_byte elf_arc_pic_pltn_entry [PLT_ENTRY_SIZE] = 
  { 
    0x30, 0x27,			/* ld %r12, [%pc,func@@got]   */
    0x8c, 0x7f,			/* ------ " " -------------- */
    0x00, 0x00,			/* ------ " " -------------- */
    0x00, 0x00,			/* ------ " " -------------- */
    0x20, 0x7c, 		/* j_s.d [%r12]              */ 
    0xef, 0x74,			/* mov_s %r12, %pcl          */
  };


/* Function: arc_plugin_one_reloc
 * Brief   : Fill in the relocated value of the symbol into an insn
 *           depending on the relocation type. The instruction is 
 *           assumed to have been read in the correct format (ME / LE/ BE)
 * Args    : 1. insn              : the original insn into which the relocated
 *                                  value has to be filled in.  
 *           2. rel               : the relocation entry.  
 *           3. value             : the value to be plugged in the insn.  
 *           4. overflow_detected : Pointer to short to indicate relocation
 *                                  overflows.
 *           5. symbol_defined    : bool value representing if the symbol
 *                                  definition is present.  
 * Returns : the insn with the relocated value plugged in.
 */
static unsigned long
arc_plugin_one_reloc (unsigned long insn, Elf_Internal_Rela *rel,
                      int value,
                      short *overflow_detected, bfd_boolean symbol_defined
		      )
{
  unsigned long offset;
  long long check_overfl_pos,check_overfl_neg;
  reloc_howto_type *howto;
  enum elf_arc_reloc_type r_type;

  r_type           = ELF32_R_TYPE (rel->r_info);
  howto            = arc_elf_calculate_howto_index(r_type);

  if (arc_signed_reloc_type [howto->type] == 1)
    {
      check_overfl_pos = (long long)1 << (howto->bitsize-1);
      check_overfl_neg = -check_overfl_pos;
      if ((value >= check_overfl_pos) || (check_overfl_neg > value))
	*overflow_detected = 1;
    }
  else
    {
      check_overfl_pos = (long long)1 << (howto->bitsize);
      check_overfl_neg = 0;
      if ((unsigned int) value >= check_overfl_pos)
	*overflow_detected = 1;
    }

    if (*overflow_detected
      && symbol_defined == TRUE)
    {
      (*_bfd_error_handler ) ("Error: Overflow detected in relocation value;");
      if (howto->pc_relative)
	(*_bfd_error_handler) ("Relocation value should be between %lld and %lld whereas it  %d",
			     check_overfl_pos - 1, (signed long long) check_overfl_neg,
			      value);
      else
	(*_bfd_error_handler) ("Relocation value should be between %lld and %lld whereas it  %ld",
			       check_overfl_pos - 1, (signed long long) check_overfl_neg,
			       (unsigned int) value);

      bfd_set_error (bfd_error_bad_value);
      *overflow_detected = 1;
      return 0;
    }
  else
    *overflow_detected = 0;
  
  switch(r_type)
  {
    case R_ARC_B26:
	/* Retrieve the offset from the instruction, if any */
	/* Extract the last 24 bits from Position 0 to 23 in insn */

      offset = insn & 0x00ffffff;
      /* Fill in 2 bit to get the 26 bit Offset Value */
      offset = offset << 2;


      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xff000000;
      /* With the addend now being in the addend table, there is no 
       * need to use this 
       */
      /* Ramana : No longer required since
       * addends no longer exist in place 
       */
      /*      value += offset; */
      insn |= ((value >> 2) & (~0xff000000));
      break;
	
    case R_ARC_B22_PCREL:
	/* Retrieve the offset from the instruction, if any */
	/* Extract the first 10 bits from Position 6 to 15 in insn */
	offset = ((insn << 5) >> 12);
	
	/* Fill in 2 bit to get the 22 bit Offset Value */
	offset = offset << 2;
	
	/* Extract the instruction opcode alone from 'insn' */
	insn = insn & 0xf800007f;
	
	/* Ramana: All addends exist in the relocation table. Ignore
	 *  the in place addend 
	 */
	/*value += offset; */
	
	insn |= ((value >> 2) << 7) & (~0xf800007f);
	
	break;
	
    case R_ARC_S21H_PCREL:
      /* Retrieve the offset from the instruction, if any */
      /* Extract the first 10 bits from Position 6 to 15 in insn */
      offset = ((insn << 16) >> 22) << 10;

      /* Extract the remaining 10 bits from Position 17 to 26 in insn */
      offset |= ((insn << 5) >> 22);

      /* Fill in 1 bit to get the 21 bit Offset Value */
      offset = offset << 1;

      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf801003f;


      
      /* Ramana: All addends exist in the relocation table. Ignore
       *  the in place addend 
       */
      /*value += offset; */
      

      insn |= ((((value >> 1) & 0x3ff) << 17)
               | (((value >> 1) & 0xffc00) >> 4));
      break;
    case R_ARC_S21W_PCREL:
      /* Retrieve the offset from the instruction, if any */
      /* Extract the first 10 bits from Position 6 to 15 in insn */
      offset = ((insn << 16) >> 22) << 9;

      /* Extract the remaining 9 bits from Position 18 to 26 in insn */
      offset |= ((insn << 5) >> 23);

      /* Fill in 2 bits to get the 25 bit Offset Value */
      offset = offset << 2;

      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf803003f;

      /* Ramana: All addends exist in the relocation table. Ignore
       *  the in place addend 
       */
      
      /*value += offset;*/


      insn |= ((((value >> 2) & 0x1ff) << 18)
               | (((value >> 2) & 0x7fe00) >> 3));
      break;
    case R_ARC_S25H_PCREL:
      /* Retrieve the offset from the instruction, if any */
      /* Extract the high 4 bits from Position 0 to 3 in insn */
      offset = ((insn << 28) >> 28) << 10;

      /* Extract the next 10 bits from Position 6 to 15 in insn */
      offset |= ((insn << 16) >> 22);
      offset = offset << 10;

      /* Extract the remaining 10 bits from Position 17 to 26 in insn */
      offset |= ((insn << 5) >> 22);

      /* Fill in 1 bit to get the 25 bit Offset Value */
      offset = offset << 1;

      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf8010030;

      /* Ramana: All addends exist in the relocation table. Ignore
       *  the in place addend 
       */
      
      /* value += offset; */

      insn |= ((((value >> 1) & 0x3ff) << 17)
               | (((value >> 1) & 0xffc00) >> 4)
               | (((value >> 1) & 0xf00000) >> 20));
      break;
  case R_ARC_PLT32:
    BFD_DEBUG_PIC (fprintf(stderr,"plt for %x value=0x%x\n",insn,value));
    /*
      Relocations of the type R_ARC_PLT32 are for the BLcc
      instructions. However the BL instruction takes a 25-bit relative
      displacement while the BLcc instruction takes a 21-bit relative
      displacement. We are using bit-17 to distinguish between these two
      cases and handle them differently.
    */

    if(insn & 0x00020000) /* Non-conditional */
      {
	insn = insn & 0xf8030030;
	insn |= (((value >> 2) & 0x780000) >> 19);
      }
    else /* Conditional */
      {
	insn = insn & 0xf803003f;
      }
    
    insn |= ((((value >> 2) & 0x1ff) << 18)
	     | (((value >> 2) & 0x7fe00) >> 3));
    break;
  case R_ARC_S25W_PCREL:

       /* Retrieve the offset from the instruction, if any */ 	 
       /* Extract the high 4 bits from Position 0 to 3 in insn */ 	 
       offset = ((insn << 28) >> 28) << 10; 	 
  	 
       /* Extract the next 10 bits from Position 6 to 15 in insn */ 	 
       offset |= ((insn << 16) >> 22); 	 
       offset = offset << 9; 	 
  	 
       /* Extract the remaining 9 bits from Position 18 to 26 in insn */ 	 
       offset |= ((insn << 5) >> 23); 	 
  	 
       /* Fill in 2 bits to get the 25 bit Offset Value */ 	 
       offset = offset << 2;
      /* Extract the instruction opcode alone from 'insn' */
      insn = insn & 0xf8030030;
      /* Ramana: All addends exist in the relocation table. Ignore
       *  the in place addend 
       */
      
      /* value += offset; 	 */

      insn |= ((((value >> 2) & 0x1ff) << 18)
               | (((value >> 2) & 0x7fe00) >> 3)
               | (((value >> 2) & 0x780000) >> 19));
      break;
    case R_ARC_S13_PCREL:
      /* Retrieve the offset from the instruction, if any */
      /* Extract the 11 bits from Position 0 to 10 in insn */
      offset = (insn << 5) >> 21;

      /* Fill in 2 bits to get the 13 bit Offset Value */
      offset = offset << 2;

      /* Extract the instruction opcode alone from 'insn' */
      insn = (insn & 0xf800ffff);

      /* Ramana: All addends exist in the relocation table. Ignore
       *  the in place addend 
       */
      
      /* value += offset; */

      insn |= ((value >> 2) & 0x7ff) << 16;
      break;

  case R_ARC_32:
  case R_ARC_GOTPC:
  case R_ARC_GOTOFF:
  case R_ARC_GOTPC32:
  case R_ARC_32_ME:
      insn = value;
      
  case R_ARC_8:
  case R_ARC_16:
  case R_ARC_24:
    /* One would have to OR the value here since 
       insn would contain the bits read in correctly. */

    
    insn |= value ;
      break;

  case R_ARC_SDA32_ME:
    insn |= value;
    break;
 
  case R_ARC_SDA_LDST2:
    value >>= 1;
  case R_ARC_SDA_LDST1:
    value >>= 1;
  case R_ARC_SDA_LDST:
    value &= 0x1ff;
    insn |= ( ((value & 0xff) << 16)  | ((value >> 8) << 15));
    break;

  case R_ARC_SDA16_LD:
    /* FIXME: The 16-bit insns shd not come in as higher bits of a 32-bit word */
    insn |= (value & 0x1ff) <<16;
    break;

  case R_ARC_SDA16_LD1:
    /* FIXME: The 16-bit insns shd not come in as higher bits of a 32-bit word */
    insn |= ((value >> 1) & 0x1ff ) <<16;
    break;

  case R_ARC_SDA16_LD2:
    /* FIXME: The 16-bit insns shd not come in as higher bits of a 32-bit word */
    insn |= ((value >> 2) & 0x1ff) <<16;
    break;

  default:
    /* FIXME:: This should go away once the HOWTO Array 
       is used for this purpose. 
    */
    fprintf(stderr, "Unsupported reloc used : %s (value = %d)\n", (arc_elf_calculate_howto_index(r_type))->name, value);
    break;
  }
  
  return insn;
}

/* Function : elf_arc_check_relocs
 * Brief    : Check the relocation entries and take any special
 *           actions, depending on the relocation type if needed.
 * Args     : 1. abfd   : The input bfd
 *            2. info   : link information
 *	      3. sec    : section being relocated
 *	      4. relocs : the list of relocations.
 * Returns  : True/False as the return status.
 */
static bfd_boolean
elf_arc_check_relocs (bfd *abfd, 
                      struct bfd_link_info *info, 
                      asection *sec, 
                      const Elf_Internal_Rela *relocs)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *srelgot;
  asection *sreloc;

  if (info->relocatable)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_offsets = elf_local_got_offsets (abfd);

  sgot = NULL;
  srelgot = NULL;
  sreloc = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      BFD_DEBUG_PIC (fprintf(stderr,"Processing reloc #%d in %s\n",
			     rel-relocs,__PRETTY_FUNCTION__));

      r_symndx = ELF32_R_SYM (rel->r_info);

      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];

      /* Some relocs require a global offset table.  */
      if (dynobj == NULL)
	{
	  switch (ELF32_R_TYPE (rel->r_info))
	    {
	    case R_ARC_GOTPC32:
	    case R_ARC_GOTOFF:
	    case R_ARC_GOTPC:
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfd_elf_create_got_section (dynobj, info))
		return FALSE;
	      break;

	    default:
	      break;
	    }
	}

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_ARC_GOTPC32:
	  /* This symbol requires a global offset table entry.  */

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (srelgot == NULL
	      && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot = bfd_make_section (dynobj, ".rela.got");
		  if (srelgot == NULL
		      || ! bfd_set_section_flags (dynobj, srelgot,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY))
		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		    return FALSE;
		}
	    }

	  if (h != NULL)
	    {
	      if (h->got.offset != (bfd_vma) -1)
		{
		  BFD_DEBUG_PIC(fprintf(stderr, "got entry stab entry already done%d\n",r_symndx));

		  /* We have already allocated space in the .got.  */
		  break;
		}


	      h->got.offset = sgot->size;
	      BFD_DEBUG_PIC(fprintf(stderr, "got entry stab entry %d got offset=0x%x\n",r_symndx,
				    h->got.offset));

	      /* Make sure this symbol is output as a dynamic symbol.  */
	      if (h->dynindx == -1)
		{
		  if (! bfd_elf_link_record_dynamic_symbol (info, h))
		    return FALSE;
		}

	      BFD_DEBUG_PIC(fprintf (stderr, "Got raw size increased\n"));
	      srelgot->size += sizeof (Elf32_External_Rela);
	    }
	  else
	    {
     	      /* This is a global offset table entry for a local
                 symbol.  */
	      if (local_got_offsets == NULL)
		{
		  size_t size;
		  register unsigned int i;

		  size = symtab_hdr->sh_info * sizeof (bfd_vma);
		  local_got_offsets = (bfd_vma *) bfd_alloc (abfd, size);
		  if (local_got_offsets == NULL)
		    return FALSE;
		  elf_local_got_offsets (abfd) = local_got_offsets;
		  for (i = 0; i < symtab_hdr->sh_info; i++)
		    local_got_offsets[i] = (bfd_vma) -1;
		}
	      if (local_got_offsets[r_symndx] != (bfd_vma) -1)
		{
		  BFD_DEBUG_PIC(fprintf(stderr, "got entry stab entry already done%d\n",r_symndx));

		  /* We have already allocated space in the .got.  */
		  break;
		}

	      BFD_DEBUG_PIC(fprintf(stderr, "got entry stab entry %d\n",r_symndx));

	      
	      local_got_offsets[r_symndx] = sgot->size;

	      if (info->shared)
		{
		  /* If we are generating a shared object, we need to
                     output a R_ARC_RELATIVE reloc so that the dynamic
                     linker can adjust this GOT entry.  */
		  srelgot->size += sizeof (Elf32_External_Rela);
		}
	    }
	  
	  BFD_DEBUG_PIC(fprintf (stderr, "Got raw size increased\n"));

	  sgot->size += 4;

	  break;

	case R_ARC_PLT32:
	  /* This symbol requires a procedure linkage table entry.  We
             actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code which is
             never referenced by a dynamic object, in which case we
             don't need to generate a procedure linkage table entry
             after all.  */

	  /* If this is a local symbol, we resolve it directly without
             creating a procedure linkage table entry.  */
	  if (h == NULL)
	    continue;

	  h->needs_plt = 1;

	  break;

	case R_ARC_32:
	case R_ARC_32_ME:
	case R_ARC_PC32:
	  /* If we are creating a shared library, and this is a reloc
             against a global symbol, or a non PC relative reloc
             against a local symbol, then we need to copy the reloc
             into the shared library.  However, if we are linking with
             -Bsymbolic, we do not need to copy a reloc against a
             global symbol which is defined in an object we are
             including in the link (i.e., DEF_REGULAR is set).  At
             this point we have not seen all the input files, so it is
             possible that DEF_REGULAR is not set now but will be set
             later (it is never cleared).  We account for that
             possibility below by storing information in the
             pcrel_relocs_copied field of the hash table entry.  */
	  if (info->shared
	      && (ELF32_R_TYPE (rel->r_info) != R_ARC_PC32
		  || (h != NULL
		      && (!info->symbolic || !h->def_regular))))
	    {
	      /* When creating a shared object, we must copy these
                 reloc types into the output file.  We create a reloc
                 section in dynobj and make room for this reloc.  */
	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      sreloc = bfd_make_section (dynobj, name);
		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
			return FALSE;
		    }
		}

	      sreloc->size += sizeof (Elf32_External_Rela);

	      /* If we are linking with -Bsymbolic, and this is a
                 global symbol, we count the number of PC relative
                 relocations we have entered for this symbol, so that
                 we can discard them again if the symbol is later
                 defined by a regular object.  Note that this function
                 is only called if we are using an elf_ARC linker
                 hash table, which means that h is really a pointer to
                 an elf_ARC_link_hash_entry.  */
	      if (h != NULL && info->symbolic
		  && ELF32_R_TYPE (rel->r_info) == R_ARC_PC32)
		{
		  struct elf_ARC_link_hash_entry *eh;
		  struct elf_ARC_pcrel_relocs_copied *p;

		  eh = (struct elf_ARC_link_hash_entry *) h;

		  for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
		    if (p->section == sreloc)
		      break;

		  if (p == NULL)
		    {
		      p = ((struct elf_ARC_pcrel_relocs_copied *)
			   bfd_alloc (dynobj, sizeof *p));
		      if (p == NULL)
			return FALSE;
		      p->next = eh->pcrel_relocs_copied;
		      eh->pcrel_relocs_copied = p;
		      p->section = sreloc;
		      p->count = 0;
		    }

		  ++p->count;
		}
	    }

	  break;

	default:
	  break;
	}

    }

  return TRUE;
}


/* Relocate an arc ELF section.  */
/* Function : elf_arc_relocate_section
 * Brief    : Relocate an arc section, by handling all the relocations
 *           appearing in that section.
 * Args     : output_bfd    : The bfd being written to. 
 *            info          : Link information.
 *            input_bfd     : The input bfd.
 *            input_section : The section being relocated.
 *            contents      : contents of the section being relocated.
 *            relocs        : List of relocations in the section.
 *            local_syms    : is a pointer to the swapped in local symbols.
 *            local_section : is an array giving the section in the input file
 *                            corresponding to the st_shndx field of each 
 *                            local symbol.
 * Returns  :  
 */
static bfd_boolean
elf_arc_relocate_section (bfd *output_bfd, 
                          struct bfd_link_info *info, 
                          bfd *input_bfd, 
                          asection *input_section,
			  bfd_byte * contents, 
                          Elf_Internal_Rela *relocs, 
                          Elf_Internal_Sym *local_syms, 
                          asection **local_sections)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  asection *sgot;
  asection *splt;
  asection *sreloc;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  short overflow_detected=0;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);

  sgot = NULL;
  splt = NULL;
  sreloc = NULL;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      enum elf_arc_reloc_type r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sec;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      bfd_boolean symbol_defined = TRUE;

      /* Distance of the relocation slot in the insn .This value is used for 
	 handling relative relocations. */
      long offset_in_insn = 0;

      /* The insn bytes */
      unsigned long insn;


      r_type = ELF32_R_TYPE (rel->r_info);
      
      if (r_type >= (int) R_ARC_max)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      howto = arc_elf_calculate_howto_index(r_type);

      BFD_DEBUG_PIC (fprintf(stderr,"Reloc type=%s in %s\n",
			     howto->name,
			     __PRETTY_FUNCTION__));

      r_symndx = ELF32_R_SYM (rel->r_info);


      if (info->relocatable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */

	  /* Checks if this is a local symbol 
	   * and thus the reloc might (will??) be against a section symbol.
	   */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];

		  /* for RELA relocs.Just adjust the addend 
		     value in the relocation entry.  */
		  rel->r_addend += sec->output_offset + sym->st_value;

		  BFD_DEBUG_PIC(fprintf (stderr, "local symbols reloc \
(section=%d %s) seen in %s\n", \
					 r_symndx,\
					 local_sections[r_symndx]->name, \
					 __PRETTY_FUNCTION__)); 
		}
	    }

	  continue;
	}

      /* This is a final link.  */
      h = NULL;
      sym = NULL;
      sec = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* This is a local symbol */
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);

	  /* Mergeable section handling */
	  if ((sec->flags & SEC_MERGE)
	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      asection *msec;
	      msec = sec;
	      rel->r_addend = _bfd_elf_rel_local_sym (output_bfd, sym, 
						      &msec, rel->r_addend);
 	      rel->r_addend -= relocation;
	      rel->r_addend += msec->output_section->vma + msec->output_offset;
	    }
	  
	  relocation += rel->r_addend; 
	}
      else
	{
	  /* Global symbols */
	  
	  /* get the symbol's entry in the symtab */
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* if we have encountered a definition for this symbol */
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      if (r_type == R_ARC_GOTPC
		  || (r_type == R_ARC_PLT32
		      && h->plt.offset != (bfd_vma) -1)
		  || (r_type == R_ARC_GOTPC32
		      && elf_hash_table (info)->dynamic_sections_created
		      && (! info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || !h->def_regular))
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || !h->def_regular)
		      && (r_type == R_ARC_32
			  || r_type == R_ARC_PC32)
		      && (input_section->flags & SEC_ALLOC) != 0))
		{
		  /* In these cases, we don't need the relocation
                     value.  We check specially because in some
                     obscure cases sec->output_section will be NULL.  */
		  relocation = 0;
		}
	      else if (sec->output_section == NULL)
		{
		  (*_bfd_error_handler)
		    ("%s: warning: unresolvable relocation against symbol `%s' from %s section",
		     bfd_get_filename (input_bfd), h->root.root.string,
		     bfd_get_section_name (input_bfd, input_section));
		  relocation = 0;
		}
	    else if (0 && r_type == R_ARC_SDA16_LD2) /* FIXME: delete this piece of code */
	      {
		  relocation = (h->root.u.def.value
				+ sec->output_offset);
		  /* add the addend since the arc has RELA relocations */
		  relocation += rel->r_addend;
	      }
	      else
		{
		  relocation = (h->root.u.def.value
				+ sec->output_section->vma
				+ sec->output_offset);
		  /* add the addend since the arc has RELA relocations */
		  relocation += rel->r_addend;
		}
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else if (info->shared && !info->symbolic)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string,
		      input_bfd, input_section, rel->r_offset, TRUE)))
		return FALSE;
	      symbol_defined = FALSE;
	      relocation = 0;
	    }
	}
      BFD_DEBUG_PIC ( fprintf (stderr, "Relocation = %d (%x)\n", relocation, relocation));


      switch (r_type)
	{
	case R_ARC_GOTPC32:
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_DEBUG_PIC (fprintf (stderr, "made got\n"));
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (h != NULL)
	    {
	      bfd_vma off;

	      off = h->got.offset;
	      BFD_ASSERT (off != (bfd_vma) -1);

	      if (! elf_hash_table (info)->dynamic_sections_created
		  || (info->shared
		      && (info->symbolic || h->dynindx == -1)
		      && h->def_regular))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 4, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_32 (output_bfd, relocation,
				  sgot->contents + off);
		      h->got.offset |= 1;
		    }
		}

	      relocation = sgot->output_section->vma + sgot->output_offset + off;
	      BFD_DEBUG_PIC(fprintf(stderr, "OFFSET=0x%x output_offset=%x (1)\n", off, sgot->output_offset));
	    }
	  else
	    {
	      bfd_vma off;

	      BFD_ASSERT (local_got_offsets != NULL
			  && local_got_offsets[r_symndx] != (bfd_vma) -1);

	      off = local_got_offsets[r_symndx];

	      /* The offset must always be a multiple of 4.  We use
                 the least significant bit to record whether we have
                 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_32 (output_bfd, relocation,
			      sgot->contents + off);

		  if (info->shared)
		    {
		      asection *srelgot;
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;		      

		      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
		      BFD_ASSERT (srelgot != NULL);

		      outrel.r_offset = (sgot->output_section->vma
					 + sgot->output_offset
					 + off);
		      /* RELA relocs */
		      outrel.r_addend = 0;

		      outrel.r_info = ELF32_R_INFO (0, R_ARC_RELATIVE);
		      loc = srelgot->contents;
		      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela); /* relA */
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }

		  local_got_offsets[r_symndx] |= 1;
		}

	      relocation = sgot->output_section->vma + sgot->output_offset + off;
	      BFD_DEBUG_PIC(fprintf(stderr, "OFFSET=0x%x (2)\n", off));
	    }

	  BFD_DEBUG_PIC(fprintf(stderr, "RELOCATION =%x\n",relocation));
	  /* the data in GOT32 relocs is 4 bytes into the insn */
	  offset_in_insn = 4;

	  break;

	case R_ARC_GOTOFF:
	  /* Relocation is relative to the start of the global offset
	     table.  */

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  /* Note that sgot->output_offset is not involved in this
	     calculation.  We always want the start of .got.  If we
	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
	     permitted by the ABI, we might have to change this
	     calculation.  */
	  BFD_DEBUG_PIC(fprintf(stderr,"GOTOFF relocation = %x. Subtracting %x\n",relocation, sgot->output_section->vma));
	  relocation -= sgot->output_section->vma;

	  break;

	case R_ARC_GOTPC:
	  /* Use global offset table as symbol value.  */

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  relocation = sgot->output_section->vma;
	  
	  offset_in_insn = 4;
	  break;

	case R_ARC_PLT32:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLT32 reloc again a local symbol directly,
             without using the procedure linkage table.  */
	  if (h == NULL)
	    break;

	  if (h->plt.offset == (bfd_vma) -1)
	    {
	      /* We didn't make a PLT entry for this symbol.  This
                 happens when statically linking PIC code, or when
                 using -Bsymbolic.  */
	      break;
	    }

	  if (splt == NULL)
	    {
	      splt = bfd_get_section_by_name (dynobj, ".plt");
	      BFD_ASSERT (splt != NULL);
	    }

	  relocation = (splt->output_section->vma
			+ splt->output_offset
			+ h->plt.offset);

	  break;

	case R_ARC_32:
	case R_ARC_32_ME:
	case R_ARC_PC32:
	  if (info->shared
	      && (r_type != R_ARC_PC32
		  || (h != NULL
		      && h->dynindx != -1
		      && (!info->symbolic || !h->def_regular))))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip, relocate;
	      bfd_byte *loc;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);

		  BFD_ASSERT (sreloc != NULL);
		}

	      skip = FALSE;

	      outrel.r_offset = _bfd_elf_section_offset (output_bfd, 
							 info, 
							 input_section,
							 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1)
		  skip = TRUE;
	      	      
	      outrel.r_addend = 0;
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);

	      if (skip)
		{
		  memset (&outrel, 0, sizeof outrel);
		  relocate = FALSE;
		}
	      else if (r_type == R_ARC_PC32)
		{
		  BFD_ASSERT (h != NULL && h->dynindx != -1);
		  if ((input_section->flags & SEC_ALLOC) != 0)
		    relocate = FALSE;
		  else
		    relocate = TRUE;
		  outrel.r_info = ELF32_R_INFO (h->dynindx, R_ARC_PC32);
		}
	      else
		{
		  /* h->dynindx may be -1 if this symbol was marked to
                     become local.  */
		  if (h == NULL
		      || ((info->symbolic || h->dynindx == -1)
			  && h->def_regular))
		    {
		      relocate = TRUE;
		      outrel.r_addend = 0;
		      outrel.r_info = ELF32_R_INFO (0, R_ARC_RELATIVE);
		    }
		  else
		    {
		      BFD_ASSERT (h->dynindx != -1);
		      if ((input_section->flags & SEC_ALLOC) != 0)
			relocate = FALSE;
		      else
			relocate = TRUE;
		      outrel.r_info = ELF32_R_INFO (h->dynindx, R_ARC_32);
		    }
		}

	      BFD_ASSERT(sreloc->contents != 0);

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela); /* relA */

	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      /* If this reloc is against an external symbol, we do
		 not want to fiddle with the addend.  Otherwise, we
		 need to include the symbol value so that it becomes
		 an addend for the dynamic reloc.  */
	      if (! relocate)
		continue;
	    }

	  /* PLT32 has to be w.r.t the instruction's start */
	  offset_in_insn = 0;
	  break;

	case R_ARC_B22_PCREL:
	  /* 'offset_in_insn' in case of the A4 is from the instruction in
	     the delay slot of the branch instruction hence the -4 offset.  */
 	  offset_in_insn = -4;
	  break;

	case R_ARC_SDA32_ME:

	case R_ARC_SDA_LDST:
	case R_ARC_SDA_LDST1:
	case R_ARC_SDA_LDST2:

	case R_ARC_SDA16_LD:
	case R_ARC_SDA16_LD1:
	case R_ARC_SDA16_LD2:
	  {
	    /* Get the base of .sdata section */
	    struct elf_link_hash_entry *h;
	    
	    h = elf_link_hash_lookup (elf_hash_table (info), "__SDATA_BEGIN__",
				      FALSE, FALSE, TRUE);
	    
	    if (h->root.type == bfd_link_hash_undefined)
	    {
	      (*_bfd_error_handler)("Error: Linker symbol __SDATA_BEGIN__ not found");
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }

	    /* Subtract the address of __SDATA_BEGIN__ from the relocation value */
	    ///	    fprintf (stderr, "relocation BEFORE = 0x%x SDATA_BEGIN = 0x%x\n", relocation, h->root.u.def.value);
	    relocation -= (h->root.u.def.value + h->root.u.def.section->output_section->vma);
	    //	    fprintf (stderr, "relocation AFTER = 0x%x SDATA_BEGIN = 0x%x\n", relocation, h->root.u.def.value);
	    break;
	  }
	default:
	  /* FIXME: Putting in a random dummy relocation value for the time being */
	  //	  fprintf (stderr, "In %s, relocation = 0x%x,  r_type = %d\n", __PRETTY_FUNCTION__, relocation, r_type);
	  break;
	}


      /* get the insn bytes here */
      if(elf_elfheader(input_bfd)->e_machine == EM_ARC)
	insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
      else
	if(input_section && (input_section->flags & SEC_CODE))
	  insn = bfd_get_32_me (input_bfd, contents + rel->r_offset);
	else
	  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
      
      BFD_DEBUG_PIC(fprintf(stderr, "relocation before the pc relative stuff @@offset 0x%x= %d[0x%x]\n", 
			    rel->r_offset,relocation, relocation));

      BFD_DEBUG_PIC(fprintf(stderr,"addend = 0x%x\n",rel->r_addend));

      /* For branches we need to find the offset from pcl rounded down to 4 byte boundary.Hence the (& ~3) */
      if (howto->pc_relative || r_type==R_ARC_PLT32 || r_type==R_ARC_GOTPC || r_type==R_ARC_GOTPC32)
	{
	  relocation -= (((input_section->output_section->vma + input_section->output_offset + rel->r_offset) & ~3) - offset_in_insn );
	}
#if 0
      else if (r_type==R_ARC_GOTPC32)
	{
	  relocation -= (input_section->output_section->vma + 
			 input_section->output_offset + rel->r_offset 
			 - offset_in_insn );
	}
#endif



      BFD_DEBUG_PIC(fprintf(stderr, "relocation AFTER the pc relative handling = %d[0x%x]\n", relocation, relocation));

      /* What does the modified insn look like */
      insn = arc_plugin_one_reloc (insn, rel, relocation,
				   &overflow_detected, symbol_defined);

      if (overflow_detected)
	{
	  if(h)
	    (*_bfd_error_handler) ("Global symbol: \"%s\".", h->root.root.string);
	  else
	    (*_bfd_error_handler) ("Local symbol: \"%s\".", local_sections[r_symndx]->name);
	  (*_bfd_error_handler) ("\nRelocation type is:%s \nFileName:%s \
                             \nSection Name:%s\
                             \nOffset in Section:%ld", howto->name, bfd_get_filename (input_bfd),
			     bfd_get_section_name (input_bfd, input_section),
			     rel->r_offset);

	  return FALSE;
	}
      
      BFD_DEBUG_PIC (fprintf (stderr, "Relocation = %d [0x%x]\n", relocation, relocation));

      /* now write back into the section, with middle endian encoding
	 only for executable section */
      if(elf_elfheader(input_bfd)->e_machine == EM_ARC)
	bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
      else
	if (input_section && (input_section->flags & SEC_CODE))
	  bfd_put_32_me (input_bfd, insn, contents + rel->r_offset);
	else
	  bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

      r = bfd_reloc_ok;
      

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = h->root.root.string;
		else
		  {
		    name = bfd_elf_string_from_elf_section (input_bfd,
							    symtab_hdr->sh_link,
							    sym->st_name);
		    if (name == NULL)
		      return FALSE;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, (h ? &h->root : NULL), name, howto->name,
			(bfd_vma) 0, input_bfd, input_section, rel->r_offset)))
		  return FALSE;
	      }
	      break;
	    }
	}
      
    }
  
  return TRUE;
}


/* Function :  elf_arc_finish_dynamic_symbol
 * Brief    :  Finish up dynamic symbol handling.  We set the
 *           contents of various dynamic sections here.  
 * Args     :  output_bfd : 
 *             info       :
 *             h          :
 *             sym        :
 * Returns  : True/False as the return status.
 */
static bfd_boolean
elf_arc_finish_dynamic_symbol (bfd *output_bfd, 
                               struct bfd_link_info *info, 
                               struct elf_link_hash_entry *h, 
                               Elf_Internal_Sym *sym)
{
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection *splt;
      asection *sgot;
      asection *srel;
      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */

      BFD_ASSERT (h->dynindx != -1);

      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
      srel = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);

      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first TWO entries in the procedure linkage table are reserved.  */
      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 2;

      /* Get the offset into the .got table of the entry that
	 corresponds to this function.  Each .got entry is 4 bytes.
	 The first three are reserved.  */
      got_offset = (plt_index + 3) * 4;

      /* Fill in the entry in the procedure linkage table.  */
      if (! info->shared)
	{
	  memcpy (splt->contents + h->plt.offset, elf_arc_abs_pltn_entry,
		  PLT_ENTRY_SIZE);

	  /* fill in the limm in the plt entry to make it jump through its corresponding *(gotentry) */
	  bfd_put_32_me (output_bfd,
			 (sgot-> output_section->vma + sgot->output_offset + got_offset)
			 -(splt->output_section->vma + splt->output_offset + h->plt.offset),
			 splt->contents + h->plt.offset + 4);

	}
      else
	{
	  memcpy (splt->contents + h->plt.offset, elf_arc_pic_pltn_entry,
		  PLT_ENTRY_SIZE);

	  /* fill in the limm in the plt entry to make it jump through its corresponding *(gotentry) */
	  bfd_put_32_me (output_bfd,
			 (sgot-> output_section->vma + sgot->output_offset + got_offset)
			 -(splt->output_section->vma + splt->output_offset + h->plt.offset),
			 splt->contents + h->plt.offset + 4);

	}


      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd,
		  (splt->output_section->vma
		   + splt->output_offset),
		  sgot->contents + got_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + got_offset);
      /* RELA relocs */
      rel.r_addend = 0;
      rel.r_info = ELF32_R_INFO (h->dynindx, R_ARC_JMP_SLOT);

      loc = srel->contents;
      loc += plt_index * sizeof (Elf32_External_Rela); /* relA */

      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);

      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}

    }

  if (h->got.offset != (bfd_vma) -1)
    {
      asection *sgot;
      asection *srel;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */

      sgot = bfd_get_section_by_name (dynobj, ".got");
      srel = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srel != NULL);

      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + (h->got.offset &~ 1));

      /* If this is a -Bsymbolic link, and the symbol is defined
	 locally, we just want to emit a RELATIVE reloc.  Likewise if
	 the symbol was forced to be local because of a version file.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (info->shared
	  && (info->symbolic || h->dynindx == -1)
	  && h->def_regular)
	{
	  rel.r_addend = 0;
	  rel.r_info = ELF32_R_INFO (0, R_ARC_RELATIVE);
	}
      else
	{
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
	  /* RELA relocs */
	  rel.r_addend = 0;
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_ARC_GLOB_DAT);
	}

      loc = srel->contents;
      loc += srel->reloc_count++ * sizeof (Elf32_External_Rela);/* relA */
      
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
    }

  if (h->needs_copy)
    {
      asection *s;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol needs a copy reloc.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));

      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rela.bss");
      BFD_ASSERT (s != NULL);
      
      rel.r_addend = 0;
      rel.r_offset = (h->root.u.def.value
		      + h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset);
      rel.r_info = ELF32_R_INFO (h->dynindx, R_ARC_COPY);

      loc =  s->contents;
      loc += s->reloc_count++ * sizeof (Elf32_External_Rela); /* relA */
      
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || strcmp (h->root.root.string, "__DYNAMIC") == 0
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}


/* Function :  elf_arc_finish_dynamic_sections
 * Brief    :  Finish up the dynamic sections handling.  
 * Args     :  output_bfd : 
 *             info       :
 *             h          :
 *             sym        :
 * Returns  : True/False as the return status.
 */
static bfd_boolean
elf_arc_finish_dynamic_sections (bfd *output_bfd,struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sgot;
  asection *sdyn;
  asection *sec_ptr;
  char * oldname;

  dynobj = elf_hash_table (info)->dynobj;

  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      asection *splt;
      Elf32_External_Dyn *dyncon, *dynconend;

      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  asection *s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_INIT:
	      oldname = INIT_SYM_STRING;
	      name = init_str;
	      goto get_sym;

	    case DT_FINI:
	      oldname = FINI_SYM_STRING;
	      name = fini_str;
	      goto get_sym;

	    get_sym:
	      {
		struct elf_link_hash_entry *h;

		h = elf_link_hash_lookup (elf_hash_table (info), name,
					  FALSE, FALSE, TRUE);
		if (h != NULL
		    && (h->root.type == bfd_link_hash_defined
			|| h->root.type == bfd_link_hash_defweak))
		  {
		    dyn.d_un.d_val = h->root.u.def.value;
		    sec_ptr = h->root.u.def.section;
		    if (sec_ptr->output_section != NULL)
		      dyn.d_un.d_val += (sec_ptr->output_section->vma
					 + sec_ptr->output_offset);
		    else
		      {
			/* The symbol is imported from another shared
			   library and does not apply to this one.  */
			dyn.d_un.d_val = 0;
		      }

		    bfd_elf32_swap_dyn_out (dynobj, &dyn, dyncon);
		  }
		else
		  {
		    (*_bfd_error_handler)
		      ("warning: specified init/fini symbol %s not found.Defaulting to address of symbol %s", 
		       name, oldname);

		    /* restore the default name */
		    name = oldname;

		    h = elf_link_hash_lookup (elf_hash_table (info), name,
					      FALSE, FALSE, TRUE);
		    if (h != NULL
			&& (h->root.type == bfd_link_hash_defined
			    || h->root.type == bfd_link_hash_defweak))
		      {
			dyn.d_un.d_val = h->root.u.def.value;
			sec_ptr = h->root.u.def.section;
			if (sec_ptr->output_section != NULL)
			  dyn.d_un.d_val += (sec_ptr->output_section->vma
					     + sec_ptr->output_offset);
			else
			  {
			    /* The symbol is imported from another shared
			       library and does not apply to this one.  */
			    dyn.d_un.d_val = 0;
			  }
			
			bfd_elf32_swap_dyn_out (dynobj, &dyn, dyncon);
		      }
		
		  }

	      }
	      break;
	      
	    case DT_PLTGOT:
	      name = ".plt";
	      goto get_vma;
	    case DT_JMPREL:
	      name = ".rela.plt";
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_RELASZ:
	      /* My reading of the SVR4 ABI indicates that the
		 procedure linkage table relocs (DT_JMPREL) should be
		 included in the overall relocs (DT_REL).  This is
		 what Solaris does.  However, UnixWare can not handle
		 that case.  Therefore, we override the DT_RELASZ entry
		 here to make it not include the JMPREL relocs.  Since
		 the linker script arranges for .rela.plt to follow all
		 other relocation sections, we don't have to worry
		 about changing the DT_REL entry.  */
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      if (s != NULL)
		dyn.d_un.d_val -= s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	    }
	}

      /* Fill in the first entry in the procedure linkage table.  */
      if (splt->size > 0)
	{
	  if (info->shared)
	    {
	      memcpy (splt->contents, elf_arc_pic_plt0_entry, 2 * PLT_ENTRY_SIZE);
	      
	      /* fill in the _DYNAMIC@@GOTPC+4 and  
		 _DYNAMIC@@GOTPC+8 at PLT0+4 and PLT0+12 */
	      bfd_put_32_me (output_bfd,
			     ( sgot->output_section->vma + sgot->output_offset + 4 )
			     -(splt->output_section->vma + splt->output_offset ),
			     splt->contents + 4);
	      bfd_put_32_me (output_bfd,
			     (sgot->output_section->vma + sgot->output_offset + 8)
			     -(splt->output_section->vma + splt->output_offset +8),
			     splt->contents + 12);
	      
	      /* put got base at plt0+12 */
	      bfd_put_32 (output_bfd,
			  (sgot->output_section->vma + sgot->output_offset),
			  splt->contents + 20);
	    }
	  else
	    {
	      memcpy (splt->contents, elf_arc_abs_plt0_entry, 2 * PLT_ENTRY_SIZE);

	      /* in the executable, fill in the exact got addresses
		 for the module id ptr (gotbase+4) and the dl resolve
		 routine (gotbase+8) in the middle endian format */
	      bfd_put_32_me (output_bfd,
			     sgot->output_section->vma + sgot->output_offset + 4,
			     splt->contents + 4);
	      bfd_put_32_me (output_bfd,
			     sgot->output_section->vma + sgot->output_offset + 8,
			     splt->contents + 12);

	      /* put got base at plt0+12 */
	      bfd_put_32 (output_bfd,
			  (sgot->output_section->vma + sgot->output_offset),
			  splt->contents + 20);

	    }


	}

      /* UnixWare sets the entsize of .plt to 4, although that doesn't
	 really seem like the right value.  */
      elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;

    }


  /* Fill in the first three entries in the global offset table.  */
  if (sgot->size > 0)
    {
      if (sdyn == NULL)
	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
	bfd_put_32 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
    }

  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;

  return TRUE;
}

/* Desc : Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf_arc_adjust_dynamic_symbol (struct bfd_link_info *info, 
                               struct elf_link_hash_entry *h)
{
  bfd *dynobj;
  asection *s;
  unsigned int power_of_two;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic && h->ref_regular && !h->def_regular)));

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC || h->needs_plt)
    {
      if (!info->shared && !h->def_dynamic && !h->ref_dynamic)
	{
	  /* This case can occur if we saw a PLT32 reloc in an input
             file, but the symbol was never referred to by a dynamic
             object.  In such a case, we don't actually need to build
             a procedure linkage table, and we can just do a PC32
             reloc instead.  */
	  BFD_ASSERT (h->needs_plt);
	  return TRUE;
	}

      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (s->size == 0)
	{
	  s->size += 2 *PLT_ENTRY_SIZE;
	  BFD_DEBUG_PIC (fprintf (stderr, "first plt entry at %d\n", s->size));
	}
      else
	{
	  BFD_DEBUG_PIC (fprintf (stderr, "Next plt entry at %d\n", s->size));
	}
  
      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.  This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (!info->shared && !h->def_regular)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = s->size;
	}

      h->plt.offset = s->size;

      /* Make room for this entry.  */
      s->size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */

      s = bfd_get_section_by_name (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->size += 4;

      /* We also need to make an entry in the .rela.plt section.  */
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->size += sizeof (Elf32_External_Rela);

      return TRUE;
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  s = bfd_get_section_by_name (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);

  /* We must generate a R_ARC_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      asection *srel;

      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf32_External_Rela);
      h->needs_copy = 1;
    }

  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf_arc_size_dynamic_sections (bfd *output_bfd, 
                               struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd_boolean reltext;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      struct elf_link_hash_entry *h;
      
      /* Set the contents of the .interp section to the interpreter.  */
      if (! info->shared)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}

      /* Add some entries to the .dynamic section.  We fill in some of the
	 values later, in elf_bfd_final_link, but we must add the entries
	 now so that we know the final size of the .dynamic section.  */
      /* Checking if the .init section is present. We also create DT_INIT / DT_FINE
       * entries if the init_str has been changed by the user 
       */
      h =  elf_link_hash_lookup (elf_hash_table (info), "init", FALSE,
				FALSE, FALSE);
      if ((h != NULL
	   && (h->ref_regular || h->def_regular))
	  || (strcmp (init_str, INIT_SYM_STRING) != 0))	      
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_INIT, 0))
		return FALSE;
	}
      h =  elf_link_hash_lookup (elf_hash_table (info), "fini", FALSE,
				 FALSE, FALSE);
      if ((h != NULL
	   && (h->ref_regular || h->def_regular))
	  || (strcmp (fini_str, FINI_SYM_STRING) != 0))	      
		      
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_FINI, 0))
		return FALSE;
	}

    }
  else
    {
      /* We may have created entries in the .rela.got section.
         However, if we are not creating the dynamic sections, we will
         not actually use these entries.  Reset the size of .rela.got,
         which will cause it to get stripped from the output file
         below.  */
      s = bfd_get_section_by_name (dynobj, ".rela.got");
      if (s != NULL)
	s->size = 0;
    }

  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared && info->symbolic)
    elf_ARC_link_hash_traverse (elf_ARC_hash_table (info),
				 elf_ARC_discard_copies,
				 (void *) NULL);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = FALSE;
  relocs = FALSE;
  reltext = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      bfd_boolean strip;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      strip = FALSE;

      if (strcmp (name, ".plt") == 0)
	{
	  if (s->size == 0)
	    {
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = TRUE;
	    }
	}
      else if (strncmp (name, ".rela", 5) == 0)
	{
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rela.bss and
		 .rela.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = TRUE;
	    }
	  else
	    {
	      asection *target;

	      /* Remember whether there are any reloc sections other
                 than .rela.plt.  */
	      if (strcmp (name, ".rela.plt") != 0)
		{
		  const char *outname;

		  relocs = TRUE;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  The entries in the .rela.plt section
		     really apply to the .got section, which we
		     created ourselves and so know is not readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 4);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = TRUE;
		}

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (strncmp (name, ".got", 4) != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (strip)
	{
	  asection **spp;

	  for (spp = &s->output_section->owner->sections;
	       *spp != s->output_section;
	       spp = &(*spp)->next)
	    ;
	  *spp = s->output_section->next;
	  --s->output_section->owner->section_count;

	  continue;
	}

      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_arc_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (! info->shared)
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_DEBUG, 0))
		return FALSE;
	}

      if (plt)
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0)
		|| ! _bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)
		|| ! _bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
		|| ! _bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))
		return FALSE;
	}

      if (relocs)
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_RELA, 0)
		|| ! _bfd_elf_add_dynamic_entry (info, DT_RELASZ, 0)
		|| ! _bfd_elf_add_dynamic_entry (info, DT_RELENT,
						  sizeof (Elf32_External_Rela)))
		return FALSE;
	}

      if (reltext)
	{
	    /*Ravi: changed from bfd_elf32_add_dynamic_entry */
	    if (! _bfd_elf_add_dynamic_entry (info, DT_TEXTREL, 0))
		return FALSE;
	}
    }

  return TRUE;
}

/* Core file support. */
/* Support for core dump NOTE sections.  */

static bfd_boolean
elf_arc_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  size_t size;
  
  switch (note->descsz)
    {
    default:
      return FALSE;
      
    case 240:		/* Linux/ARC700 */
      /* pr_cursig */
      elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
      
      /* pr_pid */
      elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);

      /* pr_reg */
      offset = 72;
      size = 164;

      break;
    }
    

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
elf_arc_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  
  switch (note->descsz)
    {
    default:
      return FALSE;
      
    case 124:		/* ARC / Linux elf_prpsinfo.  */
      elf_tdata (abfd)->core_program
	= _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
      elf_tdata (abfd)->core_command
	= _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
    }
  
  
  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */
  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);
    
    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }
  
  return TRUE;
}

#define TARGET_LITTLE_SYM	bfd_elf32_littlearc_vec
#define TARGET_LITTLE_NAME	"elf32-littlearc"
#define TARGET_BIG_SYM		bfd_elf32_bigarc_vec
#define TARGET_BIG_NAME		"elf32-bigarc"
#define ELF_ARCH		bfd_arch_arc
#define ELF_MACHINE_CODE	EM_ARC
#define ELF_MACHINE_ALT1	EM_ARCOMPACT
#define ELF_MAXPAGESIZE		0x1000

#define elf_info_to_howto                    arc_info_to_howto_rel
#define elf_info_to_howto_rel                arc_info_to_howto_rel
#define bfd_elf32_bfd_merge_private_bfd_data arc_elf_merge_private_bfd_data
#define bfd_elf32_bfd_reloc_type_lookup      arc_elf32_bfd_reloc_type_lookup

#define elf_backend_object_p                 arc_elf_object_p
#define elf_backend_final_write_processing   arc_elf_final_write_processing
#define elf_backend_relocate_section         elf_arc_relocate_section
#define elf_backend_check_relocs             elf_arc_check_relocs
#define elf_backend_adjust_dynamic_symbol    elf_arc_adjust_dynamic_symbol

#define elf_backend_finish_dynamic_sections  elf_arc_finish_dynamic_sections

#define elf_backend_finish_dynamic_symbol    elf_arc_finish_dynamic_symbol

#define elf_backend_create_dynamic_sections  _bfd_elf_create_dynamic_sections

#define elf_backend_size_dynamic_sections    elf_arc_size_dynamic_sections

#define elf_backend_want_got_plt 1
#define elf_backend_plt_readonly 1
#define elf_backend_want_plt_sym 0
#define elf_backend_got_header_size 12
#define elf_backend_grok_psinfo elf_arc_grok_psinfo
#define elf_backend_grok_prstatus elf_arc_grok_prstatus
@


1.20.22.2
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d6 7
d30 1
a31 1
#include "sysdep.h"
d37 1
a37 1
   * NOTE: The pic related work starts after the comment marked as
d41 3
a43 11

  /*#define BFD_DEBUG_PIC(x) (fprintf(stderr,"DEBUG: %d@@%s: ",__LINE__,__PRETTY_FUNCTION__),x)*/

static reloc_howto_type *arc_elf32_bfd_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
static void arc_info_to_howto_rel
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean arc_elf_object_p PARAMS ((bfd *));
static void arc_elf_final_write_processing PARAMS ((bfd *, bfd_boolean));
static bfd_reloc_status_type arc_elf_b22_pcrel
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d51 25
d77 2
a78 4
static bfd_vma bfd_get_32_me
PARAMS ((bfd *, const unsigned char *));
static void bfd_put_32_me
PARAMS ((bfd *, bfd_vma, unsigned char *));
d82 1
a82 1
PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d84 2
a85 3
PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean arc_elf_merge_private_bfd_data
PARAMS ((bfd *ibfd, bfd *obfd));
d87 1
a87 1
(enum elf_arc_reloc_type r_type);
d138 1
a138 1
  PARAMS ((struct elf_ARC_link_hash_entry *, PTR));
d145 1
a145 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
d156 2
a157 2
elf_ARC_link_hash_newfunc (struct bfd_hash_entry *entry,
                           struct bfd_hash_table *table,
a195 1

d197 2
a198 1
				       elf_ARC_link_hash_newfunc,/* stub for ARC (according to ChangeLog 2006-05-24  Bjoern Haase )*/0 ))
d217 1
a217 1
                        PTR ignore ATTRIBUTE_UNUSED)
d220 1
a220 1

d222 1
a222 1
  if((h->root.def_regular) == 0)
d226 2
a227 1
    s->section->rawsize -= s->count * sizeof (Elf32_External_Rel);
d232 1
a232 1
/* The HOWTO Array needs to be specified as follows.
d238 1
a238 1
    bitsize     --- > Exact bitsize.
d240 3
a242 3
    bitpos      --- > Bit Position.
    complain_on_overflow ---> What complaint on overflow.
    function    --- > Any special function to be used .
d244 1
a244 1
    partial_inplace--> Addend sits partially in place and in
d246 1
a246 1
    srcmask       ---> Source Mask 0 for RELA and corresponding
d248 1
a248 1
		       is set.
d251 2
a252 2
                       and the assembler leaves an offset in here.

d255 4
a258 4
   use the arc_elf_calculate_howto_index function.  All changes in
   the HOWTO array need a corresponding change in the above mentioned
   function. The need for this function is the presence of a hole
   in the ARC ABI.
d292 2
a293 1
  ARC_RELA_HOWTO (R_ARC_32   ,0 ,3 ,32,FALSE,0,bfd_elf_generic_reloc,
d295 1
d298 1
d301 1
a301 1
  ARC_RELA_HOWTO (R_ARC_H30 ,2 ,3 ,32, FALSE, 0, bfd_elf_generic_reloc,
d321 15
a335 7
  ARC_UNSUPPORTED_HOWTO (R_ARC_SDA32,"R_ARC_SDA32"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SDA_LDST,"R_ARC_SDALDST"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SDA_LDST1,"R_ARC_SDALDST1"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SDA_LDST2,"R_ARC_SDALDST2"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SDA16_LD,"R_ARC_SDA16_LD"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SDA16_LD1,"R_ARC_SDA16_LD1"),
  ARC_UNSUPPORTED_HOWTO (R_ARC_SDA16_LD2,"R_ARC_SDA16_LD2"),
a341 1

d349 1
a349 1

d352 4
a355 1
  ARC_UNSUPPORTED_HOWTO (R_ARC_SDA32_ME,"R_ARC_SDA32_ME"),
d402 82
d485 2
a486 2
static bfd_reloc_status_type
arc_unsupported_reloc (bfd * ibfd ATTRIBUTE_UNUSED,
d488 4
a491 4
		       asymbol * sym ATTRIBUTE_UNUSED,
		       PTR ptr ATTRIBUTE_UNUSED,
		       asection * section ATTRIBUTE_UNUSED,
		       bfd *obfd ATTRIBUTE_UNUSED,
d525 1
a525 1
  { BFD_RELOC_ARC_COPY , R_ARC_COPY},
d528 2
a529 2
  { BFD_RELOC_ARC_GOTOFF , R_ARC_GOTOFF},
  { BFD_RELOC_ARC_GOTPC , R_ARC_GOTPC},
d531 10
d544 2
a545 2
arc_elf32_bfd_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
                                 bfd_reloc_code_real_type code)
a547 1

d553 1
a553 1
        {
d563 16
d580 1
a580 1
static reloc_howto_type *
d584 4
a587 4
  BFD_ASSERT ((r_type < (unsigned int)R_ARC_hole_base) ||
	      (r_type >= (unsigned int) R_ARC_hole_base +
	       R_ARC_reloc_hole_gap));
  if(r_type > R_ARC_hole_base)
d595 3
a597 3
arc_info_to_howto_rel (bfd * abfd ATTRIBUTE_UNUSED,
                       arelent * cache_ptr,
                       Elf_Internal_Rela *dst)
d601 1
d605 1
a605 2


d613 1
a613 1

d617 1
a617 1
  if(bfd_count_sections(ibfd) == 0)
d619 2
a620 2

  mach_ibfd = elf_elfheader(ibfd)->e_machine;
d625 4
d632 1
a632 1
  if(mach_obfd == EM_NONE)
d641 1
a641 1
	  _bfd_error_handler(_("\ERROR: Attempting to link an %s binary(%s) \
d643 4
a646 4
			     (mach_ibfd == EM_ARC)?"A4":"ARCompact",
			     bfd_get_filename(ibfd) ,
			     (mach_obfd == EM_ARC)?"A4":"ARCompact",
			     bfd_get_filename(obfd));
d650 1
a650 1

d655 1
a655 1

d662 1
a662 2
arc_elf_object_p (abfd)
     bfd *abfd;
d669 3
d694 2
a695 3
arc_elf_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d702 4
d728 1
a728 1
arcompact_elf_me_reloc (bfd *abfd ,
d731 1
a731 1
                        PTR data,
d753 1
a753 1
         where the section symbol winds up in the output section.  */
d762 1
a762 1
     symbol is considered to have a value of zero (SVR4 ABI, p. 4-27). */
d764 1
a764 1
  if (symbol_in != NULL && bfd_is_und_section (symbol_in->section)
a853 1

d927 1
a927 1
  if (bfd_big_endian(abfd)) {
d936 1
a936 1

d939 1
a939 1

a946 25
/* Handle PC relative relocation */
bfd_reloc_status_type
arc_elf_b22_pcrel (bfd *abfd ATTRIBUTE_UNUSED,
                   arelent *reloc_entry,
                   asymbol *symbol,
                   PTR data ATTRIBUTE_UNUSED,
                   asection *input_section,
                   bfd *output_bfd,
                   char **error_message ATTRIBUTE_UNUSED)
{
  /* If incremental linking, update the address of the relocation with the
     section offset */


  if (output_bfd != (bfd *) NULL)
  {
    reloc_entry->address += input_section->output_offset;
    if ((symbol->flags & BSF_SECTION_SYM) && symbol->section)
      reloc_entry->addend  += ((**(reloc_entry->sym_ptr_ptr)).section)->output_offset;

    return bfd_reloc_ok;
  }

  return bfd_reloc_continue;
}
d949 1
a949 1
 * PIC-related routines for the arc backend
d952 1
a952 1
/* This will be overridden by the interpreter ld-linux.so specified in
d954 1
a954 2
#define ELF_DYNAMIC_INTERPRETER  "/sbin/ld-uClibc-0.9.26.so"
/*"/usr/local/arc/lib/libc.so.1"*/
d960 2
a961 2
static const bfd_byte elf_arc_abs_plt0_entry [2 * PLT_ENTRY_SIZE] =
  {
d964 1
a964 1
    0x00, 0x00,
d977 2
a978 2
static const bfd_byte elf_arc_abs_pltn_entry [PLT_ENTRY_SIZE] =
  {
d983 1
a983 1
    0x20, 0x7c, 		/* j_s.d [%r12]              */
d988 2
a989 2
static const bfd_byte elf_arc_pic_plt0_entry [2 * PLT_ENTRY_SIZE] =
  {
d992 1
a992 1
    0x00, 0x00,
d1005 2
a1006 2
static const bfd_byte elf_arc_pic_pltn_entry [PLT_ENTRY_SIZE] =
  {
d1011 1
a1011 1
    0x20, 0x7c, 		/* j_s.d [%r12]              */
d1018 1
a1018 1
 *           depending on the relocation type. The instruction is
d1020 8
a1027 4
 * Args    : 1. insn   : the original insn into which the relocated
 *                       value has to be filled in.
 *           2. r_type : the relocation type.
 *           3. value  : the value to be plugged in the insn.
a1029 1
/* FIXME::: Ramana this whole function needs to check for overflows. */
d1031 4
a1034 2
arc_plugin_one_reloc (unsigned long insn, enum elf_arc_reloc_type r_type,
		      int value)
d1037 6
d1044 35
d1092 2
a1093 2
      /* With the addend now being in the addend table, there is no
       * need to use this
d1096 1
a1096 1
       * addends no longer exist in place
d1101 1
a1101 1

d1106 1
a1106 1

d1109 1
a1109 1

d1112 6
a1117 3

	value += offset;

d1119 1
a1119 1

d1121 1
a1121 1

d1137 1
a1137 1

d1139 1
a1139 1
       *  the in place addend
d1142 1
a1142 1

d1162 1
a1162 1
       *  the in place addend
d1164 1
a1164 1

d1190 1
a1190 1
       *  the in place addend
d1192 1
a1192 1

d1218 1
a1218 1

d1224 12
a1235 12
       /* Retrieve the offset from the instruction, if any */
       /* Extract the high 4 bits from Position 0 to 3 in insn */
       offset = ((insn << 28) >> 28) << 10;

       /* Extract the next 10 bits from Position 6 to 15 in insn */
       offset |= ((insn << 16) >> 22);
       offset = offset << 9;

       /* Extract the remaining 9 bits from Position 18 to 26 in insn */
       offset |= ((insn << 5) >> 23);

       /* Fill in 2 bits to get the 25 bit Offset Value */
d1240 1
a1240 1
       *  the in place addend
d1242 1
a1242 1

d1261 1
a1261 1
       *  the in place addend
d1263 1
a1263 1

d1275 1
a1275 1

d1279 1
a1279 1
    /* One would have to OR the value here since
d1282 1
a1282 1

d1285 29
d1315 2
a1316 2
    /* FIXME:: This should go away once the HOWTO Array
       is used for this purpose.
d1318 1
d1321 1
a1321 1

d1335 3
a1337 3
elf_arc_check_relocs (bfd *abfd,
                      struct bfd_link_info *info,
                      asection *sec,
d1437 1
a1437 1
	      h->got.offset = sgot->rawsize;
d1449 1
a1449 1
	      srelgot->rawsize += sizeof (Elf32_External_Rela);
d1478 2
a1479 2

	      local_got_offsets[r_symndx] = sgot->rawsize;
d1486 1
a1486 1
		  srelgot->rawsize += sizeof (Elf32_External_Rela);
d1489 1
a1489 1

d1492 1
a1492 1
	  sgot->rawsize += 4;
d1531 1
a1531 2
		      && (! info->symbolic
			  || (h->def_regular) == 0))))
d1568 1
a1568 1
	      sreloc->rawsize += sizeof (Elf32_External_Rela);
d1622 1
a1622 1
 * Args     : output_bfd    : The bfd being written to.
d1630 1
a1630 1
 *                            corresponding to the st_shndx field of each
d1632 1
a1632 1
 * Returns  :
d1635 3
a1637 3
elf_arc_relocate_section (bfd *output_bfd,
                          struct bfd_link_info *info,
                          bfd *input_bfd,
d1639 3
a1641 3
					      bfd_byte * contents,
                          Elf_Internal_Rela *relocs,
                          Elf_Internal_Sym *local_syms,
d1653 1
d1676 1
d1678 1
a1678 1
      /* Distance of the relocation slot in the insn .This value is used for
d1687 1
a1687 1

d1709 1
a1709 1
	  /* Checks if this is a local symbol
d1719 1
a1719 1
		  /* for RELA relocs.Just adjust the addend
d1724 4
a1727 2
(section=%d %s) seen in %s\n", r_symndx, local_sections[r_symndx]->name, \
					 __PRETTY_FUNCTION__));
d1754 1
a1754 1
	      rel->r_addend = _bfd_elf_rel_local_sym (output_bfd, sym,
d1759 2
a1760 2

	  relocation += rel->r_addend;
d1765 1
a1765 1

d1785 1
a1785 1
			  || (h->def_regular) == 0))
d1788 1
a1788 1
			  || (h->def_regular) == 0)
d1806 7
d1832 1
d1861 1
a1861 1
		      && (h->def_regular)))
d1911 1
a1911 1
		      bfd_byte *loc;
d1936 1
a1936 1
	  /* the data in GOTPC32 relocs is 4 bytes into the insn */
d1971 1
a1971 1

d2011 1
a2011 2
		      && (! info->symbolic
			  || (h->def_regular) == 0))))
d2044 2
a2045 2
	      outrel.r_offset = _bfd_elf_section_offset (output_bfd,
							 info,
d2050 1
a2050 1

d2075 1
a2075 1
			  && (h->def_regular) != 0))
d2117 29
d2147 2
d2161 2
a2162 2

      BFD_DEBUG_PIC(fprintf(stderr, "relocation before the pc relative stuff @@offset 0x%x= %d[0x%x]\n",
d2168 1
a2168 1
      if (howto->pc_relative || r_type==R_ARC_PLT32 || r_type==R_ARC_GOTPC)
d2170 1
a2170 2
	  relocation -= (((input_section->output_section->vma + input_section->output_offset +
			   rel->r_offset) & ~3) - offset_in_insn );
d2172 1
d2175 2
a2176 2
	  relocation -= (input_section->output_section->vma +
			 input_section->output_offset + rel->r_offset
d2179 1
d2183 1
a2183 3
      BFD_DEBUG_PIC(fprintf(stderr, \
			    "relocation AFTER the pc relative \
handling = %d[0x%x]\n", relocation, relocation));
d2186 2
a2187 1
      insn = arc_plugin_one_reloc (insn, r_type, relocation);
d2189 16
a2204 2
      BFD_DEBUG_PIC (fprintf (stderr, "Relocation = %d [0x%x]\n", \
			      relocation, relocation));
d2217 1
a2217 1

a2241 1
		/* <irf-todo>
d2243 3
a2245 3
		       (info, name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rel->r_offset)))
		  return FALSE;*/
d2250 1
a2250 1

d2252 1
a2252 1

d2259 2
a2260 2
 *           contents of various dynamic sections here.
 * Args     :  output_bfd :
d2267 3
a2269 3
elf_arc_finish_dynamic_symbol (bfd *output_bfd,
                               struct bfd_link_info *info,
                               struct elf_link_hash_entry *h,
d2353 1
a2353 1
      if ((h->def_regular) == 0)
d2387 1
a2387 1
	  && (h->def_regular))
d2401 2
a2402 2
      loc += srel->reloc_count++ * sizeof (Elf32_External_Rel);

d2406 1
a2406 1
  if ((h->needs_copy) != 0)
d2421 2
a2422 1

d2430 1
a2430 1

d2445 2
a2446 2
 * Brief    :  Finish up the dynamic sections handling.
 * Args     :  output_bfd :
d2452 2
a2453 1
static bfd_boolean elf_arc_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info *info)
d2476 1
a2476 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->rawsize);
d2527 2
a2528 1
		      ("warning: specified init/fini symbol %s not found.Defaulting to address of symbol %s", name, oldname);
d2550 1
a2550 1

d2553 1
a2553 1

d2558 1
a2558 1

d2574 1
a2574 4
	      if (s->size != 0)
		dyn.d_un.d_val = s->size;
	      else
		dyn.d_un.d_val = s->rawsize;
d2590 1
a2590 6
		{
		  if (s->size != 0)
		    dyn.d_un.d_val -= s->size;
		  else
		    dyn.d_un.d_val -= s->rawsize;
		}
d2597 1
a2597 1
      if (splt->rawsize > 0)
d2602 3
a2604 2

	      /* fill in the   _DYNAMIC@@GOTPC+4 and  _DYNAMIC@@GOTPC+8 at PLT0+4 and PLT0+12 */
d2613 1
a2613 1

d2651 1
a2651 1
  if (sgot->rawsize > 0)
d2674 3
a2676 1
static bfd_boolean elf_arc_adjust_dynamic_symbol (struct bfd_link_info * info, struct elf_link_hash_entry *h)
d2686 1
a2686 1
	      && ((h->needs_plt)
d2688 1
a2688 3
		  || ((h->def_dynamic) != 0
		      && (h->ref_regular) != 0
		      && (h->def_regular) == 0)));
d2693 1
a2693 2
  if (h->type == STT_FUNC
      || (h->needs_plt) != 0)
d2695 1
a2695 3
      if (! info->shared
	  && (h->def_dynamic) == 0
	  && (h->ref_dynamic) == 0)
d2702 1
a2702 1
	  BFD_ASSERT ((h->needs_plt) != 0);
d2718 6
a2723 1
      if (s->rawsize == 0)
d2725 1
a2725 2
	  s->rawsize += 2 *PLT_ENTRY_SIZE;
	  BFD_DEBUG_PIC (fprintf (stderr, "first plt entry at %d\n", s->rawsize));
d2727 1
a2727 5
      else {
	  BFD_DEBUG_PIC (fprintf (stderr, "Next plt entry at %d\n", s->rawsize));
  	  printf("Unimplimented path: elf32-arc.c: <Irf-todo>");
  	  }

d2733 1
a2733 2
      if (! info->shared
	  && (h->def_regular) == 0)
d2736 1
a2736 1
	  h->root.u.def.value = s->rawsize;
d2739 1
a2739 1
      h->plt.offset = s->rawsize;
d2742 1
a2742 1
      s->rawsize += PLT_ENTRY_SIZE;
d2749 1
a2749 1
      s->rawsize += 4;
d2754 1
a2754 1
      s->rawsize += sizeof (Elf32_External_Rela);
d2804 1
a2804 1
      srel->rawsize += sizeof (Elf32_External_Rela);
d2815 1
a2815 2
  s->rawsize = BFD_ALIGN (s->rawsize,
			    (bfd_size_type) (1 << power_of_two));
d2824 1
a2824 1
  h->root.u.def.value = s->rawsize;
d2827 1
a2827 1
  s->rawsize += h->size;
d2835 1
a2835 1
elf_arc_size_dynamic_sections (bfd *output_bfd,
d2850 1
a2850 1

d2856 1
a2856 1
	  s->rawsize = sizeof ELF_DYNAMIC_INTERPRETER;
d2864 1
a2864 1
       * entries if the init_str has been changed by the user
d2869 2
a2870 2
	  && (h->ref_regular || h->def_regular) != 0)
	  || (strcmp(init_str,INIT_SYM_STRING) != 0))
d2879 3
a2881 3
	  && (h->ref_regular || h->def_regular) != 0)
	 || (strcmp(fini_str,FINI_SYM_STRING) != 0))

d2898 1
a2898 1
	s->rawsize = 0;
d2908 1
a2908 1
				 (PTR) NULL);
d2932 1
a2932 1
	  if (s->rawsize == 0)
d2946 1
a2946 1
	  if (s->rawsize == 0)
d3011 2
a3012 2
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->rawsize);
      if (s->contents == NULL && s->rawsize != 0)
d3060 1
d3069 1
a3069 1

d3074 1
a3074 1

d3078 1
a3078 1

d3088 1
a3088 1

d3098 1
a3098 1

d3103 1
a3103 1

d3110 2
a3111 2


d3118 1
a3118 1

d3122 1
a3122 1

a3125 1

d3135 4
d3140 5
a3144 21
#define elf_info_to_howto	arc_info_to_howto_rel
#define elf_info_to_howto_rel	arc_info_to_howto_rel
#define bfd_elf32_bfd_merge_private_bfd_data \
				arc_elf_merge_private_bfd_data
#define bfd_elf32_bfd_reloc_type_lookup \
                                arc_elf32_bfd_reloc_type_lookup
static reloc_howto_type *
bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
                                 const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (elf_arc_howto_table) / sizeof (elf_arc_howto_table[0]);
       i++)
    if (elf_arc_howto_table[i].name != NULL
        && strcasecmp (elf_arc_howto_table[i].name, r_name) == 0)
      return &elf_arc_howto_table[i];

  return NULL;
}
d3146 1
a3146 10
#define elf_backend_object_p	arc_elf_object_p
#define elf_backend_final_write_processing \
				arc_elf_final_write_processing
#define elf_backend_relocate_section    elf_arc_relocate_section
#define elf_backend_check_relocs	elf_arc_check_relocs
#define elf_backend_adjust_dynamic_symbol \
					elf_arc_adjust_dynamic_symbol

#define elf_backend_finish_dynamic_sections \
					elf_arc_finish_dynamic_sections
d3148 1
a3148 2
#define elf_backend_finish_dynamic_symbol \
					elf_arc_finish_dynamic_symbol
d3150 1
a3150 2
#define elf_backend_create_dynamic_sections \
                                        _bfd_elf_create_dynamic_sections
d3152 1
a3152 2
#define elf_backend_size_dynamic_sections \
					elf_arc_size_dynamic_sections
@


1.19
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
@


1.18
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.17
log
@Update function declarations to ISO C90 formatting
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1999, 2001, 2002, 2005
d150 16
@


1.16
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1999, 2001, 2002
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a29 11
static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
static void arc_info_to_howto_rel
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean arc_elf_object_p
  PARAMS ((bfd *));
static void arc_elf_final_write_processing
  PARAMS ((bfd *, bfd_boolean));
static bfd_reloc_status_type arc_elf_b22_pcrel
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

d35 22
d60 13
a72 13
  HOWTO (R_ARC_NONE,		/* type  */
	 0,			/* rightshift  */
	 2,			/* size (0 = byte, 1 = short, 2 = long)  */
	 32,			/* bitsize  */
	 FALSE,			/* pc_relative  */
	 0,			/* bitpos  */
	 complain_overflow_bitfield, /* complain_on_overflow  */
	 bfd_elf_generic_reloc,	/* special_function  */
	 "R_ARC_NONE",		/* name  */
	 TRUE,			/* partial_inplace  */
	 0,			/* src_mask  */
	 0,			/* dst_mask  */
	 FALSE),		/* pcrel_offset  */
d75 13
a87 13
  HOWTO (R_ARC_32,		/* type  */
	 0,			/* rightshift  */
	 2,			/* size (0 = byte, 1 = short, 2 = long)  */
	 32,			/* bitsize  */
	 FALSE,			/* pc_relative  */
	 0,			/* bitpos  */
	 complain_overflow_bitfield, /* complain_on_overflow  */
	 bfd_elf_generic_reloc,	/* special_function  */
	 "R_ARC_32",		/* name  */
	 TRUE,			/* partial_inplace  */
	 0xffffffff,		/* src_mask  */
	 0xffffffff,		/* dst_mask  */
	 FALSE),		/* pcrel_offset  */
d90 13
a102 13
  HOWTO (R_ARC_B26,		/* type  */
	 2,			/* rightshift  */
	 2,			/* size (0 = byte, 1 = short, 2 = long)  */
	 26,			/* bitsize  */
	 FALSE,			/* pc_relative  */
	 0,			/* bitpos  */
	 complain_overflow_bitfield, /* complain_on_overflow  */
	 bfd_elf_generic_reloc,	/* special_function  */
	 "R_ARC_B26",		/* name  */
	 TRUE,			/* partial_inplace  */
	 0x00ffffff,		/* src_mask  */
	 0x00ffffff,		/* dst_mask  */
	 FALSE),		/* pcrel_offset  */
d105 13
a117 13
  HOWTO (R_ARC_B22_PCREL,	/* type  */
	 2,			/* rightshift  */
	 2,			/* size (0 = byte, 1 = short, 2 = long)  */
	 22,			/* bitsize  */
	 TRUE,			/* pc_relative  */
	 7,			/* bitpos  */
	 complain_overflow_signed, /* complain_on_overflow  */
	 arc_elf_b22_pcrel,	/* special_function  */
	 "R_ARC_B22_PCREL",	/* name  */
	 TRUE,			/* partial_inplace  */
	 0x07ffff80,		/* src_mask  */
	 0x07ffff80,		/* dst_mask  */
	 FALSE),		/* pcrel_offset  */
d138 2
a139 3
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d153 3
a155 4
arc_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d167 1
a167 2
arc_elf_object_p (abfd)
     bfd *abfd;
d199 2
a200 3
arc_elf_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d224 12
a235 36
bfd_reloc_status_type
arc_elf_b22_pcrel (abfd, reloc_entry, symbol, data, input_section,
		   output_bfd, error_message)
     bfd * abfd;
     arelent * reloc_entry;
     asymbol * symbol;
     PTR data;
     asection * input_section;
     bfd * output_bfd;
     char ** error_message;
{
  /* If linking, back up the final symbol address by the address of the
     reloc.  This cannot be accomplished by setting the pcrel_offset
     field to TRUE, as bfd_install_relocation will detect this and refuse
     to install the offset in the first place, but bfd_perform_relocation
     will still insist on removing it.  */
  if (output_bfd == (bfd *) NULL)
    reloc_entry->addend -= reloc_entry->address;

  /* Fall through to the default elf reloc handler.  */
  return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
}

#define TARGET_LITTLE_SYM bfd_elf32_littlearc_vec
#define TARGET_LITTLE_NAME "elf32-littlearc"
#define TARGET_BIG_SYM bfd_elf32_bigarc_vec
#define TARGET_BIG_NAME	"elf32-bigarc"
#define ELF_ARCH bfd_arch_arc
#define ELF_MACHINE_CODE EM_ARC
#define ELF_MAXPAGESIZE	0x1000

#define elf_info_to_howto 0
#define elf_info_to_howto_rel arc_info_to_howto_rel
#define elf_backend_object_p arc_elf_object_p
#define elf_backend_final_write_processing arc_elf_final_write_processing
@


1.15
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.14
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.13
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d33 1
a33 1
static boolean arc_elf_object_p
d36 1
a36 1
  PARAMS ((bfd *, boolean));
d52 1
a52 1
	 false,			/* pc_relative  */
d57 1
a57 1
	 true,			/* partial_inplace  */
d60 1
a60 1
	 false),		/* pcrel_offset  */
d67 1
a67 1
	 false,			/* pc_relative  */
d72 1
a72 1
	 true,			/* partial_inplace  */
d75 1
a75 1
	 false),		/* pcrel_offset  */
d82 1
a82 1
	 false,			/* pc_relative  */
d87 1
a87 1
	 true,			/* partial_inplace  */
d90 1
a90 1
	 false),		/* pcrel_offset  */
d97 1
a97 1
	 true,			/* pc_relative  */
d102 1
a102 1
	 true,			/* partial_inplace  */
d105 1
a105 1
	 false),		/* pcrel_offset  */
d156 1
a156 1
static boolean
d192 1
a192 1
     boolean linker ATTRIBUTE_UNUSED;
d229 1
a229 1
     field to true, as bfd_install_relocation will detect this and refuse
@


1.12
log
@	* elfxx-target.h (USE_REL): Don't define as 1.
	* elf32-arm.h (USE_REL): Provide a default define of 0.
	Use #if rather than #ifdef when testing USE_REL.
	* elf32-m32r.c: Likewise.

	* elf32-arc.c (USE_REL): Define as 1.
	* elf32-d10v.c (USE_REL): Likewise.
	* elf32-m32r.c (USE_REL): Likewise.
	* elf32-m68hc11.c (USE_REL): Likewise.
	* elf32-m68hc12.c (USE_REL): Likewise.
	* elf32-or32.c (USE_REL): Likewise.
	* elfarm-nabi.c (USE_REL): Likewise.
@
text
@d32 1
a32 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
d145 1
a145 1
     Elf32_Internal_Rel *dst;
@


1.11
log
@	* elf32-arc.c: Fix formatting.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i386qnx.c: Likewise.
	* elf32-or32.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 1997, 1999, 2001 Free Software Foundation, Inc.
d43 1
a43 1
#define USE_REL
@


1.11.14.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1997, 1999, 2001, 2002
   Free Software Foundation, Inc.
d42 1
a42 1
#define USE_REL	1
@


1.11.14.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d32 2
a33 2
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean arc_elf_object_p
d36 1
a36 1
  PARAMS ((bfd *, bfd_boolean));
d52 1
a52 1
	 FALSE,			/* pc_relative  */
d57 1
a57 1
	 TRUE,			/* partial_inplace  */
d60 1
a60 1
	 FALSE),		/* pcrel_offset  */
d67 1
a67 1
	 FALSE,			/* pc_relative  */
d72 1
a72 1
	 TRUE,			/* partial_inplace  */
d75 1
a75 1
	 FALSE),		/* pcrel_offset  */
d82 1
a82 1
	 FALSE,			/* pc_relative  */
d87 1
a87 1
	 TRUE,			/* partial_inplace  */
d90 1
a90 1
	 FALSE),		/* pcrel_offset  */
d97 1
a97 1
	 TRUE,			/* pc_relative  */
d102 1
a102 1
	 TRUE,			/* partial_inplace  */
d105 1
a105 1
	 FALSE),		/* pcrel_offset  */
d145 1
a145 1
     Elf_Internal_Rela *dst;
d156 1
a156 1
static bfd_boolean
d192 1
a192 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d229 1
a229 1
     field to TRUE, as bfd_install_relocation will detect this and refuse
@


1.11.12.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1997, 1999, 2001, 2002
   Free Software Foundation, Inc.
d42 1
a42 1
#define USE_REL	1
@


1.11.12.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d32 2
a33 2
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean arc_elf_object_p
d36 1
a36 1
  PARAMS ((bfd *, bfd_boolean));
d52 1
a52 1
	 FALSE,			/* pc_relative  */
d57 1
a57 1
	 TRUE,			/* partial_inplace  */
d60 1
a60 1
	 FALSE),		/* pcrel_offset  */
d67 1
a67 1
	 FALSE,			/* pc_relative  */
d72 1
a72 1
	 TRUE,			/* partial_inplace  */
d75 1
a75 1
	 FALSE),		/* pcrel_offset  */
d82 1
a82 1
	 FALSE,			/* pc_relative  */
d87 1
a87 1
	 TRUE,			/* partial_inplace  */
d90 1
a90 1
	 FALSE),		/* pcrel_offset  */
d97 1
a97 1
	 TRUE,			/* pc_relative  */
d102 1
a102 1
	 TRUE,			/* partial_inplace  */
d105 1
a105 1
	 FALSE),		/* pcrel_offset  */
d145 1
a145 1
     Elf_Internal_Rela *dst;
d156 1
a156 1
static bfd_boolean
d192 1
a192 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d229 1
a229 1
     field to TRUE, as bfd_install_relocation will detect this and refuse
@


1.10
log
@	* elf32-arc.c (elf_arc_howto_table): Set partial_inplace for all
	relocs.
@
text
@d238 1
a238 1
  
@


1.10.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d238 1
a238 1

@


1.10.10.2
log
@merge from mainline
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1997, 1999, 2001, 2002
   Free Software Foundation, Inc.
d42 1
a42 1
#define USE_REL	1
@


1.10.8.1
log
@merge from trunk
@
text
@d238 1
a238 1

@


1.9
log
@Fix (for the last time, I hope) handling of R_ARC_B22_PCREL.
@
text
@d56 1
a56 1
	 false,			/* partial_inplace  */
d71 1
a71 1
	 false,			/* partial_inplace  */
d86 1
a86 1
	 false,			/* partial_inplace  */
@


1.8
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d26 1
d36 2
d99 1
a99 1
	 bfd_elf_generic_reloc,	/* special_function  */
a104 1

d131 4
a134 5
  for (i = 0; i < sizeof (arc_reloc_map) / sizeof (struct arc_reloc_map); i++)
    {
      if (arc_reloc_map[i].bfd_reloc_val == code)
	return &elf_arc_howto_table[arc_reloc_map[i].elf_reloc_val];
    }
d215 24
@


1.7
log
@* elf.c (prep_headers): Get the machine code from the elf
backend data.
* elf-m10200.c (ELF_MACHINE_CODE): Redefine to EM_MN10200.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_MN10200.
* elf-m10300.c (ELF_MACHINE_CODE): Redefine to EM_MN10300.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_MN10300.
* elf-arc.c (arc_elf_final_write_processing): Don't override
e_machine, it's now properly set in prep_headers.
* elf32-avr.c (elf32_avr_object_p): Accept both EM_AVR and
EM_AVR_OLD.
(ELF_MACHINE_ALT1): Define to EM_AVR_OLD.
* elf-d10v.c (ELF_MACHINE_CODE): Redefine to EM_D10V.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_D10V.
* elf-d30v.c (ELF_MACHINE_CODE): Redefine to EM_D30V.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_D30V.
* elf-fr30.c (ELF_MACHINE_CODE): Redefine to EM_FR30.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_FR30.
* elf-m32r.c (ELF_MACHINE_CODE): Redefine to EM_M32R.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_M32R.
* elf32-pj.c (ELF_MACHINE_ALT1): DEfine to EM_PJ_OLD.
* elf-v850.c (ELF_MACHINE_CODE): Redefine to EM_V850.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_V850.
@
text
@d158 1
a158 1
  int mach = bfd_mach_arc_6;
@


1.6
log
@Change 'partial_inplace' to true (this target uses REL relocations) and
'pcrel_offset' to false (the PC is implied, not stored in the offset).
@
text
@a209 1
  elf_elfheader (abfd)->e_machine = EM_ARC;
@


1.5
log
@Peter Targett's backwards compatibility and other arc fixes.
@
text
@d98 1
a98 1
	 false,			/* partial_inplace  */
d101 1
a101 1
	 true),			/* pcrel_offset  */
@


1.4
log
@Update copyright notices
@
text
@d60 5
a64 5
	 0,	                /* rightshift  */
	 2,	                /* size (0 = byte, 1 = short, 2 = long)  */
	 32,	                /* bitsize  */
	 false,	                /* pc_relative  */
	 0,	                /* bitpos  */
d66 1
a66 1
	 bfd_elf_generic_reloc, /* special_function  */
d68 4
a71 4
	 false,	                /* partial_inplace  */
	 0xffffffff,	        /* src_mask  */
	 0xffffffff,   		/* dst_mask  */
	 false),                /* pcrel_offset  */
d158 1
a158 1
  int mach = bfd_mach_arc_5;
a165 1
	default:
d169 1
a195 1
    default:
d199 1
@


1.3
log
@Updated ARC assembler from arccores.com
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1997, 1999, 2000 Free Software Foundation, Inc.
@


1.3.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1999, 2001 Free Software Foundation, Inc.
d60 5
a64 5
	 0,			/* rightshift  */
	 2,			/* size (0 = byte, 1 = short, 2 = long)  */
	 32,			/* bitsize  */
	 false,			/* pc_relative  */
	 0,			/* bitpos  */
d66 1
a66 1
	 bfd_elf_generic_reloc,	/* special_function  */
d68 4
a71 4
	 false,			/* partial_inplace  */
	 0xffffffff,		/* src_mask  */
	 0xffffffff,		/* dst_mask  */
	 false),		/* pcrel_offset  */
d158 1
a158 1
  int mach = bfd_mach_arc_6;
d166 1
a169 1
	default:
d196 1
a199 1
    default:
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1997, 1999 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 1
a28 1
 PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
d31 4
a34 2
static boolean arc_elf_object_p PARAMS ((bfd *));
static void arc_elf_final_write_processing PARAMS ((bfd *, boolean));
d38 1
d44 13
a56 13
  HOWTO (R_ARC_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARC_NONE",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d59 13
a71 13
  HOWTO (R_ARC_32,		/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARC_32",		/* name */
	 false,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,   		/* dst_mask */
	 false),                /* pcrel_offset */
d74 13
a86 13
  HOWTO (R_ARC_B26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARC_B26",		/* name */
	 false,			/* partial_inplace */
	 0x00ffffff,		/* src_mask */
	 0x00ffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d89 13
a101 13
  HOWTO (R_ARC_B22_PCREL,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 22,			/* bitsize */
	 true,			/* pc_relative */
	 7,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARC_B22_PCREL",	/* name */
	 false,			/* partial_inplace */
	 0x07ffff80,		/* src_mask */
	 0x07ffff80,		/* dst_mask */
	 true),			/* pcrel_offset */
d129 1
a129 3
  for (i = 0;
       i < sizeof (arc_reloc_map) / sizeof (struct arc_reloc_map);
       i++)
a133 1

d158 1
a158 2
  int mach;
  unsigned long arch = elf_elfheader (abfd)->e_flags & EF_ARC_MACH;
d160 1
a160 1
  switch (arch)
d162 18
a179 6
    case E_ARC_MACH_BASE:
      mach = bfd_mach_arc_base;
      break;
    default:
      /* Unknown cpu type.  ??? What to do?  */
      return false;
d181 1
a181 3

  (void) bfd_default_set_arch_mach (abfd, bfd_arch_arc, mach);
  return true;
a191 1
  int mach;
d194 1
a194 1
  switch (mach = bfd_get_mach (abfd))
d196 12
a207 2
    case bfd_mach_arc_base:
      val = E_ARC_MACH_BASE;
a208 2
    default:
      return;
d210 1
a210 1

d215 12
a226 13
#define TARGET_LITTLE_SYM	bfd_elf32_littlearc_vec
#define TARGET_LITTLE_NAME	"elf32-littlearc"
#define TARGET_BIG_SYM		bfd_elf32_bigarc_vec
#define TARGET_BIG_NAME		"elf32-bigarc"
#define ELF_ARCH		bfd_arch_arc
#define ELF_MACHINE_CODE	EM_CYGNUS_ARC
#define ELF_MAXPAGESIZE		0x1000

#define elf_info_to_howto	0
#define elf_info_to_howto_rel	arc_info_to_howto_rel
#define elf_backend_object_p	arc_elf_object_p
#define elf_backend_final_write_processing \
				arc_elf_final_write_processing
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1995, 1997 Free Software Foundation, Inc.
d121 1
a121 1
     bfd *abfd;
d141 1
a141 1
     bfd *abfd;
d181 1
a181 1
     boolean linker;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

