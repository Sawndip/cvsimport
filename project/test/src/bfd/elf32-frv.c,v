head	1.84;
access;
symbols
	sid-snapshot-20180601:1.84
	sid-snapshot-20180501:1.84
	sid-snapshot-20180401:1.84
	sid-snapshot-20180301:1.84
	sid-snapshot-20180201:1.84
	sid-snapshot-20180101:1.84
	sid-snapshot-20171201:1.84
	sid-snapshot-20171101:1.84
	sid-snapshot-20171001:1.84
	sid-snapshot-20170901:1.84
	sid-snapshot-20170801:1.84
	sid-snapshot-20170701:1.84
	sid-snapshot-20170601:1.84
	sid-snapshot-20170501:1.84
	sid-snapshot-20170401:1.84
	sid-snapshot-20170301:1.84
	sid-snapshot-20170201:1.84
	sid-snapshot-20170101:1.84
	sid-snapshot-20161201:1.84
	sid-snapshot-20161101:1.84
	sid-snapshot-20160901:1.84
	sid-snapshot-20160801:1.84
	sid-snapshot-20160701:1.84
	sid-snapshot-20160601:1.84
	sid-snapshot-20160501:1.84
	sid-snapshot-20160401:1.84
	sid-snapshot-20160301:1.84
	sid-snapshot-20160201:1.84
	sid-snapshot-20160101:1.84
	sid-snapshot-20151201:1.84
	sid-snapshot-20151101:1.84
	sid-snapshot-20151001:1.84
	sid-snapshot-20150901:1.84
	sid-snapshot-20150801:1.84
	sid-snapshot-20150701:1.84
	sid-snapshot-20150601:1.84
	sid-snapshot-20150501:1.84
	sid-snapshot-20150401:1.84
	sid-snapshot-20150301:1.84
	sid-snapshot-20150201:1.84
	sid-snapshot-20150101:1.84
	sid-snapshot-20141201:1.84
	sid-snapshot-20141101:1.84
	sid-snapshot-20141001:1.84
	sid-snapshot-20140901:1.84
	sid-snapshot-20140801:1.84
	sid-snapshot-20140701:1.84
	sid-snapshot-20140601:1.84
	sid-snapshot-20140501:1.84
	sid-snapshot-20140401:1.84
	sid-snapshot-20140301:1.84
	sid-snapshot-20140201:1.84
	sid-snapshot-20140101:1.84
	sid-snapshot-20131201:1.84
	sid-snapshot-20131101:1.84
	sid-snapshot-20131001:1.84
	binutils-2_24-branch:1.84.0.2
	binutils-2_24-branchpoint:1.84
	binutils-2_21_1:1.71
	sid-snapshot-20130901:1.84
	gdb_7_6_1-2013-08-30-release:1.83
	sid-snapshot-20130801:1.84
	sid-snapshot-20130701:1.84
	sid-snapshot-20130601:1.84
	sid-snapshot-20130501:1.84
	gdb_7_6-2013-04-26-release:1.83
	sid-snapshot-20130401:1.84
	binutils-2_23_2:1.78
	gdb_7_6-branch:1.83.0.2
	gdb_7_6-2013-03-12-branchpoint:1.83
	sid-snapshot-20130301:1.83
	sid-snapshot-20130201:1.81
	sid-snapshot-20130101:1.80
	sid-snapshot-20121201:1.80
	gdb_7_5_1-2012-11-29-release:1.78
	binutils-2_23_1:1.78
	sid-snapshot-20121101:1.79
	binutils-2_23:1.78
	sid-snapshot-20121001:1.78
	sid-snapshot-20120901:1.78
	gdb_7_5-2012-08-17-release:1.78
	sid-snapshot-20120801:1.78
	binutils-2_23-branch:1.78.0.4
	binutils-2_23-branchpoint:1.78
	gdb_7_5-branch:1.78.0.2
	gdb_7_5-2012-07-18-branchpoint:1.78
	sid-snapshot-20120701:1.77
	sid-snapshot-20120601:1.76
	sid-snapshot-20120501:1.75
	binutils-2_22_branch:1.73.0.4
	gdb_7_4_1-2012-04-26-release:1.74
	sid-snapshot-20120401:1.74
	sid-snapshot-20120301:1.74
	sid-snapshot-20120201:1.74
	gdb_7_4-2012-01-24-release:1.74
	sid-snapshot-20120101:1.74
	gdb_7_4-branch:1.74.0.2
	gdb_7_4-2011-12-13-branchpoint:1.74
	sid-snapshot-20111201:1.74
	binutils-2_22:1.73
	sid-snapshot-20111101:1.74
	sid-snapshot-20111001:1.73
	binutils-2_22-branch:1.73.0.2
	binutils-2_22-branchpoint:1.73
	gdb_7_3_1-2011-09-04-release:1.72
	sid-snapshot-20110901:1.73
	sid-snapshot-20110801:1.73
	gdb_7_3-2011-07-26-release:1.72
	sid-snapshot-20110701:1.73
	sid-snapshot-20110601:1.73
	sid-snapshot-20110501:1.72
	gdb_7_3-branch:1.72.0.2
	gdb_7_3-2011-04-01-branchpoint:1.72
	sid-snapshot-20110401:1.72
	sid-snapshot-20110301:1.72
	sid-snapshot-20110201:1.71
	sid-snapshot-20110101:1.71
	binutils-2_21:1.71
	sid-snapshot-20101201:1.71
	binutils-2_21-branch:1.71.0.2
	binutils-2_21-branchpoint:1.71
	sid-snapshot-20101101:1.71
	sid-snapshot-20101001:1.69
	binutils-2_20_1:1.66
	gdb_7_2-2010-09-02-release:1.67
	sid-snapshot-20100901:1.69
	sid-snapshot-20100801:1.67
	gdb_7_2-branch:1.67.0.4
	gdb_7_2-2010-07-07-branchpoint:1.67
	sid-snapshot-20100701:1.67
	sid-snapshot-20100601:1.67
	sid-snapshot-20100501:1.67
	sid-snapshot-20100401:1.67
	gdb_7_1-2010-03-18-release:1.67
	sid-snapshot-20100301:1.67
	gdb_7_1-branch:1.67.0.2
	gdb_7_1-2010-02-18-branchpoint:1.67
	sid-snapshot-20100201:1.66
	sid-snapshot-20100101:1.66
	gdb_7_0_1-2009-12-22-release:1.66
	sid-snapshot-20091201:1.66
	sid-snapshot-20091101:1.66
	binutils-2_20:1.66
	gdb_7_0-2009-10-06-release:1.66
	sid-snapshot-20091001:1.66
	gdb_7_0-branch:1.66.0.4
	gdb_7_0-2009-09-16-branchpoint:1.66
	arc-sim-20090309:1.59
	binutils-arc-20081103-branch:1.63.0.12
	binutils-arc-20081103-branchpoint:1.63
	binutils-2_20-branch:1.66.0.2
	binutils-2_20-branchpoint:1.66
	sid-snapshot-20090901:1.65
	sid-snapshot-20090801:1.65
	msnyder-checkpoint-072509-branch:1.65.0.2
	msnyder-checkpoint-072509-branchpoint:1.65
	sid-snapshot-20090701:1.64
	dje-cgen-play1-branch:1.64.0.2
	dje-cgen-play1-branchpoint:1.64
	sid-snapshot-20090601:1.64
	sid-snapshot-20090501:1.63
	sid-snapshot-20090401:1.63
	arc-20081103-branch:1.63.0.10
	arc-20081103-branchpoint:1.63
	arc-insight_6_8-branch:1.59.0.6
	arc-insight_6_8-branchpoint:1.59
	insight_6_8-branch:1.59.0.4
	insight_6_8-branchpoint:1.59
	sid-snapshot-20090301:1.63
	binutils-2_19_1:1.63
	sid-snapshot-20090201:1.63
	sid-snapshot-20090101:1.63
	reverse-20081226-branch:1.63.0.8
	reverse-20081226-branchpoint:1.63
	sid-snapshot-20081201:1.63
	multiprocess-20081120-branch:1.63.0.6
	multiprocess-20081120-branchpoint:1.63
	sid-snapshot-20081101:1.63
	binutils-2_19:1.63
	sid-snapshot-20081001:1.63
	reverse-20080930-branch:1.63.0.4
	reverse-20080930-branchpoint:1.63
	binutils-2_19-branch:1.63.0.2
	binutils-2_19-branchpoint:1.63
	sid-snapshot-20080901:1.63
	sid-snapshot-20080801:1.63
	reverse-20080717-branch:1.61.0.4
	reverse-20080717-branchpoint:1.61
	sid-snapshot-20080701:1.61
	msnyder-reverse-20080609-branch:1.61.0.2
	msnyder-reverse-20080609-branchpoint:1.61
	drow-reverse-20070409-branch:1.51.0.2
	drow-reverse-20070409-branchpoint:1.51
	sid-snapshot-20080601:1.61
	sid-snapshot-20080501:1.59
	sid-snapshot-20080403:1.59
	sid-snapshot-20080401:1.59
	gdb_6_8-2008-03-27-release:1.59
	sid-snapshot-20080301:1.59
	gdb_6_8-branch:1.59.0.2
	gdb_6_8-2008-02-26-branchpoint:1.59
	sid-snapshot-20080201:1.59
	sid-snapshot-20080101:1.59
	sid-snapshot-20071201:1.58
	sid-snapshot-20071101:1.58
	gdb_6_7_1-2007-10-29-release:1.56
	gdb_6_7-2007-10-10-release:1.56
	sid-snapshot-20071001:1.58
	gdb_6_7-branch:1.56.0.4
	gdb_6_7-2007-09-07-branchpoint:1.56
	binutils-2_18:1.56
	binutils-2_18-branch:1.56.0.2
	binutils-2_18-branchpoint:1.56
	insight_6_6-20070208-release:1.49
	binutils-csl-coldfire-4_1-32:1.46
	binutils-csl-sourcerygxx-4_1-32:1.46
	gdb_6_6-2006-12-18-release:1.49
	binutils-csl-innovasic-fido-3_4_4-33:1.46
	binutils-csl-sourcerygxx-3_4_4-32:1.37
	binutils-csl-coldfire-4_1-30:1.46
	binutils-csl-sourcerygxx-4_1-30:1.46
	binutils-csl-coldfire-4_1-28:1.46
	binutils-csl-sourcerygxx-4_1-29:1.46
	binutils-csl-sourcerygxx-4_1-28:1.46
	gdb_6_6-branch:1.49.0.2
	gdb_6_6-2006-11-15-branchpoint:1.49
	binutils-csl-arm-2006q3-27:1.46
	binutils-csl-sourcerygxx-4_1-27:1.46
	binutils-csl-arm-2006q3-26:1.46
	binutils-csl-sourcerygxx-4_1-26:1.46
	binutils-csl-sourcerygxx-4_1-25:1.46
	binutils-csl-sourcerygxx-4_1-24:1.46
	binutils-csl-sourcerygxx-4_1-23:1.46
	insight_6_5-20061003-release:1.46
	gdb-csl-symbian-6_4_50_20060226-12:1.45
	binutils-csl-sourcerygxx-4_1-21:1.46
	binutils-csl-arm-2006q3-21:1.46
	binutils-csl-sourcerygxx-4_1-22:1.46
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.46
	binutils-csl-sourcerygxx-4_1-20:1.46
	binutils-csl-arm-2006q3-19:1.46
	binutils-csl-sourcerygxx-4_1-19:1.46
	binutils-csl-sourcerygxx-4_1-18:1.46
	binutils-csl-renesas-4_1-9:1.46
	gdb-csl-sourcerygxx-3_4_4-25:1.43
	binutils-csl-sourcerygxx-3_4_4-25:1.37
	nickrob-async-20060828-mergepoint:1.48
	gdb-csl-symbian-6_4_50_20060226-11:1.45
	binutils-csl-renesas-4_1-8:1.46
	binutils-csl-renesas-4_1-7:1.46
	binutils-csl-renesas-4_1-6:1.46
	gdb-csl-sourcerygxx-4_1-17:1.45
	binutils-csl-sourcerygxx-4_1-17:1.46
	gdb-csl-20060226-branch-local-2:1.45
	gdb-csl-sourcerygxx-4_1-14:1.45
	binutils-csl-sourcerygxx-4_1-14:1.46
	binutils-csl-sourcerygxx-4_1-15:1.46
	gdb-csl-sourcerygxx-4_1-13:1.45
	binutils-csl-sourcerygxx-4_1-13:1.46
	binutils-2_17:1.46
	gdb-csl-sourcerygxx-4_1-12:1.45
	binutils-csl-sourcerygxx-4_1-12:1.46
	gdb-csl-sourcerygxx-3_4_4-21:1.45
	binutils-csl-sourcerygxx-3_4_4-21:1.46
	gdb_6_5-20060621-release:1.46
	binutils-csl-wrs-linux-3_4_4-24:1.37
	binutils-csl-wrs-linux-3_4_4-23:1.37
	gdb-csl-sourcerygxx-4_1-9:1.45
	binutils-csl-sourcerygxx-4_1-9:1.46
	gdb-csl-sourcerygxx-4_1-8:1.45
	binutils-csl-sourcerygxx-4_1-8:1.46
	gdb-csl-sourcerygxx-4_1-7:1.45
	binutils-csl-sourcerygxx-4_1-7:1.46
	gdb-csl-arm-2006q1-6:1.45
	binutils-csl-arm-2006q1-6:1.46
	gdb-csl-sourcerygxx-4_1-6:1.45
	binutils-csl-sourcerygxx-4_1-6:1.46
	binutils-csl-wrs-linux-3_4_4-22:1.37
	gdb-csl-symbian-6_4_50_20060226-10:1.45
	gdb-csl-symbian-6_4_50_20060226-9:1.45
	gdb-csl-symbian-6_4_50_20060226-8:1.45
	gdb-csl-coldfire-4_1-11:1.45
	binutils-csl-coldfire-4_1-11:1.46
	gdb-csl-sourcerygxx-3_4_4-19:1.45
	binutils-csl-sourcerygxx-3_4_4-19:1.46
	gdb-csl-coldfire-4_1-10:1.45
	gdb_6_5-branch:1.46.0.14
	gdb_6_5-2006-05-14-branchpoint:1.46
	binutils-csl-coldfire-4_1-10:1.46
	gdb-csl-sourcerygxx-4_1-5:1.45
	binutils-csl-sourcerygxx-4_1-5:1.46
	nickrob-async-20060513-branch:1.46.0.12
	nickrob-async-20060513-branchpoint:1.46
	gdb-csl-sourcerygxx-4_1-4:1.45
	binutils-csl-sourcerygxx-4_1-4:1.46
	msnyder-reverse-20060502-branch:1.46.0.10
	msnyder-reverse-20060502-branchpoint:1.46
	binutils-csl-wrs-linux-3_4_4-21:1.37
	gdb-csl-morpho-4_1-4:1.45
	binutils-csl-morpho-4_1-4:1.46
	gdb-csl-sourcerygxx-3_4_4-17:1.45
	binutils-csl-sourcerygxx-3_4_4-17:1.46
	binutils-csl-wrs-linux-3_4_4-20:1.37
	readline_5_1-import-branch:1.46.0.8
	readline_5_1-import-branchpoint:1.46
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.45
	binutils-2_17-branch:1.46.0.6
	binutils-2_17-branchpoint:1.46
	gdb-csl-symbian-20060226-branch:1.45.0.6
	gdb-csl-symbian-20060226-branchpoint:1.45
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.45
	msnyder-reverse-20060331-branch:1.46.0.4
	msnyder-reverse-20060331-branchpoint:1.46
	binutils-csl-2_17-branch:1.46.0.2
	binutils-csl-2_17-branchpoint:1.46
	gdb-csl-available-20060303-branch:1.45.0.4
	gdb-csl-available-20060303-branchpoint:1.45
	gdb-csl-20060226-branch:1.45.0.2
	gdb-csl-20060226-branchpoint:1.45
	gdb_6_4-20051202-release:1.43
	msnyder-fork-checkpoint-branch:1.43.0.8
	msnyder-fork-checkpoint-branchpoint:1.43
	gdb-csl-gxxpro-6_3-branch:1.43.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.43
	gdb_6_4-branch:1.43.0.4
	gdb_6_4-2005-11-01-branchpoint:1.43
	gdb-csl-arm-20051020-branch:1.43.0.2
	gdb-csl-arm-20051020-branchpoint:1.43
	binutils-csl-gxxpro-3_4-branch:1.37.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.37
	binutils-2_16_1:1.37
	msnyder-tracepoint-checkpoint-branch:1.41.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.41
	gdb-csl-arm-20050325-2005-q1b:1.37
	binutils-csl-arm-2005q1b:1.37
	binutils-2_16:1.37
	gdb-csl-arm-20050325-2005-q1a:1.37
	binutils-csl-arm-2005q1a:1.37
	csl-arm-20050325-branch:1.37.0.6
	csl-arm-20050325-branchpoint:1.37
	binutils-csl-arm-2005q1-branch:1.37.0.4
	binutils-csl-arm-2005q1-branchpoint:1.37
	binutils-2_16-branch:1.37.0.2
	binutils-2_16-branchpoint:1.37
	csl-arm-2004-q3d:1.32
	gdb_6_3-20041109-release:1.31
	gdb_6_3-branch:1.31.0.2
	gdb_6_3-20041019-branchpoint:1.31
	csl-arm-2004-q3:1.30
	drow_intercu-merge-20040921:1.30
	drow_intercu-merge-20040915:1.28
	jimb-gdb_6_2-e500-branch:1.26.0.6
	jimb-gdb_6_2-e500-branchpoint:1.26
	gdb_6_2-20040730-release:1.26
	gdb_6_2-branch:1.26.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.26
	gdb_6_1_1-20040616-release:1.15
	binutils-2_15:1.12.4.5
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.21
	csl-arm-2004-q1:1.21
	gdb_6_1-2004-04-05-release:1.15
	drow_intercu-merge-20040402:1.21
	drow_intercu-merge-20040327:1.20
	ezannoni_pie-20040323-branch:1.18.0.2
	ezannoni_pie-20040323-branchpoint:1.18
	cagney_tramp-20040321-mergepoint:1.18
	cagney_tramp-20040309-branch:1.17.0.2
	cagney_tramp-20040309-branchpoint:1.17
	gdb_6_1-branch:1.15.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.15
	drow_intercu-20040221-branch:1.12.0.6
	drow_intercu-20040221-branchpoint:1.12
	binutils-2_15-branch:1.12.0.4
	cagney_bfdfile-20040213-branch:1.12.0.2
	cagney_bfdfile-20040213-branchpoint:1.12
	drow-cplus-merge-20040208:1.12
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.2
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	csl-arm-2003-q4:1.10
	drow-cplus-merge-20031224:1.10
	drow-cplus-merge-20031220:1.10
	carlton_dictionary-20031215-merge:1.10
	drow-cplus-merge-20031214:1.10
	carlton-dictionary-20031111-merge:1.10
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.7.0.4
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.2
	cagney_x86i386-20030821-branch:1.6.0.2
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.5.0.36
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.5
	binutils-2_14:1.5
	cagney_convert-20030606-branch:1.5.0.32
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.30
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.26
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	binutils-2_14-branch:1.5.0.22
	binutils-2_14-branchpoint:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.20
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.18
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.16
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.14
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.12
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.10
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.8
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.6
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.4
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.2
	cagney-unwind-20030108-branchpoint:1.5
	binutils-2_13_2_1:1.2
	binutils-2_13_2:1.2
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.3
	binutils-2_13_1:1.2
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.12
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.10
	carlton_dictionary-20020920-branchpoint:1.3
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.8
	gdb_5_3-branch:1.3.0.6
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.4
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.2
	readline_4_3-import-branchpoint:1.3
	binutils-2_13:1.2
	binutils-2_13-branchpoint:1.2
	binutils-2_13-branch:1.2.0.2
	cagney_regbuf-20020515-branch:1.1.0.4
	kseitz_interps-20020528-branch:1.1.0.2
	binutils_latest_snapshot:1.84;
locks; strict;
comment	@ * @;


1.84
date	2013.03.30.10.14.14;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2013.02.21.03.02.28;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2013.02.10.04.01.15;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.80;

1.80
date	2012.11.09.08.29.29;	author hjl;	state Exp;
branches;
next	1.79;

1.79
date	2012.10.23.09.33.54;	author nathan;	state Exp;
branches;
next	1.78;

1.78
date	2012.07.13.14.22.46;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2012.06.29.14.45.58;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2012.05.07.03.27.49;	author macro;	state Exp;
branches;
next	1.75;

1.75
date	2012.04.24.05.12.33;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2011.10.19.07.17.13;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2011.05.23.06.14.21;	author amodra;	state Exp;
branches
	1.73.2.1;
next	1.72;

1.72
date	2011.02.28.18.30.16;	author ktietz;	state Exp;
branches;
next	1.71;

1.71
date	2010.10.25.15.54.13;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2010.10.11.09.11.34;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2010.08.25.14.53.41;	author hjl;	state Exp;
branches;
next	1.68;

1.68
date	2010.08.18.12.24.05;	author palves;	state Exp;
branches;
next	1.67;

1.67
date	2010.02.04.09.16.39;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2009.07.10.15.26.56;	author tromey;	state Exp;
branches;
next	1.64;

1.64
date	2009.05.27.13.31.23;	author nathan;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2008.07.21.14.36.07;	author hjl;	state Exp;
branches;
next	1.61;

1.61
date	2008.05.21.12.01.36;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.15.17.00.13;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.31.11.01.54;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.28.08.43.45;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.26.13.45.31;	author jbeulich;	state Exp;
branches;
next	1.56;

1.56
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.29.16.29.15;	author jsm28;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.10.05.18.42;	author aoliva;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.08.06.09.30;	author aoliva;	state Exp;
branches;
next	1.52;

1.52
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2006.06.20.14.34.08;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2006.06.20.02.22.13;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2006.02.25.09.23.30;	author rsandifo;	state Exp;
branches;
next	1.44;

1.44
date	2006.02.17.18.08.00;	author kevinb;	state Exp;
branches;
next	1.43;

1.43
date	2005.08.15.15.39.08;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2005.06.20.18.12.06;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.07.02.55.54;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.05.14.33.45;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.04.15.53.12;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.04.07.19.22;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2005.02.17.17.10.58;	author aoliva;	state Exp;
branches;
next	1.36;

1.36
date	2005.02.16.02.38.53;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.07.07.59.34;	author aoliva;	state Exp;
branches;
next	1.34;

1.34
date	2005.01.31.23.13.19;	author bje;	state Exp;
branches;
next	1.33;

1.33
date	2005.01.25.20.22.22;	author aoliva;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.21.15.28.21;	author hjl;	state Exp;
branches;
next	1.31;

1.31
date	2004.10.10.13.58.05;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2004.09.17.07.14.26;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2004.09.16.14.52.03;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.13.03.15.57;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.21.06.46.20;	author aoliva;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.24.04.46.18;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.21.14.45.41;	author aoliva;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.08.07.05.32;	author aoliva;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.07.06.28.39;	author aoliva;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.06.02.46.29;	author aoliva;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.27.10.58.05;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.26.06.13.39;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.25.12.48.32;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.20.23.16.39;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.02.23.01.18;	author aoliva;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2004.03.01.10.11.38;	author rsandifo;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.28.00.35.45;	author aoliva;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.28.00.33.33;	author aoliva;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.24.16.39.01;	author aoliva;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.30.21.11.37;	author aoliva;	state Exp;
branches
	1.12.4.1
	1.12.6.1;
next	1.11;

1.11
date	2004.01.06.19.18.59;	author aoliva;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.05.13.17.08;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.08.17.57.59;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.07.19.17.23;	author aoliva;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.27.09.21.15;	author rsandifo;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.25.06.40.24;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.28.11.55.38;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.23.12.34.35;	author amodra;	state Exp;
branches
	1.3.10.1
	1.3.12.1;
next	1.2;

1.2
date	2002.07.01.08.06.43;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.18.21.10.54;	author brolley;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.73.2.1
date	2012.05.11.12.24.23;	author nickc;	state Exp;
branches;
next	;

1.17.2.1
date	2004.03.21.23.57.26;	author cagney;	state Exp;
branches;
next	;

1.12.4.1
date	2004.04.08.12.41.40;	author amodra;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2004.04.09.18.28.00;	author drow;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2004.05.06.01.58.12;	author aoliva;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2004.05.06.02.43.16;	author aoliva;	state Exp;
branches;
next	1.12.4.5;

1.12.4.5
date	2004.05.07.06.28.49;	author aoliva;	state Exp;
branches;
next	;

1.12.6.1
date	2004.03.27.17.37.32;	author drow;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2004.04.02.16.47.33;	author drow;	state Exp;
branches;
next	1.12.6.3;

1.12.6.3
date	2004.09.16.17.00.22;	author drow;	state Exp;
branches;
next	1.12.6.4;

1.12.6.4
date	2004.09.21.20.44.01;	author drow;	state Exp;
branches;
next	;

1.3.10.1
date	2002.12.23.19.37.39;	author carlton;	state Exp;
branches;
next	1.3.10.2;

1.3.10.2
date	2003.06.27.21.49.13;	author carlton;	state Exp;
branches;
next	1.3.10.3;

1.3.10.3
date	2003.09.17.21.27.50;	author carlton;	state Exp;
branches;
next	1.3.10.4;

1.3.10.4
date	2003.11.11.23.50.15;	author carlton;	state Exp;
branches;
next	1.3.10.5;

1.3.10.5
date	2004.01.26.19.11.04;	author carlton;	state Exp;
branches;
next	;

1.3.12.1
date	2003.12.14.20.26.39;	author drow;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2004.01.13.16.11.36;	author drow;	state Exp;
branches;
next	1.3.12.3;

1.3.12.3
date	2004.02.09.19.43.24;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2002.06.20.01.30.07;	author kseitz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.07.22.21.46.43;	author kseitz;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.08.09.18.34.13;	author kseitz;	state Exp;
branches;
next	;

1.1.4.1
date	2002.06.21.15.56.24;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.84
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@/* FRV-specific support for 32-bit ELF.
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/frv.h"
#include "dwarf2.h"
#include "hashtab.h"

/* Forward declarations.  */


static reloc_howto_type elf32_frv_howto_table [] =
{
  /* This reloc does nothing.  */
  HOWTO (R_FRV_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit absolute relocation.  */
  HOWTO (R_FRV_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit pc-relative relocation.  */
  HOWTO (R_FRV_LABEL16,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_LABEL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 24-bit pc-relative relocation.  */
  HOWTO (R_FRV_LABEL24,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_LABEL24",	/* name */
	 FALSE,			/* partial_inplace */
	 0x7e03ffff,		/* src_mask */
	 0x7e03ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_FRV_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_LO16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_FRV_HI16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_HI16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_FRV_GPREL12,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GPREL12",	/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_FRV_GPRELU12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GPRELU12",	/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0x3f03f,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_FRV_GPREL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GPREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_FRV_GPRELHI,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GPRELHI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_FRV_GPRELLO,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GPRELLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     the symbol.  */
  HOWTO (R_FRV_GOT12,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOT12",		/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTHI,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTHI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTLO,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTLO",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The 32-bit address of the canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOT12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOT12", /* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTHI,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTHI", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTLO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTLO", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The 64-bit descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_VALUE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_VALUE", /* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTOFF12, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTOFF12", /* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTOFFHI, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTOFFHI", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTOFFLO, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTOFFLO", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     the symbol.  */
  HOWTO (R_FRV_GOTOFF12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTOFF12",	/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTOFFHI,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTOFFHI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTOFFLO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTOFFLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 24-bit pc-relative relocation referencing the TLS PLT entry for
     a thread-local symbol.  If the symbol number is 0, it refers to
     the module.  */
  HOWTO (R_FRV_GETTLSOFF,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GETTLSOFF",	/* name */
	 FALSE,			/* partial_inplace */
	 0x7e03ffff,		/* src_mask */
	 0x7e03ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 64-bit TLS descriptor for a symbol.  This relocation is only
     valid as a REL, dynamic relocation.  */
  HOWTO (R_FRV_TLSDESC_VALUE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_TLSDESC_VALUE", /* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the TLS
     descriptor of the symbol.  */
  HOWTO (R_FRV_GOTTLSDESC12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTTLSDESC12",	/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the TLS descriptor of the
     symbol.  */
  HOWTO (R_FRV_GOTTLSDESCHI,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTTLSDESCHI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the TLS descriptor of the
     symbol.  */
  HOWTO (R_FRV_GOTTLSDESCLO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTTLSDESCLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the offset from the module base
     address to the thread-local symbol address.  */
  HOWTO (R_FRV_TLSMOFF12,	 /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_TLSMOFF12",	/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The upper 16 bits of the offset from the module base address to
     the thread-local symbol address.  */
  HOWTO (R_FRV_TLSMOFFHI,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_TLSMOFFHI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The lower 16 bits of the offset from the module base address to
     the thread-local symbol address.  */
  HOWTO (R_FRV_TLSMOFFLO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_TLSMOFFLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the TLSOFF entry
     for a symbol.  */
  HOWTO (R_FRV_GOTTLSOFF12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTTLSOFF12",	/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the TLSOFF entry for a
     symbol.  */
  HOWTO (R_FRV_GOTTLSOFFHI,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTTLSOFFHI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the TLSOFF entry for a
     symbol.  */
  HOWTO (R_FRV_GOTTLSOFFLO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTTLSOFFLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The 32-bit offset from the thread pointer (not the module base
     address) to a thread-local symbol.  */
  HOWTO (R_FRV_TLSOFF,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_TLSOFF",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An annotation for linker relaxation, that denotes the
     symbol+addend whose TLS descriptor is referenced by the sum of
     the two input registers of an ldd instruction.  */
  HOWTO (R_FRV_TLSDESC_RELAX,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_TLSDESC_RELAX",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An annotation for linker relaxation, that denotes the
     symbol+addend whose TLS resolver entry point is given by the sum
     of the two register operands of an calll instruction.  */
  HOWTO (R_FRV_GETTLSOFF_RELAX,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GETTLSOFF_RELAX", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An annotation for linker relaxation, that denotes the
     symbol+addend whose TLS offset GOT entry is given by the sum of
     the two input registers of an ld instruction.  */
  HOWTO (R_FRV_TLSOFF_RELAX,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_TLSOFF_RELAX",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32-bit offset from the module base address to
     the thread-local symbol address.  */
  HOWTO (R_FRV_TLSMOFF,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_TLSMOFF",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* GNU extension to record C++ vtable hierarchy.  */
static reloc_howto_type elf32_frv_vtinherit_howto =
  HOWTO (R_FRV_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_FRV_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage.  */
static reloc_howto_type elf32_frv_vtentry_howto =
  HOWTO (R_FRV_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
	 "R_FRV_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* The following 3 relocations are REL.  The only difference to the
   entries in the table above are that partial_inplace is TRUE.  */
static reloc_howto_type elf32_frv_rel_32_howto =
  HOWTO (R_FRV_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

static reloc_howto_type elf32_frv_rel_funcdesc_howto =
  HOWTO (R_FRV_FUNCDESC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

static reloc_howto_type elf32_frv_rel_funcdesc_value_howto =
  HOWTO (R_FRV_FUNCDESC_VALUE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_VALUE", /* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

static reloc_howto_type elf32_frv_rel_tlsdesc_value_howto =
  /* A 64-bit TLS descriptor for a symbol.  The first word resolves to
     an entry point, and the second resolves to a special argument.
     If the symbol turns out to be in static TLS, the entry point is a
     return instruction, and the special argument is the TLS offset
     for the symbol.  If it's in dynamic TLS, the entry point is a TLS
     offset resolver, and the special argument is a pointer to a data
     structure allocated by the dynamic loader, containing the GOT
     address for the offset resolver, the module id, the offset within
     the module, and anything else the TLS offset resolver might need
     to determine the TLS offset for the symbol in the running
     thread.  */
  HOWTO (R_FRV_TLSDESC_VALUE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_TLSDESC_VALUE", /* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

static reloc_howto_type elf32_frv_rel_tlsoff_howto =
  /* The 32-bit offset from the thread pointer (not the module base
     address) to a thread-local symbol.  */
  HOWTO (R_FRV_TLSOFF,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_TLSOFF",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */



extern const bfd_target bfd_elf32_frvfdpic_vec;
#define IS_FDPIC(bfd) ((bfd)->xvec == &bfd_elf32_frvfdpic_vec)

/* An extension of the elf hash table data structure, containing some
   additional FRV-specific data.  */
struct frvfdpic_elf_link_hash_table
{
  struct elf_link_hash_table elf;

  /* A pointer to the .got section.  */
  asection *sgot;
  /* A pointer to the .rel.got section.  */
  asection *sgotrel;
  /* A pointer to the .rofixup section.  */
  asection *sgotfixup;
  /* A pointer to the .plt section.  */
  asection *splt;
  /* A pointer to the .rel.plt section.  */
  asection *spltrel;
  /* GOT base offset.  */
  bfd_vma got0;
  /* Location of the first non-lazy PLT entry, i.e., the number of
     bytes taken by lazy PLT entries.  If locally-bound TLS
     descriptors require a ret instruction, it will be placed at this
     offset.  */
  bfd_vma plt0;
  /* A hash table holding information about which symbols were
     referenced with which PIC-related relocations.  */
  struct htab *relocs_info;
  /* Summary reloc information collected by
     _frvfdpic_count_got_plt_entries.  */
  struct _frvfdpic_dynamic_got_info *g;
};

/* Get the FRV ELF linker hash table from a link_info structure.  */

#define frvfdpic_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == FRV_ELF_DATA ? ((struct frvfdpic_elf_link_hash_table *) ((p)->hash)) : NULL)

#define frvfdpic_got_section(info) \
  (frvfdpic_hash_table (info)->sgot)
#define frvfdpic_gotrel_section(info) \
  (frvfdpic_hash_table (info)->sgotrel)
#define frvfdpic_gotfixup_section(info) \
  (frvfdpic_hash_table (info)->sgotfixup)
#define frvfdpic_plt_section(info) \
  (frvfdpic_hash_table (info)->splt)
#define frvfdpic_pltrel_section(info) \
  (frvfdpic_hash_table (info)->spltrel)
#define frvfdpic_relocs_info(info) \
  (frvfdpic_hash_table (info)->relocs_info)
#define frvfdpic_got_initial_offset(info) \
  (frvfdpic_hash_table (info)->got0)
#define frvfdpic_plt_initial_offset(info) \
  (frvfdpic_hash_table (info)->plt0)
#define frvfdpic_dynamic_got_plt_info(info) \
  (frvfdpic_hash_table (info)->g)

/* Currently it's the same, but if some day we have a reason to change
   it, we'd better be using a different macro.

   FIXME: if there's any TLS PLT entry that uses local-exec or
   initial-exec models, we could use the ret at the end of any of them
   instead of adding one more.  */
#define frvfdpic_plt_tls_ret_offset(info) \
  (frvfdpic_plt_initial_offset (info))

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so.1"

#define DEFAULT_STACK_SIZE 0x20000

/* This structure is used to collect the number of entries present in
   each addressable range of the got.  */
struct _frvfdpic_dynamic_got_info
{
  /* Several bits of information about the current link.  */
  struct bfd_link_info *info;
  /* Total GOT size needed for GOT entries within the 12-, 16- or 32-bit
     ranges.  */
  bfd_vma got12, gotlos, gothilo;
  /* Total GOT size needed for function descriptor entries within the 12-,
     16- or 32-bit ranges.  */
  bfd_vma fd12, fdlos, fdhilo;
  /* Total GOT size needed by function descriptor entries referenced
     in PLT entries, that would be profitable to place in offsets
     close to the PIC register.  */
  bfd_vma fdplt;
  /* Total PLT size needed by lazy PLT entries.  */
  bfd_vma lzplt;
  /* Total GOT size needed for TLS descriptor entries within the 12-,
     16- or 32-bit ranges.  */
  bfd_vma tlsd12, tlsdlos, tlsdhilo;
  /* Total GOT size needed by TLS descriptors referenced in PLT
     entries, that would be profitable to place in offers close to the
     PIC register.  */
  bfd_vma tlsdplt;
  /* Total PLT size needed by TLS lazy PLT entries.  */
  bfd_vma tlslzplt;
  /* Number of relocations carried over from input object files.  */
  unsigned long relocs;
  /* Number of fixups introduced by relocations in input object files.  */
  unsigned long fixups;
  /* The number of fixups that reference the ret instruction added to
     the PLT for locally-resolved TLS descriptors.  */
  unsigned long tls_ret_refs;
};

/* This structure is used to assign offsets to got entries, function
   descriptors, plt entries and lazy plt entries.  */

struct _frvfdpic_dynamic_got_plt_info
{
  /* Summary information collected with _frvfdpic_count_got_plt_entries.  */
  struct _frvfdpic_dynamic_got_info g;

  /* For each addressable range, we record a MAX (positive) and MIN
     (negative) value.  CUR is used to assign got entries, and it's
     incremented from an initial positive value to MAX, then from MIN
     to FDCUR (unless FDCUR wraps around first).  FDCUR is used to
     assign function descriptors, and it's decreased from an initial
     non-positive value to MIN, then from MAX down to CUR (unless CUR
     wraps around first).  All of MIN, MAX, CUR and FDCUR always point
     to even words.  ODD, if non-zero, indicates an odd word to be
     used for the next got entry, otherwise CUR is used and
     incremented by a pair of words, wrapping around when it reaches
     MAX.  FDCUR is decremented (and wrapped) before the next function
     descriptor is chosen.  FDPLT indicates the number of remaining
     slots that can be used for function descriptors used only by PLT
     entries.

     TMAX, TMIN and TCUR are used to assign TLS descriptors.  TCUR
     starts as MAX, and grows up to TMAX, then wraps around to TMIN
     and grows up to MIN.  TLSDPLT indicates the number of remaining
     slots that can be used for TLS descriptors used only by TLS PLT
     entries.  */
  struct _frvfdpic_dynamic_got_alloc_data
  {
    bfd_signed_vma max, cur, odd, fdcur, min;
    bfd_signed_vma tmax, tcur, tmin;
    bfd_vma fdplt, tlsdplt;
  } got12, gotlos, gothilo;
};

/* Create an FRV ELF linker hash table.  */

static struct bfd_link_hash_table *
frvfdpic_elf_link_hash_table_create (bfd *abfd)
{
  struct frvfdpic_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct frvfdpic_elf_link_hash_table);

  ret = bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd,
				      _bfd_elf_link_hash_newfunc,
				      sizeof (struct elf_link_hash_entry),
				      FRV_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  return &ret->elf.root;
}

/* Decide whether a reference to a symbol can be resolved locally or
   not.  If the symbol is protected, we want the local address, but
   its function descriptor must be assigned by the dynamic linker.  */
#define FRVFDPIC_SYM_LOCAL(INFO, H) \
  (_bfd_elf_symbol_refs_local_p ((H), (INFO), 1) \
   || ! elf_hash_table (INFO)->dynamic_sections_created)
#define FRVFDPIC_FUNCDESC_LOCAL(INFO, H) \
  ((H)->dynindx == -1 || ! elf_hash_table (INFO)->dynamic_sections_created)

/* This structure collects information on what kind of GOT, PLT or
   function descriptors are required by relocations that reference a
   certain symbol.  */
struct frvfdpic_relocs_info
{
  /* The index of the symbol, as stored in the relocation r_info, if
     we have a local symbol; -1 otherwise.  */
  long symndx;
  union
  {
    /* The input bfd in which the symbol is defined, if it's a local
       symbol.  */
    bfd *abfd;
    /* If symndx == -1, the hash table entry corresponding to a global
       symbol (even if it turns out to bind locally, in which case it
       should ideally be replaced with section's symndx + addend).  */
    struct elf_link_hash_entry *h;
  } d;
  /* The addend of the relocation that references the symbol.  */
  bfd_vma addend;

  /* The fields above are used to identify an entry.  The fields below
     contain information on how an entry is used and, later on, which
     locations it was assigned.  */
  /* The following 3 fields record whether the symbol+addend above was
     ever referenced with a GOT relocation.  The 12 suffix indicates a
     GOT12 relocation; los is used for GOTLO relocations that are not
     matched by a GOTHI relocation; hilo is used for GOTLO/GOTHI
     pairs.  */
  unsigned got12:1;
  unsigned gotlos:1;
  unsigned gothilo:1;
  /* Whether a FUNCDESC relocation references symbol+addend.  */
  unsigned fd:1;
  /* Whether a FUNCDESC_GOT relocation references symbol+addend.  */
  unsigned fdgot12:1;
  unsigned fdgotlos:1;
  unsigned fdgothilo:1;
  /* Whether a FUNCDESC_GOTOFF relocation references symbol+addend.  */
  unsigned fdgoff12:1;
  unsigned fdgofflos:1;
  unsigned fdgoffhilo:1;
  /* Whether a GETTLSOFF relocation references symbol+addend.  */
  unsigned tlsplt:1;
  /* FIXME: we should probably add tlspltdesc, tlspltoff and
     tlspltimm, to tell what kind of TLS PLT entry we're generating.
     We might instead just pre-compute flags telling whether the
     object is suitable for local exec, initial exec or general
     dynamic addressing, and use that all over the place.  We could
     also try to do a better job of merging TLSOFF and TLSDESC entries
     in main executables, but perhaps we can get rid of TLSDESC
     entirely in them instead.  */
  /* Whether a GOTTLSDESC relocation references symbol+addend.  */
  unsigned tlsdesc12:1;
  unsigned tlsdesclos:1;
  unsigned tlsdeschilo:1;
  /* Whether a GOTTLSOFF relocation references symbol+addend.  */
  unsigned tlsoff12:1;
  unsigned tlsofflos:1;
  unsigned tlsoffhilo:1;
  /* Whether symbol+addend is referenced with GOTOFF12, GOTOFFLO or
     GOTOFFHI relocations.  The addend doesn't really matter, since we
     envision that this will only be used to check whether the symbol
     is mapped to the same segment as the got.  */
  unsigned gotoff:1;
  /* Whether symbol+addend is referenced by a LABEL24 relocation.  */
  unsigned call:1;
  /* Whether symbol+addend is referenced by a 32 or FUNCDESC_VALUE
     relocation.  */
  unsigned sym:1;
  /* Whether we need a PLT entry for a symbol.  Should be implied by
     something like:
     (call && symndx == -1 && ! FRVFDPIC_SYM_LOCAL (info, d.h))  */
  unsigned plt:1;
  /* Whether a function descriptor should be created in this link unit
     for symbol+addend.  Should be implied by something like:
     (plt || fdgotoff12 || fdgotofflos || fdgotofflohi
      || ((fd || fdgot12 || fdgotlos || fdgothilo)
          && (symndx != -1 || FRVFDPIC_FUNCDESC_LOCAL (info, d.h))))  */
  unsigned privfd:1;
  /* Whether a lazy PLT entry is needed for this symbol+addend.
     Should be implied by something like:
     (privfd && symndx == -1 && ! FRVFDPIC_SYM_LOCAL (info, d.h)
      && ! (info->flags & DF_BIND_NOW))  */
  unsigned lazyplt:1;
  /* Whether we've already emitted GOT relocations and PLT entries as
     needed for this symbol.  */
  unsigned done:1;

  /* The number of R_FRV_32, R_FRV_FUNCDESC, R_FRV_FUNCDESC_VALUE and
     R_FRV_TLSDESC_VALUE, R_FRV_TLSOFF relocations referencing
     symbol+addend.  */
  unsigned relocs32, relocsfd, relocsfdv, relocstlsd, relocstlsoff;

  /* The number of .rofixups entries and dynamic relocations allocated
     for this symbol, minus any that might have already been used.  */
  unsigned fixups, dynrelocs;

  /* The offsets of the GOT entries assigned to symbol+addend, to the
     function descriptor's address, and to a function descriptor,
     respectively.  Should be zero if unassigned.  The offsets are
     counted from the value that will be assigned to the PIC register,
     not from the beginning of the .got section.  */
  bfd_signed_vma got_entry, fdgot_entry, fd_entry;
  /* The offsets of the PLT entries assigned to symbol+addend,
     non-lazy and lazy, respectively.  If unassigned, should be
     (bfd_vma)-1.  */
  bfd_vma plt_entry, lzplt_entry;
  /* The offsets of the GOT entries for TLS offset and TLS descriptor.  */
  bfd_signed_vma tlsoff_entry, tlsdesc_entry;
  /* The offset of the TLS offset PLT entry.  */
  bfd_vma tlsplt_entry;
};

/* Compute a hash with the key fields of an frvfdpic_relocs_info entry.  */
static hashval_t
frvfdpic_relocs_info_hash (const void *entry_)
{
  const struct frvfdpic_relocs_info *entry = entry_;

  return (entry->symndx == -1
	  ? (long) entry->d.h->root.root.hash
	  : entry->symndx + (long) entry->d.abfd->id * 257) + entry->addend;
}

/* Test whether the key fields of two frvfdpic_relocs_info entries are
   identical.  */
static int
frvfdpic_relocs_info_eq (const void *entry1, const void *entry2)
{
  const struct frvfdpic_relocs_info *e1 = entry1;
  const struct frvfdpic_relocs_info *e2 = entry2;

  return e1->symndx == e2->symndx && e1->addend == e2->addend
    && (e1->symndx == -1 ? e1->d.h == e2->d.h : e1->d.abfd == e2->d.abfd);
}

/* Find or create an entry in a hash table HT that matches the key
   fields of the given ENTRY.  If it's not found, memory for a new
   entry is allocated in ABFD's obstack.  */
static struct frvfdpic_relocs_info *
frvfdpic_relocs_info_find (struct htab *ht,
			   bfd *abfd,
			   const struct frvfdpic_relocs_info *entry,
			   enum insert_option insert)
{
  struct frvfdpic_relocs_info **loc =
    (struct frvfdpic_relocs_info **) htab_find_slot (ht, entry, insert);

  if (! loc)
    return NULL;

  if (*loc)
    return *loc;

  *loc = bfd_zalloc (abfd, sizeof (**loc));

  if (! *loc)
    return *loc;

  (*loc)->symndx = entry->symndx;
  (*loc)->d = entry->d;
  (*loc)->addend = entry->addend;
  (*loc)->plt_entry = (bfd_vma)-1;
  (*loc)->lzplt_entry = (bfd_vma)-1;
  (*loc)->tlsplt_entry = (bfd_vma)-1;

  return *loc;
}

/* Obtain the address of the entry in HT associated with H's symbol +
   addend, creating a new entry if none existed.  ABFD is only used
   for memory allocation purposes.  */
inline static struct frvfdpic_relocs_info *
frvfdpic_relocs_info_for_global (struct htab *ht,
				 bfd *abfd,
				 struct elf_link_hash_entry *h,
				 bfd_vma addend,
				 enum insert_option insert)
{
  struct frvfdpic_relocs_info entry;

  entry.symndx = -1;
  entry.d.h = h;
  entry.addend = addend;

  return frvfdpic_relocs_info_find (ht, abfd, &entry, insert);
}

/* Obtain the address of the entry in HT associated with the SYMNDXth
   local symbol of the input bfd ABFD, plus the addend, creating a new
   entry if none existed.  */
inline static struct frvfdpic_relocs_info *
frvfdpic_relocs_info_for_local (struct htab *ht,
				bfd *abfd,
				long symndx,
				bfd_vma addend,
				enum insert_option insert)
{
  struct frvfdpic_relocs_info entry;

  entry.symndx = symndx;
  entry.d.abfd = abfd;
  entry.addend = addend;

  return frvfdpic_relocs_info_find (ht, abfd, &entry, insert);
}

/* Merge fields set by check_relocs() of two entries that end up being
   mapped to the same (presumably global) symbol.  */

inline static void
frvfdpic_pic_merge_early_relocs_info (struct frvfdpic_relocs_info *e2,
				      struct frvfdpic_relocs_info const *e1)
{
  e2->got12 |= e1->got12;
  e2->gotlos |= e1->gotlos;
  e2->gothilo |= e1->gothilo;
  e2->fd |= e1->fd;
  e2->fdgot12 |= e1->fdgot12;
  e2->fdgotlos |= e1->fdgotlos;
  e2->fdgothilo |= e1->fdgothilo;
  e2->fdgoff12 |= e1->fdgoff12;
  e2->fdgofflos |= e1->fdgofflos;
  e2->fdgoffhilo |= e1->fdgoffhilo;
  e2->tlsplt |= e1->tlsplt;
  e2->tlsdesc12 |= e1->tlsdesc12;
  e2->tlsdesclos |= e1->tlsdesclos;
  e2->tlsdeschilo |= e1->tlsdeschilo;
  e2->tlsoff12 |= e1->tlsoff12;
  e2->tlsofflos |= e1->tlsofflos;
  e2->tlsoffhilo |= e1->tlsoffhilo;
  e2->gotoff |= e1->gotoff;
  e2->call |= e1->call;
  e2->sym |= e1->sym;
}

/* Every block of 65535 lazy PLT entries shares a single call to the
   resolver, inserted in the 32768th lazy PLT entry (i.e., entry #
   32767, counting from 0).  All other lazy PLT entries branch to it
   in a single instruction.  */

#define FRVFDPIC_LZPLT_BLOCK_SIZE ((bfd_vma) 8 * 65535 + 4)
#define FRVFDPIC_LZPLT_RESOLV_LOC (8 * 32767)

/* Add a dynamic relocation to the SRELOC section.  */

inline static bfd_vma
_frvfdpic_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
			 int reloc_type, long dynindx, bfd_vma addend,
			 struct frvfdpic_relocs_info *entry)
{
  Elf_Internal_Rela outrel;
  bfd_vma reloc_offset;

  outrel.r_offset = offset;
  outrel.r_info = ELF32_R_INFO (dynindx, reloc_type);
  outrel.r_addend = addend;

  reloc_offset = sreloc->reloc_count * sizeof (Elf32_External_Rel);
  BFD_ASSERT (reloc_offset < sreloc->size);
  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
			    sreloc->contents + reloc_offset);
  sreloc->reloc_count++;

  /* If the entry's index is zero, this relocation was probably to a
     linkonce section that got discarded.  We reserved a dynamic
     relocation, but it was for another entry than the one we got at
     the time of emitting the relocation.  Unfortunately there's no
     simple way for us to catch this situation, since the relocation
     is cleared right before calling relocate_section, at which point
     we no longer know what the relocation used to point to.  */
  if (entry->symndx)
    {
      BFD_ASSERT (entry->dynrelocs > 0);
      entry->dynrelocs--;
    }

  return reloc_offset;
}

/* Add a fixup to the ROFIXUP section.  */

static bfd_vma
_frvfdpic_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset,
		       struct frvfdpic_relocs_info *entry)
{
  bfd_vma fixup_offset;

  if (rofixup->flags & SEC_EXCLUDE)
    return -1;

  fixup_offset = rofixup->reloc_count * 4;
  if (rofixup->contents)
    {
      BFD_ASSERT (fixup_offset < rofixup->size);
      bfd_put_32 (output_bfd, offset, rofixup->contents + fixup_offset);
    }
  rofixup->reloc_count++;

  if (entry && entry->symndx)
    {
      /* See discussion about symndx == 0 in _frvfdpic_add_dyn_reloc
	 above.  */
      BFD_ASSERT (entry->fixups > 0);
      entry->fixups--;
    }

  return fixup_offset;
}

/* Find the segment number in which OSEC, and output section, is
   located.  */

static unsigned
_frvfdpic_osec_to_segment (bfd *output_bfd, asection *osec)
{
  Elf_Internal_Phdr *p = _bfd_elf_find_segment_containing_section (output_bfd, osec);

  return (p != NULL) ? p - elf_tdata (output_bfd)->phdr : -1;
}

inline static bfd_boolean
_frvfdpic_osec_readonly_p (bfd *output_bfd, asection *osec)
{
  unsigned seg = _frvfdpic_osec_to_segment (output_bfd, osec);

  return ! (elf_tdata (output_bfd)->phdr[seg].p_flags & PF_W);
}

#define FRVFDPIC_TLS_BIAS (2048 - 16)

/* Return the base VMA address which should be subtracted from real addresses
   when resolving TLSMOFF relocation.
   This is PT_TLS segment p_vaddr, plus the 2048-16 bias.  */

static bfd_vma
tls_biased_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return FRVFDPIC_TLS_BIAS;
  return elf_hash_table (info)->tls_sec->vma + FRVFDPIC_TLS_BIAS;
}

/* Generate relocations for GOT entries, function descriptors, and
   code for PLT and lazy PLT entries.  */

inline static bfd_boolean
_frvfdpic_emit_got_relocs_plt_entries (struct frvfdpic_relocs_info *entry,
				       bfd *output_bfd,
				       struct bfd_link_info *info,
				       asection *sec,
				       Elf_Internal_Sym *sym,
				       bfd_vma addend)

{
  bfd_vma fd_lazy_rel_offset = (bfd_vma)-1;
  int dynindx = -1;

  if (entry->done)
    return TRUE;
  entry->done = 1;

  if (entry->got_entry || entry->fdgot_entry || entry->fd_entry
      || entry->tlsoff_entry || entry->tlsdesc_entry)
    {
      /* If the symbol is dynamic, consider it for dynamic
	 relocations, otherwise decay to section + offset.  */
      if (entry->symndx == -1 && entry->d.h->dynindx != -1)
	dynindx = entry->d.h->dynindx;
      else
	{
	  if (sec
	      && sec->output_section
	      && ! bfd_is_abs_section (sec->output_section)
	      && ! bfd_is_und_section (sec->output_section))
	    dynindx = elf_section_data (sec->output_section)->dynindx;
	  else
	    dynindx = 0;
	}
    }

  /* Generate relocation for GOT entry pointing to the symbol.  */
  if (entry->got_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;

      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1
		  || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}

      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1
	      || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma;
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    _frvfdpic_add_rofixup (output_bfd,
				   frvfdpic_gotfixup_section (info),
				   frvfdpic_got_section (info)->output_section
				   ->vma
				   + frvfdpic_got_section (info)->output_offset
				   + frvfdpic_got_initial_offset (info)
				   + entry->got_entry, entry);
	}
      else
	_frvfdpic_add_dyn_reloc (output_bfd, frvfdpic_gotrel_section (info),
				 _bfd_elf_section_offset
				 (output_bfd, info,
				  frvfdpic_got_section (info),
				  frvfdpic_got_initial_offset (info)
				  + entry->got_entry)
				 + frvfdpic_got_section (info)
				 ->output_section->vma
				 + frvfdpic_got_section (info)->output_offset,
				 R_FRV_32, idx, ad, entry);

      bfd_put_32 (output_bfd, ad,
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
		  + entry->got_entry);
    }

  /* Generate relocation for GOT entry pointing to a canonical
     function descriptor.  */
  if (entry->fdgot_entry)
    {
      int reloc, idx;
      bfd_vma ad = 0;

      if (! (entry->symndx == -1
	     && entry->d.h->root.type == bfd_link_hash_undefweak
	     && FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  /* If the symbol is dynamic and there may be dynamic symbol
	     resolution because we are, or are linked with, a shared
	     library, emit a FUNCDESC relocation such that the dynamic
	     linker will allocate the function descriptor.  If the
	     symbol needs a non-local function descriptor but binds
	     locally (e.g., its visibility is protected, emit a
	     dynamic relocation decayed to section+offset.  */
	  if (entry->symndx == -1
	      && ! FRVFDPIC_FUNCDESC_LOCAL (info, entry->d.h)
	      && FRVFDPIC_SYM_LOCAL (info, entry->d.h)
	      && !(info->executable && !info->pie))
	    {
	      reloc = R_FRV_FUNCDESC;
	      idx = elf_section_data (entry->d.h->root.u.def.section
				      ->output_section)->dynindx;
	      ad = entry->d.h->root.u.def.section->output_offset
		+ entry->d.h->root.u.def.value;
	    }
	  else if (entry->symndx == -1
		   && ! FRVFDPIC_FUNCDESC_LOCAL (info, entry->d.h))
	    {
	      reloc = R_FRV_FUNCDESC;
	      idx = dynindx;
	      ad = addend;
	      if (ad)
		{
		  (*info->callbacks->reloc_dangerous)
		    (info, _("relocation requires zero addend"),
		     elf_hash_table (info)->dynobj,
		     frvfdpic_got_section (info),
		     entry->fdgot_entry);
		  return FALSE;
		}
	    }
	  else
	    {
	      /* Otherwise, we know we have a private function descriptor,
		 so reference it directly.  */
	      if (elf_hash_table (info)->dynamic_sections_created)
		BFD_ASSERT (entry->privfd);
	      reloc = R_FRV_32;
	      idx = elf_section_data (frvfdpic_got_section (info)
				      ->output_section)->dynindx;
	      ad = frvfdpic_got_section (info)->output_offset
		+ frvfdpic_got_initial_offset (info) + entry->fd_entry;
	    }

	  /* If there is room for dynamic symbol resolution, emit the
	     dynamic relocation.  However, if we're linking an
	     executable at a fixed location, we won't have emitted a
	     dynamic symbol entry for the got section, so idx will be
	     zero, which means we can and should compute the address
	     of the private descriptor ourselves.  */
	  if (info->executable && !info->pie
	      && (entry->symndx != -1
		  || FRVFDPIC_FUNCDESC_LOCAL (info, entry->d.h)))
	    {
	      ad += frvfdpic_got_section (info)->output_section->vma;
	      _frvfdpic_add_rofixup (output_bfd,
				     frvfdpic_gotfixup_section (info),
				     frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset
				     + frvfdpic_got_initial_offset (info)
				     + entry->fdgot_entry, entry);
	    }
	  else
	    _frvfdpic_add_dyn_reloc (output_bfd,
				     frvfdpic_gotrel_section (info),
				     _bfd_elf_section_offset
				     (output_bfd, info,
				      frvfdpic_got_section (info),
				      frvfdpic_got_initial_offset (info)
				      + entry->fdgot_entry)
				     + frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset,
				     reloc, idx, ad, entry);
	}

      bfd_put_32 (output_bfd, ad,
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
		  + entry->fdgot_entry);
    }

  /* Generate relocation to fill in a private function descriptor in
     the GOT.  */
  if (entry->fd_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;
      bfd_vma ofst;
      long lowword, highword;

      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1
		  || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}

      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1 || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma;
	  ofst = 0;
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    {
	      _frvfdpic_add_rofixup (output_bfd,
				     frvfdpic_gotfixup_section (info),
				     frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset
				     + frvfdpic_got_initial_offset (info)
				     + entry->fd_entry, entry);
	      _frvfdpic_add_rofixup (output_bfd,
				     frvfdpic_gotfixup_section (info),
				     frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset
				     + frvfdpic_got_initial_offset (info)
				     + entry->fd_entry + 4, entry);
	    }
	}
      else
	{
	  ofst =
	    _frvfdpic_add_dyn_reloc (output_bfd,
				     entry->lazyplt
				     ? frvfdpic_pltrel_section (info)
				     : frvfdpic_gotrel_section (info),
				     _bfd_elf_section_offset
				     (output_bfd, info,
				      frvfdpic_got_section (info),
				      frvfdpic_got_initial_offset (info)
				      + entry->fd_entry)
				     + frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset,
				     R_FRV_FUNCDESC_VALUE, idx, ad, entry);
	}

      /* If we've omitted the dynamic relocation, just emit the fixed
	 addresses of the symbol and of the local GOT base offset.  */
      if (info->executable && !info->pie && sec && sec->output_section)
	{
	  lowword = ad;
	  highword = frvfdpic_got_section (info)->output_section->vma
	    + frvfdpic_got_section (info)->output_offset
	    + frvfdpic_got_initial_offset (info);
	}
      else if (entry->lazyplt)
	{
	  if (ad)
	    {
	      (*info->callbacks->reloc_dangerous)
		(info, _("relocation requires zero addend"),
		 elf_hash_table (info)->dynobj,
		 frvfdpic_got_section (info),
		 entry->fd_entry);
	      return FALSE;
	    }

	  fd_lazy_rel_offset = ofst;

	  /* A function descriptor used for lazy or local resolving is
	     initialized such that its high word contains the output
	     section index in which the PLT entries are located, and
	     the low word contains the address of the lazy PLT entry
	     entry point, that must be within the memory region
	     assigned to that section.  */
	  lowword = entry->lzplt_entry + 4
	    + frvfdpic_plt_section (info)->output_offset
	    + frvfdpic_plt_section (info)->output_section->vma;
	  highword = _frvfdpic_osec_to_segment
	    (output_bfd, frvfdpic_plt_section (info)->output_section);
	}
      else
	{
	  /* A function descriptor for a local function gets the index
	     of the section.  For a non-local function, it's
	     disregarded.  */
	  lowword = ad;
	  if (sec == NULL
	      || (entry->symndx == -1 && entry->d.h->dynindx != -1
		  && entry->d.h->dynindx == idx))
	    highword = 0;
	  else
	    highword = _frvfdpic_osec_to_segment
	      (output_bfd, sec->output_section);
	}

      bfd_put_32 (output_bfd, lowword,
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
		  + entry->fd_entry);
      bfd_put_32 (output_bfd, highword,
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
		  + entry->fd_entry + 4);
    }

  /* Generate code for the PLT entry.  */
  if (entry->plt_entry != (bfd_vma) -1)
    {
      bfd_byte *plt_code = frvfdpic_plt_section (info)->contents
	+ entry->plt_entry;

      BFD_ASSERT (entry->fd_entry);

      /* Figure out what kind of PLT entry we need, depending on the
	 location of the function descriptor within the GOT.  */
      if (entry->fd_entry >= -(1 << (12 - 1))
	  && entry->fd_entry < (1 << (12 - 1)))
	{
	  /* lddi @@(gr15, fd_entry), gr14 */
	  bfd_put_32 (output_bfd,
		      0x9cccf000 | (entry->fd_entry & ((1 << 12) - 1)),
		      plt_code);
	  plt_code += 4;
	}
      else
	{
	  if (entry->fd_entry >= -(1 << (16 - 1))
	      && entry->fd_entry < (1 << (16 - 1)))
	    {
	      /* setlos lo(fd_entry), gr14 */
	      bfd_put_32 (output_bfd,
			  0x9cfc0000
			  | (entry->fd_entry & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      plt_code += 4;
	    }
	  else
	    {
	      /* sethi.p hi(fd_entry), gr14
		 setlo lo(fd_entry), gr14 */
	      bfd_put_32 (output_bfd,
			  0x1cf80000
			  | ((entry->fd_entry >> 16)
			     & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      plt_code += 4;
	      bfd_put_32 (output_bfd,
			  0x9cf40000
			  | (entry->fd_entry & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      plt_code += 4;
	    }
	  /* ldd @@(gr14,gr15),gr14 */
	  bfd_put_32 (output_bfd, 0x9c08e14f, plt_code);
	  plt_code += 4;
	}
      /* jmpl @@(gr14,gr0) */
      bfd_put_32 (output_bfd, 0x8030e000, plt_code);
    }

  /* Generate code for the lazy PLT entry.  */
  if (entry->lzplt_entry != (bfd_vma) -1)
    {
      bfd_byte *lzplt_code = frvfdpic_plt_section (info)->contents
	+ entry->lzplt_entry;
      bfd_vma resolverStub_addr;

      bfd_put_32 (output_bfd, fd_lazy_rel_offset, lzplt_code);
      lzplt_code += 4;

      resolverStub_addr = entry->lzplt_entry / FRVFDPIC_LZPLT_BLOCK_SIZE
	* FRVFDPIC_LZPLT_BLOCK_SIZE + FRVFDPIC_LZPLT_RESOLV_LOC;
      if (resolverStub_addr >= frvfdpic_plt_initial_offset (info))
	resolverStub_addr = frvfdpic_plt_initial_offset (info) - 12;

      if (entry->lzplt_entry == resolverStub_addr)
	{
	  /* This is a lazy PLT entry that includes a resolver call.  */
	  /* ldd @@(gr15,gr0), gr4
	     jmpl @@(gr4,gr0)  */
	  bfd_put_32 (output_bfd, 0x8808f140, lzplt_code);
	  bfd_put_32 (output_bfd, 0x80304000, lzplt_code + 4);
	}
      else
	{
	  /* bra  resolverStub */
	  bfd_put_32 (output_bfd,
		      0xc01a0000
		      | (((resolverStub_addr - entry->lzplt_entry)
			  / 4) & (((bfd_vma)1 << 16) - 1)),
		      lzplt_code);
	}
    }

  /* Generate relocation for GOT entry holding the TLS offset.  */
  if (entry->tlsoff_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;

      if (entry->symndx != -1
	  || FRVFDPIC_SYM_LOCAL (info, entry->d.h))
	{
	  /* If the symbol is dynamic but binds locally, use
	     section+offset.  */
	  if (sec)
	    {
	      if (entry->symndx == -1)
		ad += entry->d.h->root.u.def.value;
	      else
		ad += sym->st_value;
	      ad += sec->output_offset;
	      if (sec->output_section
		  && elf_section_data (sec->output_section))
		idx = elf_section_data (sec->output_section)->dynindx;
	      else
		idx = 0;
	    }
	}

      /* *ABS*+addend is special for TLS relocations, use only the
	 addend.  */
      if (info->executable
	  && idx == 0
	  && (bfd_is_abs_section (sec)
	      || bfd_is_und_section (sec)))
	;
      /* If we're linking an executable, we can entirely omit the
	 dynamic relocation if the symbol is local to this module.  */
      else if (info->executable
	       && (entry->symndx != -1
		   || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma - tls_biased_base (info);
	}
      else
	{
	  if (idx == 0
	      && (bfd_is_abs_section (sec)
		  || bfd_is_und_section (sec)))
	    {
	      if (! elf_hash_table (info)->tls_sec)
		{
		  (*info->callbacks->undefined_symbol)
		    (info, "TLS section", elf_hash_table (info)->dynobj,
		     frvfdpic_got_section (info), entry->tlsoff_entry, TRUE);
		  return FALSE;
		}
	      idx = elf_section_data (elf_hash_table (info)->tls_sec)->dynindx;
	      ad += FRVFDPIC_TLS_BIAS;
	    }
	  _frvfdpic_add_dyn_reloc (output_bfd, frvfdpic_gotrel_section (info),
				   _bfd_elf_section_offset
				   (output_bfd, info,
				    frvfdpic_got_section (info),
				    frvfdpic_got_initial_offset (info)
				    + entry->tlsoff_entry)
				   + frvfdpic_got_section (info)
				   ->output_section->vma
				   + frvfdpic_got_section (info)
				   ->output_offset,
				   R_FRV_TLSOFF, idx, ad, entry);
	}

      bfd_put_32 (output_bfd, ad,
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
		  + entry->tlsoff_entry);
    }

  if (entry->tlsdesc_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;

      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1
		  || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}

      /* If we didn't set up a TLS offset entry, but we're linking an
	 executable and the symbol binds locally, we can use the
	 module offset in the TLS descriptor in relaxations.  */
      if (info->executable && ! entry->tlsoff_entry)
	entry->tlsoff_entry = entry->tlsdesc_entry + 4;

      if (info->executable && !info->pie
	  && ((idx == 0
	       && (bfd_is_abs_section (sec)
		   || bfd_is_und_section (sec)))
	      || entry->symndx != -1
	      || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  /* *ABS*+addend is special for TLS relocations, use only the
	     addend for the TLS offset, and take the module id as
	     0.  */
	  if (idx == 0
	      && (bfd_is_abs_section (sec)
		  || bfd_is_und_section (sec)))
	    ;
	  /* For other TLS symbols that bind locally, add the section
	     TLS offset to the addend.  */
	  else if (sec)
	    ad += sec->output_section->vma - tls_biased_base (info);

	  bfd_put_32 (output_bfd,
		      frvfdpic_plt_section (info)->output_section->vma
		      + frvfdpic_plt_section (info)->output_offset
		      + frvfdpic_plt_tls_ret_offset (info),
		      frvfdpic_got_section (info)->contents
		      + frvfdpic_got_initial_offset (info)
		      + entry->tlsdesc_entry);

	  _frvfdpic_add_rofixup (output_bfd,
				 frvfdpic_gotfixup_section (info),
				 frvfdpic_got_section (info)
				 ->output_section->vma
				 + frvfdpic_got_section (info)
				 ->output_offset
				 + frvfdpic_got_initial_offset (info)
				 + entry->tlsdesc_entry, entry);

	  BFD_ASSERT (frvfdpic_dynamic_got_plt_info (info)->tls_ret_refs);

	  /* We've used one of the reserved fixups, so discount it so
	     that we can check at the end that we've used them
	     all.  */
	  frvfdpic_dynamic_got_plt_info (info)->tls_ret_refs--;

	  /* While at that, make sure the ret instruction makes to the
	     right location in the PLT.  We could do it only when we
	     got to 0, but since the check at the end will only print
	     a warning, make sure we have the ret in place in case the
	     warning is missed.  */
	  bfd_put_32 (output_bfd, 0xc03a4000,
		      frvfdpic_plt_section (info)->contents
		      + frvfdpic_plt_tls_ret_offset (info));
	}
      else
	{
	  if (idx == 0
	      && (bfd_is_abs_section (sec)
		  || bfd_is_und_section (sec)))
	    {
	      if (! elf_hash_table (info)->tls_sec)
		{
		  (*info->callbacks->undefined_symbol)
		    (info, "TLS section", elf_hash_table (info)->dynobj,
		     frvfdpic_got_section (info), entry->tlsdesc_entry, TRUE);
		  return FALSE;
		}
	      idx = elf_section_data (elf_hash_table (info)->tls_sec)->dynindx;
	      ad += FRVFDPIC_TLS_BIAS;
	    }

	  _frvfdpic_add_dyn_reloc (output_bfd, frvfdpic_gotrel_section (info),
				   _bfd_elf_section_offset
				   (output_bfd, info,
				    frvfdpic_got_section (info),
				    frvfdpic_got_initial_offset (info)
				    + entry->tlsdesc_entry)
				   + frvfdpic_got_section (info)
				   ->output_section->vma
				   + frvfdpic_got_section (info)
				   ->output_offset,
				   R_FRV_TLSDESC_VALUE, idx, ad, entry);

	  bfd_put_32 (output_bfd, 0,
		      frvfdpic_got_section (info)->contents
		      + frvfdpic_got_initial_offset (info)
		      + entry->tlsdesc_entry);
	}

      bfd_put_32 (output_bfd, ad,
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
		  + entry->tlsdesc_entry + 4);
    }

  /* Generate code for the get-TLS-offset PLT entry.  */
  if (entry->tlsplt_entry != (bfd_vma) -1)
    {
      bfd_byte *plt_code = frvfdpic_plt_section (info)->contents
	+ entry->tlsplt_entry;

      if (info->executable
	  && (entry->symndx != -1
	      || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  int idx = dynindx;
	  bfd_vma ad = addend;

	  /* sec may be NULL when referencing an undefweak symbol
	     while linking a static executable.  */
	  if (!sec)
	    {
	      BFD_ASSERT (entry->symndx == -1
			  && entry->d.h->root.type == bfd_link_hash_undefweak);
	    }
	  else
	    {
	      if (entry->symndx == -1)
		ad += entry->d.h->root.u.def.value;
	      else
		ad += sym->st_value;
	      ad += sec->output_offset;
	      if (sec->output_section
		  && elf_section_data (sec->output_section))
		idx = elf_section_data (sec->output_section)->dynindx;
	      else
		idx = 0;
	    }

	  /* *ABS*+addend is special for TLS relocations, use only the
	     addend for the TLS offset, and take the module id as
	     0.  */
	  if (idx == 0
	      && (bfd_is_abs_section (sec)
		  || bfd_is_und_section (sec)))
	    ;
	  /* For other TLS symbols that bind locally, add the section
	     TLS offset to the addend.  */
	  else if (sec)
	    ad += sec->output_section->vma - tls_biased_base (info);

	  if ((bfd_signed_vma)ad >= -(1 << (16 - 1))
	      && (bfd_signed_vma)ad < (1 << (16 - 1)))
	    {
	      /* setlos lo(ad), gr9 */
	      bfd_put_32 (output_bfd,
			  0x92fc0000
			  | (ad
			     & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      plt_code += 4;
	    }
	  else
	    {
	      /* sethi.p hi(ad), gr9
		 setlo lo(ad), gr9 */
	      bfd_put_32 (output_bfd,
			  0x12f80000
			  | ((ad >> 16)
			     & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      plt_code += 4;
	      bfd_put_32 (output_bfd,
			  0x92f40000
			  | (ad
			     & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      plt_code += 4;
	    }
	  /* ret */
	  bfd_put_32 (output_bfd, 0xc03a4000, plt_code);
	}
      else if (entry->tlsoff_entry)
	{
	  /* Figure out what kind of PLT entry we need, depending on the
	     location of the TLS descriptor within the GOT.  */
	  if (entry->tlsoff_entry >= -(1 << (12 - 1))
	      && entry->tlsoff_entry < (1 << (12 - 1)))
	    {
	      /* ldi @@(gr15, tlsoff_entry), gr9 */
	      bfd_put_32 (output_bfd,
			  0x92c8f000 | (entry->tlsoff_entry
					& ((1 << 12) - 1)),
			  plt_code);
	      plt_code += 4;
	    }
	  else
	    {
	      if (entry->tlsoff_entry >= -(1 << (16 - 1))
		  && entry->tlsoff_entry < (1 << (16 - 1)))
		{
		  /* setlos lo(tlsoff_entry), gr8 */
		  bfd_put_32 (output_bfd,
			      0x90fc0000
			      | (entry->tlsoff_entry
				 & (((bfd_vma)1 << 16) - 1)),
			      plt_code);
		  plt_code += 4;
		}
	      else
		{
		  /* sethi.p hi(tlsoff_entry), gr8
		     setlo lo(tlsoff_entry), gr8 */
		  bfd_put_32 (output_bfd,
			      0x10f80000
			      | ((entry->tlsoff_entry >> 16)
				 & (((bfd_vma)1 << 16) - 1)),
			      plt_code);
		  plt_code += 4;
		  bfd_put_32 (output_bfd,
			      0x90f40000
			      | (entry->tlsoff_entry
				 & (((bfd_vma)1 << 16) - 1)),
			      plt_code);
		  plt_code += 4;
		}
	      /* ld @@(gr15,gr8),gr9 */
	      bfd_put_32 (output_bfd, 0x9008f108, plt_code);
	      plt_code += 4;
	    }
	  /* ret */
	  bfd_put_32 (output_bfd, 0xc03a4000, plt_code);
	}
      else
	{
	  BFD_ASSERT (entry->tlsdesc_entry);

	  /* Figure out what kind of PLT entry we need, depending on the
	     location of the TLS descriptor within the GOT.  */
	  if (entry->tlsdesc_entry >= -(1 << (12 - 1))
	      && entry->tlsdesc_entry < (1 << (12 - 1)))
	    {
	      /* lddi @@(gr15, tlsdesc_entry), gr8 */
	      bfd_put_32 (output_bfd,
			  0x90ccf000 | (entry->tlsdesc_entry
					& ((1 << 12) - 1)),
			  plt_code);
	      plt_code += 4;
	    }
	  else
	    {
	      if (entry->tlsdesc_entry >= -(1 << (16 - 1))
		  && entry->tlsdesc_entry < (1 << (16 - 1)))
		{
		  /* setlos lo(tlsdesc_entry), gr8 */
		  bfd_put_32 (output_bfd,
			      0x90fc0000
			      | (entry->tlsdesc_entry
				 & (((bfd_vma)1 << 16) - 1)),
			      plt_code);
		  plt_code += 4;
		}
	      else
		{
		  /* sethi.p hi(tlsdesc_entry), gr8
		     setlo lo(tlsdesc_entry), gr8 */
		  bfd_put_32 (output_bfd,
			      0x10f80000
			      | ((entry->tlsdesc_entry >> 16)
				 & (((bfd_vma)1 << 16) - 1)),
			      plt_code);
		  plt_code += 4;
		  bfd_put_32 (output_bfd,
			      0x90f40000
			      | (entry->tlsdesc_entry
				 & (((bfd_vma)1 << 16) - 1)),
			      plt_code);
		  plt_code += 4;
		}
	      /* ldd @@(gr15,gr8),gr8 */
	      bfd_put_32 (output_bfd, 0x9008f148, plt_code);
	      plt_code += 4;
	    }
	  /* jmpl @@(gr8,gr0) */
	  bfd_put_32 (output_bfd, 0x80308000, plt_code);
	}
    }

  return TRUE;
}

/* Handle an FRV small data reloc.  */

static bfd_reloc_status_type
elf32_frv_relocate_gprel12 (struct bfd_link_info *info,
			    bfd *input_bfd,
			    asection *input_section,
			    Elf_Internal_Rela *relocation,
			    bfd_byte *contents,
			    bfd_vma value)
{
  bfd_vma insn;
  bfd_vma gp;
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);

  gp = (h->u.def.value
	+ h->u.def.section->output_section->vma
	+ h->u.def.section->output_offset);

  value -= input_section->output_section->vma;
  value -= (gp - input_section->output_section->vma);

  insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);

  value += relocation->r_addend;

  if ((long) value > 0x7ff || (long) value < -0x800)
    return bfd_reloc_overflow;

  bfd_put_32 (input_bfd,
	      (insn & 0xfffff000) | (value & 0xfff),
	      contents + relocation->r_offset);

  return bfd_reloc_ok;
}

/* Handle an FRV small data reloc. for the u12 field.  */

static bfd_reloc_status_type
elf32_frv_relocate_gprelu12 (struct bfd_link_info *info,
			     bfd *input_bfd,
			     asection *input_section,
			     Elf_Internal_Rela *relocation,
			     bfd_byte *contents,
			     bfd_vma value)
{
  bfd_vma insn;
  bfd_vma gp;
  struct bfd_link_hash_entry *h;
  bfd_vma mask;

  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);

  gp = (h->u.def.value
	+ h->u.def.section->output_section->vma
	+ h->u.def.section->output_offset);

  value -= input_section->output_section->vma;
  value -= (gp - input_section->output_section->vma);

  insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);

  value += relocation->r_addend;

  if ((long) value > 0x7ff || (long) value < -0x800)
    return bfd_reloc_overflow;

  /* The high 6 bits go into bits 17-12. The low 6 bits go into bits 5-0.  */
  mask = 0x3f03f;
  insn = (insn & ~mask) | ((value & 0xfc0) << 12) | (value & 0x3f);

  bfd_put_32 (input_bfd, insn, contents + relocation->r_offset);

  return bfd_reloc_ok;
}

/* Handle an FRV ELF HI16 reloc.  */

static bfd_reloc_status_type
elf32_frv_relocate_hi16 (bfd *input_bfd,
			 Elf_Internal_Rela *relhi,
			 bfd_byte *contents,
			 bfd_vma value)
{
  bfd_vma insn;

  insn = bfd_get_32 (input_bfd, contents + relhi->r_offset);

  value += relhi->r_addend;
  value = ((value >> 16) & 0xffff);

  insn = (insn & 0xffff0000) | value;

  if ((long) value > 0xffff || (long) value < -0x10000)
    return bfd_reloc_overflow;

  bfd_put_32 (input_bfd, insn, contents + relhi->r_offset);
  return bfd_reloc_ok;

}
static bfd_reloc_status_type
elf32_frv_relocate_lo16 (bfd *input_bfd,
			 Elf_Internal_Rela *rello,
			 bfd_byte *contents,
			 bfd_vma value)
{
  bfd_vma insn;

  insn = bfd_get_32 (input_bfd, contents + rello->r_offset);

  value += rello->r_addend;
  value = value & 0xffff;

  insn = (insn & 0xffff0000) | value;

  if ((long) value > 0xffff || (long) value < -0x10000)
    return bfd_reloc_overflow;

  bfd_put_32 (input_bfd, insn, contents + rello->r_offset);
  return bfd_reloc_ok;
}

/* Perform the relocation for the CALL label24 instruction.  */

static bfd_reloc_status_type
elf32_frv_relocate_label24 (bfd *input_bfd,
			    asection *input_section,
			    Elf_Internal_Rela *rello,
			    bfd_byte *contents,
			    bfd_vma value)
{
  bfd_vma insn;
  bfd_vma label6;
  bfd_vma label18;

  /* The format for the call instruction is:

    0 000000 0001111 000000000000000000
      label6 opcode  label18

    The branch calculation is: pc + (4*label24)
    where label24 is the concatenation of label6 and label18.  */

  /* Grab the instruction.  */
  insn = bfd_get_32 (input_bfd, contents + rello->r_offset);

  value -= input_section->output_section->vma + input_section->output_offset;
  value -= rello->r_offset;
  value += rello->r_addend;

  value = value >> 2;

  label6  = value & 0xfc0000;
  label6  = label6 << 7;

  label18 = value & 0x3ffff;

  insn = insn & 0x803c0000;
  insn = insn | label6;
  insn = insn | label18;

  bfd_put_32 (input_bfd, insn, contents + rello->r_offset);

  return bfd_reloc_ok;
}

static bfd_reloc_status_type
elf32_frv_relocate_gprelhi (struct bfd_link_info *info,
			    bfd *input_bfd,
			    asection *input_section,
			    Elf_Internal_Rela *relocation,
			    bfd_byte *contents,
			    bfd_vma value)
{
  bfd_vma insn;
  bfd_vma gp;
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);

  gp = (h->u.def.value
        + h->u.def.section->output_section->vma
        + h->u.def.section->output_offset);

  value -= input_section->output_section->vma;
  value -= (gp - input_section->output_section->vma);
  value += relocation->r_addend;
  value = ((value >> 16) & 0xffff);

  if ((long) value > 0xffff || (long) value < -0x10000)
    return bfd_reloc_overflow;

  insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);
  insn = (insn & 0xffff0000) | value;

  bfd_put_32 (input_bfd, insn, contents + relocation->r_offset);
  return bfd_reloc_ok;
}

static bfd_reloc_status_type
elf32_frv_relocate_gprello (struct bfd_link_info *info,
			    bfd *input_bfd,
			    asection *input_section,
			    Elf_Internal_Rela *relocation,
			    bfd_byte *contents,
			    bfd_vma value)
{
  bfd_vma insn;
  bfd_vma gp;
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);

  gp = (h->u.def.value
        + h->u.def.section->output_section->vma
        + h->u.def.section->output_offset);

  value -= input_section->output_section->vma;
  value -= (gp - input_section->output_section->vma);
  value += relocation->r_addend;
  value = value & 0xffff;

  if ((long) value > 0xffff || (long) value < -0x10000)
    return bfd_reloc_overflow;

  insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);
  insn = (insn & 0xffff0000) | value;

  bfd_put_32 (input_bfd, insn, contents + relocation->r_offset);

 return bfd_reloc_ok;
}

static reloc_howto_type *
frv_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
		       bfd_reloc_code_real_type code)
{
  switch (code)
    {
    default:
      break;

    case BFD_RELOC_NONE:
      return &elf32_frv_howto_table[ (int) R_FRV_NONE];

    case BFD_RELOC_32:
      if (elf_elfheader (abfd)->e_type == ET_EXEC
	  || elf_elfheader (abfd)->e_type == ET_DYN)
	return &elf32_frv_rel_32_howto;
      /* Fall through.  */
    case BFD_RELOC_CTOR:
      return &elf32_frv_howto_table[ (int) R_FRV_32];

    case BFD_RELOC_FRV_LABEL16:
      return &elf32_frv_howto_table[ (int) R_FRV_LABEL16];

    case BFD_RELOC_FRV_LABEL24:
      return &elf32_frv_howto_table[ (int) R_FRV_LABEL24];

    case BFD_RELOC_FRV_LO16:
      return &elf32_frv_howto_table[ (int) R_FRV_LO16];

    case BFD_RELOC_FRV_HI16:
      return &elf32_frv_howto_table[ (int) R_FRV_HI16];

    case BFD_RELOC_FRV_GPREL12:
      return &elf32_frv_howto_table[ (int) R_FRV_GPREL12];

    case BFD_RELOC_FRV_GPRELU12:
      return &elf32_frv_howto_table[ (int) R_FRV_GPRELU12];

    case BFD_RELOC_FRV_GPREL32:
      return &elf32_frv_howto_table[ (int) R_FRV_GPREL32];

    case BFD_RELOC_FRV_GPRELHI:
      return &elf32_frv_howto_table[ (int) R_FRV_GPRELHI];

    case BFD_RELOC_FRV_GPRELLO:
      return &elf32_frv_howto_table[ (int) R_FRV_GPRELLO];

    case BFD_RELOC_FRV_GOT12:
      return &elf32_frv_howto_table[ (int) R_FRV_GOT12];

    case BFD_RELOC_FRV_GOTHI:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTHI];

    case BFD_RELOC_FRV_GOTLO:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTLO];

    case BFD_RELOC_FRV_FUNCDESC:
      if (elf_elfheader (abfd)->e_type == ET_EXEC
	  || elf_elfheader (abfd)->e_type == ET_DYN)
	return &elf32_frv_rel_funcdesc_howto;
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC];

    case BFD_RELOC_FRV_FUNCDESC_GOT12:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOT12];

    case BFD_RELOC_FRV_FUNCDESC_GOTHI:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTHI];

    case BFD_RELOC_FRV_FUNCDESC_GOTLO:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTLO];

    case BFD_RELOC_FRV_FUNCDESC_VALUE:
      if (elf_elfheader (abfd)->e_type == ET_EXEC
	  || elf_elfheader (abfd)->e_type == ET_DYN)
	return &elf32_frv_rel_funcdesc_value_howto;
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_VALUE];

    case BFD_RELOC_FRV_FUNCDESC_GOTOFF12:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTOFF12];

    case BFD_RELOC_FRV_FUNCDESC_GOTOFFHI:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTOFFHI];

    case BFD_RELOC_FRV_FUNCDESC_GOTOFFLO:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTOFFLO];

    case BFD_RELOC_FRV_GOTOFF12:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTOFF12];

    case BFD_RELOC_FRV_GOTOFFHI:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTOFFHI];

    case BFD_RELOC_FRV_GOTOFFLO:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTOFFLO];

    case BFD_RELOC_FRV_GETTLSOFF:
      return &elf32_frv_howto_table[ (int) R_FRV_GETTLSOFF];

    case BFD_RELOC_FRV_TLSDESC_VALUE:
      if (elf_elfheader (abfd)->e_type == ET_EXEC
	  || elf_elfheader (abfd)->e_type == ET_DYN)
	return &elf32_frv_rel_tlsdesc_value_howto;
      return &elf32_frv_howto_table[ (int) R_FRV_TLSDESC_VALUE];

    case BFD_RELOC_FRV_GOTTLSDESC12:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTTLSDESC12];

    case BFD_RELOC_FRV_GOTTLSDESCHI:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTTLSDESCHI];

    case BFD_RELOC_FRV_GOTTLSDESCLO:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTTLSDESCLO];

    case BFD_RELOC_FRV_TLSMOFF12:
      return &elf32_frv_howto_table[ (int) R_FRV_TLSMOFF12];

    case BFD_RELOC_FRV_TLSMOFFHI:
      return &elf32_frv_howto_table[ (int) R_FRV_TLSMOFFHI];

    case BFD_RELOC_FRV_TLSMOFFLO:
      return &elf32_frv_howto_table[ (int) R_FRV_TLSMOFFLO];

    case BFD_RELOC_FRV_GOTTLSOFF12:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTTLSOFF12];

    case BFD_RELOC_FRV_GOTTLSOFFHI:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTTLSOFFHI];

    case BFD_RELOC_FRV_GOTTLSOFFLO:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTTLSOFFLO];

    case BFD_RELOC_FRV_TLSOFF:
      if (elf_elfheader (abfd)->e_type == ET_EXEC
	  || elf_elfheader (abfd)->e_type == ET_DYN)
	return &elf32_frv_rel_tlsoff_howto;
      return &elf32_frv_howto_table[ (int) R_FRV_TLSOFF];

    case BFD_RELOC_FRV_TLSDESC_RELAX:
      return &elf32_frv_howto_table[ (int) R_FRV_TLSDESC_RELAX];

    case BFD_RELOC_FRV_GETTLSOFF_RELAX:
      return &elf32_frv_howto_table[ (int) R_FRV_GETTLSOFF_RELAX];

    case BFD_RELOC_FRV_TLSOFF_RELAX:
      return &elf32_frv_howto_table[ (int) R_FRV_TLSOFF_RELAX];

    case BFD_RELOC_FRV_TLSMOFF:
      return &elf32_frv_howto_table[ (int) R_FRV_TLSMOFF];

    case BFD_RELOC_VTABLE_INHERIT:
      return &elf32_frv_vtinherit_howto;

    case BFD_RELOC_VTABLE_ENTRY:
      return &elf32_frv_vtentry_howto;
    }

  return NULL;
}

static reloc_howto_type *
frv_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED, const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (elf32_frv_howto_table) / sizeof (elf32_frv_howto_table[0]);
       i++)
    if (elf32_frv_howto_table[i].name != NULL
	&& strcasecmp (elf32_frv_howto_table[i].name, r_name) == 0)
      return &elf32_frv_howto_table[i];

  if (strcasecmp (elf32_frv_vtinherit_howto.name, r_name) == 0)
    return &elf32_frv_vtinherit_howto;
  if (strcasecmp (elf32_frv_vtentry_howto.name, r_name) == 0)
    return &elf32_frv_vtentry_howto;

  return NULL;
}

/* Set the howto pointer for an FRV ELF reloc.  */

static void
frv_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			arelent *cache_ptr,
			Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  switch (r_type)
    {
    case R_FRV_GNU_VTINHERIT:
      cache_ptr->howto = &elf32_frv_vtinherit_howto;
      break;

    case R_FRV_GNU_VTENTRY:
      cache_ptr->howto = &elf32_frv_vtentry_howto;
      break;

    default:
      cache_ptr->howto = & elf32_frv_howto_table [r_type];
      break;
    }
}

/* Set the howto pointer for an FRV ELF REL reloc.  */
static void
frvfdpic_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
			    arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  switch (r_type)
    {
    case R_FRV_32:
      cache_ptr->howto = &elf32_frv_rel_32_howto;
      break;

    case R_FRV_FUNCDESC:
      cache_ptr->howto = &elf32_frv_rel_funcdesc_howto;
      break;

    case R_FRV_FUNCDESC_VALUE:
      cache_ptr->howto = &elf32_frv_rel_funcdesc_value_howto;
      break;

    case R_FRV_TLSDESC_VALUE:
      cache_ptr->howto = &elf32_frv_rel_tlsdesc_value_howto;
      break;

    case R_FRV_TLSOFF:
      cache_ptr->howto = &elf32_frv_rel_tlsoff_howto;
      break;

    default:
      cache_ptr->howto = NULL;
      break;
    }
}

/* Perform a single relocation.  By default we use the standard BFD
   routines, but a few relocs, we have to do them ourselves.  */

static bfd_reloc_status_type
frv_final_link_relocate (reloc_howto_type *howto,
			 bfd *input_bfd,
			 asection *input_section,
			 bfd_byte *contents,
			 Elf_Internal_Rela *rel,
			 bfd_vma relocation)
{
  return _bfd_final_link_relocate (howto, input_bfd, input_section,
				   contents, rel->r_offset, relocation,
				   rel->r_addend);
}


/* Relocate an FRV ELF section.

   The RELOCATE_SECTION function is called by the new ELF backend linker
   to handle the relocations for a section.

   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.

   This function is responsible for adjusting the section contents as
   necessary, and (if using Rela relocs and generating a relocatable
   output file) adjusting the reloc addend as necessary.

   This function does not have to worry about setting the reloc
   address or the reloc symbol index.

   LOCAL_SYMS is a pointer to the swapped in local symbols.

   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.

   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).

   When generating relocatable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */

static bfd_boolean
elf32_frv_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info,
			    bfd *input_bfd,
			    asection *input_section,
			    bfd_byte *contents,
			    Elf_Internal_Rela *relocs,
			    Elf_Internal_Sym *local_syms,
			    asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  unsigned isec_segment, got_segment, plt_segment, gprel_segment, tls_segment,
    check_segment[2];
  int silence_segment_error = !(info->shared || info->pie);
  unsigned long insn;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend     = relocs + input_section->reloc_count;

  isec_segment = _frvfdpic_osec_to_segment (output_bfd,
					    input_section->output_section);
  if (IS_FDPIC (output_bfd) && frvfdpic_got_section (info))
    got_segment = _frvfdpic_osec_to_segment (output_bfd,
					     frvfdpic_got_section (info)
					     ->output_section);
  else
    got_segment = -1;
  if (IS_FDPIC (output_bfd) && frvfdpic_gotfixup_section (info))
    gprel_segment = _frvfdpic_osec_to_segment (output_bfd,
					       frvfdpic_gotfixup_section (info)
					       ->output_section);
  else
    gprel_segment = -1;
  if (IS_FDPIC (output_bfd) && frvfdpic_plt_section (info))
    plt_segment = _frvfdpic_osec_to_segment (output_bfd,
					     frvfdpic_plt_section (info)
					     ->output_section);
  else
    plt_segment = -1;
  if (elf_hash_table (info)->tls_sec)
    tls_segment = _frvfdpic_osec_to_segment (output_bfd,
					     elf_hash_table (info)->tls_sec);
  else
    tls_segment = -1;

  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char *name;
      int r_type;
      asection *osec;
      struct frvfdpic_relocs_info *picrel;
      bfd_vma orig_addend = rel->r_addend;

      r_type = ELF32_R_TYPE (rel->r_info);

      if (   r_type == R_FRV_GNU_VTINHERIT
	  || r_type == R_FRV_GNU_VTENTRY)
	continue;

      r_symndx = ELF32_R_SYM (rel->r_info);
      howto  = elf32_frv_howto_table + ELF32_R_TYPE (rel->r_info);
      h      = NULL;
      sym    = NULL;
      sec    = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  osec = sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  if (name == NULL || name[0] == 0)
	    name = bfd_section_name (input_bfd, sec);
	}
      else
	{
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	  osec = sec;
	  name = h->root.root.string;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      if (r_type != R_FRV_TLSMOFF
	  && h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && !FRVFDPIC_SYM_LOCAL (info, h))
	{
	  osec = sec = NULL;
	  relocation = 0;
	}

      switch (r_type)
	{
	case R_FRV_LABEL24:
	case R_FRV_32:
	  if (! IS_FDPIC (output_bfd))
	    goto non_fdpic;

	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFFLO:
	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	case R_FRV_FUNCDESC:
	case R_FRV_FUNCDESC_VALUE:
	case R_FRV_GETTLSOFF:
	case R_FRV_TLSDESC_VALUE:
	case R_FRV_GOTTLSDESC12:
	case R_FRV_GOTTLSDESCHI:
	case R_FRV_GOTTLSDESCLO:
	case R_FRV_TLSMOFF12:
	case R_FRV_TLSMOFFHI:
	case R_FRV_TLSMOFFLO:
	case R_FRV_GOTTLSOFF12:
	case R_FRV_GOTTLSOFFHI:
	case R_FRV_GOTTLSOFFLO:
	case R_FRV_TLSOFF:
	case R_FRV_TLSDESC_RELAX:
	case R_FRV_GETTLSOFF_RELAX:
	case R_FRV_TLSOFF_RELAX:
	case R_FRV_TLSMOFF:
	  if (h != NULL)
	    picrel = frvfdpic_relocs_info_for_global (frvfdpic_relocs_info
						      (info), input_bfd, h,
						      orig_addend, INSERT);
	  else
	    /* In order to find the entry we created before, we must
	       use the original addend, not the one that may have been
	       modified by _bfd_elf_rela_local_sym().  */
	    picrel = frvfdpic_relocs_info_for_local (frvfdpic_relocs_info
						     (info), input_bfd, r_symndx,
						     orig_addend, INSERT);
	  if (! picrel)
	    return FALSE;

	  if (!_frvfdpic_emit_got_relocs_plt_entries (picrel, output_bfd, info,
						      osec, sym,
						      rel->r_addend))
	    {
	      info->callbacks->einfo
		(_("%H: relocation to `%s+%v'"
		   " may have caused the error above\n"),
		 input_bfd, input_section, rel->r_offset, name, rel->r_addend);
	      return FALSE;
	    }

	  break;

	default:
	non_fdpic:
	  picrel = NULL;
	  if (h
	      && ! FRVFDPIC_SYM_LOCAL (info, h)
	      && _bfd_elf_section_offset (output_bfd, info, input_section,
					  rel->r_offset) != (bfd_vma) -1)
	    {
	      info->callbacks->einfo
		(_("%H: relocation references symbol"
		   " not defined in the module\n"),
		 input_bfd, input_section, rel->r_offset);
	      return FALSE;
	    }
	  break;
	}

      switch (r_type)
	{
	case R_FRV_GETTLSOFF:
	case R_FRV_TLSDESC_VALUE:
	case R_FRV_GOTTLSDESC12:
	case R_FRV_GOTTLSDESCHI:
	case R_FRV_GOTTLSDESCLO:
	case R_FRV_TLSMOFF12:
	case R_FRV_TLSMOFFHI:
	case R_FRV_TLSMOFFLO:
	case R_FRV_GOTTLSOFF12:
	case R_FRV_GOTTLSOFFHI:
	case R_FRV_GOTTLSOFFLO:
	case R_FRV_TLSOFF:
	case R_FRV_TLSDESC_RELAX:
	case R_FRV_GETTLSOFF_RELAX:
	case R_FRV_TLSOFF_RELAX:
	case R_FRV_TLSMOFF:
	  if (sec && (bfd_is_abs_section (sec) || bfd_is_und_section (sec)))
	    relocation += tls_biased_base (info);
	  break;

	default:
	  break;
	}

      /* Try to apply TLS relaxations.  */
      if (1)
	switch (r_type)
	  {

#define LOCAL_EXEC_P(info, picrel) \
  ((info)->executable \
   && (picrel->symndx != -1 || FRVFDPIC_SYM_LOCAL ((info), (picrel)->d.h)))
#define INITIAL_EXEC_P(info, picrel) \
  (((info)->executable || (info)->flags & DF_STATIC_TLS) \
   && (picrel)->tlsoff_entry)

#define IN_RANGE_FOR_OFST12_P(value) \
  ((bfd_vma)((value) + 2048) < (bfd_vma)4096)
#define IN_RANGE_FOR_SETLOS_P(value) \
  ((bfd_vma)((value) + 32768) < (bfd_vma)65536)
#define TLSMOFF_IN_RANGE_FOR_SETLOS_P(value, info) \
  (IN_RANGE_FOR_SETLOS_P ((value) - tls_biased_base (info)))

#define RELAX_GETTLSOFF_LOCAL_EXEC_P(info, picrel, value) \
  (LOCAL_EXEC_P ((info), (picrel)) \
   && TLSMOFF_IN_RANGE_FOR_SETLOS_P((value), (info)))
#define RELAX_GETTLSOFF_INITIAL_EXEC_P(info, picrel) \
  (INITIAL_EXEC_P ((info), (picrel)) \
   && IN_RANGE_FOR_OFST12_P ((picrel)->tlsoff_entry))

#define RELAX_TLSDESC_LOCAL_EXEC_P(info, picrel, value) \
  (LOCAL_EXEC_P ((info), (picrel)))
#define RELAX_TLSDESC_INITIAL_EXEC_P(info, picrel) \
  (INITIAL_EXEC_P ((info), (picrel)))

#define RELAX_GOTTLSOFF_LOCAL_EXEC_P(info, picrel, value) \
  (LOCAL_EXEC_P ((info), (picrel)) \
   && TLSMOFF_IN_RANGE_FOR_SETLOS_P((value), (info)))

	  case R_FRV_GETTLSOFF:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this a call instruction?  */
	    if ((insn & (unsigned long)0x01fc0000) != 0x003c0000)
	      {
		info->callbacks->einfo
		  (_("%H: R_FRV_GETTLSOFF not applied to a call instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (RELAX_GETTLSOFF_LOCAL_EXEC_P (info, picrel,
					      relocation + rel->r_addend))
	      {
		/* Replace the call instruction (except the packing bit)
		   with setlos #tlsmofflo(symbol+offset), gr9.  */
		insn &= (unsigned long)0x80000000;
		insn |= (unsigned long)0x12fc0000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_TLSMOFFLO;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    else if (RELAX_GETTLSOFF_INITIAL_EXEC_P (info, picrel))
	      {
		/* Replace the call instruction (except the packing bit)
		   with ldi @@(gr15, #gottlsoff12(symbol+addend)), gr9.  */
		insn &= (unsigned long)0x80000000;
		insn |= (unsigned long)0x12c8f000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_GOTTLSOFF12;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    break;

	  case R_FRV_GOTTLSDESC12:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this an lddi instruction?  */
	    if ((insn & (unsigned long)0x01fc0000) != 0x00cc0000)
	      {
		info->callbacks->einfo
		  (_("%H: R_FRV_GOTTLSDESC12"
		     " not applied to an lddi instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (RELAX_TLSDESC_LOCAL_EXEC_P (info, picrel,
					    relocation + rel->r_addend)
		&& TLSMOFF_IN_RANGE_FOR_SETLOS_P (relocation + rel->r_addend,
						  info))
	      {
		/* Replace lddi @@(grB, #gottlsdesc12(symbol+offset), grC
		   with setlos #tlsmofflo(symbol+offset), gr<C+1>.
		   Preserve the packing bit.  */
		insn = (insn & (unsigned long)0x80000000)
		  | ((insn + (unsigned long)0x02000000)
		     & (unsigned long)0x7e000000);
		insn |= (unsigned long)0x00fc0000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_TLSMOFFLO;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    else if (RELAX_TLSDESC_LOCAL_EXEC_P (info, picrel,
						 relocation + rel->r_addend))
	      {
		/* Replace lddi @@(grB, #gottlsdesc12(symbol+offset), grC
		   with sethi #tlsmoffhi(symbol+offset), gr<C+1>.
		   Preserve the packing bit.  */
		insn = (insn & (unsigned long)0x80000000)
		  | ((insn + (unsigned long)0x02000000)
		     & (unsigned long)0x7e000000);
		insn |= (unsigned long)0x00f80000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_TLSMOFFHI;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    else if (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel))
	      {
		/* Replace lddi @@(grB, #gottlsdesc12(symbol+offset), grC
		   with ldi @@(grB, #gottlsoff12(symbol+offset),
		   gr<C+1>.  Preserve the packing bit.  If gottlsoff12
		   overflows, we'll error out, but that's sort-of ok,
		   since we'd started with gottlsdesc12, that's actually
		   more demanding.  Compiling with -fPIE instead of
		   -fpie would fix it; linking with --relax should fix
		   it as well.  */
		insn = (insn & (unsigned long)0x80cbf000)
		  | ((insn + (unsigned long)0x02000000)
		     & (unsigned long)0x7e000000);
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_GOTTLSOFF12;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    break;

	  case R_FRV_GOTTLSDESCHI:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this a sethi instruction?  */
	    if ((insn & (unsigned long)0x01ff0000) != 0x00f80000)
	      {
		info->callbacks->einfo
		  (_("%H: R_FRV_GOTTLSDESCHI"
		     " not applied to a sethi instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (RELAX_TLSDESC_LOCAL_EXEC_P (info, picrel,
					    relocation + rel->r_addend)
		|| (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel)
		    && IN_RANGE_FOR_SETLOS_P (picrel->tlsoff_entry)))
	      {
		/* Replace sethi with a nop.  Preserve the packing bit.  */
		insn &= (unsigned long)0x80000000;
		insn |= (unsigned long)0x00880000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		/* Nothing to relocate.  */
		continue;
	      }

	    else if (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel))
	      {
		/* Simply decay GOTTLSDESC to GOTTLSOFF.  */
		r_type = R_FRV_GOTTLSOFFHI;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    break;

	  case R_FRV_GOTTLSDESCLO:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this a setlo or setlos instruction?  */
	    if ((insn & (unsigned long)0x01f70000) != 0x00f40000)
	      {
		info->callbacks->einfo
		  (_("%H: R_FRV_GOTTLSDESCLO"
		     " not applied to a setlo or setlos instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (RELAX_TLSDESC_LOCAL_EXEC_P (info, picrel,
					    relocation + rel->r_addend)
		|| (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel)
		    && IN_RANGE_FOR_OFST12_P (picrel->tlsoff_entry)))
	      {
		/* Replace setlo/setlos with a nop.  Preserve the
		   packing bit.  */
		insn &= (unsigned long)0x80000000;
		insn |= (unsigned long)0x00880000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		/* Nothing to relocate.  */
		continue;
	      }

	    else if (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel))
	      {
		/* If the corresponding sethi (if it exists) decayed
		   to a nop, make sure this becomes (or already is) a
		   setlos, not setlo.  */
		if (IN_RANGE_FOR_SETLOS_P (picrel->tlsoff_entry))
		  {
		    insn |= (unsigned long)0x00080000;
		    bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
		  }

		/* Simply decay GOTTLSDESC to GOTTLSOFF.  */
		r_type = R_FRV_GOTTLSOFFLO;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    break;

	  case R_FRV_TLSDESC_RELAX:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this an ldd instruction?  */
	    if ((insn & (unsigned long)0x01fc0fc0) != 0x00080140)
	      {
		info->callbacks->einfo
		  (_("%H: R_FRV_TLSDESC_RELAX"
		     " not applied to an ldd instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (RELAX_TLSDESC_LOCAL_EXEC_P (info, picrel,
					    relocation + rel->r_addend)
		&& TLSMOFF_IN_RANGE_FOR_SETLOS_P (relocation + rel->r_addend,
						  info))
	      {
		/* Replace ldd #tlsdesc(symbol+offset)@@(grB, grA), grC
		   with setlos #tlsmofflo(symbol+offset), gr<C+1>.
		   Preserve the packing bit.  */
		insn = (insn & (unsigned long)0x80000000)
		  | ((insn + (unsigned long)0x02000000)
		     & (unsigned long)0x7e000000);
		insn |= (unsigned long)0x00fc0000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_TLSMOFFLO;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    else if (RELAX_TLSDESC_LOCAL_EXEC_P (info, picrel,
						 relocation + rel->r_addend))
	      {
		/* Replace ldd #tlsdesc(symbol+offset)@@(grB, grA), grC
		   with sethi #tlsmoffhi(symbol+offset), gr<C+1>.
		   Preserve the packing bit.  */
		insn = (insn & (unsigned long)0x80000000)
		  | ((insn + (unsigned long)0x02000000)
		     & (unsigned long)0x7e000000);
		insn |= (unsigned long)0x00f80000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_TLSMOFFHI;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    else if (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel)
		     && IN_RANGE_FOR_OFST12_P (picrel->tlsoff_entry))
	      {
		/* Replace ldd #tlsdesc(symbol+offset)@@(grB, grA), grC
		   with ldi @@(grB, #gottlsoff12(symbol+offset), gr<C+1>.
		   Preserve the packing bit.  */
		insn = (insn & (unsigned long)0x8003f000)
		  | (unsigned long)0x00c80000
		  | ((insn + (unsigned long)0x02000000)
		     & (unsigned long)0x7e000000);
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_GOTTLSOFF12;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    else if (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel))
	      {
		/* Replace ldd #tlsdesc(symbol+offset)@@(grB, grA), grC
		   with ld #tlsoff(symbol+offset)@@(grB, grA), gr<C+1>.
		   Preserve the packing bit.  */
		insn = (insn & (unsigned long)0x81ffffbf)
		  | ((insn + (unsigned long)0x02000000)
		     & (unsigned long)0x7e000000);
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		/* #tlsoff(symbol+offset) is just a relaxation
                    annotation, so there's nothing left to
                    relocate.  */
		continue;
	      }

	    break;

	  case R_FRV_GETTLSOFF_RELAX:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this a calll or callil instruction?  */
	    if ((insn & (unsigned long)0x7ff80fc0) != 0x02300000)
	      {
		info->callbacks->einfo
		  (_("%H: R_FRV_GETTLSOFF_RELAX"
		     " not applied to a calll instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (RELAX_TLSDESC_LOCAL_EXEC_P (info, picrel,
					    relocation + rel->r_addend)
		&& TLSMOFF_IN_RANGE_FOR_SETLOS_P (relocation + rel->r_addend,
						  info))
	      {
		/* Replace calll with a nop.  Preserve the packing bit.  */
		insn &= (unsigned long)0x80000000;
		insn |= (unsigned long)0x00880000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		/* Nothing to relocate.  */
		continue;
	      }

	    else if (RELAX_TLSDESC_LOCAL_EXEC_P (info, picrel,
						 relocation + rel->r_addend))
	      {
		/* Replace calll with setlo #tlsmofflo(symbol+offset), gr9.
		   Preserve the packing bit.  */
		insn &= (unsigned long)0x80000000;
		insn |= (unsigned long)0x12f40000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_TLSMOFFLO;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    else if (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel))
	      {
		/* Replace calll with a nop.  Preserve the packing bit.  */
		insn &= (unsigned long)0x80000000;
		insn |= (unsigned long)0x00880000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		/* Nothing to relocate.  */
		continue;
	      }

	    break;

	  case R_FRV_GOTTLSOFF12:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this an ldi instruction?  */
	    if ((insn & (unsigned long)0x01fc0000) != 0x00c80000)
	      {
		info->callbacks->einfo
		  (_("%H: R_FRV_GOTTLSOFF12"
		     " not applied to an ldi instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (RELAX_GOTTLSOFF_LOCAL_EXEC_P (info, picrel,
					      relocation + rel->r_addend))
	      {
		/* Replace ldi @@(grB, #gottlsoff12(symbol+offset), grC
		   with setlos #tlsmofflo(symbol+offset), grC.
		   Preserve the packing bit.  */
		insn &= (unsigned long)0xfe000000;
		insn |= (unsigned long)0x00fc0000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_TLSMOFFLO;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    break;

	  case R_FRV_GOTTLSOFFHI:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this a sethi instruction?  */
	    if ((insn & (unsigned long)0x01ff0000) != 0x00f80000)
	      {
		info->callbacks->einfo
		  (_("%H: R_FRV_GOTTLSOFFHI"
		     " not applied to a sethi instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (RELAX_GOTTLSOFF_LOCAL_EXEC_P (info, picrel,
					      relocation + rel->r_addend)
		|| (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel)
		    && IN_RANGE_FOR_OFST12_P (picrel->tlsoff_entry)))
	      {
		/* Replace sethi with a nop.  Preserve the packing bit.  */
		insn &= (unsigned long)0x80000000;
		insn |= (unsigned long)0x00880000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		/* Nothing to relocate.  */
		continue;
	      }

	    break;

	  case R_FRV_GOTTLSOFFLO:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this a setlo or setlos instruction?  */
	    if ((insn & (unsigned long)0x01f70000) != 0x00f40000)
	      {
		info->callbacks->einfo
		  (_("%H: R_FRV_GOTTLSOFFLO"
		     " not applied to a setlo or setlos instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (RELAX_GOTTLSOFF_LOCAL_EXEC_P (info, picrel,
					      relocation + rel->r_addend)
		|| (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel)
		    && IN_RANGE_FOR_OFST12_P (picrel->tlsoff_entry)))
	      {
		/* Replace setlo/setlos with a nop.  Preserve the
		   packing bit.  */
		insn &= (unsigned long)0x80000000;
		insn |= (unsigned long)0x00880000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		/* Nothing to relocate.  */
		continue;
	      }

	    break;

	  case R_FRV_TLSOFF_RELAX:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this an ld instruction?  */
	    if ((insn & (unsigned long)0x01fc0fc0) != 0x00080100)
	      {
		info->callbacks->einfo
		  (_("%H: R_FRV_TLSOFF_RELAX"
		     " not applied to an ld instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (RELAX_GOTTLSOFF_LOCAL_EXEC_P (info, picrel,
					      relocation + rel->r_addend))
	      {
		/* Replace ld #gottlsoff(symbol+offset)@@(grB, grA), grC
		   with setlos #tlsmofflo(symbol+offset), grC.
		   Preserve the packing bit.  */
		insn &= (unsigned long)0xfe000000;
		insn |= (unsigned long)0x00fc0000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_TLSMOFFLO;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    else if (RELAX_TLSDESC_INITIAL_EXEC_P (info, picrel)
		     && IN_RANGE_FOR_OFST12_P (picrel->tlsoff_entry))
	      {
		/* Replace ld #tlsoff(symbol+offset)@@(grB, grA), grC
		   with ldi @@(grB, #gottlsoff12(symbol+offset), grC.
		   Preserve the packing bit.  */
		insn = (insn & (unsigned long)0xfe03f000)
		  | (unsigned long)0x00c80000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		r_type = R_FRV_GOTTLSOFF12;
		howto  = elf32_frv_howto_table + r_type;
		rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      }

	    break;

	  case R_FRV_TLSMOFFHI:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this a sethi instruction?  */
	    if ((insn & (unsigned long)0x01ff0000) != 0x00f80000)
	      {
		info->callbacks->einfo
		  (_("%H: R_FRV_TLSMOFFHI"
		     " not applied to a sethi instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (TLSMOFF_IN_RANGE_FOR_SETLOS_P (relocation + rel->r_addend,
					       info))
	      {
		/* Replace sethi with a nop.  Preserve the packing bit.  */
		insn &= (unsigned long)0x80000000;
		insn |= (unsigned long)0x00880000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);

		/* Nothing to relocate.  */
		continue;
	      }

	    break;

	  case R_FRV_TLSMOFFLO:
	    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);

	    /* Is this a setlo or setlos instruction?  */
	    if ((insn & (unsigned long)0x01f70000) != 0x00f40000)
	      {
		info->callbacks->einfo
		  (_("R_FRV_TLSMOFFLO"
		     " not applied to a setlo or setlos instruction\n"),
		   input_bfd, input_section, rel->r_offset);
		return FALSE;
	      }

	    if (TLSMOFF_IN_RANGE_FOR_SETLOS_P (relocation + rel->r_addend,
					       info))
	      /* If the corresponding sethi (if it exists) decayed
		 to a nop, make sure this becomes (or already is) a
		 setlos, not setlo.  */
	      {
		insn |= (unsigned long)0x00080000;
		bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
	      }

	    break;

	    /*
	      There's nothing to relax in these:
		R_FRV_TLSDESC_VALUE
		R_FRV_TLSOFF
		R_FRV_TLSMOFF12
		R_FRV_TLSMOFFHI
		R_FRV_TLSMOFFLO
		R_FRV_TLSMOFF
	    */

	  default:
	    break;
	  }

      switch (r_type)
	{
	case R_FRV_LABEL24:
	  check_segment[0] = isec_segment;
	  if (! IS_FDPIC (output_bfd))
	    check_segment[1] = isec_segment;
	  else if (picrel->plt)
	    {
	      relocation = frvfdpic_plt_section (info)->output_section->vma
		+ frvfdpic_plt_section (info)->output_offset
		+ picrel->plt_entry;
	      check_segment[1] = plt_segment;
	    }
	  /* We don't want to warn on calls to undefined weak symbols,
	     as calls to them must be protected by non-NULL tests
	     anyway, and unprotected calls would invoke undefined
	     behavior.  */
	  else if (picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefweak)
	    check_segment[1] = check_segment[0];
	  else
	    check_segment[1] = sec
	      ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
	      : (unsigned)-1;
	  break;

	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	  relocation = picrel->got_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	  relocation = picrel->fdgot_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFLO:
	  relocation -= frvfdpic_got_section (info)->output_section->vma
	    + frvfdpic_got_section (info)->output_offset
	    + frvfdpic_got_initial_offset (info);
	  check_segment[0] = got_segment;
	  check_segment[1] = sec
	    ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;

	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	  relocation = picrel->fd_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_FRV_FUNCDESC:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;

	    if (! (h && h->root.type == bfd_link_hash_undefweak
		   && FRVFDPIC_SYM_LOCAL (info, h)))
	      {
		/* If the symbol is dynamic and there may be dynamic
		   symbol resolution because we are or are linked with a
		   shared library, emit a FUNCDESC relocation such that
		   the dynamic linker will allocate the function
		   descriptor.  If the symbol needs a non-local function
		   descriptor but binds locally (e.g., its visibility is
		   protected, emit a dynamic relocation decayed to
		   section+offset.  */
		if (h && ! FRVFDPIC_FUNCDESC_LOCAL (info, h)
		    && FRVFDPIC_SYM_LOCAL (info, h)
		    && !(info->executable && !info->pie))
		  {
		    dynindx = elf_section_data (h->root.u.def.section
						->output_section)->dynindx;
		    addend += h->root.u.def.section->output_offset
		      + h->root.u.def.value;
		  }
		else if (h && ! FRVFDPIC_FUNCDESC_LOCAL (info, h))
		  {
		    if (addend)
		      {
			info->callbacks->einfo
			  (_("%H: R_FRV_FUNCDESC references dynamic symbol"
			     " with nonzero addend\n"),
			   input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    dynindx = h->dynindx;
		  }
		else
		  {
		    /* Otherwise, we know we have a private function
		       descriptor, so reference it directly.  */
		    BFD_ASSERT (picrel->privfd);
		    r_type = R_FRV_32;
		    dynindx = elf_section_data (frvfdpic_got_section (info)
						->output_section)->dynindx;
		    addend = frvfdpic_got_section (info)->output_offset
		      + frvfdpic_got_initial_offset (info)
		      + picrel->fd_entry;
		  }

		/* If there is room for dynamic symbol resolution, emit
		   the dynamic relocation.  However, if we're linking an
		   executable at a fixed location, we won't have emitted a
		   dynamic symbol entry for the got section, so idx will
		   be zero, which means we can and should compute the
		   address of the private descriptor ourselves.  */
		if (info->executable && !info->pie
		    && (!h || FRVFDPIC_FUNCDESC_LOCAL (info, h)))
		  {
		    addend += frvfdpic_got_section (info)->output_section->vma;
		    if ((bfd_get_section_flags (output_bfd,
						input_section->output_section)
			 & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		      {
			bfd_vma offset;

			if (_frvfdpic_osec_readonly_p (output_bfd,
						       input_section
						       ->output_section))
			  {
			    info->callbacks->einfo
			      (_("%H: cannot emit fixups"
				 " in read-only section\n"),
			       input_bfd, input_section, rel->r_offset);
			    return FALSE;
			  }

			offset = _bfd_elf_section_offset
			  (output_bfd, info,
			   input_section, rel->r_offset);

			if (offset != (bfd_vma)-1)
			  _frvfdpic_add_rofixup (output_bfd,
						 frvfdpic_gotfixup_section
						 (info),
						 offset + input_section
						 ->output_section->vma
						 + input_section->output_offset,
						 picrel);
		      }
		  }
		else if ((bfd_get_section_flags (output_bfd,
						 input_section->output_section)
			  & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    bfd_vma offset;

		    if (_frvfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->einfo
			  (_("%H: cannot emit dynamic relocations"
			     " in read-only section\n"),
			   input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }

		    offset = _bfd_elf_section_offset
		      (output_bfd, info,
		       input_section, rel->r_offset);

		    if (offset != (bfd_vma)-1)
		      _frvfdpic_add_dyn_reloc (output_bfd,
					       frvfdpic_gotrel_section (info),
					       offset + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       r_type, dynindx, addend, picrel);
		  }
		else
		  addend += frvfdpic_got_section (info)->output_section->vma;
	      }

	    /* We want the addend in-place because dynamic
	       relocations are REL.  Setting relocation to it should
	       arrange for it to be installed.  */
	    relocation = addend - rel->r_addend;
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_FRV_32:
	  if (! IS_FDPIC (output_bfd))
	    {
	      check_segment[0] = check_segment[1] = -1;
	      break;
	    }
	  /* Fall through.  */
	case R_FRV_FUNCDESC_VALUE:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;

	    /* If the symbol is dynamic but binds locally, use
	       section+offset.  */
	    if (h && ! FRVFDPIC_SYM_LOCAL (info, h))
	      {
		if (addend && r_type == R_FRV_FUNCDESC_VALUE)
		  {
		    info->callbacks->einfo
		      (_("%H: R_FRV_FUNCDESC_VALUE"
			 " references dynamic symbol with nonzero addend\n"),
		       input_bfd, input_section, rel->r_offset);
		    return FALSE;
		  }
		dynindx = h->dynindx;
	      }
	    else
	      {
		if (h)
		  addend += h->root.u.def.value;
		else
		  addend += sym->st_value;
		if (osec)
		  addend += osec->output_offset;
		if (osec && osec->output_section
		    && ! bfd_is_abs_section (osec->output_section)
		    && ! bfd_is_und_section (osec->output_section))
		  dynindx = elf_section_data (osec->output_section)->dynindx;
		else
		  dynindx = 0;
	      }

	    /* If we're linking an executable at a fixed address, we
	       can omit the dynamic relocation as long as the symbol
	       is defined in the current link unit (which is implied
	       by its output section not being NULL).  */
	    if (info->executable && !info->pie
		&& (!h || FRVFDPIC_SYM_LOCAL (info, h)))
	      {
		if (osec)
		  addend += osec->output_section->vma;
		if (IS_FDPIC (input_bfd)
		    && (bfd_get_section_flags (output_bfd,
					       input_section->output_section)
			& (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_frvfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->einfo
			  (_("%H: cannot emit fixups in read-only section\n"),
			   input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    if (!h || h->root.type != bfd_link_hash_undefweak)
		      {
			bfd_vma offset = _bfd_elf_section_offset
			  (output_bfd, info,
			   input_section, rel->r_offset);

			if (offset != (bfd_vma)-1)
			  {
			    _frvfdpic_add_rofixup (output_bfd,
						   frvfdpic_gotfixup_section
						   (info),
						   offset + input_section
						   ->output_section->vma
						   + input_section->output_offset,
						   picrel);
			    if (r_type == R_FRV_FUNCDESC_VALUE)
			      _frvfdpic_add_rofixup
				(output_bfd,
				 frvfdpic_gotfixup_section (info),
				 offset
				 + input_section->output_section->vma
				 + input_section->output_offset + 4, picrel);
			  }
		      }
		  }
	      }
	    else
	      {
		if ((bfd_get_section_flags (output_bfd,
					    input_section->output_section)
		     & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    bfd_vma offset;

		    if (_frvfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->einfo
			  (_("%H: cannot emit dynamic relocations"
			     " in read-only section\n"),
			   input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }

		    offset = _bfd_elf_section_offset
		      (output_bfd, info,
		       input_section, rel->r_offset);

		    if (offset != (bfd_vma)-1)
		      _frvfdpic_add_dyn_reloc (output_bfd,
					       frvfdpic_gotrel_section (info),
					       offset + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       r_type, dynindx, addend, picrel);
		  }
		else if (osec)
		  addend += osec->output_section->vma;
		/* We want the addend in-place because dynamic
		   relocations are REL.  Setting relocation to it
		   should arrange for it to be installed.  */
		relocation = addend - rel->r_addend;
	      }

	    if (r_type == R_FRV_FUNCDESC_VALUE)
	      {
		/* If we've omitted the dynamic relocation, just emit
		   the fixed addresses of the symbol and of the local
		   GOT base offset.  */
		if (info->executable && !info->pie
		    && (!h || FRVFDPIC_SYM_LOCAL (info, h)))
		  bfd_put_32 (output_bfd,
			      frvfdpic_got_section (info)->output_section->vma
			      + frvfdpic_got_section (info)->output_offset
			      + frvfdpic_got_initial_offset (info),
			      contents + rel->r_offset + 4);
		else
		  /* A function descriptor used for lazy or local
		     resolving is initialized such that its high word
		     contains the output section index in which the
		     PLT entries are located, and the low word
		     contains the offset of the lazy PLT entry entry
		     point into that section.  */
		  bfd_put_32 (output_bfd,
			      h && ! FRVFDPIC_SYM_LOCAL (info, h)
			      ? 0
			      : _frvfdpic_osec_to_segment (output_bfd,
							   sec
							   ->output_section),
			      contents + rel->r_offset + 4);
	      }
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_FRV_GPREL12:
	case R_FRV_GPRELU12:
	case R_FRV_GPREL32:
	case R_FRV_GPRELHI:
	case R_FRV_GPRELLO:
	  check_segment[0] = gprel_segment;
	  check_segment[1] = sec
	    ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;

	case R_FRV_GETTLSOFF:
	  relocation = frvfdpic_plt_section (info)->output_section->vma
	    + frvfdpic_plt_section (info)->output_offset
	    + picrel->tlsplt_entry;
	  BFD_ASSERT (picrel->tlsplt_entry != (bfd_vma)-1
		      && picrel->tlsdesc_entry);
	  check_segment[0] = isec_segment;
	  check_segment[1] = plt_segment;
	  break;

	case R_FRV_GOTTLSDESC12:
	case R_FRV_GOTTLSDESCHI:
	case R_FRV_GOTTLSDESCLO:
	  BFD_ASSERT (picrel->tlsdesc_entry);
	  relocation = picrel->tlsdesc_entry;
	  check_segment[0] = tls_segment;
	  check_segment[1] = sec
	    && ! bfd_is_abs_section (sec)
	    && ! bfd_is_und_section (sec)
	    ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
	    : tls_segment;
	  break;

	case R_FRV_TLSMOFF12:
	case R_FRV_TLSMOFFHI:
	case R_FRV_TLSMOFFLO:
	case R_FRV_TLSMOFF:
	  check_segment[0] = tls_segment;
	  if (! sec)
	    check_segment[1] = -1;
	  else if (bfd_is_abs_section (sec)
		   || bfd_is_und_section (sec))
	    {
	      relocation = 0;
	      check_segment[1] = tls_segment;
	    }
	  else if (sec->output_section)
	    {
	      relocation -= tls_biased_base (info);
	      check_segment[1] =
		_frvfdpic_osec_to_segment (output_bfd, sec->output_section);
	    }
	  else
	    check_segment[1] = -1;
	  break;

	case R_FRV_GOTTLSOFF12:
	case R_FRV_GOTTLSOFFHI:
	case R_FRV_GOTTLSOFFLO:
	  BFD_ASSERT (picrel->tlsoff_entry);
	  relocation = picrel->tlsoff_entry;
	  check_segment[0] = tls_segment;
	  check_segment[1] = sec
	    && ! bfd_is_abs_section (sec)
	    && ! bfd_is_und_section (sec)
	    ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
	    : tls_segment;
	  break;

	case R_FRV_TLSDESC_VALUE:
	case R_FRV_TLSOFF:
	  /* These shouldn't be present in input object files.  */
	  check_segment[0] = check_segment[1] = isec_segment;
	  break;

	case R_FRV_TLSDESC_RELAX:
	case R_FRV_GETTLSOFF_RELAX:
	case R_FRV_TLSOFF_RELAX:
	  /* These are just annotations for relaxation, nothing to do
	     here.  */
	  continue;

	default:
	  check_segment[0] = isec_segment;
	  check_segment[1] = sec
	    ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;
	}

      if (check_segment[0] != check_segment[1] && IS_FDPIC (output_bfd))
	{
	  /* If you take this out, remove the #error from fdpic-static-6.d
	     in the ld testsuite.  */
	  /* This helps catch problems in GCC while we can't do more
	     than static linking.  The idea is to test whether the
	     input file basename is crt0.o only once.  */
	  if (silence_segment_error == 1)
	    silence_segment_error =
	      (strlen (input_bfd->filename) == 6
	       && filename_cmp (input_bfd->filename, "crt0.o") == 0)
	      || (strlen (input_bfd->filename) > 6
		  && filename_cmp (input_bfd->filename
				   + strlen (input_bfd->filename) - 7,
			     "/crt0.o") == 0)
	      ? -1 : 0;
	  if (!silence_segment_error
	      /* We don't want duplicate errors for undefined
		 symbols.  */
	      && !(picrel && picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefined))
	    {
	      info->callbacks->einfo
		(_("%H: reloc against `%s' references a different segment\n"),
		 input_bfd, input_section, rel->r_offset, name);
	    }
	  if (!silence_segment_error && (info->shared || info->pie))
	    return FALSE;
	  elf_elfheader (output_bfd)->e_flags |= EF_FRV_PIC;
	}

      switch (r_type)
	{
	case R_FRV_GOTOFFHI:
	case R_FRV_TLSMOFFHI:
	  /* We need the addend to be applied before we shift the
	     value right.  */
	  relocation += rel->r_addend;
	  /* Fall through.  */
	case R_FRV_GOTHI:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_GOTTLSOFFHI:
	case R_FRV_GOTTLSDESCHI:
	  relocation >>= 16;
	  /* Fall through.  */

	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_GOTOFFLO:
	case R_FRV_FUNCDESC_GOTOFFLO:
	case R_FRV_GOTTLSOFFLO:
	case R_FRV_GOTTLSDESCLO:
	case R_FRV_TLSMOFFLO:
	  relocation &= 0xffff;
	  break;

	default:
	  break;
	}

      switch (r_type)
	{
	case R_FRV_LABEL24:
	  if (! IS_FDPIC (output_bfd) || ! picrel->plt)
	    break;
	  /* Fall through.  */

	  /* When referencing a GOT entry, a function descriptor or a
	     PLT, we don't want the addend to apply to the reference,
	     but rather to the referenced symbol.  The actual entry
	     will have already been created taking the addend into
	     account, so cancel it out here.  */
	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	case R_FRV_GETTLSOFF:
	case R_FRV_GOTTLSDESC12:
	case R_FRV_GOTTLSDESCHI:
	case R_FRV_GOTTLSDESCLO:
	case R_FRV_GOTTLSOFF12:
	case R_FRV_GOTTLSOFFHI:
	case R_FRV_GOTTLSOFFLO:
	  /* Note that we only want GOTOFFHI, not GOTOFFLO or GOTOFF12
	     here, since we do want to apply the addend to the others.
	     Note that we've applied the addend to GOTOFFHI before we
	     shifted it right.  */
	case R_FRV_GOTOFFHI:
	case R_FRV_TLSMOFFHI:
	  relocation -= rel->r_addend;
	  break;

	default:
	  break;
	}

     if (r_type == R_FRV_HI16)
       r = elf32_frv_relocate_hi16 (input_bfd, rel, contents, relocation);

     else if (r_type == R_FRV_LO16)
       r = elf32_frv_relocate_lo16 (input_bfd, rel, contents, relocation);

     else if (r_type == R_FRV_LABEL24 || r_type == R_FRV_GETTLSOFF)
       r = elf32_frv_relocate_label24 (input_bfd, input_section, rel,
				       contents, relocation);

     else if (r_type == R_FRV_GPREL12)
       r = elf32_frv_relocate_gprel12 (info, input_bfd, input_section, rel,
				       contents, relocation);

     else if (r_type == R_FRV_GPRELU12)
       r = elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, rel,
					contents, relocation);

     else if (r_type == R_FRV_GPRELLO)
       r = elf32_frv_relocate_gprello (info, input_bfd, input_section, rel,
				       contents, relocation);

     else if (r_type == R_FRV_GPRELHI)
       r = elf32_frv_relocate_gprelhi (info, input_bfd, input_section, rel,
				       contents, relocation);

     else if (r_type == R_FRV_TLSOFF
	      || r_type == R_FRV_TLSDESC_VALUE)
       r = bfd_reloc_notsupported;

     else
       r = frv_final_link_relocate (howto, input_bfd, input_section, contents,
				    rel, relocation);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, (h ? &h->root : NULL), name, howto->name,
		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    {
	      info->callbacks->einfo
		(_("%H: reloc against `%s': %s\n"),
		 input_bfd, input_section, rel->r_offset, name, msg);
	      return FALSE;
	    }

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
elf32_frv_gc_mark_hook (asection *sec,
			struct bfd_link_info *info,
			Elf_Internal_Rela *rel,
			struct elf_link_hash_entry *h,
			Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_FRV_GNU_VTINHERIT:
      case R_FRV_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put .comm items in .scomm, and not .comm.  */

static bfd_boolean
elf32_frv_add_symbol_hook (bfd *abfd,
			   struct bfd_link_info *info,
			   Elf_Internal_Sym *sym,
			   const char **namep ATTRIBUTE_UNUSED,
			   flagword *flagsp ATTRIBUTE_UNUSED,
			   asection **secp,
			   bfd_vma *valp)
{
  if (sym->st_shndx == SHN_COMMON
      && !info->relocatable
      && (int)sym->st_size <= (int)bfd_get_gp_size (abfd))
    {
      /* Common symbols less than or equal to -G nn bytes are
	 automatically put into .sbss.  */

      asection *scomm = bfd_get_section_by_name (abfd, ".scommon");

      if (scomm == NULL)
	{
	  scomm = bfd_make_section_with_flags (abfd, ".scommon",
					       (SEC_ALLOC
						| SEC_IS_COMMON
						| SEC_LINKER_CREATED));
	  if (scomm == NULL)
	    return FALSE;
	}

      *secp = scomm;
      *valp = sym->st_size;
    }

  return TRUE;
}

/* We need dynamic symbols for every section, since segments can
   relocate independently.  */
static bfd_boolean
_frvfdpic_link_omit_section_dynsym (bfd *output_bfd ATTRIBUTE_UNUSED,
				    struct bfd_link_info *info
				    ATTRIBUTE_UNUSED,
				    asection *p ATTRIBUTE_UNUSED)
{
  switch (elf_section_data (p)->this_hdr.sh_type)
    {
    case SHT_PROGBITS:
    case SHT_NOBITS:
      /* If sh_type is yet undecided, assume it could be
	 SHT_PROGBITS/SHT_NOBITS.  */
    case SHT_NULL:
      return FALSE;

      /* There shouldn't be section relative relocations
	 against any other section.  */
    default:
      return TRUE;
    }
}

/* Create  a .got section, as well as its additional info field.  This
   is almost entirely copied from
   elflink.c:_bfd_elf_create_got_section().  */

static bfd_boolean
_frv_create_got_section (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags, pltflags;
  asection *s;
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int ptralign;
  int offset;

  /* This function may be called more than once.  */
  s = bfd_get_linker_section (abfd, ".got");
  if (s != NULL)
    return TRUE;

  /* Machine specific: although pointers are 32-bits wide, we want the
     GOT to be aligned to a 64-bit boundary, such that function
     descriptors in it can be accessed with 64-bit loads and
     stores.  */
  ptralign = 3;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
  pltflags = flags;

  s = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, ptralign))
    return FALSE;

  if (bed->want_got_plt)
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".got.plt", flags);
      if (s == NULL
	  || !bfd_set_section_alignment (abfd, s, ptralign))
	return FALSE;
    }

  if (bed->want_got_sym)
    {
      /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
	 (or .got.plt) section.  We don't do this in the linker script
	 because we don't want to define the symbol if we are not creating
	 a global offset table.  */
      h = _bfd_elf_define_linkage_sym (abfd, info, s, "_GLOBAL_OFFSET_TABLE_");
      elf_hash_table (info)->hgot = h;
      if (h == NULL)
	return FALSE;

      /* Machine-specific: we want the symbol for executables as
	 well.  */
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }

  /* The first bit of the global offset table is the header.  */
  s->size += bed->got_header_size;

  /* This is the machine-specific part.  Create and initialize section
     data for the got.  */
  if (IS_FDPIC (abfd))
    {
      frvfdpic_got_section (info) = s;
      frvfdpic_relocs_info (info) = htab_try_create (1,
						     frvfdpic_relocs_info_hash,
						     frvfdpic_relocs_info_eq,
						     (htab_del) NULL);
      if (! frvfdpic_relocs_info (info))
	return FALSE;

      s = bfd_make_section_anyway_with_flags (abfd, ".rel.got",
					      (flags | SEC_READONLY));
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      frvfdpic_gotrel_section (info) = s;

      /* Machine-specific.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".rofixup",
					      (flags | SEC_READONLY));
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      frvfdpic_gotfixup_section (info) = s;
      offset = -2048;
      flags = BSF_GLOBAL;
    }
  else
    {
      offset = 2048;
      flags = BSF_GLOBAL | BSF_WEAK;
    }

  /* Define _gp in .rofixup, for FDPIC, or .got otherwise.  If it
     turns out that we're linking with a different linker script, the
     linker script will override it.  */
  bh = NULL;
  if (!(_bfd_generic_link_add_one_symbol
	(info, abfd, "_gp", flags, s, offset, (const char *) NULL, FALSE,
	 bed->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->def_regular = 1;
  h->type = STT_OBJECT;
  /* h->other = STV_HIDDEN; */ /* Should we?  */

  /* Machine-specific: we want the symbol for executables as well.  */
  if (IS_FDPIC (abfd) && ! bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;

  if (!IS_FDPIC (abfd))
    return TRUE;

  /* FDPIC supports Thread Local Storage, and this may require a
     procedure linkage table for TLS PLT entries.  */

  /* This is mostly copied from
     elflink.c:_bfd_elf_create_dynamic_sections().  */

  flags = pltflags;
  pltflags |= SEC_CODE;
  if (bed->plt_not_loaded)
    pltflags &= ~ (SEC_CODE | SEC_LOAD | SEC_HAS_CONTENTS);
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  s = bfd_make_section_anyway_with_flags (abfd, ".plt", pltflags);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;
  /* FRV-specific: remember it.  */
  frvfdpic_plt_section (info) = s;

  /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
     .plt section.  */
  if (bed->want_plt_sym)
    {
      h = _bfd_elf_define_linkage_sym (abfd, info, s,
				       "_PROCEDURE_LINKAGE_TABLE_");
      elf_hash_table (info)->hplt = h;
      if (h == NULL)
	return FALSE;
    }

  /* FRV-specific: we want rel relocations for the plt.  */
  s = bfd_make_section_anyway_with_flags (abfd, ".rel.plt",
					  flags | SEC_READONLY);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  /* FRV-specific: remember it.  */
  frvfdpic_pltrel_section (info) = s;

  return TRUE;
}

/* Make sure the got and plt sections exist, and that our pointers in
   the link hash table point to them.  */

static bfd_boolean
elf32_frvfdpic_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  /* This is mostly copied from
     elflink.c:_bfd_elf_create_dynamic_sections().  */
  flagword flags;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */

  /* FRV-specific: we want to create the GOT and the PLT in the FRV
     way.  */
  if (! _frv_create_got_section (abfd, info))
    return FALSE;

  /* FRV-specific: make sure we created everything we wanted.  */
  BFD_ASSERT (frvfdpic_got_section (info) && frvfdpic_gotrel_section (info)
	      && frvfdpic_gotfixup_section (info)
	      && frvfdpic_plt_section (info)
	      && frvfdpic_pltrel_section (info));

  if (bed->want_dynbss)
    {
      /* The .dynbss section is a place to put symbols which are defined
	 by dynamic objects, are referenced by regular objects, and are
	 not functions.  We must allocate space for them in the process
	 image and use a R_*_COPY reloc to tell the dynamic linker to
	 initialize them at run time.  The linker script puts the .dynbss
	 section into the .bss section of the final image.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".dynbss",
					      SEC_ALLOC | SEC_LINKER_CREATED);
      if (s == NULL)
	return FALSE;

      /* The .rel[a].bss section holds copy relocs.  This section is not
     normally needed.  We need to create it here, though, so that the
     linker will map it to an output section.  We can't just create it
     only if we need it, because we will not know whether we need it
     until we have seen all the input files, and the first time the
     main linker code calls BFD after examining all the input files
     (size_dynamic_sections) the input sections have already been
     mapped to the output sections.  If the section turns out not to
     be needed, we can discard it later.  We will never need this
     section when generating a shared object, since they do not use
     copy relocs.  */
      if (! info->shared)
	{
	  s = bfd_make_section_anyway_with_flags (abfd,
						  (bed->default_use_rela_p
						   ? ".rela.bss" : ".rel.bss"),
						  flags | SEC_READONLY);
	  if (s == NULL
	      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
	    return FALSE;
	}
    }

  return TRUE;
}

/* Compute the total GOT and PLT size required by each symbol in each
   range.  Symbols may require up to 4 words in the GOT: an entry
   pointing to the symbol, an entry pointing to its function
   descriptor, and a private function descriptors taking two
   words.  */

static void
_frvfdpic_count_nontls_entries (struct frvfdpic_relocs_info *entry,
				struct _frvfdpic_dynamic_got_info *dinfo)
{
  /* Allocate space for a GOT entry pointing to the symbol.  */
  if (entry->got12)
    dinfo->got12 += 4;
  else if (entry->gotlos)
    dinfo->gotlos += 4;
  else if (entry->gothilo)
    dinfo->gothilo += 4;
  else
    entry->relocs32--;
  entry->relocs32++;

  /* Allocate space for a GOT entry pointing to the function
     descriptor.  */
  if (entry->fdgot12)
    dinfo->got12 += 4;
  else if (entry->fdgotlos)
    dinfo->gotlos += 4;
  else if (entry->fdgothilo)
    dinfo->gothilo += 4;
  else
    entry->relocsfd--;
  entry->relocsfd++;

  /* Decide whether we need a PLT entry, a function descriptor in the
     GOT, and a lazy PLT entry for this symbol.  */
  entry->plt = entry->call
    && entry->symndx == -1 && ! FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)
    && elf_hash_table (dinfo->info)->dynamic_sections_created;
  entry->privfd = entry->plt
    || entry->fdgoff12 || entry->fdgofflos || entry->fdgoffhilo
    || ((entry->fd || entry->fdgot12 || entry->fdgotlos || entry->fdgothilo)
	&& (entry->symndx != -1
	    || FRVFDPIC_FUNCDESC_LOCAL (dinfo->info, entry->d.h)));
  entry->lazyplt = entry->privfd
    && entry->symndx == -1 && ! FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)
    && ! (dinfo->info->flags & DF_BIND_NOW)
    && elf_hash_table (dinfo->info)->dynamic_sections_created;

  /* Allocate space for a function descriptor.  */
  if (entry->fdgoff12)
    dinfo->fd12 += 8;
  else if (entry->fdgofflos)
    dinfo->fdlos += 8;
  else if (entry->privfd && entry->plt)
    dinfo->fdplt += 8;
  else if (entry->privfd)
    dinfo->fdhilo += 8;
  else
    entry->relocsfdv--;
  entry->relocsfdv++;

  if (entry->lazyplt)
    dinfo->lzplt += 8;
}

/* Compute the total GOT size required by each TLS symbol in each
   range.  Symbols may require up to 5 words in the GOT: an entry
   holding the TLS offset for the symbol, and an entry with a full TLS
   descriptor taking 4 words.  */

static void
_frvfdpic_count_tls_entries (struct frvfdpic_relocs_info *entry,
			     struct _frvfdpic_dynamic_got_info *dinfo,
			     bfd_boolean subtract)
{
  const int l = subtract ? -1 : 1;

  /* Allocate space for a GOT entry with the TLS offset of the
     symbol.  */
  if (entry->tlsoff12)
    dinfo->got12 += 4 * l;
  else if (entry->tlsofflos)
    dinfo->gotlos += 4 * l;
  else if (entry->tlsoffhilo)
    dinfo->gothilo += 4 * l;
  else
    entry->relocstlsoff -= l;
  entry->relocstlsoff += l;

  /* If there's any TLSOFF relocation, mark the output file as not
     suitable for dlopening.  This mark will remain even if we relax
     all such relocations, but this is not a problem, since we'll only
     do so for executables, and we definitely don't want anyone
     dlopening executables.  */
  if (entry->relocstlsoff)
    dinfo->info->flags |= DF_STATIC_TLS;

  /* Allocate space for a TLS descriptor.  */
  if (entry->tlsdesc12)
    dinfo->tlsd12 += 8 * l;
  else if (entry->tlsdesclos)
    dinfo->tlsdlos += 8 * l;
  else if (entry->tlsplt)
    dinfo->tlsdplt += 8 * l;
  else if (entry->tlsdeschilo)
    dinfo->tlsdhilo += 8 * l;
  else
    entry->relocstlsd -= l;
  entry->relocstlsd += l;
}

/* Compute the number of dynamic relocations and fixups that a symbol
   requires, and add (or subtract) from the grand and per-symbol
   totals.  */

static void
_frvfdpic_count_relocs_fixups (struct frvfdpic_relocs_info *entry,
			       struct _frvfdpic_dynamic_got_info *dinfo,
			       bfd_boolean subtract)
{
  bfd_vma relocs = 0, fixups = 0, tlsrets = 0;

  if (!dinfo->info->executable || dinfo->info->pie)
    {
      relocs = entry->relocs32 + entry->relocsfd + entry->relocsfdv
	+ entry->relocstlsd;

      /* In the executable, TLS relocations to symbols that bind
	 locally (including those that resolve to global TLS offsets)
	 are resolved immediately, without any need for fixups or
	 dynamic relocations.  In shared libraries, however, we must
	 emit dynamic relocations even for local symbols, because we
	 don't know the module id the library is going to get at
	 run-time, nor its TLS base offset.  */
      if (!dinfo->info->executable
	  || (entry->symndx == -1
	      && ! FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)))
	relocs += entry->relocstlsoff;
    }
  else
    {
      if (entry->symndx != -1 || FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h))
	{
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    fixups += entry->relocs32 + 2 * entry->relocsfdv;
	  fixups += entry->relocstlsd;
	  tlsrets += entry->relocstlsd;
	}
      else
	{
	  relocs += entry->relocs32 + entry->relocsfdv
	    + entry->relocstlsoff + entry->relocstlsd;
	}

      if (entry->symndx != -1
	  || FRVFDPIC_FUNCDESC_LOCAL (dinfo->info, entry->d.h))
	{
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    fixups += entry->relocsfd;
	}
      else
	relocs += entry->relocsfd;
    }

  if (subtract)
    {
      relocs = - relocs;
      fixups = - fixups;
      tlsrets = - tlsrets;
    }

  entry->dynrelocs += relocs;
  entry->fixups += fixups;
  dinfo->relocs += relocs;
  dinfo->fixups += fixups;
  dinfo->tls_ret_refs += tlsrets;
}

/* Look for opportunities to relax TLS relocations.  We can assume
   we're linking the main executable or a static-tls library, since
   otherwise we wouldn't have got here.  When relaxing, we have to
   first undo any previous accounting of TLS uses of fixups, dynamic
   relocations, GOT and PLT entries.  */

static void
_frvfdpic_relax_tls_entries (struct frvfdpic_relocs_info *entry,
			     struct _frvfdpic_dynamic_got_info *dinfo,
			     bfd_boolean relaxing)
{
  bfd_boolean changed = ! relaxing;

  BFD_ASSERT (dinfo->info->executable
	      || (dinfo->info->flags & DF_STATIC_TLS));

  if (entry->tlsdesc12 || entry->tlsdesclos || entry->tlsdeschilo)
    {
      if (! changed)
	{
	  _frvfdpic_count_relocs_fixups (entry, dinfo, TRUE);
	  _frvfdpic_count_tls_entries (entry, dinfo, TRUE);
	  changed = TRUE;
	}

      /* When linking an executable, we can always decay GOTTLSDESC to
	 TLSMOFF, if the symbol is local, or GOTTLSOFF, otherwise.
	 When linking a static-tls shared library, using TLSMOFF is
	 not an option, but we can still use GOTTLSOFF.  When decaying
	 to GOTTLSOFF, we must keep the GOT entry in range.  We know
	 it has to fit because we'll be trading the 4 words of hte TLS
	 descriptor for a single word in the same range.  */
      if (! dinfo->info->executable
	  || (entry->symndx == -1
	      && ! FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)))
	{
	  entry->tlsoff12 |= entry->tlsdesc12;
	  entry->tlsofflos |= entry->tlsdesclos;
	  entry->tlsoffhilo |= entry->tlsdeschilo;
	}

      entry->tlsdesc12 = entry->tlsdesclos = entry->tlsdeschilo = 0;
    }

  /* We can only decay TLSOFFs or call #gettlsoff to TLSMOFF in the
     main executable.  We have to check whether the symbol's TLSOFF is
     in range for a setlos.  For symbols with a hash entry, we can
     determine exactly what to do; for others locals, we don't have
     addresses handy, so we use the size of the TLS section as an
     approximation.  If we get it wrong, we'll retain a GOT entry
     holding the TLS offset (without dynamic relocations or fixups),
     but we'll still optimize away the loads from it.  Since TLS sizes
     are generally very small, it's probably not worth attempting to
     do better than this.  */
  if ((entry->tlsplt
       || entry->tlsoff12 || entry->tlsofflos || entry->tlsoffhilo)
      && dinfo->info->executable && relaxing
      && ((entry->symndx == -1
	   && FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)
	   /* The above may hold for an undefweak TLS symbol, so make
	      sure we don't have this case before accessing def.value
	      and def.section.  */
	   && (entry->d.h->root.type == bfd_link_hash_undefweak
	       || (bfd_vma)(entry->d.h->root.u.def.value
			    + (entry->d.h->root.u.def.section
			       ->output_section->vma)
			    + entry->d.h->root.u.def.section->output_offset
			    + entry->addend
			    - tls_biased_base (dinfo->info)
			    + 32768) < (bfd_vma)65536))
	  || (entry->symndx != -1
	      && (elf_hash_table (dinfo->info)->tls_sec->size
		  + abs (entry->addend) < 32768 + FRVFDPIC_TLS_BIAS))))
    {
      if (! changed)
	{
	  _frvfdpic_count_relocs_fixups (entry, dinfo, TRUE);
	  _frvfdpic_count_tls_entries (entry, dinfo, TRUE);
	  changed = TRUE;
	}

      entry->tlsplt =
	entry->tlsoff12 = entry->tlsofflos = entry->tlsoffhilo = 0;
    }

  /* We can decay `call #gettlsoff' to a ldi #tlsoff if we already
     have a #gottlsoff12 relocation for this entry, or if we can fit
     one more in the 12-bit (and 16-bit) ranges.  */
  if (entry->tlsplt
      && (entry->tlsoff12
	  || (relaxing
	      && dinfo->got12 + dinfo->fd12 + dinfo->tlsd12 <= 4096 - 12 - 4
	      && (dinfo->got12 + dinfo->fd12 + dinfo->tlsd12
		  + dinfo->gotlos + dinfo->fdlos + dinfo->tlsdlos
		  <= 65536 - 12 - 4))))
    {
      if (! changed)
	{
	  _frvfdpic_count_relocs_fixups (entry, dinfo, TRUE);
	  _frvfdpic_count_tls_entries (entry, dinfo, TRUE);
	  changed = TRUE;
	}

      entry->tlsoff12 = 1;
      entry->tlsplt = 0;
    }

  if (changed)
    {
      _frvfdpic_count_tls_entries (entry, dinfo, FALSE);
      _frvfdpic_count_relocs_fixups (entry, dinfo, FALSE);
    }

  return;
}

/* Compute the total GOT and PLT size required by each symbol in each range. *
   Symbols may require up to 4 words in the GOT: an entry pointing to
   the symbol, an entry pointing to its function descriptor, and a
   private function descriptors taking two words.  */

static int
_frvfdpic_count_got_plt_entries (void **entryp, void *dinfo_)
{
  struct frvfdpic_relocs_info *entry = *entryp;
  struct _frvfdpic_dynamic_got_info *dinfo = dinfo_;

  _frvfdpic_count_nontls_entries (entry, dinfo);

  if (dinfo->info->executable || (dinfo->info->flags & DF_STATIC_TLS))
    _frvfdpic_relax_tls_entries (entry, dinfo, FALSE);
  else
    {
      _frvfdpic_count_tls_entries (entry, dinfo, FALSE);
      _frvfdpic_count_relocs_fixups (entry, dinfo, FALSE);
    }

  return 1;
}

/* Determine the positive and negative ranges to be used by each
   offset range in the GOT.  FDCUR and CUR, that must be aligned to a
   double-word boundary, are the minimum (negative) and maximum
   (positive) GOT offsets already used by previous ranges, except for
   an ODD entry that may have been left behind.  GOT and FD indicate
   the size of GOT entries and function descriptors that must be
   placed within the range from -WRAP to WRAP.  If there's room left,
   up to FDPLT bytes should be reserved for additional function
   descriptors.  */

inline static bfd_signed_vma
_frvfdpic_compute_got_alloc_data (struct _frvfdpic_dynamic_got_alloc_data *gad,
				  bfd_signed_vma fdcur,
				  bfd_signed_vma odd,
				  bfd_signed_vma cur,
				  bfd_vma got,
				  bfd_vma fd,
				  bfd_vma fdplt,
				  bfd_vma tlsd,
				  bfd_vma tlsdplt,
				  bfd_vma wrap)
{
  bfd_signed_vma wrapmin = -wrap;
  const bfd_vma tdescsz = 8;

  /* Start at the given initial points.  */
  gad->fdcur = fdcur;
  gad->cur = cur;

  /* If we had an incoming odd word and we have any got entries that
     are going to use it, consume it, otherwise leave gad->odd at
     zero.  We might force gad->odd to zero and return the incoming
     odd such that it is used by the next range, but then GOT entries
     might appear to be out of order and we wouldn't be able to
     shorten the GOT by one word if it turns out to end with an
     unpaired GOT entry.  */
  if (odd && got)
    {
      gad->odd = odd;
      got -= 4;
      odd = 0;
    }
  else
    gad->odd = 0;

  /* If we're left with an unpaired GOT entry, compute its location
     such that we can return it.  Otherwise, if got doesn't require an
     odd number of words here, either odd was already zero in the
     block above, or it was set to zero because got was non-zero, or
     got was already zero.  In the latter case, we want the value of
     odd to carry over to the return statement, so we don't want to
     reset odd unless the condition below is true.  */
  if (got & 4)
    {
      odd = cur + got;
      got += 4;
    }

  /* Compute the tentative boundaries of this range.  */
  gad->max = cur + got;
  gad->min = fdcur - fd;
  gad->fdplt = 0;

  /* If function descriptors took too much space, wrap some of them
     around.  */
  if (gad->min < wrapmin)
    {
      gad->max += wrapmin - gad->min;
      gad->tmin = gad->min = wrapmin;
    }

  /* If GOT entries took too much space, wrap some of them around.
     This may well cause gad->min to become lower than wrapmin.  This
     will cause a relocation overflow later on, so we don't have to
     report it here . */
  if ((bfd_vma) gad->max > wrap)
    {
      gad->min -= gad->max - wrap;
      gad->max = wrap;
    }

  /* Add TLS descriptors.  */
  gad->tmax = gad->max + tlsd;
  gad->tmin = gad->min;
  gad->tlsdplt = 0;

  /* If TLS descriptors took too much space, wrap an integral number
     of them around.  */
  if ((bfd_vma) gad->tmax > wrap)
    {
      bfd_vma wrapsize = gad->tmax - wrap;

      wrapsize += tdescsz / 2;
      wrapsize &= ~ tdescsz / 2;

      gad->tmin -= wrapsize;
      gad->tmax -= wrapsize;
    }

  /* If there is space left and we have function descriptors
     referenced in PLT entries that could take advantage of shorter
     offsets, place them now.  */
  if (fdplt && gad->tmin > wrapmin)
    {
      bfd_vma fds;

      if ((bfd_vma) (gad->tmin - wrapmin) < fdplt)
	fds = gad->tmin - wrapmin;
      else
	fds = fdplt;

      fdplt -= fds;
      gad->min -= fds;
      gad->tmin -= fds;
      gad->fdplt += fds;
    }

  /* If there is more space left, try to place some more function
     descriptors for PLT entries.  */
  if (fdplt && (bfd_vma) gad->tmax < wrap)
    {
      bfd_vma fds;

      if ((bfd_vma) (wrap - gad->tmax) < fdplt)
	fds = wrap - gad->tmax;
      else
	fds = fdplt;

      fdplt -= fds;
      gad->max += fds;
      gad->tmax += fds;
      gad->fdplt += fds;
    }

  /* If there is space left and we have TLS descriptors referenced in
     PLT entries that could take advantage of shorter offsets, place
     them now.  */
  if (tlsdplt && gad->tmin > wrapmin)
    {
      bfd_vma tlsds;

      if ((bfd_vma) (gad->tmin - wrapmin) < tlsdplt)
	tlsds = (gad->tmin - wrapmin) & ~ (tdescsz / 2);
      else
	tlsds = tlsdplt;

      tlsdplt -= tlsds;
      gad->tmin -= tlsds;
      gad->tlsdplt += tlsds;
    }

  /* If there is more space left, try to place some more TLS
     descriptors for PLT entries.  Although we could try to fit an
     additional TLS descriptor with half of it just before before the
     wrap point and another right past the wrap point, this might
     cause us to run out of space for the next region, so don't do
     it.  */
  if (tlsdplt && (bfd_vma) gad->tmax < wrap - tdescsz / 2)
    {
      bfd_vma tlsds;

      if ((bfd_vma) (wrap - gad->tmax) < tlsdplt)
	tlsds = (wrap - gad->tmax) & ~ (tdescsz / 2);
      else
	tlsds = tlsdplt;

      tlsdplt -= tlsds;
      gad->tmax += tlsds;
      gad->tlsdplt += tlsds;
    }

  /* If odd was initially computed as an offset past the wrap point,
     wrap it around.  */
  if (odd > gad->max)
    odd = gad->min + odd - gad->max;

  /* _frvfdpic_get_got_entry() below will always wrap gad->cur if needed
     before returning, so do it here too.  This guarantees that,
     should cur and fdcur meet at the wrap point, they'll both be
     equal to min.  */
  if (gad->cur == gad->max)
    gad->cur = gad->min;

  /* Ditto for _frvfdpic_get_tlsdesc_entry().  */
  gad->tcur = gad->max;
  if (gad->tcur == gad->tmax)
    gad->tcur = gad->tmin;

  return odd;
}

/* Compute the location of the next GOT entry, given the allocation
   data for a range.  */

inline static bfd_signed_vma
_frvfdpic_get_got_entry (struct _frvfdpic_dynamic_got_alloc_data *gad)
{
  bfd_signed_vma ret;

  if (gad->odd)
    {
      /* If there was an odd word left behind, use it.  */
      ret = gad->odd;
      gad->odd = 0;
    }
  else
    {
      /* Otherwise, use the word pointed to by cur, reserve the next
	 as an odd word, and skip to the next pair of words, possibly
	 wrapping around.  */
      ret = gad->cur;
      gad->odd = gad->cur + 4;
      gad->cur += 8;
      if (gad->cur == gad->max)
	gad->cur = gad->min;
    }

  return ret;
}

/* Compute the location of the next function descriptor entry in the
   GOT, given the allocation data for a range.  */

inline static bfd_signed_vma
_frvfdpic_get_fd_entry (struct _frvfdpic_dynamic_got_alloc_data *gad)
{
  /* If we're at the bottom, wrap around, and only then allocate the
     next pair of words.  */
  if (gad->fdcur == gad->min)
    gad->fdcur = gad->max;
  return gad->fdcur -= 8;
}

/* Compute the location of the next TLS descriptor entry in the GOT,
   given the allocation data for a range.  */
inline static bfd_signed_vma
_frvfdpic_get_tlsdesc_entry (struct _frvfdpic_dynamic_got_alloc_data *gad)
{
  bfd_signed_vma ret;

  ret = gad->tcur;

  gad->tcur += 8;

  /* If we're at the top of the region, wrap around to the bottom.  */
  if (gad->tcur == gad->tmax)
    gad->tcur = gad->tmin;

  return ret;
}

/* Assign GOT offsets for every GOT entry and function descriptor.
   Doing everything in a single pass is tricky.  */

static int
_frvfdpic_assign_got_entries (void **entryp, void *info_)
{
  struct frvfdpic_relocs_info *entry = *entryp;
  struct _frvfdpic_dynamic_got_plt_info *dinfo = info_;

  if (entry->got12)
    entry->got_entry = _frvfdpic_get_got_entry (&dinfo->got12);
  else if (entry->gotlos)
    entry->got_entry = _frvfdpic_get_got_entry (&dinfo->gotlos);
  else if (entry->gothilo)
    entry->got_entry = _frvfdpic_get_got_entry (&dinfo->gothilo);

  if (entry->fdgot12)
    entry->fdgot_entry = _frvfdpic_get_got_entry (&dinfo->got12);
  else if (entry->fdgotlos)
    entry->fdgot_entry = _frvfdpic_get_got_entry (&dinfo->gotlos);
  else if (entry->fdgothilo)
    entry->fdgot_entry = _frvfdpic_get_got_entry (&dinfo->gothilo);

  if (entry->fdgoff12)
    entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->got12);
  else if (entry->plt && dinfo->got12.fdplt)
    {
      dinfo->got12.fdplt -= 8;
      entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->got12);
    }
  else if (entry->fdgofflos)
    entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gotlos);
  else if (entry->plt && dinfo->gotlos.fdplt)
    {
      dinfo->gotlos.fdplt -= 8;
      entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gotlos);
    }
  else if (entry->plt)
    {
      dinfo->gothilo.fdplt -= 8;
      entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gothilo);
    }
  else if (entry->privfd)
    entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gothilo);

  if (entry->tlsoff12)
    entry->tlsoff_entry = _frvfdpic_get_got_entry (&dinfo->got12);
  else if (entry->tlsofflos)
    entry->tlsoff_entry = _frvfdpic_get_got_entry (&dinfo->gotlos);
  else if (entry->tlsoffhilo)
    entry->tlsoff_entry = _frvfdpic_get_got_entry (&dinfo->gothilo);

  if (entry->tlsdesc12)
    entry->tlsdesc_entry = _frvfdpic_get_tlsdesc_entry (&dinfo->got12);
  else if (entry->tlsplt && dinfo->got12.tlsdplt)
    {
      dinfo->got12.tlsdplt -= 8;
      entry->tlsdesc_entry = _frvfdpic_get_tlsdesc_entry (&dinfo->got12);
    }
  else if (entry->tlsdesclos)
    entry->tlsdesc_entry = _frvfdpic_get_tlsdesc_entry (&dinfo->gotlos);
  else if (entry->tlsplt && dinfo->gotlos.tlsdplt)
    {
      dinfo->gotlos.tlsdplt -= 8;
      entry->tlsdesc_entry = _frvfdpic_get_tlsdesc_entry (&dinfo->gotlos);
    }
  else if (entry->tlsplt)
    {
      dinfo->gothilo.tlsdplt -= 8;
      entry->tlsdesc_entry = _frvfdpic_get_tlsdesc_entry (&dinfo->gothilo);
    }
  else if (entry->tlsdeschilo)
    entry->tlsdesc_entry = _frvfdpic_get_tlsdesc_entry (&dinfo->gothilo);

  return 1;
}

/* Assign GOT offsets to private function descriptors used by PLT
   entries (or referenced by 32-bit offsets), as well as PLT entries
   and lazy PLT entries.  */

static int
_frvfdpic_assign_plt_entries (void **entryp, void *info_)
{
  struct frvfdpic_relocs_info *entry = *entryp;
  struct _frvfdpic_dynamic_got_plt_info *dinfo = info_;

  if (entry->privfd)
    BFD_ASSERT (entry->fd_entry);

  if (entry->plt)
    {
      int size;

      /* We use the section's raw size to mark the location of the
	 next PLT entry.  */
      entry->plt_entry = frvfdpic_plt_section (dinfo->g.info)->size;

      /* Figure out the length of this PLT entry based on the
	 addressing mode we need to reach the function descriptor.  */
      BFD_ASSERT (entry->fd_entry);
      if (entry->fd_entry >= -(1 << (12 - 1))
	  && entry->fd_entry < (1 << (12 - 1)))
	size = 8;
      else if (entry->fd_entry >= -(1 << (16 - 1))
	       && entry->fd_entry < (1 << (16 - 1)))
	size = 12;
      else
	size = 16;

      frvfdpic_plt_section (dinfo->g.info)->size += size;
    }

  if (entry->lazyplt)
    {
      entry->lzplt_entry = dinfo->g.lzplt;
      dinfo->g.lzplt += 8;
      /* If this entry is the one that gets the resolver stub, account
	 for the additional instruction.  */
      if (entry->lzplt_entry % FRVFDPIC_LZPLT_BLOCK_SIZE
	  == FRVFDPIC_LZPLT_RESOLV_LOC)
	dinfo->g.lzplt += 4;
    }

  if (entry->tlsplt)
    {
      int size;

      entry->tlsplt_entry
	= frvfdpic_plt_section (dinfo->g.info)->size;

      if (dinfo->g.info->executable
	  && (entry->symndx != -1
	      || FRVFDPIC_SYM_LOCAL (dinfo->g.info, entry->d.h)))
	{
	  if ((bfd_signed_vma)entry->addend >= -(1 << (16 - 1))
	      /* FIXME: here we use the size of the TLS section
		 as an upper bound for the value of the TLS
		 symbol, because we may not know the exact value
		 yet.  If we get it wrong, we'll just waste a
		 word in the PLT, and we should never get even
		 close to 32 KiB of TLS anyway.  */
	      && elf_hash_table (dinfo->g.info)->tls_sec
	      && (elf_hash_table (dinfo->g.info)->tls_sec->size
		  + (bfd_signed_vma)(entry->addend) <= (1 << (16 - 1))))
	    size = 8;
	  else
	    size = 12;
	}
      else if (entry->tlsoff_entry)
	{
	  if (entry->tlsoff_entry >= -(1 << (12 - 1))
	      && entry->tlsoff_entry < (1 << (12 - 1)))
	    size = 8;
	  else if (entry->tlsoff_entry >= -(1 << (16 - 1))
		   && entry->tlsoff_entry < (1 << (16 - 1)))
	    size = 12;
	  else
	    size = 16;
	}
      else
	{
	  BFD_ASSERT (entry->tlsdesc_entry);

	  if (entry->tlsdesc_entry >= -(1 << (12 - 1))
	      && entry->tlsdesc_entry < (1 << (12 - 1)))
	    size = 8;
	  else if (entry->tlsdesc_entry >= -(1 << (16 - 1))
		   && entry->tlsdesc_entry < (1 << (16 - 1)))
	    size = 12;
	  else
	    size = 16;
	}

      frvfdpic_plt_section (dinfo->g.info)->size += size;
    }

  return 1;
}

/* Cancel out any effects of calling _frvfdpic_assign_got_entries and
   _frvfdpic_assign_plt_entries.  */

static int
_frvfdpic_reset_got_plt_entries (void **entryp, void *ignore ATTRIBUTE_UNUSED)
{
  struct frvfdpic_relocs_info *entry = *entryp;

  entry->got_entry = 0;
  entry->fdgot_entry = 0;
  entry->fd_entry = 0;
  entry->plt_entry = (bfd_vma)-1;
  entry->lzplt_entry = (bfd_vma)-1;
  entry->tlsoff_entry = 0;
  entry->tlsdesc_entry = 0;
  entry->tlsplt_entry = (bfd_vma)-1;

  return 1;
}

/* Follow indirect and warning hash entries so that each got entry
   points to the final symbol definition.  P must point to a pointer
   to the hash table we're traversing.  Since this traversal may
   modify the hash table, we set this pointer to NULL to indicate
   we've made a potentially-destructive change to the hash table, so
   the traversal must be restarted.  */
static int
_frvfdpic_resolve_final_relocs_info (void **entryp, void *p)
{
  struct frvfdpic_relocs_info *entry = *entryp;
  htab_t *htab = p;

  if (entry->symndx == -1)
    {
      struct elf_link_hash_entry *h = entry->d.h;
      struct frvfdpic_relocs_info *oentry;

      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *)h->root.u.i.link;

      if (entry->d.h == h)
	return 1;

      oentry = frvfdpic_relocs_info_for_global (*htab, 0, h, entry->addend,
						NO_INSERT);

      if (oentry)
	{
	  /* Merge the two entries.  */
	  frvfdpic_pic_merge_early_relocs_info (oentry, entry);
	  htab_clear_slot (*htab, entryp);
	  return 1;
	}

      entry->d.h = h;

      /* If we can't find this entry with the new bfd hash, re-insert
	 it, and get the traversal restarted.  */
      if (! htab_find (*htab, entry))
	{
	  htab_clear_slot (*htab, entryp);
	  entryp = htab_find_slot (*htab, entry, INSERT);
	  if (! *entryp)
	    *entryp = entry;
	  /* Abort the traversal, since the whole table may have
	     moved, and leave it up to the parent to restart the
	     process.  */
	  *(htab_t *)p = NULL;
	  return 0;
	}
    }

  return 1;
}

/* Compute the total size of the GOT, the PLT, the dynamic relocations
   section and the rofixup section.  Assign locations for GOT and PLT
   entries.  */

static bfd_boolean
_frvfdpic_size_got_plt (bfd *output_bfd,
			struct _frvfdpic_dynamic_got_plt_info *gpinfop)
{
  bfd_signed_vma odd;
  bfd_vma limit, tlslimit;
  struct bfd_link_info *info = gpinfop->g.info;
  bfd *dynobj = elf_hash_table (info)->dynobj;

  memcpy (frvfdpic_dynamic_got_plt_info (info), &gpinfop->g,
	  sizeof (gpinfop->g));

  odd = 12;
  /* Compute the total size taken by entries in the 12-bit and 16-bit
     ranges, to tell how many PLT function descriptors we can bring
     into the 12-bit range without causing the 16-bit range to
     overflow.  */
  limit = odd + gpinfop->g.got12 + gpinfop->g.gotlos
    + gpinfop->g.fd12 + gpinfop->g.fdlos
    + gpinfop->g.tlsd12 + gpinfop->g.tlsdlos;
  if (limit < (bfd_vma)1 << 16)
    limit = ((bfd_vma)1 << 16) - limit;
  else
    limit = 0;
  if (gpinfop->g.fdplt < limit)
    {
      tlslimit = (limit - gpinfop->g.fdplt) & ~ (bfd_vma) 8;
      limit = gpinfop->g.fdplt;
    }
  else
    tlslimit = 0;
  if (gpinfop->g.tlsdplt < tlslimit)
    tlslimit = gpinfop->g.tlsdplt;

  /* Determine the ranges of GOT offsets that we can use for each
     range of addressing modes.  */
  odd = _frvfdpic_compute_got_alloc_data (&gpinfop->got12,
					  0,
					  odd,
					  16,
					  gpinfop->g.got12,
					  gpinfop->g.fd12,
					  limit,
					  gpinfop->g.tlsd12,
					  tlslimit,
					  (bfd_vma)1 << (12-1));
  odd = _frvfdpic_compute_got_alloc_data (&gpinfop->gotlos,
					  gpinfop->got12.tmin,
					  odd,
					  gpinfop->got12.tmax,
					  gpinfop->g.gotlos,
					  gpinfop->g.fdlos,
					  gpinfop->g.fdplt
					  - gpinfop->got12.fdplt,
					  gpinfop->g.tlsdlos,
					  gpinfop->g.tlsdplt
					  - gpinfop->got12.tlsdplt,
					  (bfd_vma)1 << (16-1));
  odd = _frvfdpic_compute_got_alloc_data (&gpinfop->gothilo,
					  gpinfop->gotlos.tmin,
					  odd,
					  gpinfop->gotlos.tmax,
					  gpinfop->g.gothilo,
					  gpinfop->g.fdhilo,
					  gpinfop->g.fdplt
					  - gpinfop->got12.fdplt
					  - gpinfop->gotlos.fdplt,
					  gpinfop->g.tlsdhilo,
					  gpinfop->g.tlsdplt
					  - gpinfop->got12.tlsdplt
					  - gpinfop->gotlos.tlsdplt,
					  (bfd_vma)1 << (32-1));

  /* Now assign (most) GOT offsets.  */
  htab_traverse (frvfdpic_relocs_info (info), _frvfdpic_assign_got_entries,
		 gpinfop);

  frvfdpic_got_section (info)->size = gpinfop->gothilo.tmax
    - gpinfop->gothilo.tmin
    /* If an odd word is the last word of the GOT, we don't need this
       word to be part of the GOT.  */
    - (odd + 4 == gpinfop->gothilo.tmax ? 4 : 0);
  if (frvfdpic_got_section (info)->size == 0)
    frvfdpic_got_section (info)->flags |= SEC_EXCLUDE;
  else if (frvfdpic_got_section (info)->size == 12
	   && ! elf_hash_table (info)->dynamic_sections_created)
    {
      frvfdpic_got_section (info)->flags |= SEC_EXCLUDE;
      frvfdpic_got_section (info)->size = 0;
    }
  /* This will be non-NULL during relaxation.  The assumption is that
     the size of one of these sections will never grow, only shrink,
     so we can use the larger buffer we allocated before.  */
  else if (frvfdpic_got_section (info)->contents == NULL)
    {
      frvfdpic_got_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 frvfdpic_got_section (info)->size);
      if (frvfdpic_got_section (info)->contents == NULL)
	return FALSE;
    }

  if (frvfdpic_gotrel_section (info))
    /* Subtract the number of lzplt entries, since those will generate
       relocations in the pltrel section.  */
    frvfdpic_gotrel_section (info)->size =
      (gpinfop->g.relocs - gpinfop->g.lzplt / 8)
      * get_elf_backend_data (output_bfd)->s->sizeof_rel;
  else
    BFD_ASSERT (gpinfop->g.relocs == 0);
  if (frvfdpic_gotrel_section (info)->size == 0)
    frvfdpic_gotrel_section (info)->flags |= SEC_EXCLUDE;
  else if (frvfdpic_gotrel_section (info)->contents == NULL)
    {
      frvfdpic_gotrel_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 frvfdpic_gotrel_section (info)->size);
      if (frvfdpic_gotrel_section (info)->contents == NULL)
	return FALSE;
    }

  frvfdpic_gotfixup_section (info)->size = (gpinfop->g.fixups + 1) * 4;
  if (frvfdpic_gotfixup_section (info)->size == 0)
    frvfdpic_gotfixup_section (info)->flags |= SEC_EXCLUDE;
  else if (frvfdpic_gotfixup_section (info)->contents == NULL)
    {
      frvfdpic_gotfixup_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 frvfdpic_gotfixup_section (info)->size);
      if (frvfdpic_gotfixup_section (info)->contents == NULL)
	return FALSE;
    }

  if (frvfdpic_pltrel_section (info))
    {
      frvfdpic_pltrel_section (info)->size =
	gpinfop->g.lzplt / 8
	* get_elf_backend_data (output_bfd)->s->sizeof_rel;
      if (frvfdpic_pltrel_section (info)->size == 0)
	frvfdpic_pltrel_section (info)->flags |= SEC_EXCLUDE;
      else if (frvfdpic_pltrel_section (info)->contents == NULL)
	{
	  frvfdpic_pltrel_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj,
				     frvfdpic_pltrel_section (info)->size);
	  if (frvfdpic_pltrel_section (info)->contents == NULL)
	    return FALSE;
	}
    }

  /* Add 4 bytes for every block of at most 65535 lazy PLT entries,
     such that there's room for the additional instruction needed to
     call the resolver.  Since _frvfdpic_assign_got_entries didn't
     account for them, our block size is 4 bytes smaller than the real
     block size.  */
  if (frvfdpic_plt_section (info))
    {
      frvfdpic_plt_section (info)->size = gpinfop->g.lzplt
	+ ((gpinfop->g.lzplt + (FRVFDPIC_LZPLT_BLOCK_SIZE - 4) - 8)
	   / (FRVFDPIC_LZPLT_BLOCK_SIZE - 4) * 4);
    }

  /* Reset it, such that _frvfdpic_assign_plt_entries() can use it to
     actually assign lazy PLT entries addresses.  */
  gpinfop->g.lzplt = 0;

  /* Save information that we're going to need to generate GOT and PLT
     entries.  */
  frvfdpic_got_initial_offset (info) = -gpinfop->gothilo.tmin;

  if (get_elf_backend_data (output_bfd)->want_got_sym)
    elf_hash_table (info)->hgot->root.u.def.value
      = frvfdpic_got_initial_offset (info);

  if (frvfdpic_plt_section (info))
    frvfdpic_plt_initial_offset (info) =
      frvfdpic_plt_section (info)->size;

  /* Allocate a ret statement at plt_initial_offset, to be used by
     locally-resolved TLS descriptors.  */
  if (gpinfop->g.tls_ret_refs)
    frvfdpic_plt_section (info)->size += 4;

  htab_traverse (frvfdpic_relocs_info (info), _frvfdpic_assign_plt_entries,
		 gpinfop);

  /* Allocate the PLT section contents only after
     _frvfdpic_assign_plt_entries has a chance to add the size of the
     non-lazy PLT entries.  */
  if (frvfdpic_plt_section (info))
    {
      if (frvfdpic_plt_section (info)->size == 0)
	frvfdpic_plt_section (info)->flags |= SEC_EXCLUDE;
      else if (frvfdpic_plt_section (info)->contents == NULL)
	{
	  frvfdpic_plt_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj,
				     frvfdpic_plt_section (info)->size);
	  if (frvfdpic_plt_section (info)->contents == NULL)
	    return FALSE;
	}
    }

  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf32_frvfdpic_size_dynamic_sections (bfd *output_bfd,
				      struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  struct _frvfdpic_dynamic_got_plt_info gpinfo;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  memset (&gpinfo, 0, sizeof (gpinfo));
  gpinfo.g.info = info;

  for (;;)
    {
      htab_t relocs = frvfdpic_relocs_info (info);

      htab_traverse (relocs, _frvfdpic_resolve_final_relocs_info, &relocs);

      if (relocs == frvfdpic_relocs_info (info))
	break;
    }

  htab_traverse (frvfdpic_relocs_info (info), _frvfdpic_count_got_plt_entries,
		 &gpinfo.g);

  /* Allocate space to save the summary information, we're going to
     use it if we're doing relaxations.  */
  frvfdpic_dynamic_got_plt_info (info) = bfd_alloc (dynobj, sizeof (gpinfo.g));

  if (!_frvfdpic_size_got_plt (output_bfd, &gpinfo))
    return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      if (frvfdpic_got_section (info)->size)
	if (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0))
	  return FALSE;

      if (frvfdpic_pltrel_section (info)->size)
	if (!_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_REL)
	    || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))
	  return FALSE;

      if (frvfdpic_gotrel_section (info)->size)
	if (!_bfd_elf_add_dynamic_entry (info, DT_REL, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_RELSZ, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_RELENT,
					    sizeof (Elf32_External_Rel)))
	  return FALSE;
    }

  return TRUE;
}

static bfd_boolean
elf32_frvfdpic_always_size_sections (bfd *output_bfd,
				     struct bfd_link_info *info)
{
  if (!info->relocatable
      && !bfd_elf_stack_segment_size (output_bfd, info,
				      "__stacksize", DEFAULT_STACK_SIZE))
    return FALSE;

  return TRUE;
}

/* Check whether any of the relocations was optimized away, and
   subtract it from the relocation or fixup count.  */
static bfd_boolean
_frvfdpic_check_discarded_relocs (bfd *abfd, asection *sec,
				  struct bfd_link_info *info,

				  bfd_boolean *changed)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel, *erel;

  if ((sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  rel = elf_section_data (sec)->relocs;

  /* Now examine each relocation.  */
  for (erel = rel + sec->reloc_count; rel < erel; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;
      struct frvfdpic_relocs_info *picrel;
      struct _frvfdpic_dynamic_got_info *dinfo;

      if (ELF32_R_TYPE (rel->r_info) != R_FRV_32
	  && ELF32_R_TYPE (rel->r_info) != R_FRV_FUNCDESC)
	continue;

      if (_bfd_elf_section_offset (sec->output_section->owner,
				   info, sec, rel->r_offset)
	  != (bfd_vma)-1)
	continue;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *)h->root.u.i.link;
	}

      if (h != NULL)
	picrel = frvfdpic_relocs_info_for_global (frvfdpic_relocs_info (info),
						  abfd, h,
						  rel->r_addend, NO_INSERT);
      else
	picrel = frvfdpic_relocs_info_for_local (frvfdpic_relocs_info (info),
						 abfd, r_symndx,
						 rel->r_addend, NO_INSERT);

      if (! picrel)
	return FALSE;

      *changed = TRUE;
      dinfo = frvfdpic_dynamic_got_plt_info (info);

      _frvfdpic_count_relocs_fixups (picrel, dinfo, TRUE);
      if (ELF32_R_TYPE (rel->r_info) == R_FRV_32)
	picrel->relocs32--;
      else /* we know (ELF32_R_TYPE (rel->r_info) == R_FRV_FUNCDESC) */
	picrel->relocsfd--;
      _frvfdpic_count_relocs_fixups (picrel, dinfo, FALSE);
    }

  return TRUE;
}

static bfd_boolean
frvfdpic_elf_discard_info (bfd *ibfd,
			   struct elf_reloc_cookie *cookie ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info)
{
  bfd_boolean changed = FALSE;
  asection *s;
  bfd *obfd = NULL;

  /* Account for relaxation of .eh_frame section.  */
  for (s = ibfd->sections; s; s = s->next)
    if (s->sec_info_type == SEC_INFO_TYPE_EH_FRAME)
      {
	if (!_frvfdpic_check_discarded_relocs (ibfd, s, info, &changed))
	  return FALSE;
	obfd = s->output_section->owner;
      }

  if (changed)
    {
      struct _frvfdpic_dynamic_got_plt_info gpinfo;

      memset (&gpinfo, 0, sizeof (gpinfo));
      memcpy (&gpinfo.g, frvfdpic_dynamic_got_plt_info (info),
	      sizeof (gpinfo.g));

      /* Clear GOT and PLT assignments.  */
      htab_traverse (frvfdpic_relocs_info (info),
		     _frvfdpic_reset_got_plt_entries,
		     NULL);

      if (!_frvfdpic_size_got_plt (obfd, &gpinfo))
	return FALSE;
    }

  return TRUE;
}

/* Look for opportunities to relax TLS relocations.  We can assume
   we're linking the main executable or a static-tls library, since
   otherwise we wouldn't have got here.  */

static int
_frvfdpic_relax_got_plt_entries (void **entryp, void *dinfo_)
{
  struct frvfdpic_relocs_info *entry = *entryp;
  struct _frvfdpic_dynamic_got_info *dinfo = dinfo_;

  _frvfdpic_relax_tls_entries (entry, dinfo, TRUE);

  return 1;
}

static bfd_boolean
elf32_frvfdpic_relax_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
			      struct bfd_link_info *info, bfd_boolean *again)
{
  struct _frvfdpic_dynamic_got_plt_info gpinfo;

  if (info->relocatable)
    (*info->callbacks->einfo)
      (_("%P%F: --relax and -r may not be used together\n"));

  /* If we return early, we didn't change anything.  */
  *again = FALSE;

  /* We'll do our thing when requested to relax the GOT section.  */
  if (sec != frvfdpic_got_section (info))
    return TRUE;

  /* We can only relax when linking the main executable or a library
     that can't be dlopened.  */
  if (! info->executable && ! (info->flags & DF_STATIC_TLS))
    return TRUE;

  /* If there isn't a TLS section for this binary, we can't do
     anything about its TLS relocations (it probably doesn't have
     any.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return TRUE;

  memset (&gpinfo, 0, sizeof (gpinfo));
  memcpy (&gpinfo.g, frvfdpic_dynamic_got_plt_info (info), sizeof (gpinfo.g));

  /* Now look for opportunities to relax, adjusting the GOT usage
     as needed.  */
  htab_traverse (frvfdpic_relocs_info (info),
		 _frvfdpic_relax_got_plt_entries,
		 &gpinfo.g);

  /* If we changed anything, reset and re-assign GOT and PLT entries.  */
  if (memcmp (frvfdpic_dynamic_got_plt_info (info),
	      &gpinfo.g, sizeof (gpinfo.g)) != 0)
    {
      /* Clear GOT and PLT assignments.  */
      htab_traverse (frvfdpic_relocs_info (info),
		     _frvfdpic_reset_got_plt_entries,
		     NULL);

      /* The owner of the TLS section is the output bfd.  There should
	 be a better way to get to it.  */
      if (!_frvfdpic_size_got_plt (elf_hash_table (info)->tls_sec->owner,
				   &gpinfo))
	return FALSE;

      /* Repeat until we don't make any further changes.  We could fail to
	 introduce changes in a round if, for example, the 12-bit range is
	 full, but we later release some space by getting rid of TLS
	 descriptors in it.  We have to repeat the whole process because
	 we might have changed the size of a section processed before this
	 one.  */
      *again = TRUE;
    }

  return TRUE;
}

/* Fill in code and data in dynamic sections.  */

static bfd_boolean
elf32_frv_finish_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				   struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  /* Nothing to be done for non-FDPIC.  */
  return TRUE;
}

static bfd_boolean
elf32_frvfdpic_finish_dynamic_sections (bfd *output_bfd,
					struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sdyn;

  dynobj = elf_hash_table (info)->dynobj;

  if (frvfdpic_dynamic_got_plt_info (info))
    {
      BFD_ASSERT (frvfdpic_dynamic_got_plt_info (info)->tls_ret_refs == 0);
    }
  if (frvfdpic_got_section (info))
    {
      BFD_ASSERT (frvfdpic_gotrel_section (info)->size
		  == (frvfdpic_gotrel_section (info)->reloc_count
		      * sizeof (Elf32_External_Rel)));

      if (frvfdpic_gotfixup_section (info))
	{
	  struct elf_link_hash_entry *hgot = elf_hash_table (info)->hgot;
	  bfd_vma got_value = hgot->root.u.def.value
	    + hgot->root.u.def.section->output_section->vma
	    + hgot->root.u.def.section->output_offset;
	  struct bfd_link_hash_entry *hend;

	  _frvfdpic_add_rofixup (output_bfd, frvfdpic_gotfixup_section (info),
				 got_value, 0);

	  if (frvfdpic_gotfixup_section (info)->size
	      != (frvfdpic_gotfixup_section (info)->reloc_count * 4))
	    {
	    error:
	      info->callbacks->einfo
		("LINKER BUG: .rofixup section size mismatch\n");
	      return FALSE;
	    }

	  hend = bfd_link_hash_lookup (info->hash, "__ROFIXUP_END__",
				       FALSE, FALSE, TRUE);
	  if (hend
	      && (hend->type == bfd_link_hash_defined
		  || hend->type == bfd_link_hash_defweak)
	      && hend->u.def.section->output_section != NULL)
	    {
	      bfd_vma value =
		frvfdpic_gotfixup_section (info)->output_section->vma
		+ frvfdpic_gotfixup_section (info)->output_offset
		+ frvfdpic_gotfixup_section (info)->size
		- hend->u.def.section->output_section->vma
		- hend->u.def.section->output_offset;
	      BFD_ASSERT (hend->u.def.value == value);
	      if (hend->u.def.value != value)
		goto error;
	    }
	}
    }
  if (frvfdpic_pltrel_section (info))
    {
      BFD_ASSERT (frvfdpic_pltrel_section (info)->size
		  == (frvfdpic_pltrel_section (info)->reloc_count
		      * sizeof (Elf32_External_Rel)));
    }


  if (elf_hash_table (info)->dynamic_sections_created)
    {
      Elf32_External_Dyn * dyncon;
      Elf32_External_Dyn * dynconend;

      sdyn = bfd_get_linker_section (dynobj, ".dynamic");

      BFD_ASSERT (sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);

      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_PLTGOT:
	      dyn.d_un.d_ptr = frvfdpic_got_section (info)->output_section->vma
		+ frvfdpic_got_section (info)->output_offset
		+ frvfdpic_got_initial_offset (info);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_JMPREL:
	      dyn.d_un.d_ptr = frvfdpic_pltrel_section (info)
		->output_section->vma
		+ frvfdpic_pltrel_section (info)->output_offset;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      dyn.d_un.d_val = frvfdpic_pltrel_section (info)->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	    }
	}
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  */

static bfd_boolean
elf32_frvfdpic_adjust_dynamic_symbol
(struct bfd_link_info *info ATTRIBUTE_UNUSED,
 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
{
  bfd * dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
    }

  return TRUE;
}

/* Perform any actions needed for dynamic symbols.  */

static bfd_boolean
elf32_frvfdpic_finish_dynamic_symbol
(bfd *output_bfd ATTRIBUTE_UNUSED,
 struct bfd_link_info *info ATTRIBUTE_UNUSED,
 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED,
 Elf_Internal_Sym *sym ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Decide whether to attempt to turn absptr or lsda encodings in
   shared libraries into pcrel within the given input section.  */

static bfd_boolean
frvfdpic_elf_use_relative_eh_frame
(bfd *input_bfd ATTRIBUTE_UNUSED,
 struct bfd_link_info *info ATTRIBUTE_UNUSED,
 asection *eh_frame_section ATTRIBUTE_UNUSED)
{
  /* We can't use PC-relative encodings in FDPIC binaries, in general.  */
  return FALSE;
}

/* Adjust the contents of an eh_frame_hdr section before they're output.  */

static bfd_byte
frvfdpic_elf_encode_eh_address (bfd *abfd,
				struct bfd_link_info *info,
				asection *osec, bfd_vma offset,
				asection *loc_sec, bfd_vma loc_offset,
				bfd_vma *encoded)
{
  struct elf_link_hash_entry *h;

  h = elf_hash_table (info)->hgot;
  BFD_ASSERT (h && h->root.type == bfd_link_hash_defined);

  if (! h || (_frvfdpic_osec_to_segment (abfd, osec)
	      == _frvfdpic_osec_to_segment (abfd, loc_sec->output_section)))
    return _bfd_elf_encode_eh_address (abfd, info, osec, offset,
				       loc_sec, loc_offset, encoded);

  BFD_ASSERT (_frvfdpic_osec_to_segment (abfd, osec)
	      == (_frvfdpic_osec_to_segment
		  (abfd, h->root.u.def.section->output_section)));

  *encoded = osec->vma + offset
    - (h->root.u.def.value
       + h->root.u.def.section->output_section->vma
       + h->root.u.def.section->output_offset);

  return DW_EH_PE_datarel | DW_EH_PE_sdata4;
}

/* Look through the relocs for a section during the first phase.

   Besides handling virtual table relocs for gc, we have to deal with
   all sorts of PIC-related relocations.  We describe below the
   general plan on how to handle such relocations, even though we only
   collect information at this point, storing them in hash tables for
   perusal of later passes.

   32 relocations are propagated to the linker output when creating
   position-independent output.  LO16 and HI16 relocations are not
   supposed to be encountered in this case.

   LABEL16 should always be resolvable by the linker, since it's only
   used by branches.

   LABEL24, on the other hand, is used by calls.  If it turns out that
   the target of a call is a dynamic symbol, a PLT entry must be
   created for it, which triggers the creation of a private function
   descriptor and, unless lazy binding is disabled, a lazy PLT entry.

   GPREL relocations require the referenced symbol to be in the same
   segment as _gp, but this can only be checked later.

   All GOT, GOTOFF and FUNCDESC relocations require a .got section to
   exist.  LABEL24 might as well, since it may require a PLT entry,
   that will require a got.

   Non-FUNCDESC GOT relocations require a GOT entry to be created
   regardless of whether the symbol is dynamic.  However, since a
   global symbol that turns out to not be exported may have the same
   address of a non-dynamic symbol, we don't assign GOT entries at
   this point, such that we can share them in this case.  A relocation
   for the GOT entry always has to be created, be it to offset a
   private symbol by the section load address, be it to get the symbol
   resolved dynamically.

   FUNCDESC GOT relocations require a GOT entry to be created, and
   handled as if a FUNCDESC relocation was applied to the GOT entry in
   an object file.

   FUNCDESC relocations referencing a symbol that turns out to NOT be
   dynamic cause a private function descriptor to be created.  The
   FUNCDESC relocation then decays to a 32 relocation that points at
   the private descriptor.  If the symbol is dynamic, the FUNCDESC
   relocation is propagated to the linker output, such that the
   dynamic linker creates the canonical descriptor, pointing to the
   dynamically-resolved definition of the function.

   Non-FUNCDESC GOTOFF relocations must always refer to non-dynamic
   symbols that are assigned to the same segment as the GOT, but we
   can only check this later, after we know the complete set of
   symbols defined and/or exported.

   FUNCDESC GOTOFF relocations require a function descriptor to be
   created and, unless lazy binding is disabled or the symbol is not
   dynamic, a lazy PLT entry.  Since we can't tell at this point
   whether a symbol is going to be dynamic, we have to decide later
   whether to create a lazy PLT entry or bind the descriptor directly
   to the private function.

   FUNCDESC_VALUE relocations are not supposed to be present in object
   files, but they may very well be simply propagated to the linker
   output, since they have no side effect.


   A function descriptor always requires a FUNCDESC_VALUE relocation.
   Whether it's in .plt.rel or not depends on whether lazy binding is
   enabled and on whether the referenced symbol is dynamic.

   The existence of a lazy PLT requires the resolverStub lazy PLT
   entry to be present.


   As for assignment of GOT, PLT and lazy PLT entries, and private
   descriptors, we might do them all sequentially, but we can do
   better than that.  For example, we can place GOT entries and
   private function descriptors referenced using 12-bit operands
   closer to the PIC register value, such that these relocations don't
   overflow.  Those that are only referenced with LO16 relocations
   could come next, but we may as well place PLT-required function
   descriptors in the 12-bit range to make them shorter.  Symbols
   referenced with LO16/HI16 may come next, but we may place
   additional function descriptors in the 16-bit range if we can
   reliably tell that we've already placed entries that are ever
   referenced with only LO16.  PLT entries are therefore generated as
   small as possible, while not introducing relocation overflows in
   GOT or FUNCDESC_GOTOFF relocations.  Lazy PLT entries could be
   generated before or after PLT entries, but not intermingled with
   them, such that we can have more lazy PLT entries in range for a
   branch to the resolverStub.  The resolverStub should be emitted at
   the most distant location from the first lazy PLT entry such that
   it's still in range for a branch, or closer, if there isn't a need
   for so many lazy PLT entries.  Additional lazy PLT entries may be
   emitted after the resolverStub, as long as branches are still in
   range.  If the branch goes out of range, longer lazy PLT entries
   are emitted.

   We could further optimize PLT and lazy PLT entries by giving them
   priority in assignment to closer-to-gr17 locations depending on the
   number of occurrences of references to them (assuming a function
   that's called more often is more important for performance, so its
   PLT entry should be faster), or taking hints from the compiler.
   Given infinite time and money... :-)  */

static bfd_boolean
elf32_frv_check_relocs (bfd *abfd,
			struct bfd_link_info *info,
			asection *sec,
			const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  bfd *dynobj;
  struct frvfdpic_relocs_info *picrel;

  if (info->relocatable)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  dynobj = elf_hash_table (info)->dynobj;
  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_FRV_GETTLSOFF:
	case R_FRV_TLSDESC_VALUE:
	case R_FRV_GOTTLSDESC12:
	case R_FRV_GOTTLSDESCHI:
	case R_FRV_GOTTLSDESCLO:
	case R_FRV_GOTTLSOFF12:
	case R_FRV_GOTTLSOFFHI:
	case R_FRV_GOTTLSOFFLO:
	case R_FRV_TLSOFF:
	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFFLO:
	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	case R_FRV_FUNCDESC:
	case R_FRV_FUNCDESC_VALUE:
	case R_FRV_TLSMOFF12:
	case R_FRV_TLSMOFFHI:
	case R_FRV_TLSMOFFLO:
	case R_FRV_TLSMOFF:
	  if (! IS_FDPIC (abfd))
	    goto bad_reloc;
	  /* Fall through.  */
	case R_FRV_GPREL12:
	case R_FRV_GPRELU12:
	case R_FRV_GPRELHI:
	case R_FRV_GPRELLO:
	case R_FRV_LABEL24:
	case R_FRV_32:
	  if (! dynobj)
	    {
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _frv_create_got_section (abfd, info))
		return FALSE;
	    }
	  if (! IS_FDPIC (abfd))
	    {
	      picrel = NULL;
	      break;
	    }
	  if (h != NULL)
	    {
	      if (h->dynindx == -1)
		switch (ELF_ST_VISIBILITY (h->other))
		  {
		  case STV_INTERNAL:
		  case STV_HIDDEN:
		    break;
		  default:
		    bfd_elf_link_record_dynamic_symbol (info, h);
		    break;
		  }
	      picrel
		= frvfdpic_relocs_info_for_global (frvfdpic_relocs_info (info),
						   abfd, h,
						   rel->r_addend, INSERT);
	    }
	  else
	    picrel = frvfdpic_relocs_info_for_local (frvfdpic_relocs_info
						     (info), abfd, r_symndx,
						     rel->r_addend, INSERT);
	  if (! picrel)
	    return FALSE;
	  break;

	default:
	  picrel = NULL;
	  break;
	}

      switch (ELF32_R_TYPE (rel->r_info))
        {
	case R_FRV_LABEL24:
	  if (IS_FDPIC (abfd))
	    picrel->call = 1;
	  break;

	case R_FRV_FUNCDESC_VALUE:
	  picrel->relocsfdv++;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32--;
	  /* Fall through.  */

	case R_FRV_32:
	  if (! IS_FDPIC (abfd))
	    break;

	  picrel->sym = 1;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32++;
	  break;

	case R_FRV_GOT12:
	  picrel->got12 = 1;
	  break;

	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	  picrel->gothilo = 1;
	  break;

	case R_FRV_FUNCDESC_GOT12:
	  picrel->fdgot12 = 1;
	  break;

	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	  picrel->fdgothilo = 1;
	  break;

	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFFLO:
	  picrel->gotoff = 1;
	  break;

	case R_FRV_FUNCDESC_GOTOFF12:
	  picrel->fdgoff12 = 1;
	  break;

	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	  picrel->fdgoffhilo = 1;
	  break;

	case R_FRV_FUNCDESC:
	  picrel->fd = 1;
	  picrel->relocsfd++;
	  break;

	case R_FRV_GETTLSOFF:
	  picrel->tlsplt = 1;
	  break;

	case R_FRV_TLSDESC_VALUE:
	  picrel->relocstlsd++;
	  goto bad_reloc;

	case R_FRV_GOTTLSDESC12:
	  picrel->tlsdesc12 = 1;
	  break;

	case R_FRV_GOTTLSDESCHI:
	case R_FRV_GOTTLSDESCLO:
	  picrel->tlsdeschilo = 1;
	  break;

	case R_FRV_TLSMOFF12:
	case R_FRV_TLSMOFFHI:
	case R_FRV_TLSMOFFLO:
	case R_FRV_TLSMOFF:
	  break;

	case R_FRV_GOTTLSOFF12:
	  picrel->tlsoff12 = 1;
	  info->flags |= DF_STATIC_TLS;
	  break;

	case R_FRV_GOTTLSOFFHI:
	case R_FRV_GOTTLSOFFLO:
	  picrel->tlsoffhilo = 1;
	  info->flags |= DF_STATIC_TLS;
	  break;

	case R_FRV_TLSOFF:
	  picrel->relocstlsoff++;
	  info->flags |= DF_STATIC_TLS;
	  goto bad_reloc;

        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_FRV_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
        case R_FRV_GNU_VTENTRY:
          BFD_ASSERT (h != NULL);
          if (h != NULL
              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;

	case R_FRV_LABEL16:
	case R_FRV_LO16:
	case R_FRV_HI16:
	case R_FRV_GPREL12:
	case R_FRV_GPRELU12:
	case R_FRV_GPREL32:
	case R_FRV_GPRELHI:
	case R_FRV_GPRELLO:
	case R_FRV_TLSDESC_RELAX:
	case R_FRV_GETTLSOFF_RELAX:
	case R_FRV_TLSOFF_RELAX:
	  break;

	default:
	bad_reloc:
	  info->callbacks->einfo
	    (_("%B: unsupported relocation type %i\n"),
	     abfd, ELF32_R_TYPE (rel->r_info));
	  return FALSE;
        }
    }

  return TRUE;
}


/* Return the machine subcode from the ELF e_flags header.  */

static int
elf32_frv_machine (bfd *abfd)
{
  switch (elf_elfheader (abfd)->e_flags & EF_FRV_CPU_MASK)
    {
    default:		    break;
    case EF_FRV_CPU_FR550:  return bfd_mach_fr550;
    case EF_FRV_CPU_FR500:  return bfd_mach_fr500;
    case EF_FRV_CPU_FR450:  return bfd_mach_fr450;
    case EF_FRV_CPU_FR405:  return bfd_mach_fr400;
    case EF_FRV_CPU_FR400:  return bfd_mach_fr400;
    case EF_FRV_CPU_FR300:  return bfd_mach_fr300;
    case EF_FRV_CPU_SIMPLE: return bfd_mach_frvsimple;
    case EF_FRV_CPU_TOMCAT: return bfd_mach_frvtomcat;
    }

  return bfd_mach_frv;
}

/* Set the right machine number for a FRV ELF file.  */

static bfd_boolean
elf32_frv_object_p (bfd *abfd)
{
  bfd_default_set_arch_mach (abfd, bfd_arch_frv, elf32_frv_machine (abfd));
  return (((elf_elfheader (abfd)->e_flags & EF_FRV_FDPIC) != 0)
	  == (IS_FDPIC (abfd)));
}

/* Function to set the ELF flag bits.  */

static bfd_boolean
frv_elf_set_private_flags (bfd *abfd, flagword flags)
{
  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}

/* Copy backend specific data from one object module to another.  */

static bfd_boolean
frv_elf_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || elf_elfheader (obfd)->e_flags == elf_elfheader (ibfd)->e_flags);

  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = TRUE;

  /* Copy object attributes.  */
  _bfd_elf_copy_obj_attributes (ibfd, obfd);

  return TRUE;
}

/* Return true if the architecture described by elf header flag
   EXTENSION is an extension of the architecture described by BASE.  */

static bfd_boolean
frv_elf_arch_extension_p (flagword base, flagword extension)
{
  if (base == extension)
    return TRUE;

  /* CPU_GENERIC code can be merged with code for a specific
     architecture, in which case the result is marked as being
     for the specific architecture.  Everything is therefore
     an extension of CPU_GENERIC.  */
  if (base == EF_FRV_CPU_GENERIC)
    return TRUE;

  if (extension == EF_FRV_CPU_FR450)
    if (base == EF_FRV_CPU_FR400 || base == EF_FRV_CPU_FR405)
      return TRUE;

  if (extension == EF_FRV_CPU_FR405)
    if (base == EF_FRV_CPU_FR400)
      return TRUE;

  return FALSE;
}

static bfd_boolean
elf32_frvfdpic_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  if (! frv_elf_copy_private_bfd_data (ibfd, obfd))
    return FALSE;

  if (! elf_tdata (ibfd) || ! elf_tdata (ibfd)->phdr
      || ! elf_tdata (obfd) || ! elf_tdata (obfd)->phdr)
    return TRUE;

  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
frv_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword old_flags, old_partial;
  flagword new_flags, new_partial;
  bfd_boolean error = FALSE;
  char new_opt[80];
  char old_opt[80];

  new_opt[0] = old_opt[0] = '\0';
  new_flags = elf_elfheader (ibfd)->e_flags;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (new_flags & EF_FRV_FDPIC)
    new_flags &= ~EF_FRV_PIC;

#ifdef DEBUG
  (*_bfd_error_handler) ("old_flags = 0x%.8lx, new_flags = 0x%.8lx, init = %s, filename = %s",
			 old_flags, new_flags, elf_flags_init (obfd) ? "yes" : "no",
			 bfd_get_filename (ibfd));
#endif

  if (!elf_flags_init (obfd))			/* First call, no flags set.  */
    {
      elf_flags_init (obfd) = TRUE;
      old_flags = new_flags;
    }

  else if (new_flags == old_flags)		/* Compatible flags are ok.  */
    ;

  else						/* Possibly incompatible flags.  */
    {
      /* Warn if different # of gprs are used.  Note, 0 means nothing is
         said about the size of gprs.  */
      new_partial = (new_flags & EF_FRV_GPR_MASK);
      old_partial = (old_flags & EF_FRV_GPR_MASK);
      if (new_partial == old_partial)
	;

      else if (new_partial == 0)
	;

      else if (old_partial == 0)
	old_flags |= new_partial;

      else
	{
	  switch (new_partial)
	    {
	    default:		strcat (new_opt, " -mgpr-??"); break;
	    case EF_FRV_GPR_32: strcat (new_opt, " -mgpr-32"); break;
	    case EF_FRV_GPR_64: strcat (new_opt, " -mgpr-64"); break;
	    }

	  switch (old_partial)
	    {
	    default:		strcat (old_opt, " -mgpr-??"); break;
	    case EF_FRV_GPR_32: strcat (old_opt, " -mgpr-32"); break;
	    case EF_FRV_GPR_64: strcat (old_opt, " -mgpr-64"); break;
	    }
	}

      /* Warn if different # of fprs are used.  Note, 0 means nothing is
         said about the size of fprs.  */
      new_partial = (new_flags & EF_FRV_FPR_MASK);
      old_partial = (old_flags & EF_FRV_FPR_MASK);
      if (new_partial == old_partial)
	;

      else if (new_partial == 0)
	;

      else if (old_partial == 0)
	old_flags |= new_partial;

      else
	{
	  switch (new_partial)
	    {
	    default:		  strcat (new_opt, " -mfpr-?");      break;
	    case EF_FRV_FPR_32:   strcat (new_opt, " -mfpr-32");     break;
	    case EF_FRV_FPR_64:   strcat (new_opt, " -mfpr-64");     break;
	    case EF_FRV_FPR_NONE: strcat (new_opt, " -msoft-float"); break;
	    }

	  switch (old_partial)
	    {
	    default:		  strcat (old_opt, " -mfpr-?");      break;
	    case EF_FRV_FPR_32:   strcat (old_opt, " -mfpr-32");     break;
	    case EF_FRV_FPR_64:   strcat (old_opt, " -mfpr-64");     break;
	    case EF_FRV_FPR_NONE: strcat (old_opt, " -msoft-float"); break;
	    }
	}

      /* Warn if different dword support was used.  Note, 0 means nothing is
         said about the dword support.  */
      new_partial = (new_flags & EF_FRV_DWORD_MASK);
      old_partial = (old_flags & EF_FRV_DWORD_MASK);
      if (new_partial == old_partial)
	;

      else if (new_partial == 0)
	;

      else if (old_partial == 0)
	old_flags |= new_partial;

      else
	{
	  switch (new_partial)
	    {
	    default:		   strcat (new_opt, " -mdword-?");  break;
	    case EF_FRV_DWORD_YES: strcat (new_opt, " -mdword");    break;
	    case EF_FRV_DWORD_NO:  strcat (new_opt, " -mno-dword"); break;
	    }

	  switch (old_partial)
	    {
	    default:		   strcat (old_opt, " -mdword-?");  break;
	    case EF_FRV_DWORD_YES: strcat (old_opt, " -mdword");    break;
	    case EF_FRV_DWORD_NO:  strcat (old_opt, " -mno-dword"); break;
	    }
	}

      /* Or in flags that accumulate (ie, if one module uses it, mark that the
	 feature is used.  */
      old_flags |= new_flags & (EF_FRV_DOUBLE
				| EF_FRV_MEDIA
				| EF_FRV_MULADD
				| EF_FRV_NON_PIC_RELOCS);

      /* If any module was compiled without -G0, clear the G0 bit.  */
      old_flags = ((old_flags & ~ EF_FRV_G0)
		   | (old_flags & new_flags & EF_FRV_G0));

      /* If any module was compiled without -mnopack, clear the mnopack bit.  */
      old_flags = ((old_flags & ~ EF_FRV_NOPACK)
		   | (old_flags & new_flags & EF_FRV_NOPACK));

      /* We don't have to do anything if the pic flags are the same, or the new
         module(s) were compiled with -mlibrary-pic.  */
      new_partial = (new_flags & EF_FRV_PIC_FLAGS);
      old_partial = (old_flags & EF_FRV_PIC_FLAGS);
      if ((new_partial == old_partial) || ((new_partial & EF_FRV_LIBPIC) != 0))
	;

      /* If the old module(s) were compiled with -mlibrary-pic, copy in the pic
         flags if any from the new module.  */
      else if ((old_partial & EF_FRV_LIBPIC) != 0)
	old_flags = (old_flags & ~ EF_FRV_PIC_FLAGS) | new_partial;

      /* If we have mixtures of -fpic and -fPIC, or in both bits.  */
      else if (new_partial != 0 && old_partial != 0)
	old_flags |= new_partial;

      /* One module was compiled for pic and the other was not, see if we have
         had any relocations that are not pic-safe.  */
      else
	{
	  if ((old_flags & EF_FRV_NON_PIC_RELOCS) == 0)
	    old_flags |= new_partial;
	  else
	    {
	      old_flags &= ~ EF_FRV_PIC_FLAGS;
#ifndef FRV_NO_PIC_ERROR
	      error = TRUE;
	      (*_bfd_error_handler)
		(_("%s: compiled with %s and linked with modules that use non-pic relocations"),
		 bfd_get_filename (ibfd),
		 (new_flags & EF_FRV_BIGPIC) ? "-fPIC" : "-fpic");
#endif
	    }
	}

      /* Warn if different cpu is used (allow a specific cpu to override
	 the generic cpu).  */
      new_partial = (new_flags & EF_FRV_CPU_MASK);
      old_partial = (old_flags & EF_FRV_CPU_MASK);
      if (frv_elf_arch_extension_p (new_partial, old_partial))
	;

      else if (frv_elf_arch_extension_p (old_partial, new_partial))
	old_flags = (old_flags & ~EF_FRV_CPU_MASK) | new_partial;

      else
	{
	  switch (new_partial)
	    {
	    default:		     strcat (new_opt, " -mcpu=?");      break;
	    case EF_FRV_CPU_GENERIC: strcat (new_opt, " -mcpu=frv");    break;
	    case EF_FRV_CPU_SIMPLE:  strcat (new_opt, " -mcpu=simple"); break;
	    case EF_FRV_CPU_FR550:   strcat (new_opt, " -mcpu=fr550");  break;
	    case EF_FRV_CPU_FR500:   strcat (new_opt, " -mcpu=fr500");  break;
	    case EF_FRV_CPU_FR450:   strcat (new_opt, " -mcpu=fr450");  break;
	    case EF_FRV_CPU_FR405:   strcat (new_opt, " -mcpu=fr405");  break;
	    case EF_FRV_CPU_FR400:   strcat (new_opt, " -mcpu=fr400");  break;
	    case EF_FRV_CPU_FR300:   strcat (new_opt, " -mcpu=fr300");  break;
	    case EF_FRV_CPU_TOMCAT:  strcat (new_opt, " -mcpu=tomcat"); break;
	    }

	  switch (old_partial)
	    {
	    default:		     strcat (old_opt, " -mcpu=?");      break;
	    case EF_FRV_CPU_GENERIC: strcat (old_opt, " -mcpu=frv");    break;
	    case EF_FRV_CPU_SIMPLE:  strcat (old_opt, " -mcpu=simple"); break;
	    case EF_FRV_CPU_FR550:   strcat (old_opt, " -mcpu=fr550");  break;
	    case EF_FRV_CPU_FR500:   strcat (old_opt, " -mcpu=fr500");  break;
	    case EF_FRV_CPU_FR450:   strcat (old_opt, " -mcpu=fr450");  break;
	    case EF_FRV_CPU_FR405:   strcat (old_opt, " -mcpu=fr405");  break;
	    case EF_FRV_CPU_FR400:   strcat (old_opt, " -mcpu=fr400");  break;
	    case EF_FRV_CPU_FR300:   strcat (old_opt, " -mcpu=fr300");  break;
	    case EF_FRV_CPU_TOMCAT:  strcat (old_opt, " -mcpu=tomcat"); break;
	    }
	}

      /* Print out any mismatches from above.  */
      if (new_opt[0])
	{
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%s: compiled with %s and linked with modules compiled with %s"),
	     bfd_get_filename (ibfd), new_opt, old_opt);
	}

      /* Warn about any other mismatches */
      new_partial = (new_flags & ~ EF_FRV_ALL_FLAGS);
      old_partial = (old_flags & ~ EF_FRV_ALL_FLAGS);
      if (new_partial != old_partial)
	{
	  old_flags |= new_partial;
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%s: uses different unknown e_flags (0x%lx) fields than previous modules (0x%lx)"),
	     bfd_get_filename (ibfd), (long)new_partial, (long)old_partial);
	}
    }

  /* If the cpu is -mcpu=simple, then set the -mnopack bit.  */
  if ((old_flags & EF_FRV_CPU_MASK) == EF_FRV_CPU_SIMPLE)
    old_flags |= EF_FRV_NOPACK;

  /* Update the old flags now with changes made above.  */
  old_partial = elf_elfheader (obfd)->e_flags & EF_FRV_CPU_MASK;
  elf_elfheader (obfd)->e_flags = old_flags;
  if (old_partial != (old_flags & EF_FRV_CPU_MASK))
    bfd_default_set_arch_mach (obfd, bfd_arch_frv, elf32_frv_machine (obfd));

  if (((new_flags & EF_FRV_FDPIC) == 0)
      != (! IS_FDPIC (ibfd)))
    {
      error = TRUE;
      if (IS_FDPIC (obfd))
	(*_bfd_error_handler)
	  (_("%s: cannot link non-fdpic object file into fdpic executable"),
	   bfd_get_filename (ibfd));
      else
	(*_bfd_error_handler)
	  (_("%s: cannot link fdpic object file into non-fdpic executable"),
	   bfd_get_filename (ibfd));
    }

  if (error)
    bfd_set_error (bfd_error_bad_value);

  return !error;
}


static bfd_boolean
frv_elf_print_private_bfd_data (bfd *abfd, void * ptr)
{
  FILE *file = (FILE *) ptr;
  flagword flags;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  flags = elf_elfheader (abfd)->e_flags;
  fprintf (file, _("private flags = 0x%lx:"), (unsigned long) flags);

  switch (flags & EF_FRV_CPU_MASK)
    {
    default:							break;
    case EF_FRV_CPU_SIMPLE: fprintf (file, " -mcpu=simple");	break;
    case EF_FRV_CPU_FR550:  fprintf (file, " -mcpu=fr550");	break;
    case EF_FRV_CPU_FR500:  fprintf (file, " -mcpu=fr500");	break;
    case EF_FRV_CPU_FR450:  fprintf (file, " -mcpu=fr450");	break;
    case EF_FRV_CPU_FR405:  fprintf (file, " -mcpu=fr405");	break;
    case EF_FRV_CPU_FR400:  fprintf (file, " -mcpu=fr400");	break;
    case EF_FRV_CPU_FR300:  fprintf (file, " -mcpu=fr300");	break;
    case EF_FRV_CPU_TOMCAT: fprintf (file, " -mcpu=tomcat");	break;
    }

  switch (flags & EF_FRV_GPR_MASK)
    {
    default:							break;
    case EF_FRV_GPR_32: fprintf (file, " -mgpr-32");		break;
    case EF_FRV_GPR_64: fprintf (file, " -mgpr-64");		break;
    }

  switch (flags & EF_FRV_FPR_MASK)
    {
    default:							break;
    case EF_FRV_FPR_32:   fprintf (file, " -mfpr-32");		break;
    case EF_FRV_FPR_64:   fprintf (file, " -mfpr-64");		break;
    case EF_FRV_FPR_NONE: fprintf (file, " -msoft-float");	break;
    }

  switch (flags & EF_FRV_DWORD_MASK)
    {
    default:							break;
    case EF_FRV_DWORD_YES: fprintf (file, " -mdword");		break;
    case EF_FRV_DWORD_NO:  fprintf (file, " -mno-dword");	break;
    }

  if (flags & EF_FRV_DOUBLE)
    fprintf (file, " -mdouble");

  if (flags & EF_FRV_MEDIA)
    fprintf (file, " -mmedia");

  if (flags & EF_FRV_MULADD)
    fprintf (file, " -mmuladd");

  if (flags & EF_FRV_PIC)
    fprintf (file, " -fpic");

  if (flags & EF_FRV_BIGPIC)
    fprintf (file, " -fPIC");

  if (flags & EF_FRV_LIBPIC)
    fprintf (file, " -mlibrary-pic");

  if (flags & EF_FRV_FDPIC)
    fprintf (file, " -mfdpic");

  if (flags & EF_FRV_NON_PIC_RELOCS)
    fprintf (file, " non-pic relocations");

  if (flags & EF_FRV_G0)
    fprintf (file, " -G0");

  fputc ('\n', file);
  return TRUE;
}


/* Support for core dump NOTE sections.  */

static bfd_boolean
elf32_frv_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  unsigned int raw_size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      /* The Linux/FRV elf_prstatus struct is 268 bytes long.  The other
         hardcoded offsets and sizes listed below (and contained within
	 this lexical block) refer to fields in the target's elf_prstatus
	 struct.  */
      case 268:
	/* `pr_cursig' is at offset 12.  */
	elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

	/* `pr_pid' is at offset 24.  */
	elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 24);

	/* `pr_reg' is at offset 72.  */
	offset = 72;

	/* Most grok_prstatus implementations set `raw_size' to the size
	   of the pr_reg field.  For Linux/FRV, we set `raw_size' to be
	   the size of `pr_reg' plus the size of `pr_exec_fdpic_loadmap'
	   and `pr_interp_fdpic_loadmap', both of which (by design)
	   immediately follow `pr_reg'.  This will allow these fields to
	   be viewed by GDB as registers.

	   `pr_reg' is 184 bytes long.  `pr_exec_fdpic_loadmap' and
	   `pr_interp_fdpic_loadmap' are 4 bytes each.  */
	raw_size = 184 + 4 + 4;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg", raw_size,
					  note->descpos + offset);
}

static bfd_boolean
elf32_frv_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      /* The Linux/FRV elf_prpsinfo struct is 124 bytes long.  */
      case 124:

	/* `pr_fname' is found at offset 28 and is 16 bytes long.  */
	elf_tdata (abfd)->core->program
	  = _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);

	/* `pr_psargs' is found at offset 44 and is 80 bytes long.  */
	elf_tdata (abfd)->core->command
	  = _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}
#define ELF_ARCH		bfd_arch_frv
#define ELF_TARGET_ID		FRV_ELF_DATA
#define ELF_MACHINE_CODE	EM_CYGNUS_FRV
#define ELF_MAXPAGESIZE		0x1000

#define TARGET_BIG_SYM          bfd_elf32_frv_vec
#define TARGET_BIG_NAME		"elf32-frv"

#define elf_info_to_howto			frv_info_to_howto_rela
#define elf_backend_relocate_section		elf32_frv_relocate_section
#define elf_backend_gc_mark_hook		elf32_frv_gc_mark_hook
#define elf_backend_check_relocs                elf32_frv_check_relocs
#define elf_backend_object_p			elf32_frv_object_p
#define elf_backend_add_symbol_hook             elf32_frv_add_symbol_hook

#define elf_backend_stack_align			8
#define elf_backend_can_gc_sections		1
#define elf_backend_rela_normal			1

#define bfd_elf32_bfd_reloc_type_lookup		frv_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup	frv_reloc_name_lookup
#define bfd_elf32_bfd_set_private_flags		frv_elf_set_private_flags
#define bfd_elf32_bfd_copy_private_bfd_data	frv_elf_copy_private_bfd_data
#define bfd_elf32_bfd_merge_private_bfd_data	frv_elf_merge_private_bfd_data
#define bfd_elf32_bfd_print_private_bfd_data	frv_elf_print_private_bfd_data

#define elf_backend_want_got_sym	1
#define elf_backend_got_header_size	0
#define elf_backend_want_got_plt	0
#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_plt_header_size	0

#define elf_backend_finish_dynamic_sections \
		elf32_frv_finish_dynamic_sections

#define elf_backend_grok_prstatus	elf32_frv_grok_prstatus
#define elf_backend_grok_psinfo		elf32_frv_grok_psinfo

#include "elf32-target.h"

#undef ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE		0x4000

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM          bfd_elf32_frvfdpic_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME		"elf32-frvfdpic"
#undef	elf32_bed
#define	elf32_bed		elf32_frvfdpic_bed

#undef elf_info_to_howto_rel
#define elf_info_to_howto_rel	frvfdpic_info_to_howto_rel

#undef bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create \
		frvfdpic_elf_link_hash_table_create
#undef elf_backend_always_size_sections
#define elf_backend_always_size_sections \
		elf32_frvfdpic_always_size_sections
#undef bfd_elf32_bfd_copy_private_bfd_data
#define bfd_elf32_bfd_copy_private_bfd_data \
		elf32_frvfdpic_copy_private_bfd_data

#undef elf_backend_create_dynamic_sections
#define elf_backend_create_dynamic_sections \
		elf32_frvfdpic_create_dynamic_sections
#undef elf_backend_adjust_dynamic_symbol
#define elf_backend_adjust_dynamic_symbol \
		elf32_frvfdpic_adjust_dynamic_symbol
#undef elf_backend_size_dynamic_sections
#define elf_backend_size_dynamic_sections \
		elf32_frvfdpic_size_dynamic_sections
#undef bfd_elf32_bfd_relax_section
#define bfd_elf32_bfd_relax_section \
  elf32_frvfdpic_relax_section
#undef elf_backend_finish_dynamic_symbol
#define elf_backend_finish_dynamic_symbol \
		elf32_frvfdpic_finish_dynamic_symbol
#undef elf_backend_finish_dynamic_sections
#define elf_backend_finish_dynamic_sections \
		elf32_frvfdpic_finish_dynamic_sections

#undef elf_backend_discard_info
#define elf_backend_discard_info \
		frvfdpic_elf_discard_info
#undef elf_backend_can_make_relative_eh_frame
#define elf_backend_can_make_relative_eh_frame \
		frvfdpic_elf_use_relative_eh_frame
#undef elf_backend_can_make_lsda_relative_eh_frame
#define elf_backend_can_make_lsda_relative_eh_frame \
		frvfdpic_elf_use_relative_eh_frame
#undef elf_backend_encode_eh_address
#define elf_backend_encode_eh_address \
		frvfdpic_elf_encode_eh_address

#undef elf_backend_may_use_rel_p
#define elf_backend_may_use_rel_p       1
#undef elf_backend_may_use_rela_p
#define elf_backend_may_use_rela_p      1
/* We use REL for dynamic relocations only.  */
#undef elf_backend_default_use_rela_p
#define elf_backend_default_use_rela_p  1

#undef elf_backend_omit_section_dynsym
#define elf_backend_omit_section_dynsym _frvfdpic_link_omit_section_dynsym

#include "elf32-target.h"
@


1.83
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d6049 4
@


1.82
log
@	* i386linux.c (linux_link_hash_table_create): Allocate table
	with bfd_zmalloc, not bfd_alloc.
	* pdp11.c (link_hash_table_create): Allocate table with
	bfd_malloc, not bfd_alloc.
	* elf32-bfin.c (bfinfdpic_elf_link_hash_table_create): Allocate table
	with bfd_zmalloc, not bfd_zalloc.
	(bfin_link_hash_table_create): Likewise.
	* elf32-frv.c (frvfdpic_elf_link_hash_table_create): Likewise.
	* elf64-hppa.c (elf64_hppa_hash_table_create): Likewise.
@
text
@d6749 1
a6749 1
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d6752 1
a6752 1
	elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 24);
d6788 1
a6788 1
	elf_tdata (abfd)->core_program
d6792 1
a6792 1
	elf_tdata (abfd)->core_command
d6801 1
a6801 1
    char *command = elf_tdata (abfd)->core_command;
@


1.81
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d955 1
a955 1
  ret = bfd_zalloc (abfd, amt);
@


1.80
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@d5510 1
a5510 1
				  
d6747 1
a6747 1
      case 268:	
d6763 1
a6763 1
	   
@


1.79
log
@	bfd/
	* bfd-in.h (bfd_elf_stack_segment_size): Declare.
	* bfd-in2.h: Rebuilt.
	* elfxx-target.h (elf_backend_stack_align): New.
	(elfNN_bed): Add it.
	* elf-bfd.h (struct elf_backend_data): Add stack_align field.
	* elf.c (bfd_elf_map_sections_to_segments): Pay attention to
	stack_align and stacksize for PT_GNU_STACK segment.
	(assign_file_positions_for_non_load_sections): Set p_memsz for
	PT_GNU_STACK segment.
	(copy_elf_program_header): Copy PT_GNU_STACK size.
	* elflink.c (bfd_elf_stack_segment_size): New function, taken from
	uclinux backends.
	(bfd_elf_size_dynamic_sections): Determine
	PT_GNU_STACK requirements after calling backend.  Pay attention to
	stacksize.
	* elf32-bfin.c (elf32_bfinfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_bfinfdpic_modify_program_headers): Delete.
	(elf32_bfingfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-frv.c (frvfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_frvfdpic_modify_program_headers): Delete.
	(elf32_frvfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-lm32.c (lm32_elf_always_size_sections): Leave
	PT_GNU_STACK creation to underlying elf support.  Check
	__stacksize here for backwards compatibility, and set it if
	needed.
	(lm32_elf_modify_segment_map): Delete.
	(lm32_elf_modify_program_headers): Delete.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_segment_map): Don't override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-sh.c (sh_elf_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(sh_elf_modify_program_headers): Delete.
	(sh_elf_copy_private_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-tic6x.c (elf32_tic6x_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_tic6x_modify_program_headers): Delete.
	(elf32_tic6x_copy_private_data): Delete.
	(elf_backend_stack_align): Override.
	(bfd_elf32_bfd_copy_private_bfd_data): Don't override.
	(elf_backend_modify_program_headers): Don't override.

	include/
	* bfdlink.h (struct bfd_link_info): Add stacksize option.

	ld/
	* ld.texinfo (stack-size): New option.
	* emultempl/elf32.em: Add stack-size option.

	ld/testsuite/
	* ld-elf/binutils.exp: Add -z stack-size=0.
	* ld-elf/elf.exp: Add stack-exec and stack-size tests.
	* ld-elf/orphan-region.d: Add stack-size option. Remove xfail.
	* ld-elf/stack-exec.rd: New.
	* ld-elf/stack-size.rd: New.
	* ld-elf/stack.s: New.
	* ld-scripts/empty-aligned.d: Add stack-size option.
	* ld-sh/fdpic-stack-set.d: New.
	* ld-tic6x/shlib-1.rd: Remove __stacksize symbol.
	* ld-tic6x/shlib-1b.rd: Likewise.
	* ld-tic6x/shlib-1r.rd: Likewise.
	* ld-tic6x/shlib-1rb.rd: Likewise.
	* ld-tic6x/shlib-app-1.rd: Likewise.
	* ld-tic6x/shlib-app-1b.rd: Likewise.
	* ld-tic6x/shlib-app-1r.rd: Likewise.
	* ld-tic6x/shlib-app-1rb.rd: Likewise.
	* ld-tic6x/shlib-noindex.rd: Likewise.
	* ld-tic6x/static-app-1.rd: Likewise.
	* ld-tic6x/static-app-1b.rd: Likewise.
	* ld-tic6x/static-app-1r.rd: Likewise.
	* ld-tic6x/static-app-1rb.rd: Likewise.
@
text
@d3366 1
a3366 1
		  | (unsigned long)0x00c80000;;
@


1.78
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d5497 4
a5500 30
  if (!info->relocatable)
    {
      struct elf_link_hash_entry *h;

      /* Force a PT_GNU_STACK segment to be created.  */
      if (! elf_tdata (output_bfd)->stack_flags)
	elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;

      /* Define __stacksize if it's not defined yet.  */
      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				FALSE, FALSE, FALSE);
      if (! h || h->root.type != bfd_link_hash_defined
	  || h->type != STT_OBJECT
	  || !h->def_regular)
	{
	  struct bfd_link_hash_entry *bh = NULL;

	  if (!(_bfd_generic_link_add_one_symbol
		(info, output_bfd, "__stacksize",
		 BSF_GLOBAL, bfd_abs_section_ptr, DEFAULT_STACK_SIZE,
		 (const char *) NULL, FALSE,
		 get_elf_backend_data (output_bfd)->collect, &bh)))
	    return FALSE;

	  h = (struct elf_link_hash_entry *) bh;
	  h->def_regular = 1;
	  h->type = STT_OBJECT;
	  /* This one must NOT be hidden.  */
	}
    }
a5696 45
static bfd_boolean
elf32_frvfdpic_modify_program_headers (bfd *output_bfd,
				       struct bfd_link_info *info)
{
  struct elf_obj_tdata *tdata = elf_tdata (output_bfd);
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;

  /* objcopy and strip preserve what's already there using
     elf32_frvfdpic_copy_private_bfd_data ().  */
  if (! info)
    return TRUE;

  for (p = tdata->phdr, m = tdata->segment_map; m != NULL; m = m->next, p++)
    if (m->p_type == PT_GNU_STACK)
      break;

  if (m)
    {
      struct elf_link_hash_entry *h;

      /* Obtain the pointer to the __stacksize symbol.  */
      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				FALSE, FALSE, FALSE);
      if (h)
	{
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  BFD_ASSERT (h->root.type == bfd_link_hash_defined);
	}

      /* Set the header p_memsz from the symbol value.  We
	 intentionally ignore the symbol section.  */
      if (h && h->root.type == bfd_link_hash_defined)
	p->p_memsz = h->root.u.def.value;
      else
	p->p_memsz = DEFAULT_STACK_SIZE;

      p->p_align = 8;
    }

  return TRUE;
}

a6362 2
  unsigned i;

a6373 25
  /* Copy the stack size.  */
  for (i = 0; i < elf_elfheader (ibfd)->e_phnum; i++)
    if (elf_tdata (ibfd)->phdr[i].p_type == PT_GNU_STACK)
      {
	Elf_Internal_Phdr *iphdr = &elf_tdata (ibfd)->phdr[i];

	for (i = 0; i < elf_elfheader (obfd)->e_phnum; i++)
	  if (elf_tdata (obfd)->phdr[i].p_type == PT_GNU_STACK)
	    {
	      memcpy (&elf_tdata (obfd)->phdr[i], iphdr, sizeof (*iphdr));

	      /* Rewrite the phdrs, since we're only called after they
		 were first written.  */
	      if (bfd_seek (obfd, (bfd_signed_vma) get_elf_backend_data (obfd)
			    ->s->sizeof_ehdr, SEEK_SET) != 0
		  || get_elf_backend_data (obfd)->s
		  ->write_out_phdrs (obfd, elf_tdata (obfd)->phdr,
				     elf_elfheader (obfd)->e_phnum) != 0)
		return FALSE;
	      break;
	    }

	break;
      }

d6825 1
a6869 3
#undef elf_backend_modify_program_headers
#define elf_backend_modify_program_headers \
		elf32_frvfdpic_modify_program_headers
@


1.77
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d31 1
a31 50
static bfd_reloc_status_type elf32_frv_relocate_lo16
  PARAMS ((bfd *,  Elf_Internal_Rela *, bfd_byte *, bfd_vma));
static bfd_reloc_status_type elf32_frv_relocate_hi16
  PARAMS ((bfd *,  Elf_Internal_Rela *, bfd_byte *, bfd_vma));
static bfd_reloc_status_type elf32_frv_relocate_label24
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));
static bfd_reloc_status_type elf32_frv_relocate_gprel12
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
static bfd_reloc_status_type elf32_frv_relocate_gprelu12
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
static bfd_reloc_status_type elf32_frv_relocate_gprello
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
static bfd_reloc_status_type elf32_frv_relocate_gprelhi
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
static reloc_howto_type *frv_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void frv_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean elf32_frv_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf32_frv_add_symbol_hook
  PARAMS (( bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
	    const char **, flagword *, asection **, bfd_vma *));
static bfd_reloc_status_type frv_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
static bfd_boolean elf32_frv_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static int elf32_frv_machine
  PARAMS ((bfd *));
static bfd_boolean elf32_frv_object_p
  PARAMS ((bfd *));
static bfd_boolean frv_elf_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean frv_elf_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean frv_elf_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean frv_elf_print_private_bfd_data
  PARAMS ((bfd *, PTR));
static bfd_boolean elf32_frv_grok_prstatus (bfd * abfd,
					    Elf_Internal_Note * note);
static bfd_boolean elf32_frv_grok_psinfo (bfd * abfd,
					  Elf_Internal_Note * note);
d2130 6
a2135 8
elf32_frv_relocate_gprel12 (info, input_bfd, input_section, relocation,
			    contents, value)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *relocation;
     bfd_byte *contents;
     bfd_vma value;
d2167 6
a2172 8
elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, relocation,
			     contents, value)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *relocation;
     bfd_byte *contents;
     bfd_vma value;
d2207 4
a2210 5
elf32_frv_relocate_hi16 (input_bfd, relhi, contents, value)
     bfd *input_bfd;
     Elf_Internal_Rela *relhi;
     bfd_byte *contents;
     bfd_vma value;
d2229 4
a2232 5
elf32_frv_relocate_lo16 (input_bfd, rello, contents, value)
     bfd *input_bfd;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma value;
d2253 5
a2257 6
elf32_frv_relocate_label24 (input_bfd, input_section, rello, contents, value)
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *rello;
     bfd_byte *contents;
     bfd_vma value;
d2295 6
a2300 8
elf32_frv_relocate_gprelhi (info, input_bfd, input_section, relocation,
			    contents, value)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *relocation;
     bfd_byte *contents;
     bfd_vma value;
d2328 6
a2333 8
elf32_frv_relocate_gprello (info, input_bfd, input_section, relocation,
			    contents, value)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *relocation;
     bfd_byte *contents;
     bfd_vma value;
d2362 2
a2363 3
frv_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d2543 3
a2545 4
frv_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d2606 6
a2611 8
frv_final_link_relocate (howto, input_bfd, input_section, contents, rel,
			 relocation)
     reloc_howto_type *howto;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *rel;
     bfd_vma relocation;
d2650 8
a2657 10
elf32_frv_relocate_section (output_bfd, info, input_bfd, input_section,
			    contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d4096 7
a4102 8
elf32_frv_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
d6086 4
a6089 5
elf32_frv_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d6345 1
a6345 2
elf32_frv_machine (abfd)
     bfd *abfd;
d6366 1
a6366 2
elf32_frv_object_p (abfd)
     bfd *abfd;
d6376 1
a6376 3
frv_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
d6386 1
a6386 3
frv_elf_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d6479 1
a6479 3
frv_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d6747 2
a6748 4
bfd_boolean
frv_elf_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
@


1.76
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d4237 2
a4238 2
  s = bfd_get_section_by_name (abfd, ".got");
  if (s != NULL && (s->flags & SEC_LINKER_CREATED) != 0)
d4251 1
a4251 1
  s = bfd_make_section_with_flags (abfd, ".got", flags);
d4258 1
a4258 1
      s = bfd_make_section_with_flags (abfd, ".got.plt", flags);
d4296 2
a4297 2
      s = bfd_make_section_with_flags (abfd, ".rel.got",
				       (flags | SEC_READONLY));
d4305 2
a4306 2
      s = bfd_make_section_with_flags (abfd, ".rofixup",
				       (flags | SEC_READONLY));
d4354 1
a4354 1
  s = bfd_make_section_with_flags (abfd, ".plt", pltflags);
d4373 2
a4374 2
  s = bfd_make_section_with_flags (abfd, ".rel.plt",
				   flags | SEC_READONLY);
d4421 2
a4422 2
      s = bfd_make_section_with_flags (abfd, ".dynbss",
				       SEC_ALLOC | SEC_LINKER_CREATED);
d4439 4
a4442 4
	  s = bfd_make_section_with_flags (abfd,
					   (bed->default_use_rela_p
					    ? ".rela.bss" : ".rel.bss"),
					   flags | SEC_READONLY);
d5507 1
a5507 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d5916 1
a5916 1
      sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
@


1.75
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2817 1
a2817 1
					 rel, relend, howto, contents);
@


1.74
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d2815 1
a2815 1
      if (sec != NULL && elf_discarded_section (sec))
d5684 1
a5684 1
    if (s->sec_info_type == ELF_INFO_TYPE_EH_FRAME)
@


1.73
log
@	* elf32-frv.c: Use info->callbacks->einfo throughout file in linker
	functions rather than warning callback or _bfd_error_handler.
	* elf32-ppc.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf32-ppc.c (ppc_elf_tls_optimize): Use %H in __tls_get_addr lost
	arg error.
	* elf64-ppc.c (ppc64_elf_tls_optimize): Likewise.
@
text
@d2899 4
a2902 1
	  if (h && ! FRVFDPIC_SYM_LOCAL (info, h))
@


1.73.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2815 1
a2815 1
      if (sec != NULL && discarded_section (sec))
d5681 1
a5681 1
    if (s->sec_info_type == SEC_INFO_TYPE_EH_FRAME)
@


1.72
log
@ChangeLog libiberty/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filename_cmp.c (filename_ncmp): New function.
	* functions.texi: Regenerated.

ChangeLog include/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filenames.h (filename_ncmp): New prototype.

ChangeLog bfd/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* archive.c (_bfd_find_nested_archive): Use filename_(n)cmp.
	(adjust_relative_path): Likewise.
	(_bfd_construct_extended_name_table): Likewise.
	* corefile.c (generic_core_file_matches_executable_p): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-spu.c (sort_bfds): Likewise.
	(spu_elf_auto_overlay): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* xcofflink.c (xcoff_set_import_path): Likewise.
	* xtensa-isa.c (xtensa_regfile_lookup): Likewise.
	(xtensa_regfile_lookup_shortname): Likewise.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d2887 3
a2889 2
	      (*_bfd_error_handler)
		(_("%B(%A+0x%x): relocation to `%s+%x' may have caused the error above"),
d2901 4
a2904 3
	      info->callbacks->warning
		(info, _("relocation references symbol not defined in the module"),
		 name, input_bfd, input_section, rel->r_offset);
d2977 3
a2979 4
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_GETTLSOFF not applied to a call instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3018 4
a3021 4
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_GOTTLSDESC12 not applied to an lddi instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3089 4
a3092 4
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_GOTTLSDESCHI not applied to a sethi instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3126 4
a3129 5
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_GOTTLSDESCLO"
		     " not applied to a setlo or setlos instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3173 4
a3176 4
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_TLSDESC_RELAX not applied to an ldd instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3257 4
a3260 5
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_GETTLSOFF_RELAX"
		     " not applied to a calll instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3311 4
a3314 4
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_GOTTLSOFF12 not applied to an ldi instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3341 4
a3344 4
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_GOTTLSOFFHI not applied to a sethi instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3370 4
a3373 5
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_GOTTLSOFFLO"
		     " not applied to a setlo or setlos instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3400 4
a3403 4
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_TLSOFF_RELAX not applied to an ld instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3445 4
a3448 4
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_TLSMOFFHI not applied to a sethi instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3472 4
a3475 5
		r = info->callbacks->warning
		  (info,
		   _("R_FRV_TLSMOFFLO"
		     " not applied to a setlo or setlos instruction"),
		   name, input_bfd, input_section, rel->r_offset);
d3593 4
a3596 3
			info->callbacks->warning
			  (info, _("R_FRV_FUNCDESC references dynamic symbol with nonzero addend"),
			   name, input_bfd, input_section, rel->r_offset);
d3634 4
a3637 4
			    info->callbacks->warning
			      (info,
			       _("cannot emit fixups in read-only section"),
			       name, input_bfd, input_section, rel->r_offset);
d3665 4
a3668 4
			info->callbacks->warning
			  (info,
			   _("cannot emit dynamic relocations in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
d3714 4
a3717 3
		    info->callbacks->warning
		      (info, _("R_FRV_FUNCDESC_VALUE references dynamic symbol with nonzero addend"),
		       name, input_bfd, input_section, rel->r_offset);
d3756 3
a3758 4
			info->callbacks->warning
			  (info,
			   _("cannot emit fixups in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
d3799 4
a3802 4
			info->callbacks->warning
			  (info,
			   _("cannot emit dynamic relocations in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
d3970 3
a3972 10
	      if (info->shared || info->pie)
		(*_bfd_error_handler)
		  (_("%B(%A+0x%lx): reloc against `%s': %s"),
		   input_bfd, input_section, (long)rel->r_offset, name,
		   _("relocation references a different segment"));
	      else
		info->callbacks->warning
		  (info,
		   _("relocation references a different segment"),
		   name, input_bfd, input_section, rel->r_offset);
d4120 3
a4122 3
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): reloc against `%s': %s"),
		 input_bfd, input_section, (long)rel->r_offset, name, msg);
d5876 2
a5877 2
	      (*_bfd_error_handler)
		("LINKER BUG: .rofixup section size mismatch");
d6396 2
a6397 2
	  (*_bfd_error_handler)
	    (_("%B: unsupported relocation type %i"),
@


1.71
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d3960 1
a3960 1
	       && strcmp (input_bfd->filename, "crt0.o") == 0)
d3962 2
a3963 2
		  && strcmp (input_bfd->filename
			     + strlen (input_bfd->filename) - 7,
@


1.70
log
@	* elf32-frv.c (elf32_frv_relocate_section): Set "name" for global syms.
	(elf32_frvfdpic_finish_dynamic_sections): Don't crash on
	__ROFIXUP_END__ defined in shared lib.
@
text
@d2816 2
a2817 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.69
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d2773 1
a2773 1
      const char * name = NULL;
d2799 2
a2800 1
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
d2812 1
d5901 2
a5902 1
		  || hend->type == bfd_link_hash_defweak))
@


1.68
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d6997 1
@


1.67
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d6938 1
a6938 1
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
@


1.66
log
@update copyright dates
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d885 3
a887 2
#define frvfdpic_hash_table(info) \
  ((struct frvfdpic_elf_link_hash_table *) ((info)->hash))
d1010 2
a1011 1
				      sizeof (struct elf_link_hash_entry)))
@


1.65
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.64
log
@	bfd/
	* elf32-ppc.c (ppc_elf_relax_section): Work with a partial
	link.
	* bout.c (b_out_bfd_relax_section): Reject relocatable links.
	* elf32-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-avr.c (elf32_avr_relax_section): Likewise.
	* elf32-frv.c (elf32_avr_relax_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relax_section): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relax_section): Likewise.
	* reloc.c (bfd_generic_relax_section): Likewise.
	* reloc16.c (bfd_coff_reloc16_relax_section): Likewise.
	* vms.c (vms_bfd_relax_section): Likewise.

	ld/
	* ldmain.c (main): Don't reject --relax -r.
	* ld.texinfo (PowerPC ELF32): Document behaviour of relaxing
	partial links.

	ld/testsuite/
	* ld-powerpc/vxworks-relax-2.s: New.
	* ld-powerpc/vxworks-relax-2.rd: New.
	* ld-powerpc/powerpc.exp: Add it.
@
text
@d27 1
a27 1
#include "elf/dwarf2.h"
@


1.63
log
@Silence gcc printf warnings
@
text
@d5741 4
@


1.62
log
@2008-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/6747
	* elf32-frv.c (elf32_frv_relocate_section): Revert the change
	for PR ld/6446 checked in by accident on May 21, 2008.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007
d6841 1
a6841 1
  fprintf (file, _("private flags = 0x%lx:"), (long)flags);
@


1.61
log
@        Multi-GOT support for m68k.

        bfd/

        * elf32-m68k.c (struct elf_m68k_link_hash_entry: got_entry_key,
        glist): New fields.
        (struct elf_m68k_got_entry_key, struct elf_m68k_got_entry,
        struct elf_m68k_got, struct elf_m68k_bfd2got_entry,
        struct elf_m68k_multi_got): New data structures.
        (struct elf_m68k_link_hash_table: local_gp_p, use_neg_got_offsets_p,
        allow_multigot_p, multi_got_): New fields.
        (elf_m68k_multi_got): New macro.
        (elf_m68k_link_hash_newfunc): Initialize new fields of
        struct elf_m68k_link_hash_entry.
        (elf_m68k_link_hash_table_create): Initialize new fields of
        struct elf_m68k_link_hash_table.
        (elf_m68k_link_hash_table_free): New static function implementing hook.
        (elf_m68k_init_got, elf_m68k_clear_got, elf_m68k_create_empty_got): New
        static functions for struct elf_m68k_got.
        (elf_m68k_init_got_entry_key, elf_m68k_got_entry_hash,
        elf_m68k_got_entry_eq): New static functions for
        struct elf_m68k_got_entry.
        (ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT,
        ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT): New macros.
        (enum elf_m68k_get_entry_howto): New enum.
        (elf_m68k_get_got_entry, elf_m68k_update_got_entry_type,
        elf_m68k_remove_got_entry_type): New static functions for
        struct elf_m68k_got_entry.
        (elf_m68k_add_entry_to_got): New static function.
        (elf_m68k_bfd2got_entry_hash, elf_m68k_bfd2got_entry_eq,
        elf_m68k_bfd2got_entry_del, elf_m68k_get_bfd2got_entry): New static
        functions for struct elf_m68k_bfd2got_entry.
        (struct elf_m68k_can_merge_gots_arg, elf_m68k_can_merge_gots_1,
        elf_m68k_can_merge_gots): New traversal.
        (struct elf_m68k_merge_gots_arg, elf_m68k_merge_gots_1,
        elf_m68k_merge_gots): Ditto.
        (struct elf_m68k_finalize_got_offsets_arg,
        elf_m68k_finalize_got_offsets_1, elf_m68k_finalize_got_offsets): Ditto.
        (struct elf_m68k_partition_multi_got_arg,
        elf_m68k_partition_multi_got_1, elf_m68k_init_symndx2h_1,
        elf_m68k_partition_multi_got): Ditto.
        (elf_m68k_find_got_entry_ptr, elf_m68k_remove_got_entry): New static
        functions.
        (elf_m68k_copy_indirect_symbol): New static function implementing
        a hook.
        (elf_m68k_check_relocs): Update to add entries to multi-GOT.
        (elf_m68k_gc_sweep_hook): Update to remove entries from multi-GOT.
        (elf_m68k_always_size_sections): Assign BFDs to GOTs.
        (elf_m68k_relocate_section): Update to properly handle GOT relocations.
        (elf_m68k_finish_dynamic_symbol): Update to traverse all GOT entries
        of a global symbol.
        (bfd_elf_m68k_set_target_options): New function.
        (bfd_elf32_bfd_link_hash_table_free): Define hook.
        (bfd_elf32_bfd_final_link): Change expansion to bfd_elf_final_link
        to skip generic calculation of GOT offsets.
        (elf_backend_copy_indirect_symbol): Define hook.

        * bfd-in.h (bfd_elf_m68k_set_target_options): Declare function.
        * bfd-in2.h: Regenerate.

        ld/

        * configure.in (--enable-got): New option.  Handle it.
        * configure: Regenerate.
        * config.in: Regenerate.

        * emultempl/m68kelf.em: (got_handling_target_default): New shell
        variable.
        (GOT_HANDLING_TARGET_DEFAULT): New macro.
        (GOT_HANDLING_DEFAULT): New macro.  Initialize it from configure
        option if one was given.
        (got_handling): New static variable.
        (elf_m68k_create_output_section_statements): New static function
        implementing hook.
        (PARSE_AND_LIST_PROLOGUE): Define shell variable.
        (OPTION_GOT): New macro.
        (PARSE_AND_LIST_LONGOPTS): Define shell variable.  Specify
        --got option.
        (got): New linker option.
        (PARSE_AND_LIST_OPTIONS): Define shell variable.  Print help string
        for --got option.
        (PARSE_AND_LIST_ARGS_CASES): Define shell variable.  Handle --got
        option.

        * ld.texinfo: Document --got=<type> option.
        * gen-doc.texi: Add M68K.
        * NEWS: Mention the new feature.

        ld/testsuite/

        * ld-m68k/got-12.s: New file.
        * ld-m68k/got-13.s: New file.
        * ld-m68k/got-14.s: New file.
        * ld-m68k/got-15.s: New file.
        * ld-m68k/got-34.s: New file.
        * ld-m68k/got-35.s: New file.
        * ld-m68k/got-single-12-ok.d: New dump test.
        * ld-m68k/got-single-13-er.d: New dump test.
        * ld-m68k/got-negative-14-ok.d: New dump test.
        * ld-m68k/got-negative-15-er.d: New dump test.
        * ld-m68k/got-negative-12-13-14-34-ok.d: New dump test.
        * ld-m68k/got-negative-12-13-14-35-er.d: New dump test.
        * ld-m68k/got-multigot-14-ok.d: New dump test.
        * ld-m68k/got-multigot-15-er.d: New dump test.
        * ld-m68k/got-multigot-12-13-14-34-35-ok.d: New dump test.
        * ld-m68k/xgot-15.s: New source.
        * ld-m68k/got-xgot-15-ok.d: New test.
        * ld-m68k/got-xgot-12-13-14-15-34-35-ok.d: New test.
        * ld-m68k/m68k.exp: Run new tests.
@
text
@a2730 1
  static bfd_boolean ef_frv_pic_flag_set = FALSE;
a2731 6
  if (! ef_frv_pic_flag_set && IS_FDPIC (output_bfd))
    {
      elf_elfheader (output_bfd)->e_flags |= EF_FRV_PIC;
      ef_frv_pic_flag_set = TRUE;
    }
  
d3988 1
a3988 3
	  /* PR 6446: EF_FRV_PIC should be cleared if
	     there are any inter-segment relocations.  */
	  elf_elfheader (output_bfd)->e_flags &= ~ EF_FRV_PIC;
@


1.60
log
@        bfd/
        * elf32-arm.c (THM2_MAX_FWD_BRANCH_OFFSET): Define.
        (THM2_MAX_BWD_BRANCH_OFFSET): Define.
        (ARM_MAX_FWD_BRANCH_OFFSET): Define.
        (ARM_MAX_BWD_BRANCH_OFFSET): Define.
        (THM_MAX_FWD_BRANCH_OFFSET): Define.
        (THM_MAX_BWD_BRANCH_OFFSET): Define.
        (arm_long_branch_stub): Define.
        (arm_pic_long_branch_stub): Define.
        (arm_thumb_v4t_long_branch_stub): Define.
        (arm_thumb_thumb_long_branch_stub): Define.
        (arm_thumb_arm_v4t_long_branch_stub): Define.
        (STUB_SUFFIX): Define.
        (elf32_arm_stub_type): Define.
        (elf32_arm_stub_hash_entry): Define.
        (elf32_arm_link_hash_entry): Add stub_cache field.
        (arm_stub_hash_lookup): Define.
        (elf32_arm_link_hash_table): Add stub_hash_table, stub_bfd,
        add_stub_section, layout_sections_again, stub_group, bfd_count,
        top_index, input_list fields.
        (elf32_arm_link_hash_newfunc): Init new field.
        (stub_hash_newfunc): New function.
        (elf32_arm_link_hash_table_create): Init stub_hash_table.
        (elf32_arm_hash_table_free): New function.
        (arm_type_of_stub): New function.
        (elf32_arm_stub_name): New function.
        (elf32_arm_get_stub_entry): New function.
        (elf32_arm_stub_add_mapping_symbol): New function.
        (elf32_arm_add_stub): New function.
        (arm_build_one_stub): New function.
        (arm_size_one_stub): New function.
        (elf32_arm_setup_section_lists): New function.
        (elf32_arm_next_input_section): New function.
        (group_sections): New function.
        (elf32_arm_size_stubs): New function.
        (elf32_arm_build_stubs): New function.
        (bfd_elf32_arm_add_glue_sections_to_bfd): Skip stub sections.
        (bfd_elf32_arm_process_before_allocation): No longer handle
        R_ARM_CALL and R_ARM_THM_CALL.
        (using_thumb_only): New function.
        (elf32_arm_final_link_relocate): Redirect calls to stub if range
        exceeds encoding capabilities.
        (bfd_elf32_bfd_link_hash_table_free): Define.
        * bfd-in.h (R_ARM_max): Fix value to 130.
        (elf32_arm_setup_section_lists): Protype.
        (elf32_arm_next_input_section): Protype.
        (elf32_arm_size_stubs): Protype.
        (elf32_arm_build_stubs): Protype.

        ld/
        * emultempl/armelf.em (build_section_lists): New function.
        (stub_file): Define.
        (need_laying_out): Define.
        (group_size): Define.
        (hook_stub_info): Define.
        (hook_in_stub): New function.
        (elf32_arm_add_stub_section): New function.
        (gldarm_layout_sections_again): New function.
        (gld${EMULATION_NAME}_finish): Replace arm_elf_finish(). Generate
        stubs for long calls if needed.
        (arm_elf_create_output_section_statements): create stub_file bfd.
        (arm_for_each_input_file_wrapper): New function.
        (arm_lang_for_each_input_file): New function.
        (lang_for_each_input_file): Define.
        (PARSE_AND_LIST_PROLOGUE): Add option token OPTION_STUBGROUP_SIZE.
        (PARSE_AND_LIST_LONGOPTS): Add option stub-group-size.
        (PARSE_AND_LIST_OPTIONS): Add option stub-group-size.
        (PARSE_AND_LIST_ARGS_CASES): Add OPTION_STUBGROUP_SIZE case.
        (LDEMUL_FINISH): Update to gld${EMULATION_NAME}_finish.
        * ld/lang.c (print_input_statement): Skip if bfd has
        BFD_LINKER_CREATED.

        ld/testsuite
        * ld-arm/arm-elf.exp (armelftests): Add farcall-arm-arm,
        farcall-arm-arm-pic-veneer, farcall-arm-arm-be8 farcall-arm-thumb,
        farcall-arm-thumb-blx, farcall-arm-thumb-pic-veneer,
        farcall-arm-thumb-blx-pic-veneer, farcall-thumb-thumb,
        farcall-thumb-thumb-pic-veneer, farcall-thumb-thumb-blx,
        farcall-thumb-thumb-m, farcall-thumb-thumb-m-pic-veneer,
        farcall-thumb-thumb-blx-pic-veneer, farcall-thumb-arm,
        farcall-thumb-arm-pic-veneer, farcall-thumb-arm-blx,
        farcall-thumb-arm-blx-pic-veneer.
        Change thumb2-bl-as-thumb1-bad, thumb2-bl-bad.
        * ld-arm/thumb2-bl-as-thumb1-bad.d: Reflects farcall stub
        generation.
        * ld-arm/thumb2-bl-bad.d: Likewise.
        * ld-arm/thumb2-bl-as-thumb1-bad.s: Update comments.
        * ld-arm/thumb2-bl-bad.s: Likewise.
@
text
@d2731 1
d2733 6
d3995 3
a3997 1
	  elf_elfheader (output_bfd)->e_flags |= EF_FRV_PIC;
@


1.59
log
@* elf.c (_bfd_elf_find_segment_containing_section): New function:
  Scan the segment map looking for the segment containing a
  specified function.
* elf-bfd.h: Prototype the new function.
* elf-hppa.h (elf_hppa_osec_to_segment): Delete.
  (elf_hppa_record_segment_addrs): Use new function.
* elf32-bfin.c (_bfdfdpic_osec_to_segment): Use new function.
* elf32-frv.c (_frvfdpic_osec_to_segment): Use new function.
* elf32-hppa.c (hppa_record_segment_addr): Use new function.
* elfxx-ia64.c (elfNN_ia64_relocate_section): Use new function.
@
text
@d1400 2
a1401 1
	  if (sec->output_section
d1683 3
a1685 2
	  if (entry->symndx == -1 && entry->d.h->dynindx != -1
	      && entry->d.h->dynindx == idx)
@


1.58
log
@	* elf-m10300.c (mn10300_elf_check_relocs): Delete dead code.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-bfin.c (bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (_frvfdpic_check_discarded_relocs): Likewise.
	(elf32_frv_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	(score_elf_local_relocation_p): Likewise.
	(_bfd_score_elf_relocate_section): Likewise.
	(score_elf_final_link_relocate): Likewise.
@
text
@d1344 1
a1344 18
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;

  /* Find the segment that contains the output_section.  */
  for (m = elf_tdata (output_bfd)->segment_map,
	 p = elf_tdata (output_bfd)->phdr;
       m != NULL;
       m = m->next, p++)
    {
      int i;

      for (i = m->count - 1; i >= 0; i--)
	if (m->sections[i] == osec)
	  break;

      if (i >= 0)
	break;
    }
d1346 1
a1346 1
  return p - elf_tdata (output_bfd)->phdr;
@


1.57
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d5631 1
a5631 1
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
a5639 3
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
d6179 1
a6179 1
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
a6189 3
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
@


1.56
log
@Switch sources over to use the GPL version 3
@
text
@d6403 3
a6405 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.55
log
@bfd:
	* elf-attrs.c: New.
	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
	(elf-attrs.lo): Generate dependencies.
	* Makefile.in: Regenerate.
	* configure.in (elf): Add elf-attrs.lo.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add entries for object
	attributes.
	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
	New.
	(struct elf_obj_tdata): Add entries for object attributes.
	(elf_known_obj_attributes, elf_other_obj_attributes,
	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
	New.
	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
	(bfd_section_from_shdr): Handle attributes sections.
	* elflink.c (bfd_elf_final_link): Handle attributes sections.
	* elfxx-target.h (elf_backend_obj_attrs_vendor,
	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	(elfNN_bed): Update.
	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
	aeabi_attribute_list): Remove.
	(struct elf32_arm_obj_tdata): Remove object attributes fields.
	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
	Update for new object attributes interfaces.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
	elf32_arm_add_eabi_attr_int, attr_strdup,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
	to generic code in elf-attrs.c.
	(elf32_arm_obj_attrs_arg_type): New.
	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
	(bfd_elf32_bfd_final_link): Remove.
	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
	attributes.
	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.

binutils:
	* readelf.c (display_gnu_attribute): New.
	(process_arm_specific): Rearrange as process_attributes.
	(process_arm_specific): Replace by wrapper of process_attributes.

gas:
	* as.c (create_obj_attrs_section): New.
	(main): Call create_obj_attrs_section for ELF.
	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
	skip_past_comma, s_vendor_attribute): New.
	(potable): Add gnu_attribute for ELF.
	* read.h (s_vendor_attribute): Declare.
	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
	round s_vendor_attribute.
	(aeabi_set_public_attributes): Update for new attributes
	interfaces.
	(arm_md_end): Remove attributes contents setting now done
	generically.

include/elf:
	* arm.h (elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
	Tag_Symbol, Tag_compatibility): Remove.
	* common.h (SHT_GNU_ATTRIBUTES): Define.

ld:
	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
	(ATTRS_SECTIONS): Define.
	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.54
log
@* elf32-frv.c (_frvfdpic_check_discarded_relocs): New.
(frvfdpic_elf_discard_info): New.
(elf_backend_discard_info): Define for FDPIC.
@
text
@d6493 4
@


1.53
log
@* elf32-frv.c (elf32_frv_relocate_section): Discard dynamic relocs
for which _bfd_elf_section_offset returns -1.
@
text
@d5621 116
d7088 3
@


1.52
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d3647 2
d3659 13
a3671 10
			_frvfdpic_add_rofixup (output_bfd,
					       frvfdpic_gotfixup_section
					       (info),
					       _bfd_elf_section_offset
					       (output_bfd, info,
						input_section, rel->r_offset)
					       + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       picrel);
d3678 2
d3690 12
a3701 9
		    _frvfdpic_add_dyn_reloc (output_bfd,
					     frvfdpic_gotrel_section (info),
					     _bfd_elf_section_offset
					     (output_bfd, info,
					      input_section, rel->r_offset)
					     + input_section
					     ->output_section->vma
					     + input_section->output_offset,
					     r_type, dynindx, addend, picrel);
d3782 21
a3802 19
			_frvfdpic_add_rofixup (output_bfd,
					       frvfdpic_gotfixup_section
					       (info),
					       _bfd_elf_section_offset
					       (output_bfd, info,
						input_section, rel->r_offset)
					       + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       picrel);
			if (r_type == R_FRV_FUNCDESC_VALUE)
			  _frvfdpic_add_rofixup
			    (output_bfd,
			     frvfdpic_gotfixup_section (info),
			     _bfd_elf_section_offset
			     (output_bfd, info,
			      input_section, rel->r_offset)
			     + input_section->output_section->vma
			     + input_section->output_offset + 4, picrel);
d3812 2
d3824 12
a3835 9
		    _frvfdpic_add_dyn_reloc (output_bfd,
					     frvfdpic_gotrel_section (info),
					     _bfd_elf_section_offset
					     (output_bfd, info,
					      input_section, rel->r_offset)
					     + input_section
					     ->output_section->vma
					     + input_section->output_offset,
					     r_type, dynindx, addend, picrel);
@


1.51
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.50
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d2593 20
d6889 1
@


1.49
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2 2
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
a2725 3
  if (info->relocatable)
    return TRUE;

a2776 1
      /* This is a final link.  */
d2795 9
a2803 1
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];
d2805 10
a2814 3
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d2816 2
a2817 1
	  name = h->root.root.string;
d2819 8
a2826 36
	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak))
	    {
	      if (/* TLSMOFF forces local binding.  */
		  r_type != R_FRV_TLSMOFF
		  && ! FRVFDPIC_SYM_LOCAL (info, h))
		{
		  sec = NULL;
		  relocation = 0;
		}
	      else
		{
		  sec = h->root.u.def.section;
		  relocation = (h->root.u.def.value
				+ sec->output_section->vma
				+ sec->output_offset);
		}
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
	      relocation = 0;
	    }
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset,
		      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		       || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	      relocation = 0;
	    }
	  osec = sec;
@


1.48
log
@	* elf-bfd.h (struct elf_backend_data): Add
	elf_backend_modify_program_headers.
	* elfxx-target.h (elf_backend_modify_program_headers): Define.
	(elfNN_bed): Init new field.
	* elf.c (elf_modify_segment_map): Remove comment.
	(assign_file_positions_for_load_sections): Only call
	elf_modify_segment_map for objcopy/strip.
	(assign_file_positions_except_relocs): Call
	elf_backend_modify_program_headers.
	* elf32-frv.c (elf32_frvfdpic_always_size_sections): Don't make
	.stack section.
	(elf32_frvfdpic_modify_segment_map): Delete.
	(elf32_frvfdpic_modify_program_headers): New.
	(elf_backend_modify_segment_map): Don't define.
	(elf_backend_modify_program_headers): Define.
	* elf32-bfin.c (elf32_bfinfdpic_always_size_sections): Don't make
	.stack section.
	(elf32_bfinfdpic_modify_segment_map): Delete.
	(elf32_bfinfdpic_modify_program_headers): New.
	(elf_backend_modify_segment_map): Don't define.
	(elf_backend_modify_program_headers): Define.
	* elfxx-ia64.c (elfNN_ia64_modify_program_headers): New function.
	Split out from..
	(elfNN_ia64_modify_segment_map): ..here.
	(elf_backend_modify_program_headers): Define.
@
text
@a59 6
static bfd_boolean elf32_frv_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *, const
	   Elf_Internal_Rela *));
static asection * elf32_frv_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
d4142 5
a4146 6
elf32_frv_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d4149 6
a4154 16
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_FRV_GNU_VTINHERIT:
	case R_FRV_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;
d4156 1
a4156 21
	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf32_frv_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
  return TRUE;
a4157 1

a6875 1
#define elf_backend_gc_sweep_hook		elf32_frv_gc_sweep_hook
@


1.47
log
@bfd/
	* elf-bfd.h: Formatting.
	(_bfd_elf_map_sections_to_segments): Declare.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame_hdr): Don't
	clear program_header_size.
	* elf.c (get_program_header_size): Move.  Don't use or set saved
	program_header_size here.
	(elf_modify_segment_map): New function.  Split out from..
	(assign_file_positions_for_load_sections): ..here.  Assert
	header size is correct.  Remove dead code.
	(_bfd_elf_map_sections_to_segments): Rename from
	map_sections_to_segments.  Make global.  Use get_program_header_size
	when we need estimate of header size.  Call elf_modify_segment_map.
	Set program_header_size.
	(print_segment_map): Delete.
	(_bfd_elf_sizeof_headers): If segment_map available, get the
	actual size.
	* elf32-arm.c (elf32_arm_symbian_modify_segment_map): Make safe
	for calling more than once.
	* elf32-bfin.c (elf32_bfinfdpic_modify_segment_map): Likewise.
	* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
	* elf32-i370.c (elf_backend_add_symbol_hook): Delete.
	(elf_backend_additional_program_headers): Delete.
	(elf_backend_modify_segment_map): Delete.
	* elf64-hppa.c (elf64_hppa_modify_segment_map): Convert to ISO C.
	* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
	* doc/bfdint.texi: Delete SIZEOF_HEADERS difficulties.
ld/
	* Makefile.am (ELF_DEPS): Define.  Use in emul file deps.  Fix
	many ELF emul file deps that incorrectly said they needed elf32.em
	instead of generic.em.  Add genelf.em as required.
	* Makefile.in: Regenerate.
	* ldlang.c (lang_process): Call ldemul_finish before
	lang_check_section_addresses.
	* emulparams/arcelf.sh: Generic elf target needs genelf.
	* emulparams/d30v_e.sh: Likewise.
	* emulparams/d30v_o.sh: Likewise.
	* emulparams/d30velf.sh: Likewise.
	* emulparams/elf32_dlx.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32fr30.sh: Likewise.
	* emulparams/elf32frv.sh: Likewise.
	* emulparams/elf32iq10.sh: Likewise.
	* emulparams/elf32iq2000.sh: Likewise.
	* emulparams/elf32mt.sh: Likewise.
	* emulparams/mn10200.sh: Likewise.
	* emulparams/or32.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/msp430all.sh: Likewise.  Extract common entries.
	* emulparams/pjlelf.sh: Include pjelf.sh.
	* emulparams/elf32frvfd.sh (EXTRA_EM_FILE): Unset.
	* emulparams/mn10300.sh (EXTRA_EM_FILE): Unset.
	* emultempl/elf-generic.em: New file.
	* emultempl/genelf.em: New file.
	* emultempl/elf32.em: Include elf-generic.em.
	(gld${EMULATION_NAME}_layout_sections_again): Delete.
	(gld${EMULATION_NAME}_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/hppaelf.em (hppaelf_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from hppaelf_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
	* emultempl/mmo.em: Correct comment.  Include elf-bfd.h and
	source elf-generic.em.
	(mmo_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from ppc_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
ld/testsuite/
	* ld-elf/eh1.d: Update for fewer program headers.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
@
text
@a5605 1
      asection *sec;
a5631 7

      /* Create a stack section, and set its alignment.  */
      sec = bfd_make_section (output_bfd, ".stack");

      if (sec == NULL
	  || ! bfd_set_section_alignment (output_bfd, sec, 3))
	return FALSE;
d5713 2
a5714 2
elf32_frvfdpic_modify_segment_map (bfd *output_bfd,
				   struct bfd_link_info *info)
d5716 1
d5718 1
d5725 1
a5725 1
  for (m = elf_tdata (output_bfd)->segment_map; m != NULL; m = m->next)
a5730 1
      asection *sec = bfd_get_section_by_name (output_bfd, ".stack");
d5733 4
a5736 1
      if (sec)
a5737 3
	  /* Obtain the pointer to the __stacksize symbol.  */
	  h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				    FALSE, FALSE, FALSE);
d5740 1
a5740 1
	    h = (struct elf_link_hash_entry *)h->root.u.i.link;
d5742 1
d5744 6
a5749 6
	  /* Set the section size from the symbol value.  We
	     intentionally ignore the symbol section.  */
	  if (h->root.type == bfd_link_hash_defined)
	    sec->size = h->root.u.def.value;
	  else
	    sec->size = DEFAULT_STACK_SIZE;
d5751 1
a5751 9
	  /* Add the stack section to the PT_GNU_STACK segment,
	     such that its size and alignment requirements make it
	     to the segment.  */
	  if (m->count == 0)
	    {
	      m->sections[m->count] = sec;
	      m->count++;
	    }
	}
d6962 3
a6964 3
#undef elf_backend_modify_segment_map
#define elf_backend_modify_segment_map \
		elf32_frvfdpic_modify_segment_map
@


1.46
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d5760 5
a5764 2
	  m->sections[m->count] = sec;
	  m->count++;
@


1.45
log
@bfd/
	* elf-bfd.h (elf_link_hash_table): Add hplt field.
	* elflink.c (_bfd_elf_create_dynamic_sections): Initialize it.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Likewise.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_create_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_create_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_create_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table): Remove hgot and hplt.
	(elf_i386_link_hash_table_create): Don't initialize them.
	(elf_i386_size_dynamic_sections): Use the generic ELF hplt and
	hgot fields.
	(elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_link_hash_table): Remove hplt.
	(ppc_elf_size_dynamic_sections): Use the generic ELF hplt fields.
	(ppc_elf_finish_dynamic_symbol): Likewise.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005  Free Software Foundation, Inc.
d1011 3
a1013 2
  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd,
				       _bfd_elf_link_hash_newfunc))
@


1.44
log
@	* elf32-frv.c (elf32_frv_grok_prstatus, elf32_frv_grok_psinfo):
	New functions.
	* elf_backend_grok_prstatus, elf_backend_grok_psinfo): Define.
@
text
@d4401 8
a4408 4
  if (bed->want_plt_sym
      && !_bfd_elf_define_linkage_sym (abfd, info, s,
				       "_PROCEDURE_LINKAGE_TABLE_"))
    return FALSE;
@


1.43
log
@	* elf-bfd.h (_bfd_elf_define_linkage_sym): Declare.
	* elflink.c (_bfd_elf_define_linkage_sym): New function, extracted
	from..
	(_bfd_elf_create_got_section): ..here.
	(_bfd_elf_link_create_dynamic_sections): Call it for _DYNAMIC.
	(_bfd_elf_create_dynamic_sections): ..and _PROCEDURE_LINKAGE_TABLE_.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Use
	_bfd_elf_define_linkage_sym.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf64-alpha.c (elf64_alpha_create_dynamic_sections): Likewise.
@
text
@d81 4
d6830 80
d6944 3
@


1.42
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d4304 3
a4306 4
      bh = NULL;
      if (!(_bfd_generic_link_add_one_symbol
	    (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
	     0, (const char *) NULL, FALSE, bed->collect, &bh)))
a4307 4
      h = (struct elf_link_hash_entry *) bh;
      h->def_regular = 1;
      h->type = STT_OBJECT;
      /* h->other = STV_HIDDEN; */ /* Should we?  */
a4312 2

      elf_hash_table (info)->hgot = h;
d4395 6
a4400 20
  if (bed->want_plt_sym)
    {
      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
	 .plt section.  */
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s, 0, NULL,
	      FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->def_regular = 1;
      h->type = STT_OBJECT;
      /* h->other = STV_HIDDEN; */ /* Should we?  */

      if (! info->executable
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }
@


1.41
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Remove got_symbol_offset.
	* elfxx-target.h (elf_backend_got_symbol_offset): Delete.
	* elflink.c (_bfd_elf_create_got_section): Use zero in place of
	got_symbol_offset.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Likewise.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Delete ppc code.
	(elf_backend_got_symbol_offset): Don't define.
	* elf64-ppc.c (elf_backend_got_symbol_offset): Don't define.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Add got_header_size
	and got_gap.
	(ppc_elf_create_got): Tidy.
	(ppc_elf_create_dynamic_sections): Don't set SEC_IN_MEMORY for .plt.
	(ppc_elf_check_relocs): Reduce string comparisons by using elf.hgot.
	(ppc_elf_gc_sweep_hook): Likewise.
	(ppc_elf_relocate_section): Likewise.
	(ppc_elf_finish_dynamic_symbol): Likewise.
	(allocate_got): New function.
	(allocate_dynrelocs): Use allocate_got.
	(ppc_elf_size_dynamic_sections): Likewise.  Delay tlsld_got allocation
	so that local got can refcount it.  Set got_header_size.
	(ppc_elf_relocate_section): Use value of elf.hgot rather than hard-
	coded 4.
	(ppc_elf_finish_dynamic_sections): Likewise.
	(elf_backend_got_symbol_offset): Don't define.
	(elf_backend_got_header_size): Ditto.
ld/testsuite/
	* ld-powerpc/tlsexe32.d: Update for changed got layout.
	* ld-powerpc/tlsexe32.g: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.g: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
@
text
@d6130 6
a6135 1
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.40
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d115 1
a115 1
  HOWTO (R_FRV_LABEL16,	        /* type */
d127 1
a127 1
	 TRUE),		        /* pcrel_offset */
d130 1
a130 1
  HOWTO (R_FRV_LABEL24,	/* type */
d142 1
a142 1
	 TRUE),		        /* pcrel_offset */
d144 1
a144 1
  HOWTO (R_FRV_LO16,	        /* type */
d156 1
a156 1
	 FALSE),	        /* pcrel_offset */
d158 1
a158 1
  HOWTO (R_FRV_HI16,	        /* type */
d170 1
a170 1
	 FALSE),	        /* pcrel_offset */
d172 1
a172 1
  HOWTO (R_FRV_GPREL12,	        /* type */
d180 1
a180 1
	 "R_FRV_GPREL12",       /* name */
d182 3
a184 3
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */
d186 1
a186 1
  HOWTO (R_FRV_GPRELU12,        /* type */
d194 1
a194 1
	 "R_FRV_GPRELU12",      /* name */
d196 3
a198 3
	 0xfff,		        /* src_mask */
	 0x3f03f,	        /* dst_mask */
	 FALSE),	        /* pcrel_offset */
d200 1
a200 1
  HOWTO (R_FRV_GPREL32,         /* type */
d210 1
a210 1
	 0xffffffff,            /* src_mask */
d212 1
a212 1
	 FALSE),	        /* pcrel_offset */
d214 1
a214 1
  HOWTO (R_FRV_GPRELHI,	        /* type */
d224 1
a224 1
	 0xffff,		        /* src_mask */
d226 1
a226 1
	 FALSE),	        /* pcrel_offset */
d228 1
a228 1
  HOWTO (R_FRV_GPRELLO,	        /* type */
d238 1
a238 1
	 0xffff,		        /* src_mask */
d240 1
a240 1
	 FALSE),	        /* pcrel_offset */
d244 1
a244 1
  HOWTO (R_FRV_GOT12,	        /* type */
d254 3
a256 3
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */
d260 1
a260 1
  HOWTO (R_FRV_GOTHI,	        /* type */
d270 1
a270 1
	 0xffff,		        /* src_mask */
d272 1
a272 1
	 FALSE),	        /* pcrel_offset */
d276 1
a276 1
  HOWTO (R_FRV_GOTLO,	        /* type */
d288 1
a288 1
	 FALSE),	        /* pcrel_offset */
d317 3
a319 3
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */
d335 1
a335 1
	 FALSE),	        /* pcrel_offset */
d351 1
a351 1
	 FALSE),	        /* pcrel_offset */
d380 3
a382 3
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */
d398 1
a398 1
	 FALSE),	        /* pcrel_offset */
d414 1
a414 1
	 FALSE),	        /* pcrel_offset */
d418 1
a418 1
  HOWTO (R_FRV_GOTOFF12,        /* type */
d428 3
a430 3
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */
d434 1
a434 1
  HOWTO (R_FRV_GOTOFFHI,        /* type */
d446 1
a446 1
	 FALSE),	        /* pcrel_offset */
d462 1
a462 1
	 FALSE),	        /* pcrel_offset */
d479 1
a479 1
	 TRUE),		        /* pcrel_offset */
d499 1
a499 1
  HOWTO (R_FRV_GOTTLSDESC12,    /* type */
d509 3
a511 3
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */
d515 1
a515 1
  HOWTO (R_FRV_GOTTLSDESCHI,    /* type */
d527 1
a527 1
	 FALSE),	        /* pcrel_offset */
d543 1
a543 1
	 FALSE),	        /* pcrel_offset */
d547 1
a547 1
  HOWTO (R_FRV_TLSMOFF12,        /* type */
d557 3
a559 3
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */
d563 1
a563 1
  HOWTO (R_FRV_TLSMOFFHI,        /* type */
d575 1
a575 1
	 FALSE),	        /* pcrel_offset */
d591 1
a591 1
	 FALSE),	        /* pcrel_offset */
d595 1
a595 1
  HOWTO (R_FRV_GOTTLSOFF12,        /* type */
d605 3
a607 3
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */
d611 1
a611 1
  HOWTO (R_FRV_GOTTLSOFFHI,        /* type */
d623 1
a623 1
	 FALSE),	        /* pcrel_offset */
d639 1
a639 1
	 FALSE),	        /* pcrel_offset */
d710 1
a710 1
  HOWTO (R_FRV_TLSMOFF,	/* type */
d722 1
a722 1
	 FALSE),	        /* pcrel_offset */
d727 13
a739 13
  HOWTO (R_FRV_GNU_VTINHERIT,   /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_FRV_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE);                /* pcrel_offset */
d743 13
a755 13
  HOWTO (R_FRV_GNU_VTENTRY,     /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_FRV_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE);                /* pcrel_offset */
d1875 1
a1875 1
	
d2007 1
a2007 1
      
d2035 1
a2035 1
	  
d2047 1
a2047 1
	  
d2977 1
a2977 1
 
d2994 1
a2994 1
	    
d3131 1
a3131 1
	    
d3179 1
a3179 1
	    
d3509 6
a3514 6
	        R_FRV_TLSDESC_VALUE
	        R_FRV_TLSOFF
	        R_FRV_TLSMOFF12
	        R_FRV_TLSMOFFHI
	        R_FRV_TLSMOFFLO
	        R_FRV_TLSMOFF
d3924 1
a3924 1
	  
d4307 1
a4307 2
	     bed->got_symbol_offset, (const char *) NULL, FALSE,
	     bed->collect, &bh)))
d4323 1
a4323 1
  s->size += bed->got_header_size + bed->got_symbol_offset;
d4579 1
a4579 1
  
d4763 1
a4763 1
      
d5247 1
a5247 1
      
d5835 1
a5835 1
	      bfd_vma value = 
d6278 1
a6278 1
	  
d6298 1
a6298 1
	  
d6304 1
a6304 1
	  
@


1.39
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d4216 5
a4220 5
	  scomm = bfd_make_section (abfd, ".scommon");
	  if (scomm == NULL
	      || !bfd_set_section_flags (abfd, scomm, (SEC_ALLOC
						       | SEC_IS_COMMON
						       | SEC_LINKER_CREATED)))
d4285 1
a4285 1
  s = bfd_make_section (abfd, ".got");
a4286 1
      || !bfd_set_section_flags (abfd, s, flags)
d4292 1
a4292 1
      s = bfd_make_section (abfd, ".got.plt");
a4293 1
	  || !bfd_set_section_flags (abfd, s, flags)
d4338 2
a4339 1
      s = bfd_make_section (abfd, ".rel.got");
a4340 1
	  || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
d4347 2
a4348 1
      s = bfd_make_section (abfd, ".rofixup");
a4349 1
	  || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
d4396 1
a4396 1
  s = bfd_make_section (abfd, ".plt");
a4397 1
      || ! bfd_set_section_flags (abfd, s, pltflags)
d4425 2
a4426 1
  s = bfd_make_section (abfd, ".rel.plt");
a4427 1
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d4473 3
a4475 3
      s = bfd_make_section (abfd, ".dynbss");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC | SEC_LINKER_CREATED))
d4491 4
a4494 3
	  s = bfd_make_section (abfd,
				(bed->default_use_rela_p
				 ? ".rela.bss" : ".rel.bss"));
a4495 1
	      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
@


1.38
log
@Update the FSF address in the copyright/GPL notice
@
text
@d18 1
a18 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.37
log
@bfd/ChangeLog:
* elf32-frv.c (elf32_frv_relocate_section): Remove warning from
uninitialized check_segment[1] in TLSMOFF case.
Reported by Alan Modra.
(elf32_frv_relocate_section): Improve errors and warnings.
ld/testsuite/ChangeLog:
* ld-frv/fdpic-static-6.d: Update.
* ld-frv/fdpic*.d: Remove explicit -mfdpic from #as.  Update
spelling of errors and warnings.
@
text
@d18 1
a18 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.36
log
@	* coff-arm.c (coff_arm_is_local_label_name): Warning fix.
	* elf32-frv.c (frvfdpic_relocs_info_hash): Likewise.
	* pef.c (bfd_pef_scan): Don't ignore return value of
	bfd_pef_scan_start_address.
@
text
@d3908 2
d3967 12
a3978 6
	    info->callbacks->warning
	      (info,
	       (info->shared || info->pie)
	       ? _("relocations between different segments are not supported")
	       : _("warning: relocation references a different segment"),
	       name, input_bfd, input_section, rel->r_offset);
d4124 6
a4129 2
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);
@


1.35
log
@bfd/ChangeLog:
* elf32-frv.c (FRVFDPIC_SYM_LOCAL): Remove special handling for
*ABS*/*UND* sections.
(elf32_frv_relocate_section): Move zero-addend-required error...
(_frv_emit_got_relocs_plt_entries): ... here.  Report error for
missing needed TLS section.
ld/testsuite/ChangeLog:
* ld-frv/fdpic-shared-8-fail.d: Tweak error messages.
@
text
@d1147 2
a1148 2
	  ? (long)entry->d.h->root.root.hash
	  : entry->symndx + entry->d.abfd->id * 257) + entry->addend;
@


1.34
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004  Free Software Foundation, Inc.
d1022 1
a1022 9
   || ! elf_hash_table (INFO)->dynamic_sections_created \
   /* These two additional alternatives are needed for TLS
      relocations, that use *ABS*+offset relocations to refer to the
      TLS section of the local module.  FIXME: At some point during
      linking, the definition section ceases to be regarded as the
      absolute section, and starts being regarded as the undefined
      section.  */ \
   || bfd_is_abs_section ((H)->root.u.def.section) \
   || bfd_is_und_section ((H)->root.u.def.section))
d1520 8
a1527 1
		return FALSE;
d1669 8
a1676 1
	    return FALSE;
d1853 7
d1967 7
d2901 2
a2902 2
		(_("%B: relocation at `%A+0x%x' references symbol `%s' with nonzero addend"),
		 input_bfd, input_section, rel->r_offset, name);
a2903 1

@


1.33
log
@bfd/ChangeLog:
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_relocate_section): Force local binding
for TLSMOFF.
* reloc.c: Add R_FRV_TLSMOFF.
* elf32-frv.c (elf32_frv_howto_table): Likewise.
(frv_reloc_map, frv_reloc_type_lookup): Map it.
(elf32_frv_relocate_section): Handle it.
(elf32_frv_check_relocs): Likewise.
* libbfd.h, bfd-in2.h: Rebuilt.
2004-11-26  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (_frvfdpic_emit_got_relocs_plt_entries): Don't crash
when given an undefweak TLS symbol.  Fix constant TLS PLT entries
such that they return the constant in gr9.
(_frvfdpic_relax_tls_entries): Don't crash for undefweak TLS
symbols.
(_frvfdpic_size_got_plt): Set _cooked_size of dynamic sections.
too, such that they shrink on relaxation.
(elf32_frvfdpic_finish_dynamic_sections): Check __ROFIXUP_END__ as
marking the position right past the _GLOBAL_OFFSET_TABLE_ value.
(_frvfdpic_assign_plt_entries): Shrink constant TLS PLT entries
if we can guarantee the use of 16-bit constants.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
Introduce TLS support for FR-V FDPIC.
* reloc.c: Add TLS relocations.
* elf32-frv.c (elf32_frv_howto_table): Add TLS relocations.
(elf32_frv_rel_tlsdesc_value_howto): New.
(elf32_frv_rel_tlsoff_howto): New.
(frv_reloc_map): Add new mappings.
(struct frvfdpic_elf_link_hash_table): Add pointer to summary
reloc information.
(frvfdpic_dynamic_got_plt_info): New.
(frvfdpic_plt_tls_ret_offset): New.
(ELF_DYNAMIC_INTERPRETER, DEFAULT_STACK_SIZE): Move earlier.
(struct _frvfdpic_dynamic_got_info): Likewise.  Add TLS members.
(struct _frvfdpic_dynamic_got_plt_info): Likewise.
(FRVFDPIC_SYM_LOCAL): Regard symbols defined in the absolute
section as local.
(struct frvfdpic_relocs_info): Add TLS fields.
(frvfdpic_relocs_info_hash): Warning clean up.
(frvfdpic_relocs_info_find): Initialize tlsplt_entry.
(frvfdpic_pic_merge_early_relocs_info): Merge TLS fields.
(FRVFDPIC_TLS_BIAS): Define.
(tls_biased_base): New.
(_frvfdpic_emit_got_relocs_plt_entries): Deal with TLS
relocations.
(frv_reloc_type_lookup): Likewise.
(frvfdpic_info_to_howto_rel): Likewise.
(elf32_frv_relocate_section): Likewise.
(_frv_create_got_section): Create the PLT section here.
(elf32_frvfdpic_create_dynamic_sections): Not here.
(_frvfdpic_count_nontls_entries): Move out of...
(_frvfdpic_count_got_plt_entries): ... here.
(_frvfdpic_count_tls_entries): Likewise.  Add TLS support.
(_frvfdpic_count_relocs_fixups): Likewise.  Add relaxation
support.
(_frvfdpic_relax_tls_entries): New.
(_frvfdpic_compute_got_alloc_data): Add TLS support.
(_frvfdpic_get_tlsdesc_entry): New.
(_frvfdpic_assign_got_entries): Add TLS support.
(_frvfdpic_assign_plt_entries): Likewise.
(_frvfdpic_reset_got_plt_entries): New.
(_frvfdpic_size_got_plt): Move out of...
(elf32_frvfdpic_size_dynamic_sections): ... here.
(_frvfdpic_relax_got_plt_entries): New.
(elf32_frvfdpic_relax_section): New.
(elf32_frvfdpic_finish_dynamic_sections): Add TLS sanity check.
(elf32_frv_check_relocs): Add TLS support.
(bfd_elf32_bfd_relax_section): Define for FDPIC.
* libbfd.h, bfd-in2.h: Rebuilt.
cpu/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.cpu: Add support for TLS annotations in loads and calll.
* frv.opc (parse_symbolic_address): New.
(parse_ldd_annotation): New.
(parse_call_annotation): New.
(parse_ld_annotation): New.
(parse_ulo16, parse_uslo16): Use parse_symbolic_address.
Introduce TLS relocations.
(parse_d12, parse_s12, parse_u12): Likewise.
(parse_uhi16): Likewise.  Fix constant checking on 64-bit host.
(parse_call_label, print_at): New.
gas/ChangeLog:
* config/tc-frv.c (md_apply_fix3): Mark TLS symbols as such.
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-frv.c (frv_pic_ptr): Add tlsmoff support.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* cgen.c (gas_cgen_parse_operand): Handle
CGEN_PARSE_OPERAND_SYMBOLIC.
* config/tc-frv.c (md_cgen_lookup_reloc): Handle TLS relocations.
(frv_force_relocation): Likewise.  Fix handling of PIC
relocations.
(md_apply_fix3): Likewise.
include/elf/ChangeLog:
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.h: Add R_FRV_TLSMOFF.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.h: Add TLS relocations.
include/opcode/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* cgen.h (enum cgen_parse_operand_type): Add
CGEN_PARSE_OPERAND_SYMBOLIC.
ld/testsuite/ChangeLog:
* ld-frv/fdpic.exp: Add -mfdpic to ASFLAGS.
* ld-frv/tls.exp: Likewise.
2004-11-26  Alexandre Oliva  <aoliva@@redhat.com>
* ld-frv/tls-3.s: New.
* ld-frv/tls-static-3.d: New.
* ld-frv/tls-dynamic-3.d: New.
* ld-frv/tls-pie-3.d: New.
* ld-frv/tls-shared-3.d: New.
* ld-frv/tls-relax-static-3.d: New.
* ld-frv/tls-relax-dynamic-3.d: New.
* ld-frv/tls-relax-pie-3.d: New.
* ld-frv/tls-relax-shared-3.d: New.
* ld-frv/tls.exp: Run the new tests.
* ld-frv/tls-dynamic-2.d: Adjust for improved relaxation.
* ld-frv/tls-relax-dynamic-2.d: Likewise.
* ld-frv/tls-relax-initial-shared-2.d: Likewise.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* ld-frv/tls-1-dep.s: New.
* ld-frv/tls-1-shared.lds: New.
* ld-frv/tls-1.s: New.
* ld-frv/tls-2.s: New.
* ld-frv/tls-dynamic-1.d: New.
* ld-frv/tls-dynamic-2.d: New.
* ld-frv/tls-initial-shared-2.d: New.
* ld-frv/tls-pie-1.d: New.
* ld-frv/tls-relax-dynamic-1.d: New.
* ld-frv/tls-relax-dynamic-2.d: New.
* ld-frv/tls-relax-initial-shared-2.d: New.
* ld-frv/tls-relax-pie-1.d: New.
* ld-frv/tls-relax-shared-1.d: New.
* ld-frv/tls-relax-shared-2.d: New.
* ld-frv/tls-relax-static-1.d: New.
* ld-frv/tls-shared-1-fail.d: New.
* ld-frv/tls-shared-1.d: New.
* ld-frv/tls-shared-2.d: New.
* ld-frv/tls-static-1.d: New.
* ld-frv/tls.exp: New.
* ld-frv/fdpic-pie-1.d: Adjust for 64-bit host.
* ld-frv/fdpic-pie-2.d: Likewise.
* ld-frv/fdpic-pie-6.d: Likewise.
* ld-frv/fdpic-pie-7.d: Likewise.
* ld-frv/fdpic-pie-8.d: Likewise.
* ld-frv/fdpic-shared-1.d: Likewise.
* ld-frv/fdpic-shared-2.d: Likewise.
* ld-frv/fdpic-shared-3.d: Likewise.
* ld-frv/fdpic-shared-4.d: Likewise.
* ld-frv/fdpic-shared-5.d: Likewise.
* ld-frv/fdpic-shared-6.d: Likewise.
* ld-frv/fdpic-shared-7.d: Likewise.
* ld-frv/fdpic-shared-8.d: Likewise.
* ld-frv/fdpic-shared-local-2.d: Likewise.
* ld-frv/fdpic-shared-local-8.d: Likewise.
* ld-frv/fdpic-static-1.d: Likewise.
* ld-frv/fdpic-static-2.d: Likewise.
* ld-frv/fdpic-static-6.d: Likewise.
* ld-frv/fdpic-static-7.d: Likewise.
* ld-frv/fdpic-static-8.d: Likewise.
opcodes/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv-asm.c: Rebuilt.
* frv-desc.c: Rebuilt.
* frv-desc.h: Rebuilt.
* frv-dis.c: Rebuilt.
* frv-ibld.c: Rebuilt.
* frv-opc.c: Rebuilt.
* frv-opc.h: Rebuilt.
@
text
@a848 56
/* Map BFD reloc types to FRV ELF reloc types.  */
#if 0
struct frv_reloc_map
{
  unsigned int bfd_reloc_val;
  unsigned int frv_reloc_val;
};

static const struct frv_reloc_map frv_reloc_map [] =
{
  { BFD_RELOC_NONE,           R_FRV_NONE },
  { BFD_RELOC_32,             R_FRV_32 },
  { BFD_RELOC_FRV_LABEL16,    R_FRV_LABEL16 },
  { BFD_RELOC_FRV_LABEL24,    R_FRV_LABEL24 },
  { BFD_RELOC_FRV_LO16,       R_FRV_LO16 },
  { BFD_RELOC_FRV_HI16,       R_FRV_HI16 },
  { BFD_RELOC_FRV_GPREL12,    R_FRV_GPREL12 },
  { BFD_RELOC_FRV_GPRELU12,   R_FRV_GPRELU12 },
  { BFD_RELOC_FRV_GPREL32,    R_FRV_GPREL32 },
  { BFD_RELOC_FRV_GPRELHI,    R_FRV_GPRELHI },
  { BFD_RELOC_FRV_GPRELLO,    R_FRV_GPRELLO },
  { BFD_RELOC_FRV_GOT12,      R_FRV_GOT12 },
  { BFD_RELOC_FRV_GOTHI,      R_FRV_GOTHI },
  { BFD_RELOC_FRV_GOTLO,      R_FRV_GOTLO },
  { BFD_RELOC_FRV_FUNCDESC,   R_FRV_FUNCDESC },
  { BFD_RELOC_FRV_FUNCDESC_GOT12, R_FRV_FUNCDESC_GOT12 },
  { BFD_RELOC_FRV_FUNCDESC_GOTHI, R_FRV_FUNCDESC_GOTHI },
  { BFD_RELOC_FRV_FUNCDESC_GOTLO, R_FRV_FUNCDESC_GOTLO },
  { BFD_RELOC_FRV_FUNCDESC_VALUE, R_FRV_FUNCDESC_VALUE },
  { BFD_RELOC_FRV_FUNCDESC_GOTOFF12, R_FRV_FUNCDESC_GOTOFF12 },
  { BFD_RELOC_FRV_FUNCDESC_GOTOFFHI, R_FRV_FUNCDESC_GOTOFFHI },
  { BFD_RELOC_FRV_FUNCDESC_GOTOFFLO, R_FRV_FUNCDESC_GOTOFFLO },
  { BFD_RELOC_FRV_GOTOFF12,   R_FRV_GOTOFF12 },
  { BFD_RELOC_FRV_GOTOFFHI,   R_FRV_GOTOFFHI },
  { BFD_RELOC_FRV_GOTOFFLO,   R_FRV_GOTOFFLO },
  { BFD_RELOC_FRV_GETTLSOFF,  R_FRV_GETTLSOFF },
  { BFD_RELOC_FRV_TLSDESC_VALUE, R_FRV_TLSDESC_VALUE },
  { BFD_RELOC_FRV_GOTTLSDESC12, R_FRV_GOTTLSDESC12 },
  { BFD_RELOC_FRV_GOTTLSDESCHI, R_FRV_GOTTLSDESCHI },
  { BFD_RELOC_FRV_GOTTLSDESCLO, R_FRV_GOTTLSDESCLO },
  { BFD_RELOC_FRV_TLSMOFF12,  R_FRV_TLSMOFF12 },
  { BFD_RELOC_FRV_TLSMOFFHI,  R_FRV_TLSMOFFHI },
  { BFD_RELOC_FRV_TLSMOFFLO,  R_FRV_TLSMOFFLO },
  { BFD_RELOC_FRV_GOTTLSOFF12, R_FRV_GOTTLSOFF12 },
  { BFD_RELOC_FRV_GOTTLSOFFHI, R_FRV_GOTTLSOFFHI },
  { BFD_RELOC_FRV_GOTTLSOFFLO, R_FRV_GOTTLSOFFLO },
  { BFD_RELOC_FRV_TLSOFF,     R_FRV_TLSOFF },
  { BFD_RELOC_FRV_TLSDESC_RELAX, R_FRV_TLSDESC_RELAX },
  { BFD_RELOC_FRV_GETTLSOFF_RELAX, R_FRV_GETTLSOFF_RELAX },
  { BFD_RELOC_FRV_TLSOFF_RELAX, R_FRV_TLSOFF_RELAX },
  { BFD_RELOC_FRV_TLSMOFF,    R_FRV_TLSMOFF },
  { BFD_RELOC_VTABLE_INHERIT, R_FRV_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY,   R_FRV_GNU_VTENTRY },
};
#endif

a1268 40

#if 0
  /* These are set in _frvfdpic_count_got_plt_entries() or later, and this
     function is only called in _frvfdpic_resolve_final_relocs_info(), that
     runs just before it, so we don't have to worry about the fields
     below.  */

  e2->plt |= e1->plt;
  e2->privfd |= e1->privfd;
  e2->lazyplt |= e1->lazyplt;
  e2->done |= e1->done;

  e2->relocs32 += e1->relocs32;
  e2->relocsfd += e1->relocsfd;
  e2->relocsfdv += e1->relocsfdv;
  e2->relocstlsd += e1->relocstlsd;
  e2->relocstlsoff += e1->relocstlsoff;
  e2->fixups += e1->fixups;
  e2->dynrelocs += e1->dynrelocs;

  if (abs (e1->got_entry) < abs (e2->got_entry))
    e2->got_entry = e1->got_entry;
  if (abs (e1->fdgot_entry) < abs (e2->fdgot_entry))
    e2->fdgot_entry = e1->fdgot_entry;
  if (abs (e1->fd_entry) < abs (e2->fd_entry))
    e2->fd_entry = e1->fd_entry;

  if (e1->plt_entry < e2->plt_entry)
    e2->plt_entry = e1->plt_entry;
  if (e1->lzplt_entry < e2->lzplt_entry)
    e2->lzplt_entry = e1->lzplt_entry;

  if (abs (e1->tlsoff_entry) < abs (e2->tlsoff_entry))
    e2->tlsoff_entry = e1->tlsoff_entry;
  if (abs (e1->tlsdesc_entry) < abs (e2->tlsdesc_entry))
    e2->tlsdesc_entry = e1->tlsdesc_entry;

  if (e1->tlsplt_entry < e2->tlsplt_entry)
    t2->tlsplt_entry = t1->tlsplt_entry;
#endif
d3488 10
a3497 8
#if 0	    /* There's nothing to relax in these.  */
	  case R_FRV_TLSDESC_VALUE:
	  case R_FRV_TLSOFF:
	  case R_FRV_TLSMOFF12:
	  case R_FRV_TLSMOFFHI:
	  case R_FRV_TLSMOFFLO:
	  case R_FRV_TLSMOFF:
#endif
d3927 2
a3928 2
#if 1 /* If you take this out, remove the #error from fdpic-static-6.d
	 in the ld testsuite.  */
a3940 1
#endif
a5133 1
#if 1
a5135 23
#else
  /* If this symbol requires a local function descriptor, allocate
     one.  */
  if (entry->privfd && entry->fd_entry == 0)
    {
      if (dinfo->got12.fdplt)
	{
	  entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->got12);
	  dinfo->got12.fdplt -= 8;
	}
      else if (dinfo->gotlos.fdplt)
	{
	  entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gotlos);
	  dinfo->gotlos.fdplt -= 8;
	}
      else
	{
	  BFD_ASSERT (dinfo->gothilo.fdplt);
	  entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gothilo);
	  dinfo->gothilo.fdplt -= 8;
	}
    }
#endif
@


1.32
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004 Free Software Foundation, Inc.
d353 1
a353 1
  /* The 32-bit address of the canonical descriptor of a function.  */
d464 259
d804 44
d884 16
d927 3
a929 1
     bytes taken by lazy PLT entries.  */
d934 3
d960 2
d963 2
a964 7
/* Create an FRV ELF linker hash table.  */

static struct bfd_link_hash_table *
frvfdpic_elf_link_hash_table_create (bfd *abfd)
{
  struct frvfdpic_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct frvfdpic_elf_link_hash_table);
d966 5
a970 3
  ret = bfd_zalloc (abfd, amt);
  if (ret == NULL)
    return NULL;
d972 2
a973 6
  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd,
				       _bfd_elf_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }
d975 1
a975 2
  return &ret->elf.root;
}
d977 1
a977 8
/* Decide whether a reference to a symbol can be resolved locally or
   not.  If the symbol is protected, we want the local address, but
   its function descriptor must be assigned by the dynamic linker.  */
#define FRVFDPIC_SYM_LOCAL(INFO, H) \
  (_bfd_elf_symbol_refs_local_p ((H), (INFO), 1) \
   || ! elf_hash_table (INFO)->dynamic_sections_created)
#define FRVFDPIC_FUNCDESC_LOCAL(INFO, H) \
  ((H)->dynindx == -1 || ! elf_hash_table (INFO)->dynamic_sections_created)
d979 115
a1093 4
/* This structure collects information on what kind of GOT, PLT or
   function descriptors are required by relocations that reference a
   certain symbol.  */
struct frvfdpic_relocs_info
d1132 18
d1179 4
a1182 3
  /* The number of R_FRV_32, R_FRV_FUNCDESC and R_FRV_FUNCDESC_VALUE
     relocations referencing the symbol.  */
  unsigned relocs32, relocsfd, relocsfdv;
d1198 4
d1211 1
a1211 1
	  ? entry->d.h->root.root.hash
d1255 1
d1315 7
d1340 2
d1356 8
d1477 15
d1511 2
a1512 1
  if (entry->got_entry || entry->fdgot_entry || entry->fd_entry)
d1846 1
d1851 1
a1851 1
	      plt_code += 8;
d1895 366
d2605 54
d2718 8
d2797 1
a2797 1
  unsigned isec_segment, got_segment, plt_segment, gprel_segment,
d2800 1
d2823 1
a2823 1
  if (IS_FDPIC (output_bfd) && elf_hash_table (info)->dynamic_sections_created)
d2829 5
d2884 25
a2908 2
	       || h->root.type == bfd_link_hash_defweak)
	      && ! FRVFDPIC_SYM_LOCAL (info, h))
d2910 6
a2915 1
	      sec = NULL;
d2918 623
a3540 23
	  else
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
	      relocation = 0;
	    }
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset,
		      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		       || ELF_ST_VISIBILITY (h->other)))))
d3542 13
a3554 4
	      relocation = 0;
	    }
	  osec = sec;
	}
d3556 1
a3556 6
      switch (r_type)
	{
	case R_FRV_LABEL24:
	case R_FRV_32:
	  if (! IS_FDPIC (output_bfd))
	    goto non_fdpic;
d3558 2
a3559 27
	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFFLO:
	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	case R_FRV_FUNCDESC:
	case R_FRV_FUNCDESC_VALUE:
	  if (h != NULL)
	    picrel = frvfdpic_relocs_info_for_global (frvfdpic_relocs_info
						      (info), input_bfd, h,
						      orig_addend, INSERT);
	  else
	    /* In order to find the entry we created before, we must
	       use the original addend, not the one that may have been
	       modified by _bfd_elf_rela_local_sym().  */
	    picrel = frvfdpic_relocs_info_for_local (frvfdpic_relocs_info
						     (info), input_bfd, r_symndx,
						     orig_addend, INSERT);
	  if (! picrel)
	    return FALSE;
d3561 10
a3570 8
	  if (!_frvfdpic_emit_got_relocs_plt_entries (picrel, output_bfd, info,
						      osec, sym,
						      rel->r_addend))
	    {
	      (*_bfd_error_handler)
		(_("%B: relocation at `%A+0x%x' references symbol `%s' with nonzero addend"),
		 input_bfd, input_section, rel->r_offset, name);
	      return FALSE;
d3572 9
a3580 1
	    }
d3582 1
a3582 1
	  break;
d3584 11
a3594 12
	default:
	non_fdpic:
	  picrel = NULL;
	  if (h && ! FRVFDPIC_SYM_LOCAL (info, h))
	    {
	      info->callbacks->warning
		(info, _("relocation references symbol not defined in the module"),
		 name, input_bfd, input_section, rel->r_offset);
	      return FALSE;
	    }
	  break;
	}
d3941 70
d4055 1
d4063 2
d4072 3
d4103 7
d4115 1
d4129 1
a4129 1
     else if (r_type == R_FRV_LABEL24)
d4149 4
d4326 1
a4326 1
  flagword flags;
d4347 1
d4379 1
d4397 2
a4398 1
      frvfdpic_relocs_info (info) = htab_try_create (1, frvfdpic_relocs_info_hash,
d4440 1
d4446 2
a4447 2
  return TRUE;
}
d4449 2
a4450 2
/* Make sure the got and plt sections exist, and that our pointers in
   the link hash table point to them.  */
a4451 3
static bfd_boolean
elf32_frvfdpic_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
a4453 9
  flagword flags, pltflags;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
d4455 1
a4455 1
  pltflags = flags;
d4484 1
d4500 23
a4522 1
  /* FRV-specific: we want to create the GOT in the FRV way.  */
d4571 5
a4575 4
/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so.1"
d4577 3
a4579 33
#define DEFAULT_STACK_SIZE 0x20000

/* This structure is used to collect the number of entries present in
   each addressable range of the got.  */
struct _frvfdpic_dynamic_got_info
{
  /* Several bits of information about the current link.  */
  struct bfd_link_info *info;
  /* Total size needed for GOT entries within the 12-, 16- or 32-bit
     ranges.  */
  bfd_vma got12, gotlos, gothilo;
  /* Total size needed for function descriptor entries within the 12-,
     16- or 32-bit ranges.  */
  bfd_vma fd12, fdlos, fdhilo;
  /* Total size needed function descriptor entries referenced in PLT
     entries, that would be profitable to place in offsets close to
     the PIC register.  */
  bfd_vma fdplt;
  /* Total size needed by lazy PLT entries.  */
  bfd_vma lzplt;
  /* Number of relocations carried over from input object files.  */
  unsigned long relocs;
  /* Number of fixups introduced by relocations in input object files.  */
  unsigned long fixups;
};

/* Compute the total GOT size required by each symbol in each range.
   Symbols may require up to 4 words in the GOT: an entry pointing to
   the symbol, an entry pointing to its function descriptor, and a
   private function descriptors taking two words.  */

static int
_frvfdpic_count_got_plt_entries (void **entryp, void *dinfo_)
a4580 4
  struct frvfdpic_relocs_info *entry = *entryp;
  struct _frvfdpic_dynamic_got_info *dinfo = dinfo_;
  unsigned relocs = 0, fixups = 0;

d4634 58
d4694 16
a4709 1
    relocs = entry->relocs32 + entry->relocsfd + entry->relocsfdv;
d4717 2
d4721 4
a4724 1
	relocs += entry->relocs32 + entry->relocsfdv;
d4737 7
d4748 109
d4858 7
a4864 1
  return 1;
d4867 20
a4886 2
/* This structure is used to assign offsets to got entries, function
   descriptors, plt entries and lazy plt entries.  */
d4888 2
a4889 25
struct _frvfdpic_dynamic_got_plt_info
{
  /* Summary information collected with _frvfdpic_count_got_plt_entries.  */
  struct _frvfdpic_dynamic_got_info g;

  /* For each addressable range, we record a MAX (positive) and MIN
     (negative) value.  CUR is used to assign got entries, and it's
     incremented from an initial positive value to MAX, then from MIN
     to FDCUR (unless FDCUR wraps around first).  FDCUR is used to
     assign function descriptors, and it's decreased from an initial
     non-positive value to MIN, then from MAX down to CUR (unless CUR
     wraps around first).  All of MIN, MAX, CUR and FDCUR always point
     to even words.  ODD, if non-zero, indicates an odd word to be
     used for the next got entry, otherwise CUR is used and
     incremented by a pair of words, wrapping around when it reaches
     MAX.  FDCUR is decremented (and wrapped) before the next function
     descriptor is chosen.  FDPLT indicates the number of remaining
     slots that can be used for function descriptors used only by PLT
     entries.  */
  struct _frvfdpic_dynamic_got_alloc_data
  {
    bfd_signed_vma max, cur, odd, fdcur, min;
    bfd_vma fdplt;
  } got12, gotlos, gothilo;
};
d4909 2
d4914 1
d4959 29
a4987 1
      gad->min = wrapmin;
d4989 1
d4992 2
a4993 2
     offsets, place them here.  */
  else if (fdplt && gad->min > wrapmin)
d4996 3
a4998 2
      if ((bfd_vma) (gad->min - wrapmin) < fdplt)
	fds = gad->min - wrapmin;
d5004 1
a5007 9
  /* If GOT entries took too much space, wrap some of them around.
     This may well cause gad->min to become lower than wrapmin.  This
     will cause a relocation overflow later on, so we don't have to
     report it here . */
  if ((bfd_vma) gad->max > wrap)
    {
      gad->min -= gad->max - wrap;
      gad->max = wrap;
    }
d5010 1
a5010 1
  else if (fdplt && (bfd_vma) gad->max < wrap)
d5013 3
a5015 2
      if ((bfd_vma) (wrap - gad->max) < fdplt)
	fds = wrap - gad->max;
d5021 1
d5025 37
d5074 5
d5124 18
d5187 29
d5229 4
d5254 1
d5290 73
d5422 3
a5424 1
/* Set the sizes of the dynamic sections.  */
d5427 2
a5428 2
elf32_frvfdpic_size_dynamic_sections (bfd *output_bfd,
				      struct bfd_link_info *info)
a5429 3
  bfd *dynobj;
  asection *s;
  struct _frvfdpic_dynamic_got_plt_info gpinfo;
d5431 3
a5433 29
  bfd_vma limit;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  memset (&gpinfo, 0, sizeof (gpinfo));
  gpinfo.g.info = info;

  for (;;)
    {
      htab_t relocs = frvfdpic_relocs_info (info);

      htab_traverse (relocs, _frvfdpic_resolve_final_relocs_info, &relocs);

      if (relocs == frvfdpic_relocs_info (info))
	break;
    }
d5435 2
a5436 2
  htab_traverse (frvfdpic_relocs_info (info), _frvfdpic_count_got_plt_entries,
		 &gpinfo.g);
d5443 3
a5445 2
  limit = odd + gpinfo.g.got12 + gpinfo.g.gotlos
    + gpinfo.g.fd12 + gpinfo.g.fdlos;
d5450 9
a5458 2
  if (gpinfo.g.fdplt < limit)
    limit = gpinfo.g.fdplt;
d5462 1
a5462 1
  odd = _frvfdpic_compute_got_alloc_data (&gpinfo.got12,
d5466 2
a5467 2
					  gpinfo.g.got12,
					  gpinfo.g.fd12,
d5469 2
d5472 2
a5473 2
  odd = _frvfdpic_compute_got_alloc_data (&gpinfo.gotlos,
					  gpinfo.got12.min,
d5475 8
a5482 4
					  gpinfo.got12.max,
					  gpinfo.g.gotlos,
					  gpinfo.g.fdlos,
					  gpinfo.g.fdplt - gpinfo.got12.fdplt,
d5484 2
a5485 2
  odd = _frvfdpic_compute_got_alloc_data (&gpinfo.gothilo,
					  gpinfo.gotlos.min,
d5487 10
a5496 5
					  gpinfo.gotlos.max,
					  gpinfo.g.gothilo,
					  gpinfo.g.fdhilo,
					  gpinfo.g.fdplt - gpinfo.got12.fdplt
					  - gpinfo.gotlos.fdplt,
d5501 1
a5501 1
		 &gpinfo);
d5503 2
a5504 2
  frvfdpic_got_section (info)->size = gpinfo.gothilo.max
    - gpinfo.gothilo.min
d5507 1
a5507 1
    - (odd + 4 == gpinfo.gothilo.max ? 4 : 0);
d5516 4
a5519 1
  else
d5528 1
a5528 1
  if (elf_hash_table (info)->dynamic_sections_created)
d5532 1
a5532 1
      (gpinfo.g.relocs - gpinfo.g.lzplt / 8)
d5535 1
a5535 1
    BFD_ASSERT (gpinfo.g.relocs == 0);
d5538 1
a5538 1
  else
d5547 1
a5547 1
  frvfdpic_gotfixup_section (info)->size = (gpinfo.g.fixups + 1) * 4;
d5550 1
a5550 1
  else
d5559 1
a5559 1
  if (elf_hash_table (info)->dynamic_sections_created)
d5562 2
a5563 1
	gpinfo.g.lzplt / 8 * get_elf_backend_data (output_bfd)->s->sizeof_rel;
d5566 1
a5566 1
      else
d5581 1
a5581 1
  if (elf_hash_table (info)->dynamic_sections_created)
d5583 2
a5584 2
      frvfdpic_plt_section (info)->size = gpinfo.g.lzplt
	+ ((gpinfo.g.lzplt + (FRVFDPIC_LZPLT_BLOCK_SIZE - 4) - 8)
d5590 1
a5590 1
  gpinfo.g.lzplt = 0;
d5594 1
a5594 1
  frvfdpic_got_initial_offset (info) = -gpinfo.gothilo.min;
d5598 1
a5598 1
      += frvfdpic_got_initial_offset (info);
d5600 1
a5600 1
  if (elf_hash_table (info)->dynamic_sections_created)
d5604 5
d5610 1
a5610 1
		 &gpinfo);
d5615 1
a5615 1
  if (elf_hash_table (info)->dynamic_sections_created)
d5619 1
a5619 1
      else
d5629 51
d5735 1
d5749 75
d5891 4
d5907 1
d5915 1
d5920 17
d5939 1
a5939 1
  if (elf_hash_table (info)->dynamic_sections_created)
a5945 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d5952 2
d6226 9
d6249 4
d6363 39
d6424 3
d7005 3
@


1.31
log
@	* libbfd-in.h (BFD_ASSERT, BFD_FAIL): Wrap macro body in do while.
	* libbfd.h: Regnerate.
	* elf32-cris.c: Add missing semicolon to BFD_ASSERTs.
	* elf32-frv.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* opncls.c: Likewise.
@
text
@d2547 2
a2548 2
		(info, name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
@


1.30
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d835 1
a835 1
   entry if none existed.  */  
d1024 1
a1024 1
				  
d1102 1
a1102 1
	
d1115 1
a1115 1
      
d1288 1
a1288 1
	  
d1300 1
a1300 1
	  highword = _frvfdpic_osec_to_segment 
d2098 1
a2098 1
	  
d2105 1
a2105 1
	  
d2482 1
a2482 1
	  
d2500 1
a2500 1
	     shifted it right.  */ 
d3150 1
a3150 1
  
d3225 1
a3225 1
  
d3304 1
a3304 1
  
d3334 1
a3334 1
	  BFD_ASSERT (dinfo->gothilo.fdplt)
d3373 1
a3373 1
      
d3375 1
a3375 1
}  
d3543 1
a3543 1
  
d3574 1
a3574 1
  
d3590 1
a3590 1
  
d4148 1
a4148 1
      
d4155 1
a4155 1
		
d4170 1
a4170 1
	    
d4174 1
a4174 1
	    
d4183 1
a4183 1
	    
d4188 1
a4188 1
	    
d4194 1
a4194 1
	    
d4198 1
a4198 1
	    
d4203 1
a4203 1
	    
d4208 1
a4208 1
	  
d4726 1
a4726 1
  
@


1.29
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d3868 1
a3868 1
	      && (h->weakdef != NULL
d3876 1
a3876 1
  if (h->weakdef != NULL)
d3878 4
a3881 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.28
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d2758 1
a2758 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d2817 1
a2817 1
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d2872 1
a2872 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d3680 1
a3680 1
	  || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d3692 1
a3692 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d3869 3
a3871 6
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));
@


1.27
log
@* elf-bfd.h (ELF_COMMON_DEF_P): New.
* elflink.c (_bfd_elf_symbol_refs_local_p): Use it to handle
common definitions.
* elf-m10300.c: Use SYMBOL_REFERENCES_LOCAL instead of
_bfd_elf_symbol_refs_local_p.
* elf32-frv.c (FRVFDPIC_SYM_LOCAL): Remove hack for common
symbols.
@
text
@d2045 2
a2046 3
		(_("%s: relocation at `%s+0x%x' references symbol `%s' with nonzero addend"),
		 bfd_archive_filename (input_bfd), input_section->name,
		 rel->r_offset, name);
d4239 2
a4240 2
	    (_("%s: unsupported relocation type %i"),
	     bfd_archive_filename (abfd), ELF32_R_TYPE (rel->r_info));
@


1.26
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d664 1
a664 11
   || ! elf_hash_table (INFO)->dynamic_sections_created \
   || (/* The condition below is an ugly hack to get .scommon data to
	  be regarded as local.  For some reason the
	  ELF_LINK_HASH_DEF_REGULAR bit is not set on such common
	  symbols, and the SEC_IS_COMMON bit is not set any longer
	  when we need to perform this test.  Hopefully this
	  approximation is good enough.  */ \
       ((H)->root.type == bfd_link_hash_defined \
	|| (H)->root.type == bfd_link_hash_defweak) \
       && (H)->root.u.def.section->output_section \
       && ((H)->root.u.def.section->flags & SEC_LINKER_CREATED)))
@


1.25
log
@bfd/ChangeLog:
* elf-bfd.h (struct elf_backend_data): Added
elf_backend_omit_section_dynsym.
(_bfd_elf_link_omit_section_dynsym): Declare.
* elf32-frv.c (_frvfdpic_link_omit_section_dynsym): New.
(elf_backend_omit_section_dynsym): Use it for frvfdpic.
* elflink.c (_bfd_elf_link_omit_section_dynsym): Split out of...
(_bfd_elf_link_renumber_dynsyms): ... this function.
* elfxx-target.h (elf_backend_omit_section_dynsym): Default to
_bfd_elf_link_omit_section_dynsym).
(elfNN_bed): Added elf_backend_omit_section_dynsym.
ld/ChangeLog:
* emulparams/elf32frvfd.sh (GENERATE_PIE_SCRIPT): Set to yes.
ld/testsuite/ChangeLog:
* ld-frv/fdpic-pie-1.d: Adjust for pie-specific link script.
* ld-frv/fdpic-pie-2.d: Likewise.
* ld-frv/fdpic-pie-6.d: Likewise.
* ld-frv/fdpic-pie-7.d: Likewise.
* ld-frv/fdpic-pie-8.d: Likewise.
* ld-frv/fdpic-shared-1.d: Likewise.
* ld-frv/fdpic-shared-2.d: Likewise.
* ld-frv/fdpic-shared-3.d: Likewise.
* ld-frv/fdpic-shared-4.d: Likewise.
* ld-frv/fdpic-shared-5.d: Likewise.
* ld-frv/fdpic-shared-6.d: Likewise.
* ld-frv/fdpic-shared-7.d: Likewise.
* ld-frv/fdpic-shared-8.d: Likewise.
* ld-frv/fdpic-shared-local-2.d: Likewise.
* ld-frv/fdpic-shared-local-8.d: Likewise.
@
text
@d937 1
a937 1
  BFD_ASSERT (reloc_offset < sreloc->_raw_size);
d972 1
a972 1
      BFD_ASSERT (fixup_offset < rofixup->_raw_size);
d2781 1
a2781 1
  s->_raw_size += bed->got_header_size + bed->got_symbol_offset;
d3357 1
a3357 1
      entry->plt_entry = frvfdpic_plt_section (dinfo->g.info)->_raw_size;
d3371 1
a3371 1
      frvfdpic_plt_section (dinfo->g.info)->_raw_size += size;
d3466 1
a3466 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d3533 1
a3533 1
  frvfdpic_got_section (info)->_raw_size = gpinfo.gothilo.max
d3538 1
a3538 1
  if (frvfdpic_got_section (info)->_raw_size == 0)
d3540 1
a3540 1
  else if (frvfdpic_got_section (info)->_raw_size == 12
d3544 1
a3544 1
      frvfdpic_got_section (info)->_raw_size = 0;
d3550 1
a3550 1
				 frvfdpic_got_section (info)->_raw_size);
d3558 1
a3558 1
    frvfdpic_gotrel_section (info)->_raw_size =
d3563 1
a3563 1
  if (frvfdpic_gotrel_section (info)->_raw_size == 0)
d3569 1
a3569 1
				 frvfdpic_gotrel_section (info)->_raw_size);
d3574 2
a3575 2
  frvfdpic_gotfixup_section (info)->_raw_size = (gpinfo.g.fixups + 1) * 4;
  if (frvfdpic_gotfixup_section (info)->_raw_size == 0)
d3581 1
a3581 1
				 frvfdpic_gotfixup_section (info)->_raw_size);
d3588 1
a3588 1
      frvfdpic_pltrel_section (info)->_raw_size =
d3590 1
a3590 1
      if (frvfdpic_pltrel_section (info)->_raw_size == 0)
d3596 1
a3596 2
				     frvfdpic_pltrel_section (info)
				     ->_raw_size);
d3609 1
a3609 1
      frvfdpic_plt_section (info)->_raw_size = gpinfo.g.lzplt
d3628 1
a3628 1
      frvfdpic_plt_section (info)->_raw_size;
d3638 1
a3638 1
      if (frvfdpic_plt_section (info)->_raw_size == 0)
d3644 1
a3644 1
				     frvfdpic_plt_section (info)->_raw_size);
d3652 1
a3652 1
      if (frvfdpic_got_section (info)->_raw_size)
d3656 1
a3656 1
      if (frvfdpic_pltrel_section (info)->_raw_size)
d3662 1
a3662 1
      if (frvfdpic_gotrel_section (info)->_raw_size)
d3751 1
a3751 1
	    sec->_raw_size = h->root.u.def.value;
d3753 1
a3753 1
	    sec->_raw_size = DEFAULT_STACK_SIZE;
d3787 1
a3787 1
      BFD_ASSERT (frvfdpic_gotrel_section (info)->_raw_size
d3801 1
a3801 1
	  if (frvfdpic_gotfixup_section (info)->_raw_size
d3812 1
a3812 1
      BFD_ASSERT (frvfdpic_pltrel_section (info)->_raw_size
d3827 1
a3827 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d3855 1
a3855 4
	      if (frvfdpic_pltrel_section (info)->_cooked_size != 0)
		dyn.d_un.d_val = frvfdpic_pltrel_section (info)->_cooked_size;
	      else
		dyn.d_un.d_val = frvfdpic_pltrel_section (info)->_raw_size;
@


1.24
log
@* elf32-frv.c (_frvfdpic_add_dyn_reloc): Don't warn when we get
a zero symndx for which we hadn't accounted a dynamic relocation.
(_frvfdpic_add_rofixup): Likewise.
@
text
@d2688 24
d4852 3
@


1.23
log
@* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Return
immediately if there's no link info.
(elf32_frvfdpic_copy_private_bfd_data): New.
(bfd_elf32_bfd_copy_private_bfd_data): Use it for frvfdpic.
@
text
@d942 12
a953 2
  BFD_ASSERT (entry->dynrelocs > 0);
  entry->dynrelocs--;
d977 1
a977 1
  if (entry)
d979 2
@


1.22
log
@* configure.in (bfd_elf32_frvfdpic_vec): New.
* configure: Rebuilt.
* targets.c (bfd_elf32_frvfdpic_vec): New.
* config.bfd: Enable it on frv-*-elf and frv-*-*linux*, as default
on the latter.
* elf32-frv.c: Prefix all identifiers added for FDPIC support with
frvfdpic instead of frv.  Rearrange elf-target macros such that
the FDPIC-specific ones are only defined for this new target
vector.
(bfd_elf32_frvfdpic_vec): Declare.
(IS_FDPIC): New.
(elf32_frv_relocate_section): Use it to enable segment checking
and to control rofixup emission.  Add output section vma to
applied relocation in non-LOAD non-ALLOC sections.  Use
_bfd_error_handler for errors.
(_frv_create_got_section): Create .rel.got and .rofixup only in
FDPIC.  Create non-dynamic _gp at .got+2048 in non-FDPIC, like the
linker script.
(elf32_frvfdpic_size_dynamic_sections): Assume FDPIC.
(elf32_frvfdpic_modify_segment_map): Likewise.
(elf32_frv_finish_dynamic_sections): New, do-nothing.
(elf32_frvfdpic_finish_dynamic_sections): Assume FDPIC.  Improve
error message if we miscompute the rofixup size.
(frvfdpic_elf_use_relative_eh_frame): Assume FDPIC.
(frvfdpic_elf_encode_eh_address): Likewise.
(elf32_frv_check_relocs): Reject FDPIC-only relocs in non-FDPIC.
Record relocs only in FDPIC.  Make sure _gp is defined for GPREL
relocs.  Reject unknown relocation types.
(elf32_frv_object_p): Make sure target vector matches FDPIC bits.
(frv_elf_merge_private_bfd_data): Likewise.
(ELF_MAXPAGESIZE): Revert to 0x1000 for elf32-frv; keep it as
0x4000 for newly-added elf32-frvfdpic.
@
text
@d3689 5
d4319 44
d4778 3
@


1.21
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d586 2
d591 1
a591 1
struct frv_elf_link_hash_table
d617 2
a618 2
#define frv_hash_table(info) \
  ((struct frv_elf_link_hash_table *) ((info)->hash))
d620 16
a635 16
#define frv_got_section(info) \
  (frv_hash_table (info)->sgot)
#define frv_gotrel_section(info) \
  (frv_hash_table (info)->sgotrel)
#define frv_gotfixup_section(info) \
  (frv_hash_table (info)->sgotfixup)
#define frv_plt_section(info) \
  (frv_hash_table (info)->splt)
#define frv_pltrel_section(info) \
  (frv_hash_table (info)->spltrel)
#define frv_relocs_info(info) \
  (frv_hash_table (info)->relocs_info)
#define frv_got_initial_offset(info) \
  (frv_hash_table (info)->got0)
#define frv_plt_initial_offset(info) \
  (frv_hash_table (info)->plt0)
d640 1
a640 1
frv_elf_link_hash_table_create (bfd *abfd)
d642 2
a643 2
  struct frv_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct frv_elf_link_hash_table);
d662 1
a662 1
#define FRV_SYM_LOCAL(INFO, H) \
d675 1
a675 1
#define FRV_FUNCDESC_LOCAL(INFO, H) \
d681 1
a681 1
struct frv_pic_relocs_info
d732 1
a732 1
     (call && symndx == -1 && ! FRV_SYM_LOCAL (info, d.h))  */
d738 1
a738 1
          && (symndx != -1 || FRV_FUNCDESC_LOCAL (info, d.h))))  */
d742 1
a742 1
     (privfd && symndx == -1 && ! FRV_SYM_LOCAL (info, d.h)
d769 1
a769 1
/* Compute a hash with the key fields of an frv_pic_relocs_info entry.  */
d771 1
a771 1
frv_pic_relocs_info_hash (const void *entry_)
d773 1
a773 1
  const struct frv_pic_relocs_info *entry = entry_;
d780 1
a780 1
/* Test whether the key fields of two frv_pic_relocs_info entries are
d783 1
a783 1
frv_pic_relocs_info_eq (const void *entry1, const void *entry2)
d785 2
a786 2
  const struct frv_pic_relocs_info *e1 = entry1;
  const struct frv_pic_relocs_info *e2 = entry2;
d795 5
a799 5
static struct frv_pic_relocs_info *
frv_pic_relocs_info_find (struct htab *ht,
			  bfd *abfd,
			  const struct frv_pic_relocs_info *entry,
			  enum insert_option insert)
d801 2
a802 2
  struct frv_pic_relocs_info **loc =
    (struct frv_pic_relocs_info **) htab_find_slot (ht, entry, insert);
d827 6
a832 6
inline static struct frv_pic_relocs_info *
frv_pic_relocs_info_for_global (struct htab *ht,
				bfd *abfd,
				struct elf_link_hash_entry *h,
				bfd_vma addend,
				enum insert_option insert)
d834 1
a834 1
  struct frv_pic_relocs_info entry;
d840 1
a840 1
  return frv_pic_relocs_info_find (ht, abfd, &entry, insert);
d846 6
a851 6
inline static struct frv_pic_relocs_info *
frv_pic_relocs_info_for_local (struct htab *ht,
			       bfd *abfd,
			       long symndx,
			       bfd_vma addend,
			       enum insert_option insert)
d853 1
a853 1
  struct frv_pic_relocs_info entry;
d859 1
a859 1
  return frv_pic_relocs_info_find (ht, abfd, &entry, insert);
d866 2
a867 2
frv_pic_merge_early_relocs_info (struct frv_pic_relocs_info *e2,
				 struct frv_pic_relocs_info const *e1)
d884 2
a885 2
  /* These are set in _frv_count_got_plt_entries() or later, and this
     function is only called in _frv_resolve_final_relocs_info(), that
d919 2
a920 2
#define FRV_LZPLT_BLOCK_SIZE ((bfd_vma) 8 * 65535 + 4)
#define FRV_LZPLT_RESOLV_LOC (8 * 32767)
d925 3
a927 3
_frv_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
		    int reloc_type, long dynindx, bfd_vma addend,
		    struct frv_pic_relocs_info *entry)
d951 2
a952 2
_frv_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset,
		  struct frv_pic_relocs_info *entry)
d980 1
a980 1
_frv_osec_to_segment (bfd *output_bfd, asection *osec)
d1005 1
a1005 1
_frv_osec_readonly_p (bfd *output_bfd, asection *osec)
d1007 1
a1007 1
  unsigned seg = _frv_osec_to_segment (output_bfd, osec);
d1016 6
a1021 6
_frv_emit_got_relocs_plt_entries (struct frv_pic_relocs_info *entry,
				  bfd *output_bfd,
				  struct bfd_link_info *info,
				  asection *sec,
				  Elf_Internal_Sym *sym,
				  bfd_vma addend)
d1056 2
a1057 1
      if (sec && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
d1074 2
a1075 1
	  && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
d1081 19
a1099 16
	    _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
			      frv_got_section (info)->output_section->vma
			      + frv_got_section (info)->output_offset
			      + frv_got_initial_offset (info)
			      + entry->got_entry, entry);
	}
      else
	_frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
			    _bfd_elf_section_offset
			    (output_bfd, info,
			     frv_got_section (info),
			     frv_got_initial_offset (info)
			     + entry->got_entry)
			    + frv_got_section (info)->output_section->vma
			    + frv_got_section (info)->output_offset,
			    R_FRV_32, idx, ad, entry);
d1102 2
a1103 2
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
d1116 1
a1116 1
	     && FRV_SYM_LOCAL (info, entry->d.h)))
d1125 3
a1127 2
	  if (entry->symndx == -1 && ! FRV_FUNCDESC_LOCAL (info, entry->d.h)
	      && FRV_SYM_LOCAL (info, entry->d.h)
d1137 1
a1137 1
		   && ! FRV_FUNCDESC_LOCAL (info, entry->d.h))
d1152 1
a1152 1
	      idx = elf_section_data (frv_got_section (info)
d1154 2
a1155 2
	      ad = frv_got_section (info)->output_offset
		+ frv_got_initial_offset (info) + entry->fd_entry;
d1166 1
a1166 1
		  || FRV_FUNCDESC_LOCAL (info, entry->d.h)))
d1168 9
a1176 6
	      ad += frv_got_section (info)->output_section->vma;
	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset
				+ frv_got_initial_offset (info)
				+ entry->fdgot_entry, entry);
d1179 12
a1190 9
	    _frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
				_bfd_elf_section_offset
				(output_bfd, info,
				 frv_got_section (info),
				 frv_got_initial_offset (info)
				 + entry->fdgot_entry)
				+ frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset,
				reloc, idx, ad, entry);
d1194 2
a1195 2
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
d1210 2
a1211 1
      if (sec && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
d1228 1
a1228 1
	  && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
d1236 16
a1251 10
	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset
				+ frv_got_initial_offset (info)
				+ entry->fd_entry, entry);
	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset
				+ frv_got_initial_offset (info)
				+ entry->fd_entry + 4, entry);
d1257 14
a1270 11
	    _frv_add_dyn_reloc (output_bfd,
				entry->lazyplt ? frv_pltrel_section (info)
				: frv_gotrel_section (info),
				_bfd_elf_section_offset
				(output_bfd, info,
				 frv_got_section (info),
				 frv_got_initial_offset (info)
				 + entry->fd_entry)
				+ frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset,
				R_FRV_FUNCDESC_VALUE, idx, ad, entry);
d1278 3
a1280 3
	  highword = frv_got_section (info)->output_section->vma
	    + frv_got_section (info)->output_offset
	    + frv_got_initial_offset (info);
d1296 4
a1299 4
	    + frv_plt_section (info)->output_offset
	    + frv_plt_section (info)->output_section->vma;
	  highword = _frv_osec_to_segment 
	    (output_bfd, frv_plt_section (info)->output_section);
d1311 2
a1312 1
	    highword = _frv_osec_to_segment (output_bfd, sec->output_section);
d1316 2
a1317 2
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
d1320 2
a1321 2
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
d1328 2
a1329 1
      bfd_byte *plt_code = frv_plt_section (info)->contents + entry->plt_entry;
d1382 1
a1382 1
      bfd_byte *lzplt_code = frv_plt_section (info)->contents
d1389 4
a1392 4
      resolverStub_addr = entry->lzplt_entry / FRV_LZPLT_BLOCK_SIZE
	* FRV_LZPLT_BLOCK_SIZE + FRV_LZPLT_RESOLV_LOC;
      if (resolverStub_addr >= frv_plt_initial_offset (info))
	resolverStub_addr = frv_plt_initial_offset (info) - 12;
d1796 2
a1797 2
frv_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *cache_ptr, Elf_Internal_Rela *dst)
d1898 6
a1903 6
  isec_segment = _frv_osec_to_segment (output_bfd,
				       input_section->output_section);
  if (frv_got_section (info))
    got_segment = _frv_osec_to_segment (output_bfd,
					frv_got_section (info)
					->output_section);
d1906 4
a1909 4
  if (frv_gotfixup_section (info))
    gprel_segment = _frv_osec_to_segment (output_bfd,
					  frv_gotfixup_section (info)
					  ->output_section);
d1912 4
a1915 4
  if (elf_hash_table (info)->dynamic_sections_created)
    plt_segment = _frv_osec_to_segment (output_bfd,
					frv_plt_section (info)
					->output_section);
d1931 1
a1931 1
      struct frv_pic_relocs_info *picrel;
d1969 1
a1969 1
	      && ! FRV_SYM_LOCAL (info, h))
d2007 3
d2025 3
a2027 3
	    picrel = frv_pic_relocs_info_for_global (frv_relocs_info (info),
						     input_bfd, h,
						     orig_addend, INSERT);
d2032 3
a2034 3
	    picrel = frv_pic_relocs_info_for_local (frv_relocs_info (info),
						    input_bfd, r_symndx,
						    orig_addend, INSERT);
d2038 3
a2040 2
	  if (!_frv_emit_got_relocs_plt_entries (picrel, output_bfd, info,
						 osec, sym, rel->r_addend))
d2042 4
a2045 3
	      info->callbacks->warning
		(info, _("Dynamic relocation references symbol with nonzero addend"),
		 name, input_bfd, input_section, rel->r_offset);
d2053 1
d2055 1
a2055 1
	  if (h && ! FRV_SYM_LOCAL (info, h))
d2069 3
a2071 1
	  if (picrel->plt)
d2073 2
a2074 2
	      relocation = frv_plt_section (info)->output_section->vma
		+ frv_plt_section (info)->output_offset
d2087 1
a2087 1
	      ? _frv_osec_to_segment (output_bfd, sec->output_section)
d2108 3
a2110 3
	  relocation -= frv_got_section (info)->output_section->vma
	    + frv_got_section (info)->output_offset
	    + frv_got_initial_offset (info);
d2113 1
a2113 1
	    ? _frv_osec_to_segment (output_bfd, sec->output_section)
d2130 1
a2130 1
		   && FRV_SYM_LOCAL (info, h)))
d2140 2
a2141 2
		if (h && ! FRV_FUNCDESC_LOCAL (info, h)
		    && FRV_SYM_LOCAL (info, h)
d2149 1
a2149 1
		else if (h && ! FRV_FUNCDESC_LOCAL (info, h))
d2166 1
a2166 1
		    dynindx = elf_section_data (frv_got_section	(info)
d2168 2
a2169 2
		    addend = frv_got_section (info)->output_offset
		      + frv_got_initial_offset (info)
d2180 1
a2180 1
		    && (!h || FRV_FUNCDESC_LOCAL (info, h)))
d2182 1
a2182 1
		    addend += frv_got_section (info)->output_section->vma;
d2187 3
a2189 2
			if (_frv_osec_readonly_p (output_bfd,
						  input_section->output_section))
d2197 10
a2206 8
			_frv_add_rofixup (output_bfd,
					  frv_gotfixup_section (info),
					  _bfd_elf_section_offset
					  (output_bfd, info,
					   input_section, rel->r_offset)
					  + input_section->output_section->vma
					  + input_section->output_offset,
					  picrel);
d2213 3
a2215 2
		    if (_frv_osec_readonly_p (output_bfd,
					      input_section->output_section))
d2223 9
a2231 7
		    _frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
					_bfd_elf_section_offset
					(output_bfd, info,
					 input_section, rel->r_offset)
					+ input_section->output_section->vma
					+ input_section->output_offset,
					r_type, dynindx, addend, picrel);
d2233 2
d2246 6
d2259 1
a2259 1
	    if (h && ! FRV_SYM_LOCAL (info, h))
d2291 1
a2291 1
		&& (!h || FRV_SYM_LOCAL (info, h)))
d2295 1
a2295 1
		if ((elf_elfheader (input_bfd)->e_flags & EF_FRV_FDPIC)
d2300 3
a2302 2
		    if (_frv_osec_readonly_p (output_bfd,
					      input_section->output_section))
d2312 10
a2321 8
			_frv_add_rofixup (output_bfd,
					  frv_gotfixup_section (info),
					  _bfd_elf_section_offset
					  (output_bfd, info,
					   input_section, rel->r_offset)
					  + input_section->output_section->vma
					  + input_section->output_offset,
					  picrel);
d2323 1
a2323 1
			  _frv_add_rofixup
d2325 1
a2325 1
			     frv_gotfixup_section (info),
d2340 3
a2342 2
		    if (_frv_osec_readonly_p (output_bfd,
					      input_section->output_section))
d2350 9
a2358 7
		    _frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
					_bfd_elf_section_offset
					(output_bfd, info,
					 input_section, rel->r_offset)
					+ input_section->output_section->vma
					+ input_section->output_offset,
					r_type, dynindx, addend, picrel);
d2360 2
d2374 1
a2374 1
		    && (!h || FRV_SYM_LOCAL (info, h)))
d2376 3
a2378 3
			      frv_got_section (info)->output_section->vma
			      + frv_got_section (info)->output_offset
			      + frv_got_initial_offset (info),
d2388 1
a2388 1
			      h && ! FRV_SYM_LOCAL (info, h)
d2390 3
a2392 2
			      : _frv_osec_to_segment (output_bfd,
						      sec->output_section),
d2406 1
a2406 1
	    ? _frv_osec_to_segment (output_bfd, sec->output_section)
d2413 1
a2413 1
	    ? _frv_osec_to_segment (output_bfd, sec->output_section)
d2418 1
a2418 2
      if (check_segment[0] != check_segment[1]
	  && (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC))
d2420 2
a2421 1
#if 1
d2478 1
a2478 1
	  if (! picrel->plt)
d2675 2
a2676 1
/* Create a .got section, as well as its additional info field.  This
d2689 1
d2749 8
a2756 6
  frv_got_section (info) = s;
  frv_relocs_info (info) = htab_try_create (1, frv_pic_relocs_info_hash,
					    frv_pic_relocs_info_eq,
					    (htab_del) NULL);
  if (! frv_relocs_info (info))
    return FALSE;
d2758 5
a2762 5
  s = bfd_make_section (abfd, ".rel.got");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, s, 2))
    return FALSE;
d2764 1
a2764 1
  frv_gotrel_section (info) = s;
d2766 6
a2771 6
  /* Machine-specific.  */
  s = bfd_make_section (abfd, ".rofixup");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, s, 2))
    return FALSE;
d2773 9
a2781 1
  frv_gotfixup_section (info) = s;
d2783 3
a2785 3
  /* Define _gp in .rofixup, for FDPIC.  If it turns out that
     we're linking with a different linker script, the linker script
     will override it.  */
d2788 1
a2788 1
	(info, abfd, "_gp", BSF_GLOBAL, s, -2048, (const char *) NULL, FALSE,
d2796 1
a2796 1
  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2798 1
a2798 1
  
d2806 1
a2806 1
elf32_frv_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d2833 1
a2833 1
  frv_plt_section (info) = s;
d2862 1
a2862 1
  frv_pltrel_section (info) = s;
d2869 4
a2872 3
  BFD_ASSERT (frv_got_section (info) && frv_gotrel_section (info)
	      && frv_gotfixup_section (info)
	      && frv_plt_section (info) && frv_pltrel_section (info));
d2922 1
a2922 1
struct _frv_dynamic_got_info
d2950 1
a2950 1
_frv_count_got_plt_entries (void **entryp, void *dinfo_)
d2952 2
a2953 2
  struct frv_pic_relocs_info *entry = *entryp;
  struct _frv_dynamic_got_info *dinfo = dinfo_;
d2982 1
a2982 1
    && entry->symndx == -1 && ! FRV_SYM_LOCAL (dinfo->info, entry->d.h)
d2988 1
a2988 1
	    || FRV_FUNCDESC_LOCAL (dinfo->info, entry->d.h)));
d2990 1
a2990 1
    && entry->symndx == -1 && ! FRV_SYM_LOCAL (dinfo->info, entry->d.h)
d3014 1
a3014 1
      if (entry->symndx != -1 || FRV_SYM_LOCAL (dinfo->info, entry->d.h))
d3023 2
a3024 1
      if (entry->symndx != -1 || FRV_FUNCDESC_LOCAL (dinfo->info, entry->d.h))
d3045 1
a3045 1
struct _frv_dynamic_got_plt_info
d3047 2
a3048 2
  /* Summary information collected with _frv_count_got_plt_entries.  */
  struct _frv_dynamic_got_info g;
d3064 1
a3064 1
  struct _frv_dynamic_got_alloc_data
d3082 8
a3089 8
_frv_compute_got_alloc_data (struct _frv_dynamic_got_alloc_data *gad,
			     bfd_signed_vma fdcur,
			     bfd_signed_vma odd,
			     bfd_signed_vma cur,
			     bfd_vma got,
			     bfd_vma fd,
			     bfd_vma fdplt,
			     bfd_vma wrap)
d3183 1
a3183 1
  /* _frv_get_got_entry() below will always wrap gad->cur if needed
d3197 1
a3197 1
_frv_get_got_entry (struct _frv_dynamic_got_alloc_data *gad)
d3226 1
a3226 1
_frv_get_fd_entry (struct _frv_dynamic_got_alloc_data *gad)
d3239 1
a3239 1
_frv_assign_got_entries (void **entryp, void *info_)
d3241 2
a3242 2
  struct frv_pic_relocs_info *entry = *entryp;
  struct _frv_dynamic_got_plt_info *dinfo = info_;
d3245 1
a3245 1
    entry->got_entry = _frv_get_got_entry (&dinfo->got12);
d3247 1
a3247 1
    entry->got_entry = _frv_get_got_entry (&dinfo->gotlos);
d3249 1
a3249 1
    entry->got_entry = _frv_get_got_entry (&dinfo->gothilo);
d3252 1
a3252 1
    entry->fdgot_entry = _frv_get_got_entry (&dinfo->got12);
d3254 1
a3254 1
    entry->fdgot_entry = _frv_get_got_entry (&dinfo->gotlos);
d3256 1
a3256 1
    entry->fdgot_entry = _frv_get_got_entry (&dinfo->gothilo);
d3259 1
a3259 1
    entry->fd_entry = _frv_get_fd_entry (&dinfo->got12);
d3263 1
a3263 1
      entry->fd_entry = _frv_get_fd_entry (&dinfo->got12);
d3266 1
a3266 1
    entry->fd_entry = _frv_get_fd_entry (&dinfo->gotlos);
d3270 1
a3270 1
      entry->fd_entry = _frv_get_fd_entry (&dinfo->gotlos);
d3275 1
a3275 1
      entry->fd_entry = _frv_get_fd_entry (&dinfo->gothilo);
d3278 1
a3278 1
    entry->fd_entry = _frv_get_fd_entry (&dinfo->gothilo);
d3288 1
a3288 1
_frv_assign_plt_entries (void **entryp, void *info_)
d3290 2
a3291 2
  struct frv_pic_relocs_info *entry = *entryp;
  struct _frv_dynamic_got_plt_info *dinfo = info_;
d3299 1
a3299 1
	  entry->fd_entry = _frv_get_fd_entry (&dinfo->got12);
d3304 1
a3304 1
	  entry->fd_entry = _frv_get_fd_entry (&dinfo->gotlos);
d3310 1
a3310 1
	  entry->fd_entry = _frv_get_fd_entry (&dinfo->gothilo);
d3321 1
a3321 1
      entry->plt_entry = frv_plt_section (dinfo->g.info)->_raw_size;
d3335 1
a3335 1
      frv_plt_section (dinfo->g.info)->_raw_size += size;
d3344 2
a3345 1
      if (entry->lzplt_entry % FRV_LZPLT_BLOCK_SIZE == FRV_LZPLT_RESOLV_LOC)
d3359 1
a3359 1
_frv_resolve_final_relocs_info (void **entryp, void *p)
d3361 1
a3361 1
  struct frv_pic_relocs_info *entry = *entryp;
d3367 1
a3367 1
      struct frv_pic_relocs_info *oentry;
d3376 2
a3377 2
      oentry = frv_pic_relocs_info_for_global (*htab, 0, h, entry->addend,
					       NO_INSERT);
d3382 1
a3382 1
	  frv_pic_merge_early_relocs_info (oentry, entry);
d3411 2
a3412 2
elf32_frv_size_dynamic_sections (bfd *output_bfd,
				 struct bfd_link_info *info)
d3416 1
a3416 1
  struct _frv_dynamic_got_plt_info gpinfo;
d3440 1
a3440 1
      htab_t relocs = frv_relocs_info (info);
d3442 1
a3442 1
      htab_traverse (relocs, _frv_resolve_final_relocs_info, &relocs);
d3444 1
a3444 1
      if (relocs == frv_relocs_info (info))
d3448 1
a3448 1
  htab_traverse (frv_relocs_info (info), _frv_count_got_plt_entries,
d3467 25
a3491 25
  odd = _frv_compute_got_alloc_data (&gpinfo.got12,
				     0,
				     odd,
				     16,
				     gpinfo.g.got12,
				     gpinfo.g.fd12,
				     limit,
				     (bfd_vma)1 << (12-1));
  odd = _frv_compute_got_alloc_data (&gpinfo.gotlos,
				     gpinfo.got12.min,
				     odd,
				     gpinfo.got12.max,
				     gpinfo.g.gotlos,
				     gpinfo.g.fdlos,
				     gpinfo.g.fdplt - gpinfo.got12.fdplt,
				     (bfd_vma)1 << (16-1));
  odd = _frv_compute_got_alloc_data (&gpinfo.gothilo,
				     gpinfo.gotlos.min,
				     odd,
				     gpinfo.gotlos.max,
				     gpinfo.g.gothilo,
				     gpinfo.g.fdhilo,
				     gpinfo.g.fdplt - gpinfo.got12.fdplt
				     - gpinfo.gotlos.fdplt,
				     (bfd_vma)1 << (32-1));
d3494 2
a3495 1
  htab_traverse (frv_relocs_info (info), _frv_assign_got_entries, &gpinfo);
d3497 2
a3498 1
  frv_got_section (info)->_raw_size = gpinfo.gothilo.max - gpinfo.gothilo.min
d3502 3
a3504 3
  if (frv_got_section (info)->_raw_size == 0)
    frv_got_section (info)->flags |= SEC_EXCLUDE;
  else if (frv_got_section (info)->_raw_size == 12
d3507 2
a3508 2
      frv_got_section (info)->flags |= SEC_EXCLUDE;
      frv_got_section (info)->_raw_size = 0;
d3512 4
a3515 3
      frv_got_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj, frv_got_section (info)->_raw_size);
      if (frv_got_section (info)->contents == NULL)
d3522 1
a3522 1
    frv_gotrel_section (info)->_raw_size =
d3527 2
a3528 2
  if (frv_gotrel_section (info)->_raw_size == 0)
    frv_gotrel_section (info)->flags |= SEC_EXCLUDE;
d3531 4
a3534 3
      frv_gotrel_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj, frv_gotrel_section (info)->_raw_size);
      if (frv_gotrel_section (info)->contents == NULL)
d3538 3
a3540 4
  if (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
    frv_gotfixup_section (info)->_raw_size = (gpinfo.g.fixups + 1) * 4;
  if (frv_gotfixup_section (info)->_raw_size == 0)
    frv_gotfixup_section (info)->flags |= SEC_EXCLUDE;
d3543 1
a3543 1
      frv_gotfixup_section (info)->contents =
d3545 2
a3546 2
				 frv_gotfixup_section (info)->_raw_size);
      if (frv_gotfixup_section (info)->contents == NULL)
d3552 1
a3552 1
      frv_pltrel_section (info)->_raw_size =
d3554 2
a3555 2
      if (frv_pltrel_section (info)->_raw_size == 0)
	frv_pltrel_section (info)->flags |= SEC_EXCLUDE;
d3558 1
a3558 1
	  frv_pltrel_section (info)->contents =
d3560 3
a3562 2
				     frv_pltrel_section (info)->_raw_size);
	  if (frv_pltrel_section (info)->contents == NULL)
d3569 3
a3571 3
     call the resolver.  Since _frv_assign_got_entries didn't account
     for them, our block size is 4 bytes smaller than the real block
     size.  */
d3574 3
a3576 3
      frv_plt_section (info)->_raw_size = gpinfo.g.lzplt
	+ ((gpinfo.g.lzplt + (FRV_LZPLT_BLOCK_SIZE - 4) - 8)
	   / (FRV_LZPLT_BLOCK_SIZE - 4) * 4);
d3579 1
a3579 1
  /* Reset it, such that _frv_assign_plt_entries() can use it to
d3585 1
a3585 1
  frv_got_initial_offset (info) = -gpinfo.gothilo.min;
d3589 1
a3589 1
      += frv_got_initial_offset (info);
d3592 2
a3593 1
    frv_plt_initial_offset (info) = frv_plt_section (info)->_raw_size;
d3595 2
a3596 1
  htab_traverse (frv_relocs_info (info), _frv_assign_plt_entries, &gpinfo);
d3599 1
a3599 1
     _frv_assign_plt_entries has a chance to add the size of the
d3603 2
a3604 2
      if (frv_plt_section (info)->_raw_size == 0)
	frv_plt_section (info)->flags |= SEC_EXCLUDE;
d3607 4
a3610 3
	  frv_plt_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj, frv_plt_section (info)->_raw_size);
	  if (frv_plt_section (info)->contents == NULL)
d3617 1
a3617 1
      if (frv_got_section (info)->_raw_size)
d3621 1
a3621 1
      if (frv_pltrel_section (info)->_raw_size)
d3627 1
a3627 1
      if (frv_gotrel_section (info)->_raw_size)
d3639 2
a3640 2
elf32_frv_always_size_sections (bfd *output_bfd,
				struct bfd_link_info *info)
d3642 1
a3642 2
  if (!info->relocatable
      && elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
d3684 2
a3685 2
elf32_frv_modify_segment_map (bfd *output_bfd,
			      struct bfd_link_info *info)
d3687 7
a3693 1
  if (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
d3695 2
a3696 1
      struct elf_segment_map *m;
d3698 1
a3698 5
      for (m = elf_tdata (output_bfd)->segment_map; m != NULL; m = m->next)
	if (m->p_type == PT_GNU_STACK)
	  break;

      if (m)
d3700 7
a3706 2
	  asection *sec = bfd_get_section_by_name (output_bfd, ".stack");
	  struct elf_link_hash_entry *h;
d3708 6
a3713 16
	  if (sec)
	    {
	      /* Obtain the pointer to the __stacksize symbol.  */
	      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
					FALSE, FALSE, FALSE);
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *)h->root.u.i.link;
	      BFD_ASSERT (h->root.type == bfd_link_hash_defined);

	      /* Set the section size from the symbol value.  We
		 intentionally ignore the symbol section.  */
	      if (h->root.type == bfd_link_hash_defined)
		sec->_raw_size = h->root.u.def.value;
	      else
		sec->_raw_size = DEFAULT_STACK_SIZE;
d3715 5
a3719 6
	      /* Add the stack section to the PT_GNU_STACK segment,
		 such that its size and alignment requirements make it
		 to the segment.  */
	      m->sections[m->count] = sec;
	      m->count++;
	    }
d3729 10
a3738 2
elf32_frv_finish_dynamic_sections (bfd *output_bfd,
				   struct bfd_link_info *info)
d3745 1
a3745 1
  if (frv_got_section (info))
d3747 2
a3748 2
      BFD_ASSERT (frv_gotrel_section (info)->_raw_size
		  == (frv_gotrel_section (info)->reloc_count
d3751 1
a3751 1
      if (frv_gotfixup_section (info))
d3753 10
a3762 1
	  if (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
d3764 3
a3766 29
	      struct elf_link_hash_entry *hgot = elf_hash_table (info)->hgot;
	      bfd_vma got_value = hgot->root.u.def.value
		+ hgot->root.u.def.section->output_section->vma
		+ hgot->root.u.def.section->output_offset;

	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				got_value, 0);
	    }

	  if (frv_gotfixup_section (info)->_raw_size
	      != (frv_gotfixup_section (info)->reloc_count * 4))
	    {
	      if (frv_gotfixup_section (info)->_raw_size
		  < frv_gotfixup_section (info)->reloc_count * 4)
		{
		  info->callbacks->warning
		    (info, "LINKER BUG: .rofixup section size mismatch",
		     ".rofixup", NULL, NULL, 0);
		  abort ();
		  return FALSE;
		}
	      else if (!elf_hash_table (info)->dynamic_sections_created)
		{
		  info->callbacks->warning
		    (info, "no dynamic sections, missing -melf32frvfd?",
		     ".rofixup", NULL, NULL, 0);
		  return FALSE;
		}
	      BFD_ASSERT (0);
d3772 2
a3773 2
      BFD_ASSERT (frv_pltrel_section (info)->_raw_size
		  == (frv_pltrel_section (info)->reloc_count
d3801 3
a3803 3
	      dyn.d_un.d_ptr = frv_got_section (info)->output_section->vma
		+ frv_got_section (info)->output_offset
		+ frv_got_initial_offset (info);
d3808 3
a3810 2
	      dyn.d_un.d_ptr = frv_pltrel_section (info)->output_section->vma
		+ frv_pltrel_section (info)->output_offset;
d3815 2
a3816 2
	      if (frv_pltrel_section (info)->_cooked_size != 0)
		dyn.d_un.d_val = frv_pltrel_section (info)->_cooked_size;
d3818 1
a3818 1
		dyn.d_un.d_val = frv_pltrel_section (info)->_raw_size;
d3832 3
a3834 2
elf32_frv_adjust_dynamic_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
				 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
d3867 5
a3871 4
elf32_frv_finish_dynamic_symbol (bfd *output_bfd ATTRIBUTE_UNUSED,
				 struct bfd_link_info *info ATTRIBUTE_UNUSED,
				 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED,
				 Elf_Internal_Sym *sym ATTRIBUTE_UNUSED)
d3880 4
a3883 3
frv_elf_use_relative_eh_frame (bfd *input_bfd,
			       struct bfd_link_info *info ATTRIBUTE_UNUSED,
			       asection *eh_frame_section ATTRIBUTE_UNUSED)
d3886 1
a3886 4
  if (elf_elfheader (input_bfd)->e_flags & EF_FRV_FDPIC)
    return FALSE;

  return TRUE;
d3892 5
a3896 5
frv_elf_encode_eh_address (bfd *abfd,
			   struct bfd_link_info *info,
			   asection *osec, bfd_vma offset,
			   asection *loc_sec, bfd_vma loc_offset,
			   bfd_vma *encoded)
a3899 5
  /* Non-FDPIC binaries can use PC-relative encodings.  */
  if (! (elf_elfheader (abfd)->e_flags & EF_FRV_FDPIC))
    return _bfd_elf_encode_eh_address (abfd, info, osec, offset,
				       loc_sec, loc_offset, encoded);

d3903 2
a3904 2
  if (! h || (_frv_osec_to_segment (abfd, osec)
	      == _frv_osec_to_segment (abfd, loc_sec->output_section)))
d3908 3
a3910 3
  BFD_ASSERT (_frv_osec_to_segment (abfd, osec)
	      == _frv_osec_to_segment (abfd,
				       h->root.u.def.section->output_section));
d4036 1
a4036 1
  struct frv_pic_relocs_info *picrel;
a4061 2
	case R_FRV_LABEL24:
	case R_FRV_32:
d4076 9
d4091 5
d4109 3
a4111 3
		= frv_pic_relocs_info_for_global (frv_relocs_info (info),
						  abfd, h,
						  rel->r_addend, INSERT);
d4114 3
a4116 3
	    picrel = frv_pic_relocs_info_for_local (frv_relocs_info (info),
						    abfd, r_symndx,
						    rel->r_addend, INSERT);
d4129 2
a4130 1
	  picrel->call = 1;
d4138 1
d4140 3
d4199 17
d4252 2
a4253 1
  return TRUE;
d4567 14
a4677 1
#define elf_info_to_howto_rel			frv_info_to_howto_rel
d4695 29
a4723 1
#define bfd_elf32_bfd_link_hash_table_create  frv_elf_link_hash_table_create
d4725 2
a4726 1
		elf32_frv_always_size_sections
d4728 1
a4728 1
		elf32_frv_modify_segment_map
d4730 1
d4732 2
a4733 1
		elf32_frv_create_dynamic_sections
d4735 2
a4736 1
		elf32_frv_adjust_dynamic_symbol
d4738 2
a4739 1
		elf32_frv_size_dynamic_sections
d4741 2
a4742 1
		elf32_frv_finish_dynamic_symbol
d4744 1
a4744 8
		elf32_frv_finish_dynamic_sections

#define elf_backend_want_got_sym	1
#define elf_backend_got_header_size	0
#define elf_backend_want_got_plt	0
#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_plt_header_size	0
d4746 1
d4748 2
a4749 1
		frv_elf_use_relative_eh_frame
d4751 4
a4754 2
		frv_elf_use_relative_eh_frame
#define elf_backend_encode_eh_address	frv_elf_encode_eh_address
d4756 1
d4758 1
d4761 1
@


1.20
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d2679 1
a2679 1
      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
d2727 1
a2727 1
  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
d2782 1
a2782 1
	  && ! _bfd_elf_link_record_dynamic_symbol (info, h))
d4031 1
a4031 1
		    bfd_elf32_link_record_dynamic_symbol (info, h);
d4110 1
a4110 1
          if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d4117 1
a4117 1
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.19
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d55 1
a55 1
  PARAMS (( bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
d2587 1
a2587 1
     const Elf_Internal_Sym *sym;
@


1.18
log
@bfd/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Report error if
	unresolved symbols in objects aren't allowed.

	* elf-hppa.h (elf_hppa_relocate_section): Properly handle
	unresolved symbols.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_unmark_useless_dynamic_symbols):
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

	* elf-m10200.c (mn10200_elf_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.

include/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Correct comments for the
	unresolved_syms_in_objects field.

ld/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (parse_args): Don't set unresolved_syms_in_objects
	or unresolved_syms_in_shared_libs for -Bdynamic and -Bstatic.
@
text
@d2 1
a2 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d3539 1
a3539 1
	if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0))
d3543 3
a3545 3
	if (! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_REL)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
d3549 4
a3552 4
	if (! bfd_elf32_add_dynamic_entry (info, DT_REL, 0)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_RELSZ, 0)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_RELENT,
					      sizeof (Elf32_External_Rel)))
@


1.17
log
@* elf32-frv.c (struct frv_pic_relocs_info): Added fixups and
dynrelocs.
(_frv_count_got_plt_entries): Initialize them.
(frv_pic_relocs_info_find): Add insert argument.  Adjust all
callers.
(frv_pic_relocs_info_for_global): Likewise.
(frv_pic_relocs_info_for_local): Likewise.
(frv_pic_merge_early_relocs_info): New.
(_frv_resolve_final_relocs_info): Use it in case one entry maps to
another.
(_frv_add_dyn_reloc): Add entry argument.  Adjust all callers.
Check that we don't exceed the allocated count for entry.
(_frv_add_rofixup): Likewise.
(_frv_emit_got_relocs_plt_entries): Adjust for coding standards.
(elf32_frv_finish_dynamic_sections): Improve error message in case
we emit too few rofixup entries.
@
text
@d1961 1
a1961 3
	  else if (   ! info->executable
		   && ! info->symbolic
		   && info->unresolved_syms_in_objects == RM_IGNORE
d1968 3
a1970 1
		      input_section, rel->r_offset, TRUE)))
@


1.17.2.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d1961 3
a1963 1
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
d1970 1
a1970 3
		      input_section, rel->r_offset,
		      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		       || ELF_ST_VISIBILITY (h->other)))))
@


1.16
log
@Add fr450 support.
@
text
@d751 4
d796 2
a797 1
			  const struct frv_pic_relocs_info *entry)
d800 4
a803 1
    (struct frv_pic_relocs_info **) htab_find_slot (ht, entry, INSERT);
d829 2
a830 1
				bfd_vma addend)
d838 1
a838 1
  return frv_pic_relocs_info_find (ht, abfd, &entry);
d848 2
a849 1
			       bfd_vma addend)
d857 53
a909 1
  return frv_pic_relocs_info_find (ht, abfd, &entry);
d924 2
a925 1
		    int reloc_type, long dynindx, bfd_vma addend)
d940 3
d949 2
a950 1
_frv_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset)
d964 7
a970 1
	      
d1075 2
a1076 2
	  if (entry->symndx != -1 ||
	      entry->d.h->root.type != bfd_link_hash_undefweak)
d1081 1
a1081 1
			      + entry->got_entry);
d1092 1
a1092 1
			    R_FRV_32, idx, ad);
d1165 1
a1165 1
				+ entry->fdgot_entry);
d1176 1
a1176 1
				reloc, idx, ad);
d1218 2
a1219 2
	  if (entry->symndx != -1 ||
	      entry->d.h->root.type != bfd_link_hash_undefweak)
d1225 1
a1225 1
				+ entry->fd_entry);
d1230 1
a1230 1
				+ entry->fd_entry + 4);
d1246 1
a1246 1
				R_FRV_FUNCDESC_VALUE, idx, ad);
d1998 1
a1998 1
						     orig_addend);
d2005 1
a2005 1
						    orig_addend);
d2168 2
a2169 1
					  + input_section->output_offset);
d2191 1
a2191 1
					r_type, dynindx, addend);
d2269 2
a2270 1
					  + input_section->output_offset);
d2279 1
a2279 1
			     + input_section->output_offset + 4);
d2304 1
a2304 1
					r_type, dynindx, addend);
d2884 1
d2941 1
a2941 1
    dinfo->relocs += entry->relocs32 + entry->relocsfd + entry->relocsfdv;
d2947 2
a2948 2
	      || entry->d.h->root.type != bfd_link_hash_undefweak)	  
	    dinfo->fixups += entry->relocs32 + 2 * entry->relocsfdv;
d2951 2
a2952 1
	dinfo->relocs += entry->relocs32 + entry->relocsfdv;
d2957 1
a2957 1
	    dinfo->fixups += entry->relocsfd;
d2960 1
a2960 1
	dinfo->relocs += entry->relocsfd;
d2963 5
d3295 1
d3304 11
d3678 1
a3678 1
				got_value);
d3684 10
a3693 1
	      if (!elf_hash_table (info)->dynamic_sections_created)
d4037 1
a4037 1
						  rel->r_addend);
d4042 1
a4042 1
						    rel->r_addend);
@


1.15
log
@* elf-bfd.h (struct elf_backend_data): Added
elf_backend_can_make_relative_eh_frame,
elf_backend_can_make_lsda_relative_eh_frame and
elf_backend_encode_eh_address.
(_bfd_elf_encode_eh_address): Declare.
(_bfd_elf_can_make_relative): Declare.
* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Use new
hooks to decide whether to attempt to make_relative and
make_lsda_relative.
(_bfd_elf_write_section_eh_frame_hdr): Call encode_eh_address.
(_bfd_elf_can_make_relative): New.
(_bfd_elf_encode_eh_address): New.
* elf32-frv.c (frv_elf_use_relative_eh_frame): New.
(frv_elf_encode_eh_address): New.
(elf_backend_can_make_relative_eh_frame): Define.
(elf_backend_can_make_lsda_relative_eh_frame): Define.
(elf_backend_encode_eh_address): Define.
* elfxx-target.h
(elf_backend_can_make_relative_eh_frame): Define.
(elf_backend_can_make_lsda_relative_eh_frame): Define.
(elf_backend_encode_eh_address): Define.
(elfNN_bed): Add them.
@
text
@d4035 2
d4087 27
d4298 1
a4298 4
      if (new_partial == old_partial)
	;

      else if (new_partial == EF_FRV_CPU_GENERIC)
d4301 1
a4301 1
      else if (old_partial == EF_FRV_CPU_GENERIC)
d4313 2
d4327 2
d4396 2
@


1.14
log
@* elf32-frv.c (elf32_frv_howto_table) <R_FRV_LABEL16>: Set
complain_on_overflow to signed.
@
text
@d25 1
d3704 51
d4473 6
@


1.13
log
@* elf32-frv.c (FRV_SYM_LOCAL): Weak undefined doesn't imply local.
(_frv_emit_got_relocs_plt_entries): Decay relocation to protected
function's descriptor to symbol+offset, and map local undefweak
symbol to NULL function descriptor.
(elf32_frv_relocate_section): Likewise.
@
text
@d120 1
a120 1
	 complain_overflow_bitfield, /* complain_on_overflow */
@


1.12
log
@* elf32-frv.c (elf32_frv_always_size_sections): Initialize pointer
to bfd_link_hash_entry passed by reference to
_bfd_generic_link_add_one_symbol.
@
text
@a661 1
   || (H)->root.type == bfd_link_hash_undefweak \
d1031 1
a1031 1
      bfd_vma ad;
d1033 3
a1035 5
      /* If the symbol is dynamic and there may be dynamic symbol
	 resolution because we are or are linked with a shared
	 library, emit a FUNCDESC relocation such that the dynamic
	 linker will allocate the function descriptor.  */
      if (entry->symndx == -1 && ! FRV_FUNCDESC_LOCAL (info, entry->d.h))
d1037 38
a1074 18
	  reloc = R_FRV_FUNCDESC;
	  idx = dynindx;
	  ad = addend;
	  if (ad)
	    return FALSE;
	}
      else
	{
	  /* Otherwise, we know we have a private function descriptor,
	     so reference it directly.  */
	  if (elf_hash_table (info)->dynamic_sections_created)
	    BFD_ASSERT (entry->privfd);
	  reloc = R_FRV_32;
	  idx = elf_section_data (frv_got_section (info)->output_section)
	    ->dynindx;
	  ad = frv_got_section (info)->output_offset +
	    frv_got_initial_offset (info) + entry->fd_entry;
	}
d1076 9
a1084 13
      /* If there is room for dynamic symbol resolution, emit the
	 dynamic relocation.  However, if we're linking an executable
	 at a fixed location, we won't have emitted a dynamic symbol
	 entry for the got section, so idx will be zero, which means
	 we can and should compute the address of the private
	 descriptor ourselves.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1 || FRV_FUNCDESC_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1
	      && entry->d.h->root.type == bfd_link_hash_undefweak)
	    ad = 0;
	  else
d1093 10
a1103 10
      else
	_frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
			    _bfd_elf_section_offset
			    (output_bfd, info,
			     frv_got_section (info),
			     frv_got_initial_offset (info)
			     + entry->fdgot_entry)
			    + frv_got_section (info)->output_section->vma
			    + frv_got_section (info)->output_offset,
			    reloc, idx, ad);
d2021 2
a2022 6
	    /* If the symbol is dynamic and there may be dynamic
	       symbol resolution because we are or are linked with a
	       shared library, emit a FUNCDESC relocation such that
	       the dynamic linker will allocate the function
	       descriptor.  */
	    if (h && ! FRV_FUNCDESC_LOCAL (info, h))
d2024 11
a2034 1
		if (addend)
d2036 27
a2062 4
		    info->callbacks->warning
		      (info, _("R_FRV_FUNCDESC references dynamic symbol with nonzero addend"),
		       name, input_bfd, input_section, rel->r_offset);
		    return FALSE;
a2063 14
		dynindx = h->dynindx;
	      }
	    else
	      {
		/* Otherwise, we know we have a private function
		   descriptor, so reference it directly.  */
		BFD_ASSERT (picrel->privfd);
		r_type = R_FRV_32;
		dynindx = elf_section_data (frv_got_section
					    (info)->output_section)->dynindx;
		addend = frv_got_section (info)->output_offset
		  + frv_got_initial_offset (info)
		  + picrel->fd_entry;
	      }
d2065 35
a2099 13
	    /* If there is room for dynamic symbol resolution, emit
	       the dynamic relocation.  However, if we're linking an
	       executable at a fixed location, we won't have emitted a
	       dynamic symbol entry for the got section, so idx will
	       be zero, which means we can and should compute the
	       address of the private descriptor ourselves.  */
	    if (info->executable && !info->pie
		&& (!h || FRV_FUNCDESC_LOCAL (info, h)))
	      {
		addend += frv_got_section (info)->output_section->vma;
		if ((bfd_get_section_flags (output_bfd,
					   input_section->output_section)
		     & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
d2106 1
a2106 1
			   _("cannot emit fixups in read-only section"),
d2110 1
a2110 3
		    if (! h || h->root.type != bfd_link_hash_undefweak)
		      _frv_add_rofixup (output_bfd,
					frv_gotfixup_section (info),
d2115 2
a2116 15
					+ input_section->output_offset);
		  }
	      }
	    else if ((bfd_get_section_flags (output_bfd,
					     input_section->output_section)
		      & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
	      {
		if (_frv_osec_readonly_p (output_bfd,
					  input_section->output_section))
		  {
		    info->callbacks->warning
		      (info,
		       _("cannot emit dynamic relocations in read-only section"),
		       name, input_bfd, input_section, rel->r_offset);
		    return FALSE;
a2117 7
		_frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
				    _bfd_elf_section_offset
				    (output_bfd, info,
				     input_section, rel->r_offset)
				    + input_section->output_section->vma
				    + input_section->output_offset,
				    r_type, dynindx, addend);
@


1.12.4.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004 Free Software Foundation, Inc.
d54 1
a54 1
  PARAMS (( bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d1874 3
a1876 1
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
d1883 1
a1883 3
		      input_section, rel->r_offset,
		      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		       || ELF_ST_VISIBILITY (h->other)))))
d2483 1
a2483 1
     Elf_Internal_Sym *sym;
d2575 1
a2575 1
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2623 1
a2623 1
  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2678 1
a2678 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d3416 1
a3416 1
	if (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0))
d3420 3
a3422 3
	if (!_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_REL)
	    || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))
d3426 4
a3429 4
	if (!_bfd_elf_add_dynamic_entry (info, DT_REL, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_RELSZ, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_RELENT,
					    sizeof (Elf32_External_Rel)))
d3848 1
a3848 1
		    bfd_elf_link_record_dynamic_symbol (info, h);
d3927 1
a3927 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d3934 1
a3934 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.12.4.2
log
@Merge to 2.15 branch.
@
text
@d120 1
a120 1
	 complain_overflow_signed, /* complain_on_overflow */
d662 1
a750 4
  /* The number of .rofixups entries and dynamic relocations allocated
     for this symbol, minus any that might have already been used.  */
  unsigned fixups, dynrelocs;

d792 1
a792 2
			  const struct frv_pic_relocs_info *entry,
			  enum insert_option insert)
d795 1
a795 4
    (struct frv_pic_relocs_info **) htab_find_slot (ht, entry, insert);

  if (! loc)
    return NULL;
d821 1
a821 2
				bfd_vma addend,
				enum insert_option insert)
d829 1
a829 1
  return frv_pic_relocs_info_find (ht, abfd, &entry, insert);
d839 1
a839 2
			       bfd_vma addend,
			       enum insert_option insert)
d847 1
a847 53
  return frv_pic_relocs_info_find (ht, abfd, &entry, insert);
}

/* Merge fields set by check_relocs() of two entries that end up being
   mapped to the same (presumably global) symbol.  */

inline static void
frv_pic_merge_early_relocs_info (struct frv_pic_relocs_info *e2,
				 struct frv_pic_relocs_info const *e1)
{
  e2->got12 |= e1->got12;
  e2->gotlos |= e1->gotlos;
  e2->gothilo |= e1->gothilo;
  e2->fd |= e1->fd;
  e2->fdgot12 |= e1->fdgot12;
  e2->fdgotlos |= e1->fdgotlos;
  e2->fdgothilo |= e1->fdgothilo;
  e2->fdgoff12 |= e1->fdgoff12;
  e2->fdgofflos |= e1->fdgofflos;
  e2->fdgoffhilo |= e1->fdgoffhilo;
  e2->gotoff |= e1->gotoff;
  e2->call |= e1->call;
  e2->sym |= e1->sym;

#if 0
  /* These are set in _frv_count_got_plt_entries() or later, and this
     function is only called in _frv_resolve_final_relocs_info(), that
     runs just before it, so we don't have to worry about the fields
     below.  */

  e2->plt |= e1->plt;
  e2->privfd |= e1->privfd;
  e2->lazyplt |= e1->lazyplt;
  e2->done |= e1->done;

  e2->relocs32 += e1->relocs32;
  e2->relocsfd += e1->relocsfd;
  e2->relocsfdv += e1->relocsfdv;
  e2->fixups += e1->fixups;
  e2->dynrelocs += e1->dynrelocs;

  if (abs (e1->got_entry) < abs (e2->got_entry))
    e2->got_entry = e1->got_entry;
  if (abs (e1->fdgot_entry) < abs (e2->fdgot_entry))
    e2->fdgot_entry = e1->fdgot_entry;
  if (abs (e1->fd_entry) < abs (e2->fd_entry))
    e2->fd_entry = e1->fd_entry;

  if (e1->plt_entry < e2->plt_entry)
    e2->plt_entry = e1->plt_entry;
  if (e1->lzplt_entry < e2->lzplt_entry)
    e2->lzplt_entry = e1->lzplt_entry;
#endif
d862 1
a862 2
		    int reloc_type, long dynindx, bfd_vma addend,
		    struct frv_pic_relocs_info *entry)
a876 3
  BFD_ASSERT (entry->dynrelocs > 0);
  entry->dynrelocs--;

d883 1
a883 2
_frv_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset,
		  struct frv_pic_relocs_info *entry)
d897 1
a897 7

  if (entry)
    {
      BFD_ASSERT (entry->fixups > 0);
      entry->fixups--;
    }

d1002 2
a1003 2
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
d1008 1
a1008 1
			      + entry->got_entry, entry);
d1019 1
a1019 1
			    R_FRV_32, idx, ad, entry);
d1032 1
a1032 1
      bfd_vma ad = 0;
d1034 37
a1070 30
      if (! (entry->symndx == -1
	     && entry->d.h->root.type == bfd_link_hash_undefweak
	     && FRV_SYM_LOCAL (info, entry->d.h)))
	{
	  /* If the symbol is dynamic and there may be dynamic symbol
	     resolution because we are, or are linked with, a shared
	     library, emit a FUNCDESC relocation such that the dynamic
	     linker will allocate the function descriptor.  If the
	     symbol needs a non-local function descriptor but binds
	     locally (e.g., its visibility is protected, emit a
	     dynamic relocation decayed to section+offset.  */
	  if (entry->symndx == -1 && ! FRV_FUNCDESC_LOCAL (info, entry->d.h)
	      && FRV_SYM_LOCAL (info, entry->d.h)
	      && !(info->executable && !info->pie))
	    {
	      reloc = R_FRV_FUNCDESC;
	      idx = elf_section_data (entry->d.h->root.u.def.section
				      ->output_section)->dynindx;
	      ad = entry->d.h->root.u.def.section->output_offset
		+ entry->d.h->root.u.def.value;
	    }
	  else if (entry->symndx == -1
		   && ! FRV_FUNCDESC_LOCAL (info, entry->d.h))
	    {
	      reloc = R_FRV_FUNCDESC;
	      idx = dynindx;
	      ad = addend;
	      if (ad)
		return FALSE;
	    }
a1072 21
	      /* Otherwise, we know we have a private function descriptor,
		 so reference it directly.  */
	      if (elf_hash_table (info)->dynamic_sections_created)
		BFD_ASSERT (entry->privfd);
	      reloc = R_FRV_32;
	      idx = elf_section_data (frv_got_section (info)
				      ->output_section)->dynindx;
	      ad = frv_got_section (info)->output_offset
		+ frv_got_initial_offset (info) + entry->fd_entry;
	    }

	  /* If there is room for dynamic symbol resolution, emit the
	     dynamic relocation.  However, if we're linking an
	     executable at a fixed location, we won't have emitted a
	     dynamic symbol entry for the got section, so idx will be
	     zero, which means we can and should compute the address
	     of the private descriptor ourselves.  */
	  if (info->executable && !info->pie
	      && (entry->symndx != -1
		  || FRV_FUNCDESC_LOCAL (info, entry->d.h)))
	    {
d1078 1
a1078 1
				+ entry->fdgot_entry, entry);
a1079 10
	  else
	    _frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
				_bfd_elf_section_offset
				(output_bfd, info,
				 frv_got_section (info),
				 frv_got_initial_offset (info)
				 + entry->fdgot_entry)
				+ frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset,
				reloc, idx, ad, entry);
d1081 10
d1131 2
a1132 2
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
d1138 1
a1138 1
				+ entry->fd_entry, entry);
d1143 1
a1143 1
				+ entry->fd_entry + 4, entry);
d1159 1
a1159 1
				R_FRV_FUNCDESC_VALUE, idx, ad, entry);
d1911 1
a1911 1
						     orig_addend, INSERT);
d1918 1
a1918 1
						    orig_addend, INSERT);
d2008 6
a2013 2
	    if (! (h && h->root.type == bfd_link_hash_undefweak
		   && FRV_SYM_LOCAL (info, h)))
d2015 1
a2015 11
		/* If the symbol is dynamic and there may be dynamic
		   symbol resolution because we are or are linked with a
		   shared library, emit a FUNCDESC relocation such that
		   the dynamic linker will allocate the function
		   descriptor.  If the symbol needs a non-local function
		   descriptor but binds locally (e.g., its visibility is
		   protected, emit a dynamic relocation decayed to
		   section+offset.  */
		if (h && ! FRV_FUNCDESC_LOCAL (info, h)
		    && FRV_SYM_LOCAL (info, h)
		    && !(info->executable && !info->pie))
d2017 4
a2020 27
		    dynindx = elf_section_data (h->root.u.def.section
						->output_section)->dynindx;
		    addend += h->root.u.def.section->output_offset
		      + h->root.u.def.value;
		  }
		else if (h && ! FRV_FUNCDESC_LOCAL (info, h))
		  {
		    if (addend)
		      {
			info->callbacks->warning
			  (info, _("R_FRV_FUNCDESC references dynamic symbol with nonzero addend"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    dynindx = h->dynindx;
		  }
		else
		  {
		    /* Otherwise, we know we have a private function
		       descriptor, so reference it directly.  */
		    BFD_ASSERT (picrel->privfd);
		    r_type = R_FRV_32;
		    dynindx = elf_section_data (frv_got_section	(info)
						->output_section)->dynindx;
		    addend = frv_got_section (info)->output_offset
		      + frv_got_initial_offset (info)
		      + picrel->fd_entry;
d2022 14
d2037 13
a2049 36
		/* If there is room for dynamic symbol resolution, emit
		   the dynamic relocation.  However, if we're linking an
		   executable at a fixed location, we won't have emitted a
		   dynamic symbol entry for the got section, so idx will
		   be zero, which means we can and should compute the
		   address of the private descriptor ourselves.  */
		if (info->executable && !info->pie
		    && (!h || FRV_FUNCDESC_LOCAL (info, h)))
		  {
		    addend += frv_got_section (info)->output_section->vma;
		    if ((bfd_get_section_flags (output_bfd,
						input_section->output_section)
			 & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		      {
			if (_frv_osec_readonly_p (output_bfd,
						  input_section->output_section))
			  {
			    info->callbacks->warning
			      (info,
			       _("cannot emit fixups in read-only section"),
			       name, input_bfd, input_section, rel->r_offset);
			    return FALSE;
			  }
			_frv_add_rofixup (output_bfd,
					  frv_gotfixup_section (info),
					  _bfd_elf_section_offset
					  (output_bfd, info,
					   input_section, rel->r_offset)
					  + input_section->output_section->vma
					  + input_section->output_offset,
					  picrel);
		      }
		  }
		else if ((bfd_get_section_flags (output_bfd,
						 input_section->output_section)
			  & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
d2056 1
a2056 1
			   _("cannot emit dynamic relocations in read-only section"),
d2060 3
a2062 1
		    _frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
d2067 15
a2081 2
					+ input_section->output_offset,
					r_type, dynindx, addend, picrel);
d2083 7
d2166 1
a2166 2
					  + input_section->output_offset,
					  picrel);
d2175 1
a2175 1
			     + input_section->output_offset + 4, picrel);
d2200 1
a2200 1
					r_type, dynindx, addend, picrel);
a2779 1
  unsigned relocs = 0, fixups = 0;
d2836 1
a2836 1
    relocs = entry->relocs32 + entry->relocsfd + entry->relocsfdv;
d2842 2
a2843 2
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    fixups += entry->relocs32 + 2 * entry->relocsfdv;
d2846 1
a2846 2
	relocs += entry->relocs32 + entry->relocsfdv;

d2851 1
a2851 1
	    fixups += entry->relocsfd;
d2854 1
a2854 1
	relocs += entry->relocsfd;
a2856 5
  entry->dynrelocs += relocs;
  entry->fixups += fixups;
  dinfo->relocs += relocs;
  dinfo->fixups += fixups;

a3183 1
      struct frv_pic_relocs_info *oentry;
a3191 11
      oentry = frv_pic_relocs_info_for_global (*htab, 0, h, entry->addend,
					       NO_INSERT);

      if (oentry)
	{
	  /* Merge the two entries.  */
	  frv_pic_merge_early_relocs_info (oentry, entry);
	  htab_clear_slot (*htab, entryp);
	  return 1;
	}

d3555 1
a3555 1
				got_value, 0);
d3561 1
a3561 10
	      if (frv_gotfixup_section (info)->_raw_size
		  < frv_gotfixup_section (info)->reloc_count * 4)
		{
		  info->callbacks->warning
		    (info, "LINKER BUG: .rofixup section size mismatch",
		     ".rofixup", NULL, NULL, 0);
		  abort ();
		  return FALSE;
		}
	      else if (!elf_hash_table (info)->dynamic_sections_created)
d3854 1
a3854 1
						  rel->r_addend, INSERT);
d3859 1
a3859 1
						    rel->r_addend, INSERT);
@


1.12.4.3
log
@Merge from mainline:
2004-02-27  Alexandre Oliva  <aoliva@@redhat.com>
* elf-bfd.h (struct elf_backend_data): Added
elf_backend_can_make_relative_eh_frame,
elf_backend_can_make_lsda_relative_eh_frame and
elf_backend_encode_eh_address.
(_bfd_elf_encode_eh_address): Declare.
(_bfd_elf_can_make_relative): Declare.
* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Use new
hooks to decide whether to attempt to make_relative and
make_lsda_relative.
(_bfd_elf_write_section_eh_frame_hdr): Call encode_eh_address.
(_bfd_elf_can_make_relative): New.
(_bfd_elf_encode_eh_address): New.
* elf32-frv.c (frv_elf_use_relative_eh_frame): New.
(frv_elf_encode_eh_address): New.
(elf_backend_can_make_relative_eh_frame): Define.
(elf_backend_can_make_lsda_relative_eh_frame): Define.
(elf_backend_encode_eh_address): Define.
* elfxx-target.h
(elf_backend_can_make_relative_eh_frame): Define.
(elf_backend_can_make_lsda_relative_eh_frame): Define.
(elf_backend_encode_eh_address): Define.
(elfNN_bed): Add them.
@
text
@a24 1
#include "elf/dwarf2.h"
a3805 51
/* Decide whether to attempt to turn absptr or lsda encodings in
   shared libraries into pcrel within the given input section.  */

static bfd_boolean
frv_elf_use_relative_eh_frame (bfd *input_bfd,
			       struct bfd_link_info *info ATTRIBUTE_UNUSED,
			       asection *eh_frame_section ATTRIBUTE_UNUSED)
{
  /* We can't use PC-relative encodings in FDPIC binaries, in general.  */
  if (elf_elfheader (input_bfd)->e_flags & EF_FRV_FDPIC)
    return FALSE;

  return TRUE;
}

/* Adjust the contents of an eh_frame_hdr section before they're output.  */

static bfd_byte
frv_elf_encode_eh_address (bfd *abfd,
			   struct bfd_link_info *info,
			   asection *osec, bfd_vma offset,
			   asection *loc_sec, bfd_vma loc_offset,
			   bfd_vma *encoded)
{
  struct elf_link_hash_entry *h;

  /* Non-FDPIC binaries can use PC-relative encodings.  */
  if (! (elf_elfheader (abfd)->e_flags & EF_FRV_FDPIC))
    return _bfd_elf_encode_eh_address (abfd, info, osec, offset,
				       loc_sec, loc_offset, encoded);

  h = elf_hash_table (info)->hgot;
  BFD_ASSERT (h && h->root.type == bfd_link_hash_defined);

  if (! h || (_frv_osec_to_segment (abfd, osec)
	      == _frv_osec_to_segment (abfd, loc_sec->output_section)))
    return _bfd_elf_encode_eh_address (abfd, info, osec, offset,
				       loc_sec, loc_offset, encoded);

  BFD_ASSERT (_frv_osec_to_segment (abfd, osec)
	      == _frv_osec_to_segment (abfd,
				       h->root.u.def.section->output_section));

  *encoded = osec->vma + offset
    - (h->root.u.def.value
       + h->root.u.def.section->output_section->vma
       + h->root.u.def.section->output_offset);

  return DW_EH_PE_datarel | DW_EH_PE_sdata4;
}

a4523 6

#define elf_backend_can_make_relative_eh_frame \
		frv_elf_use_relative_eh_frame
#define elf_backend_can_make_lsda_relative_eh_frame \
		frv_elf_use_relative_eh_frame
#define elf_backend_encode_eh_address	frv_elf_encode_eh_address
@


1.12.4.4
log
@* configure.in (bfd_elf32_frvfdpic_vec): New.
* configure: Rebuilt.
* targets.c (bfd_elf32_frvfdpic_vec): New.
* config.bfd: Enable it on frv-*-elf and frv-*-*linux*, as default
on the latter.
* elf32-frv.c: Prefix all identifiers added for FDPIC support with
frvfdpic instead of frv.  Rearrange elf-target macros such that
the FDPIC-specific ones are only defined for this new target
vector.
(bfd_elf32_frvfdpic_vec): Declare.
(IS_FDPIC): New.
(elf32_frv_relocate_section): Use it to enable segment checking
and to control rofixup emission.  Add output section vma to
applied relocation in non-LOAD non-ALLOC sections.  Use
_bfd_error_handler for errors.
(_frv_create_got_section): Create .rel.got and .rofixup only in
FDPIC.  Create non-dynamic _gp at .got+2048 in non-FDPIC, like the
linker script.
(elf32_frvfdpic_size_dynamic_sections): Assume FDPIC.
(elf32_frvfdpic_modify_segment_map): Likewise.
(elf32_frv_finish_dynamic_sections): New, do-nothing.
(elf32_frvfdpic_finish_dynamic_sections): Assume FDPIC.  Improve
error message if we miscompute the rofixup size.
(frvfdpic_elf_use_relative_eh_frame): Assume FDPIC.
(frvfdpic_elf_encode_eh_address): Likewise.
(elf32_frv_check_relocs): Reject FDPIC-only relocs in non-FDPIC.
Record relocs only in FDPIC.  Make sure _gp is defined for GPREL
relocs.  Reject unknown relocation types.
(elf32_frv_object_p): Make sure target vector matches FDPIC bits.
(frv_elf_merge_private_bfd_data): Likewise.
(ELF_MAXPAGESIZE): Revert to 0x1000 for elf32-frv; keep it as
0x4000 for newly-added elf32-frvfdpic.
@
text
@a585 2
extern const bfd_target bfd_elf32_frvfdpic_vec;
#define IS_FDPIC(bfd) ((bfd)->xvec == &bfd_elf32_frvfdpic_vec)
d589 1
a589 1
struct frvfdpic_elf_link_hash_table
d615 2
a616 2
#define frvfdpic_hash_table(info) \
  ((struct frvfdpic_elf_link_hash_table *) ((info)->hash))
d618 16
a633 16
#define frvfdpic_got_section(info) \
  (frvfdpic_hash_table (info)->sgot)
#define frvfdpic_gotrel_section(info) \
  (frvfdpic_hash_table (info)->sgotrel)
#define frvfdpic_gotfixup_section(info) \
  (frvfdpic_hash_table (info)->sgotfixup)
#define frvfdpic_plt_section(info) \
  (frvfdpic_hash_table (info)->splt)
#define frvfdpic_pltrel_section(info) \
  (frvfdpic_hash_table (info)->spltrel)
#define frvfdpic_relocs_info(info) \
  (frvfdpic_hash_table (info)->relocs_info)
#define frvfdpic_got_initial_offset(info) \
  (frvfdpic_hash_table (info)->got0)
#define frvfdpic_plt_initial_offset(info) \
  (frvfdpic_hash_table (info)->plt0)
d638 1
a638 1
frvfdpic_elf_link_hash_table_create (bfd *abfd)
d640 2
a641 2
  struct frvfdpic_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct frvfdpic_elf_link_hash_table);
d660 1
a660 1
#define FRVFDPIC_SYM_LOCAL(INFO, H) \
d673 1
a673 1
#define FRVFDPIC_FUNCDESC_LOCAL(INFO, H) \
d679 1
a679 1
struct frvfdpic_relocs_info
d730 1
a730 1
     (call && symndx == -1 && ! FRVFDPIC_SYM_LOCAL (info, d.h))  */
d736 1
a736 1
          && (symndx != -1 || FRVFDPIC_FUNCDESC_LOCAL (info, d.h))))  */
d740 1
a740 1
     (privfd && symndx == -1 && ! FRVFDPIC_SYM_LOCAL (info, d.h)
d767 1
a767 1
/* Compute a hash with the key fields of an frvfdpic_relocs_info entry.  */
d769 1
a769 1
frvfdpic_relocs_info_hash (const void *entry_)
d771 1
a771 1
  const struct frvfdpic_relocs_info *entry = entry_;
d778 1
a778 1
/* Test whether the key fields of two frvfdpic_relocs_info entries are
d781 1
a781 1
frvfdpic_relocs_info_eq (const void *entry1, const void *entry2)
d783 2
a784 2
  const struct frvfdpic_relocs_info *e1 = entry1;
  const struct frvfdpic_relocs_info *e2 = entry2;
d793 5
a797 5
static struct frvfdpic_relocs_info *
frvfdpic_relocs_info_find (struct htab *ht,
			   bfd *abfd,
			   const struct frvfdpic_relocs_info *entry,
			   enum insert_option insert)
d799 2
a800 2
  struct frvfdpic_relocs_info **loc =
    (struct frvfdpic_relocs_info **) htab_find_slot (ht, entry, insert);
d825 6
a830 6
inline static struct frvfdpic_relocs_info *
frvfdpic_relocs_info_for_global (struct htab *ht,
				 bfd *abfd,
				 struct elf_link_hash_entry *h,
				 bfd_vma addend,
				 enum insert_option insert)
d832 1
a832 1
  struct frvfdpic_relocs_info entry;
d838 1
a838 1
  return frvfdpic_relocs_info_find (ht, abfd, &entry, insert);
d844 6
a849 6
inline static struct frvfdpic_relocs_info *
frvfdpic_relocs_info_for_local (struct htab *ht,
				bfd *abfd,
				long symndx,
				bfd_vma addend,
				enum insert_option insert)
d851 1
a851 1
  struct frvfdpic_relocs_info entry;
d857 1
a857 1
  return frvfdpic_relocs_info_find (ht, abfd, &entry, insert);
d864 2
a865 2
frvfdpic_pic_merge_early_relocs_info (struct frvfdpic_relocs_info *e2,
				      struct frvfdpic_relocs_info const *e1)
d882 2
a883 2
  /* These are set in _frvfdpic_count_got_plt_entries() or later, and this
     function is only called in _frvfdpic_resolve_final_relocs_info(), that
d917 2
a918 2
#define FRVFDPIC_LZPLT_BLOCK_SIZE ((bfd_vma) 8 * 65535 + 4)
#define FRVFDPIC_LZPLT_RESOLV_LOC (8 * 32767)
d923 3
a925 3
_frvfdpic_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
			 int reloc_type, long dynindx, bfd_vma addend,
			 struct frvfdpic_relocs_info *entry)
d949 2
a950 2
_frvfdpic_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset,
		       struct frvfdpic_relocs_info *entry)
d978 1
a978 1
_frvfdpic_osec_to_segment (bfd *output_bfd, asection *osec)
d1003 1
a1003 1
_frvfdpic_osec_readonly_p (bfd *output_bfd, asection *osec)
d1005 1
a1005 1
  unsigned seg = _frvfdpic_osec_to_segment (output_bfd, osec);
d1014 6
a1019 6
_frvfdpic_emit_got_relocs_plt_entries (struct frvfdpic_relocs_info *entry,
				       bfd *output_bfd,
				       struct bfd_link_info *info,
				       asection *sec,
				       Elf_Internal_Sym *sym,
				       bfd_vma addend)
d1054 1
a1054 2
      if (sec && (entry->symndx != -1
		  || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
d1071 1
a1071 2
	  && (entry->symndx != -1
	      || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
d1077 16
a1092 19
	    _frvfdpic_add_rofixup (output_bfd,
				   frvfdpic_gotfixup_section (info),
				   frvfdpic_got_section (info)->output_section
				   ->vma
				   + frvfdpic_got_section (info)->output_offset
				   + frvfdpic_got_initial_offset (info)
				   + entry->got_entry, entry);
	}
      else
	_frvfdpic_add_dyn_reloc (output_bfd, frvfdpic_gotrel_section (info),
				 _bfd_elf_section_offset
				 (output_bfd, info,
				  frvfdpic_got_section (info),
				  frvfdpic_got_initial_offset (info)
				  + entry->got_entry)
				 + frvfdpic_got_section (info)
				 ->output_section->vma
				 + frvfdpic_got_section (info)->output_offset,
				 R_FRV_32, idx, ad, entry);
d1095 2
a1096 2
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
d1109 1
a1109 1
	     && FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
d1118 2
a1119 3
	  if (entry->symndx == -1
	      && ! FRVFDPIC_FUNCDESC_LOCAL (info, entry->d.h)
	      && FRVFDPIC_SYM_LOCAL (info, entry->d.h)
d1129 1
a1129 1
		   && ! FRVFDPIC_FUNCDESC_LOCAL (info, entry->d.h))
d1144 1
a1144 1
	      idx = elf_section_data (frvfdpic_got_section (info)
d1146 2
a1147 2
	      ad = frvfdpic_got_section (info)->output_offset
		+ frvfdpic_got_initial_offset (info) + entry->fd_entry;
d1158 1
a1158 1
		  || FRVFDPIC_FUNCDESC_LOCAL (info, entry->d.h)))
d1160 6
a1165 9
	      ad += frvfdpic_got_section (info)->output_section->vma;
	      _frvfdpic_add_rofixup (output_bfd,
				     frvfdpic_gotfixup_section (info),
				     frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset
				     + frvfdpic_got_initial_offset (info)
				     + entry->fdgot_entry, entry);
d1168 9
a1176 12
	    _frvfdpic_add_dyn_reloc (output_bfd,
				     frvfdpic_gotrel_section (info),
				     _bfd_elf_section_offset
				     (output_bfd, info,
				      frvfdpic_got_section (info),
				      frvfdpic_got_initial_offset (info)
				      + entry->fdgot_entry)
				     + frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset,
				     reloc, idx, ad, entry);
d1180 2
a1181 2
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
d1196 1
a1196 2
      if (sec && (entry->symndx != -1
		  || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
d1213 1
a1213 1
	  && (entry->symndx != -1 || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
d1221 10
a1230 16
	      _frvfdpic_add_rofixup (output_bfd,
				     frvfdpic_gotfixup_section (info),
				     frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset
				     + frvfdpic_got_initial_offset (info)
				     + entry->fd_entry, entry);
	      _frvfdpic_add_rofixup (output_bfd,
				     frvfdpic_gotfixup_section (info),
				     frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset
				     + frvfdpic_got_initial_offset (info)
				     + entry->fd_entry + 4, entry);
d1236 11
a1246 14
	    _frvfdpic_add_dyn_reloc (output_bfd,
				     entry->lazyplt
				     ? frvfdpic_pltrel_section (info)
				     : frvfdpic_gotrel_section (info),
				     _bfd_elf_section_offset
				     (output_bfd, info,
				      frvfdpic_got_section (info),
				      frvfdpic_got_initial_offset (info)
				      + entry->fd_entry)
				     + frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset,
				     R_FRV_FUNCDESC_VALUE, idx, ad, entry);
d1254 3
a1256 3
	  highword = frvfdpic_got_section (info)->output_section->vma
	    + frvfdpic_got_section (info)->output_offset
	    + frvfdpic_got_initial_offset (info);
d1272 4
a1275 4
	    + frvfdpic_plt_section (info)->output_offset
	    + frvfdpic_plt_section (info)->output_section->vma;
	  highword = _frvfdpic_osec_to_segment 
	    (output_bfd, frvfdpic_plt_section (info)->output_section);
d1287 1
a1287 2
	    highword = _frvfdpic_osec_to_segment
	      (output_bfd, sec->output_section);
d1291 2
a1292 2
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
d1295 2
a1296 2
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
d1303 1
a1303 2
      bfd_byte *plt_code = frvfdpic_plt_section (info)->contents
	+ entry->plt_entry;
d1356 1
a1356 1
      bfd_byte *lzplt_code = frvfdpic_plt_section (info)->contents
d1363 4
a1366 4
      resolverStub_addr = entry->lzplt_entry / FRVFDPIC_LZPLT_BLOCK_SIZE
	* FRVFDPIC_LZPLT_BLOCK_SIZE + FRVFDPIC_LZPLT_RESOLV_LOC;
      if (resolverStub_addr >= frvfdpic_plt_initial_offset (info))
	resolverStub_addr = frvfdpic_plt_initial_offset (info) - 12;
d1770 2
a1771 2
frvfdpic_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
			    arelent *cache_ptr, Elf_Internal_Rela *dst)
d1872 6
a1877 6
  isec_segment = _frvfdpic_osec_to_segment (output_bfd,
					    input_section->output_section);
  if (IS_FDPIC (output_bfd) && frvfdpic_got_section (info))
    got_segment = _frvfdpic_osec_to_segment (output_bfd,
					     frvfdpic_got_section (info)
					     ->output_section);
d1880 4
a1883 4
  if (IS_FDPIC (output_bfd) && frvfdpic_gotfixup_section (info))
    gprel_segment = _frvfdpic_osec_to_segment (output_bfd,
					       frvfdpic_gotfixup_section (info)
					       ->output_section);
d1886 4
a1889 4
  if (IS_FDPIC (output_bfd) && elf_hash_table (info)->dynamic_sections_created)
    plt_segment = _frvfdpic_osec_to_segment (output_bfd,
					     frvfdpic_plt_section (info)
					     ->output_section);
d1905 1
a1905 1
      struct frvfdpic_relocs_info *picrel;
d1943 1
a1943 1
	      && ! FRVFDPIC_SYM_LOCAL (info, h))
a1980 3
	  if (! IS_FDPIC (output_bfd))
	    goto non_fdpic;

d1996 3
a1998 3
	    picrel = frvfdpic_relocs_info_for_global (frvfdpic_relocs_info
						      (info), input_bfd, h,
						      orig_addend, INSERT);
d2003 3
a2005 3
	    picrel = frvfdpic_relocs_info_for_local (frvfdpic_relocs_info
						     (info), input_bfd, r_symndx,
						     orig_addend, INSERT);
d2009 2
a2010 3
	  if (!_frvfdpic_emit_got_relocs_plt_entries (picrel, output_bfd, info,
						      osec, sym,
						      rel->r_addend))
d2012 3
a2014 4
	      (*_bfd_error_handler)
		(_("%s: relocation at `%s+0x%x' references symbol `%s' with nonzero addend"),
		 bfd_archive_filename (input_bfd), input_section->name,
		 rel->r_offset, name);
a2021 1
	non_fdpic:
d2023 1
a2023 1
	  if (h && ! FRVFDPIC_SYM_LOCAL (info, h))
d2037 1
a2037 3
	  if (! IS_FDPIC (output_bfd))
	    check_segment[1] = isec_segment;
	  else if (picrel->plt)
d2039 2
a2040 2
	      relocation = frvfdpic_plt_section (info)->output_section->vma
		+ frvfdpic_plt_section (info)->output_offset
d2053 1
a2053 1
	      ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
d2074 3
a2076 3
	  relocation -= frvfdpic_got_section (info)->output_section->vma
	    + frvfdpic_got_section (info)->output_offset
	    + frvfdpic_got_initial_offset (info);
d2079 1
a2079 1
	    ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
d2096 1
a2096 1
		   && FRVFDPIC_SYM_LOCAL (info, h)))
d2106 2
a2107 2
		if (h && ! FRVFDPIC_FUNCDESC_LOCAL (info, h)
		    && FRVFDPIC_SYM_LOCAL (info, h)
d2115 1
a2115 1
		else if (h && ! FRVFDPIC_FUNCDESC_LOCAL (info, h))
d2132 1
a2132 1
		    dynindx = elf_section_data (frvfdpic_got_section (info)
d2134 2
a2135 2
		    addend = frvfdpic_got_section (info)->output_offset
		      + frvfdpic_got_initial_offset (info)
d2146 1
a2146 1
		    && (!h || FRVFDPIC_FUNCDESC_LOCAL (info, h)))
d2148 1
a2148 1
		    addend += frvfdpic_got_section (info)->output_section->vma;
d2153 2
a2154 3
			if (_frvfdpic_osec_readonly_p (output_bfd,
						       input_section
						       ->output_section))
d2162 8
a2169 10
			_frvfdpic_add_rofixup (output_bfd,
					       frvfdpic_gotfixup_section
					       (info),
					       _bfd_elf_section_offset
					       (output_bfd, info,
						input_section, rel->r_offset)
					       + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       picrel);
d2176 2
a2177 3
		    if (_frvfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
d2185 7
a2191 9
		    _frvfdpic_add_dyn_reloc (output_bfd,
					     frvfdpic_gotrel_section (info),
					     _bfd_elf_section_offset
					     (output_bfd, info,
					      input_section, rel->r_offset)
					     + input_section
					     ->output_section->vma
					     + input_section->output_offset,
					     r_type, dynindx, addend, picrel);
a2192 2
		else
		  addend += frvfdpic_got_section (info)->output_section->vma;
a2203 6
	  if (! IS_FDPIC (output_bfd))
	    {
	      check_segment[0] = check_segment[1] = -1;
	      break;
	    }
	  /* Fall through.  */
d2211 1
a2211 1
	    if (h && ! FRVFDPIC_SYM_LOCAL (info, h))
d2243 1
a2243 1
		&& (!h || FRVFDPIC_SYM_LOCAL (info, h)))
d2247 1
a2247 1
		if (IS_FDPIC (input_bfd)
d2252 2
a2253 3
		    if (_frvfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
d2263 8
a2270 10
			_frvfdpic_add_rofixup (output_bfd,
					       frvfdpic_gotfixup_section
					       (info),
					       _bfd_elf_section_offset
					       (output_bfd, info,
						input_section, rel->r_offset)
					       + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       picrel);
d2272 1
a2272 1
			  _frvfdpic_add_rofixup
d2274 1
a2274 1
			     frvfdpic_gotfixup_section (info),
d2289 2
a2290 3
		    if (_frvfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
d2298 7
a2304 9
		    _frvfdpic_add_dyn_reloc (output_bfd,
					     frvfdpic_gotrel_section (info),
					     _bfd_elf_section_offset
					     (output_bfd, info,
					      input_section, rel->r_offset)
					     + input_section
					     ->output_section->vma
					     + input_section->output_offset,
					     r_type, dynindx, addend, picrel);
a2305 2
		else if (osec)
		  addend += osec->output_section->vma;
d2318 1
a2318 1
		    && (!h || FRVFDPIC_SYM_LOCAL (info, h)))
d2320 3
a2322 3
			      frvfdpic_got_section (info)->output_section->vma
			      + frvfdpic_got_section (info)->output_offset
			      + frvfdpic_got_initial_offset (info),
d2332 1
a2332 1
			      h && ! FRVFDPIC_SYM_LOCAL (info, h)
d2334 2
a2335 3
			      : _frvfdpic_osec_to_segment (output_bfd,
							   sec
							   ->output_section),
d2349 1
a2349 1
	    ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
d2356 1
a2356 1
	    ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
d2361 2
a2362 1
      if (check_segment[0] != check_segment[1] && IS_FDPIC (output_bfd))
d2364 1
a2364 2
#if 1 /* If you take this out, remove the #error from fdpic-static-6.d
	 in the ld testsuite.  */
d2421 1
a2421 1
	  if (! IS_FDPIC (output_bfd) || ! picrel->plt)
d2618 1
a2618 2

/* Create  a .got section, as well as its additional info field.  This
a2630 1
  int offset;
d2690 6
a2695 8
  if (IS_FDPIC (abfd))
    {
      frvfdpic_got_section (info) = s;
      frvfdpic_relocs_info (info) = htab_try_create (1, frvfdpic_relocs_info_hash,
						     frvfdpic_relocs_info_eq,
						     (htab_del) NULL);
      if (! frvfdpic_relocs_info (info))
	return FALSE;
d2697 5
a2701 5
      s = bfd_make_section (abfd, ".rel.got");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;
d2703 1
a2703 1
      frvfdpic_gotrel_section (info) = s;
d2705 6
a2710 6
      /* Machine-specific.  */
      s = bfd_make_section (abfd, ".rofixup");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;
d2712 1
a2712 9
      frvfdpic_gotfixup_section (info) = s;
      offset = -2048;
      flags = BSF_GLOBAL;
    }
  else
    {
      offset = 2048;
      flags = BSF_GLOBAL | BSF_WEAK;
    }
d2714 3
a2716 3
  /* Define _gp in .rofixup, for FDPIC, or .got otherwise.  If it
     turns out that we're linking with a different linker script, the
     linker script will override it.  */
d2719 1
a2719 1
	(info, abfd, "_gp", flags, s, offset, (const char *) NULL, FALSE,
d2727 1
a2727 1
  if (IS_FDPIC (abfd) && ! bfd_elf_link_record_dynamic_symbol (info, h))
d2729 1
a2729 1

d2737 1
a2737 1
elf32_frvfdpic_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d2764 1
a2764 1
  frvfdpic_plt_section (info) = s;
d2793 1
a2793 1
  frvfdpic_pltrel_section (info) = s;
d2800 3
a2802 4
  BFD_ASSERT (frvfdpic_got_section (info) && frvfdpic_gotrel_section (info)
	      && frvfdpic_gotfixup_section (info)
	      && frvfdpic_plt_section (info)
	      && frvfdpic_pltrel_section (info));
d2852 1
a2852 1
struct _frvfdpic_dynamic_got_info
d2880 1
a2880 1
_frvfdpic_count_got_plt_entries (void **entryp, void *dinfo_)
d2882 2
a2883 2
  struct frvfdpic_relocs_info *entry = *entryp;
  struct _frvfdpic_dynamic_got_info *dinfo = dinfo_;
d2912 1
a2912 1
    && entry->symndx == -1 && ! FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)
d2918 1
a2918 1
	    || FRVFDPIC_FUNCDESC_LOCAL (dinfo->info, entry->d.h)));
d2920 1
a2920 1
    && entry->symndx == -1 && ! FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)
d2944 1
a2944 1
      if (entry->symndx != -1 || FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h))
d2953 1
a2953 2
      if (entry->symndx != -1
	  || FRVFDPIC_FUNCDESC_LOCAL (dinfo->info, entry->d.h))
d2974 1
a2974 1
struct _frvfdpic_dynamic_got_plt_info
d2976 2
a2977 2
  /* Summary information collected with _frvfdpic_count_got_plt_entries.  */
  struct _frvfdpic_dynamic_got_info g;
d2993 1
a2993 1
  struct _frvfdpic_dynamic_got_alloc_data
d3011 8
a3018 8
_frvfdpic_compute_got_alloc_data (struct _frvfdpic_dynamic_got_alloc_data *gad,
				  bfd_signed_vma fdcur,
				  bfd_signed_vma odd,
				  bfd_signed_vma cur,
				  bfd_vma got,
				  bfd_vma fd,
				  bfd_vma fdplt,
				  bfd_vma wrap)
d3112 1
a3112 1
  /* _frvfdpic_get_got_entry() below will always wrap gad->cur if needed
d3126 1
a3126 1
_frvfdpic_get_got_entry (struct _frvfdpic_dynamic_got_alloc_data *gad)
d3155 1
a3155 1
_frvfdpic_get_fd_entry (struct _frvfdpic_dynamic_got_alloc_data *gad)
d3168 1
a3168 1
_frvfdpic_assign_got_entries (void **entryp, void *info_)
d3170 2
a3171 2
  struct frvfdpic_relocs_info *entry = *entryp;
  struct _frvfdpic_dynamic_got_plt_info *dinfo = info_;
d3174 1
a3174 1
    entry->got_entry = _frvfdpic_get_got_entry (&dinfo->got12);
d3176 1
a3176 1
    entry->got_entry = _frvfdpic_get_got_entry (&dinfo->gotlos);
d3178 1
a3178 1
    entry->got_entry = _frvfdpic_get_got_entry (&dinfo->gothilo);
d3181 1
a3181 1
    entry->fdgot_entry = _frvfdpic_get_got_entry (&dinfo->got12);
d3183 1
a3183 1
    entry->fdgot_entry = _frvfdpic_get_got_entry (&dinfo->gotlos);
d3185 1
a3185 1
    entry->fdgot_entry = _frvfdpic_get_got_entry (&dinfo->gothilo);
d3188 1
a3188 1
    entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->got12);
d3192 1
a3192 1
      entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->got12);
d3195 1
a3195 1
    entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gotlos);
d3199 1
a3199 1
      entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gotlos);
d3204 1
a3204 1
      entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gothilo);
d3207 1
a3207 1
    entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gothilo);
d3217 1
a3217 1
_frvfdpic_assign_plt_entries (void **entryp, void *info_)
d3219 2
a3220 2
  struct frvfdpic_relocs_info *entry = *entryp;
  struct _frvfdpic_dynamic_got_plt_info *dinfo = info_;
d3228 1
a3228 1
	  entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->got12);
d3233 1
a3233 1
	  entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gotlos);
d3239 1
a3239 1
	  entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gothilo);
d3250 1
a3250 1
      entry->plt_entry = frvfdpic_plt_section (dinfo->g.info)->_raw_size;
d3264 1
a3264 1
      frvfdpic_plt_section (dinfo->g.info)->_raw_size += size;
d3273 1
a3273 2
      if (entry->lzplt_entry % FRVFDPIC_LZPLT_BLOCK_SIZE
	  == FRVFDPIC_LZPLT_RESOLV_LOC)
d3287 1
a3287 1
_frvfdpic_resolve_final_relocs_info (void **entryp, void *p)
d3289 1
a3289 1
  struct frvfdpic_relocs_info *entry = *entryp;
d3295 1
a3295 1
      struct frvfdpic_relocs_info *oentry;
d3304 2
a3305 2
      oentry = frvfdpic_relocs_info_for_global (*htab, 0, h, entry->addend,
						NO_INSERT);
d3310 1
a3310 1
	  frvfdpic_pic_merge_early_relocs_info (oentry, entry);
d3339 2
a3340 2
elf32_frvfdpic_size_dynamic_sections (bfd *output_bfd,
				      struct bfd_link_info *info)
d3344 1
a3344 1
  struct _frvfdpic_dynamic_got_plt_info gpinfo;
d3368 1
a3368 1
      htab_t relocs = frvfdpic_relocs_info (info);
d3370 1
a3370 1
      htab_traverse (relocs, _frvfdpic_resolve_final_relocs_info, &relocs);
d3372 1
a3372 1
      if (relocs == frvfdpic_relocs_info (info))
d3376 1
a3376 1
  htab_traverse (frvfdpic_relocs_info (info), _frvfdpic_count_got_plt_entries,
d3395 25
a3419 25
  odd = _frvfdpic_compute_got_alloc_data (&gpinfo.got12,
					  0,
					  odd,
					  16,
					  gpinfo.g.got12,
					  gpinfo.g.fd12,
					  limit,
					  (bfd_vma)1 << (12-1));
  odd = _frvfdpic_compute_got_alloc_data (&gpinfo.gotlos,
					  gpinfo.got12.min,
					  odd,
					  gpinfo.got12.max,
					  gpinfo.g.gotlos,
					  gpinfo.g.fdlos,
					  gpinfo.g.fdplt - gpinfo.got12.fdplt,
					  (bfd_vma)1 << (16-1));
  odd = _frvfdpic_compute_got_alloc_data (&gpinfo.gothilo,
					  gpinfo.gotlos.min,
					  odd,
					  gpinfo.gotlos.max,
					  gpinfo.g.gothilo,
					  gpinfo.g.fdhilo,
					  gpinfo.g.fdplt - gpinfo.got12.fdplt
					  - gpinfo.gotlos.fdplt,
					  (bfd_vma)1 << (32-1));
d3422 1
a3422 2
  htab_traverse (frvfdpic_relocs_info (info), _frvfdpic_assign_got_entries,
		 &gpinfo);
d3424 1
a3424 2
  frvfdpic_got_section (info)->_raw_size = gpinfo.gothilo.max
    - gpinfo.gothilo.min
d3428 3
a3430 3
  if (frvfdpic_got_section (info)->_raw_size == 0)
    frvfdpic_got_section (info)->flags |= SEC_EXCLUDE;
  else if (frvfdpic_got_section (info)->_raw_size == 12
d3433 2
a3434 2
      frvfdpic_got_section (info)->flags |= SEC_EXCLUDE;
      frvfdpic_got_section (info)->_raw_size = 0;
d3438 3
a3440 4
      frvfdpic_got_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 frvfdpic_got_section (info)->_raw_size);
      if (frvfdpic_got_section (info)->contents == NULL)
d3447 1
a3447 1
    frvfdpic_gotrel_section (info)->_raw_size =
d3452 2
a3453 2
  if (frvfdpic_gotrel_section (info)->_raw_size == 0)
    frvfdpic_gotrel_section (info)->flags |= SEC_EXCLUDE;
d3456 3
a3458 4
      frvfdpic_gotrel_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 frvfdpic_gotrel_section (info)->_raw_size);
      if (frvfdpic_gotrel_section (info)->contents == NULL)
d3462 4
a3465 3
  frvfdpic_gotfixup_section (info)->_raw_size = (gpinfo.g.fixups + 1) * 4;
  if (frvfdpic_gotfixup_section (info)->_raw_size == 0)
    frvfdpic_gotfixup_section (info)->flags |= SEC_EXCLUDE;
d3468 1
a3468 1
      frvfdpic_gotfixup_section (info)->contents =
d3470 2
a3471 2
				 frvfdpic_gotfixup_section (info)->_raw_size);
      if (frvfdpic_gotfixup_section (info)->contents == NULL)
d3477 1
a3477 1
      frvfdpic_pltrel_section (info)->_raw_size =
d3479 2
a3480 2
      if (frvfdpic_pltrel_section (info)->_raw_size == 0)
	frvfdpic_pltrel_section (info)->flags |= SEC_EXCLUDE;
d3483 1
a3483 1
	  frvfdpic_pltrel_section (info)->contents =
d3485 2
a3486 3
				     frvfdpic_pltrel_section (info)
				     ->_raw_size);
	  if (frvfdpic_pltrel_section (info)->contents == NULL)
d3493 3
a3495 3
     call the resolver.  Since _frvfdpic_assign_got_entries didn't
     account for them, our block size is 4 bytes smaller than the real
     block size.  */
d3498 3
a3500 3
      frvfdpic_plt_section (info)->_raw_size = gpinfo.g.lzplt
	+ ((gpinfo.g.lzplt + (FRVFDPIC_LZPLT_BLOCK_SIZE - 4) - 8)
	   / (FRVFDPIC_LZPLT_BLOCK_SIZE - 4) * 4);
d3503 1
a3503 1
  /* Reset it, such that _frvfdpic_assign_plt_entries() can use it to
d3509 1
a3509 1
  frvfdpic_got_initial_offset (info) = -gpinfo.gothilo.min;
d3513 1
a3513 1
      += frvfdpic_got_initial_offset (info);
d3516 1
a3516 2
    frvfdpic_plt_initial_offset (info) =
      frvfdpic_plt_section (info)->_raw_size;
d3518 1
a3518 2
  htab_traverse (frvfdpic_relocs_info (info), _frvfdpic_assign_plt_entries,
		 &gpinfo);
d3521 1
a3521 1
     _frvfdpic_assign_plt_entries has a chance to add the size of the
d3525 2
a3526 2
      if (frvfdpic_plt_section (info)->_raw_size == 0)
	frvfdpic_plt_section (info)->flags |= SEC_EXCLUDE;
d3529 3
a3531 4
	  frvfdpic_plt_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj,
				     frvfdpic_plt_section (info)->_raw_size);
	  if (frvfdpic_plt_section (info)->contents == NULL)
d3538 1
a3538 1
      if (frvfdpic_got_section (info)->_raw_size)
d3542 1
a3542 1
      if (frvfdpic_pltrel_section (info)->_raw_size)
d3548 1
a3548 1
      if (frvfdpic_gotrel_section (info)->_raw_size)
d3560 2
a3561 2
elf32_frvfdpic_always_size_sections (bfd *output_bfd,
				     struct bfd_link_info *info)
d3563 2
a3564 1
  if (!info->relocatable)
d3606 2
a3607 2
elf32_frvfdpic_modify_segment_map (bfd *output_bfd,
				   struct bfd_link_info *info)
d3609 3
a3611 1
  struct elf_segment_map *m;
d3613 3
a3615 3
  for (m = elf_tdata (output_bfd)->segment_map; m != NULL; m = m->next)
    if (m->p_type == PT_GNU_STACK)
      break;
d3617 1
a3617 6
  if (m)
    {
      asection *sec = bfd_get_section_by_name (output_bfd, ".stack");
      struct elf_link_hash_entry *h;

      if (sec)
d3619 2
a3620 7
	  /* Obtain the pointer to the __stacksize symbol.  */
	  h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				    FALSE, FALSE, FALSE);
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *)h->root.u.i.link;
	  BFD_ASSERT (h->root.type == bfd_link_hash_defined);
d3622 16
a3637 6
	  /* Set the section size from the symbol value.  We
	     intentionally ignore the symbol section.  */
	  if (h->root.type == bfd_link_hash_defined)
	    sec->_raw_size = h->root.u.def.value;
	  else
	    sec->_raw_size = DEFAULT_STACK_SIZE;
d3639 6
a3644 5
	  /* Add the stack section to the PT_GNU_STACK segment,
	     such that its size and alignment requirements make it
	     to the segment.  */
	  m->sections[m->count] = sec;
	  m->count++;
d3654 2
a3655 10
elf32_frv_finish_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				   struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  /* Nothing to be done for non-FDPIC.  */
  return TRUE;
}

static bfd_boolean
elf32_frvfdpic_finish_dynamic_sections (bfd *output_bfd,
					struct bfd_link_info *info)
d3662 1
a3662 1
  if (frvfdpic_got_section (info))
d3664 2
a3665 2
      BFD_ASSERT (frvfdpic_gotrel_section (info)->_raw_size
		  == (frvfdpic_gotrel_section (info)->reloc_count
d3668 1
a3668 1
      if (frvfdpic_gotfixup_section (info))
d3670 1
a3670 10
	  struct elf_link_hash_entry *hgot = elf_hash_table (info)->hgot;
	  bfd_vma got_value = hgot->root.u.def.value
	    + hgot->root.u.def.section->output_section->vma
	    + hgot->root.u.def.section->output_offset;

	  _frvfdpic_add_rofixup (output_bfd, frvfdpic_gotfixup_section (info),
				 got_value, 0);

	  if (frvfdpic_gotfixup_section (info)->_raw_size
	      != (frvfdpic_gotfixup_section (info)->reloc_count * 4))
d3672 29
a3700 3
	      (*_bfd_error_handler)
		("LINKER BUG: .rofixup section size mismatch");
	      return FALSE;
d3706 2
a3707 2
      BFD_ASSERT (frvfdpic_pltrel_section (info)->_raw_size
		  == (frvfdpic_pltrel_section (info)->reloc_count
d3735 3
a3737 3
	      dyn.d_un.d_ptr = frvfdpic_got_section (info)->output_section->vma
		+ frvfdpic_got_section (info)->output_offset
		+ frvfdpic_got_initial_offset (info);
d3742 2
a3743 3
	      dyn.d_un.d_ptr = frvfdpic_pltrel_section (info)
		->output_section->vma
		+ frvfdpic_pltrel_section (info)->output_offset;
d3748 2
a3749 2
	      if (frvfdpic_pltrel_section (info)->_cooked_size != 0)
		dyn.d_un.d_val = frvfdpic_pltrel_section (info)->_cooked_size;
d3751 1
a3751 1
		dyn.d_un.d_val = frvfdpic_pltrel_section (info)->_raw_size;
d3765 2
a3766 3
elf32_frvfdpic_adjust_dynamic_symbol
(struct bfd_link_info *info ATTRIBUTE_UNUSED,
 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
d3799 4
a3802 5
elf32_frvfdpic_finish_dynamic_symbol
(bfd *output_bfd ATTRIBUTE_UNUSED,
 struct bfd_link_info *info ATTRIBUTE_UNUSED,
 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED,
 Elf_Internal_Sym *sym ATTRIBUTE_UNUSED)
d3811 3
a3813 4
frvfdpic_elf_use_relative_eh_frame
(bfd *input_bfd ATTRIBUTE_UNUSED,
 struct bfd_link_info *info ATTRIBUTE_UNUSED,
 asection *eh_frame_section ATTRIBUTE_UNUSED)
d3816 4
a3819 1
  return FALSE;
d3825 5
a3829 5
frvfdpic_elf_encode_eh_address (bfd *abfd,
				struct bfd_link_info *info,
				asection *osec, bfd_vma offset,
				asection *loc_sec, bfd_vma loc_offset,
				bfd_vma *encoded)
d3833 5
d3841 2
a3842 2
  if (! h || (_frvfdpic_osec_to_segment (abfd, osec)
	      == _frvfdpic_osec_to_segment (abfd, loc_sec->output_section)))
d3846 3
a3848 3
  BFD_ASSERT (_frvfdpic_osec_to_segment (abfd, osec)
	      == (_frvfdpic_osec_to_segment
		  (abfd, h->root.u.def.section->output_section)));
d3974 1
a3974 1
  struct frvfdpic_relocs_info *picrel;
d4000 2
a4015 9
	  if (! IS_FDPIC (abfd))
	    goto bad_reloc;
	  /* Fall through.  */
	case R_FRV_GPREL12:
	case R_FRV_GPRELU12:
	case R_FRV_GPRELHI:
	case R_FRV_GPRELLO:
	case R_FRV_LABEL24:
	case R_FRV_32:
a4021 5
	  if (! IS_FDPIC (abfd))
	    {
	      picrel = NULL;
	      break;
	    }
d4035 3
a4037 3
		= frvfdpic_relocs_info_for_global (frvfdpic_relocs_info (info),
						   abfd, h,
						   rel->r_addend, INSERT);
d4040 3
a4042 3
	    picrel = frvfdpic_relocs_info_for_local (frvfdpic_relocs_info
						     (info), abfd, r_symndx,
						     rel->r_addend, INSERT);
d4055 1
a4055 2
	  if (IS_FDPIC (abfd))
	    picrel->call = 1;
a4062 1

a4063 3
	  if (! IS_FDPIC (abfd))
	    break;

a4119 17

	case R_FRV_LABEL16:
	case R_FRV_LO16:
	case R_FRV_HI16:
	case R_FRV_GPREL12:
	case R_FRV_GPRELU12:
	case R_FRV_GPREL32:
	case R_FRV_GPRELHI:
	case R_FRV_GPRELLO:
	  break;

	default:
	bad_reloc:
	  (*_bfd_error_handler)
	    (_("%s: unsupported relocation type %i"),
	     bfd_archive_filename (abfd), ELF32_R_TYPE (rel->r_info));
	  return FALSE;
d4154 1
a4154 2
  return (((elf_elfheader (abfd)->e_flags & EF_FRV_FDPIC) != 0)
	  == (IS_FDPIC (abfd)));
a4439 14
  if (((new_flags & EF_FRV_FDPIC) == 0)
      != (! IS_FDPIC (ibfd)))
    {
      error = TRUE;
      if (IS_FDPIC (obfd))
	(*_bfd_error_handler)
	  (_("%s: cannot link non-fdpic object file into fdpic executable"),
	   bfd_get_filename (ibfd));
      else
	(*_bfd_error_handler)
	  (_("%s: cannot link fdpic object file into non-fdpic executable"),
	   bfd_get_filename (ibfd));
    }

d4535 1
d4553 1
a4553 29
#define elf_backend_want_got_sym	1
#define elf_backend_got_header_size	0
#define elf_backend_want_got_plt	0
#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_plt_header_size	0

#define elf_backend_finish_dynamic_sections \
		elf32_frv_finish_dynamic_sections

#include "elf32-target.h"

#undef ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE		0x4000

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM          bfd_elf32_frvfdpic_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME		"elf32-frvfdpic"
#undef	elf32_bed
#define	elf32_bed		elf32_frvfdpic_bed

#undef elf_info_to_howto_rel
#define elf_info_to_howto_rel	frvfdpic_info_to_howto_rel

#undef bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create \
		frvfdpic_elf_link_hash_table_create
#undef elf_backend_always_size_sections
d4555 1
a4555 2
		elf32_frvfdpic_always_size_sections
#undef elf_backend_modify_segment_map
d4557 1
a4557 1
		elf32_frvfdpic_modify_segment_map
a4558 1
#undef elf_backend_create_dynamic_sections
d4560 1
a4560 2
		elf32_frvfdpic_create_dynamic_sections
#undef elf_backend_adjust_dynamic_symbol
d4562 1
a4562 2
		elf32_frvfdpic_adjust_dynamic_symbol
#undef elf_backend_size_dynamic_sections
d4564 1
a4564 2
		elf32_frvfdpic_size_dynamic_sections
#undef elf_backend_finish_dynamic_symbol
d4566 1
a4566 2
		elf32_frvfdpic_finish_dynamic_symbol
#undef elf_backend_finish_dynamic_sections
d4568 8
a4575 1
		elf32_frvfdpic_finish_dynamic_sections
a4576 1
#undef elf_backend_can_make_relative_eh_frame
d4578 1
a4578 2
		frvfdpic_elf_use_relative_eh_frame
#undef elf_backend_can_make_lsda_relative_eh_frame
d4580 2
a4581 4
		frvfdpic_elf_use_relative_eh_frame
#undef elf_backend_encode_eh_address
#define elf_backend_encode_eh_address \
		frvfdpic_elf_encode_eh_address
a4582 1
#undef elf_backend_may_use_rel_p
a4583 1
#undef elf_backend_may_use_rela_p
a4585 1
#undef elf_backend_default_use_rela_p
@


1.12.4.5
log
@* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Return
immediately if there's no link info.
(elf32_frvfdpic_copy_private_bfd_data): New.
(bfd_elf32_bfd_copy_private_bfd_data): Use it for frvfdpic.
@
text
@a3688 5
  /* objcopy and strip preserve what's already there using
     elf32_frvfdpic_copy_private_bfd_data ().  */
  if (! info)
    return TRUE;

a4284 44
static bfd_boolean
elf32_frvfdpic_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  unsigned i;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  if (! frv_elf_copy_private_bfd_data (ibfd, obfd))
    return FALSE;

  if (! elf_tdata (ibfd) || ! elf_tdata (ibfd)->phdr
      || ! elf_tdata (obfd) || ! elf_tdata (obfd)->phdr)
    return TRUE;

  /* Copy the stack size.  */
  for (i = 0; i < elf_elfheader (ibfd)->e_phnum; i++)
    if (elf_tdata (ibfd)->phdr[i].p_type == PT_GNU_STACK)
      {
	Elf_Internal_Phdr *iphdr = &elf_tdata (ibfd)->phdr[i];

	for (i = 0; i < elf_elfheader (obfd)->e_phnum; i++)
	  if (elf_tdata (obfd)->phdr[i].p_type == PT_GNU_STACK)
	    {
	      memcpy (&elf_tdata (obfd)->phdr[i], iphdr, sizeof (*iphdr));

	      /* Rewrite the phdrs, since we're only called after they
		 were first written.  */
	      if (bfd_seek (obfd, (bfd_signed_vma) get_elf_backend_data (obfd)
			    ->s->sizeof_ehdr, SEEK_SET) != 0
		  || get_elf_backend_data (obfd)->s
		  ->write_out_phdrs (obfd, elf_tdata (obfd)->phdr,
				     elf_elfheader (obfd)->e_phnum) != 0)
		return FALSE;
	      break;
	    }

	break;
      }

  return TRUE;
}

a4696 3
#undef bfd_elf32_bfd_copy_private_bfd_data
#define bfd_elf32_bfd_copy_private_bfd_data \
		elf32_frvfdpic_copy_private_bfd_data
@


1.12.6.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004 Free Software Foundation, Inc.
a24 1
#include "elf/dwarf2.h"
d54 1
a54 1
  PARAMS (( bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d120 1
a120 1
	 complain_overflow_signed, /* complain_on_overflow */
d662 1
a750 4
  /* The number of .rofixups entries and dynamic relocations allocated
     for this symbol, minus any that might have already been used.  */
  unsigned fixups, dynrelocs;

d792 1
a792 2
			  const struct frv_pic_relocs_info *entry,
			  enum insert_option insert)
d795 1
a795 4
    (struct frv_pic_relocs_info **) htab_find_slot (ht, entry, insert);

  if (! loc)
    return NULL;
d821 1
a821 2
				bfd_vma addend,
				enum insert_option insert)
d829 1
a829 1
  return frv_pic_relocs_info_find (ht, abfd, &entry, insert);
d839 1
a839 2
			       bfd_vma addend,
			       enum insert_option insert)
d847 1
a847 53
  return frv_pic_relocs_info_find (ht, abfd, &entry, insert);
}

/* Merge fields set by check_relocs() of two entries that end up being
   mapped to the same (presumably global) symbol.  */

inline static void
frv_pic_merge_early_relocs_info (struct frv_pic_relocs_info *e2,
				 struct frv_pic_relocs_info const *e1)
{
  e2->got12 |= e1->got12;
  e2->gotlos |= e1->gotlos;
  e2->gothilo |= e1->gothilo;
  e2->fd |= e1->fd;
  e2->fdgot12 |= e1->fdgot12;
  e2->fdgotlos |= e1->fdgotlos;
  e2->fdgothilo |= e1->fdgothilo;
  e2->fdgoff12 |= e1->fdgoff12;
  e2->fdgofflos |= e1->fdgofflos;
  e2->fdgoffhilo |= e1->fdgoffhilo;
  e2->gotoff |= e1->gotoff;
  e2->call |= e1->call;
  e2->sym |= e1->sym;

#if 0
  /* These are set in _frv_count_got_plt_entries() or later, and this
     function is only called in _frv_resolve_final_relocs_info(), that
     runs just before it, so we don't have to worry about the fields
     below.  */

  e2->plt |= e1->plt;
  e2->privfd |= e1->privfd;
  e2->lazyplt |= e1->lazyplt;
  e2->done |= e1->done;

  e2->relocs32 += e1->relocs32;
  e2->relocsfd += e1->relocsfd;
  e2->relocsfdv += e1->relocsfdv;
  e2->fixups += e1->fixups;
  e2->dynrelocs += e1->dynrelocs;

  if (abs (e1->got_entry) < abs (e2->got_entry))
    e2->got_entry = e1->got_entry;
  if (abs (e1->fdgot_entry) < abs (e2->fdgot_entry))
    e2->fdgot_entry = e1->fdgot_entry;
  if (abs (e1->fd_entry) < abs (e2->fd_entry))
    e2->fd_entry = e1->fd_entry;

  if (e1->plt_entry < e2->plt_entry)
    e2->plt_entry = e1->plt_entry;
  if (e1->lzplt_entry < e2->lzplt_entry)
    e2->lzplt_entry = e1->lzplt_entry;
#endif
d862 1
a862 2
		    int reloc_type, long dynindx, bfd_vma addend,
		    struct frv_pic_relocs_info *entry)
a876 3
  BFD_ASSERT (entry->dynrelocs > 0);
  entry->dynrelocs--;

d883 1
a883 2
_frv_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset,
		  struct frv_pic_relocs_info *entry)
d897 1
a897 7

  if (entry)
    {
      BFD_ASSERT (entry->fixups > 0);
      entry->fixups--;
    }

d1002 2
a1003 2
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
d1008 1
a1008 1
			      + entry->got_entry, entry);
d1019 1
a1019 1
			    R_FRV_32, idx, ad, entry);
d1032 1
a1032 1
      bfd_vma ad = 0;
d1034 37
a1070 30
      if (! (entry->symndx == -1
	     && entry->d.h->root.type == bfd_link_hash_undefweak
	     && FRV_SYM_LOCAL (info, entry->d.h)))
	{
	  /* If the symbol is dynamic and there may be dynamic symbol
	     resolution because we are, or are linked with, a shared
	     library, emit a FUNCDESC relocation such that the dynamic
	     linker will allocate the function descriptor.  If the
	     symbol needs a non-local function descriptor but binds
	     locally (e.g., its visibility is protected, emit a
	     dynamic relocation decayed to section+offset.  */
	  if (entry->symndx == -1 && ! FRV_FUNCDESC_LOCAL (info, entry->d.h)
	      && FRV_SYM_LOCAL (info, entry->d.h)
	      && !(info->executable && !info->pie))
	    {
	      reloc = R_FRV_FUNCDESC;
	      idx = elf_section_data (entry->d.h->root.u.def.section
				      ->output_section)->dynindx;
	      ad = entry->d.h->root.u.def.section->output_offset
		+ entry->d.h->root.u.def.value;
	    }
	  else if (entry->symndx == -1
		   && ! FRV_FUNCDESC_LOCAL (info, entry->d.h))
	    {
	      reloc = R_FRV_FUNCDESC;
	      idx = dynindx;
	      ad = addend;
	      if (ad)
		return FALSE;
	    }
a1072 21
	      /* Otherwise, we know we have a private function descriptor,
		 so reference it directly.  */
	      if (elf_hash_table (info)->dynamic_sections_created)
		BFD_ASSERT (entry->privfd);
	      reloc = R_FRV_32;
	      idx = elf_section_data (frv_got_section (info)
				      ->output_section)->dynindx;
	      ad = frv_got_section (info)->output_offset
		+ frv_got_initial_offset (info) + entry->fd_entry;
	    }

	  /* If there is room for dynamic symbol resolution, emit the
	     dynamic relocation.  However, if we're linking an
	     executable at a fixed location, we won't have emitted a
	     dynamic symbol entry for the got section, so idx will be
	     zero, which means we can and should compute the address
	     of the private descriptor ourselves.  */
	  if (info->executable && !info->pie
	      && (entry->symndx != -1
		  || FRV_FUNCDESC_LOCAL (info, entry->d.h)))
	    {
d1078 1
a1078 1
				+ entry->fdgot_entry, entry);
a1079 10
	  else
	    _frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
				_bfd_elf_section_offset
				(output_bfd, info,
				 frv_got_section (info),
				 frv_got_initial_offset (info)
				 + entry->fdgot_entry)
				+ frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset,
				reloc, idx, ad, entry);
d1081 10
d1131 2
a1132 2
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
d1138 1
a1138 1
				+ entry->fd_entry, entry);
d1143 1
a1143 1
				+ entry->fd_entry + 4, entry);
d1159 1
a1159 1
				R_FRV_FUNCDESC_VALUE, idx, ad, entry);
d1874 3
a1876 1
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
d1883 1
a1883 3
		      input_section, rel->r_offset,
		      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		       || ELF_ST_VISIBILITY (h->other)))))
d1911 1
a1911 1
						     orig_addend, INSERT);
d1918 1
a1918 1
						    orig_addend, INSERT);
d2008 6
a2013 2
	    if (! (h && h->root.type == bfd_link_hash_undefweak
		   && FRV_SYM_LOCAL (info, h)))
d2015 1
a2015 11
		/* If the symbol is dynamic and there may be dynamic
		   symbol resolution because we are or are linked with a
		   shared library, emit a FUNCDESC relocation such that
		   the dynamic linker will allocate the function
		   descriptor.  If the symbol needs a non-local function
		   descriptor but binds locally (e.g., its visibility is
		   protected, emit a dynamic relocation decayed to
		   section+offset.  */
		if (h && ! FRV_FUNCDESC_LOCAL (info, h)
		    && FRV_SYM_LOCAL (info, h)
		    && !(info->executable && !info->pie))
d2017 4
a2020 27
		    dynindx = elf_section_data (h->root.u.def.section
						->output_section)->dynindx;
		    addend += h->root.u.def.section->output_offset
		      + h->root.u.def.value;
		  }
		else if (h && ! FRV_FUNCDESC_LOCAL (info, h))
		  {
		    if (addend)
		      {
			info->callbacks->warning
			  (info, _("R_FRV_FUNCDESC references dynamic symbol with nonzero addend"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    dynindx = h->dynindx;
		  }
		else
		  {
		    /* Otherwise, we know we have a private function
		       descriptor, so reference it directly.  */
		    BFD_ASSERT (picrel->privfd);
		    r_type = R_FRV_32;
		    dynindx = elf_section_data (frv_got_section	(info)
						->output_section)->dynindx;
		    addend = frv_got_section (info)->output_offset
		      + frv_got_initial_offset (info)
		      + picrel->fd_entry;
d2022 14
d2037 13
a2049 36
		/* If there is room for dynamic symbol resolution, emit
		   the dynamic relocation.  However, if we're linking an
		   executable at a fixed location, we won't have emitted a
		   dynamic symbol entry for the got section, so idx will
		   be zero, which means we can and should compute the
		   address of the private descriptor ourselves.  */
		if (info->executable && !info->pie
		    && (!h || FRV_FUNCDESC_LOCAL (info, h)))
		  {
		    addend += frv_got_section (info)->output_section->vma;
		    if ((bfd_get_section_flags (output_bfd,
						input_section->output_section)
			 & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		      {
			if (_frv_osec_readonly_p (output_bfd,
						  input_section->output_section))
			  {
			    info->callbacks->warning
			      (info,
			       _("cannot emit fixups in read-only section"),
			       name, input_bfd, input_section, rel->r_offset);
			    return FALSE;
			  }
			_frv_add_rofixup (output_bfd,
					  frv_gotfixup_section (info),
					  _bfd_elf_section_offset
					  (output_bfd, info,
					   input_section, rel->r_offset)
					  + input_section->output_section->vma
					  + input_section->output_offset,
					  picrel);
		      }
		  }
		else if ((bfd_get_section_flags (output_bfd,
						 input_section->output_section)
			  & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
d2056 1
a2056 1
			   _("cannot emit dynamic relocations in read-only section"),
d2060 3
a2062 1
		    _frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
d2067 15
a2081 2
					+ input_section->output_offset,
					r_type, dynindx, addend, picrel);
d2083 7
d2166 1
a2166 2
					  + input_section->output_offset,
					  picrel);
d2175 1
a2175 1
			     + input_section->output_offset + 4, picrel);
d2200 1
a2200 1
					r_type, dynindx, addend, picrel);
d2483 1
a2483 1
     Elf_Internal_Sym *sym;
a2779 1
  unsigned relocs = 0, fixups = 0;
d2836 1
a2836 1
    relocs = entry->relocs32 + entry->relocsfd + entry->relocsfdv;
d2842 2
a2843 2
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    fixups += entry->relocs32 + 2 * entry->relocsfdv;
d2846 1
a2846 2
	relocs += entry->relocs32 + entry->relocsfdv;

d2851 1
a2851 1
	    fixups += entry->relocsfd;
d2854 1
a2854 1
	relocs += entry->relocsfd;
a2856 5
  entry->dynrelocs += relocs;
  entry->fixups += fixups;
  dinfo->relocs += relocs;
  dinfo->fixups += fixups;

a3183 1
      struct frv_pic_relocs_info *oentry;
a3191 11
      oentry = frv_pic_relocs_info_for_global (*htab, 0, h, entry->addend,
					       NO_INSERT);

      if (oentry)
	{
	  /* Merge the two entries.  */
	  frv_pic_merge_early_relocs_info (oentry, entry);
	  htab_clear_slot (*htab, entryp);
	  return 1;
	}

d3416 1
a3416 1
	if (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0))
d3420 3
a3422 3
	if (!_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_REL)
	    || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))
d3426 4
a3429 4
	if (!_bfd_elf_add_dynamic_entry (info, DT_REL, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_RELSZ, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_RELENT,
					    sizeof (Elf32_External_Rel)))
d3555 1
a3555 1
				got_value, 0);
d3561 1
a3561 10
	      if (frv_gotfixup_section (info)->_raw_size
		  < frv_gotfixup_section (info)->reloc_count * 4)
		{
		  info->callbacks->warning
		    (info, "LINKER BUG: .rofixup section size mismatch",
		     ".rofixup", NULL, NULL, 0);
		  abort ();
		  return FALSE;
		}
	      else if (!elf_hash_table (info)->dynamic_sections_created)
a3674 51
/* Decide whether to attempt to turn absptr or lsda encodings in
   shared libraries into pcrel within the given input section.  */

static bfd_boolean
frv_elf_use_relative_eh_frame (bfd *input_bfd,
			       struct bfd_link_info *info ATTRIBUTE_UNUSED,
			       asection *eh_frame_section ATTRIBUTE_UNUSED)
{
  /* We can't use PC-relative encodings in FDPIC binaries, in general.  */
  if (elf_elfheader (input_bfd)->e_flags & EF_FRV_FDPIC)
    return FALSE;

  return TRUE;
}

/* Adjust the contents of an eh_frame_hdr section before they're output.  */

static bfd_byte
frv_elf_encode_eh_address (bfd *abfd,
			   struct bfd_link_info *info,
			   asection *osec, bfd_vma offset,
			   asection *loc_sec, bfd_vma loc_offset,
			   bfd_vma *encoded)
{
  struct elf_link_hash_entry *h;

  /* Non-FDPIC binaries can use PC-relative encodings.  */
  if (! (elf_elfheader (abfd)->e_flags & EF_FRV_FDPIC))
    return _bfd_elf_encode_eh_address (abfd, info, osec, offset,
				       loc_sec, loc_offset, encoded);

  h = elf_hash_table (info)->hgot;
  BFD_ASSERT (h && h->root.type == bfd_link_hash_defined);

  if (! h || (_frv_osec_to_segment (abfd, osec)
	      == _frv_osec_to_segment (abfd, loc_sec->output_section)))
    return _bfd_elf_encode_eh_address (abfd, info, osec, offset,
				       loc_sec, loc_offset, encoded);

  BFD_ASSERT (_frv_osec_to_segment (abfd, osec)
	      == _frv_osec_to_segment (abfd,
				       h->root.u.def.section->output_section));

  *encoded = osec->vma + offset
    - (h->root.u.def.value
       + h->root.u.def.section->output_section->vma
       + h->root.u.def.section->output_offset);

  return DW_EH_PE_datarel | DW_EH_PE_sdata4;
}

d3854 1
a3854 1
						  rel->r_addend, INSERT);
d3859 1
a3859 1
						    rel->r_addend, INSERT);
a3954 2
    case EF_FRV_CPU_FR450:  return bfd_mach_fr450;
    case EF_FRV_CPU_FR405:  return bfd_mach_fr400;
a4004 27
/* Return true if the architecture described by elf header flag
   EXTENSION is an extension of the architecture described by BASE.  */

static bfd_boolean
frv_elf_arch_extension_p (flagword base, flagword extension)
{
  if (base == extension)
    return TRUE;

  /* CPU_GENERIC code can be merged with code for a specific
     architecture, in which case the result is marked as being
     for the specific architecture.  Everything is therefore
     an extension of CPU_GENERIC.  */
  if (base == EF_FRV_CPU_GENERIC)
    return TRUE;

  if (extension == EF_FRV_CPU_FR450)
    if (base == EF_FRV_CPU_FR400 || base == EF_FRV_CPU_FR405)
      return TRUE;

  if (extension == EF_FRV_CPU_FR405)
    if (base == EF_FRV_CPU_FR400)
      return TRUE;

  return FALSE;
}

d4189 4
a4192 1
      if (frv_elf_arch_extension_p (new_partial, old_partial))
d4195 1
a4195 1
      else if (frv_elf_arch_extension_p (old_partial, new_partial))
a4206 2
	    case EF_FRV_CPU_FR450:   strcat (new_opt, " -mcpu=fr450");  break;
	    case EF_FRV_CPU_FR405:   strcat (new_opt, " -mcpu=fr405");  break;
a4218 2
	    case EF_FRV_CPU_FR450:   strcat (old_opt, " -mcpu=fr450");  break;
	    case EF_FRV_CPU_FR405:   strcat (old_opt, " -mcpu=fr405");  break;
a4285 2
    case EF_FRV_CPU_FR450:  fprintf (file, " -mcpu=fr450");	break;
    case EF_FRV_CPU_FR405:  fprintf (file, " -mcpu=fr405");	break;
a4392 6

#define elf_backend_can_make_relative_eh_frame \
		frv_elf_use_relative_eh_frame
#define elf_backend_can_make_lsda_relative_eh_frame \
		frv_elf_use_relative_eh_frame
#define elf_backend_encode_eh_address	frv_elf_encode_eh_address
@


1.12.6.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d2679 1
a2679 1
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2727 1
a2727 1
  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2782 1
a2782 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d4031 1
a4031 1
		    bfd_elf_link_record_dynamic_symbol (info, h);
d4110 1
a4110 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d4117 1
a4117 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.12.6.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a585 2
extern const bfd_target bfd_elf32_frvfdpic_vec;
#define IS_FDPIC(bfd) ((bfd)->xvec == &bfd_elf32_frvfdpic_vec)
d589 1
a589 1
struct frvfdpic_elf_link_hash_table
d615 2
a616 2
#define frvfdpic_hash_table(info) \
  ((struct frvfdpic_elf_link_hash_table *) ((info)->hash))
d618 16
a633 16
#define frvfdpic_got_section(info) \
  (frvfdpic_hash_table (info)->sgot)
#define frvfdpic_gotrel_section(info) \
  (frvfdpic_hash_table (info)->sgotrel)
#define frvfdpic_gotfixup_section(info) \
  (frvfdpic_hash_table (info)->sgotfixup)
#define frvfdpic_plt_section(info) \
  (frvfdpic_hash_table (info)->splt)
#define frvfdpic_pltrel_section(info) \
  (frvfdpic_hash_table (info)->spltrel)
#define frvfdpic_relocs_info(info) \
  (frvfdpic_hash_table (info)->relocs_info)
#define frvfdpic_got_initial_offset(info) \
  (frvfdpic_hash_table (info)->got0)
#define frvfdpic_plt_initial_offset(info) \
  (frvfdpic_hash_table (info)->plt0)
d638 1
a638 1
frvfdpic_elf_link_hash_table_create (bfd *abfd)
d640 2
a641 2
  struct frvfdpic_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct frvfdpic_elf_link_hash_table);
d660 1
a660 1
#define FRVFDPIC_SYM_LOCAL(INFO, H) \
d662 12
a673 2
   || ! elf_hash_table (INFO)->dynamic_sections_created)
#define FRVFDPIC_FUNCDESC_LOCAL(INFO, H) \
d679 1
a679 1
struct frvfdpic_relocs_info
d730 1
a730 1
     (call && symndx == -1 && ! FRVFDPIC_SYM_LOCAL (info, d.h))  */
d736 1
a736 1
          && (symndx != -1 || FRVFDPIC_FUNCDESC_LOCAL (info, d.h))))  */
d740 1
a740 1
     (privfd && symndx == -1 && ! FRVFDPIC_SYM_LOCAL (info, d.h)
d767 1
a767 1
/* Compute a hash with the key fields of an frvfdpic_relocs_info entry.  */
d769 1
a769 1
frvfdpic_relocs_info_hash (const void *entry_)
d771 1
a771 1
  const struct frvfdpic_relocs_info *entry = entry_;
d778 1
a778 1
/* Test whether the key fields of two frvfdpic_relocs_info entries are
d781 1
a781 1
frvfdpic_relocs_info_eq (const void *entry1, const void *entry2)
d783 2
a784 2
  const struct frvfdpic_relocs_info *e1 = entry1;
  const struct frvfdpic_relocs_info *e2 = entry2;
d793 5
a797 5
static struct frvfdpic_relocs_info *
frvfdpic_relocs_info_find (struct htab *ht,
			   bfd *abfd,
			   const struct frvfdpic_relocs_info *entry,
			   enum insert_option insert)
d799 2
a800 2
  struct frvfdpic_relocs_info **loc =
    (struct frvfdpic_relocs_info **) htab_find_slot (ht, entry, insert);
d825 6
a830 6
inline static struct frvfdpic_relocs_info *
frvfdpic_relocs_info_for_global (struct htab *ht,
				 bfd *abfd,
				 struct elf_link_hash_entry *h,
				 bfd_vma addend,
				 enum insert_option insert)
d832 1
a832 1
  struct frvfdpic_relocs_info entry;
d838 1
a838 1
  return frvfdpic_relocs_info_find (ht, abfd, &entry, insert);
d844 6
a849 6
inline static struct frvfdpic_relocs_info *
frvfdpic_relocs_info_for_local (struct htab *ht,
				bfd *abfd,
				long symndx,
				bfd_vma addend,
				enum insert_option insert)
d851 1
a851 1
  struct frvfdpic_relocs_info entry;
d857 1
a857 1
  return frvfdpic_relocs_info_find (ht, abfd, &entry, insert);
d864 2
a865 2
frvfdpic_pic_merge_early_relocs_info (struct frvfdpic_relocs_info *e2,
				      struct frvfdpic_relocs_info const *e1)
d882 2
a883 2
  /* These are set in _frvfdpic_count_got_plt_entries() or later, and this
     function is only called in _frvfdpic_resolve_final_relocs_info(), that
d917 2
a918 2
#define FRVFDPIC_LZPLT_BLOCK_SIZE ((bfd_vma) 8 * 65535 + 4)
#define FRVFDPIC_LZPLT_RESOLV_LOC (8 * 32767)
d923 3
a925 3
_frvfdpic_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
			 int reloc_type, long dynindx, bfd_vma addend,
			 struct frvfdpic_relocs_info *entry)
d935 1
a935 1
  BFD_ASSERT (reloc_offset < sreloc->size);
d940 2
a941 12
  /* If the entry's index is zero, this relocation was probably to a
     linkonce section that got discarded.  We reserved a dynamic
     relocation, but it was for another entry than the one we got at
     the time of emitting the relocation.  Unfortunately there's no
     simple way for us to catch this situation, since the relocation
     is cleared right before calling relocate_section, at which point
     we no longer know what the relocation used to point to.  */
  if (entry->symndx)
    {
      BFD_ASSERT (entry->dynrelocs > 0);
      entry->dynrelocs--;
    }
d949 2
a950 2
_frvfdpic_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset,
		       struct frvfdpic_relocs_info *entry)
d960 1
a960 1
      BFD_ASSERT (fixup_offset < rofixup->size);
d965 1
a965 1
  if (entry && entry->symndx)
a966 2
      /* See discussion about symndx == 0 in _frvfdpic_add_dyn_reloc
	 above.  */
d978 1
a978 1
_frvfdpic_osec_to_segment (bfd *output_bfd, asection *osec)
d1003 1
a1003 1
_frvfdpic_osec_readonly_p (bfd *output_bfd, asection *osec)
d1005 1
a1005 1
  unsigned seg = _frvfdpic_osec_to_segment (output_bfd, osec);
d1014 6
a1019 6
_frvfdpic_emit_got_relocs_plt_entries (struct frvfdpic_relocs_info *entry,
				       bfd *output_bfd,
				       struct bfd_link_info *info,
				       asection *sec,
				       Elf_Internal_Sym *sym,
				       bfd_vma addend)
d1054 1
a1054 2
      if (sec && (entry->symndx != -1
		  || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
d1071 1
a1071 2
	  && (entry->symndx != -1
	      || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
d1077 16
a1092 19
	    _frvfdpic_add_rofixup (output_bfd,
				   frvfdpic_gotfixup_section (info),
				   frvfdpic_got_section (info)->output_section
				   ->vma
				   + frvfdpic_got_section (info)->output_offset
				   + frvfdpic_got_initial_offset (info)
				   + entry->got_entry, entry);
	}
      else
	_frvfdpic_add_dyn_reloc (output_bfd, frvfdpic_gotrel_section (info),
				 _bfd_elf_section_offset
				 (output_bfd, info,
				  frvfdpic_got_section (info),
				  frvfdpic_got_initial_offset (info)
				  + entry->got_entry)
				 + frvfdpic_got_section (info)
				 ->output_section->vma
				 + frvfdpic_got_section (info)->output_offset,
				 R_FRV_32, idx, ad, entry);
d1095 2
a1096 2
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
d1109 1
a1109 1
	     && FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
d1118 2
a1119 3
	  if (entry->symndx == -1
	      && ! FRVFDPIC_FUNCDESC_LOCAL (info, entry->d.h)
	      && FRVFDPIC_SYM_LOCAL (info, entry->d.h)
d1129 1
a1129 1
		   && ! FRVFDPIC_FUNCDESC_LOCAL (info, entry->d.h))
d1144 1
a1144 1
	      idx = elf_section_data (frvfdpic_got_section (info)
d1146 2
a1147 2
	      ad = frvfdpic_got_section (info)->output_offset
		+ frvfdpic_got_initial_offset (info) + entry->fd_entry;
d1158 1
a1158 1
		  || FRVFDPIC_FUNCDESC_LOCAL (info, entry->d.h)))
d1160 6
a1165 9
	      ad += frvfdpic_got_section (info)->output_section->vma;
	      _frvfdpic_add_rofixup (output_bfd,
				     frvfdpic_gotfixup_section (info),
				     frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset
				     + frvfdpic_got_initial_offset (info)
				     + entry->fdgot_entry, entry);
d1168 9
a1176 12
	    _frvfdpic_add_dyn_reloc (output_bfd,
				     frvfdpic_gotrel_section (info),
				     _bfd_elf_section_offset
				     (output_bfd, info,
				      frvfdpic_got_section (info),
				      frvfdpic_got_initial_offset (info)
				      + entry->fdgot_entry)
				     + frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset,
				     reloc, idx, ad, entry);
d1180 2
a1181 2
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
d1196 1
a1196 2
      if (sec && (entry->symndx != -1
		  || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
d1213 1
a1213 1
	  && (entry->symndx != -1 || FRVFDPIC_SYM_LOCAL (info, entry->d.h)))
d1221 10
a1230 16
	      _frvfdpic_add_rofixup (output_bfd,
				     frvfdpic_gotfixup_section (info),
				     frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset
				     + frvfdpic_got_initial_offset (info)
				     + entry->fd_entry, entry);
	      _frvfdpic_add_rofixup (output_bfd,
				     frvfdpic_gotfixup_section (info),
				     frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset
				     + frvfdpic_got_initial_offset (info)
				     + entry->fd_entry + 4, entry);
d1236 11
a1246 14
	    _frvfdpic_add_dyn_reloc (output_bfd,
				     entry->lazyplt
				     ? frvfdpic_pltrel_section (info)
				     : frvfdpic_gotrel_section (info),
				     _bfd_elf_section_offset
				     (output_bfd, info,
				      frvfdpic_got_section (info),
				      frvfdpic_got_initial_offset (info)
				      + entry->fd_entry)
				     + frvfdpic_got_section (info)
				     ->output_section->vma
				     + frvfdpic_got_section (info)
				     ->output_offset,
				     R_FRV_FUNCDESC_VALUE, idx, ad, entry);
d1254 3
a1256 3
	  highword = frvfdpic_got_section (info)->output_section->vma
	    + frvfdpic_got_section (info)->output_offset
	    + frvfdpic_got_initial_offset (info);
d1272 4
a1275 4
	    + frvfdpic_plt_section (info)->output_offset
	    + frvfdpic_plt_section (info)->output_section->vma;
	  highword = _frvfdpic_osec_to_segment 
	    (output_bfd, frvfdpic_plt_section (info)->output_section);
d1287 1
a1287 2
	    highword = _frvfdpic_osec_to_segment
	      (output_bfd, sec->output_section);
d1291 2
a1292 2
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
d1295 2
a1296 2
		  frvfdpic_got_section (info)->contents
		  + frvfdpic_got_initial_offset (info)
d1303 1
a1303 2
      bfd_byte *plt_code = frvfdpic_plt_section (info)->contents
	+ entry->plt_entry;
d1356 1
a1356 1
      bfd_byte *lzplt_code = frvfdpic_plt_section (info)->contents
d1363 4
a1366 4
      resolverStub_addr = entry->lzplt_entry / FRVFDPIC_LZPLT_BLOCK_SIZE
	* FRVFDPIC_LZPLT_BLOCK_SIZE + FRVFDPIC_LZPLT_RESOLV_LOC;
      if (resolverStub_addr >= frvfdpic_plt_initial_offset (info))
	resolverStub_addr = frvfdpic_plt_initial_offset (info) - 12;
d1770 2
a1771 2
frvfdpic_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
			    arelent *cache_ptr, Elf_Internal_Rela *dst)
d1872 6
a1877 6
  isec_segment = _frvfdpic_osec_to_segment (output_bfd,
					    input_section->output_section);
  if (IS_FDPIC (output_bfd) && frvfdpic_got_section (info))
    got_segment = _frvfdpic_osec_to_segment (output_bfd,
					     frvfdpic_got_section (info)
					     ->output_section);
d1880 4
a1883 4
  if (IS_FDPIC (output_bfd) && frvfdpic_gotfixup_section (info))
    gprel_segment = _frvfdpic_osec_to_segment (output_bfd,
					       frvfdpic_gotfixup_section (info)
					       ->output_section);
d1886 4
a1889 4
  if (IS_FDPIC (output_bfd) && elf_hash_table (info)->dynamic_sections_created)
    plt_segment = _frvfdpic_osec_to_segment (output_bfd,
					     frvfdpic_plt_section (info)
					     ->output_section);
d1905 1
a1905 1
      struct frvfdpic_relocs_info *picrel;
d1943 1
a1943 1
	      && ! FRVFDPIC_SYM_LOCAL (info, h))
a1980 3
	  if (! IS_FDPIC (output_bfd))
	    goto non_fdpic;

d1996 3
a1998 3
	    picrel = frvfdpic_relocs_info_for_global (frvfdpic_relocs_info
						      (info), input_bfd, h,
						      orig_addend, INSERT);
d2003 3
a2005 3
	    picrel = frvfdpic_relocs_info_for_local (frvfdpic_relocs_info
						     (info), input_bfd, r_symndx,
						     orig_addend, INSERT);
d2009 2
a2010 3
	  if (!_frvfdpic_emit_got_relocs_plt_entries (picrel, output_bfd, info,
						      osec, sym,
						      rel->r_addend))
d2012 3
a2014 3
	      (*_bfd_error_handler)
		(_("%B: relocation at `%A+0x%x' references symbol `%s' with nonzero addend"),
		 input_bfd, input_section, rel->r_offset, name);
a2021 1
	non_fdpic:
d2023 1
a2023 1
	  if (h && ! FRVFDPIC_SYM_LOCAL (info, h))
d2037 1
a2037 3
	  if (! IS_FDPIC (output_bfd))
	    check_segment[1] = isec_segment;
	  else if (picrel->plt)
d2039 2
a2040 2
	      relocation = frvfdpic_plt_section (info)->output_section->vma
		+ frvfdpic_plt_section (info)->output_offset
d2053 1
a2053 1
	      ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
d2074 3
a2076 3
	  relocation -= frvfdpic_got_section (info)->output_section->vma
	    + frvfdpic_got_section (info)->output_offset
	    + frvfdpic_got_initial_offset (info);
d2079 1
a2079 1
	    ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
d2096 1
a2096 1
		   && FRVFDPIC_SYM_LOCAL (info, h)))
d2106 2
a2107 2
		if (h && ! FRVFDPIC_FUNCDESC_LOCAL (info, h)
		    && FRVFDPIC_SYM_LOCAL (info, h)
d2115 1
a2115 1
		else if (h && ! FRVFDPIC_FUNCDESC_LOCAL (info, h))
d2132 1
a2132 1
		    dynindx = elf_section_data (frvfdpic_got_section (info)
d2134 2
a2135 2
		    addend = frvfdpic_got_section (info)->output_offset
		      + frvfdpic_got_initial_offset (info)
d2146 1
a2146 1
		    && (!h || FRVFDPIC_FUNCDESC_LOCAL (info, h)))
d2148 1
a2148 1
		    addend += frvfdpic_got_section (info)->output_section->vma;
d2153 2
a2154 3
			if (_frvfdpic_osec_readonly_p (output_bfd,
						       input_section
						       ->output_section))
d2162 8
a2169 10
			_frvfdpic_add_rofixup (output_bfd,
					       frvfdpic_gotfixup_section
					       (info),
					       _bfd_elf_section_offset
					       (output_bfd, info,
						input_section, rel->r_offset)
					       + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       picrel);
d2176 2
a2177 3
		    if (_frvfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
d2185 7
a2191 9
		    _frvfdpic_add_dyn_reloc (output_bfd,
					     frvfdpic_gotrel_section (info),
					     _bfd_elf_section_offset
					     (output_bfd, info,
					      input_section, rel->r_offset)
					     + input_section
					     ->output_section->vma
					     + input_section->output_offset,
					     r_type, dynindx, addend, picrel);
a2192 2
		else
		  addend += frvfdpic_got_section (info)->output_section->vma;
a2203 6
	  if (! IS_FDPIC (output_bfd))
	    {
	      check_segment[0] = check_segment[1] = -1;
	      break;
	    }
	  /* Fall through.  */
d2211 1
a2211 1
	    if (h && ! FRVFDPIC_SYM_LOCAL (info, h))
d2243 1
a2243 1
		&& (!h || FRVFDPIC_SYM_LOCAL (info, h)))
d2247 1
a2247 1
		if (IS_FDPIC (input_bfd)
d2252 2
a2253 3
		    if (_frvfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
d2263 8
a2270 10
			_frvfdpic_add_rofixup (output_bfd,
					       frvfdpic_gotfixup_section
					       (info),
					       _bfd_elf_section_offset
					       (output_bfd, info,
						input_section, rel->r_offset)
					       + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       picrel);
d2272 1
a2272 1
			  _frvfdpic_add_rofixup
d2274 1
a2274 1
			     frvfdpic_gotfixup_section (info),
d2289 2
a2290 3
		    if (_frvfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
d2298 7
a2304 9
		    _frvfdpic_add_dyn_reloc (output_bfd,
					     frvfdpic_gotrel_section (info),
					     _bfd_elf_section_offset
					     (output_bfd, info,
					      input_section, rel->r_offset)
					     + input_section
					     ->output_section->vma
					     + input_section->output_offset,
					     r_type, dynindx, addend, picrel);
a2305 2
		else if (osec)
		  addend += osec->output_section->vma;
d2318 1
a2318 1
		    && (!h || FRVFDPIC_SYM_LOCAL (info, h)))
d2320 3
a2322 3
			      frvfdpic_got_section (info)->output_section->vma
			      + frvfdpic_got_section (info)->output_offset
			      + frvfdpic_got_initial_offset (info),
d2332 1
a2332 1
			      h && ! FRVFDPIC_SYM_LOCAL (info, h)
d2334 2
a2335 3
			      : _frvfdpic_osec_to_segment (output_bfd,
							   sec
							   ->output_section),
d2349 1
a2349 1
	    ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
d2356 1
a2356 1
	    ? _frvfdpic_osec_to_segment (output_bfd, sec->output_section)
d2361 2
a2362 1
      if (check_segment[0] != check_segment[1] && IS_FDPIC (output_bfd))
d2364 1
a2364 2
#if 1 /* If you take this out, remove the #error from fdpic-static-6.d
	 in the ld testsuite.  */
d2421 1
a2421 1
	  if (! IS_FDPIC (output_bfd) || ! picrel->plt)
d2618 1
a2618 26

/* We need dynamic symbols for every section, since segments can
   relocate independently.  */
static bfd_boolean
_frvfdpic_link_omit_section_dynsym (bfd *output_bfd ATTRIBUTE_UNUSED,
				    struct bfd_link_info *info
				    ATTRIBUTE_UNUSED,
				    asection *p ATTRIBUTE_UNUSED)
{
  switch (elf_section_data (p)->this_hdr.sh_type)
    {
    case SHT_PROGBITS:
    case SHT_NOBITS:
      /* If sh_type is yet undecided, assume it could be
	 SHT_PROGBITS/SHT_NOBITS.  */
    case SHT_NULL:
      return FALSE;

      /* There shouldn't be section relative relocations
	 against any other section.  */
    default:
      return TRUE;
    }
}

/* Create  a .got section, as well as its additional info field.  This
a2630 1
  int offset;
d2686 1
a2686 1
  s->size += bed->got_header_size + bed->got_symbol_offset;
d2690 6
a2695 8
  if (IS_FDPIC (abfd))
    {
      frvfdpic_got_section (info) = s;
      frvfdpic_relocs_info (info) = htab_try_create (1, frvfdpic_relocs_info_hash,
						     frvfdpic_relocs_info_eq,
						     (htab_del) NULL);
      if (! frvfdpic_relocs_info (info))
	return FALSE;
d2697 5
a2701 5
      s = bfd_make_section (abfd, ".rel.got");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;
d2703 1
a2703 1
      frvfdpic_gotrel_section (info) = s;
d2705 6
a2710 6
      /* Machine-specific.  */
      s = bfd_make_section (abfd, ".rofixup");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;
d2712 1
a2712 9
      frvfdpic_gotfixup_section (info) = s;
      offset = -2048;
      flags = BSF_GLOBAL;
    }
  else
    {
      offset = 2048;
      flags = BSF_GLOBAL | BSF_WEAK;
    }
d2714 3
a2716 3
  /* Define _gp in .rofixup, for FDPIC, or .got otherwise.  If it
     turns out that we're linking with a different linker script, the
     linker script will override it.  */
d2719 1
a2719 1
	(info, abfd, "_gp", flags, s, offset, (const char *) NULL, FALSE,
d2727 1
a2727 1
  if (IS_FDPIC (abfd) && ! bfd_elf_link_record_dynamic_symbol (info, h))
d2729 1
a2729 1

d2737 1
a2737 1
elf32_frvfdpic_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d2764 1
a2764 1
  frvfdpic_plt_section (info) = s;
d2793 1
a2793 1
  frvfdpic_pltrel_section (info) = s;
d2800 3
a2802 4
  BFD_ASSERT (frvfdpic_got_section (info) && frvfdpic_gotrel_section (info)
	      && frvfdpic_gotfixup_section (info)
	      && frvfdpic_plt_section (info)
	      && frvfdpic_pltrel_section (info));
d2852 1
a2852 1
struct _frvfdpic_dynamic_got_info
d2880 1
a2880 1
_frvfdpic_count_got_plt_entries (void **entryp, void *dinfo_)
d2882 2
a2883 2
  struct frvfdpic_relocs_info *entry = *entryp;
  struct _frvfdpic_dynamic_got_info *dinfo = dinfo_;
d2912 1
a2912 1
    && entry->symndx == -1 && ! FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)
d2918 1
a2918 1
	    || FRVFDPIC_FUNCDESC_LOCAL (dinfo->info, entry->d.h)));
d2920 1
a2920 1
    && entry->symndx == -1 && ! FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)
d2944 1
a2944 1
      if (entry->symndx != -1 || FRVFDPIC_SYM_LOCAL (dinfo->info, entry->d.h))
d2953 1
a2953 2
      if (entry->symndx != -1
	  || FRVFDPIC_FUNCDESC_LOCAL (dinfo->info, entry->d.h))
d2974 1
a2974 1
struct _frvfdpic_dynamic_got_plt_info
d2976 2
a2977 2
  /* Summary information collected with _frvfdpic_count_got_plt_entries.  */
  struct _frvfdpic_dynamic_got_info g;
d2993 1
a2993 1
  struct _frvfdpic_dynamic_got_alloc_data
d3011 8
a3018 8
_frvfdpic_compute_got_alloc_data (struct _frvfdpic_dynamic_got_alloc_data *gad,
				  bfd_signed_vma fdcur,
				  bfd_signed_vma odd,
				  bfd_signed_vma cur,
				  bfd_vma got,
				  bfd_vma fd,
				  bfd_vma fdplt,
				  bfd_vma wrap)
d3112 1
a3112 1
  /* _frvfdpic_get_got_entry() below will always wrap gad->cur if needed
d3126 1
a3126 1
_frvfdpic_get_got_entry (struct _frvfdpic_dynamic_got_alloc_data *gad)
d3155 1
a3155 1
_frvfdpic_get_fd_entry (struct _frvfdpic_dynamic_got_alloc_data *gad)
d3168 1
a3168 1
_frvfdpic_assign_got_entries (void **entryp, void *info_)
d3170 2
a3171 2
  struct frvfdpic_relocs_info *entry = *entryp;
  struct _frvfdpic_dynamic_got_plt_info *dinfo = info_;
d3174 1
a3174 1
    entry->got_entry = _frvfdpic_get_got_entry (&dinfo->got12);
d3176 1
a3176 1
    entry->got_entry = _frvfdpic_get_got_entry (&dinfo->gotlos);
d3178 1
a3178 1
    entry->got_entry = _frvfdpic_get_got_entry (&dinfo->gothilo);
d3181 1
a3181 1
    entry->fdgot_entry = _frvfdpic_get_got_entry (&dinfo->got12);
d3183 1
a3183 1
    entry->fdgot_entry = _frvfdpic_get_got_entry (&dinfo->gotlos);
d3185 1
a3185 1
    entry->fdgot_entry = _frvfdpic_get_got_entry (&dinfo->gothilo);
d3188 1
a3188 1
    entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->got12);
d3192 1
a3192 1
      entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->got12);
d3195 1
a3195 1
    entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gotlos);
d3199 1
a3199 1
      entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gotlos);
d3204 1
a3204 1
      entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gothilo);
d3207 1
a3207 1
    entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gothilo);
d3217 1
a3217 1
_frvfdpic_assign_plt_entries (void **entryp, void *info_)
d3219 2
a3220 2
  struct frvfdpic_relocs_info *entry = *entryp;
  struct _frvfdpic_dynamic_got_plt_info *dinfo = info_;
d3228 1
a3228 1
	  entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->got12);
d3233 1
a3233 1
	  entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gotlos);
d3239 1
a3239 1
	  entry->fd_entry = _frvfdpic_get_fd_entry (&dinfo->gothilo);
d3250 1
a3250 1
      entry->plt_entry = frvfdpic_plt_section (dinfo->g.info)->size;
d3264 1
a3264 1
      frvfdpic_plt_section (dinfo->g.info)->size += size;
d3273 1
a3273 2
      if (entry->lzplt_entry % FRVFDPIC_LZPLT_BLOCK_SIZE
	  == FRVFDPIC_LZPLT_RESOLV_LOC)
d3287 1
a3287 1
_frvfdpic_resolve_final_relocs_info (void **entryp, void *p)
d3289 1
a3289 1
  struct frvfdpic_relocs_info *entry = *entryp;
d3295 1
a3295 1
      struct frvfdpic_relocs_info *oentry;
d3304 2
a3305 2
      oentry = frvfdpic_relocs_info_for_global (*htab, 0, h, entry->addend,
						NO_INSERT);
d3310 1
a3310 1
	  frvfdpic_pic_merge_early_relocs_info (oentry, entry);
d3339 2
a3340 2
elf32_frvfdpic_size_dynamic_sections (bfd *output_bfd,
				      struct bfd_link_info *info)
d3344 1
a3344 1
  struct _frvfdpic_dynamic_got_plt_info gpinfo;
d3358 1
a3358 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d3368 1
a3368 1
      htab_t relocs = frvfdpic_relocs_info (info);
d3370 1
a3370 1
      htab_traverse (relocs, _frvfdpic_resolve_final_relocs_info, &relocs);
d3372 1
a3372 1
      if (relocs == frvfdpic_relocs_info (info))
d3376 1
a3376 1
  htab_traverse (frvfdpic_relocs_info (info), _frvfdpic_count_got_plt_entries,
d3395 25
a3419 25
  odd = _frvfdpic_compute_got_alloc_data (&gpinfo.got12,
					  0,
					  odd,
					  16,
					  gpinfo.g.got12,
					  gpinfo.g.fd12,
					  limit,
					  (bfd_vma)1 << (12-1));
  odd = _frvfdpic_compute_got_alloc_data (&gpinfo.gotlos,
					  gpinfo.got12.min,
					  odd,
					  gpinfo.got12.max,
					  gpinfo.g.gotlos,
					  gpinfo.g.fdlos,
					  gpinfo.g.fdplt - gpinfo.got12.fdplt,
					  (bfd_vma)1 << (16-1));
  odd = _frvfdpic_compute_got_alloc_data (&gpinfo.gothilo,
					  gpinfo.gotlos.min,
					  odd,
					  gpinfo.gotlos.max,
					  gpinfo.g.gothilo,
					  gpinfo.g.fdhilo,
					  gpinfo.g.fdplt - gpinfo.got12.fdplt
					  - gpinfo.gotlos.fdplt,
					  (bfd_vma)1 << (32-1));
d3422 1
a3422 2
  htab_traverse (frvfdpic_relocs_info (info), _frvfdpic_assign_got_entries,
		 &gpinfo);
d3424 1
a3424 2
  frvfdpic_got_section (info)->size = gpinfo.gothilo.max
    - gpinfo.gothilo.min
d3428 3
a3430 3
  if (frvfdpic_got_section (info)->size == 0)
    frvfdpic_got_section (info)->flags |= SEC_EXCLUDE;
  else if (frvfdpic_got_section (info)->size == 12
d3433 2
a3434 2
      frvfdpic_got_section (info)->flags |= SEC_EXCLUDE;
      frvfdpic_got_section (info)->size = 0;
d3438 3
a3440 4
      frvfdpic_got_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 frvfdpic_got_section (info)->size);
      if (frvfdpic_got_section (info)->contents == NULL)
d3447 1
a3447 1
    frvfdpic_gotrel_section (info)->size =
d3452 2
a3453 2
  if (frvfdpic_gotrel_section (info)->size == 0)
    frvfdpic_gotrel_section (info)->flags |= SEC_EXCLUDE;
d3456 3
a3458 4
      frvfdpic_gotrel_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 frvfdpic_gotrel_section (info)->size);
      if (frvfdpic_gotrel_section (info)->contents == NULL)
d3462 4
a3465 3
  frvfdpic_gotfixup_section (info)->size = (gpinfo.g.fixups + 1) * 4;
  if (frvfdpic_gotfixup_section (info)->size == 0)
    frvfdpic_gotfixup_section (info)->flags |= SEC_EXCLUDE;
d3468 1
a3468 1
      frvfdpic_gotfixup_section (info)->contents =
d3470 2
a3471 2
				 frvfdpic_gotfixup_section (info)->size);
      if (frvfdpic_gotfixup_section (info)->contents == NULL)
d3477 1
a3477 1
      frvfdpic_pltrel_section (info)->size =
d3479 2
a3480 2
      if (frvfdpic_pltrel_section (info)->size == 0)
	frvfdpic_pltrel_section (info)->flags |= SEC_EXCLUDE;
d3483 1
a3483 1
	  frvfdpic_pltrel_section (info)->contents =
d3485 2
a3486 2
				     frvfdpic_pltrel_section (info)->size);
	  if (frvfdpic_pltrel_section (info)->contents == NULL)
d3493 3
a3495 3
     call the resolver.  Since _frvfdpic_assign_got_entries didn't
     account for them, our block size is 4 bytes smaller than the real
     block size.  */
d3498 3
a3500 3
      frvfdpic_plt_section (info)->size = gpinfo.g.lzplt
	+ ((gpinfo.g.lzplt + (FRVFDPIC_LZPLT_BLOCK_SIZE - 4) - 8)
	   / (FRVFDPIC_LZPLT_BLOCK_SIZE - 4) * 4);
d3503 1
a3503 1
  /* Reset it, such that _frvfdpic_assign_plt_entries() can use it to
d3509 1
a3509 1
  frvfdpic_got_initial_offset (info) = -gpinfo.gothilo.min;
d3513 1
a3513 1
      += frvfdpic_got_initial_offset (info);
d3516 1
a3516 2
    frvfdpic_plt_initial_offset (info) =
      frvfdpic_plt_section (info)->size;
d3518 1
a3518 2
  htab_traverse (frvfdpic_relocs_info (info), _frvfdpic_assign_plt_entries,
		 &gpinfo);
d3521 1
a3521 1
     _frvfdpic_assign_plt_entries has a chance to add the size of the
d3525 2
a3526 2
      if (frvfdpic_plt_section (info)->size == 0)
	frvfdpic_plt_section (info)->flags |= SEC_EXCLUDE;
d3529 3
a3531 4
	  frvfdpic_plt_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj,
				     frvfdpic_plt_section (info)->size);
	  if (frvfdpic_plt_section (info)->contents == NULL)
d3538 1
a3538 1
      if (frvfdpic_got_section (info)->size)
d3542 1
a3542 1
      if (frvfdpic_pltrel_section (info)->size)
d3548 1
a3548 1
      if (frvfdpic_gotrel_section (info)->size)
d3560 2
a3561 2
elf32_frvfdpic_always_size_sections (bfd *output_bfd,
				     struct bfd_link_info *info)
d3563 2
a3564 1
  if (!info->relocatable)
d3606 2
a3607 2
elf32_frvfdpic_modify_segment_map (bfd *output_bfd,
				   struct bfd_link_info *info)
d3609 3
a3611 1
  struct elf_segment_map *m;
d3613 3
a3615 13
  /* objcopy and strip preserve what's already there using
     elf32_frvfdpic_copy_private_bfd_data ().  */
  if (! info)
    return TRUE;

  for (m = elf_tdata (output_bfd)->segment_map; m != NULL; m = m->next)
    if (m->p_type == PT_GNU_STACK)
      break;

  if (m)
    {
      asection *sec = bfd_get_section_by_name (output_bfd, ".stack");
      struct elf_link_hash_entry *h;
d3617 1
a3617 1
      if (sec)
d3619 2
a3620 7
	  /* Obtain the pointer to the __stacksize symbol.  */
	  h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				    FALSE, FALSE, FALSE);
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *)h->root.u.i.link;
	  BFD_ASSERT (h->root.type == bfd_link_hash_defined);
d3622 23
a3644 12
	  /* Set the section size from the symbol value.  We
	     intentionally ignore the symbol section.  */
	  if (h->root.type == bfd_link_hash_defined)
	    sec->size = h->root.u.def.value;
	  else
	    sec->size = DEFAULT_STACK_SIZE;

	  /* Add the stack section to the PT_GNU_STACK segment,
	     such that its size and alignment requirements make it
	     to the segment.  */
	  m->sections[m->count] = sec;
	  m->count++;
d3654 2
a3655 10
elf32_frv_finish_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				   struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  /* Nothing to be done for non-FDPIC.  */
  return TRUE;
}

static bfd_boolean
elf32_frvfdpic_finish_dynamic_sections (bfd *output_bfd,
					struct bfd_link_info *info)
d3662 1
a3662 1
  if (frvfdpic_got_section (info))
d3664 2
a3665 2
      BFD_ASSERT (frvfdpic_gotrel_section (info)->size
		  == (frvfdpic_gotrel_section (info)->reloc_count
d3668 1
a3668 1
      if (frvfdpic_gotfixup_section (info))
d3670 1
a3670 10
	  struct elf_link_hash_entry *hgot = elf_hash_table (info)->hgot;
	  bfd_vma got_value = hgot->root.u.def.value
	    + hgot->root.u.def.section->output_section->vma
	    + hgot->root.u.def.section->output_offset;

	  _frvfdpic_add_rofixup (output_bfd, frvfdpic_gotfixup_section (info),
				 got_value, 0);

	  if (frvfdpic_gotfixup_section (info)->size
	      != (frvfdpic_gotfixup_section (info)->reloc_count * 4))
d3672 29
a3700 3
	      (*_bfd_error_handler)
		("LINKER BUG: .rofixup section size mismatch");
	      return FALSE;
d3706 2
a3707 2
      BFD_ASSERT (frvfdpic_pltrel_section (info)->size
		  == (frvfdpic_pltrel_section (info)->reloc_count
d3721 1
a3721 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
d3735 3
a3737 3
	      dyn.d_un.d_ptr = frvfdpic_got_section (info)->output_section->vma
		+ frvfdpic_got_section (info)->output_offset
		+ frvfdpic_got_initial_offset (info);
d3742 2
a3743 3
	      dyn.d_un.d_ptr = frvfdpic_pltrel_section (info)
		->output_section->vma
		+ frvfdpic_pltrel_section (info)->output_offset;
d3748 4
a3751 1
	      dyn.d_un.d_val = frvfdpic_pltrel_section (info)->size;
d3765 2
a3766 3
elf32_frvfdpic_adjust_dynamic_symbol
(struct bfd_link_info *info ATTRIBUTE_UNUSED,
 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
d3799 4
a3802 5
elf32_frvfdpic_finish_dynamic_symbol
(bfd *output_bfd ATTRIBUTE_UNUSED,
 struct bfd_link_info *info ATTRIBUTE_UNUSED,
 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED,
 Elf_Internal_Sym *sym ATTRIBUTE_UNUSED)
d3811 3
a3813 4
frvfdpic_elf_use_relative_eh_frame
(bfd *input_bfd ATTRIBUTE_UNUSED,
 struct bfd_link_info *info ATTRIBUTE_UNUSED,
 asection *eh_frame_section ATTRIBUTE_UNUSED)
d3816 4
a3819 1
  return FALSE;
d3825 5
a3829 5
frvfdpic_elf_encode_eh_address (bfd *abfd,
				struct bfd_link_info *info,
				asection *osec, bfd_vma offset,
				asection *loc_sec, bfd_vma loc_offset,
				bfd_vma *encoded)
d3833 5
d3841 2
a3842 2
  if (! h || (_frvfdpic_osec_to_segment (abfd, osec)
	      == _frvfdpic_osec_to_segment (abfd, loc_sec->output_section)))
d3846 3
a3848 3
  BFD_ASSERT (_frvfdpic_osec_to_segment (abfd, osec)
	      == (_frvfdpic_osec_to_segment
		  (abfd, h->root.u.def.section->output_section)));
d3974 1
a3974 1
  struct frvfdpic_relocs_info *picrel;
d4000 2
a4015 9
	  if (! IS_FDPIC (abfd))
	    goto bad_reloc;
	  /* Fall through.  */
	case R_FRV_GPREL12:
	case R_FRV_GPRELU12:
	case R_FRV_GPRELHI:
	case R_FRV_GPRELLO:
	case R_FRV_LABEL24:
	case R_FRV_32:
a4021 5
	  if (! IS_FDPIC (abfd))
	    {
	      picrel = NULL;
	      break;
	    }
d4035 3
a4037 3
		= frvfdpic_relocs_info_for_global (frvfdpic_relocs_info (info),
						   abfd, h,
						   rel->r_addend, INSERT);
d4040 3
a4042 3
	    picrel = frvfdpic_relocs_info_for_local (frvfdpic_relocs_info
						     (info), abfd, r_symndx,
						     rel->r_addend, INSERT);
d4055 1
a4055 2
	  if (IS_FDPIC (abfd))
	    picrel->call = 1;
a4062 1

a4063 3
	  if (! IS_FDPIC (abfd))
	    break;

a4119 17

	case R_FRV_LABEL16:
	case R_FRV_LO16:
	case R_FRV_HI16:
	case R_FRV_GPREL12:
	case R_FRV_GPRELU12:
	case R_FRV_GPREL32:
	case R_FRV_GPRELHI:
	case R_FRV_GPRELLO:
	  break;

	default:
	bad_reloc:
	  (*_bfd_error_handler)
	    (_("%B: unsupported relocation type %i"),
	     abfd, ELF32_R_TYPE (rel->r_info));
	  return FALSE;
d4156 1
a4156 2
  return (((elf_elfheader (abfd)->e_flags & EF_FRV_FDPIC) != 0)
	  == (IS_FDPIC (abfd)));
a4216 44
static bfd_boolean
elf32_frvfdpic_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  unsigned i;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  if (! frv_elf_copy_private_bfd_data (ibfd, obfd))
    return FALSE;

  if (! elf_tdata (ibfd) || ! elf_tdata (ibfd)->phdr
      || ! elf_tdata (obfd) || ! elf_tdata (obfd)->phdr)
    return TRUE;

  /* Copy the stack size.  */
  for (i = 0; i < elf_elfheader (ibfd)->e_phnum; i++)
    if (elf_tdata (ibfd)->phdr[i].p_type == PT_GNU_STACK)
      {
	Elf_Internal_Phdr *iphdr = &elf_tdata (ibfd)->phdr[i];

	for (i = 0; i < elf_elfheader (obfd)->e_phnum; i++)
	  if (elf_tdata (obfd)->phdr[i].p_type == PT_GNU_STACK)
	    {
	      memcpy (&elf_tdata (obfd)->phdr[i], iphdr, sizeof (*iphdr));

	      /* Rewrite the phdrs, since we're only called after they
		 were first written.  */
	      if (bfd_seek (obfd, (bfd_signed_vma) get_elf_backend_data (obfd)
			    ->s->sizeof_ehdr, SEEK_SET) != 0
		  || get_elf_backend_data (obfd)->s
		  ->write_out_phdrs (obfd, elf_tdata (obfd)->phdr,
				     elf_elfheader (obfd)->e_phnum) != 0)
		return FALSE;
	      break;
	    }

	break;
      }

  return TRUE;
}

a4469 14
  if (((new_flags & EF_FRV_FDPIC) == 0)
      != (! IS_FDPIC (ibfd)))
    {
      error = TRUE;
      if (IS_FDPIC (obfd))
	(*_bfd_error_handler)
	  (_("%s: cannot link non-fdpic object file into fdpic executable"),
	   bfd_get_filename (ibfd));
      else
	(*_bfd_error_handler)
	  (_("%s: cannot link fdpic object file into non-fdpic executable"),
	   bfd_get_filename (ibfd));
    }

d4567 1
d4585 1
a4585 29
#define elf_backend_want_got_sym	1
#define elf_backend_got_header_size	0
#define elf_backend_want_got_plt	0
#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_plt_header_size	0

#define elf_backend_finish_dynamic_sections \
		elf32_frv_finish_dynamic_sections

#include "elf32-target.h"

#undef ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE		0x4000

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM          bfd_elf32_frvfdpic_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME		"elf32-frvfdpic"
#undef	elf32_bed
#define	elf32_bed		elf32_frvfdpic_bed

#undef elf_info_to_howto_rel
#define elf_info_to_howto_rel	frvfdpic_info_to_howto_rel

#undef bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create \
		frvfdpic_elf_link_hash_table_create
#undef elf_backend_always_size_sections
d4587 1
a4587 2
		elf32_frvfdpic_always_size_sections
#undef elf_backend_modify_segment_map
d4589 1
a4589 4
		elf32_frvfdpic_modify_segment_map
#undef bfd_elf32_bfd_copy_private_bfd_data
#define bfd_elf32_bfd_copy_private_bfd_data \
		elf32_frvfdpic_copy_private_bfd_data
a4590 1
#undef elf_backend_create_dynamic_sections
d4592 1
a4592 2
		elf32_frvfdpic_create_dynamic_sections
#undef elf_backend_adjust_dynamic_symbol
d4594 1
a4594 2
		elf32_frvfdpic_adjust_dynamic_symbol
#undef elf_backend_size_dynamic_sections
d4596 1
a4596 2
		elf32_frvfdpic_size_dynamic_sections
#undef elf_backend_finish_dynamic_symbol
d4598 1
a4598 2
		elf32_frvfdpic_finish_dynamic_symbol
#undef elf_backend_finish_dynamic_sections
d4600 8
a4607 1
		elf32_frvfdpic_finish_dynamic_sections
a4608 1
#undef elf_backend_can_make_relative_eh_frame
d4610 1
a4610 2
		frvfdpic_elf_use_relative_eh_frame
#undef elf_backend_can_make_lsda_relative_eh_frame
d4612 2
a4613 4
		frvfdpic_elf_use_relative_eh_frame
#undef elf_backend_encode_eh_address
#define elf_backend_encode_eh_address \
		frvfdpic_elf_encode_eh_address
a4614 1
#undef elf_backend_may_use_rel_p
a4615 1
#undef elf_backend_may_use_rela_p
a4617 1
#undef elf_backend_default_use_rela_p
a4619 3
#undef elf_backend_omit_section_dynsym
#define elf_backend_omit_section_dynsym _frvfdpic_link_omit_section_dynsym

@


1.12.6.4
log
@Merge from mainline.
@
text
@d2758 1
a2758 1
      h->def_regular = 1;
d2817 1
a2817 1
  h->def_regular = 1;
d2872 1
a2872 1
      h->def_regular = 1;
d3680 1
a3680 1
	  || !h->def_regular)
d3692 1
a3692 1
	  h->def_regular = 1;
d3868 7
a3874 4
	      && (h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));
d3879 1
a3879 1
  if (h->u.weakdef != NULL)
d3881 4
a3884 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
@


1.11
log
@2003-12-17  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (_frv_osec_readonly_p): New.
(_frv_emit_got_relocs_plt_entries): Don't emit rofixup for
undefweak symbol.
(_frv_count_got_plt_entries): Adjust expected count accordingly.
(elf32_frv_relocate_section): Likewise.  Error out if attempting
to emit rofixups or dynamic relocs in read-only segments.  Use
_bfd_elf_section_offset to adjust r_offsets in rofixups and
dynamic relocations.
2003-12-12  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_relocate_section): Compute dynamic
relocations or fixups involving merged sections correctly.  Avoid
crash when undefined symbol is referenced by R_FRV_32 or
R_FRV_FUNCDESC_VALUE.
2003-12-02  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_relocate_section): Add output_offset of
input section holding local symbol to addend of R_FRV_32 or
R_FRV_FUNCDESC_VALUE dynamic relocation.
2003-11-27  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_modify_segment_map): Add link info arg.
(elf32_frv_always_size_sections): Don't store pointer to
__stacksize symbol in sec_info.
(elf32_frv_modify_segment_map): Look it up here.
2003-11-26  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (_frv_emit_got_relocs_plt_entries): Emit the address
of the lazy PLT entry, not only its offset, as the low word of a
function descriptor.
2003-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_always_size_sections): Define __stacksize
if a hash table entry already exists but is not a definition.
2003-11-05  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (frv_elf_link_hash_table_create): Use bfd_zalloc.
(_frv_add_rofixup): Don't inline.
(_frv_emit_got_relocs_plt_entries): Use NULL as funcdesc address
for undefweak symbols.
(elf32_frv_relocate_section): Avoid crash while computing
relocation when linking with shared library.  Only emit rofixups
and dynamic relocations for alloc&load sections.  Mark binaries
with inter-segment relocations for relocation as a unit.
(_frv_create_got_section): Rename .rofixup.got to .rofixup.
(DEFAULT_STACK_SIZE): New.
(_frv_count_got_plt_entries): Fix thinko in deciding whether to
emit rofixups or dynamic relocs when linking dynamic non-PIE
executables.
(elf32_frv_size_dynamic_sections): Generate rofixup on PIEs and
shared libs too.  Reserve the last entry for the GOT pointer.
(elf32_frv_finish_dynamic_sections): Emit it.
(elf32_frv_always_size_sections): New.
(elf32_frv_modify_segment_map): New.
(elf32_frv_check_relocs): Reserve relocs32 space only in ALLOC
sections.
(frv_elf_merge_private_bfd_data): Clear PIC bit if FDPIC is set.
(frv_elf_print_private_bfd_data): Handle FDPIC and LIBPIC.
(elf_backend_always_size_sections): New.
(elf_backend_modify_segment_map): New.
2003-10-31  Alexandre Oliva  <aoliva@@redhat.com>
* config.bfd: Added frv-*-*linux*.
* elf32-frv.c (_frv_emit_got_relocs_plt_entries): Use idx 0 for
ABS section, instead of crashing.
(elf32_frv_relocate_section): Don't crash before warning about
different segments in non-PIC relocation.
2003-10-17  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_relocate_section): Don't warn on LABEL24
relocs to undefweak symbols.
(elf32_frv_relocate_section): Ditto for undefined symbols.
2003-10-06  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_create_dynamic_sections): Make sure
gotfixup section was created.
2003-09-30  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_howto_table): Change GOT12,
FUNCDESC_GOT12, GOTOFF12 and FUNCDESC_GOTOFF12 to
complain_overflow_signed.
* elf32-frv.c (_frv_add_rofixup): Do not error out if contents
have not been allocated.
(_frv_emit_got_relocs_plt_entries): Return non-void.  Assert
privfd only if dynamic sections were created.
(elf32_frv_relocate_section): Compute gprel_segment, and use it
for GPREL relocs.  When linking relocatable FDPIC executables,
emit warnings for relocations that would be illegal on PIE or
shared libraries.  Emit rofixup for R_FRV_32 only if input object
is not FDPIC.
(_frv_create_got_section): Define _gp symbol in the rofixup
section.
(elf32_frv_finish_dynamic_sections): If rofixups needed but
dynamic sections missing, error out requesting -melf32frvfd.
2003-09-19  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (_frv_emit_got_relocs_plt_entries): Rearrange
computation of addends from section and global or local symbol
value.  Change return type to bfd_boolean, and return a failure if
a dynamic FUNCDESC or FUNCDESC_VALUE relocation that requires a
nonzero addend is required.
(elf32_frv_relocate_section): Likewise.  Print error for
unsupported nonzero addends.
2003-09-18  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (FRV_SYM_LOCAL): In the absence of dynamic sections,
force everything local.
(_frv_emit_got_relocs_plt_entries): Cope with NULL sec.
* elf32-frv.c (struct frv_elf_link_hash_table): Added sgotfixup.
(frv_gotfixup_section): New.
(FRV_SYM_LOCAL): Accept undefweak and local common symbols.
(struct frv_pic_relocs_info): Split relocs into relocs32, relocsfd
and relocsfdv.
(_frv_add_rofixup): New.
(_frv_emit_got_relocs_plt_entries): Generate fixups for non-PIE
fdpic executables.  Use FRV_SYM_LOCAL more widely to simplify and
improve some ugly conditions.
(elf32_frv_relocate_section): Likewise.  Reject inter-segment
relocations in fdpic.
(_frv_create_got_section): Create .rofixup.got section.
(struct _frv_dynamic_got_info): Added fixups.
(_frv_count_got_plt_entries): Account in-GOT relocations into
relocs32, relocsfd and relocsfdv.  Account them into relocs or
fixups, as appropriate.
(elf32_frv_size_dynamic_sections): Size rofixup section.  Simplify
sizing of gotrel.
(elf32_frv_finish_dynamic_sections): Verify that the right number
of relocations and fixups was generated.
(elf32_frv_check_relocs): Compute relocs32, relocsfd and
relocsfdv.
* elf32-frv.c (FRV_SYM_LOCAL): New macro, used instead of
SYMBOL_CALLS_LOCAL and SYMBOL_REFERENCES_LOCAL.
(FRV_FUNCDESC_LOCAL): New macro, used to decide whether a function
descriptor of a (formerly-)global symbol is local.
(struct frv_pic_relocs_info): Adjust comments.
(_frv_emit_got_relocs_plt_entries): Adjust.
(elf32_frv_relocate_section): Likewise.
(_frv_count_got_plt_entries): Likewise.
* elf32-frv.c (_frv_emit_got_relocs_plt_entries): Don't add global
symbol's value to addend in the common preamble.  Decay dynamic
symbols to section+offset if they bind or call locally, for GOT
and FUNCDESC_VALUE, respectively.
(elf32_frv_relocate_section): Likewise.
(elf32_frv_check_relocs): Don't register as dynamic symbols of
internal or hidden visibility.
2003-09-17  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (_frv_emit_got_relocs_plt_entries): Get addend as
argument, so as to not call _bfd_elf_rel_local_sym to compute it.
(elf32_frv_relocate_section): Pass relocation addend in.  Use
original relocation addend to look up the got relocs/plt entries
table.  Do not call _bfd_elf_rel_local_sym.  Don't error out when
processing relocations that reference .scommon symbols.
2003-09-15  Alexandre Oliva  <aoliva@@redhat.com>
Introduce support for dynamic linking.
* elf32-frv.c (R_FRV_FUNCDESC_VALUE): Mark it as 64 bits.
(elf32_frv_rel_32_howto, elf32_frv_rel_funcdesc_howto,
elf32_frv_rel_funcdesc_value_howto): New REL descriptors.
(frv_reloc_type_lookup): Return REL howtos for executables and
dynamic libraries.
(frv_info_to_howto_rel): New.
(struct frv_elf_link_hash_table): New.
(frv_hash_table, frv_got_section, frv_gotrel_section,
frv_plt_section, frv_pltrel_section, frv_relocs_info,
frv_got_initial_offset, frv_plt_initial_offset): New macros.
(frv_elf_link_hash_table_create): New.
(struct frv_pic_relocs_info): New.
(frv_pic_relocs_info_hash, frv_pic_relocs_info_eq): New.
(frv_pic_relocs_info_find): New.
(frv_pic_relocs_info_for_global, frv_pic_relocs_info_for_local):
New.
(FRV_LZPLT_BLOCK_SIZE, FRV_LZPLT_RESOLVE_LOC): New.
(_frv_add_dyn_reloc, _frv_osec_to_segment): New.
(_frv_emit_got_relocs_plt_entries): New.
(elf32_frv_relocate_section): Add support for dynamic linking.
Handle new relocations.
(_frv_create_got_section): New.
(elf32_frv_create_dynamic_sections): New.
(ELF_DYNAMIC_INTERPRETER): New.
(struct _frv_dynamic_got_info): New.
(_frv_count_got_plt_entries): New.
(struct _frv_dynamic_got_plt_info): New.
(_frv_compute_got_alloc_data): New.
(_frv_get_got_entry, _frv_get_fd_entry): New.
(_frv_assign_got_entries, _frv_assign_plt_entries): New.
(_frv_resolve_final_relocs_info): New.
(elf32_frv_size_dynamic_sections): New.
(elf32_frv_finish_dynamic_sections): New.
(elf32_frv_adjust_dynamic_symbol): New.
(elf32_frv_finish_dynamic_symbol): New.
(elf32_frv_check_relocs): Handle new relocs.  Explain how the
whole thing works.
(elf_info_to_howto_rel): Define.
(bfd_elf32_bfd_link_hash_table_create): Define.
(elf_backend_create_dynamic_sections): Define.
(elf_backend_adjust_dynamic_symbol): Define.
(elf_backend_size_dynamic_sections): Define.
(elf_backend_finish_dynamic_symbol): Define.
(elf_backend_finish_dynamic_sections): Define.
(elf_backend_want_got_sym): Define.
(elf_backend_got_header_size): Define.
(elf_backend_want_got_plt): Define.
(elf_backend_plt_readonly): Define.
(elf_backend_want_plt_sym): Define.
(elf_backend_plt_header_size): Define.
(elf_backend_may_use_rel_p): Define.
(elf_backend_may_use_rela_p): Define.
(elf_backend_default_use_rela_p): Define.
2003-08-08  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (R_FRV_FUNCDESC_VALUE, R_FRV_FUNCDESC_GOTOFF12,
R_FRV_FUNCDESC_GOTOFFHI, R_FRV_FUNCDESC_GOTOFFLO, R_FRV_GOTOFF12,
R_FRV_GOTOFFHI, R_FRV_GOTOFFLO): New.
(frv_reloc_map): Map the corresponding BFD relocs to them.
(frv_reloc_type_lookup): ... and back to BFD relocs.
* reloc.c: New relocs.
* bfd-in2.h, libbfd.h: Rebuilt.
2003-08-04  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (R_FRV_GOT12, R_FRV_GOTHI, R_FRV_GOTLO,
R_FRV_FUNCDESC, R_FRV_FUNCDESC_GOT12, R_FRV_FUNCDESC_GOTHI,
R_FRV_FUNCDESC_GOTLO): New.
(frv_reloc_map): Map the corresponding BFD relocs to them.
(frv_reloc_type_lookup): ... and back to BFD relocs.
* reloc.c: New relocs.
* bfd-in2.h, libbfd.h: Rebuilt.
@
text
@d3457 1
a3457 1
	  struct bfd_link_hash_entry *bh;
@


1.10
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d25 1
d240 223
d496 48
d566 14
a584 1
/* Handle an FRV small data reloc.  */
d586 3
a588 9
static bfd_reloc_status_type
elf32_frv_relocate_gprel12 (info, input_bfd, input_section, relocation,
			    contents, value)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *relocation;
     bfd_byte *contents;
     bfd_vma value;
d590 21
a610 3
  bfd_vma insn;
  bfd_vma gp;
  struct bfd_link_hash_entry *h;
d612 1
a612 1
  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d614 2
a615 3
  gp = (h->u.def.value
	+ h->u.def.section->output_section->vma
	+ h->u.def.section->output_offset);
d617 16
a632 2
  value -= input_section->output_section->vma;
  value -= (gp - input_section->output_section->vma);
d634 1
a634 1
  insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);
d636 5
a640 1
  value += relocation->r_addend;
d642 3
a644 2
  if ((long) value > 0x7ff || (long) value < -0x800)
    return bfd_reloc_overflow;
d646 6
a651 3
  bfd_put_32 (input_bfd,
	      (insn & 0xfffff000) | (value & 0xfff),
	      contents + relocation->r_offset);
d653 1
a653 1
  return bfd_reloc_ok;
d656 106
a761 1
/* Handle an FRV small data reloc. for the u12 field.  */
d763 3
a765 9
static bfd_reloc_status_type
elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, relocation,
			     contents, value)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *relocation;
     bfd_byte *contents;
     bfd_vma value;
d767 1
a767 4
  bfd_vma insn;
  bfd_vma gp;
  struct bfd_link_hash_entry *h;
  bfd_vma mask;
d769 4
a772 1
  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d774 7
a780 3
  gp = (h->u.def.value
	+ h->u.def.section->output_section->vma
	+ h->u.def.section->output_offset);
d782 3
a784 2
  value -= input_section->output_section->vma;
  value -= (gp - input_section->output_section->vma);
d786 583
a1368 1
  insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);
d1562 4
d1596 48
d1680 28
d1774 3
d1785 21
d1817 3
d1823 1515
a3337 3
      if (   r_type == R_FRV_GNU_VTINHERIT
	  || r_type == R_FRV_GNU_VTENTRY)
	continue;
d3339 20
a3358 8
      /* This is a final link.  */
      r_symndx = ELF32_R_SYM (rel->r_info);
      howto  = elf32_frv_howto_table + ELF32_R_TYPE (rel->r_info);
      h      = NULL;
      sym    = NULL;
      sec    = NULL;

      if (r_symndx < symtab_hdr->sh_info)
d3360 19
a3378 3
	  sym = local_syms + r_symndx;
	  sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d3380 24
a3403 4
	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
	}
d3406 6
a3411 1
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];
d3413 19
a3431 3
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d3433 2
a3434 1
	  name = h->root.root.string;
d3436 9
a3444 21
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
	      relocation = 0;
	    }
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
	      relocation = 0;
	    }
	}
d3446 12
a3457 2
     if (r_type == R_FRV_HI16)
       r = elf32_frv_relocate_hi16 (input_bfd, rel, contents, relocation);
d3459 6
a3464 2
     else if (r_type == R_FRV_LO16)
       r = elf32_frv_relocate_lo16 (input_bfd, rel, contents, relocation);
d3466 4
a3469 3
     else if (r_type == R_FRV_LABEL24)
       r = elf32_frv_relocate_label24 (input_bfd, input_section, rel,
				       contents, relocation);
d3471 2
a3472 3
     else if (r_type == R_FRV_GPREL12)
       r = elf32_frv_relocate_gprel12 (info, input_bfd, input_section, rel,
				       contents, relocation);
d3474 4
a3477 3
     else if (r_type == R_FRV_GPRELU12)
       r = elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, rel,
					contents, relocation);
d3479 2
a3480 3
     else if (r_type == R_FRV_GPRELLO)
       r = elf32_frv_relocate_gprello (info, input_bfd, input_section, rel,
				       contents, relocation);
d3482 7
a3488 3
     else if (r_type == R_FRV_GPRELHI)
       r = elf32_frv_relocate_gprelhi (info, input_bfd, input_section, rel,
				       contents, relocation);
d3490 3
a3492 3
     else
       r = frv_final_link_relocate (howto, input_bfd, input_section, contents,
				    rel, relocation);
d3494 1
a3494 1
      if (r != bfd_reloc_ok)
d3496 2
a3497 1
	  const char * msg = (const char *) NULL;
d3499 1
a3499 1
	  switch (r)
d3501 28
a3528 5
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
	      break;
d3530 6
a3535 4
	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;
d3537 1
a3537 3
	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;
d3539 5
a3543 3
	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;
d3545 8
a3552 3
	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;
d3554 2
a3555 3
	    default:
	      msg = _("internal error: unknown error");
	      break;
d3558 12
a3569 6
	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
d3572 6
d3579 1
a3579 5
  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */
d3581 1
a3581 9
static asection *
elf32_frv_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  if (h != NULL)
d3583 9
a3591 1
      switch (ELF32_R_TYPE (rel->r_info))
d3593 3
a3595 3
	case R_FRV_GNU_VTINHERIT:
	case R_FRV_GNU_VTENTRY:
	  break;
d3597 1
a3597 2
	default:
	  switch (h->root.type)
d3602 12
a3613 3
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;
d3615 7
a3621 2
	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
a3624 2
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d3626 1
a3626 1
  return NULL;
d3629 2
a3630 1
/* Update the got entry reference counts for the section being removed.  */
d3633 2
a3634 5
elf32_frv_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d3636 25
d3664 1
a3664 3

/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put .comm items in .scomm, and not .comm.  */
d3667 4
a3670 8
elf32_frv_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
a3671 23
  if (sym->st_shndx == SHN_COMMON
      && !info->relocatable
      && (int)sym->st_size <= (int)bfd_get_gp_size (abfd))
    {
      /* Common symbols less than or equal to -G nn bytes are
	 automatically put into .sbss.  */

      asection *scomm = bfd_get_section_by_name (abfd, ".scommon");

      if (scomm == NULL)
	{
	  scomm = bfd_make_section (abfd, ".scommon");
	  if (scomm == NULL
	      || !bfd_set_section_flags (abfd, scomm, (SEC_ALLOC
						       | SEC_IS_COMMON
						       | SEC_LINKER_CREATED)))
	    return FALSE;
	}

      *secp = scomm;
      *valp = sym->st_size;
    }

d3674 1
d3676 102
a3777 2
   Since we don't do .gots or .plts, we just need to consider the
   virtual table relocs for gc.  */
d3790 2
d3802 1
d3816 54
d3871 53
d4023 3
d4328 6
d4352 1
a4352 1
#define elf_info_to_howto_rel			NULL
d4369 29
@


1.9
log
@2003-10-08  Dave Brolley  <brolley@@redhat.com>
        On behalf of Michael Snyder  <msnyder@@redhat.com>

        * archures.c: Add FRV fr550 machine.
        * cpu-frv.c: Ditto.
        * elf32-frv.c: Ditto.
        * bfd-in2.h: Regenerate.
@
text
@d727 1
a727 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.8
log
@* elf32-frv.c (elf32_frv_howto_table): Set R_FRV_LABEL16's
rightshift to 2.
@
text
@d1000 1
d1249 1
d1261 1
d1328 1
@


1.7
log
@	* elf32-frv.c (elf32_frv_relocate_section): Use
	_bfd_elf_rela_local_sym.
@
text
@d114 1
a114 1
	 0,			/* rightshift */
@


1.6
log
@Correct spelling of "relocatable".
@
text
@d727 1
a727 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.5
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 2002 Free Software Foundation, Inc.
d654 1
a654 1
   necessary, and (if using Rela relocs and generating a relocateable
d668 1
a668 1
   When generating relocateable output, this function must handle
d691 1
a691 1
  if (info->relocateable)
d910 1
a910 1
      && !info->relocateable
d950 1
a950 1
  if (info->relocateable)
@


1.4
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2002 Free Software Foundation, Inc.
d34 2
a35 1
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));
d37 2
a38 1
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));
d40 2
a41 1
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));
d43 2
a44 1
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *, bfd_byte *, bfd_vma));
d47 1
a47 1
static void frv_info_to_howto_rela 
d49 6
a54 4
static boolean elf32_frv_relocate_section 
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static boolean elf32_frv_add_symbol_hook
  PARAMS (( bfd *, struct bfd_link_info *, const Elf_Internal_Sym *, const char **, flagword *, asection **, bfd_vma *));
d56 5
a60 3
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, bfd_vma));
static boolean elf32_frv_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *));
d62 17
a78 9
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *, struct elf_link_hash_entry *, Elf_Internal_Sym *));
static boolean elf32_frv_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *));
static int elf32_frv_machine PARAMS ((bfd *));
static boolean elf32_frv_object_p PARAMS ((bfd *));
static boolean frv_elf_set_private_flags PARAMS ((bfd *, flagword));
static boolean frv_elf_copy_private_bfd_data PARAMS ((bfd *, bfd *));
static boolean frv_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
static boolean frv_elf_print_private_bfd_data PARAMS ((bfd *, PTR));
d87 1
a87 1
	 false,			/* pc_relative */
d92 1
a92 1
	 false,			/* partial_inplace */
d95 1
a95 1
	 false),		/* pcrel_offset */
d102 1
a102 1
	 false,			/* pc_relative */
d107 1
a107 1
	 false,			/* partial_inplace */
d110 1
a110 1
	 false),		/* pcrel_offset */
d117 1
a117 1
	 true,			/* pc_relative */
d122 1
a122 1
	 false,			/* partial_inplace */
d125 1
a125 1
	 true),		        /* pcrel_offset */
d132 1
a132 1
	 true,			/* pc_relative */
d137 1
a137 1
	 false,			/* partial_inplace */
d140 1
a140 1
	 true),		        /* pcrel_offset */
d146 1
a146 1
	 false,			/* pc_relative */
d151 1
a151 1
	false,			/* partial_inplace */
d154 1
a154 1
	 false),	        /* pcrel_offset */
d160 1
a160 1
	 false,			/* pc_relative */
d165 1
a165 1
	 false,			/* partial_inplace */
d168 1
a168 1
	 false),	        /* pcrel_offset */
d174 1
a174 1
	 false,			/* pc_relative */
d179 1
a179 1
	 false,			/* partial_inplace */
d182 1
a182 1
	 false),	        /* pcrel_offset */
d188 1
a188 1
	 false,			/* pc_relative */
d193 1
a193 1
	 false,			/* partial_inplace */
d196 1
a196 1
	 false),	        /* pcrel_offset */
d202 1
a202 1
	 false,			/* pc_relative */
d207 1
a207 1
	 false,			/* partial_inplace */
d210 1
a210 1
	 false),	        /* pcrel_offset */
d216 1
a216 1
	 false,			/* pc_relative */
d221 1
a221 1
	 false,			/* partial_inplace */
d224 1
a224 1
	 false),	        /* pcrel_offset */
d230 1
a230 1
	 false,			/* pc_relative */
d235 1
a235 1
	 false,			/* partial_inplace */
d238 1
a238 1
	 false),	        /* pcrel_offset */
d247 1
a247 1
         false,                 /* pc_relative */
d252 1
a252 1
         false,                 /* partial_inplace */
d255 1
a255 1
         false);                /* pcrel_offset */
d263 1
a263 1
         false,                 /* pc_relative */
d268 1
a268 1
         false,                 /* partial_inplace */
d271 1
a271 1
         false);                /* pcrel_offset */
d302 2
a303 1
elf32_frv_relocate_gprel12 (info, input_bfd, input_section, relocation, contents, value)
d315 1
a315 1
  h = bfd_link_hash_lookup (info->hash, "_gp", false, false, true);
d341 2
a342 1
elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, relocation, contents, value)
d355 1
a355 1
  h = bfd_link_hash_lookup (info->hash, "_gp", false, false, true);
d360 1
a360 1
 
d444 1
a444 1
    0 000000 0001111 000000000000000000 
d474 2
a475 1
elf32_frv_relocate_gprelhi (info, input_bfd, input_section, relocation, contents, value)
d487 1
a487 1
  h = bfd_link_hash_lookup (info->hash, "_gp", false, false, true);
d509 2
a510 1
elf32_frv_relocate_gprello (info, input_bfd, input_section, relocation, contents, value)
d522 1
a522 1
  h = bfd_link_hash_lookup (info->hash, "_gp", false, false, true);
d546 1
a546 1
     bfd * abfd ATTRIBUTE_UNUSED;
d556 1
a556 1
  
d602 3
a604 3
     bfd * abfd ATTRIBUTE_UNUSED;
     arelent * cache_ptr;
     Elf_Internal_Rela * dst;
d629 8
a636 7
frv_final_link_relocate (howto, input_bfd, input_section, contents, rel, relocation)
     reloc_howto_type *  howto;
     bfd *               input_bfd;
     asection *          input_section;
     bfd_byte *          contents;
     Elf_Internal_Rela * rel;
     bfd_vma             relocation;
d674 1
a674 1
static boolean
d677 13
a689 13
     bfd *                   output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *  info;
     bfd *                   input_bfd;
     asection *              input_section;
     bfd_byte *              contents;
     Elf_Internal_Rela *     relocs;
     Elf_Internal_Sym *      local_syms;
     asection **             local_sections;
{
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  Elf_Internal_Rela *           rel;
  Elf_Internal_Rela *           relend;
d692 1
a692 1
    return true;
d700 10
a709 10
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
      const char *                 name = NULL;
      int                          r_type;
      
d711 1
a711 1
      
d715 1
a715 1
      
d722 1
a722 1
      
d730 1
a730 1
	  
d738 1
a738 1
	  
d744 1
a744 1
	  
d761 2
a762 2
		      input_section, rel->r_offset, true)))
		return false;
d766 1
a766 1
      
d774 2
a775 1
       r = elf32_frv_relocate_label24 (input_bfd, input_section, rel, contents, relocation);
d778 2
a779 1
       r = elf32_frv_relocate_gprel12 (info, input_bfd, input_section, rel, contents, relocation);
d782 2
a783 1
       r = elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, rel, contents, relocation);
d786 2
a787 1
       r = elf32_frv_relocate_gprello (info, input_bfd, input_section, rel, contents, relocation);
d790 2
a791 1
       r = elf32_frv_relocate_gprelhi (info, input_bfd, input_section, rel, contents, relocation);
d794 2
a795 1
       r = frv_final_link_relocate (howto, input_bfd, input_section, contents, rel, relocation);
d808 1
a808 1
	      
d811 1
a811 1
		(info, name, input_bfd, input_section, rel->r_offset, true);
d813 1
a813 1
	      
d836 1
a836 1
	    return false;
d840 1
a840 1
  return true;
d848 5
a852 5
     asection *                   sec;
     struct bfd_link_info *       info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *          rel;
     struct elf_link_hash_entry * h;
     Elf_Internal_Sym *           sym;
d885 1
a885 1
static boolean
d887 4
a890 4
     bfd *                     abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *    info ATTRIBUTE_UNUSED;
     asection *                sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela * relocs ATTRIBUTE_UNUSED;
d892 1
a892 1
  return true;
d899 1
a899 1
static boolean
d925 1
a925 1
	    return false;
d932 1
a932 1
  return true;
d937 2
a938 2
 
static boolean
d949 1
a949 1
 
d951 2
a952 2
    return true;
 
d958 1
a958 1
 
d964 1
a964 1
 
d970 1
a970 1
 
d977 1
a977 1
            return false;
d979 1
a979 1
 
d984 1
a984 1
            return false;
d988 2
a989 2
 
  return true;
d1014 1
a1014 1
static boolean
d1019 1
a1019 1
  return true;
d1024 1
a1024 1
static boolean
d1030 2
a1031 2
  elf_flags_init (abfd) = true;
  return true;
d1036 1
a1036 1
static boolean
d1043 1
a1043 1
    return true;
d1049 2
a1050 2
  elf_flags_init (obfd) = true;
  return true;
d1056 1
a1056 1
static boolean
d1063 1
a1063 1
  boolean error = false;
d1079 1
a1079 1
      elf_flags_init (obfd) = true;
d1221 1
a1221 1
	      error = true;
d1267 1
a1267 1
      
d1271 1
a1271 1
	  error = true;
d1283 1
a1283 1
	  error = true;
d1307 1
a1307 1
boolean
d1377 1
a1377 1
  return true;
@


1.3
log
@missed 'em from the last delta
@
text
@d44 1
a44 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
d584 1
a584 1
     Elf32_Internal_Rela * dst;
@


1.3.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d34 1
a34 2
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
d36 1
a36 2
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
d38 1
a38 2
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
d40 1
a40 2
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
d43 6
a48 8
static void frv_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean elf32_frv_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf32_frv_add_symbol_hook
  PARAMS (( bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	    const char **, flagword *, asection **, bfd_vma *));
d50 3
a52 5
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
static bfd_boolean elf32_frv_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *, const
	   Elf_Internal_Rela *));
d54 9
a62 17
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf32_frv_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static int elf32_frv_machine
  PARAMS ((bfd *));
static bfd_boolean elf32_frv_object_p
  PARAMS ((bfd *));
static bfd_boolean frv_elf_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean frv_elf_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean frv_elf_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean frv_elf_print_private_bfd_data
  PARAMS ((bfd *, PTR));
d71 1
a71 1
	 FALSE,			/* pc_relative */
d76 1
a76 1
	 FALSE,			/* partial_inplace */
d79 1
a79 1
	 FALSE),		/* pcrel_offset */
d86 1
a86 1
	 FALSE,			/* pc_relative */
d91 1
a91 1
	 FALSE,			/* partial_inplace */
d94 1
a94 1
	 FALSE),		/* pcrel_offset */
d98 1
a98 1
	 2,			/* rightshift */
d101 1
a101 1
	 TRUE,			/* pc_relative */
d106 1
a106 1
	 FALSE,			/* partial_inplace */
d109 1
a109 1
	 TRUE),		        /* pcrel_offset */
d116 1
a116 1
	 TRUE,			/* pc_relative */
d121 1
a121 1
	 FALSE,			/* partial_inplace */
d124 1
a124 1
	 TRUE),		        /* pcrel_offset */
d130 1
a130 1
	 FALSE,			/* pc_relative */
d135 1
a135 1
	 FALSE,			/* partial_inplace */
d138 1
a138 1
	 FALSE),	        /* pcrel_offset */
d144 1
a144 1
	 FALSE,			/* pc_relative */
d149 1
a149 1
	 FALSE,			/* partial_inplace */
d152 1
a152 1
	 FALSE),	        /* pcrel_offset */
d158 1
a158 1
	 FALSE,			/* pc_relative */
d163 1
a163 1
	 FALSE,			/* partial_inplace */
d166 1
a166 1
	 FALSE),	        /* pcrel_offset */
d172 1
a172 1
	 FALSE,			/* pc_relative */
d177 1
a177 1
	 FALSE,			/* partial_inplace */
d180 1
a180 1
	 FALSE),	        /* pcrel_offset */
d186 1
a186 1
	 FALSE,			/* pc_relative */
d191 1
a191 1
	 FALSE,			/* partial_inplace */
d194 1
a194 1
	 FALSE),	        /* pcrel_offset */
d200 1
a200 1
	 FALSE,			/* pc_relative */
d205 1
a205 1
	 FALSE,			/* partial_inplace */
d208 1
a208 1
	 FALSE),	        /* pcrel_offset */
d214 1
a214 1
	 FALSE,			/* pc_relative */
d219 1
a219 1
	 FALSE,			/* partial_inplace */
d222 1
a222 1
	 FALSE),	        /* pcrel_offset */
d231 1
a231 1
         FALSE,                 /* pc_relative */
d236 1
a236 1
         FALSE,                 /* partial_inplace */
d239 1
a239 1
         FALSE);                /* pcrel_offset */
d247 1
a247 1
         FALSE,                 /* pc_relative */
d252 1
a252 1
         FALSE,                 /* partial_inplace */
d255 1
a255 1
         FALSE);                /* pcrel_offset */
d286 1
a286 2
elf32_frv_relocate_gprel12 (info, input_bfd, input_section, relocation,
			    contents, value)
d298 1
a298 1
  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d324 1
a324 2
elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, relocation,
			     contents, value)
d337 1
a337 1
  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d342 1
a342 1

d426 1
a426 1
    0 000000 0001111 000000000000000000
d456 1
a456 2
elf32_frv_relocate_gprelhi (info, input_bfd, input_section, relocation,
			    contents, value)
d468 1
a468 1
  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d490 1
a490 2
elf32_frv_relocate_gprello (info, input_bfd, input_section, relocation,
			    contents, value)
d502 1
a502 1
  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d526 1
a526 1
     bfd *abfd ATTRIBUTE_UNUSED;
d536 1
a536 1

d582 3
a584 3
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d609 7
a615 8
frv_final_link_relocate (howto, input_bfd, input_section, contents, rel,
			 relocation)
     reloc_howto_type *howto;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *rel;
     bfd_vma relocation;
d633 1
a633 1
   necessary, and (if using Rela relocs and generating a relocatable
d647 1
a647 1
   When generating relocatable output, this function must handle
d653 1
a653 1
static bfd_boolean
d656 13
a668 13
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
d670 2
a671 2
  if (info->relocatable)
    return TRUE;
d679 10
a688 10
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char * name = NULL;
      int r_type;

d690 1
a690 1

d694 1
a694 1

d701 1
a701 1

d706 4
a709 2
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

d717 1
a717 1

d723 1
a723 1

d740 2
a741 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d745 1
a745 1

d753 1
a753 2
       r = elf32_frv_relocate_label24 (input_bfd, input_section, rel,
				       contents, relocation);
d756 1
a756 2
       r = elf32_frv_relocate_gprel12 (info, input_bfd, input_section, rel,
				       contents, relocation);
d759 1
a759 2
       r = elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, rel,
					contents, relocation);
d762 1
a762 2
       r = elf32_frv_relocate_gprello (info, input_bfd, input_section, rel,
				       contents, relocation);
d765 1
a765 2
       r = elf32_frv_relocate_gprelhi (info, input_bfd, input_section, rel,
				       contents, relocation);
d768 1
a768 2
       r = frv_final_link_relocate (howto, input_bfd, input_section, contents,
				    rel, relocation);
d781 1
a781 1

d784 1
a784 1
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
d786 1
a786 1

d809 1
a809 1
	    return FALSE;
d813 1
a813 1
  return TRUE;
d821 5
a825 5
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d858 1
a858 1
static bfd_boolean
d860 4
a863 4
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d865 1
a865 1
  return TRUE;
d872 1
a872 1
static bfd_boolean
d883 1
a883 1
      && !info->relocatable
d898 1
a898 1
	    return FALSE;
d905 1
a905 1
  return TRUE;
d910 2
a911 2

static bfd_boolean
d922 4
a925 4

  if (info->relocatable)
    return TRUE;

d931 1
a931 1

d937 1
a937 1

d943 1
a943 1

d950 1
a950 1
            return FALSE;
d952 1
a952 1

d957 1
a957 1
            return FALSE;
d961 2
a962 2

  return TRUE;
a974 1
    case EF_FRV_CPU_FR550:  return bfd_mach_fr550;
d987 1
a987 1
static bfd_boolean
d992 1
a992 1
  return TRUE;
d997 1
a997 1
static bfd_boolean
d1003 2
a1004 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d1009 1
a1009 1
static bfd_boolean
d1016 1
a1016 1
    return TRUE;
d1022 2
a1023 2
  elf_flags_init (obfd) = TRUE;
  return TRUE;
d1029 1
a1029 1
static bfd_boolean
d1036 1
a1036 1
  bfd_boolean error = FALSE;
d1052 1
a1052 1
      elf_flags_init (obfd) = TRUE;
d1194 1
a1194 1
	      error = TRUE;
a1222 1
	    case EF_FRV_CPU_FR550:   strcat (new_opt, " -mcpu=fr550");  break;
a1233 1
	    case EF_FRV_CPU_FR550:   strcat (old_opt, " -mcpu=fr550");  break;
d1240 1
a1240 1

d1244 1
a1244 1
	  error = TRUE;
d1256 1
a1256 1
	  error = TRUE;
d1280 1
a1280 1
bfd_boolean
a1299 1
    case EF_FRV_CPU_FR550:  fprintf (file, " -mcpu=fr550");	break;
d1350 1
a1350 1
  return TRUE;
@


1.3.12.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@a24 1
#include "hashtab.h"
a238 223

  /* A 12-bit signed operand with the GOT offset for the address of
     the symbol.  */
  HOWTO (R_FRV_GOT12,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOT12",		/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTHI,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTHI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		        /* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTLO,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTLO",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The 32-bit address of the canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOT12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOT12", /* name */
	 FALSE,			/* partial_inplace */
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTHI,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTHI", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTLO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTLO", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The 32-bit address of the canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_VALUE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_VALUE", /* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTOFF12, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTOFF12", /* name */
	 FALSE,			/* partial_inplace */
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTOFFHI, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTOFFHI", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTOFFLO, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTOFFLO", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     the symbol.  */
  HOWTO (R_FRV_GOTOFF12,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTOFF12",	/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTOFFHI,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTOFFHI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTOFFLO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTOFFLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

a271 48

/* The following 3 relocations are REL.  The only difference to the
   entries in the table above are that partial_inplace is TRUE.  */
static reloc_howto_type elf32_frv_rel_32_howto =
  HOWTO (R_FRV_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

static reloc_howto_type elf32_frv_rel_funcdesc_howto =
  HOWTO (R_FRV_FUNCDESC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

static reloc_howto_type elf32_frv_rel_funcdesc_value_howto =
  HOWTO (R_FRV_FUNCDESC_VALUE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_VALUE", /* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

a293 14
  { BFD_RELOC_FRV_GOT12,      R_FRV_GOT12 },
  { BFD_RELOC_FRV_GOTHI,      R_FRV_GOTHI },
  { BFD_RELOC_FRV_GOTLO,      R_FRV_GOTLO },
  { BFD_RELOC_FRV_FUNCDESC,   R_FRV_FUNCDESC },
  { BFD_RELOC_FRV_FUNCDESC_GOT12, R_FRV_FUNCDESC_GOT12 },
  { BFD_RELOC_FRV_FUNCDESC_GOTHI, R_FRV_FUNCDESC_GOTHI },
  { BFD_RELOC_FRV_FUNCDESC_GOTLO, R_FRV_FUNCDESC_GOTLO },
  { BFD_RELOC_FRV_FUNCDESC_VALUE, R_FRV_FUNCDESC_VALUE },
  { BFD_RELOC_FRV_FUNCDESC_GOTOFF12, R_FRV_FUNCDESC_GOTOFF12 },
  { BFD_RELOC_FRV_FUNCDESC_GOTOFFHI, R_FRV_FUNCDESC_GOTOFFHI },
  { BFD_RELOC_FRV_FUNCDESC_GOTOFFLO, R_FRV_FUNCDESC_GOTOFFLO },
  { BFD_RELOC_FRV_GOTOFF12,   R_FRV_GOTOFF12 },
  { BFD_RELOC_FRV_GOTOFFHI,   R_FRV_GOTOFFHI },
  { BFD_RELOC_FRV_GOTOFFLO,   R_FRV_GOTOFFLO },
d299 1
d301 9
a309 3
/* An extension of the elf hash table data structure, containing some
   additional FRV-specific data.  */
struct frv_elf_link_hash_table
d311 3
a313 1
  struct elf_link_hash_table elf;
d315 1
a315 19
  /* A pointer to the .got section.  */
  asection *sgot;
  /* A pointer to the .rel.got section.  */
  asection *sgotrel;
  /* A pointer to the .rofixup section.  */
  asection *sgotfixup;
  /* A pointer to the .plt section.  */
  asection *splt;
  /* A pointer to the .rel.plt section.  */
  asection *spltrel;
  /* GOT base offset.  */
  bfd_vma got0;
  /* Location of the first non-lazy PLT entry, i.e., the number of
     bytes taken by lazy PLT entries.  */
  bfd_vma plt0;
  /* A hash table holding information about which symbols were
     referenced with which PIC-related relocations.  */
  struct htab *relocs_info;
};
d317 3
a319 1
/* Get the FRV ELF linker hash table from a link_info structure.  */
d321 2
a322 2
#define frv_hash_table(info) \
  ((struct frv_elf_link_hash_table *) ((info)->hash))
d324 1
a324 16
#define frv_got_section(info) \
  (frv_hash_table (info)->sgot)
#define frv_gotrel_section(info) \
  (frv_hash_table (info)->sgotrel)
#define frv_gotfixup_section(info) \
  (frv_hash_table (info)->sgotfixup)
#define frv_plt_section(info) \
  (frv_hash_table (info)->splt)
#define frv_pltrel_section(info) \
  (frv_hash_table (info)->spltrel)
#define frv_relocs_info(info) \
  (frv_hash_table (info)->relocs_info)
#define frv_got_initial_offset(info) \
  (frv_hash_table (info)->got0)
#define frv_plt_initial_offset(info) \
  (frv_hash_table (info)->plt0)
d326 1
a326 1
/* Create an FRV ELF linker hash table.  */
d328 2
a329 5
static struct bfd_link_hash_table *
frv_elf_link_hash_table_create (bfd *abfd)
{
  struct frv_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct frv_elf_link_hash_table);
d331 3
a333 3
  ret = bfd_zalloc (abfd, amt);
  if (ret == NULL)
    return NULL;
d335 1
a335 8
  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd,
				       _bfd_elf_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }

  return &ret->elf.root;
d338 1
a338 106
/* Decide whether a reference to a symbol can be resolved locally or
   not.  If the symbol is protected, we want the local address, but
   its function descriptor must be assigned by the dynamic linker.  */
#define FRV_SYM_LOCAL(INFO, H) \
  (_bfd_elf_symbol_refs_local_p ((H), (INFO), 1) \
   || ! elf_hash_table (INFO)->dynamic_sections_created \
   || (H)->root.type == bfd_link_hash_undefweak \
   || (/* The condition below is an ugly hack to get .scommon data to
	  be regarded as local.  For some reason the
	  ELF_LINK_HASH_DEF_REGULAR bit is not set on such common
	  symbols, and the SEC_IS_COMMON bit is not set any longer
	  when we need to perform this test.  Hopefully this
	  approximation is good enough.  */ \
       ((H)->root.type == bfd_link_hash_defined \
	|| (H)->root.type == bfd_link_hash_defweak) \
       && (H)->root.u.def.section->output_section \
       && ((H)->root.u.def.section->flags & SEC_LINKER_CREATED)))
#define FRV_FUNCDESC_LOCAL(INFO, H) \
  ((H)->dynindx == -1 || ! elf_hash_table (INFO)->dynamic_sections_created)

/* This structure collects information on what kind of GOT, PLT or
   function descriptors are required by relocations that reference a
   certain symbol.  */
struct frv_pic_relocs_info
{
  /* The index of the symbol, as stored in the relocation r_info, if
     we have a local symbol; -1 otherwise.  */
  long symndx;
  union
  {
    /* The input bfd in which the symbol is defined, if it's a local
       symbol.  */
    bfd *abfd;
    /* If symndx == -1, the hash table entry corresponding to a global
       symbol (even if it turns out to bind locally, in which case it
       should ideally be replaced with section's symndx + addend).  */
    struct elf_link_hash_entry *h;
  } d;
  /* The addend of the relocation that references the symbol.  */
  bfd_vma addend;

  /* The fields above are used to identify an entry.  The fields below
     contain information on how an entry is used and, later on, which
     locations it was assigned.  */
  /* The following 3 fields record whether the symbol+addend above was
     ever referenced with a GOT relocation.  The 12 suffix indicates a
     GOT12 relocation; los is used for GOTLO relocations that are not
     matched by a GOTHI relocation; hilo is used for GOTLO/GOTHI
     pairs.  */
  unsigned got12:1;
  unsigned gotlos:1;
  unsigned gothilo:1;
  /* Whether a FUNCDESC relocation references symbol+addend.  */
  unsigned fd:1;
  /* Whether a FUNCDESC_GOT relocation references symbol+addend.  */
  unsigned fdgot12:1;
  unsigned fdgotlos:1;
  unsigned fdgothilo:1;
  /* Whether a FUNCDESC_GOTOFF relocation references symbol+addend.  */
  unsigned fdgoff12:1;
  unsigned fdgofflos:1;
  unsigned fdgoffhilo:1;
  /* Whether symbol+addend is referenced with GOTOFF12, GOTOFFLO or
     GOTOFFHI relocations.  The addend doesn't really matter, since we
     envision that this will only be used to check whether the symbol
     is mapped to the same segment as the got.  */
  unsigned gotoff:1;
  /* Whether symbol+addend is referenced by a LABEL24 relocation.  */
  unsigned call:1;
  /* Whether symbol+addend is referenced by a 32 or FUNCDESC_VALUE
     relocation.  */
  unsigned sym:1;
  /* Whether we need a PLT entry for a symbol.  Should be implied by
     something like:
     (call && symndx == -1 && ! FRV_SYM_LOCAL (info, d.h))  */
  unsigned plt:1;
  /* Whether a function descriptor should be created in this link unit
     for symbol+addend.  Should be implied by something like:
     (plt || fdgotoff12 || fdgotofflos || fdgotofflohi
      || ((fd || fdgot12 || fdgotlos || fdgothilo)
          && (symndx != -1 || FRV_FUNCDESC_LOCAL (info, d.h))))  */
  unsigned privfd:1;
  /* Whether a lazy PLT entry is needed for this symbol+addend.
     Should be implied by something like:
     (privfd && symndx == -1 && ! FRV_SYM_LOCAL (info, d.h)
      && ! (info->flags & DF_BIND_NOW))  */
  unsigned lazyplt:1;
  /* Whether we've already emitted GOT relocations and PLT entries as
     needed for this symbol.  */
  unsigned done:1;

  /* The number of R_FRV_32, R_FRV_FUNCDESC and R_FRV_FUNCDESC_VALUE
     relocations referencing the symbol.  */
  unsigned relocs32, relocsfd, relocsfdv;

  /* The offsets of the GOT entries assigned to symbol+addend, to the
     function descriptor's address, and to a function descriptor,
     respectively.  Should be zero if unassigned.  The offsets are
     counted from the value that will be assigned to the PIC register,
     not from the beginning of the .got section.  */
  bfd_signed_vma got_entry, fdgot_entry, fd_entry;
  /* The offsets of the PLT entries assigned to symbol+addend,
     non-lazy and lazy, respectively.  If unassigned, should be
     (bfd_vma)-1.  */
  bfd_vma plt_entry, lzplt_entry;
};
d340 9
a348 3
/* Compute a hash with the key fields of an frv_pic_relocs_info entry.  */
static hashval_t
frv_pic_relocs_info_hash (const void *entry_)
d350 4
a353 1
  const struct frv_pic_relocs_info *entry = entry_;
d355 1
a355 4
  return (entry->symndx == -1
	  ? entry->d.h->root.root.hash
	  : entry->symndx + entry->d.abfd->id * 257) + entry->addend;
}
d357 3
a359 7
/* Test whether the key fields of two frv_pic_relocs_info entries are
   identical.  */
static int
frv_pic_relocs_info_eq (const void *entry1, const void *entry2)
{
  const struct frv_pic_relocs_info *e1 = entry1;
  const struct frv_pic_relocs_info *e2 = entry2;
d361 2
a362 3
  return e1->symndx == e2->symndx && e1->addend == e2->addend
    && (e1->symndx == -1 ? e1->d.h == e2->d.h : e1->d.abfd == e2->d.abfd);
}
d364 1
a364 583
/* Find or create an entry in a hash table HT that matches the key
   fields of the given ENTRY.  If it's not found, memory for a new
   entry is allocated in ABFD's obstack.  */
static struct frv_pic_relocs_info *
frv_pic_relocs_info_find (struct htab *ht,
			  bfd *abfd,
			  const struct frv_pic_relocs_info *entry)
{
  struct frv_pic_relocs_info **loc =
    (struct frv_pic_relocs_info **) htab_find_slot (ht, entry, INSERT);

  if (*loc)
    return *loc;

  *loc = bfd_zalloc (abfd, sizeof (**loc));

  if (! *loc)
    return *loc;

  (*loc)->symndx = entry->symndx;
  (*loc)->d = entry->d;
  (*loc)->addend = entry->addend;
  (*loc)->plt_entry = (bfd_vma)-1;
  (*loc)->lzplt_entry = (bfd_vma)-1;

  return *loc;
}

/* Obtain the address of the entry in HT associated with H's symbol +
   addend, creating a new entry if none existed.  ABFD is only used
   for memory allocation purposes.  */
inline static struct frv_pic_relocs_info *
frv_pic_relocs_info_for_global (struct htab *ht,
				bfd *abfd,
				struct elf_link_hash_entry *h,
				bfd_vma addend)
{
  struct frv_pic_relocs_info entry;

  entry.symndx = -1;
  entry.d.h = h;
  entry.addend = addend;

  return frv_pic_relocs_info_find (ht, abfd, &entry);
}

/* Obtain the address of the entry in HT associated with the SYMNDXth
   local symbol of the input bfd ABFD, plus the addend, creating a new
   entry if none existed.  */  
inline static struct frv_pic_relocs_info *
frv_pic_relocs_info_for_local (struct htab *ht,
			       bfd *abfd,
			       long symndx,
			       bfd_vma addend)
{
  struct frv_pic_relocs_info entry;

  entry.symndx = symndx;
  entry.d.abfd = abfd;
  entry.addend = addend;

  return frv_pic_relocs_info_find (ht, abfd, &entry);
}

/* Every block of 65535 lazy PLT entries shares a single call to the
   resolver, inserted in the 32768th lazy PLT entry (i.e., entry #
   32767, counting from 0).  All other lazy PLT entries branch to it
   in a single instruction.  */

#define FRV_LZPLT_BLOCK_SIZE ((bfd_vma) 8 * 65535 + 4)
#define FRV_LZPLT_RESOLV_LOC (8 * 32767)

/* Add a dynamic relocation to the SRELOC section.  */

inline static bfd_vma
_frv_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
		    int reloc_type, long dynindx, bfd_vma addend)
{
  Elf_Internal_Rela outrel;
  bfd_vma reloc_offset;

  outrel.r_offset = offset;
  outrel.r_info = ELF32_R_INFO (dynindx, reloc_type);
  outrel.r_addend = addend;

  reloc_offset = sreloc->reloc_count * sizeof (Elf32_External_Rel);
  BFD_ASSERT (reloc_offset < sreloc->_raw_size);
  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
			    sreloc->contents + reloc_offset);
  sreloc->reloc_count++;

  return reloc_offset;
}

/* Add a fixup to the ROFIXUP section.  */

static bfd_vma
_frv_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset)
{
  bfd_vma fixup_offset;

  if (rofixup->flags & SEC_EXCLUDE)
    return -1;

  fixup_offset = rofixup->reloc_count * 4;
  if (rofixup->contents)
    {
      BFD_ASSERT (fixup_offset < rofixup->_raw_size);
      bfd_put_32 (output_bfd, offset, rofixup->contents + fixup_offset);
    }
  rofixup->reloc_count++;
	      
  return fixup_offset;
}

/* Find the segment number in which OSEC, and output section, is
   located.  */

static unsigned
_frv_osec_to_segment (bfd *output_bfd, asection *osec)
{
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;

  /* Find the segment that contains the output_section.  */
  for (m = elf_tdata (output_bfd)->segment_map,
	 p = elf_tdata (output_bfd)->phdr;
       m != NULL;
       m = m->next, p++)
    {
      int i;

      for (i = m->count - 1; i >= 0; i--)
	if (m->sections[i] == osec)
	  break;

      if (i >= 0)
	break;
    }

  return p - elf_tdata (output_bfd)->phdr;
}

inline static bfd_boolean
_frv_osec_readonly_p (bfd *output_bfd, asection *osec)
{
  unsigned seg = _frv_osec_to_segment (output_bfd, osec);

  return ! (elf_tdata (output_bfd)->phdr[seg].p_flags & PF_W);
}

/* Generate relocations for GOT entries, function descriptors, and
   code for PLT and lazy PLT entries.  */

inline static bfd_boolean
_frv_emit_got_relocs_plt_entries (struct frv_pic_relocs_info *entry,
				  bfd *output_bfd,
				  struct bfd_link_info *info,
				  asection *sec,
				  Elf_Internal_Sym *sym,
				  bfd_vma addend)
				  
{
  bfd_vma fd_lazy_rel_offset = (bfd_vma)-1;
  int dynindx = -1;

  if (entry->done)
    return TRUE;
  entry->done = 1;

  if (entry->got_entry || entry->fdgot_entry || entry->fd_entry)
    {
      /* If the symbol is dynamic, consider it for dynamic
	 relocations, otherwise decay to section + offset.  */
      if (entry->symndx == -1 && entry->d.h->dynindx != -1)
	dynindx = entry->d.h->dynindx;
      else
	{
	  if (sec->output_section
	      && ! bfd_is_abs_section (sec->output_section)
	      && ! bfd_is_und_section (sec->output_section))
	    dynindx = elf_section_data (sec->output_section)->dynindx;
	  else
	    dynindx = 0;
	}
    }

  /* Generate relocation for GOT entry pointing to the symbol.  */
  if (entry->got_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;

      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}

      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma;
	  if (entry->symndx != -1 ||
	      entry->d.h->root.type != bfd_link_hash_undefweak)
	    _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
			      frv_got_section (info)->output_section->vma
			      + frv_got_section (info)->output_offset
			      + frv_got_initial_offset (info)
			      + entry->got_entry);
	}
      else
	_frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
			    _bfd_elf_section_offset
			    (output_bfd, info,
			     frv_got_section (info),
			     frv_got_initial_offset (info)
			     + entry->got_entry)
			    + frv_got_section (info)->output_section->vma
			    + frv_got_section (info)->output_offset,
			    R_FRV_32, idx, ad);
	
      bfd_put_32 (output_bfd, ad,
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
		  + entry->got_entry);
    }

  /* Generate relocation for GOT entry pointing to a canonical
     function descriptor.  */
  if (entry->fdgot_entry)
    {
      int reloc, idx;
      bfd_vma ad;
      
      /* If the symbol is dynamic and there may be dynamic symbol
	 resolution because we are or are linked with a shared
	 library, emit a FUNCDESC relocation such that the dynamic
	 linker will allocate the function descriptor.  */
      if (entry->symndx == -1 && ! FRV_FUNCDESC_LOCAL (info, entry->d.h))
	{
	  reloc = R_FRV_FUNCDESC;
	  idx = dynindx;
	  ad = addend;
	  if (ad)
	    return FALSE;
	}
      else
	{
	  /* Otherwise, we know we have a private function descriptor,
	     so reference it directly.  */
	  if (elf_hash_table (info)->dynamic_sections_created)
	    BFD_ASSERT (entry->privfd);
	  reloc = R_FRV_32;
	  idx = elf_section_data (frv_got_section (info)->output_section)
	    ->dynindx;
	  ad = frv_got_section (info)->output_offset +
	    frv_got_initial_offset (info) + entry->fd_entry;
	}

      /* If there is room for dynamic symbol resolution, emit the
	 dynamic relocation.  However, if we're linking an executable
	 at a fixed location, we won't have emitted a dynamic symbol
	 entry for the got section, so idx will be zero, which means
	 we can and should compute the address of the private
	 descriptor ourselves.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1 || FRV_FUNCDESC_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1
	      && entry->d.h->root.type == bfd_link_hash_undefweak)
	    ad = 0;
	  else
	    {
	      ad += frv_got_section (info)->output_section->vma;
	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset
				+ frv_got_initial_offset (info)
				+ entry->fdgot_entry);
	    }
	}
      else
	_frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
			    _bfd_elf_section_offset
			    (output_bfd, info,
			     frv_got_section (info),
			     frv_got_initial_offset (info)
			     + entry->fdgot_entry)
			    + frv_got_section (info)->output_section->vma
			    + frv_got_section (info)->output_offset,
			    reloc, idx, ad);

      bfd_put_32 (output_bfd, ad,
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
		  + entry->fdgot_entry);
    }

  /* Generate relocation to fill in a private function descriptor in
     the GOT.  */
  if (entry->fd_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;
      bfd_vma ofst;
      long lowword, highword;

      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}

      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma;
	  ofst = 0;
	  if (entry->symndx != -1 ||
	      entry->d.h->root.type != bfd_link_hash_undefweak)
	    {
	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset
				+ frv_got_initial_offset (info)
				+ entry->fd_entry);
	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset
				+ frv_got_initial_offset (info)
				+ entry->fd_entry + 4);
	    }
	}
      else
	{
	  ofst =
	    _frv_add_dyn_reloc (output_bfd,
				entry->lazyplt ? frv_pltrel_section (info)
				: frv_gotrel_section (info),
				_bfd_elf_section_offset
				(output_bfd, info,
				 frv_got_section (info),
				 frv_got_initial_offset (info)
				 + entry->fd_entry)
				+ frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset,
				R_FRV_FUNCDESC_VALUE, idx, ad);
	}

      /* If we've omitted the dynamic relocation, just emit the fixed
	 addresses of the symbol and of the local GOT base offset.  */
      if (info->executable && !info->pie && sec && sec->output_section)
	{
	  lowword = ad;
	  highword = frv_got_section (info)->output_section->vma
	    + frv_got_section (info)->output_offset
	    + frv_got_initial_offset (info);
	}
      else if (entry->lazyplt)
	{
	  if (ad)
	    return FALSE;
	  
	  fd_lazy_rel_offset = ofst;

	  /* A function descriptor used for lazy or local resolving is
	     initialized such that its high word contains the output
	     section index in which the PLT entries are located, and
	     the low word contains the address of the lazy PLT entry
	     entry point, that must be within the memory region
	     assigned to that section.  */
	  lowword = entry->lzplt_entry + 4
	    + frv_plt_section (info)->output_offset
	    + frv_plt_section (info)->output_section->vma;
	  highword = _frv_osec_to_segment 
	    (output_bfd, frv_plt_section (info)->output_section);
	}
      else
	{
	  /* A function descriptor for a local function gets the index
	     of the section.  For a non-local function, it's
	     disregarded.  */
	  lowword = ad;
	  if (entry->symndx == -1 && entry->d.h->dynindx != -1
	      && entry->d.h->dynindx == idx)
	    highword = 0;
	  else
	    highword = _frv_osec_to_segment (output_bfd, sec->output_section);
	}

      bfd_put_32 (output_bfd, lowword,
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
		  + entry->fd_entry);
      bfd_put_32 (output_bfd, highword,
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
		  + entry->fd_entry + 4);
    }

  /* Generate code for the PLT entry.  */
  if (entry->plt_entry != (bfd_vma) -1)
    {
      bfd_byte *plt_code = frv_plt_section (info)->contents + entry->plt_entry;

      BFD_ASSERT (entry->fd_entry);

      /* Figure out what kind of PLT entry we need, depending on the
	 location of the function descriptor within the GOT.  */
      if (entry->fd_entry >= -(1 << (12 - 1))
	  && entry->fd_entry < (1 << (12 - 1)))
	{
	  /* lddi @@(gr15, fd_entry), gr14 */
	  bfd_put_32 (output_bfd,
		      0x9cccf000 | (entry->fd_entry & ((1 << 12) - 1)),
		      plt_code);
	  plt_code += 4;
	}
      else
	{
	  if (entry->fd_entry >= -(1 << (16 - 1))
	      && entry->fd_entry < (1 << (16 - 1)))
	    {
	      /* setlos lo(fd_entry), gr14 */
	      bfd_put_32 (output_bfd,
			  0x9cfc0000
			  | (entry->fd_entry & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      plt_code += 4;
	    }
	  else
	    {
	      /* sethi.p hi(fd_entry), gr14
		 setlo lo(fd_entry), gr14 */
	      bfd_put_32 (output_bfd,
			  0x1cf80000
			  | ((entry->fd_entry >> 16)
			     & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      bfd_put_32 (output_bfd,
			  0x9cf40000
			  | (entry->fd_entry & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      plt_code += 8;
	    }
	  /* ldd @@(gr14,gr15),gr14 */
	  bfd_put_32 (output_bfd, 0x9c08e14f, plt_code);
	  plt_code += 4;
	}
      /* jmpl @@(gr14,gr0) */
      bfd_put_32 (output_bfd, 0x8030e000, plt_code);
    }

  /* Generate code for the lazy PLT entry.  */
  if (entry->lzplt_entry != (bfd_vma) -1)
    {
      bfd_byte *lzplt_code = frv_plt_section (info)->contents
	+ entry->lzplt_entry;
      bfd_vma resolverStub_addr;

      bfd_put_32 (output_bfd, fd_lazy_rel_offset, lzplt_code);
      lzplt_code += 4;

      resolverStub_addr = entry->lzplt_entry / FRV_LZPLT_BLOCK_SIZE
	* FRV_LZPLT_BLOCK_SIZE + FRV_LZPLT_RESOLV_LOC;
      if (resolverStub_addr >= frv_plt_initial_offset (info))
	resolverStub_addr = frv_plt_initial_offset (info) - 12;

      if (entry->lzplt_entry == resolverStub_addr)
	{
	  /* This is a lazy PLT entry that includes a resolver call.  */
	  /* ldd @@(gr15,gr0), gr4
	     jmpl @@(gr4,gr0)  */
	  bfd_put_32 (output_bfd, 0x8808f140, lzplt_code);
	  bfd_put_32 (output_bfd, 0x80304000, lzplt_code + 4);
	}
      else
	{
	  /* bra  resolverStub */
	  bfd_put_32 (output_bfd,
		      0xc01a0000
		      | (((resolverStub_addr - entry->lzplt_entry)
			  / 4) & (((bfd_vma)1 << 16) - 1)),
		      lzplt_code);
	}
    }

  return TRUE;
}

/* Handle an FRV small data reloc.  */

static bfd_reloc_status_type
elf32_frv_relocate_gprel12 (info, input_bfd, input_section, relocation,
			    contents, value)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *relocation;
     bfd_byte *contents;
     bfd_vma value;
{
  bfd_vma insn;
  bfd_vma gp;
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);

  gp = (h->u.def.value
	+ h->u.def.section->output_section->vma
	+ h->u.def.section->output_offset);

  value -= input_section->output_section->vma;
  value -= (gp - input_section->output_section->vma);

  insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);

  value += relocation->r_addend;

  if ((long) value > 0x7ff || (long) value < -0x800)
    return bfd_reloc_overflow;

  bfd_put_32 (input_bfd,
	      (insn & 0xfffff000) | (value & 0xfff),
	      contents + relocation->r_offset);

  return bfd_reloc_ok;
}

/* Handle an FRV small data reloc. for the u12 field.  */

static bfd_reloc_status_type
elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, relocation,
			     contents, value)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *relocation;
     bfd_byte *contents;
     bfd_vma value;
{
  bfd_vma insn;
  bfd_vma gp;
  struct bfd_link_hash_entry *h;
  bfd_vma mask;

  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);

  gp = (h->u.def.value
	+ h->u.def.section->output_section->vma
	+ h->u.def.section->output_offset);

  value -= input_section->output_section->vma;
  value -= (gp - input_section->output_section->vma);

  insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);
a557 4
      if (elf_elfheader (abfd)->e_type == ET_EXEC
	  || elf_elfheader (abfd)->e_type == ET_DYN)
	return &elf32_frv_rel_32_howto;
      /* Fall through.  */
a587 48
    case BFD_RELOC_FRV_GOT12:
      return &elf32_frv_howto_table[ (int) R_FRV_GOT12];

    case BFD_RELOC_FRV_GOTHI:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTHI];

    case BFD_RELOC_FRV_GOTLO:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTLO];

    case BFD_RELOC_FRV_FUNCDESC:
      if (elf_elfheader (abfd)->e_type == ET_EXEC
	  || elf_elfheader (abfd)->e_type == ET_DYN)
	return &elf32_frv_rel_funcdesc_howto;
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC];

    case BFD_RELOC_FRV_FUNCDESC_GOT12:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOT12];

    case BFD_RELOC_FRV_FUNCDESC_GOTHI:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTHI];

    case BFD_RELOC_FRV_FUNCDESC_GOTLO:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTLO];

    case BFD_RELOC_FRV_FUNCDESC_VALUE:
      if (elf_elfheader (abfd)->e_type == ET_EXEC
	  || elf_elfheader (abfd)->e_type == ET_DYN)
	return &elf32_frv_rel_funcdesc_value_howto;
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_VALUE];

    case BFD_RELOC_FRV_FUNCDESC_GOTOFF12:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTOFF12];

    case BFD_RELOC_FRV_FUNCDESC_GOTOFFHI:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTOFFHI];

    case BFD_RELOC_FRV_FUNCDESC_GOTOFFLO:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTOFFLO];

    case BFD_RELOC_FRV_GOTOFF12:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTOFF12];

    case BFD_RELOC_FRV_GOTOFFHI:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTOFFHI];

    case BFD_RELOC_FRV_GOTOFFLO:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTOFFLO];

a623 28

/* Set the howto pointer for an FRV ELF REL reloc.  */
static void
frv_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  switch (r_type)
    {
    case R_FRV_32:
      cache_ptr->howto = &elf32_frv_rel_32_howto;
      break;

    case R_FRV_FUNCDESC:
      cache_ptr->howto = &elf32_frv_rel_funcdesc_howto;
      break;

    case R_FRV_FUNCDESC_VALUE:
      cache_ptr->howto = &elf32_frv_rel_funcdesc_value_howto;
      break;

    default:
      cache_ptr->howto = NULL;
      break;
    }
}
a689 3
  unsigned isec_segment, got_segment, plt_segment, gprel_segment,
    check_segment[2];
  int silence_segment_error = !(info->shared || info->pie);
a697 21
  isec_segment = _frv_osec_to_segment (output_bfd,
				       input_section->output_section);
  if (frv_got_section (info))
    got_segment = _frv_osec_to_segment (output_bfd,
					frv_got_section (info)
					->output_section);
  else
    got_segment = -1;
  if (frv_gotfixup_section (info))
    gprel_segment = _frv_osec_to_segment (output_bfd,
					  frv_gotfixup_section (info)
					  ->output_section);
  else
    gprel_segment = -1;
  if (elf_hash_table (info)->dynamic_sections_created)
    plt_segment = _frv_osec_to_segment (output_bfd,
					frv_plt_section (info)
					->output_section);
  else
    plt_segment = -1;

a708 3
      asection *osec;
      struct frv_pic_relocs_info *picrel;
      bfd_vma orig_addend = rel->r_addend;
d723 1
a723 1525
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  osec = sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
	}
      else
	{
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  name = h->root.root.string;

	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && ! FRV_SYM_LOCAL (info, h))
	    {
	      sec = NULL;
	      relocation = 0;
	    }
	  else
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
	      relocation = 0;
	    }
	  else if (   ! info->executable
		   && ! info->symbolic
		   && info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
	      relocation = 0;
	    }
	  osec = sec;
	}

      switch (r_type)
	{
	case R_FRV_LABEL24:
	case R_FRV_32:
	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFFLO:
	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	case R_FRV_FUNCDESC:
	case R_FRV_FUNCDESC_VALUE:
	  if (h != NULL)
	    picrel = frv_pic_relocs_info_for_global (frv_relocs_info (info),
						     input_bfd, h,
						     orig_addend);
	  else
	    /* In order to find the entry we created before, we must
	       use the original addend, not the one that may have been
	       modified by _bfd_elf_rela_local_sym().  */
	    picrel = frv_pic_relocs_info_for_local (frv_relocs_info (info),
						    input_bfd, r_symndx,
						    orig_addend);
	  if (! picrel)
	    return FALSE;

	  if (!_frv_emit_got_relocs_plt_entries (picrel, output_bfd, info,
						 osec, sym, rel->r_addend))
	    {
	      info->callbacks->warning
		(info, _("Dynamic relocation references symbol with nonzero addend"),
		 name, input_bfd, input_section, rel->r_offset);
	      return FALSE;

	    }

	  break;

	default:
	  picrel = NULL;
	  if (h && ! FRV_SYM_LOCAL (info, h))
	    {
	      info->callbacks->warning
		(info, _("relocation references symbol not defined in the module"),
		 name, input_bfd, input_section, rel->r_offset);
	      return FALSE;
	    }
	  break;
	}

      switch (r_type)
	{
	case R_FRV_LABEL24:
	  check_segment[0] = isec_segment;
	  if (picrel->plt)
	    {
	      relocation = frv_plt_section (info)->output_section->vma
		+ frv_plt_section (info)->output_offset
		+ picrel->plt_entry;
	      check_segment[1] = plt_segment;
	    }
	  /* We don't want to warn on calls to undefined weak symbols,
	     as calls to them must be protected by non-NULL tests
	     anyway, and unprotected calls would invoke undefined
	     behavior.  */
	  else if (picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefweak)
	    check_segment[1] = check_segment[0];
	  else
	    check_segment[1] = sec
	      ? _frv_osec_to_segment (output_bfd, sec->output_section)
	      : (unsigned)-1;
	  break;

	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	  relocation = picrel->got_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;
	  
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	  relocation = picrel->fdgot_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;
	  
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFLO:
	  relocation -= frv_got_section (info)->output_section->vma
	    + frv_got_section (info)->output_offset
	    + frv_got_initial_offset (info);
	  check_segment[0] = got_segment;
	  check_segment[1] = sec
	    ? _frv_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;

	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	  relocation = picrel->fd_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_FRV_FUNCDESC:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;

	    /* If the symbol is dynamic and there may be dynamic
	       symbol resolution because we are or are linked with a
	       shared library, emit a FUNCDESC relocation such that
	       the dynamic linker will allocate the function
	       descriptor.  */
	    if (h && ! FRV_FUNCDESC_LOCAL (info, h))
	      {
		if (addend)
		  {
		    info->callbacks->warning
		      (info, _("R_FRV_FUNCDESC references dynamic symbol with nonzero addend"),
		       name, input_bfd, input_section, rel->r_offset);
		    return FALSE;
		  }
		dynindx = h->dynindx;
	      }
	    else
	      {
		/* Otherwise, we know we have a private function
		   descriptor, so reference it directly.  */
		BFD_ASSERT (picrel->privfd);
		r_type = R_FRV_32;
		dynindx = elf_section_data (frv_got_section
					    (info)->output_section)->dynindx;
		addend = frv_got_section (info)->output_offset
		  + frv_got_initial_offset (info)
		  + picrel->fd_entry;
	      }

	    /* If there is room for dynamic symbol resolution, emit
	       the dynamic relocation.  However, if we're linking an
	       executable at a fixed location, we won't have emitted a
	       dynamic symbol entry for the got section, so idx will
	       be zero, which means we can and should compute the
	       address of the private descriptor ourselves.  */
	    if (info->executable && !info->pie
		&& (!h || FRV_FUNCDESC_LOCAL (info, h)))
	      {
		addend += frv_got_section (info)->output_section->vma;
		if ((bfd_get_section_flags (output_bfd,
					   input_section->output_section)
		     & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_frv_osec_readonly_p (output_bfd,
					      input_section->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit fixups in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    if (! h || h->root.type != bfd_link_hash_undefweak)
		      _frv_add_rofixup (output_bfd,
					frv_gotfixup_section (info),
					_bfd_elf_section_offset
					(output_bfd, info,
					 input_section, rel->r_offset)
					+ input_section->output_section->vma
					+ input_section->output_offset);
		  }
	      }
	    else if ((bfd_get_section_flags (output_bfd,
					     input_section->output_section)
		      & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
	      {
		if (_frv_osec_readonly_p (output_bfd,
					  input_section->output_section))
		  {
		    info->callbacks->warning
		      (info,
		       _("cannot emit dynamic relocations in read-only section"),
		       name, input_bfd, input_section, rel->r_offset);
		    return FALSE;
		  }
		_frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
				    _bfd_elf_section_offset
				    (output_bfd, info,
				     input_section, rel->r_offset)
				    + input_section->output_section->vma
				    + input_section->output_offset,
				    r_type, dynindx, addend);
	      }

	    /* We want the addend in-place because dynamic
	       relocations are REL.  Setting relocation to it should
	       arrange for it to be installed.  */
	    relocation = addend - rel->r_addend;
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_FRV_32:
	case R_FRV_FUNCDESC_VALUE:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;

	    /* If the symbol is dynamic but binds locally, use
	       section+offset.  */
	    if (h && ! FRV_SYM_LOCAL (info, h))
	      {
		if (addend && r_type == R_FRV_FUNCDESC_VALUE)
		  {
		    info->callbacks->warning
		      (info, _("R_FRV_FUNCDESC_VALUE references dynamic symbol with nonzero addend"),
		       name, input_bfd, input_section, rel->r_offset);
		    return FALSE;
		  }
		dynindx = h->dynindx;
	      }
	    else
	      {
		if (h)
		  addend += h->root.u.def.value;
		else
		  addend += sym->st_value;
		if (osec)
		  addend += osec->output_offset;
		if (osec && osec->output_section
		    && ! bfd_is_abs_section (osec->output_section)
		    && ! bfd_is_und_section (osec->output_section))
		  dynindx = elf_section_data (osec->output_section)->dynindx;
		else
		  dynindx = 0;
	      }

	    /* If we're linking an executable at a fixed address, we
	       can omit the dynamic relocation as long as the symbol
	       is defined in the current link unit (which is implied
	       by its output section not being NULL).  */
	    if (info->executable && !info->pie
		&& (!h || FRV_SYM_LOCAL (info, h)))
	      {
		if (osec)
		  addend += osec->output_section->vma;
		if ((elf_elfheader (input_bfd)->e_flags & EF_FRV_FDPIC)
		    && (bfd_get_section_flags (output_bfd,
					       input_section->output_section)
			& (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_frv_osec_readonly_p (output_bfd,
					      input_section->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit fixups in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    if (!h || h->root.type != bfd_link_hash_undefweak)
		      {
			_frv_add_rofixup (output_bfd,
					  frv_gotfixup_section (info),
					  _bfd_elf_section_offset
					  (output_bfd, info,
					   input_section, rel->r_offset)
					  + input_section->output_section->vma
					  + input_section->output_offset);
			if (r_type == R_FRV_FUNCDESC_VALUE)
			  _frv_add_rofixup
			    (output_bfd,
			     frv_gotfixup_section (info),
			     _bfd_elf_section_offset
			     (output_bfd, info,
			      input_section, rel->r_offset)
			     + input_section->output_section->vma
			     + input_section->output_offset + 4);
		      }
		  }
	      }
	    else
	      {
		if ((bfd_get_section_flags (output_bfd,
					    input_section->output_section)
		     & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_frv_osec_readonly_p (output_bfd,
					      input_section->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit dynamic relocations in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    _frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
					_bfd_elf_section_offset
					(output_bfd, info,
					 input_section, rel->r_offset)
					+ input_section->output_section->vma
					+ input_section->output_offset,
					r_type, dynindx, addend);
		  }
		/* We want the addend in-place because dynamic
		   relocations are REL.  Setting relocation to it
		   should arrange for it to be installed.  */
		relocation = addend - rel->r_addend;
	      }

	    if (r_type == R_FRV_FUNCDESC_VALUE)
	      {
		/* If we've omitted the dynamic relocation, just emit
		   the fixed addresses of the symbol and of the local
		   GOT base offset.  */
		if (info->executable && !info->pie
		    && (!h || FRV_SYM_LOCAL (info, h)))
		  bfd_put_32 (output_bfd,
			      frv_got_section (info)->output_section->vma
			      + frv_got_section (info)->output_offset
			      + frv_got_initial_offset (info),
			      contents + rel->r_offset + 4);
		else
		  /* A function descriptor used for lazy or local
		     resolving is initialized such that its high word
		     contains the output section index in which the
		     PLT entries are located, and the low word
		     contains the offset of the lazy PLT entry entry
		     point into that section.  */
		  bfd_put_32 (output_bfd,
			      h && ! FRV_SYM_LOCAL (info, h)
			      ? 0
			      : _frv_osec_to_segment (output_bfd,
						      sec->output_section),
			      contents + rel->r_offset + 4);
	      }
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_FRV_GPREL12:
	case R_FRV_GPRELU12:
	case R_FRV_GPREL32:
	case R_FRV_GPRELHI:
	case R_FRV_GPRELLO:
	  check_segment[0] = gprel_segment;
	  check_segment[1] = sec
	    ? _frv_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;

	default:
	  check_segment[0] = isec_segment;
	  check_segment[1] = sec
	    ? _frv_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;
	}

      if (check_segment[0] != check_segment[1]
	  && (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC))
	{
#if 1
	  /* This helps catch problems in GCC while we can't do more
	     than static linking.  The idea is to test whether the
	     input file basename is crt0.o only once.  */
	  if (silence_segment_error == 1)
	    silence_segment_error =
	      (strlen (input_bfd->filename) == 6
	       && strcmp (input_bfd->filename, "crt0.o") == 0)
	      || (strlen (input_bfd->filename) > 6
		  && strcmp (input_bfd->filename
			     + strlen (input_bfd->filename) - 7,
			     "/crt0.o") == 0)
	      ? -1 : 0;
#endif
	  if (!silence_segment_error
	      /* We don't want duplicate errors for undefined
		 symbols.  */
	      && !(picrel && picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefined))
	    info->callbacks->warning
	      (info,
	       (info->shared || info->pie)
	       ? _("relocations between different segments are not supported")
	       : _("warning: relocation references a different segment"),
	       name, input_bfd, input_section, rel->r_offset);
	  if (!silence_segment_error && (info->shared || info->pie))
	    return FALSE;
	  elf_elfheader (output_bfd)->e_flags |= EF_FRV_PIC;
	}

      switch (r_type)
	{
	case R_FRV_GOTOFFHI:
	  /* We need the addend to be applied before we shift the
	     value right.  */
	  relocation += rel->r_addend;
	  /* Fall through.  */
	case R_FRV_GOTHI:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTOFFHI:
	  relocation >>= 16;
	  /* Fall through.  */

	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_GOTOFFLO:
	case R_FRV_FUNCDESC_GOTOFFLO:
	  relocation &= 0xffff;
	  break;

	default:
	  break;
	}

      switch (r_type)
	{
	case R_FRV_LABEL24:
	  if (! picrel->plt)
	    break;
	  /* Fall through.  */
	  
	  /* When referencing a GOT entry, a function descriptor or a
	     PLT, we don't want the addend to apply to the reference,
	     but rather to the referenced symbol.  The actual entry
	     will have already been created taking the addend into
	     account, so cancel it out here.  */
	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	  /* Note that we only want GOTOFFHI, not GOTOFFLO or GOTOFF12
	     here, since we do want to apply the addend to the others.
	     Note that we've applied the addend to GOTOFFHI before we
	     shifted it right.  */ 
	case R_FRV_GOTOFFHI:
	  relocation -= rel->r_addend;
	  break;

	default:
	  break;
	}

     if (r_type == R_FRV_HI16)
       r = elf32_frv_relocate_hi16 (input_bfd, rel, contents, relocation);

     else if (r_type == R_FRV_LO16)
       r = elf32_frv_relocate_lo16 (input_bfd, rel, contents, relocation);

     else if (r_type == R_FRV_LABEL24)
       r = elf32_frv_relocate_label24 (input_bfd, input_section, rel,
				       contents, relocation);

     else if (r_type == R_FRV_GPREL12)
       r = elf32_frv_relocate_gprel12 (info, input_bfd, input_section, rel,
				       contents, relocation);

     else if (r_type == R_FRV_GPRELU12)
       r = elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, rel,
					contents, relocation);

     else if (r_type == R_FRV_GPRELLO)
       r = elf32_frv_relocate_gprello (info, input_bfd, input_section, rel,
				       contents, relocation);

     else if (r_type == R_FRV_GPRELHI)
       r = elf32_frv_relocate_gprelhi (info, input_bfd, input_section, rel,
				       contents, relocation);

     else
       r = frv_final_link_relocate (howto, input_bfd, input_section, contents,
				    rel, relocation);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
elf32_frv_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_FRV_GNU_VTINHERIT:
	case R_FRV_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf32_frv_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
  return TRUE;
}


/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put .comm items in .scomm, and not .comm.  */

static bfd_boolean
elf32_frv_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
{
  if (sym->st_shndx == SHN_COMMON
      && !info->relocatable
      && (int)sym->st_size <= (int)bfd_get_gp_size (abfd))
    {
      /* Common symbols less than or equal to -G nn bytes are
	 automatically put into .sbss.  */

      asection *scomm = bfd_get_section_by_name (abfd, ".scommon");

      if (scomm == NULL)
	{
	  scomm = bfd_make_section (abfd, ".scommon");
	  if (scomm == NULL
	      || !bfd_set_section_flags (abfd, scomm, (SEC_ALLOC
						       | SEC_IS_COMMON
						       | SEC_LINKER_CREATED)))
	    return FALSE;
	}

      *secp = scomm;
      *valp = sym->st_size;
    }

  return TRUE;
}
/* Create a .got section, as well as its additional info field.  This
   is almost entirely copied from
   elflink.c:_bfd_elf_create_got_section().  */

static bfd_boolean
_frv_create_got_section (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags;
  asection *s;
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int ptralign;

  /* This function may be called more than once.  */
  s = bfd_get_section_by_name (abfd, ".got");
  if (s != NULL && (s->flags & SEC_LINKER_CREATED) != 0)
    return TRUE;

  /* Machine specific: although pointers are 32-bits wide, we want the
     GOT to be aligned to a 64-bit boundary, such that function
     descriptors in it can be accessed with 64-bit loads and
     stores.  */
  ptralign = 3;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  s = bfd_make_section (abfd, ".got");
  if (s == NULL
      || !bfd_set_section_flags (abfd, s, flags)
      || !bfd_set_section_alignment (abfd, s, ptralign))
    return FALSE;

  if (bed->want_got_plt)
    {
      s = bfd_make_section (abfd, ".got.plt");
      if (s == NULL
	  || !bfd_set_section_flags (abfd, s, flags)
	  || !bfd_set_section_alignment (abfd, s, ptralign))
	return FALSE;
    }

  if (bed->want_got_sym)
    {
      /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
	 (or .got.plt) section.  We don't do this in the linker script
	 because we don't want to define the symbol if we are not creating
	 a global offset table.  */
      bh = NULL;
      if (!(_bfd_generic_link_add_one_symbol
	    (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
	     bed->got_symbol_offset, (const char *) NULL, FALSE,
	     bed->collect, &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_OBJECT;

      /* Machine-specific: we want the symbol for executables as
	 well.  */
      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;

      elf_hash_table (info)->hgot = h;
    }

  /* The first bit of the global offset table is the header.  */
  s->_raw_size += bed->got_header_size + bed->got_symbol_offset;

  /* This is the machine-specific part.  Create and initialize section
     data for the got.  */
  frv_got_section (info) = s;
  frv_relocs_info (info) = htab_try_create (1, frv_pic_relocs_info_hash,
					    frv_pic_relocs_info_eq,
					    (htab_del) NULL);
  if (! frv_relocs_info (info))
    return FALSE;

  s = bfd_make_section (abfd, ".rel.got");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, s, 2))
    return FALSE;

  frv_gotrel_section (info) = s;

  /* Machine-specific.  */
  s = bfd_make_section (abfd, ".rofixup");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, s, 2))
    return FALSE;

  frv_gotfixup_section (info) = s;

  /* Define _gp in .rofixup, for FDPIC.  If it turns out that
     we're linking with a different linker script, the linker script
     will override it.  */
  bh = NULL;
  if (!(_bfd_generic_link_add_one_symbol
	(info, abfd, "_gp", BSF_GLOBAL, s, -2048, (const char *) NULL, FALSE,
	 bed->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  /* Machine-specific: we want the symbol for executables as well.  */
  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;
  
  return TRUE;
}

/* Make sure the got and plt sections exist, and that our pointers in
   the link hash table point to them.  */

static bfd_boolean
elf32_frv_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  /* This is mostly copied from
     elflink.c:_bfd_elf_create_dynamic_sections().  */
  flagword flags, pltflags;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  pltflags = flags;
  pltflags |= SEC_CODE;
  if (bed->plt_not_loaded)
    pltflags &= ~ (SEC_CODE | SEC_LOAD | SEC_HAS_CONTENTS);
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  s = bfd_make_section (abfd, ".plt");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, pltflags)
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;
  /* FRV-specific: remember it.  */
  frv_plt_section (info) = s;

  if (bed->want_plt_sym)
    {
      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
	 .plt section.  */
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s, 0, NULL,
	      FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_OBJECT;

      if (! info->executable
	  && ! _bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }

  /* FRV-specific: we want rel relocations for the plt.  */
  s = bfd_make_section (abfd, ".rel.plt");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  /* FRV-specific: remember it.  */
  frv_pltrel_section (info) = s;

  /* FRV-specific: we want to create the GOT in the FRV way.  */
  if (! _frv_create_got_section (abfd, info))
    return FALSE;

  /* FRV-specific: make sure we created everything we wanted.  */
  BFD_ASSERT (frv_got_section (info) && frv_gotrel_section (info)
	      && frv_gotfixup_section (info)
	      && frv_plt_section (info) && frv_pltrel_section (info));

  if (bed->want_dynbss)
    {
      /* The .dynbss section is a place to put symbols which are defined
	 by dynamic objects, are referenced by regular objects, and are
	 not functions.  We must allocate space for them in the process
	 image and use a R_*_COPY reloc to tell the dynamic linker to
	 initialize them at run time.  The linker script puts the .dynbss
	 section into the .bss section of the final image.  */
      s = bfd_make_section (abfd, ".dynbss");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC | SEC_LINKER_CREATED))
	return FALSE;

      /* The .rel[a].bss section holds copy relocs.  This section is not
     normally needed.  We need to create it here, though, so that the
     linker will map it to an output section.  We can't just create it
     only if we need it, because we will not know whether we need it
     until we have seen all the input files, and the first time the
     main linker code calls BFD after examining all the input files
     (size_dynamic_sections) the input sections have already been
     mapped to the output sections.  If the section turns out not to
     be needed, we can discard it later.  We will never need this
     section when generating a shared object, since they do not use
     copy relocs.  */
      if (! info->shared)
	{
	  s = bfd_make_section (abfd,
				(bed->default_use_rela_p
				 ? ".rela.bss" : ".rel.bss"));
	  if (s == NULL
	      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
	    return FALSE;
	}
    }

  return TRUE;
}

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so.1"

#define DEFAULT_STACK_SIZE 0x20000

/* This structure is used to collect the number of entries present in
   each addressable range of the got.  */
struct _frv_dynamic_got_info
{
  /* Several bits of information about the current link.  */
  struct bfd_link_info *info;
  /* Total size needed for GOT entries within the 12-, 16- or 32-bit
     ranges.  */
  bfd_vma got12, gotlos, gothilo;
  /* Total size needed for function descriptor entries within the 12-,
     16- or 32-bit ranges.  */
  bfd_vma fd12, fdlos, fdhilo;
  /* Total size needed function descriptor entries referenced in PLT
     entries, that would be profitable to place in offsets close to
     the PIC register.  */
  bfd_vma fdplt;
  /* Total size needed by lazy PLT entries.  */
  bfd_vma lzplt;
  /* Number of relocations carried over from input object files.  */
  unsigned long relocs;
  /* Number of fixups introduced by relocations in input object files.  */
  unsigned long fixups;
};

/* Compute the total GOT size required by each symbol in each range.
   Symbols may require up to 4 words in the GOT: an entry pointing to
   the symbol, an entry pointing to its function descriptor, and a
   private function descriptors taking two words.  */

static int
_frv_count_got_plt_entries (void **entryp, void *dinfo_)
{
  struct frv_pic_relocs_info *entry = *entryp;
  struct _frv_dynamic_got_info *dinfo = dinfo_;

  /* Allocate space for a GOT entry pointing to the symbol.  */
  if (entry->got12)
    dinfo->got12 += 4;
  else if (entry->gotlos)
    dinfo->gotlos += 4;
  else if (entry->gothilo)
    dinfo->gothilo += 4;
  else
    entry->relocs32--;
  entry->relocs32++;

  /* Allocate space for a GOT entry pointing to the function
     descriptor.  */
  if (entry->fdgot12)
    dinfo->got12 += 4;
  else if (entry->fdgotlos)
    dinfo->gotlos += 4;
  else if (entry->fdgothilo)
    dinfo->gothilo += 4;
  else
    entry->relocsfd--;
  entry->relocsfd++;

  /* Decide whether we need a PLT entry, a function descriptor in the
     GOT, and a lazy PLT entry for this symbol.  */
  entry->plt = entry->call
    && entry->symndx == -1 && ! FRV_SYM_LOCAL (dinfo->info, entry->d.h)
    && elf_hash_table (dinfo->info)->dynamic_sections_created;
  entry->privfd = entry->plt
    || entry->fdgoff12 || entry->fdgofflos || entry->fdgoffhilo
    || ((entry->fd || entry->fdgot12 || entry->fdgotlos || entry->fdgothilo)
	&& (entry->symndx != -1
	    || FRV_FUNCDESC_LOCAL (dinfo->info, entry->d.h)));
  entry->lazyplt = entry->privfd
    && entry->symndx == -1 && ! FRV_SYM_LOCAL (dinfo->info, entry->d.h)
    && ! (dinfo->info->flags & DF_BIND_NOW)
    && elf_hash_table (dinfo->info)->dynamic_sections_created;

  /* Allocate space for a function descriptor.  */
  if (entry->fdgoff12)
    dinfo->fd12 += 8;
  else if (entry->fdgofflos)
    dinfo->fdlos += 8;
  else if (entry->privfd && entry->plt)
    dinfo->fdplt += 8;
  else if (entry->privfd)
    dinfo->fdhilo += 8;
  else
    entry->relocsfdv--;
  entry->relocsfdv++;

  if (entry->lazyplt)
    dinfo->lzplt += 8;

  if (!dinfo->info->executable || dinfo->info->pie)
    dinfo->relocs += entry->relocs32 + entry->relocsfd + entry->relocsfdv;
  else
    {
      if (entry->symndx != -1 || FRV_SYM_LOCAL (dinfo->info, entry->d.h))
	{
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)	  
	    dinfo->fixups += entry->relocs32 + 2 * entry->relocsfdv;
	}
      else
	dinfo->relocs += entry->relocs32 + entry->relocsfdv;
      if (entry->symndx != -1 || FRV_FUNCDESC_LOCAL (dinfo->info, entry->d.h))
	{
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    dinfo->fixups += entry->relocsfd;
	}
      else
	dinfo->relocs += entry->relocsfd;
    }

  return 1;
}

/* This structure is used to assign offsets to got entries, function
   descriptors, plt entries and lazy plt entries.  */

struct _frv_dynamic_got_plt_info
{
  /* Summary information collected with _frv_count_got_plt_entries.  */
  struct _frv_dynamic_got_info g;

  /* For each addressable range, we record a MAX (positive) and MIN
     (negative) value.  CUR is used to assign got entries, and it's
     incremented from an initial positive value to MAX, then from MIN
     to FDCUR (unless FDCUR wraps around first).  FDCUR is used to
     assign function descriptors, and it's decreased from an initial
     non-positive value to MIN, then from MAX down to CUR (unless CUR
     wraps around first).  All of MIN, MAX, CUR and FDCUR always point
     to even words.  ODD, if non-zero, indicates an odd word to be
     used for the next got entry, otherwise CUR is used and
     incremented by a pair of words, wrapping around when it reaches
     MAX.  FDCUR is decremented (and wrapped) before the next function
     descriptor is chosen.  FDPLT indicates the number of remaining
     slots that can be used for function descriptors used only by PLT
     entries.  */
  struct _frv_dynamic_got_alloc_data
  {
    bfd_signed_vma max, cur, odd, fdcur, min;
    bfd_vma fdplt;
  } got12, gotlos, gothilo;
};

/* Determine the positive and negative ranges to be used by each
   offset range in the GOT.  FDCUR and CUR, that must be aligned to a
   double-word boundary, are the minimum (negative) and maximum
   (positive) GOT offsets already used by previous ranges, except for
   an ODD entry that may have been left behind.  GOT and FD indicate
   the size of GOT entries and function descriptors that must be
   placed within the range from -WRAP to WRAP.  If there's room left,
   up to FDPLT bytes should be reserved for additional function
   descriptors.  */

inline static bfd_signed_vma
_frv_compute_got_alloc_data (struct _frv_dynamic_got_alloc_data *gad,
			     bfd_signed_vma fdcur,
			     bfd_signed_vma odd,
			     bfd_signed_vma cur,
			     bfd_vma got,
			     bfd_vma fd,
			     bfd_vma fdplt,
			     bfd_vma wrap)
{
  bfd_signed_vma wrapmin = -wrap;

  /* Start at the given initial points.  */
  gad->fdcur = fdcur;
  gad->cur = cur;

  /* If we had an incoming odd word and we have any got entries that
     are going to use it, consume it, otherwise leave gad->odd at
     zero.  We might force gad->odd to zero and return the incoming
     odd such that it is used by the next range, but then GOT entries
     might appear to be out of order and we wouldn't be able to
     shorten the GOT by one word if it turns out to end with an
     unpaired GOT entry.  */
  if (odd && got)
    {
      gad->odd = odd;
      got -= 4;
      odd = 0;
    }
  else
    gad->odd = 0;

  /* If we're left with an unpaired GOT entry, compute its location
     such that we can return it.  Otherwise, if got doesn't require an
     odd number of words here, either odd was already zero in the
     block above, or it was set to zero because got was non-zero, or
     got was already zero.  In the latter case, we want the value of
     odd to carry over to the return statement, so we don't want to
     reset odd unless the condition below is true.  */
  if (got & 4)
    {
      odd = cur + got;
      got += 4;
    }
  
  /* Compute the tentative boundaries of this range.  */
  gad->max = cur + got;
  gad->min = fdcur - fd;
  gad->fdplt = 0;

  /* If function descriptors took too much space, wrap some of them
     around.  */
  if (gad->min < wrapmin)
    {
      gad->max += wrapmin - gad->min;
      gad->min = wrapmin;
    }
  /* If there is space left and we have function descriptors
     referenced in PLT entries that could take advantage of shorter
     offsets, place them here.  */
  else if (fdplt && gad->min > wrapmin)
    {
      bfd_vma fds;
      if ((bfd_vma) (gad->min - wrapmin) < fdplt)
	fds = gad->min - wrapmin;
      else
	fds = fdplt;

      fdplt -= fds;
      gad->min -= fds;
      gad->fdplt += fds;
    }

  /* If GOT entries took too much space, wrap some of them around.
     This may well cause gad->min to become lower than wrapmin.  This
     will cause a relocation overflow later on, so we don't have to
     report it here . */
  if ((bfd_vma) gad->max > wrap)
    {
      gad->min -= gad->max - wrap;
      gad->max = wrap;
    }
  /* If there is more space left, try to place some more function
     descriptors for PLT entries.  */
  else if (fdplt && (bfd_vma) gad->max < wrap)
    {
      bfd_vma fds;
      if ((bfd_vma) (wrap - gad->max) < fdplt)
	fds = wrap - gad->max;
      else
	fds = fdplt;

      fdplt -= fds;
      gad->max += fds;
      gad->fdplt += fds;
    }

  /* If odd was initially computed as an offset past the wrap point,
     wrap it around.  */
  if (odd > gad->max)
    odd = gad->min + odd - gad->max;

  /* _frv_get_got_entry() below will always wrap gad->cur if needed
     before returning, so do it here too.  This guarantees that,
     should cur and fdcur meet at the wrap point, they'll both be
     equal to min.  */
  if (gad->cur == gad->max)
    gad->cur = gad->min;

  return odd;
}

/* Compute the location of the next GOT entry, given the allocation
   data for a range.  */

inline static bfd_signed_vma
_frv_get_got_entry (struct _frv_dynamic_got_alloc_data *gad)
{
  bfd_signed_vma ret;
  
  if (gad->odd)
    {
      /* If there was an odd word left behind, use it.  */
      ret = gad->odd;
      gad->odd = 0;
    }
  else
    {
      /* Otherwise, use the word pointed to by cur, reserve the next
	 as an odd word, and skip to the next pair of words, possibly
	 wrapping around.  */
      ret = gad->cur;
      gad->odd = gad->cur + 4;
      gad->cur += 8;
      if (gad->cur == gad->max)
	gad->cur = gad->min;
    }

  return ret;
}

/* Compute the location of the next function descriptor entry in the
   GOT, given the allocation data for a range.  */

inline static bfd_signed_vma
_frv_get_fd_entry (struct _frv_dynamic_got_alloc_data *gad)
{
  /* If we're at the bottom, wrap around, and only then allocate the
     next pair of words.  */
  if (gad->fdcur == gad->min)
    gad->fdcur = gad->max;
  return gad->fdcur -= 8;
}

/* Assign GOT offsets for every GOT entry and function descriptor.
   Doing everything in a single pass is tricky.  */

static int
_frv_assign_got_entries (void **entryp, void *info_)
{
  struct frv_pic_relocs_info *entry = *entryp;
  struct _frv_dynamic_got_plt_info *dinfo = info_;

  if (entry->got12)
    entry->got_entry = _frv_get_got_entry (&dinfo->got12);
  else if (entry->gotlos)
    entry->got_entry = _frv_get_got_entry (&dinfo->gotlos);
  else if (entry->gothilo)
    entry->got_entry = _frv_get_got_entry (&dinfo->gothilo);

  if (entry->fdgot12)
    entry->fdgot_entry = _frv_get_got_entry (&dinfo->got12);
  else if (entry->fdgotlos)
    entry->fdgot_entry = _frv_get_got_entry (&dinfo->gotlos);
  else if (entry->fdgothilo)
    entry->fdgot_entry = _frv_get_got_entry (&dinfo->gothilo);

  if (entry->fdgoff12)
    entry->fd_entry = _frv_get_fd_entry (&dinfo->got12);
  else if (entry->plt && dinfo->got12.fdplt)
    {
      dinfo->got12.fdplt -= 8;
      entry->fd_entry = _frv_get_fd_entry (&dinfo->got12);
    }
  else if (entry->fdgofflos)
    entry->fd_entry = _frv_get_fd_entry (&dinfo->gotlos);
  else if (entry->plt && dinfo->gotlos.fdplt)
    {
      dinfo->gotlos.fdplt -= 8;
      entry->fd_entry = _frv_get_fd_entry (&dinfo->gotlos);
    }
  else if (entry->plt)
    {
      dinfo->gothilo.fdplt -= 8;
      entry->fd_entry = _frv_get_fd_entry (&dinfo->gothilo);
    }
  else if (entry->privfd)
    entry->fd_entry = _frv_get_fd_entry (&dinfo->gothilo);
  
  return 1;
}

/* Assign GOT offsets to private function descriptors used by PLT
   entries (or referenced by 32-bit offsets), as well as PLT entries
   and lazy PLT entries.  */

static int
_frv_assign_plt_entries (void **entryp, void *info_)
{
  struct frv_pic_relocs_info *entry = *entryp;
  struct _frv_dynamic_got_plt_info *dinfo = info_;

  /* If this symbol requires a local function descriptor, allocate
     one.  */
  if (entry->privfd && entry->fd_entry == 0)
    {
      if (dinfo->got12.fdplt)
	{
	  entry->fd_entry = _frv_get_fd_entry (&dinfo->got12);
	  dinfo->got12.fdplt -= 8;
	}
      else if (dinfo->gotlos.fdplt)
	{
	  entry->fd_entry = _frv_get_fd_entry (&dinfo->gotlos);
	  dinfo->gotlos.fdplt -= 8;
	}
      else
	{
	  BFD_ASSERT (dinfo->gothilo.fdplt)
	  entry->fd_entry = _frv_get_fd_entry (&dinfo->gothilo);
	  dinfo->gothilo.fdplt -= 8;
	}
    }

  if (entry->plt)
    {
      int size;

      /* We use the section's raw size to mark the location of the
	 next PLT entry.  */
      entry->plt_entry = frv_plt_section (dinfo->g.info)->_raw_size;

      /* Figure out the length of this PLT entry based on the
	 addressing mode we need to reach the function descriptor.  */
      BFD_ASSERT (entry->fd_entry);
      if (entry->fd_entry >= -(1 << (12 - 1))
	  && entry->fd_entry < (1 << (12 - 1)))
	size = 8;
      else if (entry->fd_entry >= -(1 << (16 - 1))
	       && entry->fd_entry < (1 << (16 - 1)))
	size = 12;
      else
	size = 16;

      frv_plt_section (dinfo->g.info)->_raw_size += size;
    }

  if (entry->lazyplt)
    {
      entry->lzplt_entry = dinfo->g.lzplt;
      dinfo->g.lzplt += 8;
      /* If this entry is the one that gets the resolver stub, account
	 for the additional instruction.  */
      if (entry->lzplt_entry % FRV_LZPLT_BLOCK_SIZE == FRV_LZPLT_RESOLV_LOC)
	dinfo->g.lzplt += 4;
    }
      
  return 1;
}  

/* Follow indirect and warning hash entries so that each got entry
   points to the final symbol definition.  P must point to a pointer
   to the hash table we're traversing.  Since this traversal may
   modify the hash table, we set this pointer to NULL to indicate
   we've made a potentially-destructive change to the hash table, so
   the traversal must be restarted.  */
static int
_frv_resolve_final_relocs_info (void **entryp, void *p)
{
  struct frv_pic_relocs_info *entry = *entryp;
  htab_t *htab = p;

  if (entry->symndx == -1)
    {
      struct elf_link_hash_entry *h = entry->d.h;

      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *)h->root.u.i.link;

      if (entry->d.h == h)
	return 1;

      entry->d.h = h;

      /* If we can't find this entry with the new bfd hash, re-insert
	 it, and get the traversal restarted.  */
      if (! htab_find (*htab, entry))
	{
	  htab_clear_slot (*htab, entryp);
	  entryp = htab_find_slot (*htab, entry, INSERT);
	  if (! *entryp)
	    *entryp = entry;
	  /* Abort the traversal, since the whole table may have
	     moved, and leave it up to the parent to restart the
	     process.  */
	  *(htab_t *)p = NULL;
	  return 0;
	}
    }

  return 1;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf32_frv_size_dynamic_sections (bfd *output_bfd,
				 struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  struct _frv_dynamic_got_plt_info gpinfo;
  bfd_signed_vma odd;
  bfd_vma limit;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  memset (&gpinfo, 0, sizeof (gpinfo));
  gpinfo.g.info = info;

  for (;;)
    {
      htab_t relocs = frv_relocs_info (info);

      htab_traverse (relocs, _frv_resolve_final_relocs_info, &relocs);

      if (relocs == frv_relocs_info (info))
	break;
    }

  htab_traverse (frv_relocs_info (info), _frv_count_got_plt_entries,
		 &gpinfo.g);

  odd = 12;
  /* Compute the total size taken by entries in the 12-bit and 16-bit
     ranges, to tell how many PLT function descriptors we can bring
     into the 12-bit range without causing the 16-bit range to
     overflow.  */
  limit = odd + gpinfo.g.got12 + gpinfo.g.gotlos
    + gpinfo.g.fd12 + gpinfo.g.fdlos;
  if (limit < (bfd_vma)1 << 16)
    limit = ((bfd_vma)1 << 16) - limit;
  else
    limit = 0;
  if (gpinfo.g.fdplt < limit)
    limit = gpinfo.g.fdplt;

  /* Determine the ranges of GOT offsets that we can use for each
     range of addressing modes.  */
  odd = _frv_compute_got_alloc_data (&gpinfo.got12,
				     0,
				     odd,
				     16,
				     gpinfo.g.got12,
				     gpinfo.g.fd12,
				     limit,
				     (bfd_vma)1 << (12-1));
  odd = _frv_compute_got_alloc_data (&gpinfo.gotlos,
				     gpinfo.got12.min,
				     odd,
				     gpinfo.got12.max,
				     gpinfo.g.gotlos,
				     gpinfo.g.fdlos,
				     gpinfo.g.fdplt - gpinfo.got12.fdplt,
				     (bfd_vma)1 << (16-1));
  odd = _frv_compute_got_alloc_data (&gpinfo.gothilo,
				     gpinfo.gotlos.min,
				     odd,
				     gpinfo.gotlos.max,
				     gpinfo.g.gothilo,
				     gpinfo.g.fdhilo,
				     gpinfo.g.fdplt - gpinfo.got12.fdplt
				     - gpinfo.gotlos.fdplt,
				     (bfd_vma)1 << (32-1));

  /* Now assign (most) GOT offsets.  */
  htab_traverse (frv_relocs_info (info), _frv_assign_got_entries, &gpinfo);

  frv_got_section (info)->_raw_size = gpinfo.gothilo.max - gpinfo.gothilo.min
    /* If an odd word is the last word of the GOT, we don't need this
       word to be part of the GOT.  */
    - (odd + 4 == gpinfo.gothilo.max ? 4 : 0);
  if (frv_got_section (info)->_raw_size == 0)
    frv_got_section (info)->flags |= SEC_EXCLUDE;
  else if (frv_got_section (info)->_raw_size == 12
	   && ! elf_hash_table (info)->dynamic_sections_created)
    {
      frv_got_section (info)->flags |= SEC_EXCLUDE;
      frv_got_section (info)->_raw_size = 0;
    }
  else
    {
      frv_got_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj, frv_got_section (info)->_raw_size);
      if (frv_got_section (info)->contents == NULL)
	return FALSE;
    }
  
  if (elf_hash_table (info)->dynamic_sections_created)
    /* Subtract the number of lzplt entries, since those will generate
       relocations in the pltrel section.  */
    frv_gotrel_section (info)->_raw_size =
      (gpinfo.g.relocs - gpinfo.g.lzplt / 8)
      * get_elf_backend_data (output_bfd)->s->sizeof_rel;
  else
    BFD_ASSERT (gpinfo.g.relocs == 0);
  if (frv_gotrel_section (info)->_raw_size == 0)
    frv_gotrel_section (info)->flags |= SEC_EXCLUDE;
  else
    {
      frv_gotrel_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj, frv_gotrel_section (info)->_raw_size);
      if (frv_gotrel_section (info)->contents == NULL)
	return FALSE;
    }

  if (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
    frv_gotfixup_section (info)->_raw_size = (gpinfo.g.fixups + 1) * 4;
  if (frv_gotfixup_section (info)->_raw_size == 0)
    frv_gotfixup_section (info)->flags |= SEC_EXCLUDE;
  else
    {
      frv_gotfixup_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 frv_gotfixup_section (info)->_raw_size);
      if (frv_gotfixup_section (info)->contents == NULL)
	return FALSE;
    }
  
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      frv_pltrel_section (info)->_raw_size =
	gpinfo.g.lzplt / 8 * get_elf_backend_data (output_bfd)->s->sizeof_rel;
      if (frv_pltrel_section (info)->_raw_size == 0)
	frv_pltrel_section (info)->flags |= SEC_EXCLUDE;
      else
d725 7
a731 5
	  frv_pltrel_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj,
				     frv_pltrel_section (info)->_raw_size);
	  if (frv_pltrel_section (info)->contents == NULL)
	    return FALSE;
a732 38
    }
  
  /* Add 4 bytes for every block of at most 65535 lazy PLT entries,
     such that there's room for the additional instruction needed to
     call the resolver.  Since _frv_assign_got_entries didn't account
     for them, our block size is 4 bytes smaller than the real block
     size.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      frv_plt_section (info)->_raw_size = gpinfo.g.lzplt
	+ ((gpinfo.g.lzplt + (FRV_LZPLT_BLOCK_SIZE - 4) - 8)
	   / (FRV_LZPLT_BLOCK_SIZE - 4) * 4);
    }

  /* Reset it, such that _frv_assign_plt_entries() can use it to
     actually assign lazy PLT entries addresses.  */
  gpinfo.g.lzplt = 0;

  /* Save information that we're going to need to generate GOT and PLT
     entries.  */
  frv_got_initial_offset (info) = -gpinfo.gothilo.min;

  if (get_elf_backend_data (output_bfd)->want_got_sym)
    elf_hash_table (info)->hgot->root.u.def.value
      += frv_got_initial_offset (info);

  if (elf_hash_table (info)->dynamic_sections_created)
    frv_plt_initial_offset (info) = frv_plt_section (info)->_raw_size;

  htab_traverse (frv_relocs_info (info), _frv_assign_plt_entries, &gpinfo);

  /* Allocate the PLT section contents only after
     _frv_assign_plt_entries has a chance to add the size of the
     non-lazy PLT entries.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      if (frv_plt_section (info)->_raw_size == 0)
	frv_plt_section (info)->flags |= SEC_EXCLUDE;
d735 1
a735 6
	  frv_plt_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj, frv_plt_section (info)->_raw_size);
	  if (frv_plt_section (info)->contents == NULL)
	    return FALSE;
	}
    }
d737 3
a739 19
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      if (frv_got_section (info)->_raw_size)
	if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0))
	  return FALSE;

      if (frv_pltrel_section (info)->_raw_size)
	if (! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_REL)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
	  return FALSE;

      if (frv_gotrel_section (info)->_raw_size)
	if (! bfd_elf32_add_dynamic_entry (info, DT_REL, 0)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_RELSZ, 0)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_RELENT,
					      sizeof (Elf32_External_Rel)))
	  return FALSE;
    }
d741 1
a741 2
  return TRUE;
}
d743 21
a763 9
static bfd_boolean
elf32_frv_always_size_sections (bfd *output_bfd,
				struct bfd_link_info *info)
{
  if (!info->relocatable
      && elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
    {
      struct elf_link_hash_entry *h;
      asection *sec;
d765 2
a766 12
      /* Force a PT_GNU_STACK segment to be created.  */
      if (! elf_tdata (output_bfd)->stack_flags)
	elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;

      /* Define __stacksize if it's not defined yet.  */
      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				FALSE, FALSE, FALSE);
      if (! h || h->root.type != bfd_link_hash_defined
	  || h->type != STT_OBJECT
	  || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	{
	  struct bfd_link_hash_entry *bh;
d768 2
a769 6
	  if (!(_bfd_generic_link_add_one_symbol
		(info, output_bfd, "__stacksize",
		 BSF_GLOBAL, bfd_abs_section_ptr, DEFAULT_STACK_SIZE,
		 (const char *) NULL, FALSE,
		 get_elf_backend_data (output_bfd)->collect, &bh)))
	    return FALSE;
d771 3
a773 4
	  h = (struct elf_link_hash_entry *) bh;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  h->type = STT_OBJECT;
	}
d775 3
a777 2
      /* Create a stack section, and set its alignment.  */
      sec = bfd_make_section (output_bfd, ".stack");
d779 3
a781 4
      if (sec == NULL
	  || ! bfd_set_section_alignment (output_bfd, sec, 3))
	return FALSE;
    }
d783 3
a785 2
  return TRUE;
}
d787 3
a789 7
static bfd_boolean
elf32_frv_modify_segment_map (bfd *output_bfd,
			      struct bfd_link_info *info)
{
  if (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
    {
      struct elf_segment_map *m;
d791 3
a793 3
      for (m = elf_tdata (output_bfd)->segment_map; m != NULL; m = m->next)
	if (m->p_type == PT_GNU_STACK)
	  break;
d795 1
a795 1
      if (m)
d797 1
a797 2
	  asection *sec = bfd_get_section_by_name (output_bfd, ".stack");
	  struct elf_link_hash_entry *h;
d799 1
a799 1
	  if (sec)
d801 5
a805 23
	      /* Obtain the pointer to the __stacksize symbol.  */
	      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
					FALSE, FALSE, FALSE);
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *)h->root.u.i.link;
	      BFD_ASSERT (h->root.type == bfd_link_hash_defined);

	      /* Set the section size from the symbol value.  We
		 intentionally ignore the symbol section.  */
	      if (h->root.type == bfd_link_hash_defined)
		sec->_raw_size = h->root.u.def.value;
	      else
		sec->_raw_size = DEFAULT_STACK_SIZE;

	      /* Add the stack section to the PT_GNU_STACK segment,
		 such that its size and alignment requirements make it
		 to the segment.  */
	      m->sections[m->count] = sec;
	      m->count++;
	    }
	}
    }
d807 4
a810 2
  return TRUE;
}
d812 3
a814 1
/* Fill in code and data in dynamic sections.  */
d816 3
a818 6
static bfd_boolean
elf32_frv_finish_dynamic_sections (bfd *output_bfd,
				   struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sdyn;
d820 3
a822 1
  dynobj = elf_hash_table (info)->dynobj;
d824 4
a827 5
  if (frv_got_section (info))
    {
      BFD_ASSERT (frv_gotrel_section (info)->_raw_size
		  == (frv_gotrel_section (info)->reloc_count
		      * sizeof (Elf32_External_Rel)));
d829 3
a831 8
      if (frv_gotfixup_section (info))
	{
	  if (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
	    {
	      struct elf_link_hash_entry *hgot = elf_hash_table (info)->hgot;
	      bfd_vma got_value = hgot->root.u.def.value
		+ hgot->root.u.def.section->output_section->vma
		+ hgot->root.u.def.section->output_offset;
d833 2
a834 16
	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				got_value);
	    }

	  if (frv_gotfixup_section (info)->_raw_size
	      != (frv_gotfixup_section (info)->reloc_count * 4))
	    {
	      if (!elf_hash_table (info)->dynamic_sections_created)
		{
		  info->callbacks->warning
		    (info, "no dynamic sections, missing -melf32frvfd?",
		     ".rofixup", NULL, NULL, 0);
		  return FALSE;
		}
	      BFD_ASSERT (0);
	    }
a836 6
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      BFD_ASSERT (frv_pltrel_section (info)->_raw_size
		  == (frv_pltrel_section (info)->reloc_count
		      * sizeof (Elf32_External_Rel)));
    }
d838 5
a842 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d844 9
a852 1
  if (elf_hash_table (info)->dynamic_sections_created)
d854 1
a854 9
      Elf32_External_Dyn * dyncon;
      Elf32_External_Dyn * dynconend;

      BFD_ASSERT (sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);

      for (; dyncon < dynconend; dyncon++)
d856 3
a858 1
	  Elf_Internal_Dyn dyn;
d860 2
a861 3
	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
d866 3
a868 6
	    case DT_PLTGOT:
	      dyn.d_un.d_ptr = frv_got_section (info)->output_section->vma
		+ frv_got_section (info)->output_offset
		+ frv_got_initial_offset (info);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
d870 2
a871 13
	    case DT_JMPREL:
	      dyn.d_un.d_ptr = frv_pltrel_section (info)->output_section->vma
		+ frv_pltrel_section (info)->output_offset;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      if (frv_pltrel_section (info)->_cooked_size != 0)
		dyn.d_un.d_val = frv_pltrel_section (info)->_cooked_size;
	      else
		dyn.d_un.d_val = frv_pltrel_section (info)->_raw_size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
d875 2
d878 1
a878 1
  return TRUE;
d881 1
a881 2
/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  */
d884 5
a888 2
elf32_frv_adjust_dynamic_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
				 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
d890 2
a891 1
  bfd * dynobj;
d893 3
a895 1
  dynobj = elf_hash_table (info)->dynobj;
d897 13
a909 14
  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->weakdef != NULL
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
d911 4
a914 5
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
    }
d916 9
a924 2
  return TRUE;
}
d926 3
a928 1
/* Perform any actions needed for dynamic symbols.  */
a929 6
static bfd_boolean
elf32_frv_finish_dynamic_symbol (bfd *output_bfd ATTRIBUTE_UNUSED,
				 struct bfd_link_info *info ATTRIBUTE_UNUSED,
				 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED,
				 Elf_Internal_Sym *sym ATTRIBUTE_UNUSED)
{
a931 1

d933 2
a934 102

   Besides handling virtual table relocs for gc, we have to deal with
   all sorts of PIC-related relocations.  We describe below the
   general plan on how to handle such relocations, even though we only
   collect information at this point, storing them in hash tables for
   perusal of later passes.

   32 relocations are propagated to the linker output when creating
   position-independent output.  LO16 and HI16 relocations are not
   supposed to be encountered in this case.

   LABEL16 should always be resolvable by the linker, since it's only
   used by branches.

   LABEL24, on the other hand, is used by calls.  If it turns out that
   the target of a call is a dynamic symbol, a PLT entry must be
   created for it, which triggers the creation of a private function
   descriptor and, unless lazy binding is disabled, a lazy PLT entry.

   GPREL relocations require the referenced symbol to be in the same
   segment as _gp, but this can only be checked later.

   All GOT, GOTOFF and FUNCDESC relocations require a .got section to
   exist.  LABEL24 might as well, since it may require a PLT entry,
   that will require a got.

   Non-FUNCDESC GOT relocations require a GOT entry to be created
   regardless of whether the symbol is dynamic.  However, since a
   global symbol that turns out to not be exported may have the same
   address of a non-dynamic symbol, we don't assign GOT entries at
   this point, such that we can share them in this case.  A relocation
   for the GOT entry always has to be created, be it to offset a
   private symbol by the section load address, be it to get the symbol
   resolved dynamically.

   FUNCDESC GOT relocations require a GOT entry to be created, and
   handled as if a FUNCDESC relocation was applied to the GOT entry in
   an object file.

   FUNCDESC relocations referencing a symbol that turns out to NOT be
   dynamic cause a private function descriptor to be created.  The
   FUNCDESC relocation then decays to a 32 relocation that points at
   the private descriptor.  If the symbol is dynamic, the FUNCDESC
   relocation is propagated to the linker output, such that the
   dynamic linker creates the canonical descriptor, pointing to the
   dynamically-resolved definition of the function.

   Non-FUNCDESC GOTOFF relocations must always refer to non-dynamic
   symbols that are assigned to the same segment as the GOT, but we
   can only check this later, after we know the complete set of
   symbols defined and/or exported.

   FUNCDESC GOTOFF relocations require a function descriptor to be
   created and, unless lazy binding is disabled or the symbol is not
   dynamic, a lazy PLT entry.  Since we can't tell at this point
   whether a symbol is going to be dynamic, we have to decide later
   whether to create a lazy PLT entry or bind the descriptor directly
   to the private function.

   FUNCDESC_VALUE relocations are not supposed to be present in object
   files, but they may very well be simply propagated to the linker
   output, since they have no side effect.


   A function descriptor always requires a FUNCDESC_VALUE relocation.
   Whether it's in .plt.rel or not depends on whether lazy binding is
   enabled and on whether the referenced symbol is dynamic.

   The existence of a lazy PLT requires the resolverStub lazy PLT
   entry to be present.


   As for assignment of GOT, PLT and lazy PLT entries, and private
   descriptors, we might do them all sequentially, but we can do
   better than that.  For example, we can place GOT entries and
   private function descriptors referenced using 12-bit operands
   closer to the PIC register value, such that these relocations don't
   overflow.  Those that are only referenced with LO16 relocations
   could come next, but we may as well place PLT-required function
   descriptors in the 12-bit range to make them shorter.  Symbols
   referenced with LO16/HI16 may come next, but we may place
   additional function descriptors in the 16-bit range if we can
   reliably tell that we've already placed entries that are ever
   referenced with only LO16.  PLT entries are therefore generated as
   small as possible, while not introducing relocation overflows in
   GOT or FUNCDESC_GOTOFF relocations.  Lazy PLT entries could be
   generated before or after PLT entries, but not intermingled with
   them, such that we can have more lazy PLT entries in range for a
   branch to the resolverStub.  The resolverStub should be emitted at
   the most distant location from the first lazy PLT entry such that
   it's still in range for a branch, or closer, if there isn't a need
   for so many lazy PLT entries.  Additional lazy PLT entries may be
   emitted after the resolverStub, as long as branches are still in
   range.  If the branch goes out of range, longer lazy PLT entries
   are emitted.

   We could further optimize PLT and lazy PLT entries by giving them
   priority in assignment to closer-to-gr17 locations depending on the
   number of occurrences of references to them (assuming a function
   that's called more often is more important for performance, so its
   PLT entry should be faster), or taking hints from the compiler.
   Given infinite time and money... :-)  */
a946 2
  bfd *dynobj;
  struct frv_pic_relocs_info *picrel;
a956 1
  dynobj = elf_hash_table (info)->dynobj;
a969 54
	{
	case R_FRV_LABEL24:
	case R_FRV_32:
	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFFLO:
	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	case R_FRV_FUNCDESC:
	case R_FRV_FUNCDESC_VALUE:
	  if (! dynobj)
	    {
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _frv_create_got_section (abfd, info))
		return FALSE;
	    }
	  if (h != NULL)
	    {
	      if (h->dynindx == -1)
		switch (ELF_ST_VISIBILITY (h->other))
		  {
		  case STV_INTERNAL:
		  case STV_HIDDEN:
		    break;
		  default:
		    bfd_elf32_link_record_dynamic_symbol (info, h);
		    break;
		  }
	      picrel
		= frv_pic_relocs_info_for_global (frv_relocs_info (info),
						  abfd, h,
						  rel->r_addend);
	    }
	  else
	    picrel = frv_pic_relocs_info_for_local (frv_relocs_info (info),
						    abfd, r_symndx,
						    rel->r_addend);
	  if (! picrel)
	    return FALSE;
	  break;

	default:
	  picrel = NULL;
	  break;
	}
      
      switch (ELF32_R_TYPE (rel->r_info))
a970 53
	case R_FRV_LABEL24:
	  picrel->call = 1;
	  break;
		
	case R_FRV_FUNCDESC_VALUE:
	  picrel->relocsfdv++;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32--;
	  /* Fall through.  */
	case R_FRV_32:
	  picrel->sym = 1;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32++;
	  break;
	    
	case R_FRV_GOT12:
	  picrel->got12 = 1;
	  break;
	    
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	  picrel->gothilo = 1;
	  break;

	case R_FRV_FUNCDESC_GOT12:
	  picrel->fdgot12 = 1;
	  break;
	    
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	  picrel->fdgothilo = 1;
	  break;
	    
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFFLO:
	  picrel->gotoff = 1;
	  break;
	    
	case R_FRV_FUNCDESC_GOTOFF12:
	  picrel->fdgoff12 = 1;
	  break;
	    
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	  picrel->fdgoffhilo = 1;
	  break;
	    
	case R_FRV_FUNCDESC:
	  picrel->fd = 1;
	  picrel->relocsfd++;
	  break;
	  
a1069 3
  if (new_flags & EF_FRV_FDPIC)
    new_flags &= ~EF_FRV_PIC;

a1371 6
  if (flags & EF_FRV_LIBPIC)
    fprintf (file, " -mlibrary-pic");

  if (flags & EF_FRV_FDPIC)
    fprintf (file, " -mfdpic");
  
d1390 1
a1390 1
#define elf_info_to_howto_rel			frv_info_to_howto_rel
a1406 29

#define bfd_elf32_bfd_link_hash_table_create  frv_elf_link_hash_table_create
#define elf_backend_always_size_sections \
		elf32_frv_always_size_sections
#define elf_backend_modify_segment_map \
		elf32_frv_modify_segment_map

#define elf_backend_create_dynamic_sections \
		elf32_frv_create_dynamic_sections
#define elf_backend_adjust_dynamic_symbol \
		elf32_frv_adjust_dynamic_symbol
#define elf_backend_size_dynamic_sections \
		elf32_frv_size_dynamic_sections
#define elf_backend_finish_dynamic_symbol \
		elf32_frv_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
		elf32_frv_finish_dynamic_sections

#define elf_backend_want_got_sym	1
#define elf_backend_got_header_size	0
#define elf_backend_want_got_plt	0
#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_plt_header_size	0

#define elf_backend_may_use_rel_p       1
#define elf_backend_may_use_rela_p      1
/* We use REL for dynamic relocations only.  */
#define elf_backend_default_use_rela_p  1
@


1.3.12.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3457 1
a3457 1
	  struct bfd_link_hash_entry *bh = NULL;
@


1.3.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d2 1
a2 1
   Copyright 2002 Free Software Foundation, Inc.
d34 1
a34 2
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
d36 1
a36 2
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
d38 1
a38 2
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
d40 1
a40 2
  PARAMS ((struct bfd_link_info *, bfd *, asection *, Elf_Internal_Rela *,
	   bfd_byte *, bfd_vma));
d43 6
a48 8
static void frv_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean elf32_frv_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf32_frv_add_symbol_hook
  PARAMS (( bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	    const char **, flagword *, asection **, bfd_vma *));
d50 3
a52 5
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
static bfd_boolean elf32_frv_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *, const
	   Elf_Internal_Rela *));
d54 9
a62 17
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf32_frv_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static int elf32_frv_machine
  PARAMS ((bfd *));
static bfd_boolean elf32_frv_object_p
  PARAMS ((bfd *));
static bfd_boolean frv_elf_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean frv_elf_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean frv_elf_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean frv_elf_print_private_bfd_data
  PARAMS ((bfd *, PTR));
d71 1
a71 1
	 FALSE,			/* pc_relative */
d76 1
a76 1
	 FALSE,			/* partial_inplace */
d79 1
a79 1
	 FALSE),		/* pcrel_offset */
d86 1
a86 1
	 FALSE,			/* pc_relative */
d91 1
a91 1
	 FALSE,			/* partial_inplace */
d94 1
a94 1
	 FALSE),		/* pcrel_offset */
d101 1
a101 1
	 TRUE,			/* pc_relative */
d106 1
a106 1
	 FALSE,			/* partial_inplace */
d109 1
a109 1
	 TRUE),		        /* pcrel_offset */
d116 1
a116 1
	 TRUE,			/* pc_relative */
d121 1
a121 1
	 FALSE,			/* partial_inplace */
d124 1
a124 1
	 TRUE),		        /* pcrel_offset */
d130 1
a130 1
	 FALSE,			/* pc_relative */
d135 1
a135 1
	 FALSE,			/* partial_inplace */
d138 1
a138 1
	 FALSE),	        /* pcrel_offset */
d144 1
a144 1
	 FALSE,			/* pc_relative */
d149 1
a149 1
	 FALSE,			/* partial_inplace */
d152 1
a152 1
	 FALSE),	        /* pcrel_offset */
d158 1
a158 1
	 FALSE,			/* pc_relative */
d163 1
a163 1
	 FALSE,			/* partial_inplace */
d166 1
a166 1
	 FALSE),	        /* pcrel_offset */
d172 1
a172 1
	 FALSE,			/* pc_relative */
d177 1
a177 1
	 FALSE,			/* partial_inplace */
d180 1
a180 1
	 FALSE),	        /* pcrel_offset */
d186 1
a186 1
	 FALSE,			/* pc_relative */
d191 1
a191 1
	 FALSE,			/* partial_inplace */
d194 1
a194 1
	 FALSE),	        /* pcrel_offset */
d200 1
a200 1
	 FALSE,			/* pc_relative */
d205 1
a205 1
	 FALSE,			/* partial_inplace */
d208 1
a208 1
	 FALSE),	        /* pcrel_offset */
d214 1
a214 1
	 FALSE,			/* pc_relative */
d219 1
a219 1
	 FALSE,			/* partial_inplace */
d222 1
a222 1
	 FALSE),	        /* pcrel_offset */
d231 1
a231 1
         FALSE,                 /* pc_relative */
d236 1
a236 1
         FALSE,                 /* partial_inplace */
d239 1
a239 1
         FALSE);                /* pcrel_offset */
d247 1
a247 1
         FALSE,                 /* pc_relative */
d252 1
a252 1
         FALSE,                 /* partial_inplace */
d255 1
a255 1
         FALSE);                /* pcrel_offset */
d286 1
a286 2
elf32_frv_relocate_gprel12 (info, input_bfd, input_section, relocation,
			    contents, value)
d298 1
a298 1
  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d324 1
a324 2
elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, relocation,
			     contents, value)
d337 1
a337 1
  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d342 1
a342 1

d426 1
a426 1
    0 000000 0001111 000000000000000000
d456 1
a456 2
elf32_frv_relocate_gprelhi (info, input_bfd, input_section, relocation,
			    contents, value)
d468 1
a468 1
  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d490 1
a490 2
elf32_frv_relocate_gprello (info, input_bfd, input_section, relocation,
			    contents, value)
d502 1
a502 1
  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d526 1
a526 1
     bfd *abfd ATTRIBUTE_UNUSED;
d536 1
a536 1

d582 3
a584 3
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d609 7
a615 8
frv_final_link_relocate (howto, input_bfd, input_section, contents, rel,
			 relocation)
     reloc_howto_type *howto;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *rel;
     bfd_vma relocation;
d653 1
a653 1
static bfd_boolean
d656 13
a668 13
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
d671 1
a671 1
    return TRUE;
d679 10
a688 10
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char * name = NULL;
      int r_type;

d690 1
a690 1

d694 1
a694 1

d701 1
a701 1

d709 1
a709 1

d717 1
a717 1

d723 1
a723 1

d740 2
a741 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d745 1
a745 1

d753 1
a753 2
       r = elf32_frv_relocate_label24 (input_bfd, input_section, rel,
				       contents, relocation);
d756 1
a756 2
       r = elf32_frv_relocate_gprel12 (info, input_bfd, input_section, rel,
				       contents, relocation);
d759 1
a759 2
       r = elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, rel,
					contents, relocation);
d762 1
a762 2
       r = elf32_frv_relocate_gprello (info, input_bfd, input_section, rel,
				       contents, relocation);
d765 1
a765 2
       r = elf32_frv_relocate_gprelhi (info, input_bfd, input_section, rel,
				       contents, relocation);
d768 1
a768 2
       r = frv_final_link_relocate (howto, input_bfd, input_section, contents,
				    rel, relocation);
d781 1
a781 1

d784 1
a784 1
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
d786 1
a786 1

d809 1
a809 1
	    return FALSE;
d813 1
a813 1
  return TRUE;
d821 5
a825 5
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d858 1
a858 1
static bfd_boolean
d860 4
a863 4
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d865 1
a865 1
  return TRUE;
d872 1
a872 1
static bfd_boolean
d898 1
a898 1
	    return FALSE;
d905 1
a905 1
  return TRUE;
d910 2
a911 2

static bfd_boolean
d922 1
a922 1

d924 2
a925 2
    return TRUE;

d931 1
a931 1

d937 1
a937 1

d943 1
a943 1

d950 1
a950 1
            return FALSE;
d952 1
a952 1

d957 1
a957 1
            return FALSE;
d961 2
a962 2

  return TRUE;
d987 1
a987 1
static bfd_boolean
d992 1
a992 1
  return TRUE;
d997 1
a997 1
static bfd_boolean
d1003 2
a1004 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d1009 1
a1009 1
static bfd_boolean
d1016 1
a1016 1
    return TRUE;
d1022 2
a1023 2
  elf_flags_init (obfd) = TRUE;
  return TRUE;
d1029 1
a1029 1
static bfd_boolean
d1036 1
a1036 1
  bfd_boolean error = FALSE;
d1052 1
a1052 1
      elf_flags_init (obfd) = TRUE;
d1194 1
a1194 1
	      error = TRUE;
d1240 1
a1240 1

d1244 1
a1244 1
	  error = TRUE;
d1256 1
a1256 1
	  error = TRUE;
d1280 1
a1280 1
bfd_boolean
d1350 1
a1350 1
  return TRUE;
@


1.3.10.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d654 1
a654 1
   necessary, and (if using Rela relocs and generating a relocatable
d668 1
a668 1
   When generating relocatable output, this function must handle
d691 1
a691 1
  if (info->relocatable)
d910 1
a910 1
      && !info->relocatable
d950 1
a950 1
  if (info->relocatable)
@


1.3.10.3
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d727 3
a729 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.3.10.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d114 1
a114 1
	 2,			/* rightshift */
d727 1
a727 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
a999 1
    case EF_FRV_CPU_FR550:  return bfd_mach_fr550;
a1247 1
	    case EF_FRV_CPU_FR550:   strcat (new_opt, " -mcpu=fr550");  break;
a1258 1
	    case EF_FRV_CPU_FR550:   strcat (old_opt, " -mcpu=fr550");  break;
a1324 1
    case EF_FRV_CPU_FR550:  fprintf (file, " -mcpu=fr550");	break;
@


1.3.10.5
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@a24 1
#include "hashtab.h"
a238 223

  /* A 12-bit signed operand with the GOT offset for the address of
     the symbol.  */
  HOWTO (R_FRV_GOT12,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOT12",		/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTHI,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTHI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		        /* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTLO,	        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTLO",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The 32-bit address of the canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOT12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOT12", /* name */
	 FALSE,			/* partial_inplace */
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTHI,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTHI", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTLO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTLO", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The 32-bit address of the canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_VALUE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_VALUE", /* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTOFF12, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTOFF12", /* name */
	 FALSE,			/* partial_inplace */
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTOFFHI, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTOFFHI", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_FRV_FUNCDESC_GOTOFFLO, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_GOTOFFLO", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     the symbol.  */
  HOWTO (R_FRV_GOTOFF12,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTOFF12",	/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,		        /* src_mask */
	 0xfff,		        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTOFFHI,        /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTOFFHI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_FRV_GOTOFFLO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_GOTOFFLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

a271 48

/* The following 3 relocations are REL.  The only difference to the
   entries in the table above are that partial_inplace is TRUE.  */
static reloc_howto_type elf32_frv_rel_32_howto =
  HOWTO (R_FRV_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

static reloc_howto_type elf32_frv_rel_funcdesc_howto =
  HOWTO (R_FRV_FUNCDESC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

static reloc_howto_type elf32_frv_rel_funcdesc_value_howto =
  HOWTO (R_FRV_FUNCDESC_VALUE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_FRV_FUNCDESC_VALUE", /* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE);		/* pcrel_offset */

a293 14
  { BFD_RELOC_FRV_GOT12,      R_FRV_GOT12 },
  { BFD_RELOC_FRV_GOTHI,      R_FRV_GOTHI },
  { BFD_RELOC_FRV_GOTLO,      R_FRV_GOTLO },
  { BFD_RELOC_FRV_FUNCDESC,   R_FRV_FUNCDESC },
  { BFD_RELOC_FRV_FUNCDESC_GOT12, R_FRV_FUNCDESC_GOT12 },
  { BFD_RELOC_FRV_FUNCDESC_GOTHI, R_FRV_FUNCDESC_GOTHI },
  { BFD_RELOC_FRV_FUNCDESC_GOTLO, R_FRV_FUNCDESC_GOTLO },
  { BFD_RELOC_FRV_FUNCDESC_VALUE, R_FRV_FUNCDESC_VALUE },
  { BFD_RELOC_FRV_FUNCDESC_GOTOFF12, R_FRV_FUNCDESC_GOTOFF12 },
  { BFD_RELOC_FRV_FUNCDESC_GOTOFFHI, R_FRV_FUNCDESC_GOTOFFHI },
  { BFD_RELOC_FRV_FUNCDESC_GOTOFFLO, R_FRV_FUNCDESC_GOTOFFLO },
  { BFD_RELOC_FRV_GOTOFF12,   R_FRV_GOTOFF12 },
  { BFD_RELOC_FRV_GOTOFFHI,   R_FRV_GOTOFFHI },
  { BFD_RELOC_FRV_GOTOFFLO,   R_FRV_GOTOFFLO },
d299 1
d301 9
a309 3
/* An extension of the elf hash table data structure, containing some
   additional FRV-specific data.  */
struct frv_elf_link_hash_table
d311 3
a313 1
  struct elf_link_hash_table elf;
d315 1
a315 19
  /* A pointer to the .got section.  */
  asection *sgot;
  /* A pointer to the .rel.got section.  */
  asection *sgotrel;
  /* A pointer to the .rofixup section.  */
  asection *sgotfixup;
  /* A pointer to the .plt section.  */
  asection *splt;
  /* A pointer to the .rel.plt section.  */
  asection *spltrel;
  /* GOT base offset.  */
  bfd_vma got0;
  /* Location of the first non-lazy PLT entry, i.e., the number of
     bytes taken by lazy PLT entries.  */
  bfd_vma plt0;
  /* A hash table holding information about which symbols were
     referenced with which PIC-related relocations.  */
  struct htab *relocs_info;
};
d317 3
a319 1
/* Get the FRV ELF linker hash table from a link_info structure.  */
d321 2
a322 2
#define frv_hash_table(info) \
  ((struct frv_elf_link_hash_table *) ((info)->hash))
d324 1
a324 16
#define frv_got_section(info) \
  (frv_hash_table (info)->sgot)
#define frv_gotrel_section(info) \
  (frv_hash_table (info)->sgotrel)
#define frv_gotfixup_section(info) \
  (frv_hash_table (info)->sgotfixup)
#define frv_plt_section(info) \
  (frv_hash_table (info)->splt)
#define frv_pltrel_section(info) \
  (frv_hash_table (info)->spltrel)
#define frv_relocs_info(info) \
  (frv_hash_table (info)->relocs_info)
#define frv_got_initial_offset(info) \
  (frv_hash_table (info)->got0)
#define frv_plt_initial_offset(info) \
  (frv_hash_table (info)->plt0)
d326 1
a326 1
/* Create an FRV ELF linker hash table.  */
d328 2
a329 5
static struct bfd_link_hash_table *
frv_elf_link_hash_table_create (bfd *abfd)
{
  struct frv_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct frv_elf_link_hash_table);
d331 3
a333 3
  ret = bfd_zalloc (abfd, amt);
  if (ret == NULL)
    return NULL;
d335 1
a335 8
  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd,
				       _bfd_elf_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }

  return &ret->elf.root;
d338 1
a338 106
/* Decide whether a reference to a symbol can be resolved locally or
   not.  If the symbol is protected, we want the local address, but
   its function descriptor must be assigned by the dynamic linker.  */
#define FRV_SYM_LOCAL(INFO, H) \
  (_bfd_elf_symbol_refs_local_p ((H), (INFO), 1) \
   || ! elf_hash_table (INFO)->dynamic_sections_created \
   || (H)->root.type == bfd_link_hash_undefweak \
   || (/* The condition below is an ugly hack to get .scommon data to
	  be regarded as local.  For some reason the
	  ELF_LINK_HASH_DEF_REGULAR bit is not set on such common
	  symbols, and the SEC_IS_COMMON bit is not set any longer
	  when we need to perform this test.  Hopefully this
	  approximation is good enough.  */ \
       ((H)->root.type == bfd_link_hash_defined \
	|| (H)->root.type == bfd_link_hash_defweak) \
       && (H)->root.u.def.section->output_section \
       && ((H)->root.u.def.section->flags & SEC_LINKER_CREATED)))
#define FRV_FUNCDESC_LOCAL(INFO, H) \
  ((H)->dynindx == -1 || ! elf_hash_table (INFO)->dynamic_sections_created)

/* This structure collects information on what kind of GOT, PLT or
   function descriptors are required by relocations that reference a
   certain symbol.  */
struct frv_pic_relocs_info
{
  /* The index of the symbol, as stored in the relocation r_info, if
     we have a local symbol; -1 otherwise.  */
  long symndx;
  union
  {
    /* The input bfd in which the symbol is defined, if it's a local
       symbol.  */
    bfd *abfd;
    /* If symndx == -1, the hash table entry corresponding to a global
       symbol (even if it turns out to bind locally, in which case it
       should ideally be replaced with section's symndx + addend).  */
    struct elf_link_hash_entry *h;
  } d;
  /* The addend of the relocation that references the symbol.  */
  bfd_vma addend;

  /* The fields above are used to identify an entry.  The fields below
     contain information on how an entry is used and, later on, which
     locations it was assigned.  */
  /* The following 3 fields record whether the symbol+addend above was
     ever referenced with a GOT relocation.  The 12 suffix indicates a
     GOT12 relocation; los is used for GOTLO relocations that are not
     matched by a GOTHI relocation; hilo is used for GOTLO/GOTHI
     pairs.  */
  unsigned got12:1;
  unsigned gotlos:1;
  unsigned gothilo:1;
  /* Whether a FUNCDESC relocation references symbol+addend.  */
  unsigned fd:1;
  /* Whether a FUNCDESC_GOT relocation references symbol+addend.  */
  unsigned fdgot12:1;
  unsigned fdgotlos:1;
  unsigned fdgothilo:1;
  /* Whether a FUNCDESC_GOTOFF relocation references symbol+addend.  */
  unsigned fdgoff12:1;
  unsigned fdgofflos:1;
  unsigned fdgoffhilo:1;
  /* Whether symbol+addend is referenced with GOTOFF12, GOTOFFLO or
     GOTOFFHI relocations.  The addend doesn't really matter, since we
     envision that this will only be used to check whether the symbol
     is mapped to the same segment as the got.  */
  unsigned gotoff:1;
  /* Whether symbol+addend is referenced by a LABEL24 relocation.  */
  unsigned call:1;
  /* Whether symbol+addend is referenced by a 32 or FUNCDESC_VALUE
     relocation.  */
  unsigned sym:1;
  /* Whether we need a PLT entry for a symbol.  Should be implied by
     something like:
     (call && symndx == -1 && ! FRV_SYM_LOCAL (info, d.h))  */
  unsigned plt:1;
  /* Whether a function descriptor should be created in this link unit
     for symbol+addend.  Should be implied by something like:
     (plt || fdgotoff12 || fdgotofflos || fdgotofflohi
      || ((fd || fdgot12 || fdgotlos || fdgothilo)
          && (symndx != -1 || FRV_FUNCDESC_LOCAL (info, d.h))))  */
  unsigned privfd:1;
  /* Whether a lazy PLT entry is needed for this symbol+addend.
     Should be implied by something like:
     (privfd && symndx == -1 && ! FRV_SYM_LOCAL (info, d.h)
      && ! (info->flags & DF_BIND_NOW))  */
  unsigned lazyplt:1;
  /* Whether we've already emitted GOT relocations and PLT entries as
     needed for this symbol.  */
  unsigned done:1;

  /* The number of R_FRV_32, R_FRV_FUNCDESC and R_FRV_FUNCDESC_VALUE
     relocations referencing the symbol.  */
  unsigned relocs32, relocsfd, relocsfdv;

  /* The offsets of the GOT entries assigned to symbol+addend, to the
     function descriptor's address, and to a function descriptor,
     respectively.  Should be zero if unassigned.  The offsets are
     counted from the value that will be assigned to the PIC register,
     not from the beginning of the .got section.  */
  bfd_signed_vma got_entry, fdgot_entry, fd_entry;
  /* The offsets of the PLT entries assigned to symbol+addend,
     non-lazy and lazy, respectively.  If unassigned, should be
     (bfd_vma)-1.  */
  bfd_vma plt_entry, lzplt_entry;
};
d340 9
a348 3
/* Compute a hash with the key fields of an frv_pic_relocs_info entry.  */
static hashval_t
frv_pic_relocs_info_hash (const void *entry_)
d350 4
a353 1
  const struct frv_pic_relocs_info *entry = entry_;
d355 1
a355 4
  return (entry->symndx == -1
	  ? entry->d.h->root.root.hash
	  : entry->symndx + entry->d.abfd->id * 257) + entry->addend;
}
d357 3
a359 7
/* Test whether the key fields of two frv_pic_relocs_info entries are
   identical.  */
static int
frv_pic_relocs_info_eq (const void *entry1, const void *entry2)
{
  const struct frv_pic_relocs_info *e1 = entry1;
  const struct frv_pic_relocs_info *e2 = entry2;
d361 2
a362 3
  return e1->symndx == e2->symndx && e1->addend == e2->addend
    && (e1->symndx == -1 ? e1->d.h == e2->d.h : e1->d.abfd == e2->d.abfd);
}
d364 1
a364 583
/* Find or create an entry in a hash table HT that matches the key
   fields of the given ENTRY.  If it's not found, memory for a new
   entry is allocated in ABFD's obstack.  */
static struct frv_pic_relocs_info *
frv_pic_relocs_info_find (struct htab *ht,
			  bfd *abfd,
			  const struct frv_pic_relocs_info *entry)
{
  struct frv_pic_relocs_info **loc =
    (struct frv_pic_relocs_info **) htab_find_slot (ht, entry, INSERT);

  if (*loc)
    return *loc;

  *loc = bfd_zalloc (abfd, sizeof (**loc));

  if (! *loc)
    return *loc;

  (*loc)->symndx = entry->symndx;
  (*loc)->d = entry->d;
  (*loc)->addend = entry->addend;
  (*loc)->plt_entry = (bfd_vma)-1;
  (*loc)->lzplt_entry = (bfd_vma)-1;

  return *loc;
}

/* Obtain the address of the entry in HT associated with H's symbol +
   addend, creating a new entry if none existed.  ABFD is only used
   for memory allocation purposes.  */
inline static struct frv_pic_relocs_info *
frv_pic_relocs_info_for_global (struct htab *ht,
				bfd *abfd,
				struct elf_link_hash_entry *h,
				bfd_vma addend)
{
  struct frv_pic_relocs_info entry;

  entry.symndx = -1;
  entry.d.h = h;
  entry.addend = addend;

  return frv_pic_relocs_info_find (ht, abfd, &entry);
}

/* Obtain the address of the entry in HT associated with the SYMNDXth
   local symbol of the input bfd ABFD, plus the addend, creating a new
   entry if none existed.  */  
inline static struct frv_pic_relocs_info *
frv_pic_relocs_info_for_local (struct htab *ht,
			       bfd *abfd,
			       long symndx,
			       bfd_vma addend)
{
  struct frv_pic_relocs_info entry;

  entry.symndx = symndx;
  entry.d.abfd = abfd;
  entry.addend = addend;

  return frv_pic_relocs_info_find (ht, abfd, &entry);
}

/* Every block of 65535 lazy PLT entries shares a single call to the
   resolver, inserted in the 32768th lazy PLT entry (i.e., entry #
   32767, counting from 0).  All other lazy PLT entries branch to it
   in a single instruction.  */

#define FRV_LZPLT_BLOCK_SIZE ((bfd_vma) 8 * 65535 + 4)
#define FRV_LZPLT_RESOLV_LOC (8 * 32767)

/* Add a dynamic relocation to the SRELOC section.  */

inline static bfd_vma
_frv_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
		    int reloc_type, long dynindx, bfd_vma addend)
{
  Elf_Internal_Rela outrel;
  bfd_vma reloc_offset;

  outrel.r_offset = offset;
  outrel.r_info = ELF32_R_INFO (dynindx, reloc_type);
  outrel.r_addend = addend;

  reloc_offset = sreloc->reloc_count * sizeof (Elf32_External_Rel);
  BFD_ASSERT (reloc_offset < sreloc->_raw_size);
  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
			    sreloc->contents + reloc_offset);
  sreloc->reloc_count++;

  return reloc_offset;
}

/* Add a fixup to the ROFIXUP section.  */

static bfd_vma
_frv_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset)
{
  bfd_vma fixup_offset;

  if (rofixup->flags & SEC_EXCLUDE)
    return -1;

  fixup_offset = rofixup->reloc_count * 4;
  if (rofixup->contents)
    {
      BFD_ASSERT (fixup_offset < rofixup->_raw_size);
      bfd_put_32 (output_bfd, offset, rofixup->contents + fixup_offset);
    }
  rofixup->reloc_count++;
	      
  return fixup_offset;
}

/* Find the segment number in which OSEC, and output section, is
   located.  */

static unsigned
_frv_osec_to_segment (bfd *output_bfd, asection *osec)
{
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;

  /* Find the segment that contains the output_section.  */
  for (m = elf_tdata (output_bfd)->segment_map,
	 p = elf_tdata (output_bfd)->phdr;
       m != NULL;
       m = m->next, p++)
    {
      int i;

      for (i = m->count - 1; i >= 0; i--)
	if (m->sections[i] == osec)
	  break;

      if (i >= 0)
	break;
    }

  return p - elf_tdata (output_bfd)->phdr;
}

inline static bfd_boolean
_frv_osec_readonly_p (bfd *output_bfd, asection *osec)
{
  unsigned seg = _frv_osec_to_segment (output_bfd, osec);

  return ! (elf_tdata (output_bfd)->phdr[seg].p_flags & PF_W);
}

/* Generate relocations for GOT entries, function descriptors, and
   code for PLT and lazy PLT entries.  */

inline static bfd_boolean
_frv_emit_got_relocs_plt_entries (struct frv_pic_relocs_info *entry,
				  bfd *output_bfd,
				  struct bfd_link_info *info,
				  asection *sec,
				  Elf_Internal_Sym *sym,
				  bfd_vma addend)
				  
{
  bfd_vma fd_lazy_rel_offset = (bfd_vma)-1;
  int dynindx = -1;

  if (entry->done)
    return TRUE;
  entry->done = 1;

  if (entry->got_entry || entry->fdgot_entry || entry->fd_entry)
    {
      /* If the symbol is dynamic, consider it for dynamic
	 relocations, otherwise decay to section + offset.  */
      if (entry->symndx == -1 && entry->d.h->dynindx != -1)
	dynindx = entry->d.h->dynindx;
      else
	{
	  if (sec->output_section
	      && ! bfd_is_abs_section (sec->output_section)
	      && ! bfd_is_und_section (sec->output_section))
	    dynindx = elf_section_data (sec->output_section)->dynindx;
	  else
	    dynindx = 0;
	}
    }

  /* Generate relocation for GOT entry pointing to the symbol.  */
  if (entry->got_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;

      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}

      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma;
	  if (entry->symndx != -1 ||
	      entry->d.h->root.type != bfd_link_hash_undefweak)
	    _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
			      frv_got_section (info)->output_section->vma
			      + frv_got_section (info)->output_offset
			      + frv_got_initial_offset (info)
			      + entry->got_entry);
	}
      else
	_frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
			    _bfd_elf_section_offset
			    (output_bfd, info,
			     frv_got_section (info),
			     frv_got_initial_offset (info)
			     + entry->got_entry)
			    + frv_got_section (info)->output_section->vma
			    + frv_got_section (info)->output_offset,
			    R_FRV_32, idx, ad);
	
      bfd_put_32 (output_bfd, ad,
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
		  + entry->got_entry);
    }

  /* Generate relocation for GOT entry pointing to a canonical
     function descriptor.  */
  if (entry->fdgot_entry)
    {
      int reloc, idx;
      bfd_vma ad;
      
      /* If the symbol is dynamic and there may be dynamic symbol
	 resolution because we are or are linked with a shared
	 library, emit a FUNCDESC relocation such that the dynamic
	 linker will allocate the function descriptor.  */
      if (entry->symndx == -1 && ! FRV_FUNCDESC_LOCAL (info, entry->d.h))
	{
	  reloc = R_FRV_FUNCDESC;
	  idx = dynindx;
	  ad = addend;
	  if (ad)
	    return FALSE;
	}
      else
	{
	  /* Otherwise, we know we have a private function descriptor,
	     so reference it directly.  */
	  if (elf_hash_table (info)->dynamic_sections_created)
	    BFD_ASSERT (entry->privfd);
	  reloc = R_FRV_32;
	  idx = elf_section_data (frv_got_section (info)->output_section)
	    ->dynindx;
	  ad = frv_got_section (info)->output_offset +
	    frv_got_initial_offset (info) + entry->fd_entry;
	}

      /* If there is room for dynamic symbol resolution, emit the
	 dynamic relocation.  However, if we're linking an executable
	 at a fixed location, we won't have emitted a dynamic symbol
	 entry for the got section, so idx will be zero, which means
	 we can and should compute the address of the private
	 descriptor ourselves.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1 || FRV_FUNCDESC_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1
	      && entry->d.h->root.type == bfd_link_hash_undefweak)
	    ad = 0;
	  else
	    {
	      ad += frv_got_section (info)->output_section->vma;
	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset
				+ frv_got_initial_offset (info)
				+ entry->fdgot_entry);
	    }
	}
      else
	_frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
			    _bfd_elf_section_offset
			    (output_bfd, info,
			     frv_got_section (info),
			     frv_got_initial_offset (info)
			     + entry->fdgot_entry)
			    + frv_got_section (info)->output_section->vma
			    + frv_got_section (info)->output_offset,
			    reloc, idx, ad);

      bfd_put_32 (output_bfd, ad,
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
		  + entry->fdgot_entry);
    }

  /* Generate relocation to fill in a private function descriptor in
     the GOT.  */
  if (entry->fd_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;
      bfd_vma ofst;
      long lowword, highword;

      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}

      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1 || FRV_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma;
	  ofst = 0;
	  if (entry->symndx != -1 ||
	      entry->d.h->root.type != bfd_link_hash_undefweak)
	    {
	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset
				+ frv_got_initial_offset (info)
				+ entry->fd_entry);
	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset
				+ frv_got_initial_offset (info)
				+ entry->fd_entry + 4);
	    }
	}
      else
	{
	  ofst =
	    _frv_add_dyn_reloc (output_bfd,
				entry->lazyplt ? frv_pltrel_section (info)
				: frv_gotrel_section (info),
				_bfd_elf_section_offset
				(output_bfd, info,
				 frv_got_section (info),
				 frv_got_initial_offset (info)
				 + entry->fd_entry)
				+ frv_got_section (info)->output_section->vma
				+ frv_got_section (info)->output_offset,
				R_FRV_FUNCDESC_VALUE, idx, ad);
	}

      /* If we've omitted the dynamic relocation, just emit the fixed
	 addresses of the symbol and of the local GOT base offset.  */
      if (info->executable && !info->pie && sec && sec->output_section)
	{
	  lowword = ad;
	  highword = frv_got_section (info)->output_section->vma
	    + frv_got_section (info)->output_offset
	    + frv_got_initial_offset (info);
	}
      else if (entry->lazyplt)
	{
	  if (ad)
	    return FALSE;
	  
	  fd_lazy_rel_offset = ofst;

	  /* A function descriptor used for lazy or local resolving is
	     initialized such that its high word contains the output
	     section index in which the PLT entries are located, and
	     the low word contains the address of the lazy PLT entry
	     entry point, that must be within the memory region
	     assigned to that section.  */
	  lowword = entry->lzplt_entry + 4
	    + frv_plt_section (info)->output_offset
	    + frv_plt_section (info)->output_section->vma;
	  highword = _frv_osec_to_segment 
	    (output_bfd, frv_plt_section (info)->output_section);
	}
      else
	{
	  /* A function descriptor for a local function gets the index
	     of the section.  For a non-local function, it's
	     disregarded.  */
	  lowword = ad;
	  if (entry->symndx == -1 && entry->d.h->dynindx != -1
	      && entry->d.h->dynindx == idx)
	    highword = 0;
	  else
	    highword = _frv_osec_to_segment (output_bfd, sec->output_section);
	}

      bfd_put_32 (output_bfd, lowword,
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
		  + entry->fd_entry);
      bfd_put_32 (output_bfd, highword,
		  frv_got_section (info)->contents
		  + frv_got_initial_offset (info)
		  + entry->fd_entry + 4);
    }

  /* Generate code for the PLT entry.  */
  if (entry->plt_entry != (bfd_vma) -1)
    {
      bfd_byte *plt_code = frv_plt_section (info)->contents + entry->plt_entry;

      BFD_ASSERT (entry->fd_entry);

      /* Figure out what kind of PLT entry we need, depending on the
	 location of the function descriptor within the GOT.  */
      if (entry->fd_entry >= -(1 << (12 - 1))
	  && entry->fd_entry < (1 << (12 - 1)))
	{
	  /* lddi @@(gr15, fd_entry), gr14 */
	  bfd_put_32 (output_bfd,
		      0x9cccf000 | (entry->fd_entry & ((1 << 12) - 1)),
		      plt_code);
	  plt_code += 4;
	}
      else
	{
	  if (entry->fd_entry >= -(1 << (16 - 1))
	      && entry->fd_entry < (1 << (16 - 1)))
	    {
	      /* setlos lo(fd_entry), gr14 */
	      bfd_put_32 (output_bfd,
			  0x9cfc0000
			  | (entry->fd_entry & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      plt_code += 4;
	    }
	  else
	    {
	      /* sethi.p hi(fd_entry), gr14
		 setlo lo(fd_entry), gr14 */
	      bfd_put_32 (output_bfd,
			  0x1cf80000
			  | ((entry->fd_entry >> 16)
			     & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      bfd_put_32 (output_bfd,
			  0x9cf40000
			  | (entry->fd_entry & (((bfd_vma)1 << 16) - 1)),
			  plt_code);
	      plt_code += 8;
	    }
	  /* ldd @@(gr14,gr15),gr14 */
	  bfd_put_32 (output_bfd, 0x9c08e14f, plt_code);
	  plt_code += 4;
	}
      /* jmpl @@(gr14,gr0) */
      bfd_put_32 (output_bfd, 0x8030e000, plt_code);
    }

  /* Generate code for the lazy PLT entry.  */
  if (entry->lzplt_entry != (bfd_vma) -1)
    {
      bfd_byte *lzplt_code = frv_plt_section (info)->contents
	+ entry->lzplt_entry;
      bfd_vma resolverStub_addr;

      bfd_put_32 (output_bfd, fd_lazy_rel_offset, lzplt_code);
      lzplt_code += 4;

      resolverStub_addr = entry->lzplt_entry / FRV_LZPLT_BLOCK_SIZE
	* FRV_LZPLT_BLOCK_SIZE + FRV_LZPLT_RESOLV_LOC;
      if (resolverStub_addr >= frv_plt_initial_offset (info))
	resolverStub_addr = frv_plt_initial_offset (info) - 12;

      if (entry->lzplt_entry == resolverStub_addr)
	{
	  /* This is a lazy PLT entry that includes a resolver call.  */
	  /* ldd @@(gr15,gr0), gr4
	     jmpl @@(gr4,gr0)  */
	  bfd_put_32 (output_bfd, 0x8808f140, lzplt_code);
	  bfd_put_32 (output_bfd, 0x80304000, lzplt_code + 4);
	}
      else
	{
	  /* bra  resolverStub */
	  bfd_put_32 (output_bfd,
		      0xc01a0000
		      | (((resolverStub_addr - entry->lzplt_entry)
			  / 4) & (((bfd_vma)1 << 16) - 1)),
		      lzplt_code);
	}
    }

  return TRUE;
}

/* Handle an FRV small data reloc.  */

static bfd_reloc_status_type
elf32_frv_relocate_gprel12 (info, input_bfd, input_section, relocation,
			    contents, value)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *relocation;
     bfd_byte *contents;
     bfd_vma value;
{
  bfd_vma insn;
  bfd_vma gp;
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);

  gp = (h->u.def.value
	+ h->u.def.section->output_section->vma
	+ h->u.def.section->output_offset);

  value -= input_section->output_section->vma;
  value -= (gp - input_section->output_section->vma);

  insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);

  value += relocation->r_addend;

  if ((long) value > 0x7ff || (long) value < -0x800)
    return bfd_reloc_overflow;

  bfd_put_32 (input_bfd,
	      (insn & 0xfffff000) | (value & 0xfff),
	      contents + relocation->r_offset);

  return bfd_reloc_ok;
}

/* Handle an FRV small data reloc. for the u12 field.  */

static bfd_reloc_status_type
elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, relocation,
			     contents, value)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *relocation;
     bfd_byte *contents;
     bfd_vma value;
{
  bfd_vma insn;
  bfd_vma gp;
  struct bfd_link_hash_entry *h;
  bfd_vma mask;

  h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);

  gp = (h->u.def.value
	+ h->u.def.section->output_section->vma
	+ h->u.def.section->output_offset);

  value -= input_section->output_section->vma;
  value -= (gp - input_section->output_section->vma);

  insn = bfd_get_32 (input_bfd, contents + relocation->r_offset);
a557 4
      if (elf_elfheader (abfd)->e_type == ET_EXEC
	  || elf_elfheader (abfd)->e_type == ET_DYN)
	return &elf32_frv_rel_32_howto;
      /* Fall through.  */
a587 48
    case BFD_RELOC_FRV_GOT12:
      return &elf32_frv_howto_table[ (int) R_FRV_GOT12];

    case BFD_RELOC_FRV_GOTHI:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTHI];

    case BFD_RELOC_FRV_GOTLO:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTLO];

    case BFD_RELOC_FRV_FUNCDESC:
      if (elf_elfheader (abfd)->e_type == ET_EXEC
	  || elf_elfheader (abfd)->e_type == ET_DYN)
	return &elf32_frv_rel_funcdesc_howto;
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC];

    case BFD_RELOC_FRV_FUNCDESC_GOT12:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOT12];

    case BFD_RELOC_FRV_FUNCDESC_GOTHI:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTHI];

    case BFD_RELOC_FRV_FUNCDESC_GOTLO:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTLO];

    case BFD_RELOC_FRV_FUNCDESC_VALUE:
      if (elf_elfheader (abfd)->e_type == ET_EXEC
	  || elf_elfheader (abfd)->e_type == ET_DYN)
	return &elf32_frv_rel_funcdesc_value_howto;
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_VALUE];

    case BFD_RELOC_FRV_FUNCDESC_GOTOFF12:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTOFF12];

    case BFD_RELOC_FRV_FUNCDESC_GOTOFFHI:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTOFFHI];

    case BFD_RELOC_FRV_FUNCDESC_GOTOFFLO:
      return &elf32_frv_howto_table[ (int) R_FRV_FUNCDESC_GOTOFFLO];

    case BFD_RELOC_FRV_GOTOFF12:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTOFF12];

    case BFD_RELOC_FRV_GOTOFFHI:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTOFFHI];

    case BFD_RELOC_FRV_GOTOFFLO:
      return &elf32_frv_howto_table[ (int) R_FRV_GOTOFFLO];

a623 28

/* Set the howto pointer for an FRV ELF REL reloc.  */
static void
frv_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  switch (r_type)
    {
    case R_FRV_32:
      cache_ptr->howto = &elf32_frv_rel_32_howto;
      break;

    case R_FRV_FUNCDESC:
      cache_ptr->howto = &elf32_frv_rel_funcdesc_howto;
      break;

    case R_FRV_FUNCDESC_VALUE:
      cache_ptr->howto = &elf32_frv_rel_funcdesc_value_howto;
      break;

    default:
      cache_ptr->howto = NULL;
      break;
    }
}
a689 3
  unsigned isec_segment, got_segment, plt_segment, gprel_segment,
    check_segment[2];
  int silence_segment_error = !(info->shared || info->pie);
a697 21
  isec_segment = _frv_osec_to_segment (output_bfd,
				       input_section->output_section);
  if (frv_got_section (info))
    got_segment = _frv_osec_to_segment (output_bfd,
					frv_got_section (info)
					->output_section);
  else
    got_segment = -1;
  if (frv_gotfixup_section (info))
    gprel_segment = _frv_osec_to_segment (output_bfd,
					  frv_gotfixup_section (info)
					  ->output_section);
  else
    gprel_segment = -1;
  if (elf_hash_table (info)->dynamic_sections_created)
    plt_segment = _frv_osec_to_segment (output_bfd,
					frv_plt_section (info)
					->output_section);
  else
    plt_segment = -1;

a708 3
      asection *osec;
      struct frv_pic_relocs_info *picrel;
      bfd_vma orig_addend = rel->r_addend;
d723 1
a723 1525
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  osec = sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
	}
      else
	{
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  name = h->root.root.string;

	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && ! FRV_SYM_LOCAL (info, h))
	    {
	      sec = NULL;
	      relocation = 0;
	    }
	  else
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
	      relocation = 0;
	    }
	  else if (   ! info->executable
		   && ! info->symbolic
		   && info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
	      relocation = 0;
	    }
	  osec = sec;
	}

      switch (r_type)
	{
	case R_FRV_LABEL24:
	case R_FRV_32:
	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFFLO:
	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	case R_FRV_FUNCDESC:
	case R_FRV_FUNCDESC_VALUE:
	  if (h != NULL)
	    picrel = frv_pic_relocs_info_for_global (frv_relocs_info (info),
						     input_bfd, h,
						     orig_addend);
	  else
	    /* In order to find the entry we created before, we must
	       use the original addend, not the one that may have been
	       modified by _bfd_elf_rela_local_sym().  */
	    picrel = frv_pic_relocs_info_for_local (frv_relocs_info (info),
						    input_bfd, r_symndx,
						    orig_addend);
	  if (! picrel)
	    return FALSE;

	  if (!_frv_emit_got_relocs_plt_entries (picrel, output_bfd, info,
						 osec, sym, rel->r_addend))
	    {
	      info->callbacks->warning
		(info, _("Dynamic relocation references symbol with nonzero addend"),
		 name, input_bfd, input_section, rel->r_offset);
	      return FALSE;

	    }

	  break;

	default:
	  picrel = NULL;
	  if (h && ! FRV_SYM_LOCAL (info, h))
	    {
	      info->callbacks->warning
		(info, _("relocation references symbol not defined in the module"),
		 name, input_bfd, input_section, rel->r_offset);
	      return FALSE;
	    }
	  break;
	}

      switch (r_type)
	{
	case R_FRV_LABEL24:
	  check_segment[0] = isec_segment;
	  if (picrel->plt)
	    {
	      relocation = frv_plt_section (info)->output_section->vma
		+ frv_plt_section (info)->output_offset
		+ picrel->plt_entry;
	      check_segment[1] = plt_segment;
	    }
	  /* We don't want to warn on calls to undefined weak symbols,
	     as calls to them must be protected by non-NULL tests
	     anyway, and unprotected calls would invoke undefined
	     behavior.  */
	  else if (picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefweak)
	    check_segment[1] = check_segment[0];
	  else
	    check_segment[1] = sec
	      ? _frv_osec_to_segment (output_bfd, sec->output_section)
	      : (unsigned)-1;
	  break;

	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	  relocation = picrel->got_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;
	  
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	  relocation = picrel->fdgot_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;
	  
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFLO:
	  relocation -= frv_got_section (info)->output_section->vma
	    + frv_got_section (info)->output_offset
	    + frv_got_initial_offset (info);
	  check_segment[0] = got_segment;
	  check_segment[1] = sec
	    ? _frv_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;

	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	  relocation = picrel->fd_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_FRV_FUNCDESC:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;

	    /* If the symbol is dynamic and there may be dynamic
	       symbol resolution because we are or are linked with a
	       shared library, emit a FUNCDESC relocation such that
	       the dynamic linker will allocate the function
	       descriptor.  */
	    if (h && ! FRV_FUNCDESC_LOCAL (info, h))
	      {
		if (addend)
		  {
		    info->callbacks->warning
		      (info, _("R_FRV_FUNCDESC references dynamic symbol with nonzero addend"),
		       name, input_bfd, input_section, rel->r_offset);
		    return FALSE;
		  }
		dynindx = h->dynindx;
	      }
	    else
	      {
		/* Otherwise, we know we have a private function
		   descriptor, so reference it directly.  */
		BFD_ASSERT (picrel->privfd);
		r_type = R_FRV_32;
		dynindx = elf_section_data (frv_got_section
					    (info)->output_section)->dynindx;
		addend = frv_got_section (info)->output_offset
		  + frv_got_initial_offset (info)
		  + picrel->fd_entry;
	      }

	    /* If there is room for dynamic symbol resolution, emit
	       the dynamic relocation.  However, if we're linking an
	       executable at a fixed location, we won't have emitted a
	       dynamic symbol entry for the got section, so idx will
	       be zero, which means we can and should compute the
	       address of the private descriptor ourselves.  */
	    if (info->executable && !info->pie
		&& (!h || FRV_FUNCDESC_LOCAL (info, h)))
	      {
		addend += frv_got_section (info)->output_section->vma;
		if ((bfd_get_section_flags (output_bfd,
					   input_section->output_section)
		     & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_frv_osec_readonly_p (output_bfd,
					      input_section->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit fixups in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    if (! h || h->root.type != bfd_link_hash_undefweak)
		      _frv_add_rofixup (output_bfd,
					frv_gotfixup_section (info),
					_bfd_elf_section_offset
					(output_bfd, info,
					 input_section, rel->r_offset)
					+ input_section->output_section->vma
					+ input_section->output_offset);
		  }
	      }
	    else if ((bfd_get_section_flags (output_bfd,
					     input_section->output_section)
		      & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
	      {
		if (_frv_osec_readonly_p (output_bfd,
					  input_section->output_section))
		  {
		    info->callbacks->warning
		      (info,
		       _("cannot emit dynamic relocations in read-only section"),
		       name, input_bfd, input_section, rel->r_offset);
		    return FALSE;
		  }
		_frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
				    _bfd_elf_section_offset
				    (output_bfd, info,
				     input_section, rel->r_offset)
				    + input_section->output_section->vma
				    + input_section->output_offset,
				    r_type, dynindx, addend);
	      }

	    /* We want the addend in-place because dynamic
	       relocations are REL.  Setting relocation to it should
	       arrange for it to be installed.  */
	    relocation = addend - rel->r_addend;
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_FRV_32:
	case R_FRV_FUNCDESC_VALUE:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;

	    /* If the symbol is dynamic but binds locally, use
	       section+offset.  */
	    if (h && ! FRV_SYM_LOCAL (info, h))
	      {
		if (addend && r_type == R_FRV_FUNCDESC_VALUE)
		  {
		    info->callbacks->warning
		      (info, _("R_FRV_FUNCDESC_VALUE references dynamic symbol with nonzero addend"),
		       name, input_bfd, input_section, rel->r_offset);
		    return FALSE;
		  }
		dynindx = h->dynindx;
	      }
	    else
	      {
		if (h)
		  addend += h->root.u.def.value;
		else
		  addend += sym->st_value;
		if (osec)
		  addend += osec->output_offset;
		if (osec && osec->output_section
		    && ! bfd_is_abs_section (osec->output_section)
		    && ! bfd_is_und_section (osec->output_section))
		  dynindx = elf_section_data (osec->output_section)->dynindx;
		else
		  dynindx = 0;
	      }

	    /* If we're linking an executable at a fixed address, we
	       can omit the dynamic relocation as long as the symbol
	       is defined in the current link unit (which is implied
	       by its output section not being NULL).  */
	    if (info->executable && !info->pie
		&& (!h || FRV_SYM_LOCAL (info, h)))
	      {
		if (osec)
		  addend += osec->output_section->vma;
		if ((elf_elfheader (input_bfd)->e_flags & EF_FRV_FDPIC)
		    && (bfd_get_section_flags (output_bfd,
					       input_section->output_section)
			& (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_frv_osec_readonly_p (output_bfd,
					      input_section->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit fixups in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    if (!h || h->root.type != bfd_link_hash_undefweak)
		      {
			_frv_add_rofixup (output_bfd,
					  frv_gotfixup_section (info),
					  _bfd_elf_section_offset
					  (output_bfd, info,
					   input_section, rel->r_offset)
					  + input_section->output_section->vma
					  + input_section->output_offset);
			if (r_type == R_FRV_FUNCDESC_VALUE)
			  _frv_add_rofixup
			    (output_bfd,
			     frv_gotfixup_section (info),
			     _bfd_elf_section_offset
			     (output_bfd, info,
			      input_section, rel->r_offset)
			     + input_section->output_section->vma
			     + input_section->output_offset + 4);
		      }
		  }
	      }
	    else
	      {
		if ((bfd_get_section_flags (output_bfd,
					    input_section->output_section)
		     & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_frv_osec_readonly_p (output_bfd,
					      input_section->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit dynamic relocations in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    _frv_add_dyn_reloc (output_bfd, frv_gotrel_section (info),
					_bfd_elf_section_offset
					(output_bfd, info,
					 input_section, rel->r_offset)
					+ input_section->output_section->vma
					+ input_section->output_offset,
					r_type, dynindx, addend);
		  }
		/* We want the addend in-place because dynamic
		   relocations are REL.  Setting relocation to it
		   should arrange for it to be installed.  */
		relocation = addend - rel->r_addend;
	      }

	    if (r_type == R_FRV_FUNCDESC_VALUE)
	      {
		/* If we've omitted the dynamic relocation, just emit
		   the fixed addresses of the symbol and of the local
		   GOT base offset.  */
		if (info->executable && !info->pie
		    && (!h || FRV_SYM_LOCAL (info, h)))
		  bfd_put_32 (output_bfd,
			      frv_got_section (info)->output_section->vma
			      + frv_got_section (info)->output_offset
			      + frv_got_initial_offset (info),
			      contents + rel->r_offset + 4);
		else
		  /* A function descriptor used for lazy or local
		     resolving is initialized such that its high word
		     contains the output section index in which the
		     PLT entries are located, and the low word
		     contains the offset of the lazy PLT entry entry
		     point into that section.  */
		  bfd_put_32 (output_bfd,
			      h && ! FRV_SYM_LOCAL (info, h)
			      ? 0
			      : _frv_osec_to_segment (output_bfd,
						      sec->output_section),
			      contents + rel->r_offset + 4);
	      }
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_FRV_GPREL12:
	case R_FRV_GPRELU12:
	case R_FRV_GPREL32:
	case R_FRV_GPRELHI:
	case R_FRV_GPRELLO:
	  check_segment[0] = gprel_segment;
	  check_segment[1] = sec
	    ? _frv_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;

	default:
	  check_segment[0] = isec_segment;
	  check_segment[1] = sec
	    ? _frv_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;
	}

      if (check_segment[0] != check_segment[1]
	  && (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC))
	{
#if 1
	  /* This helps catch problems in GCC while we can't do more
	     than static linking.  The idea is to test whether the
	     input file basename is crt0.o only once.  */
	  if (silence_segment_error == 1)
	    silence_segment_error =
	      (strlen (input_bfd->filename) == 6
	       && strcmp (input_bfd->filename, "crt0.o") == 0)
	      || (strlen (input_bfd->filename) > 6
		  && strcmp (input_bfd->filename
			     + strlen (input_bfd->filename) - 7,
			     "/crt0.o") == 0)
	      ? -1 : 0;
#endif
	  if (!silence_segment_error
	      /* We don't want duplicate errors for undefined
		 symbols.  */
	      && !(picrel && picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefined))
	    info->callbacks->warning
	      (info,
	       (info->shared || info->pie)
	       ? _("relocations between different segments are not supported")
	       : _("warning: relocation references a different segment"),
	       name, input_bfd, input_section, rel->r_offset);
	  if (!silence_segment_error && (info->shared || info->pie))
	    return FALSE;
	  elf_elfheader (output_bfd)->e_flags |= EF_FRV_PIC;
	}

      switch (r_type)
	{
	case R_FRV_GOTOFFHI:
	  /* We need the addend to be applied before we shift the
	     value right.  */
	  relocation += rel->r_addend;
	  /* Fall through.  */
	case R_FRV_GOTHI:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTOFFHI:
	  relocation >>= 16;
	  /* Fall through.  */

	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_GOTOFFLO:
	case R_FRV_FUNCDESC_GOTOFFLO:
	  relocation &= 0xffff;
	  break;

	default:
	  break;
	}

      switch (r_type)
	{
	case R_FRV_LABEL24:
	  if (! picrel->plt)
	    break;
	  /* Fall through.  */
	  
	  /* When referencing a GOT entry, a function descriptor or a
	     PLT, we don't want the addend to apply to the reference,
	     but rather to the referenced symbol.  The actual entry
	     will have already been created taking the addend into
	     account, so cancel it out here.  */
	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	  /* Note that we only want GOTOFFHI, not GOTOFFLO or GOTOFF12
	     here, since we do want to apply the addend to the others.
	     Note that we've applied the addend to GOTOFFHI before we
	     shifted it right.  */ 
	case R_FRV_GOTOFFHI:
	  relocation -= rel->r_addend;
	  break;

	default:
	  break;
	}

     if (r_type == R_FRV_HI16)
       r = elf32_frv_relocate_hi16 (input_bfd, rel, contents, relocation);

     else if (r_type == R_FRV_LO16)
       r = elf32_frv_relocate_lo16 (input_bfd, rel, contents, relocation);

     else if (r_type == R_FRV_LABEL24)
       r = elf32_frv_relocate_label24 (input_bfd, input_section, rel,
				       contents, relocation);

     else if (r_type == R_FRV_GPREL12)
       r = elf32_frv_relocate_gprel12 (info, input_bfd, input_section, rel,
				       contents, relocation);

     else if (r_type == R_FRV_GPRELU12)
       r = elf32_frv_relocate_gprelu12 (info, input_bfd, input_section, rel,
					contents, relocation);

     else if (r_type == R_FRV_GPRELLO)
       r = elf32_frv_relocate_gprello (info, input_bfd, input_section, rel,
				       contents, relocation);

     else if (r_type == R_FRV_GPRELHI)
       r = elf32_frv_relocate_gprelhi (info, input_bfd, input_section, rel,
				       contents, relocation);

     else
       r = frv_final_link_relocate (howto, input_bfd, input_section, contents,
				    rel, relocation);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
elf32_frv_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_FRV_GNU_VTINHERIT:
	case R_FRV_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf32_frv_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
  return TRUE;
}


/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put .comm items in .scomm, and not .comm.  */

static bfd_boolean
elf32_frv_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
{
  if (sym->st_shndx == SHN_COMMON
      && !info->relocatable
      && (int)sym->st_size <= (int)bfd_get_gp_size (abfd))
    {
      /* Common symbols less than or equal to -G nn bytes are
	 automatically put into .sbss.  */

      asection *scomm = bfd_get_section_by_name (abfd, ".scommon");

      if (scomm == NULL)
	{
	  scomm = bfd_make_section (abfd, ".scommon");
	  if (scomm == NULL
	      || !bfd_set_section_flags (abfd, scomm, (SEC_ALLOC
						       | SEC_IS_COMMON
						       | SEC_LINKER_CREATED)))
	    return FALSE;
	}

      *secp = scomm;
      *valp = sym->st_size;
    }

  return TRUE;
}
/* Create a .got section, as well as its additional info field.  This
   is almost entirely copied from
   elflink.c:_bfd_elf_create_got_section().  */

static bfd_boolean
_frv_create_got_section (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags;
  asection *s;
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int ptralign;

  /* This function may be called more than once.  */
  s = bfd_get_section_by_name (abfd, ".got");
  if (s != NULL && (s->flags & SEC_LINKER_CREATED) != 0)
    return TRUE;

  /* Machine specific: although pointers are 32-bits wide, we want the
     GOT to be aligned to a 64-bit boundary, such that function
     descriptors in it can be accessed with 64-bit loads and
     stores.  */
  ptralign = 3;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  s = bfd_make_section (abfd, ".got");
  if (s == NULL
      || !bfd_set_section_flags (abfd, s, flags)
      || !bfd_set_section_alignment (abfd, s, ptralign))
    return FALSE;

  if (bed->want_got_plt)
    {
      s = bfd_make_section (abfd, ".got.plt");
      if (s == NULL
	  || !bfd_set_section_flags (abfd, s, flags)
	  || !bfd_set_section_alignment (abfd, s, ptralign))
	return FALSE;
    }

  if (bed->want_got_sym)
    {
      /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
	 (or .got.plt) section.  We don't do this in the linker script
	 because we don't want to define the symbol if we are not creating
	 a global offset table.  */
      bh = NULL;
      if (!(_bfd_generic_link_add_one_symbol
	    (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
	     bed->got_symbol_offset, (const char *) NULL, FALSE,
	     bed->collect, &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_OBJECT;

      /* Machine-specific: we want the symbol for executables as
	 well.  */
      if (! _bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;

      elf_hash_table (info)->hgot = h;
    }

  /* The first bit of the global offset table is the header.  */
  s->_raw_size += bed->got_header_size + bed->got_symbol_offset;

  /* This is the machine-specific part.  Create and initialize section
     data for the got.  */
  frv_got_section (info) = s;
  frv_relocs_info (info) = htab_try_create (1, frv_pic_relocs_info_hash,
					    frv_pic_relocs_info_eq,
					    (htab_del) NULL);
  if (! frv_relocs_info (info))
    return FALSE;

  s = bfd_make_section (abfd, ".rel.got");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, s, 2))
    return FALSE;

  frv_gotrel_section (info) = s;

  /* Machine-specific.  */
  s = bfd_make_section (abfd, ".rofixup");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, (flags | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, s, 2))
    return FALSE;

  frv_gotfixup_section (info) = s;

  /* Define _gp in .rofixup, for FDPIC.  If it turns out that
     we're linking with a different linker script, the linker script
     will override it.  */
  bh = NULL;
  if (!(_bfd_generic_link_add_one_symbol
	(info, abfd, "_gp", BSF_GLOBAL, s, -2048, (const char *) NULL, FALSE,
	 bed->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  /* Machine-specific: we want the symbol for executables as well.  */
  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;
  
  return TRUE;
}

/* Make sure the got and plt sections exist, and that our pointers in
   the link hash table point to them.  */

static bfd_boolean
elf32_frv_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  /* This is mostly copied from
     elflink.c:_bfd_elf_create_dynamic_sections().  */
  flagword flags, pltflags;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  pltflags = flags;
  pltflags |= SEC_CODE;
  if (bed->plt_not_loaded)
    pltflags &= ~ (SEC_CODE | SEC_LOAD | SEC_HAS_CONTENTS);
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  s = bfd_make_section (abfd, ".plt");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, pltflags)
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;
  /* FRV-specific: remember it.  */
  frv_plt_section (info) = s;

  if (bed->want_plt_sym)
    {
      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
	 .plt section.  */
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s, 0, NULL,
	      FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
      h->type = STT_OBJECT;

      if (! info->executable
	  && ! _bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }

  /* FRV-specific: we want rel relocations for the plt.  */
  s = bfd_make_section (abfd, ".rel.plt");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  /* FRV-specific: remember it.  */
  frv_pltrel_section (info) = s;

  /* FRV-specific: we want to create the GOT in the FRV way.  */
  if (! _frv_create_got_section (abfd, info))
    return FALSE;

  /* FRV-specific: make sure we created everything we wanted.  */
  BFD_ASSERT (frv_got_section (info) && frv_gotrel_section (info)
	      && frv_gotfixup_section (info)
	      && frv_plt_section (info) && frv_pltrel_section (info));

  if (bed->want_dynbss)
    {
      /* The .dynbss section is a place to put symbols which are defined
	 by dynamic objects, are referenced by regular objects, and are
	 not functions.  We must allocate space for them in the process
	 image and use a R_*_COPY reloc to tell the dynamic linker to
	 initialize them at run time.  The linker script puts the .dynbss
	 section into the .bss section of the final image.  */
      s = bfd_make_section (abfd, ".dynbss");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC | SEC_LINKER_CREATED))
	return FALSE;

      /* The .rel[a].bss section holds copy relocs.  This section is not
     normally needed.  We need to create it here, though, so that the
     linker will map it to an output section.  We can't just create it
     only if we need it, because we will not know whether we need it
     until we have seen all the input files, and the first time the
     main linker code calls BFD after examining all the input files
     (size_dynamic_sections) the input sections have already been
     mapped to the output sections.  If the section turns out not to
     be needed, we can discard it later.  We will never need this
     section when generating a shared object, since they do not use
     copy relocs.  */
      if (! info->shared)
	{
	  s = bfd_make_section (abfd,
				(bed->default_use_rela_p
				 ? ".rela.bss" : ".rel.bss"));
	  if (s == NULL
	      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
	    return FALSE;
	}
    }

  return TRUE;
}

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so.1"

#define DEFAULT_STACK_SIZE 0x20000

/* This structure is used to collect the number of entries present in
   each addressable range of the got.  */
struct _frv_dynamic_got_info
{
  /* Several bits of information about the current link.  */
  struct bfd_link_info *info;
  /* Total size needed for GOT entries within the 12-, 16- or 32-bit
     ranges.  */
  bfd_vma got12, gotlos, gothilo;
  /* Total size needed for function descriptor entries within the 12-,
     16- or 32-bit ranges.  */
  bfd_vma fd12, fdlos, fdhilo;
  /* Total size needed function descriptor entries referenced in PLT
     entries, that would be profitable to place in offsets close to
     the PIC register.  */
  bfd_vma fdplt;
  /* Total size needed by lazy PLT entries.  */
  bfd_vma lzplt;
  /* Number of relocations carried over from input object files.  */
  unsigned long relocs;
  /* Number of fixups introduced by relocations in input object files.  */
  unsigned long fixups;
};

/* Compute the total GOT size required by each symbol in each range.
   Symbols may require up to 4 words in the GOT: an entry pointing to
   the symbol, an entry pointing to its function descriptor, and a
   private function descriptors taking two words.  */

static int
_frv_count_got_plt_entries (void **entryp, void *dinfo_)
{
  struct frv_pic_relocs_info *entry = *entryp;
  struct _frv_dynamic_got_info *dinfo = dinfo_;

  /* Allocate space for a GOT entry pointing to the symbol.  */
  if (entry->got12)
    dinfo->got12 += 4;
  else if (entry->gotlos)
    dinfo->gotlos += 4;
  else if (entry->gothilo)
    dinfo->gothilo += 4;
  else
    entry->relocs32--;
  entry->relocs32++;

  /* Allocate space for a GOT entry pointing to the function
     descriptor.  */
  if (entry->fdgot12)
    dinfo->got12 += 4;
  else if (entry->fdgotlos)
    dinfo->gotlos += 4;
  else if (entry->fdgothilo)
    dinfo->gothilo += 4;
  else
    entry->relocsfd--;
  entry->relocsfd++;

  /* Decide whether we need a PLT entry, a function descriptor in the
     GOT, and a lazy PLT entry for this symbol.  */
  entry->plt = entry->call
    && entry->symndx == -1 && ! FRV_SYM_LOCAL (dinfo->info, entry->d.h)
    && elf_hash_table (dinfo->info)->dynamic_sections_created;
  entry->privfd = entry->plt
    || entry->fdgoff12 || entry->fdgofflos || entry->fdgoffhilo
    || ((entry->fd || entry->fdgot12 || entry->fdgotlos || entry->fdgothilo)
	&& (entry->symndx != -1
	    || FRV_FUNCDESC_LOCAL (dinfo->info, entry->d.h)));
  entry->lazyplt = entry->privfd
    && entry->symndx == -1 && ! FRV_SYM_LOCAL (dinfo->info, entry->d.h)
    && ! (dinfo->info->flags & DF_BIND_NOW)
    && elf_hash_table (dinfo->info)->dynamic_sections_created;

  /* Allocate space for a function descriptor.  */
  if (entry->fdgoff12)
    dinfo->fd12 += 8;
  else if (entry->fdgofflos)
    dinfo->fdlos += 8;
  else if (entry->privfd && entry->plt)
    dinfo->fdplt += 8;
  else if (entry->privfd)
    dinfo->fdhilo += 8;
  else
    entry->relocsfdv--;
  entry->relocsfdv++;

  if (entry->lazyplt)
    dinfo->lzplt += 8;

  if (!dinfo->info->executable || dinfo->info->pie)
    dinfo->relocs += entry->relocs32 + entry->relocsfd + entry->relocsfdv;
  else
    {
      if (entry->symndx != -1 || FRV_SYM_LOCAL (dinfo->info, entry->d.h))
	{
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)	  
	    dinfo->fixups += entry->relocs32 + 2 * entry->relocsfdv;
	}
      else
	dinfo->relocs += entry->relocs32 + entry->relocsfdv;
      if (entry->symndx != -1 || FRV_FUNCDESC_LOCAL (dinfo->info, entry->d.h))
	{
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    dinfo->fixups += entry->relocsfd;
	}
      else
	dinfo->relocs += entry->relocsfd;
    }

  return 1;
}

/* This structure is used to assign offsets to got entries, function
   descriptors, plt entries and lazy plt entries.  */

struct _frv_dynamic_got_plt_info
{
  /* Summary information collected with _frv_count_got_plt_entries.  */
  struct _frv_dynamic_got_info g;

  /* For each addressable range, we record a MAX (positive) and MIN
     (negative) value.  CUR is used to assign got entries, and it's
     incremented from an initial positive value to MAX, then from MIN
     to FDCUR (unless FDCUR wraps around first).  FDCUR is used to
     assign function descriptors, and it's decreased from an initial
     non-positive value to MIN, then from MAX down to CUR (unless CUR
     wraps around first).  All of MIN, MAX, CUR and FDCUR always point
     to even words.  ODD, if non-zero, indicates an odd word to be
     used for the next got entry, otherwise CUR is used and
     incremented by a pair of words, wrapping around when it reaches
     MAX.  FDCUR is decremented (and wrapped) before the next function
     descriptor is chosen.  FDPLT indicates the number of remaining
     slots that can be used for function descriptors used only by PLT
     entries.  */
  struct _frv_dynamic_got_alloc_data
  {
    bfd_signed_vma max, cur, odd, fdcur, min;
    bfd_vma fdplt;
  } got12, gotlos, gothilo;
};

/* Determine the positive and negative ranges to be used by each
   offset range in the GOT.  FDCUR and CUR, that must be aligned to a
   double-word boundary, are the minimum (negative) and maximum
   (positive) GOT offsets already used by previous ranges, except for
   an ODD entry that may have been left behind.  GOT and FD indicate
   the size of GOT entries and function descriptors that must be
   placed within the range from -WRAP to WRAP.  If there's room left,
   up to FDPLT bytes should be reserved for additional function
   descriptors.  */

inline static bfd_signed_vma
_frv_compute_got_alloc_data (struct _frv_dynamic_got_alloc_data *gad,
			     bfd_signed_vma fdcur,
			     bfd_signed_vma odd,
			     bfd_signed_vma cur,
			     bfd_vma got,
			     bfd_vma fd,
			     bfd_vma fdplt,
			     bfd_vma wrap)
{
  bfd_signed_vma wrapmin = -wrap;

  /* Start at the given initial points.  */
  gad->fdcur = fdcur;
  gad->cur = cur;

  /* If we had an incoming odd word and we have any got entries that
     are going to use it, consume it, otherwise leave gad->odd at
     zero.  We might force gad->odd to zero and return the incoming
     odd such that it is used by the next range, but then GOT entries
     might appear to be out of order and we wouldn't be able to
     shorten the GOT by one word if it turns out to end with an
     unpaired GOT entry.  */
  if (odd && got)
    {
      gad->odd = odd;
      got -= 4;
      odd = 0;
    }
  else
    gad->odd = 0;

  /* If we're left with an unpaired GOT entry, compute its location
     such that we can return it.  Otherwise, if got doesn't require an
     odd number of words here, either odd was already zero in the
     block above, or it was set to zero because got was non-zero, or
     got was already zero.  In the latter case, we want the value of
     odd to carry over to the return statement, so we don't want to
     reset odd unless the condition below is true.  */
  if (got & 4)
    {
      odd = cur + got;
      got += 4;
    }
  
  /* Compute the tentative boundaries of this range.  */
  gad->max = cur + got;
  gad->min = fdcur - fd;
  gad->fdplt = 0;

  /* If function descriptors took too much space, wrap some of them
     around.  */
  if (gad->min < wrapmin)
    {
      gad->max += wrapmin - gad->min;
      gad->min = wrapmin;
    }
  /* If there is space left and we have function descriptors
     referenced in PLT entries that could take advantage of shorter
     offsets, place them here.  */
  else if (fdplt && gad->min > wrapmin)
    {
      bfd_vma fds;
      if ((bfd_vma) (gad->min - wrapmin) < fdplt)
	fds = gad->min - wrapmin;
      else
	fds = fdplt;

      fdplt -= fds;
      gad->min -= fds;
      gad->fdplt += fds;
    }

  /* If GOT entries took too much space, wrap some of them around.
     This may well cause gad->min to become lower than wrapmin.  This
     will cause a relocation overflow later on, so we don't have to
     report it here . */
  if ((bfd_vma) gad->max > wrap)
    {
      gad->min -= gad->max - wrap;
      gad->max = wrap;
    }
  /* If there is more space left, try to place some more function
     descriptors for PLT entries.  */
  else if (fdplt && (bfd_vma) gad->max < wrap)
    {
      bfd_vma fds;
      if ((bfd_vma) (wrap - gad->max) < fdplt)
	fds = wrap - gad->max;
      else
	fds = fdplt;

      fdplt -= fds;
      gad->max += fds;
      gad->fdplt += fds;
    }

  /* If odd was initially computed as an offset past the wrap point,
     wrap it around.  */
  if (odd > gad->max)
    odd = gad->min + odd - gad->max;

  /* _frv_get_got_entry() below will always wrap gad->cur if needed
     before returning, so do it here too.  This guarantees that,
     should cur and fdcur meet at the wrap point, they'll both be
     equal to min.  */
  if (gad->cur == gad->max)
    gad->cur = gad->min;

  return odd;
}

/* Compute the location of the next GOT entry, given the allocation
   data for a range.  */

inline static bfd_signed_vma
_frv_get_got_entry (struct _frv_dynamic_got_alloc_data *gad)
{
  bfd_signed_vma ret;
  
  if (gad->odd)
    {
      /* If there was an odd word left behind, use it.  */
      ret = gad->odd;
      gad->odd = 0;
    }
  else
    {
      /* Otherwise, use the word pointed to by cur, reserve the next
	 as an odd word, and skip to the next pair of words, possibly
	 wrapping around.  */
      ret = gad->cur;
      gad->odd = gad->cur + 4;
      gad->cur += 8;
      if (gad->cur == gad->max)
	gad->cur = gad->min;
    }

  return ret;
}

/* Compute the location of the next function descriptor entry in the
   GOT, given the allocation data for a range.  */

inline static bfd_signed_vma
_frv_get_fd_entry (struct _frv_dynamic_got_alloc_data *gad)
{
  /* If we're at the bottom, wrap around, and only then allocate the
     next pair of words.  */
  if (gad->fdcur == gad->min)
    gad->fdcur = gad->max;
  return gad->fdcur -= 8;
}

/* Assign GOT offsets for every GOT entry and function descriptor.
   Doing everything in a single pass is tricky.  */

static int
_frv_assign_got_entries (void **entryp, void *info_)
{
  struct frv_pic_relocs_info *entry = *entryp;
  struct _frv_dynamic_got_plt_info *dinfo = info_;

  if (entry->got12)
    entry->got_entry = _frv_get_got_entry (&dinfo->got12);
  else if (entry->gotlos)
    entry->got_entry = _frv_get_got_entry (&dinfo->gotlos);
  else if (entry->gothilo)
    entry->got_entry = _frv_get_got_entry (&dinfo->gothilo);

  if (entry->fdgot12)
    entry->fdgot_entry = _frv_get_got_entry (&dinfo->got12);
  else if (entry->fdgotlos)
    entry->fdgot_entry = _frv_get_got_entry (&dinfo->gotlos);
  else if (entry->fdgothilo)
    entry->fdgot_entry = _frv_get_got_entry (&dinfo->gothilo);

  if (entry->fdgoff12)
    entry->fd_entry = _frv_get_fd_entry (&dinfo->got12);
  else if (entry->plt && dinfo->got12.fdplt)
    {
      dinfo->got12.fdplt -= 8;
      entry->fd_entry = _frv_get_fd_entry (&dinfo->got12);
    }
  else if (entry->fdgofflos)
    entry->fd_entry = _frv_get_fd_entry (&dinfo->gotlos);
  else if (entry->plt && dinfo->gotlos.fdplt)
    {
      dinfo->gotlos.fdplt -= 8;
      entry->fd_entry = _frv_get_fd_entry (&dinfo->gotlos);
    }
  else if (entry->plt)
    {
      dinfo->gothilo.fdplt -= 8;
      entry->fd_entry = _frv_get_fd_entry (&dinfo->gothilo);
    }
  else if (entry->privfd)
    entry->fd_entry = _frv_get_fd_entry (&dinfo->gothilo);
  
  return 1;
}

/* Assign GOT offsets to private function descriptors used by PLT
   entries (or referenced by 32-bit offsets), as well as PLT entries
   and lazy PLT entries.  */

static int
_frv_assign_plt_entries (void **entryp, void *info_)
{
  struct frv_pic_relocs_info *entry = *entryp;
  struct _frv_dynamic_got_plt_info *dinfo = info_;

  /* If this symbol requires a local function descriptor, allocate
     one.  */
  if (entry->privfd && entry->fd_entry == 0)
    {
      if (dinfo->got12.fdplt)
	{
	  entry->fd_entry = _frv_get_fd_entry (&dinfo->got12);
	  dinfo->got12.fdplt -= 8;
	}
      else if (dinfo->gotlos.fdplt)
	{
	  entry->fd_entry = _frv_get_fd_entry (&dinfo->gotlos);
	  dinfo->gotlos.fdplt -= 8;
	}
      else
	{
	  BFD_ASSERT (dinfo->gothilo.fdplt)
	  entry->fd_entry = _frv_get_fd_entry (&dinfo->gothilo);
	  dinfo->gothilo.fdplt -= 8;
	}
    }

  if (entry->plt)
    {
      int size;

      /* We use the section's raw size to mark the location of the
	 next PLT entry.  */
      entry->plt_entry = frv_plt_section (dinfo->g.info)->_raw_size;

      /* Figure out the length of this PLT entry based on the
	 addressing mode we need to reach the function descriptor.  */
      BFD_ASSERT (entry->fd_entry);
      if (entry->fd_entry >= -(1 << (12 - 1))
	  && entry->fd_entry < (1 << (12 - 1)))
	size = 8;
      else if (entry->fd_entry >= -(1 << (16 - 1))
	       && entry->fd_entry < (1 << (16 - 1)))
	size = 12;
      else
	size = 16;

      frv_plt_section (dinfo->g.info)->_raw_size += size;
    }

  if (entry->lazyplt)
    {
      entry->lzplt_entry = dinfo->g.lzplt;
      dinfo->g.lzplt += 8;
      /* If this entry is the one that gets the resolver stub, account
	 for the additional instruction.  */
      if (entry->lzplt_entry % FRV_LZPLT_BLOCK_SIZE == FRV_LZPLT_RESOLV_LOC)
	dinfo->g.lzplt += 4;
    }
      
  return 1;
}  

/* Follow indirect and warning hash entries so that each got entry
   points to the final symbol definition.  P must point to a pointer
   to the hash table we're traversing.  Since this traversal may
   modify the hash table, we set this pointer to NULL to indicate
   we've made a potentially-destructive change to the hash table, so
   the traversal must be restarted.  */
static int
_frv_resolve_final_relocs_info (void **entryp, void *p)
{
  struct frv_pic_relocs_info *entry = *entryp;
  htab_t *htab = p;

  if (entry->symndx == -1)
    {
      struct elf_link_hash_entry *h = entry->d.h;

      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *)h->root.u.i.link;

      if (entry->d.h == h)
	return 1;

      entry->d.h = h;

      /* If we can't find this entry with the new bfd hash, re-insert
	 it, and get the traversal restarted.  */
      if (! htab_find (*htab, entry))
	{
	  htab_clear_slot (*htab, entryp);
	  entryp = htab_find_slot (*htab, entry, INSERT);
	  if (! *entryp)
	    *entryp = entry;
	  /* Abort the traversal, since the whole table may have
	     moved, and leave it up to the parent to restart the
	     process.  */
	  *(htab_t *)p = NULL;
	  return 0;
	}
    }

  return 1;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf32_frv_size_dynamic_sections (bfd *output_bfd,
				 struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  struct _frv_dynamic_got_plt_info gpinfo;
  bfd_signed_vma odd;
  bfd_vma limit;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  memset (&gpinfo, 0, sizeof (gpinfo));
  gpinfo.g.info = info;

  for (;;)
    {
      htab_t relocs = frv_relocs_info (info);

      htab_traverse (relocs, _frv_resolve_final_relocs_info, &relocs);

      if (relocs == frv_relocs_info (info))
	break;
    }

  htab_traverse (frv_relocs_info (info), _frv_count_got_plt_entries,
		 &gpinfo.g);

  odd = 12;
  /* Compute the total size taken by entries in the 12-bit and 16-bit
     ranges, to tell how many PLT function descriptors we can bring
     into the 12-bit range without causing the 16-bit range to
     overflow.  */
  limit = odd + gpinfo.g.got12 + gpinfo.g.gotlos
    + gpinfo.g.fd12 + gpinfo.g.fdlos;
  if (limit < (bfd_vma)1 << 16)
    limit = ((bfd_vma)1 << 16) - limit;
  else
    limit = 0;
  if (gpinfo.g.fdplt < limit)
    limit = gpinfo.g.fdplt;

  /* Determine the ranges of GOT offsets that we can use for each
     range of addressing modes.  */
  odd = _frv_compute_got_alloc_data (&gpinfo.got12,
				     0,
				     odd,
				     16,
				     gpinfo.g.got12,
				     gpinfo.g.fd12,
				     limit,
				     (bfd_vma)1 << (12-1));
  odd = _frv_compute_got_alloc_data (&gpinfo.gotlos,
				     gpinfo.got12.min,
				     odd,
				     gpinfo.got12.max,
				     gpinfo.g.gotlos,
				     gpinfo.g.fdlos,
				     gpinfo.g.fdplt - gpinfo.got12.fdplt,
				     (bfd_vma)1 << (16-1));
  odd = _frv_compute_got_alloc_data (&gpinfo.gothilo,
				     gpinfo.gotlos.min,
				     odd,
				     gpinfo.gotlos.max,
				     gpinfo.g.gothilo,
				     gpinfo.g.fdhilo,
				     gpinfo.g.fdplt - gpinfo.got12.fdplt
				     - gpinfo.gotlos.fdplt,
				     (bfd_vma)1 << (32-1));

  /* Now assign (most) GOT offsets.  */
  htab_traverse (frv_relocs_info (info), _frv_assign_got_entries, &gpinfo);

  frv_got_section (info)->_raw_size = gpinfo.gothilo.max - gpinfo.gothilo.min
    /* If an odd word is the last word of the GOT, we don't need this
       word to be part of the GOT.  */
    - (odd + 4 == gpinfo.gothilo.max ? 4 : 0);
  if (frv_got_section (info)->_raw_size == 0)
    frv_got_section (info)->flags |= SEC_EXCLUDE;
  else if (frv_got_section (info)->_raw_size == 12
	   && ! elf_hash_table (info)->dynamic_sections_created)
    {
      frv_got_section (info)->flags |= SEC_EXCLUDE;
      frv_got_section (info)->_raw_size = 0;
    }
  else
    {
      frv_got_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj, frv_got_section (info)->_raw_size);
      if (frv_got_section (info)->contents == NULL)
	return FALSE;
    }
  
  if (elf_hash_table (info)->dynamic_sections_created)
    /* Subtract the number of lzplt entries, since those will generate
       relocations in the pltrel section.  */
    frv_gotrel_section (info)->_raw_size =
      (gpinfo.g.relocs - gpinfo.g.lzplt / 8)
      * get_elf_backend_data (output_bfd)->s->sizeof_rel;
  else
    BFD_ASSERT (gpinfo.g.relocs == 0);
  if (frv_gotrel_section (info)->_raw_size == 0)
    frv_gotrel_section (info)->flags |= SEC_EXCLUDE;
  else
    {
      frv_gotrel_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj, frv_gotrel_section (info)->_raw_size);
      if (frv_gotrel_section (info)->contents == NULL)
	return FALSE;
    }

  if (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
    frv_gotfixup_section (info)->_raw_size = (gpinfo.g.fixups + 1) * 4;
  if (frv_gotfixup_section (info)->_raw_size == 0)
    frv_gotfixup_section (info)->flags |= SEC_EXCLUDE;
  else
    {
      frv_gotfixup_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 frv_gotfixup_section (info)->_raw_size);
      if (frv_gotfixup_section (info)->contents == NULL)
	return FALSE;
    }
  
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      frv_pltrel_section (info)->_raw_size =
	gpinfo.g.lzplt / 8 * get_elf_backend_data (output_bfd)->s->sizeof_rel;
      if (frv_pltrel_section (info)->_raw_size == 0)
	frv_pltrel_section (info)->flags |= SEC_EXCLUDE;
      else
d725 7
a731 5
	  frv_pltrel_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj,
				     frv_pltrel_section (info)->_raw_size);
	  if (frv_pltrel_section (info)->contents == NULL)
	    return FALSE;
a732 38
    }
  
  /* Add 4 bytes for every block of at most 65535 lazy PLT entries,
     such that there's room for the additional instruction needed to
     call the resolver.  Since _frv_assign_got_entries didn't account
     for them, our block size is 4 bytes smaller than the real block
     size.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      frv_plt_section (info)->_raw_size = gpinfo.g.lzplt
	+ ((gpinfo.g.lzplt + (FRV_LZPLT_BLOCK_SIZE - 4) - 8)
	   / (FRV_LZPLT_BLOCK_SIZE - 4) * 4);
    }

  /* Reset it, such that _frv_assign_plt_entries() can use it to
     actually assign lazy PLT entries addresses.  */
  gpinfo.g.lzplt = 0;

  /* Save information that we're going to need to generate GOT and PLT
     entries.  */
  frv_got_initial_offset (info) = -gpinfo.gothilo.min;

  if (get_elf_backend_data (output_bfd)->want_got_sym)
    elf_hash_table (info)->hgot->root.u.def.value
      += frv_got_initial_offset (info);

  if (elf_hash_table (info)->dynamic_sections_created)
    frv_plt_initial_offset (info) = frv_plt_section (info)->_raw_size;

  htab_traverse (frv_relocs_info (info), _frv_assign_plt_entries, &gpinfo);

  /* Allocate the PLT section contents only after
     _frv_assign_plt_entries has a chance to add the size of the
     non-lazy PLT entries.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      if (frv_plt_section (info)->_raw_size == 0)
	frv_plt_section (info)->flags |= SEC_EXCLUDE;
d735 1
a735 6
	  frv_plt_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj, frv_plt_section (info)->_raw_size);
	  if (frv_plt_section (info)->contents == NULL)
	    return FALSE;
	}
    }
d737 3
a739 19
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      if (frv_got_section (info)->_raw_size)
	if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0))
	  return FALSE;

      if (frv_pltrel_section (info)->_raw_size)
	if (! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_REL)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
	  return FALSE;

      if (frv_gotrel_section (info)->_raw_size)
	if (! bfd_elf32_add_dynamic_entry (info, DT_REL, 0)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_RELSZ, 0)
	    || ! bfd_elf32_add_dynamic_entry (info, DT_RELENT,
					      sizeof (Elf32_External_Rel)))
	  return FALSE;
    }
d741 1
a741 2
  return TRUE;
}
d743 21
a763 9
static bfd_boolean
elf32_frv_always_size_sections (bfd *output_bfd,
				struct bfd_link_info *info)
{
  if (!info->relocatable
      && elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
    {
      struct elf_link_hash_entry *h;
      asection *sec;
d765 2
a766 12
      /* Force a PT_GNU_STACK segment to be created.  */
      if (! elf_tdata (output_bfd)->stack_flags)
	elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;

      /* Define __stacksize if it's not defined yet.  */
      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				FALSE, FALSE, FALSE);
      if (! h || h->root.type != bfd_link_hash_defined
	  || h->type != STT_OBJECT
	  || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	{
	  struct bfd_link_hash_entry *bh;
d768 2
a769 6
	  if (!(_bfd_generic_link_add_one_symbol
		(info, output_bfd, "__stacksize",
		 BSF_GLOBAL, bfd_abs_section_ptr, DEFAULT_STACK_SIZE,
		 (const char *) NULL, FALSE,
		 get_elf_backend_data (output_bfd)->collect, &bh)))
	    return FALSE;
d771 3
a773 4
	  h = (struct elf_link_hash_entry *) bh;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  h->type = STT_OBJECT;
	}
d775 3
a777 2
      /* Create a stack section, and set its alignment.  */
      sec = bfd_make_section (output_bfd, ".stack");
d779 3
a781 4
      if (sec == NULL
	  || ! bfd_set_section_alignment (output_bfd, sec, 3))
	return FALSE;
    }
d783 3
a785 2
  return TRUE;
}
d787 3
a789 7
static bfd_boolean
elf32_frv_modify_segment_map (bfd *output_bfd,
			      struct bfd_link_info *info)
{
  if (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
    {
      struct elf_segment_map *m;
d791 3
a793 3
      for (m = elf_tdata (output_bfd)->segment_map; m != NULL; m = m->next)
	if (m->p_type == PT_GNU_STACK)
	  break;
d795 1
a795 1
      if (m)
d797 1
a797 2
	  asection *sec = bfd_get_section_by_name (output_bfd, ".stack");
	  struct elf_link_hash_entry *h;
d799 1
a799 1
	  if (sec)
d801 5
a805 23
	      /* Obtain the pointer to the __stacksize symbol.  */
	      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
					FALSE, FALSE, FALSE);
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *)h->root.u.i.link;
	      BFD_ASSERT (h->root.type == bfd_link_hash_defined);

	      /* Set the section size from the symbol value.  We
		 intentionally ignore the symbol section.  */
	      if (h->root.type == bfd_link_hash_defined)
		sec->_raw_size = h->root.u.def.value;
	      else
		sec->_raw_size = DEFAULT_STACK_SIZE;

	      /* Add the stack section to the PT_GNU_STACK segment,
		 such that its size and alignment requirements make it
		 to the segment.  */
	      m->sections[m->count] = sec;
	      m->count++;
	    }
	}
    }
d807 4
a810 2
  return TRUE;
}
d812 3
a814 1
/* Fill in code and data in dynamic sections.  */
d816 3
a818 6
static bfd_boolean
elf32_frv_finish_dynamic_sections (bfd *output_bfd,
				   struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sdyn;
d820 3
a822 1
  dynobj = elf_hash_table (info)->dynobj;
d824 4
a827 5
  if (frv_got_section (info))
    {
      BFD_ASSERT (frv_gotrel_section (info)->_raw_size
		  == (frv_gotrel_section (info)->reloc_count
		      * sizeof (Elf32_External_Rel)));
d829 3
a831 8
      if (frv_gotfixup_section (info))
	{
	  if (elf_elfheader (output_bfd)->e_flags & EF_FRV_FDPIC)
	    {
	      struct elf_link_hash_entry *hgot = elf_hash_table (info)->hgot;
	      bfd_vma got_value = hgot->root.u.def.value
		+ hgot->root.u.def.section->output_section->vma
		+ hgot->root.u.def.section->output_offset;
d833 2
a834 16
	      _frv_add_rofixup (output_bfd, frv_gotfixup_section (info),
				got_value);
	    }

	  if (frv_gotfixup_section (info)->_raw_size
	      != (frv_gotfixup_section (info)->reloc_count * 4))
	    {
	      if (!elf_hash_table (info)->dynamic_sections_created)
		{
		  info->callbacks->warning
		    (info, "no dynamic sections, missing -melf32frvfd?",
		     ".rofixup", NULL, NULL, 0);
		  return FALSE;
		}
	      BFD_ASSERT (0);
	    }
a836 6
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      BFD_ASSERT (frv_pltrel_section (info)->_raw_size
		  == (frv_pltrel_section (info)->reloc_count
		      * sizeof (Elf32_External_Rel)));
    }
d838 5
a842 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d844 9
a852 1
  if (elf_hash_table (info)->dynamic_sections_created)
d854 1
a854 9
      Elf32_External_Dyn * dyncon;
      Elf32_External_Dyn * dynconend;

      BFD_ASSERT (sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);

      for (; dyncon < dynconend; dyncon++)
d856 3
a858 1
	  Elf_Internal_Dyn dyn;
d860 2
a861 3
	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
d866 3
a868 6
	    case DT_PLTGOT:
	      dyn.d_un.d_ptr = frv_got_section (info)->output_section->vma
		+ frv_got_section (info)->output_offset
		+ frv_got_initial_offset (info);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
d870 2
a871 13
	    case DT_JMPREL:
	      dyn.d_un.d_ptr = frv_pltrel_section (info)->output_section->vma
		+ frv_pltrel_section (info)->output_offset;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      if (frv_pltrel_section (info)->_cooked_size != 0)
		dyn.d_un.d_val = frv_pltrel_section (info)->_cooked_size;
	      else
		dyn.d_un.d_val = frv_pltrel_section (info)->_raw_size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
d875 2
d878 1
a878 1
  return TRUE;
d881 1
a881 2
/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  */
d884 5
a888 2
elf32_frv_adjust_dynamic_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
				 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
d890 2
a891 1
  bfd * dynobj;
d893 3
a895 1
  dynobj = elf_hash_table (info)->dynobj;
d897 13
a909 14
  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->weakdef != NULL
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
d911 4
a914 5
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
    }
d916 9
a924 2
  return TRUE;
}
d926 3
a928 1
/* Perform any actions needed for dynamic symbols.  */
a929 6
static bfd_boolean
elf32_frv_finish_dynamic_symbol (bfd *output_bfd ATTRIBUTE_UNUSED,
				 struct bfd_link_info *info ATTRIBUTE_UNUSED,
				 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED,
				 Elf_Internal_Sym *sym ATTRIBUTE_UNUSED)
{
a931 1

d933 2
a934 102

   Besides handling virtual table relocs for gc, we have to deal with
   all sorts of PIC-related relocations.  We describe below the
   general plan on how to handle such relocations, even though we only
   collect information at this point, storing them in hash tables for
   perusal of later passes.

   32 relocations are propagated to the linker output when creating
   position-independent output.  LO16 and HI16 relocations are not
   supposed to be encountered in this case.

   LABEL16 should always be resolvable by the linker, since it's only
   used by branches.

   LABEL24, on the other hand, is used by calls.  If it turns out that
   the target of a call is a dynamic symbol, a PLT entry must be
   created for it, which triggers the creation of a private function
   descriptor and, unless lazy binding is disabled, a lazy PLT entry.

   GPREL relocations require the referenced symbol to be in the same
   segment as _gp, but this can only be checked later.

   All GOT, GOTOFF and FUNCDESC relocations require a .got section to
   exist.  LABEL24 might as well, since it may require a PLT entry,
   that will require a got.

   Non-FUNCDESC GOT relocations require a GOT entry to be created
   regardless of whether the symbol is dynamic.  However, since a
   global symbol that turns out to not be exported may have the same
   address of a non-dynamic symbol, we don't assign GOT entries at
   this point, such that we can share them in this case.  A relocation
   for the GOT entry always has to be created, be it to offset a
   private symbol by the section load address, be it to get the symbol
   resolved dynamically.

   FUNCDESC GOT relocations require a GOT entry to be created, and
   handled as if a FUNCDESC relocation was applied to the GOT entry in
   an object file.

   FUNCDESC relocations referencing a symbol that turns out to NOT be
   dynamic cause a private function descriptor to be created.  The
   FUNCDESC relocation then decays to a 32 relocation that points at
   the private descriptor.  If the symbol is dynamic, the FUNCDESC
   relocation is propagated to the linker output, such that the
   dynamic linker creates the canonical descriptor, pointing to the
   dynamically-resolved definition of the function.

   Non-FUNCDESC GOTOFF relocations must always refer to non-dynamic
   symbols that are assigned to the same segment as the GOT, but we
   can only check this later, after we know the complete set of
   symbols defined and/or exported.

   FUNCDESC GOTOFF relocations require a function descriptor to be
   created and, unless lazy binding is disabled or the symbol is not
   dynamic, a lazy PLT entry.  Since we can't tell at this point
   whether a symbol is going to be dynamic, we have to decide later
   whether to create a lazy PLT entry or bind the descriptor directly
   to the private function.

   FUNCDESC_VALUE relocations are not supposed to be present in object
   files, but they may very well be simply propagated to the linker
   output, since they have no side effect.


   A function descriptor always requires a FUNCDESC_VALUE relocation.
   Whether it's in .plt.rel or not depends on whether lazy binding is
   enabled and on whether the referenced symbol is dynamic.

   The existence of a lazy PLT requires the resolverStub lazy PLT
   entry to be present.


   As for assignment of GOT, PLT and lazy PLT entries, and private
   descriptors, we might do them all sequentially, but we can do
   better than that.  For example, we can place GOT entries and
   private function descriptors referenced using 12-bit operands
   closer to the PIC register value, such that these relocations don't
   overflow.  Those that are only referenced with LO16 relocations
   could come next, but we may as well place PLT-required function
   descriptors in the 12-bit range to make them shorter.  Symbols
   referenced with LO16/HI16 may come next, but we may place
   additional function descriptors in the 16-bit range if we can
   reliably tell that we've already placed entries that are ever
   referenced with only LO16.  PLT entries are therefore generated as
   small as possible, while not introducing relocation overflows in
   GOT or FUNCDESC_GOTOFF relocations.  Lazy PLT entries could be
   generated before or after PLT entries, but not intermingled with
   them, such that we can have more lazy PLT entries in range for a
   branch to the resolverStub.  The resolverStub should be emitted at
   the most distant location from the first lazy PLT entry such that
   it's still in range for a branch, or closer, if there isn't a need
   for so many lazy PLT entries.  Additional lazy PLT entries may be
   emitted after the resolverStub, as long as branches are still in
   range.  If the branch goes out of range, longer lazy PLT entries
   are emitted.

   We could further optimize PLT and lazy PLT entries by giving them
   priority in assignment to closer-to-gr17 locations depending on the
   number of occurrences of references to them (assuming a function
   that's called more often is more important for performance, so its
   PLT entry should be faster), or taking hints from the compiler.
   Given infinite time and money... :-)  */
a946 2
  bfd *dynobj;
  struct frv_pic_relocs_info *picrel;
a956 1
  dynobj = elf_hash_table (info)->dynobj;
a969 54
	{
	case R_FRV_LABEL24:
	case R_FRV_32:
	case R_FRV_GOT12:
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	case R_FRV_FUNCDESC_GOT12:
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFFLO:
	case R_FRV_FUNCDESC_GOTOFF12:
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	case R_FRV_FUNCDESC:
	case R_FRV_FUNCDESC_VALUE:
	  if (! dynobj)
	    {
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _frv_create_got_section (abfd, info))
		return FALSE;
	    }
	  if (h != NULL)
	    {
	      if (h->dynindx == -1)
		switch (ELF_ST_VISIBILITY (h->other))
		  {
		  case STV_INTERNAL:
		  case STV_HIDDEN:
		    break;
		  default:
		    bfd_elf32_link_record_dynamic_symbol (info, h);
		    break;
		  }
	      picrel
		= frv_pic_relocs_info_for_global (frv_relocs_info (info),
						  abfd, h,
						  rel->r_addend);
	    }
	  else
	    picrel = frv_pic_relocs_info_for_local (frv_relocs_info (info),
						    abfd, r_symndx,
						    rel->r_addend);
	  if (! picrel)
	    return FALSE;
	  break;

	default:
	  picrel = NULL;
	  break;
	}
      
      switch (ELF32_R_TYPE (rel->r_info))
a970 53
	case R_FRV_LABEL24:
	  picrel->call = 1;
	  break;
		
	case R_FRV_FUNCDESC_VALUE:
	  picrel->relocsfdv++;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32--;
	  /* Fall through.  */
	case R_FRV_32:
	  picrel->sym = 1;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32++;
	  break;
	    
	case R_FRV_GOT12:
	  picrel->got12 = 1;
	  break;
	    
	case R_FRV_GOTHI:
	case R_FRV_GOTLO:
	  picrel->gothilo = 1;
	  break;

	case R_FRV_FUNCDESC_GOT12:
	  picrel->fdgot12 = 1;
	  break;
	    
	case R_FRV_FUNCDESC_GOTHI:
	case R_FRV_FUNCDESC_GOTLO:
	  picrel->fdgothilo = 1;
	  break;
	    
	case R_FRV_GOTOFF12:
	case R_FRV_GOTOFFHI:
	case R_FRV_GOTOFFLO:
	  picrel->gotoff = 1;
	  break;
	    
	case R_FRV_FUNCDESC_GOTOFF12:
	  picrel->fdgoff12 = 1;
	  break;
	    
	case R_FRV_FUNCDESC_GOTOFFHI:
	case R_FRV_FUNCDESC_GOTOFFLO:
	  picrel->fdgoffhilo = 1;
	  break;
	    
	case R_FRV_FUNCDESC:
	  picrel->fd = 1;
	  picrel->relocsfd++;
	  break;
	  
a1069 3
  if (new_flags & EF_FRV_FDPIC)
    new_flags &= ~EF_FRV_PIC;

a1371 6
  if (flags & EF_FRV_LIBPIC)
    fprintf (file, " -mlibrary-pic");

  if (flags & EF_FRV_FDPIC)
    fprintf (file, " -mfdpic");
  
d1390 1
a1390 1
#define elf_info_to_howto_rel			frv_info_to_howto_rel
a1406 29

#define bfd_elf32_bfd_link_hash_table_create  frv_elf_link_hash_table_create
#define elf_backend_always_size_sections \
		elf32_frv_always_size_sections
#define elf_backend_modify_segment_map \
		elf32_frv_modify_segment_map

#define elf_backend_create_dynamic_sections \
		elf32_frv_create_dynamic_sections
#define elf_backend_adjust_dynamic_symbol \
		elf32_frv_adjust_dynamic_symbol
#define elf_backend_size_dynamic_sections \
		elf32_frv_size_dynamic_sections
#define elf_backend_finish_dynamic_symbol \
		elf32_frv_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
		elf32_frv_finish_dynamic_sections

#define elf_backend_want_got_sym	1
#define elf_backend_got_header_size	0
#define elf_backend_want_got_plt	0
#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_plt_header_size	0

#define elf_backend_may_use_rel_p       1
#define elf_backend_may_use_rela_p      1
/* We use REL for dynamic relocations only.  */
#define elf_backend_default_use_rela_p  1
@


1.2
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@a623 3
   There is some attempt to make this function usable for many architectures,
   both USE_REL and USE_RELA ['twould be nice if such a critter existed],
   if only to serve as a learning tool.
d655 1
a655 1
			   contents, relocs, local_syms, local_sections)
d670 3
d695 1
a696 22

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections [r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d1371 1
@


1.1
log
@2002-06-18  Dave Brolley  <brolley@@redhat.com>

	From Catherine Moore, Michael Meissner, Dave Brolley:
	* po/SRC-POTFILES.in: Add cpu-frv.c and elf32-frv.c
	* targets.c: Support bfd_elf32_frv_vec.
	* reloc.c: Add FRV relocs.
	* configure.in: Add support for bfd-elf32-frv-vec.
	* config.bfd (targ_cpu): Add support for frv-*-elf.
	* archures.c: Add frv arch and machines.
	* Makefile.am (ALL_MACHINES): Add cpu-frv.lo.
	(ALL_MACHINES_CFILES): Add cpu-frv.c.
	(BFD32_BACKENDS): Add elf32-frv.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-frv.c
	(cpu-frv.lo): New target.
	(elf32-frv.lo): New target.
	* cpu-frv.c: New file.
	* elf32-frv.c: New file.
@
text
@d54 1
a54 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *, struct elf_link_hash_entry *, Elf_Internal_Sym *));
d841 2
a842 2
elf32_frv_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *                        abfd;
d872 1
a872 7
    {
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.1.4.1
log
@Merge with trunk.
@
text
@@


1.1.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@@


1.1.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d54 1
a54 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *, struct elf_link_hash_entry *, Elf_Internal_Sym *));
d841 2
a842 2
elf32_frv_gc_mark_hook (sec, info, rel, h, sym)
     asection *                   sec;
d872 7
a878 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
@


1.1.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d624 3
d658 1
a658 1
			    contents, relocs, local_syms, local_sections)
a672 3
  if (info->relocateable)
    return true;

d695 22
a717 1
      r_symndx = ELF32_R_SYM (rel->r_info);
a1391 1
#define elf_backend_rela_normal			1
@


