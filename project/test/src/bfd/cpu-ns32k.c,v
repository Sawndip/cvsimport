head	1.24;
access;
symbols
	sid-snapshot-20180601:1.24
	sid-snapshot-20180501:1.24
	sid-snapshot-20180401:1.24
	sid-snapshot-20180301:1.24
	sid-snapshot-20180201:1.24
	sid-snapshot-20180101:1.24
	sid-snapshot-20171201:1.24
	sid-snapshot-20171101:1.24
	sid-snapshot-20171001:1.24
	sid-snapshot-20170901:1.24
	sid-snapshot-20170801:1.24
	sid-snapshot-20170701:1.24
	sid-snapshot-20170601:1.24
	sid-snapshot-20170501:1.24
	sid-snapshot-20170401:1.24
	sid-snapshot-20170301:1.24
	sid-snapshot-20170201:1.24
	sid-snapshot-20170101:1.24
	sid-snapshot-20161201:1.24
	sid-snapshot-20161101:1.24
	sid-snapshot-20160901:1.24
	sid-snapshot-20160801:1.24
	sid-snapshot-20160701:1.24
	sid-snapshot-20160601:1.24
	sid-snapshot-20160501:1.24
	sid-snapshot-20160401:1.24
	sid-snapshot-20160301:1.24
	sid-snapshot-20160201:1.24
	sid-snapshot-20160101:1.24
	sid-snapshot-20151201:1.24
	sid-snapshot-20151101:1.24
	sid-snapshot-20151001:1.24
	sid-snapshot-20150901:1.24
	sid-snapshot-20150801:1.24
	sid-snapshot-20150701:1.24
	sid-snapshot-20150601:1.24
	sid-snapshot-20150501:1.24
	sid-snapshot-20150401:1.24
	sid-snapshot-20150301:1.24
	sid-snapshot-20150201:1.24
	sid-snapshot-20150101:1.24
	sid-snapshot-20141201:1.24
	sid-snapshot-20141101:1.24
	sid-snapshot-20141001:1.24
	sid-snapshot-20140901:1.24
	sid-snapshot-20140801:1.24
	sid-snapshot-20140701:1.24
	sid-snapshot-20140601:1.24
	sid-snapshot-20140501:1.24
	sid-snapshot-20140401:1.24
	sid-snapshot-20140301:1.24
	sid-snapshot-20140201:1.24
	sid-snapshot-20140101:1.24
	sid-snapshot-20131201:1.24
	sid-snapshot-20131101:1.24
	sid-snapshot-20131001:1.24
	binutils-2_24-branch:1.24.0.8
	binutils-2_24-branchpoint:1.24
	binutils-2_21_1:1.21
	sid-snapshot-20130901:1.24
	gdb_7_6_1-2013-08-30-release:1.24
	sid-snapshot-20130801:1.24
	sid-snapshot-20130701:1.24
	sid-snapshot-20130601:1.24
	sid-snapshot-20130501:1.24
	gdb_7_6-2013-04-26-release:1.24
	sid-snapshot-20130401:1.24
	binutils-2_23_2:1.24
	gdb_7_6-branch:1.24.0.6
	gdb_7_6-2013-03-12-branchpoint:1.24
	sid-snapshot-20130301:1.24
	sid-snapshot-20130201:1.24
	sid-snapshot-20130101:1.24
	sid-snapshot-20121201:1.24
	gdb_7_5_1-2012-11-29-release:1.24
	binutils-2_23_1:1.24
	sid-snapshot-20121101:1.24
	binutils-2_23:1.24
	sid-snapshot-20121001:1.24
	sid-snapshot-20120901:1.24
	gdb_7_5-2012-08-17-release:1.24
	sid-snapshot-20120801:1.24
	binutils-2_23-branch:1.24.0.4
	binutils-2_23-branchpoint:1.24
	gdb_7_5-branch:1.24.0.2
	gdb_7_5-2012-07-18-branchpoint:1.24
	sid-snapshot-20120701:1.23
	sid-snapshot-20120601:1.23
	sid-snapshot-20120501:1.22
	binutils-2_22_branch:1.21.0.48
	gdb_7_4_1-2012-04-26-release:1.21
	sid-snapshot-20120401:1.22
	sid-snapshot-20120301:1.22
	sid-snapshot-20120201:1.22
	gdb_7_4-2012-01-24-release:1.21
	sid-snapshot-20120101:1.21
	gdb_7_4-branch:1.21.0.46
	gdb_7_4-2011-12-13-branchpoint:1.21
	sid-snapshot-20111201:1.21
	binutils-2_22:1.21
	sid-snapshot-20111101:1.21
	sid-snapshot-20111001:1.21
	binutils-2_22-branch:1.21.0.44
	binutils-2_22-branchpoint:1.21
	gdb_7_3_1-2011-09-04-release:1.21
	sid-snapshot-20110901:1.21
	sid-snapshot-20110801:1.21
	gdb_7_3-2011-07-26-release:1.21
	sid-snapshot-20110701:1.21
	sid-snapshot-20110601:1.21
	sid-snapshot-20110501:1.21
	gdb_7_3-branch:1.21.0.42
	gdb_7_3-2011-04-01-branchpoint:1.21
	sid-snapshot-20110401:1.21
	sid-snapshot-20110301:1.21
	sid-snapshot-20110201:1.21
	sid-snapshot-20110101:1.21
	binutils-2_21:1.21
	sid-snapshot-20101201:1.21
	binutils-2_21-branch:1.21.0.40
	binutils-2_21-branchpoint:1.21
	sid-snapshot-20101101:1.21
	sid-snapshot-20101001:1.21
	binutils-2_20_1:1.21
	gdb_7_2-2010-09-02-release:1.21
	sid-snapshot-20100901:1.21
	sid-snapshot-20100801:1.21
	gdb_7_2-branch:1.21.0.38
	gdb_7_2-2010-07-07-branchpoint:1.21
	sid-snapshot-20100701:1.21
	sid-snapshot-20100601:1.21
	sid-snapshot-20100501:1.21
	sid-snapshot-20100401:1.21
	gdb_7_1-2010-03-18-release:1.21
	sid-snapshot-20100301:1.21
	gdb_7_1-branch:1.21.0.36
	gdb_7_1-2010-02-18-branchpoint:1.21
	sid-snapshot-20100201:1.21
	sid-snapshot-20100101:1.21
	gdb_7_0_1-2009-12-22-release:1.21
	sid-snapshot-20091201:1.21
	sid-snapshot-20091101:1.21
	binutils-2_20:1.21
	gdb_7_0-2009-10-06-release:1.21
	sid-snapshot-20091001:1.21
	gdb_7_0-branch:1.21.0.34
	gdb_7_0-2009-09-16-branchpoint:1.21
	arc-sim-20090309:1.21
	binutils-arc-20081103-branch:1.21.0.32
	binutils-arc-20081103-branchpoint:1.21
	binutils-2_20-branch:1.21.0.30
	binutils-2_20-branchpoint:1.21
	sid-snapshot-20090901:1.21
	sid-snapshot-20090801:1.21
	msnyder-checkpoint-072509-branch:1.21.0.28
	msnyder-checkpoint-072509-branchpoint:1.21
	sid-snapshot-20090701:1.21
	dje-cgen-play1-branch:1.21.0.26
	dje-cgen-play1-branchpoint:1.21
	sid-snapshot-20090601:1.21
	sid-snapshot-20090501:1.21
	sid-snapshot-20090401:1.21
	arc-20081103-branch:1.21.0.24
	arc-20081103-branchpoint:1.21
	arc-insight_6_8-branch:1.21.0.22
	arc-insight_6_8-branchpoint:1.21
	insight_6_8-branch:1.21.0.20
	insight_6_8-branchpoint:1.21
	sid-snapshot-20090301:1.21
	binutils-2_19_1:1.21
	sid-snapshot-20090201:1.21
	sid-snapshot-20090101:1.21
	reverse-20081226-branch:1.21.0.18
	reverse-20081226-branchpoint:1.21
	sid-snapshot-20081201:1.21
	multiprocess-20081120-branch:1.21.0.16
	multiprocess-20081120-branchpoint:1.21
	sid-snapshot-20081101:1.21
	binutils-2_19:1.21
	sid-snapshot-20081001:1.21
	reverse-20080930-branch:1.21.0.14
	reverse-20080930-branchpoint:1.21
	binutils-2_19-branch:1.21.0.12
	binutils-2_19-branchpoint:1.21
	sid-snapshot-20080901:1.21
	sid-snapshot-20080801:1.21
	reverse-20080717-branch:1.21.0.10
	reverse-20080717-branchpoint:1.21
	sid-snapshot-20080701:1.21
	msnyder-reverse-20080609-branch:1.21.0.8
	msnyder-reverse-20080609-branchpoint:1.21
	drow-reverse-20070409-branch:1.19.0.34
	drow-reverse-20070409-branchpoint:1.19
	sid-snapshot-20080601:1.21
	sid-snapshot-20080501:1.21
	sid-snapshot-20080403:1.21
	sid-snapshot-20080401:1.21
	gdb_6_8-2008-03-27-release:1.21
	sid-snapshot-20080301:1.21
	gdb_6_8-branch:1.21.0.6
	gdb_6_8-2008-02-26-branchpoint:1.21
	sid-snapshot-20080201:1.21
	sid-snapshot-20080101:1.21
	sid-snapshot-20071201:1.21
	sid-snapshot-20071101:1.21
	gdb_6_7_1-2007-10-29-release:1.21
	gdb_6_7-2007-10-10-release:1.21
	sid-snapshot-20071001:1.21
	gdb_6_7-branch:1.21.0.4
	gdb_6_7-2007-09-07-branchpoint:1.21
	binutils-2_18:1.21
	binutils-2_18-branch:1.21.0.2
	binutils-2_18-branchpoint:1.21
	insight_6_6-20070208-release:1.19
	binutils-csl-coldfire-4_1-32:1.19
	binutils-csl-sourcerygxx-4_1-32:1.19
	gdb_6_6-2006-12-18-release:1.19
	binutils-csl-innovasic-fido-3_4_4-33:1.19
	binutils-csl-sourcerygxx-3_4_4-32:1.17
	binutils-csl-coldfire-4_1-30:1.19
	binutils-csl-sourcerygxx-4_1-30:1.19
	binutils-csl-coldfire-4_1-28:1.19
	binutils-csl-sourcerygxx-4_1-29:1.19
	binutils-csl-sourcerygxx-4_1-28:1.19
	gdb_6_6-branch:1.19.0.32
	gdb_6_6-2006-11-15-branchpoint:1.19
	binutils-csl-arm-2006q3-27:1.19
	binutils-csl-sourcerygxx-4_1-27:1.19
	binutils-csl-arm-2006q3-26:1.19
	binutils-csl-sourcerygxx-4_1-26:1.19
	binutils-csl-sourcerygxx-4_1-25:1.19
	binutils-csl-sourcerygxx-4_1-24:1.19
	binutils-csl-sourcerygxx-4_1-23:1.19
	insight_6_5-20061003-release:1.19
	gdb-csl-symbian-6_4_50_20060226-12:1.19
	binutils-csl-sourcerygxx-4_1-21:1.19
	binutils-csl-arm-2006q3-21:1.19
	binutils-csl-sourcerygxx-4_1-22:1.19
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.19
	binutils-csl-sourcerygxx-4_1-20:1.19
	binutils-csl-arm-2006q3-19:1.19
	binutils-csl-sourcerygxx-4_1-19:1.19
	binutils-csl-sourcerygxx-4_1-18:1.19
	binutils-csl-renesas-4_1-9:1.19
	gdb-csl-sourcerygxx-3_4_4-25:1.19
	binutils-csl-sourcerygxx-3_4_4-25:1.17
	nickrob-async-20060828-mergepoint:1.19
	gdb-csl-symbian-6_4_50_20060226-11:1.19
	binutils-csl-renesas-4_1-8:1.19
	binutils-csl-renesas-4_1-7:1.19
	binutils-csl-renesas-4_1-6:1.19
	gdb-csl-sourcerygxx-4_1-17:1.19
	binutils-csl-sourcerygxx-4_1-17:1.19
	gdb-csl-20060226-branch-local-2:1.19
	gdb-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-15:1.19
	gdb-csl-sourcerygxx-4_1-13:1.19
	binutils-csl-sourcerygxx-4_1-13:1.19
	binutils-2_17:1.19
	gdb-csl-sourcerygxx-4_1-12:1.19
	binutils-csl-sourcerygxx-4_1-12:1.19
	gdb-csl-sourcerygxx-3_4_4-21:1.19
	binutils-csl-sourcerygxx-3_4_4-21:1.19
	gdb_6_5-20060621-release:1.19
	binutils-csl-wrs-linux-3_4_4-24:1.17
	binutils-csl-wrs-linux-3_4_4-23:1.17
	gdb-csl-sourcerygxx-4_1-9:1.19
	binutils-csl-sourcerygxx-4_1-9:1.19
	gdb-csl-sourcerygxx-4_1-8:1.19
	binutils-csl-sourcerygxx-4_1-8:1.19
	gdb-csl-sourcerygxx-4_1-7:1.19
	binutils-csl-sourcerygxx-4_1-7:1.19
	gdb-csl-arm-2006q1-6:1.19
	binutils-csl-arm-2006q1-6:1.19
	gdb-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-wrs-linux-3_4_4-22:1.17
	gdb-csl-symbian-6_4_50_20060226-10:1.19
	gdb-csl-symbian-6_4_50_20060226-9:1.19
	gdb-csl-symbian-6_4_50_20060226-8:1.19
	gdb-csl-coldfire-4_1-11:1.19
	binutils-csl-coldfire-4_1-11:1.19
	gdb-csl-sourcerygxx-3_4_4-19:1.19
	binutils-csl-sourcerygxx-3_4_4-19:1.19
	gdb-csl-coldfire-4_1-10:1.19
	gdb_6_5-branch:1.19.0.30
	gdb_6_5-2006-05-14-branchpoint:1.19
	binutils-csl-coldfire-4_1-10:1.19
	gdb-csl-sourcerygxx-4_1-5:1.19
	binutils-csl-sourcerygxx-4_1-5:1.19
	nickrob-async-20060513-branch:1.19.0.28
	nickrob-async-20060513-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-4:1.19
	binutils-csl-sourcerygxx-4_1-4:1.19
	msnyder-reverse-20060502-branch:1.19.0.26
	msnyder-reverse-20060502-branchpoint:1.19
	binutils-csl-wrs-linux-3_4_4-21:1.17
	gdb-csl-morpho-4_1-4:1.19
	binutils-csl-morpho-4_1-4:1.19
	gdb-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-wrs-linux-3_4_4-20:1.17
	readline_5_1-import-branch:1.19.0.24
	readline_5_1-import-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19
	binutils-2_17-branch:1.19.0.22
	binutils-2_17-branchpoint:1.19
	gdb-csl-symbian-20060226-branch:1.19.0.20
	gdb-csl-symbian-20060226-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19
	msnyder-reverse-20060331-branch:1.19.0.18
	msnyder-reverse-20060331-branchpoint:1.19
	binutils-csl-2_17-branch:1.19.0.16
	binutils-csl-2_17-branchpoint:1.19
	gdb-csl-available-20060303-branch:1.19.0.14
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.12
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.19
	msnyder-fork-checkpoint-branch:1.19.0.10
	msnyder-fork-checkpoint-branchpoint:1.19
	gdb-csl-gxxpro-6_3-branch:1.19.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.19
	gdb_6_4-branch:1.19.0.6
	gdb_6_4-2005-11-01-branchpoint:1.19
	gdb-csl-arm-20051020-branch:1.19.0.4
	gdb-csl-arm-20051020-branchpoint:1.19
	binutils-csl-gxxpro-3_4-branch:1.17.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.17
	binutils-2_16_1:1.17
	msnyder-tracepoint-checkpoint-branch:1.19.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.19
	gdb-csl-arm-20050325-2005-q1b:1.17
	binutils-csl-arm-2005q1b:1.17
	binutils-2_16:1.17
	gdb-csl-arm-20050325-2005-q1a:1.17
	binutils-csl-arm-2005q1a:1.17
	csl-arm-20050325-branch:1.17.0.6
	csl-arm-20050325-branchpoint:1.17
	binutils-csl-arm-2005q1-branch:1.17.0.4
	binutils-csl-arm-2005q1-branchpoint:1.17
	binutils-2_16-branch:1.17.0.2
	binutils-2_16-branchpoint:1.17
	csl-arm-2004-q3d:1.15
	gdb_6_3-20041109-release:1.15
	gdb_6_3-branch:1.15.0.4
	gdb_6_3-20041019-branchpoint:1.15
	csl-arm-2004-q3:1.15
	drow_intercu-merge-20040921:1.15
	drow_intercu-merge-20040915:1.15
	jimb-gdb_6_2-e500-branch:1.15.0.6
	jimb-gdb_6_2-e500-branchpoint:1.15
	gdb_6_2-20040730-release:1.15
	gdb_6_2-branch:1.15.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.15
	gdb_6_1_1-20040616-release:1.13
	binutils-2_15:1.13
	binutils-2_15-branchpoint:1.13
	csl-arm-2004-q1a:1.13
	csl-arm-2004-q1:1.13
	gdb_6_1-2004-04-05-release:1.13
	drow_intercu-merge-20040402:1.13
	drow_intercu-merge-20040327:1.13
	ezannoni_pie-20040323-branch:1.13.0.14
	ezannoni_pie-20040323-branchpoint:1.13
	cagney_tramp-20040321-mergepoint:1.13
	cagney_tramp-20040309-branch:1.13.0.12
	cagney_tramp-20040309-branchpoint:1.13
	gdb_6_1-branch:1.13.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.13
	drow_intercu-20040221-branch:1.13.0.8
	drow_intercu-20040221-branchpoint:1.13
	binutils-2_15-branch:1.13.0.6
	cagney_bfdfile-20040213-branch:1.13.0.4
	cagney_bfdfile-20040213-branchpoint:1.13
	drow-cplus-merge-20040208:1.13
	carlton_dictionary-20040126-merge:1.13
	cagney_bigcore-20040122-branch:1.13.0.2
	cagney_bigcore-20040122-branchpoint:1.13
	drow-cplus-merge-20040113:1.13
	csl-arm-2003-q4:1.13
	drow-cplus-merge-20031224:1.13
	drow-cplus-merge-20031220:1.13
	carlton_dictionary-20031215-merge:1.13
	drow-cplus-merge-20031214:1.13
	carlton-dictionary-20031111-merge:1.12
	gdb_6_0-2003-10-04-release:1.10
	kettenis_sparc-20030918-branch:1.11.0.6
	kettenis_sparc-20030918-branchpoint:1.11
	carlton_dictionary-20030917-merge:1.11
	ezannoni_pie-20030916-branchpoint:1.11
	ezannoni_pie-20030916-branch:1.11.0.4
	cagney_x86i386-20030821-branch:1.11.0.2
	cagney_x86i386-20030821-branchpoint:1.11
	carlton_dictionary-20030805-merge:1.11
	carlton_dictionary-20030627-merge:1.11
	gdb_6_0-branch:1.10.0.36
	gdb_6_0-2003-06-23-branchpoint:1.10
	jimb-ppc64-linux-20030613-branch:1.10.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.10
	binutils-2_14:1.10
	cagney_convert-20030606-branch:1.10.0.32
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.10.0.30
	cagney_writestrings-20030508-branchpoint:1.10
	jimb-ppc64-linux-20030528-branch:1.10.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.10
	carlton_dictionary-20030523-merge:1.10
	cagney_fileio-20030521-branch:1.10.0.26
	cagney_fileio-20030521-branchpoint:1.10
	kettenis_i386newframe-20030517-mergepoint:1.10
	jimb-ppc64-linux-20030509-branch:1.10.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.10
	kettenis_i386newframe-20030504-mergepoint:1.10
	carlton_dictionary-20030430-merge:1.10
	binutils-2_14-branch:1.10.0.22
	binutils-2_14-branchpoint:1.10
	kettenis_i386newframe-20030419-branch:1.10.0.20
	kettenis_i386newframe-20030419-branchpoint:1.10
	carlton_dictionary-20030416-merge:1.10
	cagney_frameaddr-20030409-mergepoint:1.10
	kettenis_i386newframe-20030406-branch:1.10.0.18
	kettenis_i386newframe-20030406-branchpoint:1.10
	cagney_frameaddr-20030403-branchpoint:1.10
	cagney_frameaddr-20030403-branch:1.10.0.16
	cagney_framebase-20030330-mergepoint:1.10
	cagney_framebase-20030326-branch:1.10.0.14
	cagney_framebase-20030326-branchpoint:1.10
	cagney_lazyid-20030317-branch:1.10.0.12
	cagney_lazyid-20030317-branchpoint:1.10
	kettenis-i386newframe-20030316-mergepoint:1.10
	offbyone-20030313-branch:1.10.0.10
	offbyone-20030313-branchpoint:1.10
	kettenis-i386newframe-20030308-branch:1.10.0.8
	kettenis-i386newframe-20030308-branchpoint:1.10
	carlton_dictionary-20030305-merge:1.10
	cagney_offbyone-20030303-branch:1.10.0.6
	cagney_offbyone-20030303-branchpoint:1.10
	carlton_dictionary-20030207-merge:1.10
	interps-20030202-branch:1.10.0.4
	interps-20030202-branchpoint:1.10
	cagney-unwind-20030108-branch:1.10.0.2
	cagney-unwind-20030108-branchpoint:1.10
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.9
	binutils-2_13_1:1.8
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.12
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.10
	carlton_dictionary-20020920-branchpoint:1.9
	sid-20020905-branchpoint:1.9
	sid-20020905-branch:1.9.0.8
	gdb_5_3-branch:1.9.0.6
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.4
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.2
	readline_4_3-import-branchpoint:1.9
	binutils-2_13:1.8
	gdb_5_2_1-2002-07-23-release:1.7
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.2
	kseitz_interps-20020528-branch:1.7.0.10
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.8
	cagney_regbuf-20020515-branchpoint:1.7
	binutils-2_12_1:1.7
	jimb-macro-020506-branch:1.7.0.6
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	binutils-2_12:1.7
	gdb_5_2-branch:1.7.0.4
	gdb_5_2-2002-03-03-branchpoint:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.4
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.2
	gdb_5_1-2001-07-29-branchpoint:1.6
	binutils-2_11_2:1.5.2.1
	binutils-2_11_1:1.5.2.1
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.2
	insight-precleanup-2001-01-01:1.5
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.24
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2012.07.13.14.22.45;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2012.05.05.03.05.25;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2012.01.31.17.54.35;	author hjl;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.04.15.53.06;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.04.07.19.21;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.03.11.40.58;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.31.23.13.17;	author bje;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.29.13.46.29;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.24.04.46.16;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.24.18.06.40;	author kazu;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	2003.10.31.05.32.45;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.25.06.40.19;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.30.08.39.36;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.31.16.23.28;	author nickc;	state Exp;
branches
	1.9.10.1
	1.9.12.1;
next	1.8;

1.8
date	2002.06.25.06.21.50;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.18.09.57.22;	author amodra;	state Exp;
branches
	1.7.10.1;
next	1.6;

1.6
date	2001.03.08.21.03.58;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.22.01.08.53;	author kazu;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.11.16.20.48.09;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.16.20.35.08;	author nsd;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.10.28.58;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.13.8.1
date	2004.09.16.17.00.18;	author drow;	state Exp;
branches;
next	;

1.9.10.1
date	2002.12.23.19.37.34;	author carlton;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2003.06.27.21.49.10;	author carlton;	state Exp;
branches;
next	1.9.10.3;

1.9.10.3
date	2003.11.11.23.50.11;	author carlton;	state Exp;
branches;
next	1.9.10.4;

1.9.10.4
date	2003.12.15.23.59.17;	author carlton;	state Exp;
branches;
next	;

1.9.12.1
date	2003.12.14.20.26.37;	author drow;	state Exp;
branches;
next	;

1.7.10.1
date	2002.07.22.21.46.41;	author kseitz;	state Exp;
branches;
next	1.7.10.2;

1.7.10.2
date	2002.08.09.18.34.11;	author kseitz;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.24
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@/* BFD support for the ns32k architecture.
   Copyright 1990, 1991, 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2007, 2012 Free Software Foundation, Inc.
   Almost totally rewritten by Ian Dall from initial work
   by Andrew Cagney.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "ns32k.h"

#define N(machine, printable, d, next)  \
{  32, 32, 8, bfd_arch_ns32k, machine, "ns32k",printable,3,d, \
   bfd_default_compatible,bfd_default_scan,bfd_arch_default_fill,next, }

static const bfd_arch_info_type arch_info_struct[] =
{
  N(32532,"ns32k:32532",TRUE, 0), /* The word ns32k will match this too.  */
};

const bfd_arch_info_type bfd_ns32k_arch =
  N(32032,"ns32k:32032",FALSE, &arch_info_struct[0]);

bfd_vma
_bfd_ns32k_get_displacement (bfd_byte *buffer, int size)
{
  bfd_signed_vma value;

  switch (size)
    {
    case 1:
      value = ((*buffer & 0x7f) ^ 0x40) - 0x40;
      break;

    case 2:
      value = ((*buffer++ & 0x3f) ^ 0x20) - 0x20;
      value = (value << 8) | (0xff & *buffer);
      break;

    case 4:
      value = ((*buffer++ & 0x3f) ^ 0x20) - 0x20;
      value = (value << 8) | (0xff & *buffer++);
      value = (value << 8) | (0xff & *buffer++);
      value = (value << 8) | (0xff & *buffer);
      break;

    default:
      abort ();
      return 0;
    }

  return value;
}

void
_bfd_ns32k_put_displacement (bfd_vma value, bfd_byte *buffer, int size)
{
  switch (size)
    {
    case 1:
      value &= 0x7f;
      *buffer++ = value;
      break;

    case 2:
      value &= 0x3fff;
      value |= 0x8000;
      *buffer++ = (value >> 8);
      *buffer++ = value;
      break;

    case 4:
      value |= (bfd_vma) 0xc0000000;
      *buffer++ = (value >> 24);
      *buffer++ = (value >> 16);
      *buffer++ = (value >> 8);
      *buffer++ = value;
      break;
  }
  return;
}

bfd_vma
_bfd_ns32k_get_immediate (bfd_byte *buffer, int size)
{
  bfd_vma value = 0;

  switch (size)
    {
    case 4:
      value = (value << 8) | (*buffer++ & 0xff);
      value = (value << 8) | (*buffer++ & 0xff);
    case 2:
      value = (value << 8) | (*buffer++ & 0xff);
    case 1:
      value = (value << 8) | (*buffer++ & 0xff);
      break;
    default:
      abort ();
    }
  return value;
}

void
_bfd_ns32k_put_immediate (bfd_vma value, bfd_byte *buffer, int size)
{
  buffer += size - 1;
  switch (size)
    {
    case 4:
      *buffer-- = (value & 0xff); value >>= 8;
      *buffer-- = (value & 0xff); value >>= 8;
    case 2:
      *buffer-- = (value & 0xff); value >>= 8;
    case 1:
      *buffer-- = (value & 0xff); value >>= 8;
    }
}

/* This is just like the standard perform_relocation except we
   use get_data and put_data which know about the ns32k storage
   methods.  This is probably a lot more complicated than it
   needs to be!  */

static bfd_reloc_status_type
do_ns32k_reloc (bfd *      abfd,
		arelent *  reloc_entry,
		struct bfd_symbol * symbol,
		void *     data,
		asection * input_section,
		bfd *      output_bfd,
		char **    error_message ATTRIBUTE_UNUSED,
		bfd_vma (* get_data) (bfd_byte *, int),
		void (*    put_data) (bfd_vma, bfd_byte *, int))
{
  int overflow = 0;
  bfd_vma relocation;
  bfd_reloc_status_type flag = bfd_reloc_ok;
  bfd_size_type addr = reloc_entry->address;
  bfd_vma output_base = 0;
  reloc_howto_type *howto = reloc_entry->howto;
  asection *reloc_target_output_section;
  bfd_byte *location;

  if (bfd_is_abs_section (symbol->section)
      && output_bfd != (bfd *) NULL)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* If we are not producing relocatable output, return an error if
     the symbol is not defined.  An undefined weak symbol is
     considered to have a value of zero (SVR4 ABI, p. 4-27).  */
  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0
      && output_bfd == (bfd *) NULL)
    flag = bfd_reloc_undefined;

  /* Is the address of the relocation really within the section?  */
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  /* Work out which section the relocation is targeted at and the
     initial relocation command value.  */

  /* Get symbol value.  (Common symbols are special.)  */
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  reloc_target_output_section = symbol->section->output_section;

  /* Convert input-section-relative symbol value to absolute.  */
  if (output_bfd != NULL && ! howto->partial_inplace)
    output_base = 0;
  else
    output_base = reloc_target_output_section->vma;

  relocation += output_base + symbol->section->output_offset;

  /* Add in supplied addend.  */
  relocation += reloc_entry->addend;

  /* Here the variable relocation holds the final address of the
     symbol we are relocating against, plus any addend.  */

  if (howto->pc_relative)
    {
      /* This is a PC relative relocation.  We want to set RELOCATION
	 to the distance between the address of the symbol and the
	 location.  RELOCATION is already the address of the symbol.

	 We start by subtracting the address of the section containing
	 the location.

	 If pcrel_offset is set, we must further subtract the position
	 of the location within the section.  Some targets arrange for
	 the addend to be the negative of the position of the location
	 within the section; for example, i386-aout does this.  For
	 i386-aout, pcrel_offset is FALSE.  Some other targets do not
	 include the position of the location; for example, m88kbcs,
	 or ELF.  For those targets, pcrel_offset is TRUE.

	 If we are producing relocatable output, then we must ensure
	 that this reloc will be correctly computed when the final
	 relocation is done.  If pcrel_offset is FALSE we want to wind
	 up with the negative of the location within the section,
	 which means we must adjust the existing addend by the change
	 in the location within the section.  If pcrel_offset is TRUE
	 we do not want to adjust the existing addend at all.

	 FIXME: This seems logical to me, but for the case of
	 producing relocatable output it is not what the code
	 actually does.  I don't want to change it, because it seems
	 far too likely that something will break.  */
      relocation -=
	input_section->output_section->vma + input_section->output_offset;

      if (howto->pcrel_offset)
	relocation -= reloc_entry->address;
    }

  if (output_bfd != (bfd *) NULL)
    {
      if (! howto->partial_inplace)
	{
	  /* This is a partial relocation, and we want to apply the relocation
	     to the reloc entry rather than the raw data. Modify the reloc
	     inplace to reflect what we now know.  */
	  reloc_entry->addend = relocation;
	  reloc_entry->address += input_section->output_offset;
	  return flag;
	}
      else
	{
	  /* This is a partial relocation, but inplace, so modify the
	     reloc record a bit.

	     If we've relocated with a symbol with a section, change
	     into a ref to the section belonging to the symbol.  */

	  reloc_entry->address += input_section->output_offset;

	  /* WTF?? */
	  if (abfd->xvec->flavour == bfd_target_coff_flavour)
	    {
	      /* For m68k-coff, the addend was being subtracted twice during
		 relocation with -r.  Removing the line below this comment
		 fixes that problem; see PR 2953.

		 However, Ian wrote the following, regarding removing the line
		 below, which explains why it is still enabled:  --djm

		 If you put a patch like that into BFD you need to check all
		 the COFF linkers.  I am fairly certain that patch will break
		 coff-i386 (e.g., SCO); see coff_i386_reloc in coff-i386.c
		 where I worked around the problem in a different way.  There
		 may very well be a reason that the code works as it does.

		 Hmmm.  The first obvious point is that bfd_perform_relocation
		 should not have any tests that depend upon the flavour.  It's
		 seem like entirely the wrong place for such a thing.  The
		 second obvious point is that the current code ignores the
		 reloc addend when producing relocatable output for COFF.
		 That's peculiar.  In fact, I really have no idea what the
		 point of the line you want to remove is.

		 A typical COFF reloc subtracts the old value of the symbol
		 and adds in the new value to the location in the object file
		 (if it's a pc relative reloc it adds the difference between
		 the symbol value and the location).  When relocating we need
		 to preserve that property.

		 BFD handles this by setting the addend to the negative of the
		 old value of the symbol.  Unfortunately it handles common
		 symbols in a non-standard way (it doesn't subtract the old
		 value) but that's a different story (we can't change it
		 without losing backward compatibility with old object files)
		 (coff-i386 does subtract the old value, to be compatible with
		 existing coff-i386 targets, like SCO).

		 So everything works fine when not producing relocatable
		 output.  When we are producing relocatable output, logically
		 we should do exactly what we do when not producing
		 relocatable output.  Therefore, your patch is correct.  In
		 fact, it should probably always just set reloc_entry->addend
		 to 0 for all cases, since it is, in fact, going to add the
		 value into the object file.  This won't hurt the COFF code,
		 which doesn't use the addend; I'm not sure what it will do
		 to other formats (the thing to check for would be whether
		 any formats both use the addend and set partial_inplace).

		 When I wanted to make coff-i386 produce relocatable output,
		 I ran into the problem that you are running into: I wanted
		 to remove that line.  Rather than risk it, I made the
		 coff-i386 relocs use a special function; it's coff_i386_reloc
		 in coff-i386.c.  The function specifically adds the addend
		 field into the object file, knowing that bfd_perform_relocation
		 is not going to.  If you remove that line, then coff-i386.c
		 will wind up adding the addend field in twice.  It's trivial
		 to fix; it just needs to be done.

		 The problem with removing the line is just that it may break
		 some working code.  With BFD it's hard to be sure of anything.
		 The right way to deal with this is simply to build and test at
		 least all the supported COFF targets.  It should be
		 straightforward if time and disk space consuming.  For each
		 target:
		   1) build the linker
		   2) generate some executable, and link it using -r (I would
		      probably use paranoia.o and link against newlib/libc.a,
		      which for all the supported targets would be available in
		      /usr/cygnus/progressive/H-host/target/lib/libc.a).
		   3) make the change to reloc.c
		   4) rebuild the linker
		   5) repeat step 2
		   6) if the resulting object files are the same, you have at
		      least made it no worse
		   7) if they are different you have to figure out which
		      version is right.  */
	      relocation -= reloc_entry->addend;
	      reloc_entry->addend = 0;
	    }
	  else
	    {
	      reloc_entry->addend = relocation;
	    }
	}
    }
  else
    {
      reloc_entry->addend = 0;
    }

  /* FIXME: This overflow checking is incomplete, because the value
     might have overflowed before we get here.  For a correct check we
     need to compute the value in a size larger than bitsize, but we
     can't reasonably do that for a reloc the same size as a host
     machine word.
     FIXME: We should also do overflow checking on the result after
     adding in the value contained in the object file.  */
  if (howto->complain_on_overflow != complain_overflow_dont)
    {
      bfd_vma check;

      /* Get the value that will be used for the relocation, but
	 starting at bit position zero.  */
      if (howto->rightshift > howto->bitpos)
	check = relocation >> (howto->rightshift - howto->bitpos);
      else
	check = relocation << (howto->bitpos - howto->rightshift);
      switch (howto->complain_on_overflow)
	{
	case complain_overflow_signed:
	  {
	    /* Assumes two's complement.  */
	    bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	    bfd_signed_vma reloc_signed_min = ~reloc_signed_max;

	    /* The above right shift is incorrect for a signed value.
	       Fix it up by forcing on the upper bits.  */
	    if (howto->rightshift > howto->bitpos
		&& (bfd_signed_vma) relocation < 0)
	      check |= ((bfd_vma) - 1
			& ~((bfd_vma) - 1
			    >> (howto->rightshift - howto->bitpos)));
	    if ((bfd_signed_vma) check > reloc_signed_max
		|| (bfd_signed_vma) check < reloc_signed_min)
	      flag = bfd_reloc_overflow;
	  }
	  break;
	case complain_overflow_unsigned:
	  {
	    /* Assumes two's complement.  This expression avoids
	       overflow if howto->bitsize is the number of bits in
	       bfd_vma.  */
	    bfd_vma reloc_unsigned_max =
	    (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;

	    if ((bfd_vma) check > reloc_unsigned_max)
	      flag = bfd_reloc_overflow;
	  }
	  break;
	case complain_overflow_bitfield:
	  {
	    /* Assumes two's complement.  This expression avoids
	       overflow if howto->bitsize is the number of bits in
	       bfd_vma.  */
	    bfd_vma reloc_bits = (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;

	    if (((bfd_vma) check & ~reloc_bits) != 0
		&& (((bfd_vma) check & ~reloc_bits)
		    != (-(bfd_vma) 1 & ~reloc_bits)))
	      {
		/* The above right shift is incorrect for a signed
		   value.  See if turning on the upper bits fixes the
		   overflow.  */
		if (howto->rightshift > howto->bitpos
		    && (bfd_signed_vma) relocation < 0)
		  {
		    check |= ((bfd_vma) - 1
			      & ~((bfd_vma) - 1
				  >> (howto->rightshift - howto->bitpos)));
		    if (((bfd_vma) check & ~reloc_bits)
			!= (-(bfd_vma) 1 & ~reloc_bits))
		      flag = bfd_reloc_overflow;
		  }
		else
		  flag = bfd_reloc_overflow;
	      }
	  }
	  break;
	default:
	  abort ();
	}
    }

  /* Either we are relocating all the way, or we don't want to apply
     the relocation to the reloc entry (probably because there isn't
     any room in the output format to describe addends to relocs).  */

  /* The cast to bfd_vma avoids a bug in the Alpha OSF/1 C compiler
     (OSF version 1.3, compiler version 3.11).  It miscompiles the
     following program:

     struct str
     {
       unsigned int i0;
     } s = { 0 };

     int
     main ()
     {
       unsigned long x;

       x = 0x100000000;
       x <<= (unsigned long) s.i0;
       if (x == 0)
	 printf ("failed\n");
       else
	 printf ("succeeded (%lx)\n", x);
     }
     */

  relocation >>= (bfd_vma) howto->rightshift;

  /* Shift everything up to where it's going to be used.  */
  relocation <<= (bfd_vma) howto->bitpos;

  /* Wait for the day when all have the mask in them.  */

  /* What we do:
     i instruction to be left alone
     o offset within instruction
     r relocation offset to apply
     S src mask
     D dst mask
     N ~dst mask
     A part 1
     B part 2
     R result

     Do this:
     i i i i i o o o o o        from bfd_get<size>
     and           S S S S S    to get the size offset we want
     +   r r r r r r r r r r  to get the final value to place
     and           D D D D D  to chop to right size
     -----------------------
     A A A A A
     And this:
     ...   i i i i i o o o o o  from bfd_get<size>
     and   N N N N N            get instruction
     -----------------------
     ...   B B B B B

     And then:
     B B B B B
     or              A A A A A
     -----------------------
     R R R R R R R R R R        put into bfd_put<size>.  */

#define DOIT(x) \
  x = ( (x & ~howto->dst_mask) | (((x & howto->src_mask) +  relocation) & howto->dst_mask))

  location = (bfd_byte *) data + addr;
  switch (howto->size)
    {
    case 0:
      {
	bfd_vma x = get_data (location, 1);
	DOIT (x);
	put_data ((bfd_vma) x, location, 1);
      }
      break;

    case 1:
      if (relocation)
	{
	  bfd_vma x = get_data (location, 2);
	  DOIT (x);
	  put_data ((bfd_vma) x, location, 2);
	}
      break;
    case 2:
      if (relocation)
	{
	  bfd_vma x = get_data (location, 4);
	  DOIT (x);
	  put_data ((bfd_vma) x, location, 4);
	}
      break;
    case -2:
      {
	bfd_vma x = get_data (location, 4);
	relocation = -relocation;
	DOIT(x);
	put_data ((bfd_vma) x, location, 4);
      }
      break;

    case 3:
      /* Do nothing.  */
      break;

    case 4:
#ifdef BFD64
      if (relocation)
	{
	  bfd_vma x = get_data (location, 8);
	  DOIT (x);
	  put_data (x, location, 8);
	}
#else
      abort ();
#endif
      break;
    default:
      return bfd_reloc_other;
    }
  if ((howto->complain_on_overflow != complain_overflow_dont) && overflow)
    return bfd_reloc_overflow;

  return flag;
}

/* Relocate a given location using a given value and howto.  */

bfd_reloc_status_type
_bfd_do_ns32k_reloc_contents (reloc_howto_type *howto,
			      bfd *input_bfd ATTRIBUTE_UNUSED,
			      bfd_vma relocation,
			      bfd_byte *location,
			      bfd_vma (*get_data) (bfd_byte *, int),
			      void (*put_data) (bfd_vma, bfd_byte *, int))
{
  int size;
  bfd_vma x;
  bfd_boolean overflow;

  /* If the size is negative, negate RELOCATION.  This isn't very
     general.  */
  if (howto->size < 0)
    relocation = -relocation;

  /* Get the value we are going to relocate.  */
  size = bfd_get_reloc_size (howto);
  switch (size)
    {
    default:
    case 0:
      abort ();
    case 1:
    case 2:
    case 4:
#ifdef BFD64
    case 8:
#endif
      x = get_data (location, size);
      break;
    }

  /* Check for overflow.  FIXME: We may drop bits during the addition
     which we don't check for.  We must either check at every single
     operation, which would be tedious, or we must do the computations
     in a type larger than bfd_vma, which would be inefficient.  */
  overflow = FALSE;
  if (howto->complain_on_overflow != complain_overflow_dont)
    {
      bfd_vma check;
      bfd_signed_vma signed_check;
      bfd_vma add;
      bfd_signed_vma signed_add;

      if (howto->rightshift == 0)
	{
	  check = relocation;
	  signed_check = (bfd_signed_vma) relocation;
	}
      else
	{
	  /* Drop unwanted bits from the value we are relocating to.  */
	  check = relocation >> howto->rightshift;

	  /* If this is a signed value, the rightshift just dropped
	     leading 1 bits (assuming twos complement).  */
	  if ((bfd_signed_vma) relocation >= 0)
	    signed_check = check;
	  else
	    signed_check = (check
			    | ((bfd_vma) - 1
			       & ~((bfd_vma) - 1 >> howto->rightshift)));
	}

      /* Get the value from the object file.  */
      add = x & howto->src_mask;

      /* Get the value from the object file with an appropriate sign.
	 The expression involving howto->src_mask isolates the upper
	 bit of src_mask.  If that bit is set in the value we are
	 adding, it is negative, and we subtract out that number times
	 two.  If src_mask includes the highest possible bit, then we
	 can not get the upper bit, but that does not matter since
	 signed_add needs no adjustment to become negative in that
	 case.  */
      signed_add = add;
      if ((add & (((~howto->src_mask) >> 1) & howto->src_mask)) != 0)
	signed_add -= (((~howto->src_mask) >> 1) & howto->src_mask) << 1;

      /* Add the value from the object file, shifted so that it is a
	 straight number.  */
      if (howto->bitpos == 0)
	{
	  check += add;
	  signed_check += signed_add;
	}
      else
	{
	  check += add >> howto->bitpos;

	  /* For the signed case we use ADD, rather than SIGNED_ADD,
	     to avoid warnings from SVR4 cc.  This is OK since we
	     explicitly handle the sign bits.  */
	  if (signed_add >= 0)
	    signed_check += add >> howto->bitpos;
	  else
	    signed_check += ((add >> howto->bitpos)
			     | ((bfd_vma) - 1
				& ~((bfd_vma) - 1 >> howto->bitpos)));
	}

      switch (howto->complain_on_overflow)
	{
	case complain_overflow_signed:
	  {
	    /* Assumes two's complement.  */
	    bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	    bfd_signed_vma reloc_signed_min = ~reloc_signed_max;

	    if (signed_check > reloc_signed_max
		|| signed_check < reloc_signed_min)
	      overflow = TRUE;
	  }
	  break;
	case complain_overflow_unsigned:
	  {
	    /* Assumes two's complement.  This expression avoids
	       overflow if howto->bitsize is the number of bits in
	       bfd_vma.  */
	    bfd_vma reloc_unsigned_max =
	    (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;

	    if (check > reloc_unsigned_max)
	      overflow = TRUE;
	  }
	  break;
	case complain_overflow_bitfield:
	  {
	    /* Assumes two's complement.  This expression avoids
	       overflow if howto->bitsize is the number of bits in
	       bfd_vma.  */
	    bfd_vma reloc_bits = (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;

	    if ((check & ~reloc_bits) != 0
		&& (((bfd_vma) signed_check & ~reloc_bits)
		    != (-(bfd_vma) 1 & ~reloc_bits)))
	      overflow = TRUE;
	  }
	  break;
	default:
	  abort ();
	}
    }

  /* Put RELOCATION in the right bits.  */
  relocation >>= (bfd_vma) howto->rightshift;
  relocation <<= (bfd_vma) howto->bitpos;

  /* Add RELOCATION to the right bits of X.  */
  x = ((x & ~howto->dst_mask)
       | (((x & howto->src_mask) + relocation) & howto->dst_mask));

  /* Put the relocated value back in the object file.  */
  switch (size)
    {
    default:
    case 0:
      abort ();
    case 1:
    case 2:
    case 4:
#ifdef BFD64
    case 8:
#endif
      put_data (x, location, size);
      break;
    }

  return overflow ? bfd_reloc_overflow : bfd_reloc_ok;
}

bfd_reloc_status_type
_bfd_ns32k_reloc_disp (bfd *abfd,
		       arelent *reloc_entry,
		       struct bfd_symbol *symbol,
		       void * data,
		       asection *input_section,
		       bfd *output_bfd,
		       char **error_message)
{
  return do_ns32k_reloc (abfd, reloc_entry, symbol, data, input_section,
			 output_bfd, error_message,
			 _bfd_ns32k_get_displacement,
			 _bfd_ns32k_put_displacement);
}

bfd_reloc_status_type
_bfd_ns32k_reloc_imm (bfd *abfd,
		      arelent *reloc_entry,
		      struct bfd_symbol *symbol,
		      void * data,
		      asection *input_section,
		      bfd *output_bfd,
		      char **error_message)
{
  return do_ns32k_reloc (abfd, reloc_entry, symbol, data, input_section,
			 output_bfd, error_message, _bfd_ns32k_get_immediate,
			 _bfd_ns32k_put_immediate);
}

bfd_reloc_status_type
_bfd_ns32k_final_link_relocate (reloc_howto_type *howto,
				bfd *input_bfd,
				asection *input_section,
				bfd_byte *contents,
				bfd_vma address,
				bfd_vma value,
				bfd_vma addend)
{
  bfd_vma relocation;

  /* Sanity check the address.  */
  if (address > bfd_get_section_limit (input_bfd, input_section))
    return bfd_reloc_outofrange;

  /* This function assumes that we are dealing with a basic relocation
     against a symbol.  We want to compute the value of the symbol to
     relocate to.  This is just VALUE, the value of the symbol, plus
     ADDEND, any addend associated with the reloc.  */
  relocation = value + addend;

  /* If the relocation is PC relative, we want to set RELOCATION to
     the distance between the symbol (currently in RELOCATION) and the
     location we are relocating.  Some targets (e.g., i386-aout)
     arrange for the contents of the section to be the negative of the
     offset of the location within the section; for such targets
     pcrel_offset is FALSE.  Other targets (e.g., m88kbcs or ELF)
     simply leave the contents of the section as zero; for such
     targets pcrel_offset is TRUE.  If pcrel_offset is FALSE we do not
     need to subtract out the offset of the location within the
     section (which is just ADDRESS).  */
  if (howto->pc_relative)
    {
      relocation -= (input_section->output_section->vma
		     + input_section->output_offset);
      if (howto->pcrel_offset)
	relocation -= address;
    }

  return _bfd_ns32k_relocate_contents (howto, input_bfd, relocation,
				       contents + address);
}
@


1.23
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@a40 6
static bfd_reloc_status_type do_ns32k_reloc
  PARAMS ((bfd *, arelent *, struct bfd_symbol *, PTR, asection *,
	   bfd *, char **,
	   bfd_vma (*) (bfd_byte *, int),
	   void (*) (bfd_vma, bfd_byte *, int)));

d42 1
a42 3
_bfd_ns32k_get_displacement (buffer, size)
     bfd_byte *buffer;
     int size;
d73 1
a73 4
_bfd_ns32k_put_displacement (value, buffer, size)
     bfd_vma value;
     bfd_byte *buffer;
     int size;
d101 1
a101 3
_bfd_ns32k_get_immediate (buffer, size)
     bfd_byte *buffer;
     int size;
d122 1
a122 4
_bfd_ns32k_put_immediate (value, buffer, size)
     bfd_vma value;
     bfd_byte *buffer;
     int size;
d143 9
a151 11
do_ns32k_reloc (abfd, reloc_entry, symbol, data, input_section, output_bfd,
		error_message, get_data, put_data)
     bfd *abfd;
     arelent *reloc_entry;
     struct bfd_symbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
     bfd_vma (*get_data) PARAMS ((bfd_byte *, int));
     void (*put_data) PARAMS ((bfd_vma, bfd_byte *, int));
d568 6
a573 8
_bfd_do_ns32k_reloc_contents (howto, input_bfd, relocation, location,
			      get_data, put_data)
     reloc_howto_type *howto;
     bfd *input_bfd ATTRIBUTE_UNUSED;
     bfd_vma relocation;
     bfd_byte *location;
     bfd_vma (*get_data) PARAMS ((bfd_byte *, int));
     void (*put_data) PARAMS ((bfd_vma, bfd_byte *, int));
d741 7
a747 9
_bfd_ns32k_reloc_disp (abfd, reloc_entry, symbol, data, input_section,
		       output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     struct bfd_symbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d756 7
a762 9
_bfd_ns32k_reloc_imm (abfd, reloc_entry, symbol, data, input_section,
		      output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     struct bfd_symbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d770 7
a776 9
_bfd_ns32k_final_link_relocate (howto, input_bfd, input_section, contents,
				address, value, addend)
     reloc_howto_type *howto;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma address;
     bfd_vma value;
     bfd_vma addend;
@


1.22
log
@Support arch-dependent fill

bfd/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* archures.c (bfd_arch_info): Add fill.
	(bfd_default_arch_struct): Add bfd_arch_default_fill.
	(bfd_arch_default_fill): New.

	* configure.in: Set bfd version to 2.22.52.
	* configure: Regenerated.

	* cpu-alpha.c: Add bfd_arch_default_fill to bfd_arch_info
	initializer.
	* cpu-arc.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-d10v.c: Likewise.
	* cpu-d30v.c: Likewise.
	* cpu-dlx.c: Likewise.
	* cpu-epiphany.c: Likewise.
	* cpu-fr30.c: Likewise.
	* cpu-frv.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-hppa.c: Likewise.
	* cpu-i370.c: Likewise.
	* cpu-i860.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-ia64.c: Likewise.
	* cpu-ip2k.c: Likewise.
	* cpu-iq2000.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m10200.c: Likewise.
	* cpu-m10300.c: Likewise.
	* cpu-m32c.c: Likewise.
	* cpu-m32r.c: Likewise.
	* cpu-m68hc11.c: Likewise.
	* cpu-m68hc12.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-m88k.c: Likewise.
	* cpu-mcore.c: Likewise.
	* cpu-mep.c: Likewise.
	* cpu-microblaze.c: Likewise.
	* cpu-mips.c: Likewise.
	* cpu-mmix.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-mt.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-openrisc.c: Likewise.
	* cpu-or32.c: Likewise.
	* cpu-pdp11.c: Likewise.
	* cpu-pj.c: Likewise.
	* cpu-plugin.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rl78.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-rx.c: Likewise.
	* cpu-s390.c: Likewise.
	* cpu-score.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-sparc.c: Likewise.
	* cpu-spu.c: Likewise.
	* cpu-tic30.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-tic54x.c: Likewise.
	* cpu-tic6x.c: Likewise.
	* cpu-tic80.c: Likewise.
	* cpu-tilegx.c: Likewise.
	* cpu-tilepro.c: Likewise.
	* cpu-v850.c: Likewise.
	* cpu-vax.c: Likewise.
	* cpu-w65.c: Likewise.
	* cpu-we32k.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* cpu-xstormy16.c: Likewise.
	* cpu-xtensa.c: Likewise.
	* cpu-z80.c: Likewise.
	* cpu-z8k.c: Likewise.

	* cpu-i386.c: Include "libiberty.h".
	(bfd_arch_i386_fill): New.
	Add bfd_arch_i386_fill to  bfd_arch_info initializer.

	* cpu-k1om.c: Add bfd_arch_i386_fill to  bfd_arch_info initializer.
	* cpu-l1om.c: Likewise.

	* linker.c (default_data_link_order): Call abfd->arch_info->fill
	if fill size is 0.

	* bfd-in2.h: Regenerated.

include/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* bfdlink.h (bfd_link_order): Update comments on data size.

ld/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* emulparams/elf32_x86_64.sh: Remove NOP.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_k1om.sh: Likewise.
	* emulparams/elf_l1om.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.

	* ldlang.c (zero_fill): Initialized to 0.

	* ldwrite.c (build_link_order): Set data size to linker odrder
	size when they are the same.

	* scripttempl/elf.sc: Don't specify fill if NOP is undefined.

ld/testsuite/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* ld-i386/tlsbindesc.dd: Update no-op padding.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlspic.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlsbindesc.dd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
@
text
@d3 1
a3 1
   2004, 2005, 2007 Free Software Foundation, Inc.
d180 1
a180 1
  if ((symbol->section == &bfd_abs_section)
d190 1
a190 1
  if (symbol->section == &bfd_und_section
@


1.21
log
@Switch sources over to use the GPL version 3
@
text
@d30 2
a31 1
{  32, 32, 8, bfd_arch_ns32k, machine, "ns32k",printable,3,d,bfd_default_compatible,bfd_default_scan, next, }
@


1.20
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.19
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 1
a3 1
   2004, 2005 Free Software Foundation, Inc.
d23 1
a24 1
#include "sysdep.h"
@


1.18
log
@Update the FSF address in the copyright/GPL notice
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.17
log
@update copyright dates
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.16
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1994, 1995, 1998, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
@


1.15
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@a281 1
#if 1
a356 1
#endif
@


1.14
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a172 1
  bfd_size_type sz;
d194 1
a194 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
a804 1
  bfd_size_type sz;
d807 1
a807 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (address > sz)
@


1.13
log
@	* aix5ppc-core.c: Fix comment typos.
	* aout-arm.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aoutx.h: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd.c: Likewise.
	* bfdio.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-z8k.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* cofflink.c: Likewise.
	* cpu-alpha.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* dwarf2.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1994, 1995, 1998, 2000, 2001, 2002, 2003
d173 1
d195 2
a196 1
  if (reloc_entry->address > input_section->_cooked_size)
d807 1
d810 2
a811 1
  if (address > input_section->_cooked_size)
@


1.13.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1994, 1995, 1998, 2000, 2001, 2002, 2003, 2004
d194 1
a194 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d807 1
a807 1
  if (address > bfd_get_section_limit (input_bfd, input_section))
@


1.12
log
@Index: sim/frv/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* traps.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/d10v/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* simops.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/common/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* sim-trace.c, sim-base.h: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: ld/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* emultempl/pe.em, pe-dll.c: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: bfd/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* syms.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".
	* vms.h, targets.c, section.c, reloc.c, peicode.h: Ditto.
	* mipsbsd.c, elf.c, linker.c, elf-bfd.h, ecoff.c: Ditto.
	* cpu-z8k.c, cpu-ns32k.c, cpu-h8500.c, bfd.c, bfd-in.h: Ditto.
	* bfd-in2.h: Re-generate.
@
text
@d197 1
a197 1
  /* Work out which section the relocation is targetted at and the
d681 1
a681 1
	     explictly handle the sign bits.  */
@


1.11
log
@Correct spelling of "relocatable".
@
text
@d40 1
a40 1
  PARAMS ((bfd *, arelent *, struct symbol_cache_entry *, PTR, asection *,
d161 1
a161 1
     struct symbol_cache_entry *symbol;
d765 1
a765 1
     struct symbol_cache_entry *symbol;
d782 1
a782 1
     struct symbol_cache_entry *symbol;
@


1.10
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1994, 1995, 1998, 2000, 2001, 2002
d185 1
a185 1
  /* If we are not producing relocateable output, return an error if
d239 1
a239 1
	 If we are producing relocateable output, then we must ensure
d248 1
a248 1
	 producing relocateable output it is not what the code
d300 1
a300 1
		 reloc addend when producing relocateable output for COFF.
d318 2
a319 2
		 So everything works fine when not producing relocateable
		 output.  When we are producing relocateable output, logically
d321 1
a321 1
		 relocateable output.  Therefore, your patch is correct.  In
d329 1
a329 1
		 When I wanted to make coff-i386 produce relocateable output,
@


1.9
log
@Fix bugs and remove compile time warnings for N"32K port.
@
text
@d33 1
a33 1
  N(32532,"ns32k:32532",true, 0), /* The word ns32k will match this too.  */
d37 1
a37 1
  N(32032,"ns32k:32032",false, &arch_info_struct[0]);
d235 1
a235 1
	 i386-aout, pcrel_offset is false.  Some other targets do not
d237 1
a237 1
	 or ELF.  For those targets, pcrel_offset is true.
d241 1
a241 1
	 relocation is done.  If pcrel_offset is false we want to wind
d244 1
a244 1
	 in the location within the section.  If pcrel_offset is true
d597 1
a597 1
  boolean overflow;
d625 1
a625 1
  overflow = false;
d700 1
a700 1
	      overflow = true;
d712 1
a712 1
	      overflow = true;
d725 1
a725 1
	      overflow = true;
d821 1
a821 1
     pcrel_offset is false.  Other targets (e.g., m88kbcs or ELF)
d823 1
a823 1
     targets pcrel_offset is true.  If pcrel_offset is false we do not
@


1.9.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1994, 1995, 1998, 2000, 2001, 2002, 2003
d33 1
a33 1
  N(32532,"ns32k:32532",TRUE, 0), /* The word ns32k will match this too.  */
d37 1
a37 1
  N(32032,"ns32k:32032",FALSE, &arch_info_struct[0]);
d40 1
a40 1
  PARAMS ((bfd *, arelent *, struct bfd_symbol *, PTR, asection *,
d161 1
a161 1
     struct bfd_symbol *symbol;
d185 1
a185 1
  /* If we are not producing relocatable output, return an error if
d197 1
a197 1
  /* Work out which section the relocation is targeted at and the
d235 1
a235 1
	 i386-aout, pcrel_offset is FALSE.  Some other targets do not
d237 1
a237 1
	 or ELF.  For those targets, pcrel_offset is TRUE.
d239 1
a239 1
	 If we are producing relocatable output, then we must ensure
d241 1
a241 1
	 relocation is done.  If pcrel_offset is FALSE we want to wind
d244 1
a244 1
	 in the location within the section.  If pcrel_offset is TRUE
d248 1
a248 1
	 producing relocatable output it is not what the code
d300 1
a300 1
		 reloc addend when producing relocatable output for COFF.
d318 2
a319 2
		 So everything works fine when not producing relocatable
		 output.  When we are producing relocatable output, logically
d321 1
a321 1
		 relocatable output.  Therefore, your patch is correct.  In
d329 1
a329 1
		 When I wanted to make coff-i386 produce relocatable output,
d597 1
a597 1
  bfd_boolean overflow;
d625 1
a625 1
  overflow = FALSE;
d681 1
a681 1
	     explicitly handle the sign bits.  */
d700 1
a700 1
	      overflow = TRUE;
d712 1
a712 1
	      overflow = TRUE;
d725 1
a725 1
	      overflow = TRUE;
d765 1
a765 1
     struct bfd_symbol *symbol;
d782 1
a782 1
     struct bfd_symbol *symbol;
d821 1
a821 1
     pcrel_offset is FALSE.  Other targets (e.g., m88kbcs or ELF)
d823 1
a823 1
     targets pcrel_offset is TRUE.  If pcrel_offset is FALSE we do not
@


1.9.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d33 1
a33 1
  N(32532,"ns32k:32532",TRUE, 0), /* The word ns32k will match this too.  */
d37 1
a37 1
  N(32032,"ns32k:32032",FALSE, &arch_info_struct[0]);
d235 1
a235 1
	 i386-aout, pcrel_offset is FALSE.  Some other targets do not
d237 1
a237 1
	 or ELF.  For those targets, pcrel_offset is TRUE.
d241 1
a241 1
	 relocation is done.  If pcrel_offset is FALSE we want to wind
d244 1
a244 1
	 in the location within the section.  If pcrel_offset is TRUE
d597 1
a597 1
  bfd_boolean overflow;
d625 1
a625 1
  overflow = FALSE;
d700 1
a700 1
	      overflow = TRUE;
d712 1
a712 1
	      overflow = TRUE;
d725 1
a725 1
	      overflow = TRUE;
d821 1
a821 1
     pcrel_offset is FALSE.  Other targets (e.g., m88kbcs or ELF)
d823 1
a823 1
     targets pcrel_offset is TRUE.  If pcrel_offset is FALSE we do not
@


1.9.10.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1994, 1995, 1998, 2000, 2001, 2002, 2003
d185 1
a185 1
  /* If we are not producing relocatable output, return an error if
d239 1
a239 1
	 If we are producing relocatable output, then we must ensure
d248 1
a248 1
	 producing relocatable output it is not what the code
d300 1
a300 1
		 reloc addend when producing relocatable output for COFF.
d318 2
a319 2
		 So everything works fine when not producing relocatable
		 output.  When we are producing relocatable output, logically
d321 1
a321 1
		 relocatable output.  Therefore, your patch is correct.  In
d329 1
a329 1
		 When I wanted to make coff-i386 produce relocatable output,
@


1.9.10.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d40 1
a40 1
  PARAMS ((bfd *, arelent *, struct bfd_symbol *, PTR, asection *,
d161 1
a161 1
     struct bfd_symbol *symbol;
d765 1
a765 1
     struct bfd_symbol *symbol;
d782 1
a782 1
     struct bfd_symbol *symbol;
@


1.9.10.4
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d197 1
a197 1
  /* Work out which section the relocation is targeted at and the
d681 1
a681 1
	     explicitly handle the sign bits.  */
@


1.8
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d33 1
a33 1
  N(32532,"ns32k:32532",true, 0), /* the word ns32k will match this too */
d43 1
a43 1
	   int (*) (bfd_vma, bfd_byte *, int)));
d51 1
d74 1
d78 1
a78 1
int
a86 2
      if (value + 0x40 > 0x7f)
	return -1;
a91 2
      if (value + 0x2000 > 0x3fff)
	return -1;
a98 3
      /* FIXME: is this correct?  -0x1f000000 <= value < 0x2000000 */
      if (value + 0x1f000000 > 0x3effffff)
	return -1;
a104 2
    default:
      return -1;
d106 1
a106 1
  return 0;
d115 1
a117 5
    case 8:
      value = (value << 8) | (*buffer++ & 0xff);
      value = (value << 8) | (*buffer++ & 0xff);
      value = (value << 8) | (*buffer++ & 0xff);
      value = (value << 8) | (*buffer++ & 0xff);
d125 3
d132 1
a132 1
int
a140 5
    case 8:
      *buffer-- = (value & 0xff); value >>= 8;
      *buffer-- = (value & 0xff); value >>= 8;
      *buffer-- = (value & 0xff); value >>= 8;
      *buffer-- = (value & 0xff); value >>= 8;
a148 1
  return 0;
d152 4
a155 4
 * use get_data and put_data which know about the ns32k
 * storage methods.
 * This is probably a lot more complicated than it needs to be!
 */
d167 1
a167 1
     int (*put_data) PARAMS ((bfd_vma, bfd_byte *, int));
a250 1

d287 2
a288 2
However, Ian wrote the following, regarding removing the line below,
which explains why it is still enabled:  --djm
d290 67
a356 62
If you put a patch like that into BFD you need to check all the COFF
linkers.  I am fairly certain that patch will break coff-i386 (e.g.,
SCO); see coff_i386_reloc in coff-i386.c where I worked around the
problem in a different way.  There may very well be a reason that the
code works as it does.

Hmmm.  The first obvious point is that bfd_perform_relocation should
not have any tests that depend upon the flavour.  It's seem like
entirely the wrong place for such a thing.  The second obvious point
is that the current code ignores the reloc addend when producing
relocateable output for COFF.  That's peculiar.  In fact, I really
have no idea what the point of the line you want to remove is.

A typical COFF reloc subtracts the old value of the symbol and adds in
the new value to the location in the object file (if it's a pc
relative reloc it adds the difference between the symbol value and the
location).  When relocating we need to preserve that property.

BFD handles this by setting the addend to the negative of the old
value of the symbol.  Unfortunately it handles common symbols in a
non-standard way (it doesn't subtract the old value) but that's a
different story (we can't change it without losing backward
compatibility with old object files) (coff-i386 does subtract the old
value, to be compatible with existing coff-i386 targets, like SCO).

So everything works fine when not producing relocateable output.  When
we are producing relocateable output, logically we should do exactly
what we do when not producing relocateable output.  Therefore, your
patch is correct.  In fact, it should probably always just set
reloc_entry->addend to 0 for all cases, since it is, in fact, going to
add the value into the object file.  This won't hurt the COFF code,
which doesn't use the addend; I'm not sure what it will do to other
formats (the thing to check for would be whether any formats both use
the addend and set partial_inplace).

When I wanted to make coff-i386 produce relocateable output, I ran
into the problem that you are running into: I wanted to remove that
line.  Rather than risk it, I made the coff-i386 relocs use a special
function; it's coff_i386_reloc in coff-i386.c.  The function
specifically adds the addend field into the object file, knowing that
bfd_perform_relocation is not going to.  If you remove that line, then
coff-i386.c will wind up adding the addend field in twice.  It's
trivial to fix; it just needs to be done.

The problem with removing the line is just that it may break some
working code.  With BFD it's hard to be sure of anything.  The right
way to deal with this is simply to build and test at least all the
supported COFF targets.  It should be straightforward if time and disk
space consuming.  For each target:
    1) build the linker
    2) generate some executable, and link it using -r (I would
       probably use paranoia.o and link against newlib/libc.a, which
       for all the supported targets would be available in
       /usr/cygnus/progressive/H-host/target/lib/libc.a).
    3) make the change to reloc.c
    4) rebuild the linker
    5) repeat step 2
    6) if the resulting object files are the same, you have at least
       made it no worse
    7) if they are different you have to figure out which version is
       right
*/
d455 3
a457 5
  /*
    Either we are relocating all the way, or we don't want to apply
    the relocation to the reloc entry (probably because there isn't
    any room in the output format to describe addends to relocs)
    */
d484 1
a484 2
  /* Shift everything up to where it's going to be used */

d487 1
a487 1
  /* Wait for the day when all have the mask in them */
d517 1
a517 2
     R R R R R R R R R R        put into bfd_put<size>
     */
d527 1
a527 1
	char x = get_data (location, 1);
d529 1
a529 1
	overflow = put_data ((bfd_vma) x, location, 1);
d536 1
a536 1
	  short x = get_data (location, 2);
d538 1
a538 1
	  overflow = put_data ((bfd_vma) x, location, 2);
d544 1
a544 1
	  long x = get_data (location, 4);
d546 1
a546 1
	  overflow = put_data ((bfd_vma) x, location, 4);
d551 1
a551 1
	long x = get_data (location, 4);
d554 1
a554 1
	overflow = put_data ((bfd_vma) x, location, 4);
d559 1
a559 1
      /* Do nothing */
d568 1
a568 1
	  overflow = put_data (x, location, 8);
d593 1
a593 1
     int (*put_data) PARAMS ((bfd_vma, bfd_byte *, int));
@


1.7
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1994, 1995, 1998, 2000, 2001
d223 1
a223 1
  if (output_bfd && howto->partial_inplace == false)
d236 1
a236 1
  if (howto->pc_relative == true)
d269 1
a269 1
      if (howto->pcrel_offset == true)
d275 1
a275 1
      if (howto->partial_inplace == false)
@


1.7.10.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1994, 1995, 1998, 2000, 2001, 2002
d223 1
a223 1
  if (output_bfd != NULL && ! howto->partial_inplace)
d236 1
a236 1
  if (howto->pc_relative)
d269 1
a269 1
      if (howto->pcrel_offset)
d275 1
a275 1
      if (! howto->partial_inplace)
@


1.7.10.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d33 1
a33 1
  N(32532,"ns32k:32532",true, 0), /* The word ns32k will match this too.  */
d43 1
a43 1
	   void (*) (bfd_vma, bfd_byte *, int)));
a50 1

a72 1

d76 1
a76 1
void
d85 2
d92 2
d101 3
d110 2
d113 1
a113 1
  return;
a121 1

d124 5
a135 3
      break;
    default:
      abort ();
d140 1
a140 1
void
d149 5
d162 1
d166 4
a169 4
   use get_data and put_data which know about the ns32k storage
   methods.  This is probably a lot more complicated than it
   needs to be!  */

d181 1
a181 1
     void (*put_data) PARAMS ((bfd_vma, bfd_byte *, int));
d265 1
d302 2
a303 2
		 However, Ian wrote the following, regarding removing the line
		 below, which explains why it is still enabled:  --djm
d305 62
a366 67
		 If you put a patch like that into BFD you need to check all
		 the COFF linkers.  I am fairly certain that patch will break
		 coff-i386 (e.g., SCO); see coff_i386_reloc in coff-i386.c
		 where I worked around the problem in a different way.  There
		 may very well be a reason that the code works as it does.

		 Hmmm.  The first obvious point is that bfd_perform_relocation
		 should not have any tests that depend upon the flavour.  It's
		 seem like entirely the wrong place for such a thing.  The
		 second obvious point is that the current code ignores the
		 reloc addend when producing relocateable output for COFF.
		 That's peculiar.  In fact, I really have no idea what the
		 point of the line you want to remove is.

		 A typical COFF reloc subtracts the old value of the symbol
		 and adds in the new value to the location in the object file
		 (if it's a pc relative reloc it adds the difference between
		 the symbol value and the location).  When relocating we need
		 to preserve that property.

		 BFD handles this by setting the addend to the negative of the
		 old value of the symbol.  Unfortunately it handles common
		 symbols in a non-standard way (it doesn't subtract the old
		 value) but that's a different story (we can't change it
		 without losing backward compatibility with old object files)
		 (coff-i386 does subtract the old value, to be compatible with
		 existing coff-i386 targets, like SCO).

		 So everything works fine when not producing relocateable
		 output.  When we are producing relocateable output, logically
		 we should do exactly what we do when not producing
		 relocateable output.  Therefore, your patch is correct.  In
		 fact, it should probably always just set reloc_entry->addend
		 to 0 for all cases, since it is, in fact, going to add the
		 value into the object file.  This won't hurt the COFF code,
		 which doesn't use the addend; I'm not sure what it will do
		 to other formats (the thing to check for would be whether
		 any formats both use the addend and set partial_inplace).

		 When I wanted to make coff-i386 produce relocateable output,
		 I ran into the problem that you are running into: I wanted
		 to remove that line.  Rather than risk it, I made the
		 coff-i386 relocs use a special function; it's coff_i386_reloc
		 in coff-i386.c.  The function specifically adds the addend
		 field into the object file, knowing that bfd_perform_relocation
		 is not going to.  If you remove that line, then coff-i386.c
		 will wind up adding the addend field in twice.  It's trivial
		 to fix; it just needs to be done.

		 The problem with removing the line is just that it may break
		 some working code.  With BFD it's hard to be sure of anything.
		 The right way to deal with this is simply to build and test at
		 least all the supported COFF targets.  It should be
		 straightforward if time and disk space consuming.  For each
		 target:
		   1) build the linker
		   2) generate some executable, and link it using -r (I would
		      probably use paranoia.o and link against newlib/libc.a,
		      which for all the supported targets would be available in
		      /usr/cygnus/progressive/H-host/target/lib/libc.a).
		   3) make the change to reloc.c
		   4) rebuild the linker
		   5) repeat step 2
		   6) if the resulting object files are the same, you have at
		      least made it no worse
		   7) if they are different you have to figure out which
		      version is right.  */
d465 5
a469 3
  /* Either we are relocating all the way, or we don't want to apply
     the relocation to the reloc entry (probably because there isn't
     any room in the output format to describe addends to relocs).  */
d496 2
a497 1
  /* Shift everything up to where it's going to be used.  */
d500 1
a500 1
  /* Wait for the day when all have the mask in them.  */
d530 2
a531 1
     R R R R R R R R R R        put into bfd_put<size>.  */
d541 1
a541 1
	bfd_vma x = get_data (location, 1);
d543 1
a543 1
	put_data ((bfd_vma) x, location, 1);
d550 1
a550 1
	  bfd_vma x = get_data (location, 2);
d552 1
a552 1
	  put_data ((bfd_vma) x, location, 2);
d558 1
a558 1
	  bfd_vma x = get_data (location, 4);
d560 1
a560 1
	  put_data ((bfd_vma) x, location, 4);
d565 1
a565 1
	bfd_vma x = get_data (location, 4);
d568 1
a568 1
	put_data ((bfd_vma) x, location, 4);
d573 1
a573 1
      /* Do nothing.  */
d582 1
a582 1
	  put_data (x, location, 8);
d607 1
a607 1
     void (*put_data) PARAMS ((bfd_vma, bfd_byte *, int));
@


1.6
log
@Update copyright notices
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1994, 1995, 1998, 2000
d39 5
a43 10
static long
ns32k_sign_extend(value, bits)
     int value;
     int bits;
{
  value = value & ((1 << bits) - 1);
  return (value & (1 << (bits-1))
	  ? value | (~((1 << bits) - 1))
	  : value);
}
d45 2
a46 2
long
_bfd_ns32k_get_displacement(buffer, offset, size)
d48 1
a48 2
     long offset;
     long size;
d50 1
a50 2
  long value;
  buffer += offset;
d54 1
a54 1
      value = ns32k_sign_extend (*buffer, 7);
d56 1
d58 1
a58 1
      value = ns32k_sign_extend(*buffer++, 6);
d61 1
d63 1
a63 1
      value = ns32k_sign_extend(*buffer++, 6);
d68 1
d77 2
a78 2
_bfd_ns32k_put_displacement(value, buffer, offset, size)
     long value;
d80 1
a80 2
     long offset;
     long size;
a81 1
  buffer += offset;
d85 1
a85 1
      if (value < -64 || value > 63)
d87 2
a88 2
      value&=0x7f;
      *buffer++=value;
d90 1
d92 1
a92 1
      if (value < -8192 || value > 8191)
d94 4
a97 4
      value&=0x3fff;
      value|=0x8000;
      *buffer++=(value>>8);
      *buffer++=value;
d99 1
d101 2
a102 1
      if (value < -0x1f000000 || value >= 0x20000000)
d104 5
a108 5
      value|=0xc0000000;
      *buffer++=(value>>24);
      *buffer++=(value>>16);
      *buffer++=(value>>8);
      *buffer++=value;
d116 2
a117 2
long
_bfd_ns32k_get_immediate (buffer, offset, size)
d119 1
a119 2
     long offset;
     long size;
d121 1
a121 2
  long value = 0;
  buffer += offset;
d124 5
a130 1
    case 3:
d141 2
a142 2
_bfd_ns32k_put_immediate (value, buffer, offset, size)
     long value;
d144 1
a144 2
     long offset;
     long size;
d146 1
a146 1
  buffer += offset + size - 1;
d149 5
a155 1
    case 3:
d180 2
a181 2
     long (*get_data) ();
     int (*put_data) ();
d190 1
d439 2
a440 1
		&& ((bfd_vma) check & ~reloc_bits) != (-1 & ~reloc_bits))
d451 2
a452 1
		    if (((bfd_vma) check & ~reloc_bits) != (-1 & ~reloc_bits))
d536 1
d541 1
a541 1
	char x = get_data (data, addr, 1);
d543 1
a543 1
	overflow = put_data(x, data, addr, 1);
d550 1
a550 1
	  short x = get_data (data, addr, 2);
d552 1
a552 1
	  overflow = put_data(x, (unsigned char *) data, addr, 2);
d558 1
a558 1
	  long x = get_data (data, addr, 4);
d560 1
a560 1
	  overflow = put_data(x, data, addr, 4);
d565 1
a565 1
	long  x = get_data(data, addr, 4);
d568 1
a568 1
	overflow = put_data(x, data , addr, 4);
d580 1
a580 1
	  bfd_vma x = get_data (data, addr, 8);
d582 1
a582 1
	  overflow = put_data(x, data, addr, 8);
d600 1
a600 1
_bfd_do_ns32k_reloc_contents ( howto, input_bfd, relocation, location,
d606 2
a607 2
     long (*get_data) ();
     int (*put_data) ();
d631 1
a631 1
      x = get_data (location, 0, size);
d738 1
a738 1
		    != (-1 & ~reloc_bits)))
d767 1
a767 1
      put_data(x, location, 0, size);
@


1.5
log
@2000-11-21  Kazu Hirata  <kazu@@hxi.com>

	* coff-a29k.c: Fix formatting.
	* coff-h8500.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-w65.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-hppa.c: Likewise.
	* cpu-ns32k.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 94, 95, 96, 98, 1999 Free Software Foundation, Inc.
@


1.5.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1994, 1995, 1998, 2000
   Free Software Foundation, Inc.
@


1.4
log
@2000-11-16  Kazu Hirata  <kazu@@hxi.com>

	* cpu-a29k.c: Fix formatting.
	* cpu-alpha.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-d10v.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-hppa.c: Likewise.
	* cpu-i370.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-ia64-opc.c: Likewise.
	* cpu-ia64.c: Likewise.
	* cpu-m32r.c: Likewise.
	* cpu-m68hc11.c: Likewise.
	* cpu-m68hc12.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-m88k.c: Likewise.
	* cpu-mips.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-pj.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-sparc.c: Likewise.
	* cpu-tic54x.c: Likewise.
	* cpu-v850.c: Likewise.
	* cpu-vax.c: Likewise.
	* cpu-w65.c: Likewise.
	* cpu-we32k.c: Likewise.
	* cpu-z8k.c: Likewise.
@
text
@d177 2
a178 2
     long (*get_data)();
     int (*put_data)();
d599 2
a600 2
     long (*get_data)();
     int (*put_data)();
@


1.3
log
@	* bfd-in.h (bfd_family_coff): Define.
	* bfd-in2.h: Regenerate.
	* coffgen.c (coff_count_linenumbers, coff_symbol_from,
	coff_find_nearest_line): Check COFFness using bfd_family_coff()
	instead of bfd_target_coff_flavour.
	* cofflink.c (_bfd_coff_final_link): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Don't strcmp() target name to
	exclude XCOFF files.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation):
	Likewise.
	* targets.c (enum bfd_flavour): Add bfd_target_xcoff_flavour.
	* xcoff-target.h (TARGET_SYM): Use bfd_target_xcoff_flavour.
	* xcofflink.c (XCOFF_XVECP): Delete.
	(bfd_xcoff_link_record_set, bfd_xcoff_import_symbol,
	bfd_xcoff_export_symbol, bfd_xcoff_link_count_reloc,
	bfd_xcoff_record_link_assignment,
	bfd_xcoff_size_dynamic_sections): Replace XCOFF_XVECP() with
	check for bfd_target_xcoff_flavour.
@
text
@d31 1
a31 1
{ 
a202 1

a214 1

@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d293 1
a293 2
	  if (abfd->xvec->flavour == bfd_target_coff_flavour
	      && strcmp (abfd->xvec->name, "aixcoff-rs6000") != 0)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 94, 95, 96, 1998 Free Software Foundation, Inc.
d176 1
a176 1
     char **error_message;
d599 1
a599 1
     bfd *input_bfd;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

