head	1.81;
access;
symbols
	sid-snapshot-20180601:1.81
	sid-snapshot-20180501:1.81
	sid-snapshot-20180401:1.81
	sid-snapshot-20180301:1.81
	sid-snapshot-20180201:1.81
	sid-snapshot-20180101:1.81
	sid-snapshot-20171201:1.81
	sid-snapshot-20171101:1.81
	sid-snapshot-20171001:1.81
	sid-snapshot-20170901:1.81
	sid-snapshot-20170801:1.81
	sid-snapshot-20170701:1.81
	sid-snapshot-20170601:1.81
	sid-snapshot-20170501:1.81
	sid-snapshot-20170401:1.81
	sid-snapshot-20170301:1.81
	sid-snapshot-20170201:1.81
	sid-snapshot-20170101:1.81
	sid-snapshot-20161201:1.81
	sid-snapshot-20161101:1.81
	sid-snapshot-20160901:1.81
	sid-snapshot-20160801:1.81
	sid-snapshot-20160701:1.81
	sid-snapshot-20160601:1.81
	sid-snapshot-20160501:1.81
	sid-snapshot-20160401:1.81
	sid-snapshot-20160301:1.81
	sid-snapshot-20160201:1.81
	sid-snapshot-20160101:1.81
	sid-snapshot-20151201:1.81
	sid-snapshot-20151101:1.81
	sid-snapshot-20151001:1.81
	sid-snapshot-20150901:1.81
	sid-snapshot-20150801:1.81
	sid-snapshot-20150701:1.81
	sid-snapshot-20150601:1.81
	sid-snapshot-20150501:1.81
	sid-snapshot-20150401:1.81
	sid-snapshot-20150301:1.81
	sid-snapshot-20150201:1.81
	sid-snapshot-20150101:1.81
	sid-snapshot-20141201:1.81
	sid-snapshot-20141101:1.81
	sid-snapshot-20141001:1.81
	sid-snapshot-20140901:1.81
	sid-snapshot-20140801:1.81
	sid-snapshot-20140701:1.81
	sid-snapshot-20140601:1.81
	sid-snapshot-20140501:1.81
	sid-snapshot-20140401:1.81
	sid-snapshot-20140301:1.81
	sid-snapshot-20140201:1.81
	sid-snapshot-20140101:1.81
	sid-snapshot-20131201:1.81
	sid-snapshot-20131101:1.81
	sid-snapshot-20131001:1.81
	binutils-2_24-branch:1.81.0.4
	binutils-2_24-branchpoint:1.81
	binutils-2_21_1:1.79
	sid-snapshot-20130901:1.81
	gdb_7_6_1-2013-08-30-release:1.81
	sid-snapshot-20130801:1.81
	sid-snapshot-20130701:1.81
	sid-snapshot-20130601:1.81
	sid-snapshot-20130501:1.81
	gdb_7_6-2013-04-26-release:1.81
	sid-snapshot-20130401:1.81
	binutils-2_23_2:1.80
	gdb_7_6-branch:1.81.0.2
	gdb_7_6-2013-03-12-branchpoint:1.81
	sid-snapshot-20130301:1.81
	sid-snapshot-20130201:1.80
	sid-snapshot-20130101:1.80
	sid-snapshot-20121201:1.80
	gdb_7_5_1-2012-11-29-release:1.80
	binutils-2_23_1:1.80
	sid-snapshot-20121101:1.80
	binutils-2_23:1.80
	sid-snapshot-20121001:1.80
	sid-snapshot-20120901:1.80
	gdb_7_5-2012-08-17-release:1.80
	sid-snapshot-20120801:1.80
	binutils-2_23-branch:1.80.0.4
	binutils-2_23-branchpoint:1.80
	gdb_7_5-branch:1.80.0.2
	gdb_7_5-2012-07-18-branchpoint:1.80
	sid-snapshot-20120701:1.80
	sid-snapshot-20120601:1.80
	sid-snapshot-20120501:1.79
	binutils-2_22_branch:1.79.0.10
	gdb_7_4_1-2012-04-26-release:1.79
	sid-snapshot-20120401:1.79
	sid-snapshot-20120301:1.79
	sid-snapshot-20120201:1.79
	gdb_7_4-2012-01-24-release:1.79
	sid-snapshot-20120101:1.79
	gdb_7_4-branch:1.79.0.8
	gdb_7_4-2011-12-13-branchpoint:1.79
	sid-snapshot-20111201:1.79
	binutils-2_22:1.79
	sid-snapshot-20111101:1.79
	sid-snapshot-20111001:1.79
	binutils-2_22-branch:1.79.0.6
	binutils-2_22-branchpoint:1.79
	gdb_7_3_1-2011-09-04-release:1.79
	sid-snapshot-20110901:1.79
	sid-snapshot-20110801:1.79
	gdb_7_3-2011-07-26-release:1.79
	sid-snapshot-20110701:1.79
	sid-snapshot-20110601:1.79
	sid-snapshot-20110501:1.79
	gdb_7_3-branch:1.79.0.4
	gdb_7_3-2011-04-01-branchpoint:1.79
	sid-snapshot-20110401:1.79
	sid-snapshot-20110301:1.79
	sid-snapshot-20110201:1.79
	sid-snapshot-20110101:1.79
	binutils-2_21:1.79
	sid-snapshot-20101201:1.79
	binutils-2_21-branch:1.79.0.2
	binutils-2_21-branchpoint:1.79
	sid-snapshot-20101101:1.79
	sid-snapshot-20101001:1.79
	binutils-2_20_1:1.76.2.1
	gdb_7_2-2010-09-02-release:1.78
	sid-snapshot-20100901:1.79
	sid-snapshot-20100801:1.78
	gdb_7_2-branch:1.78.0.4
	gdb_7_2-2010-07-07-branchpoint:1.78
	sid-snapshot-20100701:1.78
	sid-snapshot-20100601:1.78
	sid-snapshot-20100501:1.78
	sid-snapshot-20100401:1.78
	gdb_7_1-2010-03-18-release:1.78
	sid-snapshot-20100301:1.78
	gdb_7_1-branch:1.78.0.2
	gdb_7_1-2010-02-18-branchpoint:1.78
	sid-snapshot-20100201:1.78
	sid-snapshot-20100101:1.78
	gdb_7_0_1-2009-12-22-release:1.77
	sid-snapshot-20091201:1.77
	sid-snapshot-20091101:1.77
	binutils-2_20:1.76.2.1
	gdb_7_0-2009-10-06-release:1.77
	sid-snapshot-20091001:1.77
	gdb_7_0-branch:1.77.0.2
	gdb_7_0-2009-09-16-branchpoint:1.77
	arc-sim-20090309:1.73
	binutils-arc-20081103-branch:1.74.0.12
	binutils-arc-20081103-branchpoint:1.74
	binutils-2_20-branch:1.76.0.2
	binutils-2_20-branchpoint:1.76
	sid-snapshot-20090901:1.75
	sid-snapshot-20090801:1.75
	msnyder-checkpoint-072509-branch:1.75.0.4
	msnyder-checkpoint-072509-branchpoint:1.75
	sid-snapshot-20090701:1.75
	dje-cgen-play1-branch:1.75.0.2
	dje-cgen-play1-branchpoint:1.75
	sid-snapshot-20090601:1.75
	sid-snapshot-20090501:1.75
	sid-snapshot-20090401:1.75
	arc-20081103-branch:1.74.0.10
	arc-20081103-branchpoint:1.74
	arc-insight_6_8-branch:1.73.0.10
	arc-insight_6_8-branchpoint:1.73
	insight_6_8-branch:1.73.0.8
	insight_6_8-branchpoint:1.73
	sid-snapshot-20090301:1.74
	binutils-2_19_1:1.74
	sid-snapshot-20090201:1.74
	sid-snapshot-20090101:1.74
	reverse-20081226-branch:1.74.0.8
	reverse-20081226-branchpoint:1.74
	sid-snapshot-20081201:1.74
	multiprocess-20081120-branch:1.74.0.6
	multiprocess-20081120-branchpoint:1.74
	sid-snapshot-20081101:1.74
	binutils-2_19:1.74
	sid-snapshot-20081001:1.74
	reverse-20080930-branch:1.74.0.4
	reverse-20080930-branchpoint:1.74
	binutils-2_19-branch:1.74.0.2
	binutils-2_19-branchpoint:1.74
	sid-snapshot-20080901:1.74
	sid-snapshot-20080801:1.74
	reverse-20080717-branch:1.73.0.6
	reverse-20080717-branchpoint:1.73
	sid-snapshot-20080701:1.73
	msnyder-reverse-20080609-branch:1.73.0.4
	msnyder-reverse-20080609-branchpoint:1.73
	drow-reverse-20070409-branch:1.70.0.2
	drow-reverse-20070409-branchpoint:1.70
	sid-snapshot-20080601:1.73
	sid-snapshot-20080501:1.73
	sid-snapshot-20080403:1.73
	sid-snapshot-20080401:1.73
	gdb_6_8-2008-03-27-release:1.73
	sid-snapshot-20080301:1.73
	gdb_6_8-branch:1.73.0.2
	gdb_6_8-2008-02-26-branchpoint:1.73
	sid-snapshot-20080201:1.73
	sid-snapshot-20080101:1.73
	sid-snapshot-20071201:1.73
	sid-snapshot-20071101:1.73
	gdb_6_7_1-2007-10-29-release:1.72
	gdb_6_7-2007-10-10-release:1.72
	sid-snapshot-20071001:1.72
	gdb_6_7-branch:1.72.0.4
	gdb_6_7-2007-09-07-branchpoint:1.72
	binutils-2_18:1.72
	binutils-2_18-branch:1.72.0.2
	binutils-2_18-branchpoint:1.72
	insight_6_6-20070208-release:1.69
	binutils-csl-coldfire-4_1-32:1.63
	binutils-csl-sourcerygxx-4_1-32:1.63
	gdb_6_6-2006-12-18-release:1.69
	binutils-csl-innovasic-fido-3_4_4-33:1.63
	binutils-csl-sourcerygxx-3_4_4-32:1.57
	binutils-csl-coldfire-4_1-30:1.63
	binutils-csl-sourcerygxx-4_1-30:1.63
	binutils-csl-coldfire-4_1-28:1.63
	binutils-csl-sourcerygxx-4_1-29:1.63
	binutils-csl-sourcerygxx-4_1-28:1.63
	gdb_6_6-branch:1.69.0.2
	gdb_6_6-2006-11-15-branchpoint:1.69
	binutils-csl-arm-2006q3-27:1.63
	binutils-csl-sourcerygxx-4_1-27:1.63
	binutils-csl-arm-2006q3-26:1.63
	binutils-csl-sourcerygxx-4_1-26:1.63
	binutils-csl-sourcerygxx-4_1-25:1.63
	binutils-csl-sourcerygxx-4_1-24:1.63
	binutils-csl-sourcerygxx-4_1-23:1.63
	insight_6_5-20061003-release:1.64
	gdb-csl-symbian-6_4_50_20060226-12:1.62
	binutils-csl-sourcerygxx-4_1-21:1.63
	binutils-csl-arm-2006q3-21:1.63
	binutils-csl-sourcerygxx-4_1-22:1.63
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.63
	binutils-csl-sourcerygxx-4_1-20:1.63
	binutils-csl-arm-2006q3-19:1.63
	binutils-csl-sourcerygxx-4_1-19:1.63
	binutils-csl-sourcerygxx-4_1-18:1.63
	binutils-csl-renesas-4_1-9:1.63
	gdb-csl-sourcerygxx-3_4_4-25:1.62
	binutils-csl-sourcerygxx-3_4_4-25:1.57
	nickrob-async-20060828-mergepoint:1.68
	gdb-csl-symbian-6_4_50_20060226-11:1.62
	binutils-csl-renesas-4_1-8:1.63
	binutils-csl-renesas-4_1-7:1.63
	binutils-csl-renesas-4_1-6:1.63
	gdb-csl-sourcerygxx-4_1-17:1.62
	binutils-csl-sourcerygxx-4_1-17:1.63
	gdb-csl-20060226-branch-local-2:1.62
	gdb-csl-sourcerygxx-4_1-14:1.62
	binutils-csl-sourcerygxx-4_1-14:1.63
	binutils-csl-sourcerygxx-4_1-15:1.63
	gdb-csl-sourcerygxx-4_1-13:1.62
	binutils-csl-sourcerygxx-4_1-13:1.63
	binutils-2_17:1.63
	gdb-csl-sourcerygxx-4_1-12:1.62
	binutils-csl-sourcerygxx-4_1-12:1.63
	gdb-csl-sourcerygxx-3_4_4-21:1.62
	binutils-csl-sourcerygxx-3_4_4-21:1.63
	gdb_6_5-20060621-release:1.64
	binutils-csl-wrs-linux-3_4_4-24:1.57
	binutils-csl-wrs-linux-3_4_4-23:1.57
	gdb-csl-sourcerygxx-4_1-9:1.62
	binutils-csl-sourcerygxx-4_1-9:1.63
	gdb-csl-sourcerygxx-4_1-8:1.62
	binutils-csl-sourcerygxx-4_1-8:1.63
	gdb-csl-sourcerygxx-4_1-7:1.62
	binutils-csl-sourcerygxx-4_1-7:1.63
	gdb-csl-arm-2006q1-6:1.62
	binutils-csl-arm-2006q1-6:1.63
	gdb-csl-sourcerygxx-4_1-6:1.62
	binutils-csl-sourcerygxx-4_1-6:1.63
	binutils-csl-wrs-linux-3_4_4-22:1.57
	gdb-csl-symbian-6_4_50_20060226-10:1.62
	gdb-csl-symbian-6_4_50_20060226-9:1.62
	gdb-csl-symbian-6_4_50_20060226-8:1.62
	gdb-csl-coldfire-4_1-11:1.62
	binutils-csl-coldfire-4_1-11:1.63
	gdb-csl-sourcerygxx-3_4_4-19:1.62
	binutils-csl-sourcerygxx-3_4_4-19:1.63
	gdb-csl-coldfire-4_1-10:1.62
	gdb_6_5-branch:1.64.0.4
	gdb_6_5-2006-05-14-branchpoint:1.64
	binutils-csl-coldfire-4_1-10:1.63
	gdb-csl-sourcerygxx-4_1-5:1.62
	binutils-csl-sourcerygxx-4_1-5:1.63
	nickrob-async-20060513-branch:1.64.0.2
	nickrob-async-20060513-branchpoint:1.64
	gdb-csl-sourcerygxx-4_1-4:1.62
	binutils-csl-sourcerygxx-4_1-4:1.63
	msnyder-reverse-20060502-branch:1.63.0.10
	msnyder-reverse-20060502-branchpoint:1.63
	binutils-csl-wrs-linux-3_4_4-21:1.57
	gdb-csl-morpho-4_1-4:1.62
	binutils-csl-morpho-4_1-4:1.63
	gdb-csl-sourcerygxx-3_4_4-17:1.62
	binutils-csl-sourcerygxx-3_4_4-17:1.63
	binutils-csl-wrs-linux-3_4_4-20:1.57
	readline_5_1-import-branch:1.63.0.8
	readline_5_1-import-branchpoint:1.63
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.62
	binutils-2_17-branch:1.63.0.6
	binutils-2_17-branchpoint:1.63
	gdb-csl-symbian-20060226-branch:1.62.0.16
	gdb-csl-symbian-20060226-branchpoint:1.62
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.62
	msnyder-reverse-20060331-branch:1.63.0.4
	msnyder-reverse-20060331-branchpoint:1.63
	binutils-csl-2_17-branch:1.63.0.2
	binutils-csl-2_17-branchpoint:1.63
	gdb-csl-available-20060303-branch:1.62.0.14
	gdb-csl-available-20060303-branchpoint:1.62
	gdb-csl-20060226-branch:1.62.0.12
	gdb-csl-20060226-branchpoint:1.62
	gdb_6_4-20051202-release:1.62
	msnyder-fork-checkpoint-branch:1.62.0.10
	msnyder-fork-checkpoint-branchpoint:1.62
	gdb-csl-gxxpro-6_3-branch:1.62.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.62
	gdb_6_4-branch:1.62.0.6
	gdb_6_4-2005-11-01-branchpoint:1.62
	gdb-csl-arm-20051020-branch:1.62.0.4
	gdb-csl-arm-20051020-branchpoint:1.62
	binutils-csl-gxxpro-3_4-branch:1.57.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.57
	binutils-2_16_1:1.57
	msnyder-tracepoint-checkpoint-branch:1.62.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.62
	gdb-csl-arm-20050325-2005-q1b:1.60
	binutils-csl-arm-2005q1b:1.57
	binutils-2_16:1.57
	gdb-csl-arm-20050325-2005-q1a:1.60
	binutils-csl-arm-2005q1a:1.57
	csl-arm-20050325-branch:1.60.0.2
	csl-arm-20050325-branchpoint:1.60
	binutils-csl-arm-2005q1-branch:1.57.0.4
	binutils-csl-arm-2005q1-branchpoint:1.57
	binutils-2_16-branch:1.57.0.2
	binutils-2_16-branchpoint:1.57
	csl-arm-2004-q3d:1.55
	gdb_6_3-20041109-release:1.54
	gdb_6_3-branch:1.54.0.2
	gdb_6_3-20041019-branchpoint:1.54
	csl-arm-2004-q3:1.54
	drow_intercu-merge-20040921:1.54
	drow_intercu-merge-20040915:1.54
	jimb-gdb_6_2-e500-branch:1.53.0.6
	jimb-gdb_6_2-e500-branchpoint:1.53
	gdb_6_2-20040730-release:1.53
	gdb_6_2-branch:1.53.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.53
	gdb_6_1_1-20040616-release:1.51
	binutils-2_15:1.51
	binutils-2_15-branchpoint:1.51
	csl-arm-2004-q1a:1.51
	csl-arm-2004-q1:1.51
	gdb_6_1-2004-04-05-release:1.51
	drow_intercu-merge-20040402:1.51
	drow_intercu-merge-20040327:1.51
	ezannoni_pie-20040323-branch:1.51.0.14
	ezannoni_pie-20040323-branchpoint:1.51
	cagney_tramp-20040321-mergepoint:1.51
	cagney_tramp-20040309-branch:1.51.0.12
	cagney_tramp-20040309-branchpoint:1.51
	gdb_6_1-branch:1.51.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.51
	drow_intercu-20040221-branch:1.51.0.8
	drow_intercu-20040221-branchpoint:1.51
	binutils-2_15-branch:1.51.0.6
	cagney_bfdfile-20040213-branch:1.51.0.4
	cagney_bfdfile-20040213-branchpoint:1.51
	drow-cplus-merge-20040208:1.51
	carlton_dictionary-20040126-merge:1.51
	cagney_bigcore-20040122-branch:1.51.0.2
	cagney_bigcore-20040122-branchpoint:1.51
	drow-cplus-merge-20040113:1.51
	csl-arm-2003-q4:1.49
	drow-cplus-merge-20031224:1.49
	drow-cplus-merge-20031220:1.49
	carlton_dictionary-20031215-merge:1.49
	drow-cplus-merge-20031214:1.49
	carlton-dictionary-20031111-merge:1.46
	gdb_6_0-2003-10-04-release:1.44
	kettenis_sparc-20030918-branch:1.46.0.6
	kettenis_sparc-20030918-branchpoint:1.46
	carlton_dictionary-20030917-merge:1.46
	ezannoni_pie-20030916-branchpoint:1.46
	ezannoni_pie-20030916-branch:1.46.0.4
	cagney_x86i386-20030821-branch:1.46.0.2
	cagney_x86i386-20030821-branchpoint:1.46
	carlton_dictionary-20030805-merge:1.46
	carlton_dictionary-20030627-merge:1.45
	gdb_6_0-branch:1.44.0.6
	gdb_6_0-2003-06-23-branchpoint:1.44
	jimb-ppc64-linux-20030613-branch:1.44.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.44
	binutils-2_14:1.43
	cagney_convert-20030606-branch:1.44.0.2
	cagney_convert-20030606-branchpoint:1.44
	cagney_writestrings-20030508-branch:1.43.0.16
	cagney_writestrings-20030508-branchpoint:1.43
	jimb-ppc64-linux-20030528-branch:1.43.0.14
	jimb-ppc64-linux-20030528-branchpoint:1.43
	carlton_dictionary-20030523-merge:1.43
	cagney_fileio-20030521-branch:1.43.0.12
	cagney_fileio-20030521-branchpoint:1.43
	kettenis_i386newframe-20030517-mergepoint:1.43
	jimb-ppc64-linux-20030509-branch:1.43.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.43
	kettenis_i386newframe-20030504-mergepoint:1.43
	carlton_dictionary-20030430-merge:1.43
	binutils-2_14-branch:1.43.0.8
	binutils-2_14-branchpoint:1.43
	kettenis_i386newframe-20030419-branch:1.43.0.6
	kettenis_i386newframe-20030419-branchpoint:1.43
	carlton_dictionary-20030416-merge:1.43
	cagney_frameaddr-20030409-mergepoint:1.43
	kettenis_i386newframe-20030406-branch:1.43.0.4
	kettenis_i386newframe-20030406-branchpoint:1.43
	cagney_frameaddr-20030403-branchpoint:1.43
	cagney_frameaddr-20030403-branch:1.43.0.2
	cagney_framebase-20030330-mergepoint:1.42
	cagney_framebase-20030326-branch:1.42.0.2
	cagney_framebase-20030326-branchpoint:1.42
	cagney_lazyid-20030317-branch:1.41.0.12
	cagney_lazyid-20030317-branchpoint:1.41
	kettenis-i386newframe-20030316-mergepoint:1.41
	offbyone-20030313-branch:1.41.0.10
	offbyone-20030313-branchpoint:1.41
	kettenis-i386newframe-20030308-branch:1.41.0.8
	kettenis-i386newframe-20030308-branchpoint:1.41
	carlton_dictionary-20030305-merge:1.41
	cagney_offbyone-20030303-branch:1.41.0.6
	cagney_offbyone-20030303-branchpoint:1.41
	carlton_dictionary-20030207-merge:1.41
	interps-20030202-branch:1.41.0.4
	interps-20030202-branchpoint:1.41
	cagney-unwind-20030108-branch:1.41.0.2
	cagney-unwind-20030108-branchpoint:1.41
	binutils-2_13_2_1:1.38.4.1
	binutils-2_13_2:1.38.4.1
	carlton_dictionary-20021223-merge:1.41
	gdb_5_3-2002-12-12-release:1.38
	carlton_dictionary-20021115-merge:1.39
	binutils-2_13_1:1.38.4.1
	kseitz_interps-20021105-merge:1.39
	kseitz_interps-20021103-merge:1.39
	drow-cplus-merge-20021020:1.39
	drow-cplus-merge-20021025:1.39
	carlton_dictionary-20021025-merge:1.39
	carlton_dictionary-20021011-merge:1.39
	drow-cplus-branch:1.38.0.16
	drow-cplus-branchpoint:1.38
	kseitz_interps-20020930-merge:1.38
	carlton_dictionary-20020927-merge:1.38
	carlton_dictionary-branch:1.38.0.14
	carlton_dictionary-20020920-branchpoint:1.38
	sid-20020905-branchpoint:1.38
	sid-20020905-branch:1.38.0.12
	gdb_5_3-branch:1.38.0.10
	gdb_5_3-2002-09-04-branchpoint:1.38
	kseitz_interps-20020829-merge:1.38
	cagney_sysregs-20020825-branch:1.38.0.8
	cagney_sysregs-20020825-branchpoint:1.38
	readline_4_3-import-branch:1.38.0.6
	readline_4_3-import-branchpoint:1.38
	binutils-2_13:1.38
	gdb_5_2_1-2002-07-23-release:1.33
	binutils-2_13-branchpoint:1.38
	binutils-2_13-branch:1.38.0.4
	kseitz_interps-20020528-branch:1.38.0.2
	kseitz_interps-20020528-branchpoint:1.38
	cagney_regbuf-20020515-branch:1.37.0.4
	cagney_regbuf-20020515-branchpoint:1.37
	binutils-2_12_1:1.33.2.2
	jimb-macro-020506-branch:1.37.0.2
	jimb-macro-020506-branchpoint:1.37
	gdb_5_2-2002-04-29-release:1.33
	binutils-2_12:1.33
	gdb_5_2-branch:1.33.0.4
	gdb_5_2-2002-03-03-branchpoint:1.33
	binutils-2_12-branch:1.33.0.2
	binutils-2_12-branchpoint:1.33
	gdb_5_1_1-2002-01-24-release:1.27
	gdb_5_1_0_1-2002-01-03-release:1.27
	cygnus_cvs_20020108_pre:1.31
	gdb_5_1_0_1-2002-01-03-branch:1.27.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.27
	gdb_5_1-2001-11-21-release:1.27
	gdb_s390-2001-09-26-branch:1.27.0.4
	gdb_s390-2001-09-26-branchpoint:1.27
	gdb_5_1-2001-07-29-branch:1.27.0.2
	gdb_5_1-2001-07-29-branchpoint:1.27
	binutils-2_11_2:1.23.2.2
	binutils-2_11_1:1.23.2.2
	binutils-2_11:1.23
	x86_64versiong3:1.23
	binutils-2_11-branch:1.23.0.2
	insight-precleanup-2001-01-01:1.21
	binutils-2_10_1:1.16
	binutils-2_10:1.16
	gdb-premipsmulti-2000-06-06-branch:1.16.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.16
	gdb_5_0-2000-05-19-release:1.16
	gdb_4_18_2-2000-05-18-release:1.16
	gdb_4_95_1-2000-05-11-snapshot:1.16
	gdb_4_95_0-2000-04-27-snapshot:1.16
	gdb_5_0-2000-04-10-branch:1.16.0.4
	gdb_5_0-2000-04-10-branchpoint:1.16
	binutils-2_10-branch:1.16.0.2
	binutils-2_10-branchpoint:1.16
	binutils_latest_snapshot:1.81
	repo-unification-2000-02-06:1.13
	binu_ss_19990721:1.10
	binu_ss_19990602:1.6
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.81
date	2013.02.10.04.36.30;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2012.05.05.03.05.25;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2010.08.25.07.02.40;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2009.12.12.10.07.53;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2009.09.05.07.56.21;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	2009.09.02.07.18.35;	author amodra;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2009.03.28.23.19.00;	author mmitchel;	state Exp;
branches;
next	1.74;

1.74
date	2008.07.18.11.30.22;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	2007.10.15.02.00.11;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2007.07.03.14.26.39;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2007.03.26.12.22.59;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2006.11.10.07.35.19;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2006.08.21.08.12.44;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2006.08.07.10.26.08;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2006.08.06.15.04.17;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.11.08.48.58;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2005.05.04.15.53.02;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2005.03.22.18.43.09;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.22.16.14.41;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.21.15.43.38;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2005.02.16.02.38.53;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2005.01.31.23.13.15;	author bje;	state Exp;
branches;
next	1.55;

1.55
date	2004.10.21.15.28.15;	author hjl;	state Exp;
branches;
next	1.54;

1.54
date	2004.08.13.03.15.55;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.29.13.46.29;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2004.06.24.04.46.15;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2004.01.09.13.59.55;	author nickc;	state Exp;
branches
	1.51.8.1;
next	1.50;

1.50
date	2004.01.08.16.46.56;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2003.12.05.11.30.18;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.04.17.46.24;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2003.11.24.18.06.39;	author kazu;	state Exp;
branches;
next	1.46;

1.46
date	2003.07.25.10.50.03;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.25.06.40.18;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.04.10.47.30;	author sveinse;	state Exp;
branches;
next	1.43;

1.43
date	2003.04.01.13.08.05;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2003.03.25.20.55.57;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.21.02.21.00;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.30.08.39.35;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.23.12.37.19;	author nickc;	state Exp;
branches
	1.38.2.1
	1.38.4.1
	1.38.14.1
	1.38.16.1;
next	1.37;

1.37
date	2002.04.18.09.28.29;	author nickc;	state Exp;
branches
	1.37.4.1;
next	1.36;

1.36
date	2002.04.04.19.53.35;	author drow;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.04.14.04.39;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.27.11.28.19;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.01.13.26.56;	author pthomas;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2002.01.30.14.51.38;	author pthomas;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.20.23.30.34;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.18.09.57.21;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.25.09.47.34;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.01.15.18.32;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.27.17.12.17;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.06.22.33.46;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.06.20.27.50;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.23.11.45.52;	author kazu;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.01.11.01.43.20;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.18.20.50.41;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.25.00.21.34;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.15.20.20.52;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.08.23.46.41;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.04.05.11.37;	author aoliva;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.01.20.39.07;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.28.18.56.10;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	99.12.17.00.42.32;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	99.11.25.11.52.39;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	99.07.27.14.45.44;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	99.07.19.14.55.15;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	99.07.12.10.28.30;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.07.12.07.34.52;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.06.21.10.04.37;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.25.11.56.16;	author clm;	state Exp;
branches;
next	1.5;

1.5
date	99.05.19.10.20.12;	author clm;	state Exp;
branches;
next	1.4;

1.4
date	99.05.19.07.27.14;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.05.10.18.27.32;	author clm;	state Exp;
branches;
next	1.2;

1.2
date	99.05.05.18.56.25;	author clm;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.76.2.1
date	2009.09.05.08.00.18;	author nickc;	state Exp;
branches;
next	;

1.51.8.1
date	2004.09.16.17.00.13;	author drow;	state Exp;
branches;
next	;

1.38.2.1
date	2002.11.03.22.01.33;	author ezannoni;	state Exp;
branches;
next	;

1.38.4.1
date	2002.10.11.08.56.13;	author amodra;	state Exp;
branches;
next	;

1.38.14.1
date	2002.10.11.22.22.46;	author carlton;	state Exp;
branches;
next	1.38.14.2;

1.38.14.2
date	2002.12.23.19.37.25;	author carlton;	state Exp;
branches;
next	1.38.14.3;

1.38.14.3
date	2003.04.16.19.56.41;	author carlton;	state Exp;
branches;
next	1.38.14.4;

1.38.14.4
date	2003.06.27.21.49.06;	author carlton;	state Exp;
branches;
next	1.38.14.5;

1.38.14.5
date	2003.08.05.17.12.43;	author carlton;	state Exp;
branches;
next	1.38.14.6;

1.38.14.6
date	2003.12.15.23.59.12;	author carlton;	state Exp;
branches;
next	1.38.14.7;

1.38.14.7
date	2004.01.26.19.11.03;	author carlton;	state Exp;
branches;
next	;

1.38.16.1
date	2002.10.26.17.11.56;	author drow;	state Exp;
branches;
next	1.38.16.2;

1.38.16.2
date	2003.12.14.20.26.34;	author drow;	state Exp;
branches;
next	1.38.16.3;

1.38.16.3
date	2004.01.13.16.11.35;	author drow;	state Exp;
branches;
next	;

1.37.4.1
date	2002.06.15.16.42.34;	author cagney;	state Exp;
branches;
next	;

1.33.2.1
date	2002.04.04.14.52.54;	author amodra;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2002.05.10.10.02.52;	author nickc;	state Exp;
branches;
next	;

1.23.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2001.06.14.11.16.59;	author nickc;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.81
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@/* BFD back-end for ARM COFF files.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "coff/arm.h"
#include "coff/internal.h"

#ifdef COFF_WITH_PE
#include "coff/pe.h"
#endif

#include "libcoff.h"

/* Macros for manipulation the bits in the flags field of the coff data
   structure.  */
#define APCS_26_FLAG(abfd) \
  (coff_data (abfd)->flags & F_APCS_26)

#define APCS_FLOAT_FLAG(abfd) \
  (coff_data (abfd)->flags & F_APCS_FLOAT)

#define PIC_FLAG(abfd) \
  (coff_data (abfd)->flags & F_PIC)

#define APCS_SET(abfd) \
  (coff_data (abfd)->flags & F_APCS_SET)

#define SET_APCS_FLAGS(abfd, flgs) \
  do									\
    {									\
      coff_data (abfd)->flags &= ~(F_APCS_26 | F_APCS_FLOAT | F_PIC);	\
      coff_data (abfd)->flags |= (flgs) | F_APCS_SET;			\
    }									\
  while (0)

#define INTERWORK_FLAG(abfd) \
  (coff_data (abfd)->flags & F_INTERWORK)

#define INTERWORK_SET(abfd) \
  (coff_data (abfd)->flags & F_INTERWORK_SET)

#define SET_INTERWORK_FLAG(abfd, flg) \
  do									\
    {									\
      coff_data (abfd)->flags &= ~F_INTERWORK;				\
      coff_data (abfd)->flags |= (flg) | F_INTERWORK_SET;		\
    }									\
  while (0)

#ifndef NUM_ELEM
#define NUM_ELEM(a) ((sizeof (a)) / sizeof ((a)[0]))
#endif

typedef enum {bunknown, b9, b12, b23} thumb_pcrel_branchtype;
/* Some typedefs for holding instructions.  */
typedef unsigned long int insn32;
typedef unsigned short int insn16;

/* The linker script knows the section names for placement.
   The entry_names are used to do simple name mangling on the stubs.
   Given a function name, and its type, the stub can be found. The
   name can be changed. The only requirement is the %s be present.  */

#define THUMB2ARM_GLUE_SECTION_NAME ".glue_7t"
#define THUMB2ARM_GLUE_ENTRY_NAME   "__%s_from_thumb"

#define ARM2THUMB_GLUE_SECTION_NAME ".glue_7"
#define ARM2THUMB_GLUE_ENTRY_NAME   "__%s_from_arm"

/* Used by the assembler.  */

static bfd_reloc_status_type
coff_arm_reloc (bfd *abfd,
		arelent *reloc_entry,
		asymbol *symbol ATTRIBUTE_UNUSED,
		void * data,
		asection *input_section ATTRIBUTE_UNUSED,
		bfd *output_bfd,
		char **error_message ATTRIBUTE_UNUSED)
{
  symvalue diff;

  if (output_bfd == NULL)
    return bfd_reloc_continue;

  diff = reloc_entry->addend;

#define DOIT(x)							\
  x = ((x & ~howto->dst_mask)					\
       | (((x & howto->src_mask) + diff) & howto->dst_mask))

    if (diff != 0)
      {
	reloc_howto_type *howto = reloc_entry->howto;
	unsigned char *addr = (unsigned char *) data + reloc_entry->address;

	switch (howto->size)
	  {
	  case 0:
	    {
	      char x = bfd_get_8 (abfd, addr);
	      DOIT (x);
	      bfd_put_8 (abfd, x, addr);
	    }
	    break;

	  case 1:
	    {
	      short x = bfd_get_16 (abfd, addr);
	      DOIT (x);
	      bfd_put_16 (abfd, (bfd_vma) x, addr);
	    }
	    break;

	  case 2:
	    {
	      long x = bfd_get_32 (abfd, addr);
	      DOIT (x);
	      bfd_put_32 (abfd, (bfd_vma) x, addr);
	    }
	    break;

	  default:
	    abort ();
	  }
      }

  /* Now let bfd_perform_relocation finish everything up.  */
  return bfd_reloc_continue;
}

/* If USER_LABEL_PREFIX is defined as "_" (see coff_arm_is_local_label_name()
   in this file), then TARGET_UNDERSCORE should be defined, otherwise it
   should not.  */
#ifndef TARGET_UNDERSCORE
#define TARGET_UNDERSCORE '_'
#endif

#ifndef PCRELOFFSET
#define PCRELOFFSET TRUE
#endif

/* These most certainly belong somewhere else. Just had to get rid of
   the manifest constants in the code.  */

#ifdef ARM_WINCE

#define ARM_26D      0
#define ARM_32       1
#define ARM_RVA32    2
#define ARM_26	     3
#define ARM_THUMB12  4
#define ARM_SECTION  14
#define ARM_SECREL   15

#else

#define ARM_8        0
#define ARM_16       1
#define ARM_32       2
#define ARM_26       3
#define ARM_DISP8    4
#define ARM_DISP16   5
#define ARM_DISP32   6
#define ARM_26D      7
/* 8 is unused.  */
#define ARM_NEG16    9
#define ARM_NEG32   10
#define ARM_RVA32   11
#define ARM_THUMB9  12
#define ARM_THUMB12 13
#define ARM_THUMB23 14

#endif

static bfd_reloc_status_type aoutarm_fix_pcrel_26_done
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type aoutarm_fix_pcrel_26
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type coff_thumb_pcrel_12
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
#ifndef ARM_WINCE
static bfd_reloc_status_type coff_thumb_pcrel_9
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type coff_thumb_pcrel_23
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
#endif

static reloc_howto_type aoutarm_std_reloc_howto[] =
  {
#ifdef ARM_WINCE
    HOWTO (ARM_26D,
	   2,
	   2,
	   24,
	   TRUE,
	   0,
	   complain_overflow_dont,
	   aoutarm_fix_pcrel_26_done,
	   "ARM_26D",
	   TRUE, 	/* partial_inplace.  */
	   0x00ffffff,
	   0x0,
	   PCRELOFFSET),
    HOWTO (ARM_32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_32",
	   TRUE, 	/* partial_inplace.  */
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_RVA32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_RVA32",
	   TRUE, 	/* partial_inplace.  */
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_26,
	   2,
	   2,
	   24,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   aoutarm_fix_pcrel_26 ,
	   "ARM_26",
	   FALSE,
	   0x00ffffff,
	   0x00ffffff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB12,
	   1,
	   1,
	   11,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_12 ,
	   "ARM_THUMB12",
	   FALSE,
	   0x000007ff,
	   0x000007ff,
	   PCRELOFFSET),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    EMPTY_HOWTO (-1),
    HOWTO (ARM_SECTION,
	   0,
	   1,
	   16,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_SECTION",
	   TRUE, 	/* partial_inplace.  */
	   0x0000ffff,
	   0x0000ffff,
	   PCRELOFFSET),
    HOWTO (ARM_SECREL,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_SECREL",
	   TRUE, 	/* partial_inplace.  */
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
#else /* not ARM_WINCE */
    HOWTO (ARM_8,
	   0,
	   0,
	   8,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_8",
	   TRUE,
	   0x000000ff,
	   0x000000ff,
	   PCRELOFFSET),
    HOWTO (ARM_16,
	   0,
	   1,
	   16,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_16",
	   TRUE,
	   0x0000ffff,
	   0x0000ffff,
	   PCRELOFFSET),
    HOWTO (ARM_32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_26,
	   2,
	   2,
	   24,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   aoutarm_fix_pcrel_26 ,
	   "ARM_26",
	   FALSE,
	   0x00ffffff,
	   0x00ffffff,
	   PCRELOFFSET),
    HOWTO (ARM_DISP8,
	   0,
	   0,
	   8,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_arm_reloc,
	   "ARM_DISP8",
	   TRUE,
	   0x000000ff,
	   0x000000ff,
	   TRUE),
    HOWTO (ARM_DISP16,
	   0,
	   1,
	   16,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_arm_reloc,
	   "ARM_DISP16",
	   TRUE,
	   0x0000ffff,
	   0x0000ffff,
	   TRUE),
    HOWTO (ARM_DISP32,
	   0,
	   2,
	   32,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_arm_reloc,
	   "ARM_DISP32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   TRUE),
    HOWTO (ARM_26D,
	   2,
	   2,
	   24,
	   FALSE,
	   0,
	   complain_overflow_dont,
	   aoutarm_fix_pcrel_26_done,
	   "ARM_26D",
	   TRUE,
	   0x00ffffff,
	   0x0,
	   FALSE),
    /* 8 is unused */
    EMPTY_HOWTO (-1),
    HOWTO (ARM_NEG16,
	   0,
	   -1,
	   16,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_NEG16",
	   TRUE,
	   0x0000ffff,
	   0x0000ffff,
	   FALSE),
    HOWTO (ARM_NEG32,
	   0,
	   -2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_NEG32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   FALSE),
    HOWTO (ARM_RVA32,
	   0,
	   2,
	   32,
	   FALSE,
	   0,
	   complain_overflow_bitfield,
	   coff_arm_reloc,
	   "ARM_RVA32",
	   TRUE,
	   0xffffffff,
	   0xffffffff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB9,
	   1,
	   1,
	   8,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_9 ,
	   "ARM_THUMB9",
	   FALSE,
	   0x000000ff,
	   0x000000ff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB12,
	   1,
	   1,
	   11,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_12 ,
	   "ARM_THUMB12",
	   FALSE,
	   0x000007ff,
	   0x000007ff,
	   PCRELOFFSET),
    HOWTO (ARM_THUMB23,
	   1,
	   2,
	   22,
	   TRUE,
	   0,
	   complain_overflow_signed,
	   coff_thumb_pcrel_23 ,
	   "ARM_THUMB23",
	   FALSE,
	   0x07ff07ff,
	   0x07ff07ff,
	   PCRELOFFSET)
#endif /* not ARM_WINCE */
  };

#define NUM_RELOCS NUM_ELEM (aoutarm_std_reloc_howto)

#ifdef COFF_WITH_PE
/* Return TRUE if this relocation should
   appear in the output .reloc section.  */

static bfd_boolean
in_reloc_p (bfd * abfd ATTRIBUTE_UNUSED,
	    reloc_howto_type * howto)
{
  return !howto->pc_relative && howto->type != ARM_RVA32;
}
#endif

#define RTYPE2HOWTO(cache_ptr, dst)		\
  (cache_ptr)->howto =				\
    (dst)->r_type < NUM_RELOCS			\
    ? aoutarm_std_reloc_howto + (dst)->r_type	\
    : NULL

#define coff_rtype_to_howto coff_arm_rtype_to_howto

static reloc_howto_type *
coff_arm_rtype_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
			 asection *sec,
			 struct internal_reloc *rel,
			 struct coff_link_hash_entry *h ATTRIBUTE_UNUSED,
			 struct internal_syment *sym ATTRIBUTE_UNUSED,
			 bfd_vma *addendp)
{
  reloc_howto_type * howto;

  if (rel->r_type >= NUM_RELOCS)
    return NULL;

  howto = aoutarm_std_reloc_howto + rel->r_type;

  if (rel->r_type == ARM_RVA32)
    *addendp -= pe_data (sec->output_section->owner)->pe_opthdr.ImageBase;

#if defined COFF_WITH_PE && defined ARM_WINCE
  if (rel->r_type == ARM_SECREL)
    {
      bfd_vma osect_vma;

      if (h && (h->type == bfd_link_hash_defined
		|| h->type == bfd_link_hash_defweak))
	osect_vma = h->root.u.def.section->output_section->vma;
      else
	{
	  int i;

	  /* Sigh, the only way to get the section to offset against
	     is to find it the hard way.  */

	  for (sec = abfd->sections, i = 1; i < sym->n_scnum; i++)
	    sec = sec->next;

	  osect_vma = sec->output_section->vma;
	}

      *addendp -= osect_vma;
    }
#endif

  return howto;
}

/* Used by the assembler.  */

static bfd_reloc_status_type
aoutarm_fix_pcrel_26_done (bfd *abfd ATTRIBUTE_UNUSED,
			   arelent *reloc_entry ATTRIBUTE_UNUSED,
			   asymbol *symbol ATTRIBUTE_UNUSED,
			   void * data ATTRIBUTE_UNUSED,
			   asection *input_section ATTRIBUTE_UNUSED,
			   bfd *output_bfd ATTRIBUTE_UNUSED,
			   char **error_message ATTRIBUTE_UNUSED)
{
  /* This is dead simple at present.  */
  return bfd_reloc_ok;
}

/* Used by the assembler.  */

static bfd_reloc_status_type
aoutarm_fix_pcrel_26 (bfd *abfd,
		      arelent *reloc_entry,
		      asymbol *symbol,
		      void * data,
		      asection *input_section,
		      bfd *output_bfd,
		      char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma relocation;
  bfd_size_type addr = reloc_entry->address;
  long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
  bfd_reloc_status_type flag = bfd_reloc_ok;

  /* If this is an undefined symbol, return error.  */
  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0)
    return output_bfd ? bfd_reloc_continue : bfd_reloc_undefined;

  /* If the sections are different, and we are doing a partial relocation,
     just ignore it for now.  */
  if (symbol->section->name != input_section->name
      && output_bfd != (bfd *)NULL)
    return bfd_reloc_continue;

  relocation = (target & 0x00ffffff) << 2;
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend.  */
  relocation += symbol->value;
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
  relocation -= input_section->output_section->vma;
  relocation -= input_section->output_offset;
  relocation -= addr;

  if (relocation & 3)
    return bfd_reloc_overflow;

  /* Check for overflow.  */
  if (relocation & 0x02000000)
    {
      if ((relocation & ~ (bfd_vma) 0x03ffffff) != ~ (bfd_vma) 0x03ffffff)
	flag = bfd_reloc_overflow;
    }
  else if (relocation & ~(bfd_vma) 0x03ffffff)
    flag = bfd_reloc_overflow;

  target &= ~0x00ffffff;
  target |= (relocation >> 2) & 0x00ffffff;
  bfd_put_32 (abfd, (bfd_vma) target, (bfd_byte *) data + addr);

  /* Now the ARM magic... Change the reloc type so that it is marked as done.
     Strictly this is only necessary if we are doing a partial relocation.  */
  reloc_entry->howto = &aoutarm_std_reloc_howto[ARM_26D];

  return flag;
}

static bfd_reloc_status_type
coff_thumb_pcrel_common (bfd *abfd,
			 arelent *reloc_entry,
			 asymbol *symbol,
			 void * data,
			 asection *input_section,
			 bfd *output_bfd,
			 char **error_message ATTRIBUTE_UNUSED,
			 thumb_pcrel_branchtype btype)
{
  bfd_vma relocation = 0;
  bfd_size_type addr = reloc_entry->address;
  long target = bfd_get_32 (abfd, (bfd_byte *) data + addr);
  bfd_reloc_status_type flag = bfd_reloc_ok;
  bfd_vma dstmsk;
  bfd_vma offmsk;
  bfd_vma signbit;

  /* NOTE: This routine is currently used by GAS, but not by the link
     phase.  */
  switch (btype)
    {
    case b9:
      dstmsk  = 0x000000ff;
      offmsk  = 0x000001fe;
      signbit = 0x00000100;
      break;

    case b12:
      dstmsk  = 0x000007ff;
      offmsk  = 0x00000ffe;
      signbit = 0x00000800;
      break;

    case b23:
      dstmsk  = 0x07ff07ff;
      offmsk  = 0x007fffff;
      signbit = 0x00400000;
      break;

    default:
      abort ();
    }

  /* If this is an undefined symbol, return error.  */
  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0)
    return output_bfd ? bfd_reloc_continue : bfd_reloc_undefined;

  /* If the sections are different, and we are doing a partial relocation,
     just ignore it for now.  */
  if (symbol->section->name != input_section->name
      && output_bfd != (bfd *)NULL)
    return bfd_reloc_continue;

  switch (btype)
    {
    case b9:
    case b12:
      relocation = ((target & dstmsk) << 1);
      break;

    case b23:
      if (bfd_big_endian (abfd))
	relocation = ((target & 0x7ff) << 1)  | ((target & 0x07ff0000) >> 4);
      else
	relocation = ((target & 0x7ff) << 12) | ((target & 0x07ff0000) >> 15);
      break;

    default:
      abort ();
    }

  relocation = (relocation ^ signbit) - signbit; /* Sign extend.  */
  relocation += symbol->value;
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
  relocation -= input_section->output_section->vma;
  relocation -= input_section->output_offset;
  relocation -= addr;

  if (relocation & 1)
    return bfd_reloc_overflow;

  /* Check for overflow.  */
  if (relocation & signbit)
    {
      if ((relocation & ~offmsk) != ~offmsk)
	flag = bfd_reloc_overflow;
    }
  else if (relocation & ~offmsk)
    flag = bfd_reloc_overflow;

  target &= ~dstmsk;
  switch (btype)
   {
   case b9:
   case b12:
     target |= (relocation >> 1);
     break;

   case b23:
     if (bfd_big_endian (abfd))
       target |= (((relocation & 0xfff) >> 1)
		  | ((relocation << 4)  & 0x07ff0000));
     else
       target |= (((relocation & 0xffe) << 15)
		  | ((relocation >> 12) & 0x7ff));
     break;

   default:
     abort ();
   }

  bfd_put_32 (abfd, (bfd_vma) target, (bfd_byte *) data + addr);

  /* Now the ARM magic... Change the reloc type so that it is marked as done.
     Strictly this is only necessary if we are doing a partial relocation.  */
  reloc_entry->howto = & aoutarm_std_reloc_howto [ARM_26D];

  /* TODO: We should possibly have DONE entries for the THUMB PCREL relocations.  */
  return flag;
}

#ifndef ARM_WINCE
static bfd_reloc_status_type
coff_thumb_pcrel_23 (bfd *abfd,
		     arelent *reloc_entry,
		     asymbol *symbol,
		     void * data,
		     asection *input_section,
		     bfd *output_bfd,
		     char **error_message)
{
  return coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data,
                                  input_section, output_bfd, error_message,
				  b23);
}

static bfd_reloc_status_type
coff_thumb_pcrel_9 (bfd *abfd,
		    arelent *reloc_entry,
		    asymbol *symbol,
		    void * data,
		    asection *input_section,
		    bfd *output_bfd,
		    char **error_message)
{
  return coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data,
                                  input_section, output_bfd, error_message,
				  b9);
}
#endif /* not ARM_WINCE */

static bfd_reloc_status_type
coff_thumb_pcrel_12 (bfd *abfd,
		     arelent *reloc_entry,
		     asymbol *symbol,
		     void * data,
		     asection *input_section,
		     bfd *output_bfd,
		     char **error_message)
{
  return coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data,
                                  input_section, output_bfd, error_message,
				  b12);
}

static const struct reloc_howto_struct *
coff_arm_reloc_type_lookup (bfd * abfd, bfd_reloc_code_real_type code)
{
#define ASTD(i,j)       case i: return aoutarm_std_reloc_howto + j

  if (code == BFD_RELOC_CTOR)
    switch (bfd_arch_bits_per_address (abfd))
      {
      case 32:
        code = BFD_RELOC_32;
        break;
      default:
	return NULL;
      }

  switch (code)
    {
#ifdef ARM_WINCE
      ASTD (BFD_RELOC_32,                   ARM_32);
      ASTD (BFD_RELOC_RVA,                  ARM_RVA32);
      ASTD (BFD_RELOC_ARM_PCREL_BRANCH,     ARM_26);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH12, ARM_THUMB12);
      ASTD (BFD_RELOC_32_SECREL,            ARM_SECREL);
#else
      ASTD (BFD_RELOC_8,                    ARM_8);
      ASTD (BFD_RELOC_16,                   ARM_16);
      ASTD (BFD_RELOC_32,                   ARM_32);
      ASTD (BFD_RELOC_ARM_PCREL_BRANCH,     ARM_26);
      ASTD (BFD_RELOC_ARM_PCREL_BLX,        ARM_26);
      ASTD (BFD_RELOC_8_PCREL,              ARM_DISP8);
      ASTD (BFD_RELOC_16_PCREL,             ARM_DISP16);
      ASTD (BFD_RELOC_32_PCREL,             ARM_DISP32);
      ASTD (BFD_RELOC_RVA,                  ARM_RVA32);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH9,  ARM_THUMB9);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH12, ARM_THUMB12);
      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH23, ARM_THUMB23);
      ASTD (BFD_RELOC_THUMB_PCREL_BLX,      ARM_THUMB23);
#endif
    default: return NULL;
    }
}

static reloc_howto_type *
coff_arm_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < (sizeof (aoutarm_std_reloc_howto)
	    / sizeof (aoutarm_std_reloc_howto[0]));
       i++)
    if (aoutarm_std_reloc_howto[i].name != NULL
	&& strcasecmp (aoutarm_std_reloc_howto[i].name, r_name) == 0)
      return &aoutarm_std_reloc_howto[i];

  return NULL;
}

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER  2
#define COFF_PAGE_SIZE                        0x1000

/* Turn a howto into a reloc  nunmber.  */
#define SELECT_RELOC(x,howto) { x.r_type = howto->type; }
#define BADMAG(x)             ARMBADMAG(x)
#define ARM                   1			/* Customize coffcode.h.  */

#ifndef ARM_WINCE
/* Make sure that the 'r_offset' field is copied properly
   so that identical binaries will compare the same.  */
#define SWAP_IN_RELOC_OFFSET	H_GET_32
#define SWAP_OUT_RELOC_OFFSET	H_PUT_32
#endif

/* Extend the coff_link_hash_table structure with a few ARM specific fields.
   This allows us to store global data here without actually creating any
   global variables, which is a no-no in the BFD world.  */
struct coff_arm_link_hash_table
  {
    /* The original coff_link_hash_table structure.  MUST be first field.  */
    struct coff_link_hash_table	root;

    /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
    bfd_size_type		thumb_glue_size;

    /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
    bfd_size_type		arm_glue_size;

    /* An arbitrary input BFD chosen to hold the glue sections.  */
    bfd *			bfd_of_glue_owner;

    /* Support interworking with old, non-interworking aware ARM code.  */
    int 			support_old_code;
};

/* Get the ARM coff linker hash table from a link_info structure.  */
#define coff_arm_hash_table(info) \
  ((struct coff_arm_link_hash_table *) ((info)->hash))

/* Create an ARM coff linker hash table.  */

static struct bfd_link_hash_table *
coff_arm_link_hash_table_create (bfd * abfd)
{
  struct coff_arm_link_hash_table * ret;
  bfd_size_type amt = sizeof (struct coff_arm_link_hash_table);

  ret = bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_coff_link_hash_table_init (&ret->root,
				       abfd,
				       _bfd_coff_link_hash_newfunc,
				       sizeof (struct coff_link_hash_entry)))
    {
      free (ret);
      return NULL;
    }

  return & ret->root.root;
}

static bfd_boolean
arm_emit_base_file_entry (struct bfd_link_info *info,
			  bfd *output_bfd,
			  asection *input_section,
			  bfd_vma reloc_offset)
{
  bfd_vma addr = (reloc_offset
		  - input_section->vma
		  + input_section->output_offset
		  + input_section->output_section->vma);

  if (coff_data (output_bfd)->pe)
     addr -= pe_data (output_bfd)->pe_opthdr.ImageBase;
  if (fwrite (&addr, sizeof (addr), 1, (FILE *) info->base_file) == 1)
    return TRUE;

  bfd_set_error (bfd_error_system_call);
  return FALSE;
}

#ifndef ARM_WINCE
/* The thumb form of a long branch is a bit finicky, because the offset
   encoding is split over two fields, each in it's own instruction. They
   can occur in any order. So given a thumb form of long branch, and an
   offset, insert the offset into the thumb branch and return finished
   instruction.

   It takes two thumb instructions to encode the target address. Each has
   11 bits to invest. The upper 11 bits are stored in one (identified by
   H-0.. see below), the lower 11 bits are stored in the other (identified
   by H-1).

   Combine together and shifted left by 1 (it's a half word address) and
   there you have it.

     Op: 1111 = F,
     H-0, upper address-0 = 000
     Op: 1111 = F,
     H-1, lower address-0 = 800

   They can be ordered either way, but the arm tools I've seen always put
   the lower one first. It probably doesn't matter. krk@@cygnus.com

   XXX:  Actually the order does matter.  The second instruction (H-1)
   moves the computed address into the PC, so it must be the second one
   in the sequence.  The problem, however is that whilst little endian code
   stores the instructions in HI then LOW order, big endian code does the
   reverse.  nickc@@cygnus.com.  */

#define LOW_HI_ORDER 0xF800F000
#define HI_LOW_ORDER 0xF000F800

static insn32
insert_thumb_branch (insn32 br_insn, int rel_off)
{
  unsigned int low_bits;
  unsigned int high_bits;

  BFD_ASSERT ((rel_off & 1) != 1);

  rel_off >>= 1;                              /* Half word aligned address.  */
  low_bits = rel_off & 0x000007FF;            /* The bottom 11 bits.  */
  high_bits = (rel_off >> 11) & 0x000007FF;   /* The top 11 bits.  */

  if ((br_insn & LOW_HI_ORDER) == LOW_HI_ORDER)
    br_insn = LOW_HI_ORDER | (low_bits << 16) | high_bits;
  else if ((br_insn & HI_LOW_ORDER) == HI_LOW_ORDER)
    br_insn = HI_LOW_ORDER | (high_bits << 16) | low_bits;
  else
    /* FIXME: the BFD library should never abort except for internal errors
       - it should return an error status.  */
    abort (); /* Error - not a valid branch instruction form.  */

  return br_insn;
}


static struct coff_link_hash_entry *
find_thumb_glue (struct bfd_link_info *info,
		 const char *name,
		 bfd *input_bfd)
{
  char *tmp_name;
  struct coff_link_hash_entry *myh;
  bfd_size_type amt = strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1;

  tmp_name = bfd_malloc (amt);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);

  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);

  if (myh == NULL)
    /* xgettext:c-format */
    _bfd_error_handler (_("%B: unable to find THUMB glue '%s' for `%s'"),
			input_bfd, tmp_name, name);

  free (tmp_name);

  return myh;
}
#endif /* not ARM_WINCE */

static struct coff_link_hash_entry *
find_arm_glue (struct bfd_link_info *info,
	       const char *name,
	       bfd *input_bfd)
{
  char *tmp_name;
  struct coff_link_hash_entry * myh;
  bfd_size_type amt = strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1;

  tmp_name = bfd_malloc (amt);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);

  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);

  if (myh == NULL)
    /* xgettext:c-format */
    _bfd_error_handler (_("%B: unable to find ARM glue '%s' for `%s'"),
			input_bfd, tmp_name, name);

  free (tmp_name);

  return myh;
}

/*
  ARM->Thumb glue:

       .arm
       __func_from_arm:
	     ldr r12, __func_addr
	     bx  r12
       __func_addr:
            .word func    @@ behave as if you saw a ARM_32 reloc
*/

#define ARM2THUMB_GLUE_SIZE 12
static const insn32 a2t1_ldr_insn       = 0xe59fc000;
static const insn32 a2t2_bx_r12_insn    = 0xe12fff1c;
static const insn32 a2t3_func_addr_insn = 0x00000001;

/*
   Thumb->ARM:				Thumb->(non-interworking aware) ARM

   .thumb				.thumb
   .align 2				.align 2
      __func_from_thumb:		   __func_from_thumb:
	   bx pc				push {r6, lr}
	   nop					ldr  r6, __func_addr
   .arm						mov  lr, pc
      __func_change_to_arm:			bx   r6
	   b func   			.arm
					   __func_back_to_thumb:
   		  				ldmia r13! {r6, lr}
   					        bx    lr
   					   __func_addr:
					        .word	func
*/

#define THUMB2ARM_GLUE_SIZE (globals->support_old_code ? 20 : 8)
#ifndef ARM_WINCE
static const insn16 t2a1_bx_pc_insn = 0x4778;
static const insn16 t2a2_noop_insn  = 0x46c0;
static const insn32 t2a3_b_insn     = 0xea000000;

static const insn16 t2a1_push_insn  = 0xb540;
static const insn16 t2a2_ldr_insn   = 0x4e03;
static const insn16 t2a3_mov_insn   = 0x46fe;
static const insn16 t2a4_bx_insn    = 0x4730;
static const insn32 t2a5_pop_insn   = 0xe8bd4040;
static const insn32 t2a6_bx_insn    = 0xe12fff1e;
#endif

/* TODO:
     We should really create new local (static) symbols in destination
     object for each stub we create.  We should also create local
     (static) symbols within the stubs when switching between ARM and
     Thumb code.  This will ensure that the debugger and disassembler
     can present a better view of stubs.

     We can treat stubs like literal sections, and for the THUMB9 ones
     (short addressing range) we should be able to insert the stubs
     between sections. i.e. the simplest approach (since relocations
     are done on a section basis) is to dump the stubs at the end of
     processing a section. That way we can always try and minimise the
     offset to and from a stub. However, this does not map well onto
     the way that the linker/BFD does its work: mapping all input
     sections to output sections via the linker script before doing
     all the processing.

     Unfortunately it may be easier to just to disallow short range
     Thumb->ARM stubs (i.e. no conditional inter-working branches,
     only branch-and-link (BL) calls.  This will simplify the processing
     since we can then put all of the stubs into their own section.

  TODO:
     On a different subject, rather than complaining when a
     branch cannot fit in the number of bits available for the
     instruction we should generate a trampoline stub (needed to
     address the complete 32bit address space).  */

/* The standard COFF backend linker does not cope with the special
   Thumb BRANCH23 relocation.  The alternative would be to split the
   BRANCH23 into seperate HI23 and LO23 relocations. However, it is a
   bit simpler simply providing our own relocation driver.  */

/* The reloc processing routine for the ARM/Thumb COFF linker.  NOTE:
   This code is a very slightly modified copy of
   _bfd_coff_generic_relocate_section.  It would be a much more
   maintainable solution to have a MACRO that could be expanded within
   _bfd_coff_generic_relocate_section that would only be provided for
   ARM/Thumb builds.  It is only the code marked THUMBEXTENSION that
   is different from the original.  */

static bfd_boolean
coff_arm_relocate_section (bfd *output_bfd,
			   struct bfd_link_info *info,
			   bfd *input_bfd,
			   asection *input_section,
			   bfd_byte *contents,
			   struct internal_reloc *relocs,
			   struct internal_syment *syms,
			   asection **sections)
{
  struct internal_reloc * rel;
  struct internal_reloc * relend;
#ifndef ARM_WINCE
  bfd_vma high_address = bfd_get_section_limit (input_bfd, input_section);
#endif

  rel = relocs;
  relend = rel + input_section->reloc_count;

  for (; rel < relend; rel++)
    {
      int                            done = 0;
      long                           symndx;
      struct coff_link_hash_entry *  h;
      struct internal_syment *       sym;
      bfd_vma                        addend;
      bfd_vma                        val;
      reloc_howto_type *             howto;
      bfd_reloc_status_type          rstat;
      bfd_vma                        h_val;

      symndx = rel->r_symndx;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	}
      else
	{
	  h = obj_coff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	}

      /* COFF treats common symbols in one of two ways.  Either the
         size of the symbol is included in the section contents, or it
         is not.  We assume that the size is not included, and force
         the rtype_to_howto function to adjust the addend as needed.  */

      if (sym != NULL && sym->n_scnum != 0)
	addend = - sym->n_value;
      else
	addend = 0;

      howto = coff_rtype_to_howto (input_bfd, input_section, rel, h,
				       sym, &addend);
      if (howto == NULL)
	return FALSE;

      /* The relocation_section function will skip pcrel_offset relocs
         when doing a relocatable link.  However, we want to convert
         ARM_26 to ARM_26D relocs if possible.  We return a fake howto in
         this case without pcrel_offset set, and adjust the addend to
         compensate.  'partial_inplace' is also set, since we want 'done'
         relocations to be reflected in section's data.  */
      if (rel->r_type == ARM_26
          && h != NULL
          && info->relocatable
          && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
          && (h->root.u.def.section->output_section
	      == input_section->output_section))
        {
          static reloc_howto_type fake_arm26_reloc =
	    HOWTO (ARM_26,
    	       2,
    	       2,
    	       24,
    	       TRUE,
    	       0,
    	       complain_overflow_signed,
    	       aoutarm_fix_pcrel_26 ,
    	       "ARM_26",
    	       TRUE,
    	       0x00ffffff,
    	       0x00ffffff,
    	       FALSE);

          addend -= rel->r_vaddr - input_section->vma;
#ifdef ARM_WINCE
          /* FIXME: I don't know why, but the hack is necessary for correct
                    generation of bl's instruction offset.  */
          addend -= 8;
#endif
          howto = & fake_arm26_reloc;
        }

#ifdef ARM_WINCE
      /* MS ARM-CE makes the reloc relative to the opcode's pc, not
	 the next opcode's pc, so is off by one.  */
      if (howto->pc_relative && !info->relocatable)
	addend -= 8;
#endif

      /* If we are doing a relocatable link, then we can just ignore
         a PC relative reloc that is pcrel_offset.  It will already
         have the correct value.  If this is not a relocatable link,
         then we should ignore the symbol value.  */
      if (howto->pc_relative && howto->pcrel_offset)
        {
          if (info->relocatable)
            continue;
	  /* FIXME - it is not clear which targets need this next test
	     and which do not.  It is known that it is needed for the
	     VxWorks and EPOC-PE targets, but it is also known that it
	     was suppressed for other ARM targets.  This ought to be
	     sorted out one day.  */
#ifdef ARM_COFF_BUGFIX
	  /* We must not ignore the symbol value.  If the symbol is
	     within the same section, the relocation should have already
	     been fixed, but if it is not, we'll be handed a reloc into
	     the beginning of the symbol's section, so we must not cancel
	     out the symbol's value, otherwise we'll be adding it in
	     twice.  */
          if (sym != NULL && sym->n_scnum != 0)
            addend += sym->n_value;
#endif
        }

      val = 0;

      if (h == NULL)
	{
	  asection *sec;

	  if (symndx == -1)
	    {
	      sec = bfd_abs_section_ptr;
	      val = 0;
	    }
	  else
	    {
	      sec = sections[symndx];
              val = (sec->output_section->vma
		     + sec->output_offset
		     + sym->n_value
		     - sec->vma);
	    }
	}
      else
	{
          /* We don't output the stubs if we are generating a
             relocatable output file, since we may as well leave the
             stub generation to the final linker pass. If we fail to
	     verify that the name is defined, we'll try to build stubs
	     for an undefined name...  */
          if (! info->relocatable
	      && (   h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak))
            {
	      asection *   h_sec = h->root.u.def.section;
	      const char * name  = h->root.root.string;

	      /* h locates the symbol referenced in the reloc.  */
	      h_val = (h->root.u.def.value
		       + h_sec->output_section->vma
		       + h_sec->output_offset);

              if (howto->type == ARM_26)
                {
                  if (   h->symbol_class == C_THUMBSTATFUNC
		      || h->symbol_class == C_THUMBEXTFUNC)
		    {
		      /* Arm code calling a Thumb function.  */
		      unsigned long int                 tmp;
		      bfd_vma                           my_offset;
		      asection *                        s;
		      long int                          ret_offset;
		      struct coff_link_hash_entry *     myh;
		      struct coff_arm_link_hash_table * globals;

		      myh = find_arm_glue (info, name, input_bfd);
		      if (myh == NULL)
			return FALSE;

		      globals = coff_arm_hash_table (info);

		      BFD_ASSERT (globals != NULL);
		      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

		      my_offset = myh->root.u.def.value;

		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
						  ARM2THUMB_GLUE_SECTION_NAME);
		      BFD_ASSERT (s != NULL);
		      BFD_ASSERT (s->contents != NULL);
		      BFD_ASSERT (s->output_section != NULL);

		      if ((my_offset & 0x01) == 0x01)
			{
			  if (h_sec->owner != NULL
			      && INTERWORK_SET (h_sec->owner)
			      && ! INTERWORK_FLAG (h_sec->owner))
			    _bfd_error_handler
			      /* xgettext:c-format */
			      (_("%B(%s): warning: interworking not enabled.\n"
				 "  first occurrence: %B: arm call to thumb"),
			       h_sec->owner, input_bfd, name);

			  --my_offset;
			  myh->root.u.def.value = my_offset;

			  bfd_put_32 (output_bfd, (bfd_vma) a2t1_ldr_insn,
				      s->contents + my_offset);

			  bfd_put_32 (output_bfd, (bfd_vma) a2t2_bx_r12_insn,
				      s->contents + my_offset + 4);

			  /* It's a thumb address.  Add the low order bit.  */
			  bfd_put_32 (output_bfd, h_val | a2t3_func_addr_insn,
				      s->contents + my_offset + 8);

                          if (info->base_file
			      && !arm_emit_base_file_entry (info, output_bfd,
							    s, my_offset + 8))
			    return FALSE;
			}

		      BFD_ASSERT (my_offset <= globals->arm_glue_size);

		      tmp = bfd_get_32 (input_bfd, contents + rel->r_vaddr
					- input_section->vma);

		      tmp = tmp & 0xFF000000;

		      /* Somehow these are both 4 too far, so subtract 8.  */
		      ret_offset =
			s->output_offset
			+ my_offset
			+ s->output_section->vma
			- (input_section->output_offset
			   + input_section->output_section->vma
			   + rel->r_vaddr)
			- 8;

		      tmp = tmp | ((ret_offset >> 2) & 0x00FFFFFF);

		      bfd_put_32 (output_bfd, (bfd_vma) tmp,
				  contents + rel->r_vaddr - input_section->vma);
		      done = 1;
		    }
                }

#ifndef ARM_WINCE
	      /* Note: We used to check for ARM_THUMB9 and ARM_THUMB12.  */
              else if (howto->type == ARM_THUMB23)
                {
                  if (   h->symbol_class == C_EXT
		      || h->symbol_class == C_STAT
		      || h->symbol_class == C_LABEL)
		    {
		      /* Thumb code calling an ARM function.  */
		      asection *                         s = 0;
		      bfd_vma                            my_offset;
		      unsigned long int                  tmp;
		      long int                           ret_offset;
		      struct coff_link_hash_entry *      myh;
		      struct coff_arm_link_hash_table *  globals;

		      myh = find_thumb_glue (info, name, input_bfd);
		      if (myh == NULL)
			return FALSE;

		      globals = coff_arm_hash_table (info);

		      BFD_ASSERT (globals != NULL);
		      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

		      my_offset = myh->root.u.def.value;

		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
						   THUMB2ARM_GLUE_SECTION_NAME);

		      BFD_ASSERT (s != NULL);
		      BFD_ASSERT (s->contents != NULL);
		      BFD_ASSERT (s->output_section != NULL);

		      if ((my_offset & 0x01) == 0x01)
			{
			  if (h_sec->owner != NULL
			      && INTERWORK_SET (h_sec->owner)
			      && ! INTERWORK_FLAG (h_sec->owner)
			      && ! globals->support_old_code)
			    _bfd_error_handler
			      /* xgettext:c-format */
			      (_("%B(%s): warning: interworking not enabled.\n"
				 "  first occurrence: %B: thumb call to arm\n"
				 "  consider relinking with --support-old-code enabled"),
			       h_sec->owner, input_bfd, name);

			  -- my_offset;
			  myh->root.u.def.value = my_offset;

			  if (globals->support_old_code)
			    {
			      bfd_put_16 (output_bfd, (bfd_vma) t2a1_push_insn,
					  s->contents + my_offset);

			      bfd_put_16 (output_bfd, (bfd_vma) t2a2_ldr_insn,
					  s->contents + my_offset + 2);

			      bfd_put_16 (output_bfd, (bfd_vma) t2a3_mov_insn,
					  s->contents + my_offset + 4);

			      bfd_put_16 (output_bfd, (bfd_vma) t2a4_bx_insn,
					  s->contents + my_offset + 6);

			      bfd_put_32 (output_bfd, (bfd_vma) t2a5_pop_insn,
					  s->contents + my_offset + 8);

			      bfd_put_32 (output_bfd, (bfd_vma) t2a6_bx_insn,
					  s->contents + my_offset + 12);

			      /* Store the address of the function in the last word of the stub.  */
			      bfd_put_32 (output_bfd, h_val,
					  s->contents + my_offset + 16);

                              if (info->base_file
				  && !arm_emit_base_file_entry (info,
								output_bfd, s,
								my_offset + 16))
				return FALSE;
			    }
			  else
			    {
			      bfd_put_16 (output_bfd, (bfd_vma) t2a1_bx_pc_insn,
					  s->contents + my_offset);

			      bfd_put_16 (output_bfd, (bfd_vma) t2a2_noop_insn,
					  s->contents + my_offset + 2);

			      ret_offset =
		/* Address of destination of the stub.  */
				((bfd_signed_vma) h_val)
				- ((bfd_signed_vma)
		/* Offset from the start of the current section to the start of the stubs.  */
				   (s->output_offset
		/* Offset of the start of this stub from the start of the stubs.  */
				    + my_offset
		/* Address of the start of the current section.  */
				    + s->output_section->vma)
		/* The branch instruction is 4 bytes into the stub.  */
				   + 4
		/* ARM branches work from the pc of the instruction + 8.  */
				   + 8);

			      bfd_put_32 (output_bfd,
					  (bfd_vma) t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
					  s->contents + my_offset + 4);

			    }
			}

		      BFD_ASSERT (my_offset <= globals->thumb_glue_size);

		      /* Now go back and fix up the original BL insn to point
			 to here.  */
		      ret_offset =
			s->output_offset
			+ my_offset
			- (input_section->output_offset
			   + rel->r_vaddr)
			-4;

		      tmp = bfd_get_32 (input_bfd, contents + rel->r_vaddr
					- input_section->vma);

		      bfd_put_32 (output_bfd,
				  (bfd_vma) insert_thumb_branch (tmp,
								 ret_offset),
				  contents + rel->r_vaddr - input_section->vma);

		      done = 1;
                    }
                }
#endif
            }

          /* If the relocation type and destination symbol does not
             fall into one of the above categories, then we can just
             perform a direct link.  */

	  if (done)
	    rstat = bfd_reloc_ok;
	  else
	    if (   h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak)
	    {
	      asection *sec;

	      sec = h->root.u.def.section;
	      val = (h->root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	      }

	  else if (! info->relocatable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
	    }
	}

      /* Emit a reloc if the backend thinks it needs it.  */
      if (info->base_file
	  && sym
	  && pe_data(output_bfd)->in_reloc_p(output_bfd, howto)
	  && !arm_emit_base_file_entry (info, output_bfd, input_section,
					rel->r_vaddr))
	return FALSE;

      if (done)
	rstat = bfd_reloc_ok;
#ifndef ARM_WINCE
      /* Only perform this fix during the final link, not a relocatable link.  */
      else if (! info->relocatable
	       && howto->type == ARM_THUMB23)
        {
          /* This is pretty much a copy of what the default
             _bfd_final_link_relocate and _bfd_relocate_contents
             routines do to perform a relocation, with special
             processing for the split addressing of the Thumb BL
             instruction.  Again, it would probably be simpler adding a
             ThumbBRANCH23 specific macro expansion into the default
             code.  */

          bfd_vma address = rel->r_vaddr - input_section->vma;

	  if (address > high_address)
	    rstat = bfd_reloc_outofrange;
          else
            {
              bfd_vma relocation = val + addend;
	      int size = bfd_get_reloc_size (howto);
	      bfd_boolean overflow = FALSE;
	      bfd_byte *location = contents + address;
	      bfd_vma x = bfd_get_32 (input_bfd, location);
	      bfd_vma src_mask = 0x007FFFFE;
	      bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	      bfd_signed_vma reloc_signed_min = ~reloc_signed_max;
	      bfd_vma check;
	      bfd_signed_vma signed_check;
	      bfd_vma add;
	      bfd_signed_vma signed_add;

	      BFD_ASSERT (size == 4);

              /* howto->pc_relative should be TRUE for type 14 BRANCH23.  */
              relocation -= (input_section->output_section->vma
                             + input_section->output_offset);

              /* howto->pcrel_offset should be TRUE for type 14 BRANCH23.  */
              relocation -= address;

	      /* No need to negate the relocation with BRANCH23.  */
	      /* howto->complain_on_overflow == complain_overflow_signed for BRANCH23.  */
	      /* howto->rightshift == 1 */

	      /* Drop unwanted bits from the value we are relocating to.  */
	      check = relocation >> howto->rightshift;

	      /* If this is a signed value, the rightshift just dropped
		 leading 1 bits (assuming twos complement).  */
	      if ((bfd_signed_vma) relocation >= 0)
		signed_check = check;
	      else
		signed_check = (check
				| ((bfd_vma) - 1
				   & ~((bfd_vma) - 1 >> howto->rightshift)));

	      /* Get the value from the object file.  */
	      if (bfd_big_endian (input_bfd))
		add = (((x) & 0x07ff0000) >> 4) | (((x) & 0x7ff) << 1);
	      else
		add = ((((x) & 0x7ff) << 12) | (((x) & 0x07ff0000) >> 15));

	      /* Get the value from the object file with an appropriate sign.
		 The expression involving howto->src_mask isolates the upper
		 bit of src_mask.  If that bit is set in the value we are
		 adding, it is negative, and we subtract out that number times
		 two.  If src_mask includes the highest possible bit, then we
		 can not get the upper bit, but that does not matter since
		 signed_add needs no adjustment to become negative in that
		 case.  */
	      signed_add = add;

	      if ((add & (((~ src_mask) >> 1) & src_mask)) != 0)
		signed_add -= (((~ src_mask) >> 1) & src_mask) << 1;

	      /* howto->bitpos == 0 */
	      /* Add the value from the object file, shifted so that it is a
		 straight number.  */
	      signed_check += signed_add;
	      relocation   += signed_add;

	      BFD_ASSERT (howto->complain_on_overflow == complain_overflow_signed);

	      /* Assumes two's complement.  */
	      if (   signed_check > reloc_signed_max
		  || signed_check < reloc_signed_min)
		overflow = TRUE;

	      /* Put the relocation into the correct bits.
		 For a BLX instruction, make sure that the relocation is rounded up
		 to a word boundary.  This follows the semantics of the instruction
		 which specifies that bit 1 of the target address will come from bit
		 1 of the base address.  */
	      if (bfd_big_endian (input_bfd))
	        {
		  if ((x & 0x1800) == 0x0800 && (relocation & 0x02))
		    relocation += 2;
		  relocation = (((relocation & 0xffe) >> 1)  | ((relocation << 4) & 0x07ff0000));
		}
	      else
	        {
		  if ((x & 0x18000000) == 0x08000000 && (relocation & 0x02))
		    relocation += 2;
		  relocation = (((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff));
		}

	      /* Add the relocation to the correct bits of X.  */
	      x = ((x & ~howto->dst_mask) | relocation);

	      /* Put the relocated value back in the object file.  */
	      bfd_put_32 (input_bfd, x, location);

	      rstat = overflow ? bfd_reloc_overflow : bfd_reloc_ok;
            }
        }
#endif
      else
        if (info->relocatable && ! howto->partial_inplace)
            rstat = bfd_reloc_ok;
        else
	  rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents,
					    rel->r_vaddr - input_section->vma,
					    val, addend);
      /* Only perform this fix during the final link, not a relocatable link.  */
      if (! info->relocatable
	  && (rel->r_type == ARM_32 || rel->r_type == ARM_RVA32))
	{
	  /* Determine if we need to set the bottom bit of a relocated address
	     because the address is the address of a Thumb code symbol.  */
	  int patchit = FALSE;

	  if (h != NULL
	      && (   h->symbol_class == C_THUMBSTATFUNC
		  || h->symbol_class == C_THUMBEXTFUNC))
	    {
	      patchit = TRUE;
	    }
	  else if (sym != NULL
		   && sym->n_scnum > N_UNDEF)
	    {
	      /* No hash entry - use the symbol instead.  */
	      if (   sym->n_sclass == C_THUMBSTATFUNC
		  || sym->n_sclass == C_THUMBEXTFUNC)
		patchit = TRUE;
	    }

	  if (patchit)
	    {
	      bfd_byte * location = contents + rel->r_vaddr - input_section->vma;
	      bfd_vma    x        = bfd_get_32 (input_bfd, location);

	      bfd_put_32 (input_bfd, x | 1, location);
	    }
	}

      switch (rstat)
	{
	default:
	  abort ();
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_outofrange:
	  (*_bfd_error_handler)
	    (_("%B: bad reloc address 0x%lx in section `%A'"),
	     input_bfd, input_section, (unsigned long) rel->r_vaddr);
	  return FALSE;
	case bfd_reloc_overflow:
	  {
	    const char *name;
	    char buf[SYMNMLEN + 1];

	    if (symndx == -1)
	      name = "*ABS*";
	    else if (h != NULL)
	      name = NULL;
	    else
	      {
		name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
		if (name == NULL)
		  return FALSE;
	      }

	    if (! ((*info->callbacks->reloc_overflow)
		   (info, (h ? &h->root : NULL), name, howto->name,
		    (bfd_vma) 0, input_bfd, input_section,
		    rel->r_vaddr - input_section->vma)))
	      return FALSE;
	  }
	}
    }

  return TRUE;
}

#ifndef COFF_IMAGE_WITH_PE

bfd_boolean
bfd_arm_allocate_interworking_sections (struct bfd_link_info * info)
{
  asection *                        s;
  bfd_byte *                        foo;
  struct coff_arm_link_hash_table * globals;

  globals = coff_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->arm_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

      s = bfd_get_section_by_name
	(globals->bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);

      BFD_ASSERT (s != NULL);

      foo = bfd_alloc (globals->bfd_of_glue_owner, globals->arm_glue_size);

      s->size = globals->arm_glue_size;
      s->contents = foo;
    }

  if (globals->thumb_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

      s = bfd_get_section_by_name
	(globals->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

      BFD_ASSERT (s != NULL);

      foo = bfd_alloc (globals->bfd_of_glue_owner, globals->thumb_glue_size);

      s->size = globals->thumb_glue_size;
      s->contents = foo;
    }

  return TRUE;
}

static void
record_arm_to_thumb_glue (struct bfd_link_info *        info,
			  struct coff_link_hash_entry * h)
{
  const char *                      name = h->root.root.string;
  register asection *               s;
  char *                            tmp_name;
  struct coff_link_hash_entry *     myh;
  struct bfd_link_hash_entry *      bh;
  struct coff_arm_link_hash_table * globals;
  bfd_vma val;
  bfd_size_type amt;

  globals = coff_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name
    (globals->bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  amt = strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1;
  tmp_name = bfd_malloc (amt);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);

  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);

  if (myh != NULL)
    {
      free (tmp_name);
      /* We've already seen this guy.  */
      return;
    }

  /* The only trick here is using globals->arm_glue_size as the value. Even
     though the section isn't allocated yet, this is where we will be putting
     it.  */
  bh = NULL;
  val = globals->arm_glue_size + 1;
  bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,
				BSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);

  free (tmp_name);

  globals->arm_glue_size += ARM2THUMB_GLUE_SIZE;

  return;
}

#ifndef ARM_WINCE
static void
record_thumb_to_arm_glue (struct bfd_link_info *        info,
			  struct coff_link_hash_entry * h)
{
  const char *                       name = h->root.root.string;
  asection *                         s;
  char *                             tmp_name;
  struct coff_link_hash_entry *      myh;
  struct bfd_link_hash_entry *       bh;
  struct coff_arm_link_hash_table *  globals;
  bfd_vma val;
  bfd_size_type amt;

  globals = coff_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name
    (globals->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  amt = strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1;
  tmp_name = bfd_malloc (amt);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);

  myh = coff_link_hash_lookup
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);

  if (myh != NULL)
    {
      free (tmp_name);
      /* We've already seen this guy.  */
      return;
    }

  bh = NULL;
  val = globals->thumb_glue_size + 1;
  bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,
				BSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);

  /* If we mark it 'thumb', the disassembler will do a better job.  */
  myh = (struct coff_link_hash_entry *) bh;
  myh->symbol_class = C_THUMBEXTFUNC;

  free (tmp_name);

  /* Allocate another symbol to mark where we switch to arm mode.  */

#define CHANGE_TO_ARM "__%s_change_to_arm"
#define BACK_FROM_ARM "__%s_back_from_arm"

  amt = strlen (name) + strlen (CHANGE_TO_ARM) + 1;
  tmp_name = bfd_malloc (amt);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, globals->support_old_code ? BACK_FROM_ARM : CHANGE_TO_ARM, name);

  bh = NULL;
  val = globals->thumb_glue_size + (globals->support_old_code ? 8 : 4);
  bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,
				BSF_LOCAL, s, val, NULL, TRUE, FALSE, &bh);

  free (tmp_name);

  globals->thumb_glue_size += THUMB2ARM_GLUE_SIZE;

  return;
}
#endif /* not ARM_WINCE */

/* Select a BFD to be used to hold the sections used by the glue code.
   This function is called from the linker scripts in ld/emultempl/
   {armcoff/pe}.em  */

bfd_boolean
bfd_arm_get_bfd_for_interworking (bfd * 		 abfd,
				  struct bfd_link_info * info)
{
  struct coff_arm_link_hash_table * globals;
  flagword   			    flags;
  asection * 			    sec;

  /* If we are only performing a partial link do not bother
     getting a bfd to hold the glue.  */
  if (info->relocatable)
    return TRUE;

  globals = coff_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    return TRUE;

  sec = bfd_get_section_by_name (abfd, ARM2THUMB_GLUE_SECTION_NAME);

  if (sec == NULL)
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_CODE | SEC_READONLY);
      sec = bfd_make_section_with_flags (abfd, ARM2THUMB_GLUE_SECTION_NAME,
					 flags);
      if (sec == NULL
	  || ! bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;
    }

  sec = bfd_get_section_by_name (abfd, THUMB2ARM_GLUE_SECTION_NAME);

  if (sec == NULL)
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_CODE | SEC_READONLY);
      sec = bfd_make_section_with_flags (abfd, THUMB2ARM_GLUE_SECTION_NAME,
					 flags);

      if (sec == NULL
	  || ! bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;
    }

  /* Save the bfd for later use.  */
  globals->bfd_of_glue_owner = abfd;

  return TRUE;
}

bfd_boolean
bfd_arm_process_before_allocation (bfd *                   abfd,
				   struct bfd_link_info *  info,
				   int		           support_old_code)
{
  asection * sec;
  struct coff_arm_link_hash_table * globals;

  /* If we are only performing a partial link do not bother
     to construct any glue.  */
  if (info->relocatable)
    return TRUE;

  /* Here we have a bfd that is to be included on the link.  We have a hook
     to do reloc rummaging, before section sizes are nailed down.  */
  _bfd_coff_get_external_symbols (abfd);

  globals = coff_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  globals->support_old_code = support_old_code;

  /* Rummage around all the relocs and map the glue vectors.  */
  sec = abfd->sections;

  if (sec == NULL)
    return TRUE;

  for (; sec != NULL; sec = sec->next)
    {
      struct internal_reloc * i;
      struct internal_reloc * rel;

      if (sec->reloc_count == 0)
	continue;

      /* Load the relocs.  */
      /* FIXME: there may be a storage leak here.  */
      i = _bfd_coff_read_internal_relocs (abfd, sec, 1, 0, 0, 0);

      BFD_ASSERT (i != 0);

      for (rel = i; rel < i + sec->reloc_count; ++rel)
	{
	  unsigned short                 r_type  = rel->r_type;
	  long                           symndx;
	  struct coff_link_hash_entry *  h;

	  symndx = rel->r_symndx;

	  /* If the relocation is not against a symbol it cannot concern us.  */
	  if (symndx == -1)
	    continue;

	  /* If the index is outside of the range of our table, something has gone wrong.  */
	  if (symndx >= obj_conv_table_size (abfd))
	    {
	      _bfd_error_handler (_("%B: illegal symbol index in reloc: %d"),
				  abfd, symndx);
	      continue;
	    }

	  h = obj_coff_sym_hashes (abfd)[symndx];

	  /* If the relocation is against a static symbol it must be within
	     the current section and so cannot be a cross ARM/Thumb relocation.  */
	  if (h == NULL)
	    continue;

	  switch (r_type)
	    {
	    case ARM_26:
	      /* This one is a call from arm code.  We need to look up
		 the target of the call. If it is a thumb target, we
		 insert glue.  */

	      if (h->symbol_class == C_THUMBEXTFUNC)
		record_arm_to_thumb_glue (info, h);
	      break;

#ifndef ARM_WINCE
	    case ARM_THUMB23:
	      /* This one is a call from thumb code.  We used to look
		 for ARM_THUMB9 and ARM_THUMB12 as well.  We need to look
		 up the target of the call. If it is an arm target, we
		 insert glue.  If the symbol does not exist it will be
		 given a class of C_EXT and so we will generate a stub
		 for it.  This is not really a problem, since the link
		 is doomed anyway.  */

	      switch (h->symbol_class)
		{
		case C_EXT:
		case C_STAT:
		case C_LABEL:
		  record_thumb_to_arm_glue (info, h);
		  break;
		default:
		  ;
		}
	      break;
#endif

	    default:
	      break;
	    }
	}
    }

  return TRUE;
}

#endif /* ! defined (COFF_IMAGE_WITH_PE) */

#define coff_bfd_reloc_type_lookup 		coff_arm_reloc_type_lookup
#define coff_bfd_reloc_name_lookup	coff_arm_reloc_name_lookup
#define coff_relocate_section 			coff_arm_relocate_section
#define coff_bfd_is_local_label_name 		coff_arm_is_local_label_name
#define coff_adjust_symndx			coff_arm_adjust_symndx
#define coff_link_output_has_begun 		coff_arm_link_output_has_begun
#define coff_final_link_postscript		coff_arm_final_link_postscript
#define coff_bfd_merge_private_bfd_data		coff_arm_merge_private_bfd_data
#define coff_bfd_print_private_bfd_data		coff_arm_print_private_bfd_data
#define coff_bfd_set_private_flags              _bfd_coff_arm_set_private_flags
#define coff_bfd_copy_private_bfd_data          coff_arm_copy_private_bfd_data
#define coff_bfd_link_hash_table_create		coff_arm_link_hash_table_create

/* When doing a relocatable link, we want to convert ARM_26 relocs
   into ARM_26D relocs.  */

static bfd_boolean
coff_arm_adjust_symndx (bfd *obfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			bfd *ibfd,
			asection *sec,
			struct internal_reloc *irel,
			bfd_boolean *adjustedp)
{
  if (irel->r_type == ARM_26)
    {
      struct coff_link_hash_entry *h;

      h = obj_coff_sym_hashes (ibfd)[irel->r_symndx];
      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section->output_section == sec->output_section)
	irel->r_type = ARM_26D;
    }
  *adjustedp = FALSE;
  return TRUE;
}

/* Called when merging the private data areas of two BFDs.
   This is important as it allows us to detect if we are
   attempting to merge binaries compiled for different ARM
   targets, eg different CPUs or different APCS's.     */

static bfd_boolean
coff_arm_merge_private_bfd_data (bfd * ibfd, bfd * obfd)
{
  BFD_ASSERT (ibfd != NULL && obfd != NULL);

  if (ibfd == obfd)
    return TRUE;

  /* If the two formats are different we cannot merge anything.
     This is not an error, since it is permissable to change the
     input and output formats.  */
  if (   ibfd->xvec->flavour != bfd_target_coff_flavour
      || obfd->xvec->flavour != bfd_target_coff_flavour)
    return TRUE;

  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;

  /* Verify that the APCS is the same for the two BFDs.  */
  if (APCS_SET (ibfd))
    {
      if (APCS_SET (obfd))
	{
	  /* If the src and dest have different APCS flag bits set, fail.  */
	  if (APCS_26_FLAG (obfd) != APCS_26_FLAG (ibfd))
	    {
	      _bfd_error_handler
		/* xgettext: c-format */
		(_("error: %B is compiled for APCS-%d, whereas %B is compiled for APCS-%d"),
		 ibfd, obfd,
		 APCS_26_FLAG (ibfd) ? 26 : 32,
		 APCS_26_FLAG (obfd) ? 26 : 32
		 );

	      bfd_set_error (bfd_error_wrong_format);
	      return FALSE;
	    }

	  if (APCS_FLOAT_FLAG (obfd) != APCS_FLOAT_FLAG (ibfd))
	    {
	      const char *msg;

	      if (APCS_FLOAT_FLAG (ibfd))
		/* xgettext: c-format */
		msg = _("error: %B passes floats in float registers, whereas %B passes them in integer registers");
	      else
		/* xgettext: c-format */
		msg = _("error: %B passes floats in integer registers, whereas %B passes them in float registers");

	      _bfd_error_handler (msg, ibfd, obfd);

	      bfd_set_error (bfd_error_wrong_format);
	      return FALSE;
	    }

	  if (PIC_FLAG (obfd) != PIC_FLAG (ibfd))
	    {
	      const char * msg;

	      if (PIC_FLAG (ibfd))
		/* xgettext: c-format */
		msg = _("error: %B is compiled as position independent code, whereas target %B is absolute position");
	      else
		/* xgettext: c-format */
		msg = _("error: %B is compiled as absolute position code, whereas target %B is position independent");
	      _bfd_error_handler (msg, ibfd, obfd);

	      bfd_set_error (bfd_error_wrong_format);
	      return FALSE;
	    }
	}
      else
	{
	  SET_APCS_FLAGS (obfd, APCS_26_FLAG (ibfd) | APCS_FLOAT_FLAG (ibfd) | PIC_FLAG (ibfd));

	  /* Set up the arch and fields as well as these are probably wrong.  */
	  bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
	}
    }

  /* Check the interworking support.  */
  if (INTERWORK_SET (ibfd))
    {
      if (INTERWORK_SET (obfd))
	{
	  /* If the src and dest differ in their interworking issue a warning.  */
	  if (INTERWORK_FLAG (obfd) != INTERWORK_FLAG (ibfd))
	    {
	      const char * msg;

	      if (INTERWORK_FLAG (ibfd))
		/* xgettext: c-format */
		msg = _("Warning: %B supports interworking, whereas %B does not");
	      else
		/* xgettext: c-format */
		msg = _("Warning: %B does not support interworking, whereas %B does");

	      _bfd_error_handler (msg, ibfd, obfd);
	    }
	}
      else
	{
	  SET_INTERWORK_FLAG (obfd, INTERWORK_FLAG (ibfd));
	}
    }

  return TRUE;
}

/* Display the flags field.  */

static bfd_boolean
coff_arm_print_private_bfd_data (bfd * abfd, void * ptr)
{
  FILE * file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* xgettext:c-format */
  fprintf (file, _("private flags = %x:"), coff_data (abfd)->flags);

  if (APCS_SET (abfd))
    {
      /* xgettext: APCS is ARM Procedure Call Standard, it should not be translated.  */
      fprintf (file, " [APCS-%d]", APCS_26_FLAG (abfd) ? 26 : 32);

      if (APCS_FLOAT_FLAG (abfd))
	fprintf (file, _(" [floats passed in float registers]"));
      else
	fprintf (file, _(" [floats passed in integer registers]"));

      if (PIC_FLAG (abfd))
	fprintf (file, _(" [position independent]"));
      else
	fprintf (file, _(" [absolute position]"));
    }

  if (! INTERWORK_SET (abfd))
    fprintf (file, _(" [interworking flag not initialised]"));
  else if (INTERWORK_FLAG (abfd))
    fprintf (file, _(" [interworking supported]"));
  else
    fprintf (file, _(" [interworking not supported]"));

  fputc ('\n', file);

  return TRUE;
}

/* Copies the given flags into the coff_tdata.flags field.
   Typically these flags come from the f_flags[] field of
   the COFF filehdr structure, which contains important,
   target specific information.
   Note: Although this function is static, it is explicitly
   called from both coffcode.h and peicode.h.  */

static bfd_boolean
_bfd_coff_arm_set_private_flags (bfd * abfd, flagword flags)
{
  flagword flag;

  BFD_ASSERT (abfd != NULL);

  flag = (flags & F_APCS26) ? F_APCS_26 : 0;

  /* Make sure that the APCS field has not been initialised to the opposite
     value.  */
  if (APCS_SET (abfd)
      && (   (APCS_26_FLAG    (abfd) != flag)
	  || (APCS_FLOAT_FLAG (abfd) != (flags & F_APCS_FLOAT))
	  || (PIC_FLAG        (abfd) != (flags & F_PIC))
	  ))
    return FALSE;

  flag |= (flags & (F_APCS_FLOAT | F_PIC));

  SET_APCS_FLAGS (abfd, flag);

  flag = (flags & F_INTERWORK);

  /* If the BFD has already had its interworking flag set, but it
     is different from the value that we have been asked to set,
     then assume that that merged code will not support interworking
     and set the flag accordingly.  */
  if (INTERWORK_SET (abfd) && (INTERWORK_FLAG (abfd) != flag))
    {
      if (flag)
	/* xgettext: c-format */
	_bfd_error_handler (_("Warning: Not setting interworking flag of %B since it has already been specified as non-interworking"),
			    abfd);
      else
	/* xgettext: c-format */
	_bfd_error_handler (_("Warning: Clearing the interworking flag of %B due to outside request"),
			    abfd);
      flag = 0;
    }

  SET_INTERWORK_FLAG (abfd, flag);

  return TRUE;
}

/* Copy the important parts of the target specific data
   from one instance of a BFD to another.  */

static bfd_boolean
coff_arm_copy_private_bfd_data (bfd * src, bfd * dest)
{
  BFD_ASSERT (src != NULL && dest != NULL);

  if (src == dest)
    return TRUE;

  /* If the destination is not in the same format as the source, do not do
     the copy.  */
  if (src->xvec != dest->xvec)
    return TRUE;

  /* Copy the flags field.  */
  if (APCS_SET (src))
    {
      if (APCS_SET (dest))
	{
	  /* If the src and dest have different APCS flag bits set, fail.  */
	  if (APCS_26_FLAG (dest) != APCS_26_FLAG (src))
	    return FALSE;

	  if (APCS_FLOAT_FLAG (dest) != APCS_FLOAT_FLAG (src))
	    return FALSE;

	  if (PIC_FLAG (dest) != PIC_FLAG (src))
	    return FALSE;
	}
      else
	SET_APCS_FLAGS (dest, APCS_26_FLAG (src) | APCS_FLOAT_FLAG (src)
			| PIC_FLAG (src));
    }

  if (INTERWORK_SET (src))
    {
      if (INTERWORK_SET (dest))
	{
	  /* If the src and dest have different interworking flags then turn
	     off the interworking bit.  */
	  if (INTERWORK_FLAG (dest) != INTERWORK_FLAG (src))
	    {
	      if (INTERWORK_FLAG (dest))
		{
		  /* xgettext:c-format */
		  _bfd_error_handler (("\
Warning: Clearing the interworking flag of %B because non-interworking code in %B has been linked with it"),
				      dest, src);
		}

	      SET_INTERWORK_FLAG (dest, 0);
	    }
	}
      else
	{
	  SET_INTERWORK_FLAG (dest, INTERWORK_FLAG (src));
	}
    }

  return TRUE;
}

/* Note:  the definitions here of LOCAL_LABEL_PREFIX and USER_LABEL_PREIFX
   *must* match the definitions in gcc/config/arm/{coff|semi|aout}.h.  */
#ifndef LOCAL_LABEL_PREFIX
#define LOCAL_LABEL_PREFIX ""
#endif
#ifndef USER_LABEL_PREFIX
#define USER_LABEL_PREFIX "_"
#endif

/* Like _bfd_coff_is_local_label_name, but
   a) test against USER_LABEL_PREFIX, to avoid stripping labels known to be
      non-local.
   b) Allow other prefixes than ".", e.g. an empty prefix would cause all
      labels of the form Lxxx to be stripped.  */

static bfd_boolean
coff_arm_is_local_label_name (bfd *        abfd ATTRIBUTE_UNUSED,
			      const char * name)
{
#ifdef USER_LABEL_PREFIX
  if (USER_LABEL_PREFIX[0] != 0)
    {
      size_t len = strlen (USER_LABEL_PREFIX);

      if (strncmp (name, USER_LABEL_PREFIX, len) == 0)
	return FALSE;
    }
#endif

#ifdef LOCAL_LABEL_PREFIX
  /* If there is a prefix for local labels then look for this.
     If the prefix exists, but it is empty, then ignore the test.  */

  if (LOCAL_LABEL_PREFIX[0] != 0)
    {
      size_t len = strlen (LOCAL_LABEL_PREFIX);

      if (strncmp (name, LOCAL_LABEL_PREFIX, len) != 0)
	return FALSE;

      /* Perform the checks below for the rest of the name.  */
      name += len;
    }
#endif

  return name[0] == 'L';
}

/* This piece of machinery exists only to guarantee that the bfd that holds
   the glue section is written last.

   This does depend on bfd_make_section attaching a new section to the
   end of the section list for the bfd.  */

static bfd_boolean
coff_arm_link_output_has_begun (bfd * sub, struct coff_final_link_info * info)
{
  return (sub->output_has_begun
	  || sub == coff_arm_hash_table (info->info)->bfd_of_glue_owner);
}

static bfd_boolean
coff_arm_final_link_postscript (bfd * abfd ATTRIBUTE_UNUSED,
				struct coff_final_link_info * pfinfo)
{
  struct coff_arm_link_hash_table * globals;

  globals = coff_arm_hash_table (pfinfo->info);

  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    {
      if (! _bfd_coff_link_input_bfd (pfinfo, globals->bfd_of_glue_owner))
	return FALSE;

      globals->bfd_of_glue_owner->output_has_begun = TRUE;
    }

  return bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);
}

#ifndef bfd_pe_print_pdata
#define bfd_pe_print_pdata	NULL
#endif

#include "coffcode.h"

#ifndef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM armcoff_little_vec
#endif
#ifndef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME "coff-arm-little"
#endif
#ifndef TARGET_BIG_SYM
#define TARGET_BIG_SYM armcoff_big_vec
#endif
#ifndef TARGET_BIG_NAME
#define TARGET_BIG_NAME "coff-arm-big"
#endif

#ifndef TARGET_UNDERSCORE
#define TARGET_UNDERSCORE 0
#endif

#ifndef EXTRA_S_FLAGS
#ifdef COFF_WITH_PE
#define EXTRA_S_FLAGS (SEC_CODE | SEC_LINK_ONCE | SEC_LINK_DUPLICATES)
#else
#define EXTRA_S_FLAGS SEC_CODE
#endif
#endif

/* Forward declaration for use initialising alternative_target field.  */
extern const bfd_target TARGET_BIG_SYM ;

/* Target vectors.  */
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_LITTLE_SYM, TARGET_LITTLE_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_BIG_SYM, COFF_SWAP_TABLE)
CREATE_BIG_COFF_TARGET_VEC (TARGET_BIG_SYM, TARGET_BIG_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_LITTLE_SYM, COFF_SWAP_TABLE)
@


1.80
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d921 1
a921 1
  ret = bfd_malloc (amt);
a933 4
  ret->thumb_glue_size   = 0;
  ret->arm_glue_size     = 0;
  ret->bfd_of_glue_owner = NULL;

@


1.79
log
@	* aout-arm.c (MY(bfd_reloc_type_lookup)): Use bfd_arch_bits_per_address.
	* aout-ns32k.c (MY(bfd_reloc_type_lookup)): Likewise.
	* aoutx.h (NAME(aout,reloc_type_lookup)): Likewise.
	* coff-arm.c (coff_arm_reloc_type_lookup): Likewise.
	* elf-hppa.h (elf_hppa_reloc_final_type): Likewise.
	* reloc.c (bfd_default_reloc_type_lookup): Likewise.
	* riscix.c (riscix_reloc_type_lookup): Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d602 1
a602 1
  if (symbol->section == &bfd_und_section
d690 1
a690 1
  if (symbol->section == &bfd_und_section
@


1.78
log
@        * coff-arm.c (coff_arm_rtype_to_howto): Fix shadowed variable
        warning.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d820 1
a820 1
    switch (bfd_get_arch_info (abfd)->bits_per_address)
@


1.77
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@a551 1
	  asection *sec;
@


1.76
log
@update copyright dates
@
text
@d1335 2
a1336 2
                  if (   h->class == C_THUMBSTATFUNC
		      || h->class == C_THUMBEXTFUNC)
d1422 3
a1424 3
                  if (   h->class == C_EXT
		      || h->class == C_STAT
		      || h->class == C_LABEL)
d1724 2
a1725 2
	      && (   h->class == C_THUMBSTATFUNC
		  || h->class == C_THUMBEXTFUNC))
d1935 1
a1935 1
  myh->class = C_THUMBEXTFUNC;
d2099 1
a2099 1
	      if (h->class == C_THUMBEXTFUNC)
d2113 1
a2113 1
	      switch (h->class)
@


1.76.2.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d1335 2
a1336 2
                  if (   h->symbol_class == C_THUMBSTATFUNC
		      || h->symbol_class == C_THUMBEXTFUNC)
d1422 3
a1424 3
                  if (   h->symbol_class == C_EXT
		      || h->symbol_class == C_STAT
		      || h->symbol_class == C_LABEL)
d1724 2
a1725 2
	      && (   h->symbol_class == C_THUMBSTATFUNC
		  || h->symbol_class == C_THUMBEXTFUNC))
d1935 1
a1935 1
  myh->symbol_class = C_THUMBEXTFUNC;
d2099 1
a2099 1
	      if (h->symbol_class == C_THUMBEXTFUNC)
d2113 1
a2113 1
	      switch (h->symbol_class)
@


1.75
log
@	* coff-arm.c (coff_arm_merge_private_bfd_data): Use "error:", not
	"ERROR:", in error messages.
	* cpu-arm.c (bfd_arm_merge_machines): Likewise.
	* elf-attrs.c (_bfd_elf_merge_object_attributes): Likewise.
	* elf32-arm.c (tag_cpu_arch_combine): Likewise.
	(elf32_arm_merge_eabi_attributes): Likewise.
	(elf32_arm_merge_private_bfd_data): Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.74
log
@        * pe-arm-wince.c (pe_print_compressed_pdata): Define new function to
        print compressed pdata structure as described on MSDN. This only
        applies to a limited set of architectures (ARM, SH4).
        (slurp_symtab, my_symbol_for_address): Define static helper
        functions for pe_print_compressed_pdata.
        * coffcode.h (bfd_coff_backend_data): Add _bfd_coff_print_pdata field.
        (bfd_coff_have_print_pdata, bfd_coff_print_pdata): Define.
        * bfd/peXXigen.c (_bfd_XX_print_private_bfd_data_common): Add check on
        bfd_coff_backend_data, call the function if non-null.
        * pei-mcore.c: Add target dependent initialisation for
        bfd_coff_backend_data.
        * coff-sh.c: Likewise.
        * coff64-rs6000.c: Likewise.
        * coff-rs6000.c: Likewise.
        * libcoff-in.h: Likewise.
        * cf-i386lynx.c: Likewise.
        * coff-alpha.c: Likewise.
        * coff-apollo.c: Likewise.
        * coff-arm.c: Likewise.
        * coff-aux.c: Likewise.
        * coff-h8300.c: Likewise.
        * coff-h8500.c: Likewise.
        * coff-i386.c: Likewise.
        * coff-i860.c: Likewise.
        * coff-i960.c: Likewise.
        * coff-ia64.c: Likewise.
        * coff-m68k.c: Likewise.
        * coff-m88k.c: Likewise.
        * coff-maxq.c: Likewise.
        * coff-mips.c: Likewise.
        * coff-or32.c: Likewise.
        * coff-sparc.c: Likewise.
        * coff-tic30.c: Likewise.
        * coff-tic4x.c: Likewise.
        * coff-tic54x.c: Likewise.
        * coff-tic80.c: Likewise.
        * coff-w65.c: Likewise.
        * coff-we32k.c: Likewise.
        * coff-x86_64.c: Likewise.
        * coff-z80.c: Likewise.
        * coff-z8k.c: Likewise.
        * pe-mcore.c: Likewise.
        * pe-mips.c: Likewise.
        * pe-ppc.c: Likewise.
        * peXXigen.c: Likewise.
        * pei-ppc.c: Likewise.
        * libcoff.h: Regenerate.
@
text
@d2211 1
a2211 1
		(_("ERROR: %B is compiled for APCS-%d, whereas %B is compiled for APCS-%d"),
d2227 1
a2227 1
		msg = _("ERROR: %B passes floats in float registers, whereas %B passes them in integer registers");
d2230 1
a2230 1
		msg = _("ERROR: %B passes floats in integer registers, whereas %B passes them in float registers");
d2244 1
a2244 1
		msg = _("ERROR: %B is compiled as position independent code, whereas target %B is absolute position");
d2247 1
a2247 1
		msg = _("ERROR: %B is compiled as absolute position code, whereas target %B is position independent");
@


1.73
log
@	* coff-arm.c (arm_emit_base_file_entry): Check fwrite return value.
	Return status.  Adjust callers.
	* coff-mcore.c (mcore_emit_base_file_entry): Likewise.
	* coff-ppc.c (write_base_file_entry): New function.
	(coff_ppc_relocate_section): Use it.
	* elf32-arm.c (find_thumb_glue): Check asprintf return status.
	(find_arm_glue): Likewise.
	* vms-misc.c (_bfd_vms_output_flush): Check fwrite return value.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d2531 4
@


1.72
log
@Switch sources over to use the GPL version 3
@
text
@d942 1
a942 1
static void
d948 4
a951 4
  bfd_vma addr = reloc_offset
                - input_section->vma
                + input_section->output_offset
                  + input_section->output_section->vma;
d955 2
a956 1
  fwrite (& addr, 1, sizeof (addr), (FILE *) info->base_file);
d958 2
d1387 4
a1390 4
                          if (info->base_file)
                            arm_emit_base_file_entry (info, output_bfd, s,
                                                      my_offset + 8);

d1492 5
a1496 3
                              if (info->base_file)
                                arm_emit_base_file_entry (info, output_bfd, s,
							  my_offset + 16);
d1580 7
a1586 7
      if (info->base_file)
	{
	  /* Emit a reloc if the backend thinks it needs it.  */
	  if (sym && pe_data(output_bfd)->in_reloc_p(output_bfd, howto))
            arm_emit_base_file_entry (info, output_bfd, input_section,
				      rel->r_vaddr);
	}
@


1.71
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.70
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.69
log
@ * pe-arm-wince.c (LOCAL_LABEL_PREFIX): Define as ".".
 * pei-arm-wince.c (LOCAL_LABEL_PREFIX): Likewise.
 * coff-arm.c (LOCAL_LABEL_PREFIX): Only define if not defined before.
 * gas/arm/undefined.d: Run test on Windows CE.
 * gas/arm/undefined_coff.d: Don't run test on Windows CE.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006
d856 17
d2132 1
@


1.68
log
@bfd
* Makefile.am: Add rules to build pe-arm-wince.lo and pei-arm-wince.lo objects.
* Makefile.in: Regenerate.
* pe-arm-wince.c: New file.
* pei-arm-wince.c: New file.
* pei-arm.c: Remove ARM_WINCE block.
* pe-arm.c: Remove ARM_WINCE block. Rename
bfd_arm_pe_allocate_interworking_sections,
bfd_arm_pe_get_bfd_for_interworking, and
bfd_arm_pe_process_before_allocation to
bfd_armpe_allocate_interworking_sections,
bfd_armpe_get_bfd_for_interworking, and
bfd_armpe_process_before_allocation. Move them before including bfd.h.
* bfd.c: ARM wince bfd format names were renamed. Adjust.
* coff-arm.c [ARM_WINCE]: Adjust so Windows CE doesn't end up with unexpected/conflicting relocs.
* targets.c: The arm-wince-pe target got its own new vector.  Adjust.
* config.bfd: Likewise.
* configure.in: Likewise.
* configure: Regenerate.

binutils
* configure.in: Split arm-pe and arm-wince-pe. Build dlltool with -DDLLTOOL_ARM_WINCE for Windows CE case.
* configure: Regenerate.
* dlltool.c: Add support for arm-wince.

gas
* Makefile.am (TARG_ENV_HFILES): Add te-wince-pe.h.
* Makefile.in: Regenerate.
* config/tc-arm.h [TARGET_FORMAT]: ARM wince bfd names were  renamed. Adjust.

ld
* Makefile.am: Split arm-wince into its own emulation.
* Makefile.in: Regenerate.
* configure.tgt: Set targ_emul to arm_wince_pe for ARM Windows CE targets.
* pe-dll.c : Define PE_ARCH_arm_wince.
  (pe_detail_list): Add PE_ARCH_arm_wince case.
  (make_one): Handle PE_ARCH_arm_epoc and PE_ARCH_arm_wince cases.
* emulparams/arm_wince_pe.sh: New file.
* emultempl/pe.em: Handle new TARGET_IS_arm_wince_pe define.
  Remap bfd_arm_allocate_interworking_sections, bfd_arm_get_bfd_for_interworking and
  bfd_arm_process_before_allocation for arm-pe and arm-wince-pe targets too.
  (gld_${EMULATION_NAME}_recognized_file): Handle arm-wince and arm-epoc bfd format names.
@
text
@d2427 1
d2429 1
@


1.67
log
@* coff-arm.c (coff_arm_rtype_to_howto): Only check for ARM_SECREL relocation types if the target is ARM_WINCE
@
text
@d166 13
a194 14
#ifdef ARM_WINCE
#undef  ARM_32
#undef  ARM_RVA32
#undef  ARM_26
#undef  ARM_THUMB12
#undef  ARM_26D

#define ARM_26D      0
#define ARM_32       1
#define ARM_RVA32    2
#define ARM_26	     3
#define ARM_THUMB12  4
#define ARM_SECTION  14
#define ARM_SECREL   15
@


1.66
log
@* bfd.c (bfd_get_sign_extend_vma): Add cases for pe-arm-little and pei-arm-little.
* coff-arm.c (coff_arm_rtype_to_howto) [COFF_WITH_PE]: Handle ARM_SECREL.
  (coff_arm_reloc_type_lookup): Map BFD_RELOC_32_SECREL to  ARM_SECREL.
* pe-arm.c [COFF_SECTION_ALIGNMENT_ENTRIES]: Define.
* pei-arm.c [TARGET_UNDERSCORE]: Define for ARM_WINCE like in pe-arm.c.
  [COFF_SECTION_ALIGNMENT_ENTRIES]: Define.

* config/tc-arm.c: Move "dwarf2dbg.h" inclusion out of OBJ_ELF only block.
  (pe_directive_secrel) [TE_PE]: New function.
  (md_pseudo_table) [!OBJ_ELF]: Handle 2byte, 4byte, 8byte, file, loc, loc_mark_labels.
  [TE_PE]: Handle secrel32.
  (output_relax_insn): Remove OBJ_ELF around dwarf2_emit_insn call.
  (output_inst): Remove OBJ_ELF around dwarf2_emit_insn call.
  (arm_frob_label): Remove OBJ_ELF around dwarf2_emit_label call.
  (md_section_align): Only round section sizes here for AOUT targets.
  (tc_arm_regname_to_dw2regnum): Move out for OBJ_ELF only block.
  (tc_pe_dwarf2_emit_offset): New function.
  (md_apply_fix) [TE_PE]: Handle BFD_RELOC_32_SECREL.
  (cons_fix_new_arm): Handle O_secrel.
* config/tc-arm.h : Move DWARF2_LINE_MIN_INSN_LENGTH, DWARF2_DEFAULT_RETURN_COLUMN and DWARF2_CIE_DATA_ALIGNMENT out of OBJ_ELF only block.
  [TE_PE]: Define O_secrel, TC_DWARF2_EMIT_OFFSET, and declare tc_pe_dwarf2_emit_offset.

* ld-pe/pe.exp: Enable tests on arm-wince-pe.
* ld-pe/secrel.d: Adjust test to work on arm-wince-pe too.
@
text
@d542 1
a542 1
#ifdef COFF_WITH_PE
@


1.65
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d542 26
d837 1
@


1.64
log
@Apply fixes to allow arm WinCE toolchain to produce working executables.
@
text
@d1943 4
a1946 4
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY;

      sec = bfd_make_section (abfd, ARM2THUMB_GLUE_SECTION_NAME);

a1947 1
	  || ! bfd_set_section_flags (abfd, sec, flags)
d1956 4
a1959 3
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY;

      sec = bfd_make_section (abfd, THUMB2ARM_GLUE_SECTION_NAME);
a1961 1
	  || ! bfd_set_section_flags (abfd, sec, flags)
@


1.63
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d223 1
a223 1
	   FALSE,
d236 1
a236 1
	   FALSE,
d249 1
a249 1
	   FALSE,
d297 1
a297 1
	   FALSE,
d310 1
a310 1
	   FALSE,
d1212 1
a1212 1
          howto = &fake_arm26_reloc;
d1218 2
@


1.62
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005
d882 4
a885 2
  if (! _bfd_coff_link_hash_table_init
      (& ret->root, abfd, _bfd_coff_link_hash_newfunc))
@


1.61
log
@Update the FSF address in the copyright/GPL notice
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.60
log
@Oops - fix typo in ISO-C90ifcation
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.59
log
@Convert to ISO C90 formatting.
@
text
@a201 2
static bfd_reloc_status_type coff_thumb_pcrel_9
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d205 2
@


1.58
log
@(coff_link_hash_entry): Only define for non WINCE targets.
(t2a1_bx_pc_insn): Likewise.
(t2a2_noop_insn): Likewise.
(t2a3_b_insn): Likewise.
(t2a1_push_insn): Likewise.
(t2a2_ldr_insn): Likewise.
(t2a3_mov_insn): Likewise.
(t2a4_bx_insn): Likewise.
(t2a5_pop_insn): Likewise.
(t2a6_bx_insn): Likewise.
(coff_arm_relocate_section): Only declare the high_address variable for non
WINCE targets.
@
text
@a25 1

a26 1

d76 1
a76 1
/* some typedefs for holding instructions */
a79 65
     /* Forward declarations for stupid compilers.  */
static bfd_boolean coff_arm_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
           struct internal_reloc *, struct internal_syment *, asection **));
static bfd_reloc_status_type aoutarm_fix_pcrel_26_done
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type aoutarm_fix_pcrel_26
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
#ifndef ARM_WINCE
static bfd_reloc_status_type coff_thumb_pcrel_23
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type coff_thumb_pcrel_9
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static insn32 insert_thumb_branch
  PARAMS ((insn32, int));
#endif
static bfd_reloc_status_type coff_thumb_pcrel_12
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type coff_arm_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean coff_arm_adjust_symndx
  PARAMS ((bfd *, struct bfd_link_info *, bfd *,
	   asection *, struct internal_reloc *,	bfd_boolean *));
static reloc_howto_type * coff_arm_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));
static bfd_reloc_status_type coff_thumb_pcrel_common
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **,
	   thumb_pcrel_branchtype));
static const struct reloc_howto_struct * coff_arm_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static struct bfd_link_hash_table * coff_arm_link_hash_table_create
  PARAMS ((bfd *));
#ifndef ARM_WINCE
static struct coff_link_hash_entry * find_thumb_glue
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
#endif
static struct coff_link_hash_entry * find_arm_glue
  PARAMS ((struct bfd_link_info *, const char *, bfd *));
#ifndef COFF_IMAGE_WITH_PE
static void record_arm_to_thumb_glue
  PARAMS ((struct bfd_link_info *, struct coff_link_hash_entry *));
#ifndef ARM_WINCE
static void record_thumb_to_arm_glue
  PARAMS ((struct bfd_link_info *, struct coff_link_hash_entry *));
#endif
#endif
static bfd_boolean coff_arm_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean coff_arm_print_private_bfd_data
  PARAMS ((bfd *, PTR));
static bfd_boolean _bfd_coff_arm_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean coff_arm_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean coff_arm_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean coff_arm_link_output_has_begun
  PARAMS ((bfd *, struct coff_final_link_info *));
static bfd_boolean coff_arm_final_link_postscript
  PARAMS ((bfd *, struct coff_final_link_info *));
static void arm_emit_base_file_entry
  PARAMS ((struct bfd_link_info *, bfd *, asection *, bfd_vma));

d94 7
a100 9
coff_arm_reloc (abfd, reloc_entry, symbol, data, input_section, output_bfd,
		 error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d103 2
a104 1
  if (output_bfd == (bfd *) NULL)
d174 1
a174 1
/* 8 is unused */
d198 13
d315 13
a327 13
    HOWTO (ARM_8,		/* type */
	   0,			/* rightshift */
	   0,			/* size */
	   8,			/* bitsize */
	   FALSE,		/* pc_relative */
	   0,			/* bitpos */
	   complain_overflow_bitfield, /* complain_on_overflow */
	   coff_arm_reloc,	/* special_function */
	   "ARM_8",		/* name */
	   TRUE,		/* partial_inplace */
	   0x000000ff,		/* src_mask */
	   0x000000ff,		/* dst_mask */
	   PCRELOFFSET		/* pcrel_offset */),
a504 1
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
d509 2
a510 3
in_reloc_p (abfd, howto)
     bfd * abfd ATTRIBUTE_UNUSED;
     reloc_howto_type * howto;
d525 6
a530 7
coff_arm_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     struct internal_reloc *rel;
     struct coff_link_hash_entry *h ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     bfd_vma *addendp;
d548 7
a554 9
aoutarm_fix_pcrel_26_done (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     char **error_message ATTRIBUTE_UNUSED;
d563 7
a569 9
aoutarm_fix_pcrel_26 (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d621 8
a628 10
coff_thumb_pcrel_common (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message, btype)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
     thumb_pcrel_branchtype btype;
a639 1

d747 7
a753 9
coff_thumb_pcrel_23 (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d761 7
a767 9
coff_thumb_pcrel_9 (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d776 7
a782 9
coff_thumb_pcrel_12 (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d790 1
a790 3
coff_arm_reloc_type_lookup (abfd, code)
      bfd * abfd;
      bfd_reloc_code_real_type code;
d801 1
a801 1
	return (const struct reloc_howto_struct *) 0;
d826 1
a826 1
    default: return (const struct reloc_howto_struct *) 0;
d830 2
a831 3
#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)
#define COFF_PAGE_SIZE 0x1000
/* Turn a howto into a reloc  nunmber */
d833 1
d835 2
a836 2
#define BADMAG(x) ARMBADMAG(x)
#define ARM 1			/* Customize coffcode.h */
d873 1
a873 2
coff_arm_link_hash_table_create (abfd)
     bfd * abfd;
d878 2
a879 2
  ret = (struct coff_arm_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct coff_arm_link_hash_table *) NULL)
d886 1
a886 1
      return (struct bfd_link_hash_table *) NULL;
d897 4
a900 5
arm_emit_base_file_entry (info, output_bfd, input_section, reloc_offset)
      struct bfd_link_info *info;
      bfd *output_bfd;
      asection *input_section;
      bfd_vma reloc_offset;
d946 1
a946 3
insert_thumb_branch (br_insn, rel_off)
     insn32 br_insn;
     int rel_off;
d951 1
a951 1
  BFD_ASSERT((rel_off & 1) != 1);
d953 3
a955 3
  rel_off >>= 1;                              /* half word aligned address */
  low_bits = rel_off & 0x000007FF;            /* the bottom 11 bits */
  high_bits = (rel_off >> 11) & 0x000007FF;   /* the top 11 bits */
d971 3
a973 4
find_thumb_glue (info, name, input_bfd)
     struct bfd_link_info *info;
     const char *name;
     bfd *input_bfd;
d979 1
a979 1
  tmp_name = (char *) bfd_malloc (amt);
d1000 3
a1002 4
find_arm_glue (info, name, input_bfd)
     struct bfd_link_info *info;
     const char *name;
     bfd *input_bfd;
d1008 1
a1008 1
  tmp_name = (char *) bfd_malloc (amt);
d1117 8
a1124 10
coff_arm_relocate_section (output_bfd, info, input_bfd, input_section,
                           contents, relocs, syms, sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
d1207 1
a1207 1
                    generation of bl's instruction offset. */
d1375 1
a1375 1
		      /* Thumb code calling an ARM function */
d1454 2
a1455 1
				((bfd_signed_vma) h_val)	/* Address of destination of the stub.  */
d1457 10
a1466 5
				   (s->output_offset 		/* Offset from the start of the current section to the start of the stubs.  */
				    + my_offset			/* Offset of the start of this stub from the start of the stubs.  */
				    + s->output_section->vma) 	/* Address of the start of the current section.  */
				   + 4				/* The branch instruction is 4 bytes into the stub.  */
				   + 8);			/* ARM branches work from the pc of the instruction + 8.  */
d1538 1
a1538 1
      /* Only perform this fix during the final link, not a relocatable link.  nickc@@cygnus.com  */
d1662 1
a1662 4
      /* FIXME:
	 Is this the best way to fix up thumb addresses? krk@@cygnus.com
	 Probably not, but it works, and if it works it don't need fixing!  nickc@@cygnus.com */
      /* Only perform this fix during the final link, not a relocatable link.  nickc@@cygnus.com  */
a1667 1

a1679 1

d1736 1
a1736 2
bfd_arm_allocate_interworking_sections (info)
     struct bfd_link_info * info;
d1755 1
a1755 2
      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->arm_glue_size);
d1770 1
a1770 2
      foo = (bfd_byte *) bfd_alloc (globals->bfd_of_glue_owner,
				    globals->thumb_glue_size);
d1780 2
a1781 3
record_arm_to_thumb_glue (info, h)
     struct bfd_link_info *        info;
     struct coff_link_hash_entry * h;
d1803 1
a1803 1
  tmp_name = (char *) bfd_malloc (amt);
d1815 2
a1816 1
      return; /* we've already seen this guy */
a1821 1

d1836 2
a1837 3
record_thumb_to_arm_glue (info, h)
     struct bfd_link_info *        info;
     struct coff_link_hash_entry * h;
d1840 1
a1840 1
  register asection *                s;
d1859 1
a1859 1
  tmp_name = (char *) bfd_malloc (amt);
d1871 2
a1872 1
      return; /* we've already seen this guy */
d1892 1
a1892 1
  tmp_name = (char *) bfd_malloc (amt);
d1916 2
a1917 3
bfd_arm_get_bfd_for_interworking (abfd, info)
     bfd * 		    abfd;
     struct bfd_link_info * info;
d1970 3
a1972 4
bfd_arm_process_before_allocation (abfd, info, support_old_code)
     bfd *                   abfd;
     struct bfd_link_info *  info;
     int		     support_old_code;
a1983 1

a2008 1

d2101 6
a2106 7
coff_arm_adjust_symndx (obfd, info, ibfd, sec, irel, adjustedp)
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *ibfd;
     asection *sec;
     struct internal_reloc *irel;
     bfd_boolean *adjustedp;
d2129 1
a2129 3
coff_arm_merge_private_bfd_data (ibfd, obfd)
     bfd *   ibfd;
     bfd *   obfd;
d2242 1
a2242 3
coff_arm_print_private_bfd_data (abfd, ptr)
     bfd *   abfd;
     PTR     ptr;
d2287 1
a2287 3
_bfd_coff_arm_set_private_flags (abfd, flags)
	bfd *	   abfd;
	flagword   flags;
d2336 1
a2336 3
coff_arm_copy_private_bfd_data (src, dest)
     bfd *  src;
     bfd *  dest;
d2348 1
a2348 1
  /* copy the flags field */
d2408 1
d2410 2
a2411 3
coff_arm_is_local_label_name (abfd, name)
     bfd *        abfd ATTRIBUTE_UNUSED;
     const char * name;
d2446 1
a2446 3
   end of the section list for the bfd.

   krk@@cygnus.com  */
d2449 1
a2449 3
coff_arm_link_output_has_begun (sub, info)
     bfd * sub;
     struct coff_final_link_info * info;
d2456 2
a2457 3
coff_arm_final_link_postscript (abfd, pfinfo)
     bfd * abfd ATTRIBUTE_UNUSED;
     struct coff_final_link_info * pfinfo;
@


1.57
log
@	* coff-arm.c (coff_arm_is_local_label_name): Warning fix.
	* elf32-frv.c (frvfdpic_relocs_info_hash): Likewise.
	* pef.c (bfd_pef_scan): Don't ignore return value of
	bfd_pef_scan_start_address.
@
text
@d116 1
d119 1
d1141 1
d1152 1
d1209 1
d1211 1
@


1.56
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d2507 3
a2509 1
      if (strncmp (name, USER_LABEL_PREFIX, strlen (USER_LABEL_PREFIX)) == 0)
@


1.55
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@a1290 5
#if 0 /* This appears to have been true for WINCE 2.0, but it is not
	 true for WINCE 3.0.  */
      if (howto->pc_relative && !info->relocatable)
	addend -= 8;
#endif
a1339 1
#if 1 /* THUMBEXTENSION */
a1575 1
#endif /* THUMBEXTENSION */
a1603 1
#if 1 /* THUMBEXTENSION */
a1723 1
#endif /* THUMBEXTENSION */
a1730 1
#if 1 /* THUMBEXTENSION */
a1766 1
#endif /* THUMBEXTENSION */
a1815 3
#if 0
  static char                       test_char = '1';
#endif
a1831 3
#if 0
      memset (foo, test_char, (size_t) globals->arm_glue_size);
#endif
a1847 3
#if 0
      memset (foo, test_char, (size_t) globals->thumb_glue_size);
#endif
@


1.54
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d1798 1
a1798 1
	      name = h->root.root.string;
d1807 3
a1809 2
		   (info, name, howto->name, (bfd_vma) 0, input_bfd,
		    input_section, rel->r_vaddr - input_section->vma)))
@


1.53
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d1066 2
a1067 2
    _bfd_error_handler (_("%s: unable to find THUMB glue '%s' for `%s'"),
			bfd_archive_filename (input_bfd), tmp_name, name);
d1096 2
a1097 2
    _bfd_error_handler (_("%s: unable to find ARM glue '%s' for `%s'"),
			bfd_archive_filename (input_bfd), tmp_name, name);
d1398 5
a1402 10
			    {
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("%s(%s): warning: interworking not enabled."),
				 bfd_archive_filename (h_sec->owner), name);
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("  first occurrence: %s: arm call to thumb"),
				 bfd_archive_filename (input_bfd));
			    }
d1488 6
a1493 12
			    {
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("%s(%s): warning: interworking not enabled."),
				 bfd_archive_filename (h_sec->owner), name);
			      _bfd_error_handler
				/* xgettext:c-format */
				(_("  first occurrence: %s: thumb call to arm"),
				 bfd_archive_filename (input_bfd));
			      _bfd_error_handler
				(_("  consider relinking with --support-old-code enabled"));
			    }
d1787 2
a1788 4
	    (_("%s: bad reloc address 0x%lx in section `%s'"),
	     bfd_archive_filename (input_bfd),
	     (unsigned long) rel->r_vaddr,
	     bfd_get_section_name (input_bfd, input_section));
d2129 2
a2130 2
	      _bfd_error_handler (_("%s: illegal symbol index in reloc: %d"),
				  bfd_archive_filename (abfd), symndx);
d2262 4
a2265 3
		(_("ERROR: %s is compiled for APCS-%d, whereas %s is compiled for APCS-%d"),
		 bfd_archive_filename (ibfd), APCS_26_FLAG (ibfd) ? 26 : 32,
		 bfd_get_filename (obfd), APCS_26_FLAG (obfd) ? 26 : 32
d2278 1
a2278 1
		msg = _("ERROR: %s passes floats in float registers, whereas %s passes them in integer registers");
d2281 1
a2281 1
		msg = _("ERROR: %s passes floats in integer registers, whereas %s passes them in float registers");
d2283 1
a2283 2
	      _bfd_error_handler (msg, bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));
d2295 1
a2295 1
		msg = _("ERROR: %s is compiled as position independent code, whereas target %s is absolute position");
d2298 2
a2299 3
		msg = _("ERROR: %s is compiled as absolute position code, whereas target %s is position independent");
	      _bfd_error_handler (msg, bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));
d2326 1
a2326 1
		msg = _("Warning: %s supports interworking, whereas %s does not");
d2329 1
a2329 1
		msg = _("Warning: %s does not support interworking, whereas %s does");
d2331 1
a2331 2
	      _bfd_error_handler (msg, bfd_archive_filename (ibfd),
				  bfd_get_filename (obfd));
d2426 2
a2427 2
	_bfd_error_handler (_("Warning: Not setting interworking flag of %s since it has already been specified as non-interworking"),
			    bfd_archive_filename (abfd));
d2430 2
a2431 2
	_bfd_error_handler (_("Warning: Clearing the interworking flag of %s due to outside request"),
			    bfd_archive_filename (abfd));
d2490 2
a2491 3
Warning: Clearing the interworking flag of %s because non-interworking code in %s has been linked with it"),
				      bfd_get_filename (dest),
				      bfd_archive_filename (src));
@


1.52
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d1205 1
a1638 1
	  bfd_size_type sz;
d1640 1
a1640 4
	  sz = (input_section->rawsize
		? input_section->rawsize
		: input_section->size);
          if (address > sz)
@


1.51
log
@Remainder of fixes for ARM WINCE support
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d1638 1
d1640 4
a1643 1
          if (address > input_section->_raw_size)
d1865 1
a1865 1
      s->_raw_size = s->_cooked_size = globals->arm_glue_size;
d1884 1
a1884 1
      s->_raw_size = s->_cooked_size = globals->thumb_glue_size;
@


1.51.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d1066 2
a1067 2
    _bfd_error_handler (_("%B: unable to find THUMB glue '%s' for `%s'"),
			input_bfd, tmp_name, name);
d1096 2
a1097 2
    _bfd_error_handler (_("%B: unable to find ARM glue '%s' for `%s'"),
			input_bfd, tmp_name, name);
a1204 1
  bfd_vma high_address = bfd_get_section_limit (input_bfd, input_section);
d1397 10
a1406 5
			    _bfd_error_handler
			      /* xgettext:c-format */
			      (_("%B(%s): warning: interworking not enabled.\n"
				 "  first occurrence: %B: arm call to thumb"),
			       h_sec->owner, input_bfd, name);
d1492 12
a1503 6
			    _bfd_error_handler
			      /* xgettext:c-format */
			      (_("%B(%s): warning: interworking not enabled.\n"
				 "  first occurrence: %B: thumb call to arm\n"
				 "  consider relinking with --support-old-code enabled"),
			       h_sec->owner, input_bfd, name);
d1639 1
a1639 1
	  if (address > high_address)
d1797 4
a1800 2
	    (_("%B: bad reloc address 0x%lx in section `%A'"),
	     input_bfd, input_section, (unsigned long) rel->r_vaddr);
d1861 1
a1861 1
      s->size = globals->arm_glue_size;
d1880 1
a1880 1
      s->size = globals->thumb_glue_size;
d2141 2
a2142 2
	      _bfd_error_handler (_("%B: illegal symbol index in reloc: %d"),
				  abfd, symndx);
d2274 3
a2276 4
		(_("ERROR: %B is compiled for APCS-%d, whereas %B is compiled for APCS-%d"),
		 ibfd, obfd,
		 APCS_26_FLAG (ibfd) ? 26 : 32,
		 APCS_26_FLAG (obfd) ? 26 : 32
d2289 1
a2289 1
		msg = _("ERROR: %B passes floats in float registers, whereas %B passes them in integer registers");
d2292 1
a2292 1
		msg = _("ERROR: %B passes floats in integer registers, whereas %B passes them in float registers");
d2294 2
a2295 1
	      _bfd_error_handler (msg, ibfd, obfd);
d2307 1
a2307 1
		msg = _("ERROR: %B is compiled as position independent code, whereas target %B is absolute position");
d2310 3
a2312 2
		msg = _("ERROR: %B is compiled as absolute position code, whereas target %B is position independent");
	      _bfd_error_handler (msg, ibfd, obfd);
d2339 1
a2339 1
		msg = _("Warning: %B supports interworking, whereas %B does not");
d2342 1
a2342 1
		msg = _("Warning: %B does not support interworking, whereas %B does");
d2344 2
a2345 1
	      _bfd_error_handler (msg, ibfd, obfd);
d2440 2
a2441 2
	_bfd_error_handler (_("Warning: Not setting interworking flag of %B since it has already been specified as non-interworking"),
			    abfd);
d2444 2
a2445 2
	_bfd_error_handler (_("Warning: Clearing the interworking flag of %B due to outside request"),
			    abfd);
d2504 3
a2506 2
Warning: Clearing the interworking flag of %B because non-interworking code in %B has been linked with it"),
				      dest, src);
@


1.50
log
@(coff_arm_relocate_section): Do not alter relocs that are not partial_inplace
during a relocatable link.
@
text
@d271 1
a271 1
	   FALSE,
d279 1
a279 1
	   FALSE),
d1253 2
a1254 1
         compensate.  */
d1273 1
a1273 1
    	       FALSE,
d1279 5
@


1.49
log
@Fixes for use of ARM_26D reloc in arm-wince toolchain.
@
text
@d1737 7
a1743 4
        rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
                                          contents,
                                          rel->r_vaddr - input_section->vma,
                                          val, addend);
@


1.48
log
@Change ARM26* to ARM_26* in comments to match definitions.
Replace hard-coded constants with appropriate definitions (ARM_26*).
@
text
@d255 1
a259 1
#define ARM_26D      5
d267 13
a279 1
    EMPTY_HOWTO (-1),
d289 1
a289 1
	   TRUE,
d302 1
a302 1
	   TRUE,
d332 1
a332 13
    HOWTO (ARM_26D,
	   2,
	   2,
	   24,
	   FALSE,
	   0,
	   complain_overflow_dont,
	   aoutarm_fix_pcrel_26_done,
	   "ARM_26D",
	   TRUE,
	   0x00ffffff,
	   0x0,
	   FALSE),
d349 2
a350 2
	   "ARM_16",
	   TRUE,
d362 2
a363 2
	   "ARM_32",
	   TRUE,
@


1.47
log
@	* aix5ppc-core.c: Fix comment typos.
	* aout-arm.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aoutx.h: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd.c: Likewise.
	* bfdio.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-z8k.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* cofflink.c: Likewise.
	* cpu-alpha.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* dwarf2.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d1251 1
a1251 1
         ARM26 to ARM26D relocs if possible.  We return a fake howto in
d2201 2
a2202 2
/* When doing a relocatable link, we want to convert ARM26 relocs
   into ARM26D relocs.  */
d2213 1
a2213 1
  if (irel->r_type == 3)
d2222 1
a2222 1
	irel->r_type = 7;
@


1.46
log
@Include SEC_CODE so that code sections are assigned the LOAD attribute.
@
text
@d924 1
a924 1
    /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
d927 1
a927 1
    /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
d930 1
a930 1
    /* An arbitary input BFD chosen to hold the glue sections.  */
d994 1
a994 1
   11 bits to invest. The upper 11 bits are stored in one (identifed by
d1302 1
a1302 1
	     was supressed for other ARM targets.  This ought to be
d2231 1
a2231 1
   targets, eg different CPUs or differents APCS's.     */
d2364 1
a2364 1
      /* xgettext: APCS is ARM Prodecure Call Standard, it should not be translated.  */
@


1.45
log
@Correct spelling of "relocatable".
@
text
@d2616 1
a2616 1
#define EXTRA_S_FLAGS (SEC_LINK_ONCE | SEC_LINK_DUPLICATES)
d2618 1
a2618 1
#define EXTRA_S_FLAGS 0
@


1.44
log
@Altered the CREATE_xxx_COFF_TARGET_VEC macro arguments
@
text
@d3 1
a3 1
   2000, 2001, 2002
d1250 1
a1250 1
         when doing a relocateable link.  However, we want to convert
d1256 1
a1256 1
          && info->relocateable
d1286 1
a1286 1
      if (howto->pc_relative && !info->relocateable)
d1291 1
a1291 1
      /* If we are doing a relocateable link, then we can just ignore
d1293 1
a1293 1
         have the correct value.  If this is not a relocateable link,
d1297 1
a1297 1
          if (info->relocateable)
d1344 1
a1344 1
          if (! info->relocateable
d1598 1
a1598 1
	  else if (! info->relocateable)
d1620 1
a1620 1
      else if (! info->relocateable
d1746 1
a1746 1
      if (! info->relocateable
d2026 1
a2026 1
  if (info->relocateable)
d2081 1
a2081 1
  if (info->relocateable)
d2201 1
a2201 1
/* When doing a relocateable link, we want to convert ARM26 relocs
@


1.43
log
@Fixes for iWMMXt contribution.
@
text
@d2626 2
a2627 2
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_LITTLE_SYM, TARGET_LITTLE_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_BIG_SYM)
CREATE_BIG_COFF_TARGET_VEC (TARGET_BIG_SYM, TARGET_BIG_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_LITTLE_SYM)
@


1.42
log
@Add iWMMXt support
@
text
@a2242 19
  if (bfd_get_mach (obfd) && bfd_get_mach (obfd) != bfd_get_mach (ibfd))
    {
      /* For now, allow an output file type of 'xscale' if the
	 input file type is 'iWMMXt'.  This means that we will
	 not have to build an entire iWMMXt enabled set of libraries
	 just to test a iWMMXt enabled binary.  Change the output
	 type to iWMMXt though.  Similarly allow 'xscale' binaries
         to be linked into a 'iWMMXt' output binary.  */
      if (   bfd_get_mach (obfd) == bfd_mach_arm_XScale
	  && bfd_get_mach (ibfd) == bfd_mach_arm_iWMMXt)
	bfd_set_arch_mach (obfd, bfd_get_arch (obfd), bfd_mach_arm_iWMMXt);
      else if (   bfd_get_mach (ibfd) != bfd_mach_arm_XScale
	       || bfd_get_mach (obfd) != bfd_mach_arm_iWMMXt)
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return FALSE;
	}
    }

d2250 6
a2255 1
  /* Verify that the APCS is the same for the two BFDs */
d2592 1
a2592 39
  {
    asection * arm_arch_section;

    /* Look for a .note section.  If one is present check
       the machine number encoded in it, and set it to the current
       machine number if it is different.  This allows XScale and
       iWMMXt binaries to be merged and the resulting output to be set
       to iWMMXt, even if the first input file had an XScale .note.  */

    arm_arch_section = bfd_get_section_by_name (abfd, ".note");

    if (arm_arch_section != NULL)
      {
	char buffer [4];

	if (bfd_get_section_contents (abfd, arm_arch_section, buffer,
					(file_ptr) 0, sizeof buffer))
	  {
	    unsigned long arm_mach;

	    /* We have to extract the value this way to allow for a
	       host whose endian-ness is different from the target.  */
	    arm_mach = bfd_get_32 (abfd, buffer);
  
	    if (arm_mach != bfd_get_mach (abfd))
	      {
		bfd_put_32 (abfd, bfd_get_mach (abfd), buffer);

		if (! bfd_set_section_contents (abfd, arm_arch_section, buffer,
						(file_ptr) 0, sizeof buffer))
		  (*_bfd_error_handler)
		    (_("warning: unable to update contents of .note section in %s"),
		     bfd_get_filename (abfd));
	      }
	  }
      }
  }

  return TRUE;
@


1.41
log
@Disable WINCE workaround that subtracted 8 from pc relative relocations.
@
text
@d2243 19
d2605 38
@


1.40
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1284 2
d1288 1
@


1.39
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d83 1
a83 1
static boolean coff_arm_relocate_section
d102 1
a102 1
static boolean coff_arm_adjust_symndx
d104 1
a104 1
	   asection *, struct internal_reloc *,	boolean *));
d128 1
a128 1
static boolean coff_arm_merge_private_bfd_data
d130 1
a130 1
static boolean coff_arm_print_private_bfd_data
d132 1
a132 1
static boolean _bfd_coff_arm_set_private_flags
d134 1
a134 1
static boolean coff_arm_copy_private_bfd_data
d136 1
a136 1
static boolean coff_arm_is_local_label_name
d138 1
a138 1
static boolean coff_arm_link_output_has_begun
d140 1
a140 1
static boolean coff_arm_final_link_postscript
d227 1
a227 1
#define PCRELOFFSET true
d272 1
a272 1
	   false,
d277 1
a277 1
	   true,
d285 1
a285 1
	   false,
d290 1
a290 1
	   true,
d298 1
a298 1
	   true,
d303 1
a303 1
	   false,
d311 1
a311 1
	   true,
d316 1
a316 1
	   false,
d324 1
a324 1
	   false,
d329 1
a329 1
	   true,
d332 1
a332 1
	   false),
d345 1
a345 1
	   false,
d350 1
a350 1
	   true,
d358 1
a358 1
	   false,
d363 1
a363 1
	   true,
d368 1
a368 1
    HOWTO (ARM_8,			/* type */
d372 1
a372 1
	   false,			/* pc_relative */
d375 1
a375 1
	   coff_arm_reloc,		/* special_function */
d377 1
a377 1
	   true,			/* partial_inplace */
d385 1
a385 1
	   false,
d390 1
a390 1
	   true,
d398 1
a398 1
	   false,
d403 1
a403 1
	   true,
d411 1
a411 1
	   true,
d416 1
a416 1
	   false,
d424 1
a424 1
	   true,
d429 1
a429 1
	   true,
d432 1
a432 1
	   true),
d437 1
a437 1
	   true,
d442 1
a442 1
	   true,
d445 1
a445 1
	   true),
d450 1
a450 1
	   true,
d455 1
a455 1
	   true,
d458 1
a458 1
	   true),
d463 1
a463 1
	   false,
d468 1
a468 1
	   true,
d471 1
a471 1
	   false),
d478 1
a478 1
	   false,
d483 1
a483 1
	   true,
d486 1
a486 1
	   false),
d491 1
a491 1
	   false,
d496 1
a496 1
	   true,
d499 1
a499 1
	   false),
d504 1
a504 1
	   false,
d509 1
a509 1
	   true,
d517 1
a517 1
	   true,
d522 1
a522 1
	   false,
d530 1
a530 1
	   true,
d535 1
a535 1
	   false,
d543 1
a543 1
	   true,
d548 1
a548 1
	   false,
d558 2
a559 2
static boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
/* Return true if this relocation should
d562 1
a562 1
static boolean
d1062 1
a1062 1
    (coff_hash_table (info), tmp_name, false, false, true);
d1092 1
a1092 1
    (coff_hash_table (info), tmp_name, false, false, true);
d1191 1
a1191 1
static boolean
d1247 1
a1247 1
	return false;
d1267 1
a1267 1
    	       true,
d1272 1
a1272 1
    	       false,
d1275 1
a1275 1
    	       false);
d1368 1
a1368 1
			return false;
d1461 1
a1461 1
			return false;
d1599 2
a1600 2
		      rel->r_vaddr - input_section->vma, true)))
		return false;
d1634 12
a1645 12
              bfd_vma         relocation       = val + addend;
	      int             size             = bfd_get_reloc_size (howto);
	      boolean         overflow         = false;
	      bfd_byte *      location         = contents + address;
	      bfd_vma         x                = bfd_get_32 (input_bfd, location);
	      bfd_vma         src_mask         = 0x007FFFFE;
	      bfd_signed_vma  reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	      bfd_signed_vma  reloc_signed_min = ~reloc_signed_max;
	      bfd_vma         check;
	      bfd_signed_vma  signed_check;
	      bfd_vma         add;
	      bfd_signed_vma  signed_add;
d1702 1
a1702 1
		overflow = true;
d1749 1
a1749 1
	  int patchit = false;
d1755 1
a1755 1
	      patchit = true;
d1764 1
a1764 1
		patchit = true;
d1789 1
a1789 1
	  return false;
d1803 1
a1803 1
		  return false;
d1809 1
a1809 1
	      return false;
d1814 1
a1814 1
  return true;
d1819 1
a1819 1
boolean
d1872 1
a1872 1
  return true;
d1907 1
a1907 1
    (coff_hash_table (info), tmp_name, false, false, true);
d1922 1
a1922 1
				BSF_GLOBAL, s, val, NULL, true, false, &bh);
d1964 1
a1964 1
    (coff_hash_table (info), tmp_name, false, false, true);
d1975 1
a1975 1
				BSF_GLOBAL, s, val, NULL, true, false, &bh);
d1998 1
a1998 1
				BSF_LOCAL, s, val, NULL, true, false, &bh);
d2012 1
a2012 1
boolean
d2024 1
a2024 1
    return true;
d2031 1
a2031 1
    return true;
d2044 1
a2044 1
	return false;
d2058 1
a2058 1
	return false;
d2064 1
a2064 1
  return true;
d2067 1
a2067 1
boolean
d2079 1
a2079 1
    return true;
d2097 1
a2097 1
    return true;
d2181 1
a2181 1
  return true;
d2201 1
a2201 1
static boolean
d2208 1
a2208 1
     boolean *adjustedp;
d2221 2
a2222 2
  *adjustedp = false;
  return true;
d2230 1
a2230 1
static boolean
d2238 1
a2238 1
    return true;
d2245 1
a2245 1
    return true;
d2263 1
a2263 1
	      return false;
d2281 1
a2281 1
	      return false;
d2298 1
a2298 1
	      return false;
d2337 1
a2337 1
  return true;
d2342 1
a2342 1
static boolean
d2379 1
a2379 1
  return true;
d2389 1
a2389 1
static boolean
d2407 1
a2407 1
    return false;
d2434 1
a2434 1
  return true;
d2440 1
a2440 1
static boolean
d2448 1
a2448 1
    return true;
d2453 1
a2453 1
    return true;
d2462 1
a2462 1
	    return false;
d2465 1
a2465 1
	    return false;
d2468 1
a2468 1
	    return false;
d2501 1
a2501 1
  return true;
d2516 1
a2516 1
static boolean
d2525 1
a2525 1
	return false;
d2538 1
a2538 1
	return false;
d2556 1
a2556 1
static boolean
d2565 1
a2565 1
static boolean
d2579 1
a2579 1
	return false;
d2581 1
a2581 1
      globals->bfd_of_glue_owner->output_has_begun = true;
d2584 1
a2584 1
  return true;
@


1.38
log
@For the Thumb BLX reloc round the relocation up rather than down.
@
text
@d1884 1
d1919 1
d1922 1
a1922 2
				BSF_GLOBAL, s, val, NULL, true, false,
				(struct bfd_link_hash_entry **) & myh);
d1941 1
d1972 1
d1975 1
a1975 2
				BSF_GLOBAL, s, val, NULL, true, false,
				(struct bfd_link_hash_entry **) &myh);
d1978 1
d1995 1
a1995 1
  myh = NULL;
d1998 1
a1998 2
				BSF_LOCAL, s, val, NULL, true, false,
				(struct bfd_link_hash_entry **) & myh);
@


1.38.2.1
log
@merge from mainline
@
text
@a1883 1
  struct bfd_link_hash_entry *      bh;
a1917 1
  bh = NULL;
d1920 2
a1921 1
				BSF_GLOBAL, s, val, NULL, true, false, &bh);
a1939 1
  struct bfd_link_hash_entry *       bh;
a1969 1
  bh = NULL;
d1972 2
a1973 1
				BSF_GLOBAL, s, val, NULL, true, false, &bh);
a1975 1
  myh = (struct coff_link_hash_entry *) bh;
d1992 1
a1992 1
  bh = NULL;
d1995 2
a1996 1
				BSF_LOCAL, s, val, NULL, true, false, &bh);
@


1.38.16.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a1883 1
  struct bfd_link_hash_entry *      bh;
a1917 1
  bh = NULL;
d1920 2
a1921 1
				BSF_GLOBAL, s, val, NULL, true, false, &bh);
a1939 1
  struct bfd_link_hash_entry *       bh;
a1969 1
  bh = NULL;
d1972 2
a1973 1
				BSF_GLOBAL, s, val, NULL, true, false, &bh);
a1975 1
  myh = (struct coff_link_hash_entry *) bh;
d1992 1
a1992 1
  bh = NULL;
d1995 2
a1996 1
				BSF_LOCAL, s, val, NULL, true, false, &bh);
@


1.38.16.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d83 1
a83 1
static bfd_boolean coff_arm_relocate_section
d102 1
a102 1
static bfd_boolean coff_arm_adjust_symndx
d104 1
a104 1
	   asection *, struct internal_reloc *,	bfd_boolean *));
d128 1
a128 1
static bfd_boolean coff_arm_merge_private_bfd_data
d130 1
a130 1
static bfd_boolean coff_arm_print_private_bfd_data
d132 1
a132 1
static bfd_boolean _bfd_coff_arm_set_private_flags
d134 1
a134 1
static bfd_boolean coff_arm_copy_private_bfd_data
d136 1
a136 1
static bfd_boolean coff_arm_is_local_label_name
d138 1
a138 1
static bfd_boolean coff_arm_link_output_has_begun
d140 1
a140 1
static bfd_boolean coff_arm_final_link_postscript
d227 1
a227 1
#define PCRELOFFSET TRUE
a254 1
#define ARM_26D      0
d259 1
d267 1
a267 13
    HOWTO (ARM_26D,
	   2,
	   2,
	   24,
	   FALSE,
	   0,
	   complain_overflow_dont,
	   aoutarm_fix_pcrel_26_done,
	   "ARM_26D",
	   FALSE,
	   0x00ffffff,
	   0x0,
	   FALSE),
d272 1
a272 1
	   FALSE,
d277 1
a277 1
	   FALSE,
d285 1
a285 1
	   FALSE,
d290 1
a290 1
	   FALSE,
d298 1
a298 1
	   TRUE,
d303 1
a303 1
	   FALSE,
d311 1
a311 1
	   TRUE,
d316 1
a316 1
	   FALSE,
d320 13
a332 1
    EMPTY_HOWTO (-1),
d345 1
a345 1
	   FALSE,
d349 2
a350 2
	   "ARM_SECTION",
	   FALSE,
d358 1
a358 1
	   FALSE,
d362 2
a363 2
	   "ARM_SECREL",
	   FALSE,
d368 1
a368 1
    HOWTO (ARM_8,		/* type */
d372 1
a372 1
	   FALSE,		/* pc_relative */
d375 1
a375 1
	   coff_arm_reloc,	/* special_function */
d377 1
a377 1
	   TRUE,		/* partial_inplace */
d385 1
a385 1
	   FALSE,
d390 1
a390 1
	   TRUE,
d398 1
a398 1
	   FALSE,
d403 1
a403 1
	   TRUE,
d411 1
a411 1
	   TRUE,
d416 1
a416 1
	   FALSE,
d424 1
a424 1
	   TRUE,
d429 1
a429 1
	   TRUE,
d432 1
a432 1
	   TRUE),
d437 1
a437 1
	   TRUE,
d442 1
a442 1
	   TRUE,
d445 1
a445 1
	   TRUE),
d450 1
a450 1
	   TRUE,
d455 1
a455 1
	   TRUE,
d458 1
a458 1
	   TRUE),
d463 1
a463 1
	   FALSE,
d468 1
a468 1
	   TRUE,
d471 1
a471 1
	   FALSE),
d478 1
a478 1
	   FALSE,
d483 1
a483 1
	   TRUE,
d486 1
a486 1
	   FALSE),
d491 1
a491 1
	   FALSE,
d496 1
a496 1
	   TRUE,
d499 1
a499 1
	   FALSE),
d504 1
a504 1
	   FALSE,
d509 1
a509 1
	   TRUE,
d517 1
a517 1
	   TRUE,
d522 1
a522 1
	   FALSE,
d530 1
a530 1
	   TRUE,
d535 1
a535 1
	   FALSE,
d543 1
a543 1
	   TRUE,
d548 1
a548 1
	   FALSE,
d558 2
a559 2
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
/* Return TRUE if this relocation should
d562 1
a562 1
static bfd_boolean
d924 1
a924 1
    /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
d927 1
a927 1
    /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
d930 1
a930 1
    /* An arbitrary input BFD chosen to hold the glue sections.  */
d994 1
a994 1
   11 bits to invest. The upper 11 bits are stored in one (identified by
d1062 1
a1062 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
d1092 1
a1092 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
d1191 1
a1191 1
static bfd_boolean
d1247 1
a1247 1
	return FALSE;
d1250 2
a1251 2
         when doing a relocatable link.  However, we want to convert
         ARM_26 to ARM_26D relocs if possible.  We return a fake howto in
d1256 1
a1256 1
          && info->relocatable
d1267 1
a1267 1
    	       TRUE,
d1272 1
a1272 1
    	       FALSE,
d1275 1
a1275 1
    	       FALSE);
d1284 1
a1284 3
#if 0 /* This appears to have been true for WINCE 2.0, but it is not
	 true for WINCE 3.0.  */
      if (howto->pc_relative && !info->relocatable)
a1286 1
#endif
d1288 1
a1288 1
      /* If we are doing a relocatable link, then we can just ignore
d1290 1
a1290 1
         have the correct value.  If this is not a relocatable link,
d1294 1
a1294 1
          if (info->relocatable)
d1299 1
a1299 1
	     was suppressed for other ARM targets.  This ought to be
d1341 1
a1341 1
          if (! info->relocatable
d1368 1
a1368 1
			return FALSE;
d1461 1
a1461 1
			return FALSE;
d1595 1
a1595 1
	  else if (! info->relocatable)
d1599 2
a1600 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d1617 1
a1617 1
      else if (! info->relocatable
d1634 12
a1645 12
              bfd_vma relocation = val + addend;
	      int size = bfd_get_reloc_size (howto);
	      bfd_boolean overflow = FALSE;
	      bfd_byte *location = contents + address;
	      bfd_vma x = bfd_get_32 (input_bfd, location);
	      bfd_vma src_mask = 0x007FFFFE;
	      bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	      bfd_signed_vma reloc_signed_min = ~reloc_signed_max;
	      bfd_vma check;
	      bfd_signed_vma signed_check;
	      bfd_vma add;
	      bfd_signed_vma signed_add;
d1702 1
a1702 1
		overflow = TRUE;
d1743 1
a1743 1
      if (! info->relocatable
d1749 1
a1749 1
	  int patchit = FALSE;
d1755 1
a1755 1
	      patchit = TRUE;
d1764 1
a1764 1
		patchit = TRUE;
d1789 1
a1789 1
	  return FALSE;
d1803 1
a1803 1
		  return FALSE;
d1809 1
a1809 1
	      return FALSE;
d1814 1
a1814 1
  return TRUE;
d1819 1
a1819 1
bfd_boolean
d1872 1
a1872 1
  return TRUE;
d1907 1
a1907 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
d1922 1
a1922 1
				BSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);
d1964 1
a1964 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
d1975 1
a1975 1
				BSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);
d1998 1
a1998 1
				BSF_LOCAL, s, val, NULL, TRUE, FALSE, &bh);
d2012 1
a2012 1
bfd_boolean
d2023 2
a2024 2
  if (info->relocatable)
    return TRUE;
d2031 1
a2031 1
    return TRUE;
d2044 1
a2044 1
	return FALSE;
d2058 1
a2058 1
	return FALSE;
d2064 1
a2064 1
  return TRUE;
d2067 1
a2067 1
bfd_boolean
d2078 2
a2079 2
  if (info->relocatable)
    return TRUE;
d2097 1
a2097 1
    return TRUE;
d2181 1
a2181 1
  return TRUE;
d2198 2
a2199 2
/* When doing a relocatable link, we want to convert ARM_26 relocs
   into ARM_26D relocs.  */
d2201 1
a2201 1
static bfd_boolean
d2208 1
a2208 1
     bfd_boolean *adjustedp;
d2210 1
a2210 1
  if (irel->r_type == ARM_26)
d2219 1
a2219 1
	irel->r_type = ARM_26D;
d2221 2
a2222 2
  *adjustedp = FALSE;
  return TRUE;
d2228 1
a2228 1
   targets, eg different CPUs or different APCS's.     */
d2230 1
a2230 1
static bfd_boolean
d2238 1
a2238 1
    return TRUE;
d2245 1
a2245 6
    return TRUE;

  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;
d2247 1
a2247 1
  /* Verify that the APCS is the same for the two BFDs.  */
d2263 1
a2263 1
	      return FALSE;
d2281 1
a2281 1
	      return FALSE;
d2298 1
a2298 1
	      return FALSE;
d2337 1
a2337 1
  return TRUE;
d2342 1
a2342 1
static bfd_boolean
d2356 1
a2356 1
      /* xgettext: APCS is ARM Procedure Call Standard, it should not be translated.  */
d2379 1
a2379 1
  return TRUE;
d2389 1
a2389 1
static bfd_boolean
d2407 1
a2407 1
    return FALSE;
d2434 1
a2434 1
  return TRUE;
d2440 1
a2440 1
static bfd_boolean
d2448 1
a2448 1
    return TRUE;
d2453 1
a2453 1
    return TRUE;
d2462 1
a2462 1
	    return FALSE;
d2465 1
a2465 1
	    return FALSE;
d2468 1
a2468 1
	    return FALSE;
d2501 1
a2501 1
  return TRUE;
d2516 1
a2516 1
static bfd_boolean
d2525 1
a2525 1
	return FALSE;
d2538 1
a2538 1
	return FALSE;
d2556 1
a2556 1
static bfd_boolean
d2565 1
a2565 1
static bfd_boolean
d2579 1
a2579 1
	return FALSE;
d2581 1
a2581 1
      globals->bfd_of_glue_owner->output_has_begun = TRUE;
d2584 1
a2584 1
  return bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);
d2608 1
a2608 1
#define EXTRA_S_FLAGS (SEC_CODE | SEC_LINK_ONCE | SEC_LINK_DUPLICATES)
d2610 1
a2610 1
#define EXTRA_S_FLAGS SEC_CODE
d2618 2
a2619 2
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_LITTLE_SYM, TARGET_LITTLE_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_BIG_SYM, COFF_SWAP_TABLE)
CREATE_BIG_COFF_TARGET_VEC (TARGET_BIG_SYM, TARGET_BIG_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_LITTLE_SYM, COFF_SWAP_TABLE)
@


1.38.16.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d271 1
a271 1
	   TRUE,
d279 1
a279 1
	   PCRELOFFSET),
d1253 1
a1253 2
         compensate.  'partial_inplace' is also set, since we want 'done'
         relocations to be reflected in section's data.  */
d1272 1
a1272 1
    	       TRUE,
a1277 5
#ifdef ARM_WINCE
          /* FIXME: I don't know why, but the hack is necessary for correct
                    generation of bl's instruction offset. */
          addend -= 8;
#endif
d1737 4
a1740 7
        if (info->relocatable && ! howto->partial_inplace)
            rstat = bfd_reloc_ok;
        else
	  rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents,
					    rel->r_vaddr - input_section->vma,
					    val, addend);
@


1.38.14.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a1883 1
  struct bfd_link_hash_entry *      bh;
a1917 1
  bh = NULL;
d1920 2
a1921 1
				BSF_GLOBAL, s, val, NULL, true, false, &bh);
a1939 1
  struct bfd_link_hash_entry *       bh;
a1969 1
  bh = NULL;
d1972 2
a1973 1
				BSF_GLOBAL, s, val, NULL, true, false, &bh);
a1975 1
  myh = (struct coff_link_hash_entry *) bh;
d1992 1
a1992 1
  bh = NULL;
d1995 2
a1996 1
				BSF_LOCAL, s, val, NULL, true, false, &bh);
@


1.38.14.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d83 1
a83 1
static bfd_boolean coff_arm_relocate_section
d102 1
a102 1
static bfd_boolean coff_arm_adjust_symndx
d104 1
a104 1
	   asection *, struct internal_reloc *,	bfd_boolean *));
d128 1
a128 1
static bfd_boolean coff_arm_merge_private_bfd_data
d130 1
a130 1
static bfd_boolean coff_arm_print_private_bfd_data
d132 1
a132 1
static bfd_boolean _bfd_coff_arm_set_private_flags
d134 1
a134 1
static bfd_boolean coff_arm_copy_private_bfd_data
d136 1
a136 1
static bfd_boolean coff_arm_is_local_label_name
d138 1
a138 1
static bfd_boolean coff_arm_link_output_has_begun
d140 1
a140 1
static bfd_boolean coff_arm_final_link_postscript
d227 1
a227 1
#define PCRELOFFSET TRUE
d272 1
a272 1
	   FALSE,
d277 1
a277 1
	   TRUE,
d285 1
a285 1
	   FALSE,
d290 1
a290 1
	   TRUE,
d298 1
a298 1
	   TRUE,
d303 1
a303 1
	   FALSE,
d311 1
a311 1
	   TRUE,
d316 1
a316 1
	   FALSE,
d324 1
a324 1
	   FALSE,
d329 1
a329 1
	   TRUE,
d332 1
a332 1
	   FALSE),
d345 1
a345 1
	   FALSE,
d350 1
a350 1
	   TRUE,
d358 1
a358 1
	   FALSE,
d363 1
a363 1
	   TRUE,
d368 1
a368 1
    HOWTO (ARM_8,		/* type */
d372 1
a372 1
	   FALSE,		/* pc_relative */
d375 1
a375 1
	   coff_arm_reloc,	/* special_function */
d377 1
a377 1
	   TRUE,		/* partial_inplace */
d385 1
a385 1
	   FALSE,
d390 1
a390 1
	   TRUE,
d398 1
a398 1
	   FALSE,
d403 1
a403 1
	   TRUE,
d411 1
a411 1
	   TRUE,
d416 1
a416 1
	   FALSE,
d424 1
a424 1
	   TRUE,
d429 1
a429 1
	   TRUE,
d432 1
a432 1
	   TRUE),
d437 1
a437 1
	   TRUE,
d442 1
a442 1
	   TRUE,
d445 1
a445 1
	   TRUE),
d450 1
a450 1
	   TRUE,
d455 1
a455 1
	   TRUE,
d458 1
a458 1
	   TRUE),
d463 1
a463 1
	   FALSE,
d468 1
a468 1
	   TRUE,
d471 1
a471 1
	   FALSE),
d478 1
a478 1
	   FALSE,
d483 1
a483 1
	   TRUE,
d486 1
a486 1
	   FALSE),
d491 1
a491 1
	   FALSE,
d496 1
a496 1
	   TRUE,
d499 1
a499 1
	   FALSE),
d504 1
a504 1
	   FALSE,
d509 1
a509 1
	   TRUE,
d517 1
a517 1
	   TRUE,
d522 1
a522 1
	   FALSE,
d530 1
a530 1
	   TRUE,
d535 1
a535 1
	   FALSE,
d543 1
a543 1
	   TRUE,
d548 1
a548 1
	   FALSE,
d558 2
a559 2
static bfd_boolean in_reloc_p PARAMS ((bfd *, reloc_howto_type *));
/* Return TRUE if this relocation should
d562 1
a562 1
static bfd_boolean
d1062 1
a1062 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
d1092 1
a1092 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
d1191 1
a1191 1
static bfd_boolean
d1247 1
a1247 1
	return FALSE;
d1267 1
a1267 1
    	       TRUE,
d1272 1
a1272 1
    	       FALSE,
d1275 1
a1275 1
    	       FALSE);
a1283 2
#if 0 /* This appears to have been true for WINCE 2.0, but it is not
	 true for WINCE 3.0.  */
a1286 1
#endif
d1368 1
a1368 1
			return FALSE;
d1461 1
a1461 1
			return FALSE;
d1599 2
a1600 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d1634 12
a1645 12
              bfd_vma relocation = val + addend;
	      int size = bfd_get_reloc_size (howto);
	      bfd_boolean overflow = FALSE;
	      bfd_byte *location = contents + address;
	      bfd_vma x = bfd_get_32 (input_bfd, location);
	      bfd_vma src_mask = 0x007FFFFE;
	      bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	      bfd_signed_vma reloc_signed_min = ~reloc_signed_max;
	      bfd_vma check;
	      bfd_signed_vma signed_check;
	      bfd_vma add;
	      bfd_signed_vma signed_add;
d1702 1
a1702 1
		overflow = TRUE;
d1749 1
a1749 1
	  int patchit = FALSE;
d1755 1
a1755 1
	      patchit = TRUE;
d1764 1
a1764 1
		patchit = TRUE;
d1789 1
a1789 1
	  return FALSE;
d1803 1
a1803 1
		  return FALSE;
d1809 1
a1809 1
	      return FALSE;
d1814 1
a1814 1
  return TRUE;
d1819 1
a1819 1
bfd_boolean
d1872 1
a1872 1
  return TRUE;
d1907 1
a1907 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
d1922 1
a1922 1
				BSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);
d1964 1
a1964 1
    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);
d1975 1
a1975 1
				BSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);
d1998 1
a1998 1
				BSF_LOCAL, s, val, NULL, TRUE, FALSE, &bh);
d2012 1
a2012 1
bfd_boolean
d2024 1
a2024 1
    return TRUE;
d2031 1
a2031 1
    return TRUE;
d2044 1
a2044 1
	return FALSE;
d2058 1
a2058 1
	return FALSE;
d2064 1
a2064 1
  return TRUE;
d2067 1
a2067 1
bfd_boolean
d2079 1
a2079 1
    return TRUE;
d2097 1
a2097 1
    return TRUE;
d2181 1
a2181 1
  return TRUE;
d2201 1
a2201 1
static bfd_boolean
d2208 1
a2208 1
     bfd_boolean *adjustedp;
d2221 2
a2222 2
  *adjustedp = FALSE;
  return TRUE;
d2230 1
a2230 1
static bfd_boolean
d2238 1
a2238 1
    return TRUE;
d2245 1
a2245 1
    return TRUE;
d2263 1
a2263 1
	      return FALSE;
d2281 1
a2281 1
	      return FALSE;
d2298 1
a2298 1
	      return FALSE;
d2337 1
a2337 1
  return TRUE;
d2342 1
a2342 1
static bfd_boolean
d2379 1
a2379 1
  return TRUE;
d2389 1
a2389 1
static bfd_boolean
d2407 1
a2407 1
    return FALSE;
d2434 1
a2434 1
  return TRUE;
d2440 1
a2440 1
static bfd_boolean
d2448 1
a2448 1
    return TRUE;
d2453 1
a2453 1
    return TRUE;
d2462 1
a2462 1
	    return FALSE;
d2465 1
a2465 1
	    return FALSE;
d2468 1
a2468 1
	    return FALSE;
d2501 1
a2501 1
  return TRUE;
d2516 1
a2516 1
static bfd_boolean
d2525 1
a2525 1
	return FALSE;
d2538 1
a2538 1
	return FALSE;
d2556 1
a2556 1
static bfd_boolean
d2565 1
a2565 1
static bfd_boolean
d2579 1
a2579 1
	return FALSE;
d2581 1
a2581 1
      globals->bfd_of_glue_owner->output_has_begun = TRUE;
d2584 1
a2584 1
  return TRUE;
@


1.38.14.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d2250 1
a2250 6
  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;

  /* Verify that the APCS is the same for the two BFDs.  */
d2587 1
a2587 1
  return bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);
@


1.38.14.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d1250 1
a1250 1
         when doing a relocatable link.  However, we want to convert
d1256 1
a1256 1
          && info->relocatable
d1286 1
a1286 1
      if (howto->pc_relative && !info->relocatable)
d1291 1
a1291 1
      /* If we are doing a relocatable link, then we can just ignore
d1293 1
a1293 1
         have the correct value.  If this is not a relocatable link,
d1297 1
a1297 1
          if (info->relocatable)
d1344 1
a1344 1
          if (! info->relocatable
d1598 1
a1598 1
	  else if (! info->relocatable)
d1620 1
a1620 1
      else if (! info->relocatable
d1746 1
a1746 1
      if (! info->relocatable
d2026 1
a2026 1
  if (info->relocatable)
d2081 1
a2081 1
  if (info->relocatable)
d2201 1
a2201 1
/* When doing a relocatable link, we want to convert ARM26 relocs
d2626 2
a2627 2
CREATE_LITTLE_COFF_TARGET_VEC (TARGET_LITTLE_SYM, TARGET_LITTLE_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_BIG_SYM, COFF_SWAP_TABLE)
CREATE_BIG_COFF_TARGET_VEC (TARGET_BIG_SYM, TARGET_BIG_NAME, D_PAGED, EXTRA_S_FLAGS, TARGET_UNDERSCORE, & TARGET_LITTLE_SYM, COFF_SWAP_TABLE)
@


1.38.14.5
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d2616 1
a2616 1
#define EXTRA_S_FLAGS (SEC_CODE | SEC_LINK_ONCE | SEC_LINK_DUPLICATES)
d2618 1
a2618 1
#define EXTRA_S_FLAGS SEC_CODE
@


1.38.14.6
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a254 1
#define ARM_26D      0
d259 1
d267 1
a267 13
    HOWTO (ARM_26D,
	   2,
	   2,
	   24,
	   FALSE,
	   0,
	   complain_overflow_dont,
	   aoutarm_fix_pcrel_26_done,
	   "ARM_26D",
	   FALSE,
	   0x00ffffff,
	   0x0,
	   FALSE),
d277 1
a277 1
	   FALSE,
d290 1
a290 1
	   FALSE,
d320 13
a332 1
    EMPTY_HOWTO (-1),
d349 2
a350 2
	   "ARM_SECTION",
	   FALSE,
d362 2
a363 2
	   "ARM_SECREL",
	   FALSE,
d924 1
a924 1
    /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
d927 1
a927 1
    /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
d930 1
a930 1
    /* An arbitrary input BFD chosen to hold the glue sections.  */
d994 1
a994 1
   11 bits to invest. The upper 11 bits are stored in one (identified by
d1251 1
a1251 1
         ARM_26 to ARM_26D relocs if possible.  We return a fake howto in
d1302 1
a1302 1
	     was suppressed for other ARM targets.  This ought to be
d2201 2
a2202 2
/* When doing a relocatable link, we want to convert ARM_26 relocs
   into ARM_26D relocs.  */
d2213 1
a2213 1
  if (irel->r_type == ARM_26)
d2222 1
a2222 1
	irel->r_type = ARM_26D;
d2231 1
a2231 1
   targets, eg different CPUs or different APCS's.     */
d2364 1
a2364 1
      /* xgettext: APCS is ARM Procedure Call Standard, it should not be translated.  */
@


1.38.14.7
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d271 1
a271 1
	   TRUE,
d279 1
a279 1
	   PCRELOFFSET),
d1253 1
a1253 2
         compensate.  'partial_inplace' is also set, since we want 'done'
         relocations to be reflected in section's data.  */
d1272 1
a1272 1
    	       TRUE,
a1277 5
#ifdef ARM_WINCE
          /* FIXME: I don't know why, but the hack is necessary for correct
                    generation of bl's instruction offset. */
          addend -= 8;
#endif
d1737 4
a1740 7
        if (info->relocatable && ! howto->partial_inplace)
            rstat = bfd_reloc_ok;
        else
	  rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
					    contents,
					    rel->r_vaddr - input_section->vma,
					    val, addend);
@


1.38.4.1
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a1883 1
  struct bfd_link_hash_entry *      bh;
a1917 1
  bh = NULL;
d1920 2
a1921 1
				BSF_GLOBAL, s, val, NULL, true, false, &bh);
a1939 1
  struct bfd_link_hash_entry *       bh;
a1969 1
  bh = NULL;
d1972 2
a1973 1
				BSF_GLOBAL, s, val, NULL, true, false, &bh);
a1975 1
  myh = (struct coff_link_hash_entry *) bh;
d1992 1
a1992 1
  bh = NULL;
d1995 2
a1996 1
				BSF_LOCAL, s, val, NULL, true, false, &bh);
@


1.37
log
@Fix problems building arm-wince-pe toolchain.
@
text
@d1704 5
a1708 11
	      /* For the BLX(1) instruction remove bit 0 of the adjusted offset.
		 Bit 0 can only be set if the upper insn is at a half-word boundary,
		 since the destination address, an ARM instruction, must always be
		 on a word boundary.  The semantics of the BLX (1) instruction,
		 however, are that bit 0 in the offset must always be 0, and the
		 corresponding bit 1 in the target address will be set from bit
		 1 of the source address.  */
	      if ((x & 0x18000000) == 0x08000000)
		relocation &= ~0x2;

	      /* Put the relocation into the correct bits.  */
d1710 5
a1714 1
		relocation = (((relocation & 0xffe) >> 1)  | ((relocation << 4) & 0x07ff0000));
d1716 5
a1720 1
		relocation = (((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff));
@


1.37.4.1
log
@merge from trunk
@
text
@d1704 11
a1714 5
	      /* Put the relocation into the correct bits.
		 For a BLX instruction, make sure that the relocation is rounded up
		 to a word boundary.  This follows the semantics of the instruction
		 which specifies that bit 1 of the target address will come from bit
		 1 of the base address.  */
d1716 1
a1716 5
	        {
		  if ((x & 0x1800) == 0x0800 && (relocation & 0x02))
		    relocation += 2;
		  relocation = (((relocation & 0xffe) >> 1)  | ((relocation << 4) & 0x07ff0000));
		}
d1718 1
a1718 5
	        {
		  if ((x & 0x18000000) == 0x08000000 && (relocation & 0x02))
		    relocation += 2;
		  relocation = (((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff));
		}
@


1.36
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d90 1
d93 5
a99 2
static bfd_reloc_status_type coff_thumb_pcrel_9
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
a115 2
static insn32 insert_thumb_branch
  PARAMS ((insn32, int));
d123 1
d127 1
d808 1
d826 1
a826 1
coff_thumb_pcrel_12 (abfd, reloc_entry, symbol, data, input_section,
d838 1
a838 1
				  b12);
d840 1
d843 1
a843 1
coff_thumb_pcrel_9 (abfd, reloc_entry, symbol, data, input_section,
d855 1
a855 1
				  b9);
d909 1
d914 1
d986 1
d1043 1
d1073 1
d1928 1
d2002 1
@


1.35
log
@	* dep-in.sed: Cope with absolute paths.
	* Makefile.am (dep.sed): Subst TOPDIR, and not INCDIR.
	Run "make dep-am".
	* Makefile.in: Regenerate.
	* coff-arm.c: Fix copyright date.
	* cpu-h8300.c: Likewise.
	* cpu-i370.c: Likewise.
	* cpu-s390.c: Likewise.
	* cpu-mips.c: Likewise.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@d942 1
a942 1
  ret = (struct coff_arm_link_hash_table *) bfd_alloc (abfd, amt);
d949 1
a949 1
      bfd_release (abfd, ret);
@


1.34
log
@Copy the r_offset field into and out of the internal reloc strcuture.
@
text
@d3 1
a3 1
   2000, 2001
d904 1
a904 1
    so that identical binaries will compare the same.  */
@


1.33
log
@2002-01-31  Philipp Thomas  <pthomas@@suse.de>

        * coff-arm.c (coff_arm_merge_private_bfd_data): Move ERROR
        to front of message. Unify messages with elf32-arm.h. Use
        commas where neccessary.
        * elf32-arm.h (elf32_arm_merge_private_bfd_data): Use all upcase
        ERROR in messages. Unify messages with coff-arm.c. Correct
        VFP/FPA error message.
        (elf32_arm_print_private_bfd_data): Don't mark APCS-26 and
        APCS-32 for translation.
@
text
@d903 5
@


1.33.2.1
log
@Merge from mainline.
@
text
@d3 1
a3 1
   2000, 2001, 2002
a901 5

/* Make sure that the 'r_offset' field is copied properly
   so that identical binaries will compare the same.  */
#define SWAP_IN_RELOC_OFFSET	H_GET_32
#define SWAP_OUT_RELOC_OFFSET	H_PUT_32
@


1.33.2.2
log
@(SWAP_IN_RELOC_OFFSET, SWAP_OUT_RELOC_OFFSET): Do not define for ARM_WINCE builds.
Fix compile time warning messages when building for wince target.
@
text
@a89 1
#ifndef ARM_WINCE
d92 2
a95 5
static insn32 insert_thumb_branch
  PARAMS ((insn32, int));
#endif
static bfd_reloc_status_type coff_thumb_pcrel_12
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d112 2
a120 1
#ifndef ARM_WINCE
a123 1
#endif
a803 1
#ifndef ARM_WINCE
d821 1
a821 1
coff_thumb_pcrel_9 (abfd, reloc_entry, symbol, data, input_section,
d833 1
a833 1
				  b9);
a834 1
#endif /* not ARM_WINCE */
d837 1
a837 1
coff_thumb_pcrel_12 (abfd, reloc_entry, symbol, data, input_section,
d849 1
a849 1
				  b12);
a902 1
#ifndef ARM_WINCE
a906 1
#endif
a977 1
#ifndef ARM_WINCE
a1033 1

a1062 1
#endif /* not ARM_WINCE */
a1916 1
#ifndef ARM_WINCE
a1989 1
#endif /* not ARM_WINCE */
@


1.32
log
@Unify messages in coff-arm.c and elf32-arm.h.
@
text
@d2235 1
a2235 1
		(_("%s: ERROR: compiled for APCS-%d whereas target %s uses APCS-%d"),
d2250 1
a2250 1
		msg = _("%s: ERROR: passes floats in float registers whereas target %s uses integer registers");
d2253 1
a2253 1
		msg = _("%s: ERROR: passes floats in integer registers whereas target %s uses float registers");
d2268 1
a2268 1
		msg = _("%s: ERROR: compiled as position independent code, whereas target %s is absolute position");
d2271 1
a2271 1
		msg = _("%s: ERROR: compiled as absolute position code, whereas target %s is position independent");
d2300 1
a2300 1
		msg = _("Warning: %s supports interworking, whereas %s does not.");
d2303 1
a2303 1
		msg = _("Warning: %s does not support interworking, whereas %s does.");
@


1.31
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d2300 1
a2300 1
		msg = _("Warning: input file %s supports interworking, whereas %s does not.");
d2303 1
a2303 1
		msg = _("Warning: input file %s does not support interworking, whereas %s does.");
d2401 1
a2401 1
	_bfd_error_handler (_("Warning: Not setting interworking flag of %s, since it has already been specified as non-interworking"),
d2464 2
a2465 1
		  _bfd_error_handler (("Warning: Clearing the interworking bit of %s, because the non-interworking code in %s has been copied into it"),
@


1.30
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1052 1
a1052 1
			bfd_get_filename (input_bfd), tmp_name, name);
d1081 1
a1081 1
			bfd_get_filename (input_bfd), tmp_name, name);
d1376 1
a1376 1
				 bfd_get_filename (h_sec->owner), name);
d1380 1
a1380 1
				 bfd_get_filename (input_bfd));
d1471 1
a1471 1
				 bfd_get_filename (h_sec->owner), name);
d1475 1
a1475 1
				 bfd_get_filename (input_bfd));
d1768 1
a1768 1
	     bfd_get_filename (input_bfd),
d2108 1
a2108 1
				  bfd_get_filename (abfd), symndx);
d2236 1
a2236 1
		 bfd_get_filename (ibfd), APCS_26_FLAG (ibfd) ? 26 : 32,
d2255 1
a2255 1
	      _bfd_error_handler (msg, bfd_get_filename (ibfd),
d2272 1
a2272 1
	      _bfd_error_handler (msg, bfd_get_filename (ibfd),
d2305 1
a2305 1
	      _bfd_error_handler (msg, bfd_get_filename (ibfd),
d2402 1
a2402 1
			    bfd_get_filename (abfd));
d2406 1
a2406 1
			    bfd_get_filename (abfd));
d2466 1
a2466 1
				      bfd_get_filename (src));
@


1.29
log
@Add missing prototypes
@
text
@d39 33
a71 12
#define APCS_26_FLAG(       abfd )	(coff_data (abfd)->flags & F_APCS_26)
#define APCS_FLOAT_FLAG(    abfd )	(coff_data (abfd)->flags & F_APCS_FLOAT)
#define PIC_FLAG(           abfd )	(coff_data (abfd)->flags & F_PIC)
#define APCS_SET(           abfd )	(coff_data (abfd)->flags & F_APCS_SET)
#define SET_APCS_FLAGS(     abfd, flgs)	(coff_data (abfd)->flags = \
					(coff_data (abfd)->flags & ~ (F_APCS_26 | F_APCS_FLOAT | F_PIC)) \
					 | (flgs | F_APCS_SET))
#define INTERWORK_FLAG(     abfd ) 	(coff_data (abfd)->flags & F_INTERWORK)
#define INTERWORK_SET(      abfd ) 	(coff_data (abfd)->flags & F_INTERWORK_SET)
#define SET_INTERWORK_FLAG( abfd, flg )	(coff_data (abfd)->flags = \
					(coff_data (abfd)->flags & ~ F_INTERWORK) \
					 | (flg | F_INTERWORK_SET))
d103 2
a104 1
	   struct coff_link_hash_entry *, struct internal_syment *, bfd_vma *));
d108 1
a108 1
static CONST struct reloc_howto_struct * coff_arm_reloc_type_lookup
d115 1
a115 1
  PARAMS ((struct bfd_link_info *, CONST char *, bfd *));
d117 1
a117 1
  PARAMS ((struct bfd_link_info *, CONST char *, bfd *));
d171 3
a173 2
#define DOIT(x) \
  x = ((x & ~howto->dst_mask) | (((x & howto->src_mask) + diff) & howto->dst_mask))
d194 1
a194 1
	      bfd_put_16 (abfd, x, addr);
d202 1
a202 1
	      bfd_put_32 (abfd, x, addr);
d662 1
a662 1
  else if (relocation & ~0x03ffffff)
d667 1
a667 1
  bfd_put_32 (abfd, target, (bfd_byte *) data + addr);
d783 2
a784 1
       target |= ((relocation & 0xfff) >> 1)  | ((relocation << 4)  & 0x07ff0000);
d786 2
a787 1
       target |= ((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff);
d794 1
a794 1
  bfd_put_32 (abfd, target, (bfd_byte *) data + addr);
d816 2
a817 1
                                  input_section, output_bfd, error_message, b23);
d832 2
a833 1
                                  input_section, output_bfd, error_message, b12);
d848 2
a849 1
                                  input_section, output_bfd, error_message, b9);
d852 1
a852 1
static CONST struct reloc_howto_struct *
d866 1
a866 1
	return (CONST struct reloc_howto_struct *) 0;
d891 1
a891 1
    default: return (CONST struct reloc_howto_struct *) 0;
d912 1
a912 1
    long int 			thumb_glue_size;
d915 1
a915 1
    long int 			arm_glue_size;
d935 1
d937 1
a937 2
  ret = ((struct coff_arm_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct coff_arm_link_hash_table)));
d1023 2
a1024 1
    /* FIXME: the BFD library should never abort - it should return an error status.  */
d1032 3
a1034 3
     struct bfd_link_info * info;
     CONST char *           name;
     bfd *                  input_bfd;
d1036 3
a1038 2
  char *                        tmp_name;
  struct coff_link_hash_entry * myh;
d1040 1
a1040 2
  tmp_name = ((char *)
	 bfd_malloc (strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1));
d1061 3
a1063 3
     struct bfd_link_info * info;
     CONST char *           name;
     bfd *                  input_bfd;
d1065 1
a1065 1
  char *                        tmp_name;
d1067 1
d1069 1
a1069 2
  tmp_name = ((char *)
	      bfd_malloc (strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1));
d1243 2
a1244 1
          && h->root.u.def.section->output_section == input_section->output_section)
d1344 1
a1344 1
		      long int                          my_offset;
d1386 1
a1386 1
			  bfd_put_32 (output_bfd, a2t1_ldr_insn,
d1389 1
a1389 1
			  bfd_put_32 (output_bfd, a2t2_bx_r12_insn,
d1398 1
a1398 1
                                                            my_offset + 8);
d1421 2
a1422 2
		      bfd_put_32 (output_bfd, tmp, contents + rel->r_vaddr
				  - input_section->vma);
d1437 1
a1437 1
		      long int                           my_offset;
d1485 1
a1485 1
			      bfd_put_16 (output_bfd, t2a1_push_insn,
d1488 1
a1488 1
			      bfd_put_16 (output_bfd, t2a2_ldr_insn,
d1491 1
a1491 1
			      bfd_put_16 (output_bfd, t2a3_mov_insn,
d1494 1
a1494 1
			      bfd_put_16 (output_bfd, t2a4_bx_insn,
d1497 1
a1497 1
			      bfd_put_32 (output_bfd, t2a5_pop_insn,
d1500 1
a1500 1
			      bfd_put_32 (output_bfd, t2a6_bx_insn,
d1508 2
a1509 1
                                arm_emit_base_file_entry (info, output_bfd, s, my_offset + 16);
d1513 1
a1513 1
			      bfd_put_16 (output_bfd, t2a1_bx_pc_insn,
d1516 1
a1516 1
			      bfd_put_16 (output_bfd, t2a2_noop_insn,
d1529 1
a1529 1
					  t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
d1550 3
a1552 3
				  insert_thumb_branch (tmp, ret_offset),
				  contents + rel->r_vaddr
				  - input_section->vma);
d1592 2
a1593 1
            arm_emit_base_file_entry (info, output_bfd, input_section, rel->r_vaddr);
d1825 2
a1826 2
      foo = (bfd_byte *) bfd_alloc
	(globals->bfd_of_glue_owner, globals->arm_glue_size);
d1828 1
a1828 1
      memset (foo, test_char, globals->arm_glue_size);
d1844 2
a1845 2
      foo = (bfd_byte *) bfd_alloc
	(globals->bfd_of_glue_owner, globals->thumb_glue_size);
d1847 1
a1847 1
      memset (foo, test_char, globals->thumb_glue_size);
d1867 2
d1880 2
a1881 2
  tmp_name = ((char *)
	      bfd_malloc (strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1));
d1900 1
d1902 1
a1902 3
				BSF_GLOBAL,
				s, globals->arm_glue_size + 1,
				NULL, true, false,
d1922 2
d1935 2
a1936 1
  tmp_name = (char *) bfd_malloc (strlen (name) + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d1951 1
d1953 2
a1954 3
				BSF_GLOBAL, s, globals->thumb_glue_size + 1,
				NULL, true, false,
				(struct bfd_link_hash_entry **) & myh);
d1966 2
a1967 1
  tmp_name = (char *) bfd_malloc (strlen (name) + strlen (CHANGE_TO_ARM) + 1);
d1974 1
a1974 1

d1976 1
a1976 3
				BSF_LOCAL, s, globals->thumb_glue_size
				+ (globals->support_old_code ? 8 : 4),
				NULL, true, false,
d2512 1
a2512 1
      int len = strlen (LOCAL_LABEL_PREFIX);
@


1.28
log
@Replace VXWORKS with ARM_COFF_BUGFIX.
@
text
@d116 2
d122 1
a122 2
   name can be changed. The only requirement is the %s be present.
   */
d131 1
d238 1
a238 2
{
  /* type              rs size bsz  pcrel bitpos ovrf                     sf name     part_inpl readmask  setmask    pcdone */
d240 100
a339 100
  EMPTY_HOWTO (-1),
  HOWTO (ARM_32,
	0,
	2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
  HOWTO (ARM_RVA32,
	0,
	2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_RVA32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
  HOWTO (ARM_26,
	2,
	2,
	24,
	true,
	0,
	complain_overflow_signed,
	aoutarm_fix_pcrel_26 ,
	"ARM_26",
	false,
	0x00ffffff,
	0x00ffffff,
	PCRELOFFSET),
  HOWTO (ARM_THUMB12,
	1,
	1,
	11,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_12 ,
	"ARM_THUMB12",
	false,
	0x000007ff,
	0x000007ff,
	PCRELOFFSET),
  HOWTO (ARM_26D,
	2,
	2,
	24,
	false,
	0,
	complain_overflow_dont,
	aoutarm_fix_pcrel_26_done,
	"ARM_26D",
	true,
	0x00ffffff,
	0x0,
	false),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  HOWTO (ARM_SECTION,
	0,
	1,
	16,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_16",
	true,
	0x0000ffff,
	0x0000ffff,
	PCRELOFFSET),
  HOWTO (ARM_SECREL,
	0,
	2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
d341 184
a524 184
  HOWTO(ARM_8,			/* type */
	0,			/* rightshift */
	0,			/* size */
	8,			/* bitsize */
	false,			/* pc_relative */
	0,			/* bitpos */
	complain_overflow_bitfield, /* complain_on_overflow */
	coff_arm_reloc,		/* special_function */
	"ARM_8",		/* name */
        true,			/* partial_inplace */
	0x000000ff,		/* src_mask */
	0x000000ff,		/* dst_mask */
	PCRELOFFSET		/* pcrel_offset */),
  HOWTO(ARM_16,
	0,
	1,
	16,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_16",
	true,
	0x0000ffff,
	0x0000ffff,
	PCRELOFFSET),
  HOWTO(ARM_32,
	0,
	2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
  HOWTO(ARM_26,
	2,
	2,
	24,
	true,
	0,
	complain_overflow_signed,
	aoutarm_fix_pcrel_26 ,
	"ARM_26",
	false,
	0x00ffffff,
	0x00ffffff,
	PCRELOFFSET),
  HOWTO(ARM_DISP8,
	0,
	0,
	8,
	true,
	0,
	complain_overflow_signed,
	coff_arm_reloc,
	"ARM_DISP8",
	true,
	0x000000ff,
	0x000000ff,
	true),
  HOWTO( ARM_DISP16,
	0,
	1,
	16,
	true,
	0,
	complain_overflow_signed,
	coff_arm_reloc,
	"ARM_DISP16",
	true,
	0x0000ffff,
	0x0000ffff,
	true),
  HOWTO( ARM_DISP32,
	0,
	2,
	32,
	true,
	0,
	complain_overflow_signed,
 	coff_arm_reloc,
	"ARM_DISP32",
	true,
	0xffffffff,
	0xffffffff,
	true),
  HOWTO( ARM_26D,
	2,
	2,
	24,
	false,
	0,
	complain_overflow_dont,
	aoutarm_fix_pcrel_26_done,
	"ARM_26D",
	true,
	0x00ffffff,
	0x0,
	false),
  /* 8 is unused */
  EMPTY_HOWTO (-1),
  HOWTO( ARM_NEG16,
	0,
	-1,
	16,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_NEG16",
        true,
	0x0000ffff,
	0x0000ffff,
	false),
  HOWTO( ARM_NEG32,
	0,
	-2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_NEG32",
        true,
	0xffffffff,
	0xffffffff,
	false),
  HOWTO( ARM_RVA32,
	0,
	2,
	32,
	false,
	0,
	complain_overflow_bitfield,
	coff_arm_reloc,
	"ARM_RVA32",
        true,
	0xffffffff,
	0xffffffff,
	PCRELOFFSET),
  HOWTO( ARM_THUMB9,
	1,
	1,
	8,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_9 ,
	"ARM_THUMB9",
	false,
	0x000000ff,
	0x000000ff,
	PCRELOFFSET),
  HOWTO( ARM_THUMB12,
	1,
	1,
	11,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_12 ,
	"ARM_THUMB12",
	false,
	0x000007ff,
	0x000007ff,
	PCRELOFFSET),
  HOWTO( ARM_THUMB23,
	1,
	2,
	22,
	true,
	0,
	complain_overflow_signed,
	coff_thumb_pcrel_23 ,
	"ARM_THUMB23",
	false,
	0x07ff07ff,
	0x07ff07ff,
	PCRELOFFSET)
d526 1
a526 1
};
d531 1
d573 1
d609 1
a609 1
  /* If this is an undefined symbol, return error */
d621 1
a621 1
  relocation = (relocation ^ 0x02000000) - 0x02000000; /* Sign extend */
d633 1
a633 1
  /* Check for overflow */
d700 1
a700 1
  /* If this is an undefined symbol, return error */
d729 1
a729 1
  relocation = (relocation ^ signbit) - signbit; /* Sign extend */
d741 1
a741 1
  /* Check for overflow */
d775 1
a775 1
  /* TODO: We should possibly have DONE entries for the THUMB PCREL relocations */
d837 2
a838 1
      default: return (CONST struct reloc_howto_struct *) 0;
d879 3
a881 3
{
  /* The original coff_link_hash_table structure.  MUST be first field.  */
  struct coff_link_hash_table	root;
d883 2
a884 2
  /* The size in bytes of the section containg the Thumb-to-ARM glue.  */
  long int 			thumb_glue_size;
d886 2
a887 2
  /* The size in bytes of the section containg the ARM-to-Thumb glue.  */
  long int 			arm_glue_size;
d889 2
a890 2
  /* An arbitary input BFD chosen to hold the glue sections.  */
  bfd *				bfd_of_glue_owner;
d892 2
a893 2
  /* Support interworking with old, non-interworking aware ARM code.  */
  int 				support_old_code;
d939 3
a941 3
  if (coff_data(output_bfd)->pe)
     addr -= pe_data(output_bfd)->pe_opthdr.ImageBase;
  fwrite (&addr, 1, sizeof (addr), (FILE *) info->base_file);
d971 1
a971 1
   reverse.  nickc@@cygnus.com  */
d995 2
a996 3
    abort (); /* error - not a valid branch instruction form */

  /* FIXME: abort is probably not the right call. krk@@cygnus.com */
d1312 1
a1312 1
		      /* Arm code calling a Thumb function */
d1398 1
a1398 1
	      /* Note: We used to check for ARM_THUMB9 and ARM_THUMB12 */
d1489 1
a1489 1
				((bfd_signed_vma) h_val)	/* Address of destination of the stub */
@


1.27
log
@Add support for arm-vxworks target
@
text
@d1249 4
a1252 4
	     VXworks target (hence the #ifdef), but it is also known
	     that it was supressed for other (arm) targets.  This ought
	     to be sorted out one day.  */
#ifdef VXWORKS
@


1.26
log
@Update copyright notices
@
text
@d1247 12
a1258 6
#if 0  /* We must not ignore the symbol value.  If the symbol is
	  within the same section, the relocation should have already
	  been fixed, but if it is not, we'll be handed a reloc into
	  the beginning of the symbol's section, so we must not cancel
	  out the symbol's value, otherwise we'll be adding it in
	  twice.  */
@


1.25
log
@Fix BLX(1) for Thumb
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.24
log
@Add BFD_RELOC_THUMB_PCREL_BLX.
@
text
@d1591 1
a1591 1
              /* howto->pc_relative should be TRUE for type 14 BRANCH23 */
d1595 1
a1595 1
              /* howto->pcrel_offset should be TRUE for type 14 BRANCH23 */
d1601 1
a1602 1

d1616 1
a1616 3
		{
		  add = (((x) & 0x07ff0000) >> 4) | (((x) & 0x7ff) << 1);
		}
d1618 1
a1618 3
		{
		  add = ((((x) & 0x7ff) << 12) | (((x) & 0x07ff0000) >> 15));
		}
a1627 1

d1633 1
a1635 2
	      /* howto->bitpos == 0 */

d1637 1
a1637 1
	      relocation += signed_add;
d1646 9
a1654 1
	      /* Put RELOCATION into the correct bits:  */
d1656 1
d1658 1
a1658 3
		{
		  relocation = (((relocation & 0xffe) >> 1)  | ((relocation << 4) & 0x07ff0000));
		}
d1660 1
a1660 3
		{
		  relocation = (((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff));
		}
d1662 1
a1662 1
	      /* Add RELOCATION to the correct bits of X:  */
d1665 1
a1665 1
	      /* Put the relocated value back in the object file:  */
@


1.23
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d856 1
@


1.23.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
@


1.23.2.2
log
@Import changes from mainline into 2-11 branch
@
text
@a856 1
      ASTD (BFD_RELOC_THUMB_PCREL_BLX,      ARM_THUMB23);
d1246 6
a1251 12
	  /* FIXME - it is not clear which targets need this next test
	     and which do not.  It is known that it is needed for the
	     VXworks target (hence the #ifdef), but it is also known
	     that it was supressed for other (arm) targets.  This ought
	     to be sorted out one day.  */
#ifdef VXWORKS
	  /* We must not ignore the symbol value.  If the symbol is
	     within the same section, the relocation should have already
	     been fixed, but if it is not, we'll be handed a reloc into
	     the beginning of the symbol's section, so we must not cancel
	     out the symbol's value, otherwise we'll be adding it in
	     twice.  */
d1591 1
a1591 1
              /* howto->pc_relative should be TRUE for type 14 BRANCH23.  */
d1595 1
a1595 1
              /* howto->pcrel_offset should be TRUE for type 14 BRANCH23.  */
d1601 1
a1602 1
	      /* Drop unwanted bits from the value we are relocating to.  */
d1616 3
a1618 1
		add = (((x) & 0x07ff0000) >> 4) | (((x) & 0x7ff) << 1);
d1620 3
a1622 1
		add = ((((x) & 0x7ff) << 12) | (((x) & 0x07ff0000) >> 15));
d1632 1
a1637 1
	      /* howto->bitpos == 0 */
d1640 2
d1643 1
a1643 1
	      relocation   += signed_add;
d1652 1
a1652 9
	      /* For the BLX(1) instruction remove bit 0 of the adjusted offset.
		 Bit 0 can only be set if the upper insn is at a half-word boundary,
		 since the destination address, an ARM instruction, must always be
		 on a word boundary.  The semantics of the BLX (1) instruction,
		 however, are that bit 0 in the offset must always be 0, and the
		 corresponding bit 1 in the target address will be set from bit
		 1 of the source address.  */
	      if ((x & 0x18000000) == 0x08000000)
		relocation &= ~0x2;
a1653 1
	      /* Put the relocation into the correct bits.  */
d1655 3
a1657 1
		relocation = (((relocation & 0xffe) >> 1)  | ((relocation << 4) & 0x07ff0000));
d1659 3
a1661 1
		relocation = (((relocation & 0xffe) << 15) | ((relocation >> 12) & 0x7ff));
d1663 1
a1663 1
	      /* Add the relocation to the correct bits of X.  */
d1666 1
a1666 1
	      /* Put the relocated value back in the object file.  */
@


1.22
log
@Change defn of LOCAL_LABEL_PREFIX to ""
@
text
@a994 1

a2551 1

@


1.21
log
@Definbe extra allowable COFF section flags for ARM_PE target/
@
text
@d2438 2
a2439 2
 *must* match the definitions in gcc/config/arm/coff.h and semi.h */
#define LOCAL_LABEL_PREFIX "."
@


1.20
log
@Add ARM v5t, v5te and XScale support
@
text
@d2539 1
d2544 1
@


1.19
log
@2000-11-15  Kazu Hirata  <kazu@@hxi.com>

	* coff-arm.c: Fix formatting.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
@
text
@d848 1
@


1.18
log
@2000-09-08  Kazu Hirata  <kazu@@hxi.com>

	* archive.c: Fix formatting.
	* coff-arm.c: Likewise.
	* doc/chew.c: Likewise.
@
text
@d988 1
a988 1
    abort(); /* error - not a valid branch instruction form */
@


1.17
log
@* coff-arm.c (coff_arm_relocate_section): Do not ignore the symbol
value of PC-relative offsets.
@
text
@d54 1
a54 1
     
a59 1

d79 1
a79 1
static reloc_howto_type * coff_arm_rtype_to_howto 
d121 1
a121 1
   
d128 1
a128 1
/* Used by the assembler. */
d234 1
a234 1
static reloc_howto_type aoutarm_std_reloc_howto[] = 
d239 1
a239 1
  HOWTO (ARM_32, 
d241 1
a241 1
	2, 
d252 1
a252 1
  HOWTO (ARM_RVA32, 
d254 1
a254 1
	2, 
d276 1
a276 1
	0x00ffffff, 
d289 1
a289 1
	0x000007ff, 
d291 2
a292 2
  HOWTO (ARM_26D,  
	2, 
d298 1
a298 1
	aoutarm_fix_pcrel_26_done, 
d312 4
a315 4
  HOWTO (ARM_SECTION,  
	0, 
	1, 
	16, 
d320 1
a320 1
	"ARM_16", 
d323 1
a323 1
	0x0000ffff, 
d325 1
a325 1
  HOWTO (ARM_SECREL, 
d327 1
a327 1
	2, 
d352 4
a355 4
  HOWTO(ARM_16,  
	0, 
	1, 
	16, 
d360 1
a360 1
	"ARM_16", 
d363 1
a363 1
	0x0000ffff, 
d365 1
a365 1
  HOWTO(ARM_32, 
d367 1
a367 1
	2, 
d389 1
a389 1
	0x00ffffff, 
d391 1
a391 1
  HOWTO(ARM_DISP8,        
d394 1
a394 1
	8, 
d397 1
a397 1
	complain_overflow_signed, 
d399 1
a399 1
	"ARM_DISP8",  
d404 1
a404 1
  HOWTO( ARM_DISP16, 
d410 1
a410 1
	complain_overflow_signed, 
d423 1
a423 1
	complain_overflow_signed, 
d430 2
a431 2
  HOWTO( ARM_26D,  
	2, 
d437 1
a437 1
	aoutarm_fix_pcrel_26_done, 
d450 1
a450 1
	0, 
d454 2
a455 1
        true, 
a456 1
	0x0000ffff, 
d458 2
a459 2
  HOWTO( ARM_NEG32, 
	0, 
d471 1
a471 1
  HOWTO( ARM_RVA32, 
d473 1
a473 1
	2, 
d495 1
a495 1
	0x000000ff, 
d508 1
a508 1
	0x000007ff, 
d521 1
a521 1
	0x07ff07ff, 
d530 1
a530 1
   appear in the output .reloc section. */
d538 1
a538 1
}     
d562 1
a562 1
  
d570 1
a570 1
/* Used by the assembler. */
d587 1
a587 1
/* Used by the assembler. */
d604 1
a604 1
  
d625 1
a625 1
  
d695 1
a695 1
  
d770 1
a770 1
  
a819 1

d826 1
a826 1
  
d855 1
a855 1
#endif      
d875 1
a875 1
  
d878 1
a878 1
  
d885 1
a885 1
  /* Support interworking with old, non-interworking aware ARM code. */
d940 1
a940 1
   can occur in any order. So given a thumb form of long branch, and an 
d942 1
a942 1
   instruction. 
d944 1
a944 1
   It takes two thumb instructions to encode the target address. Each has 
d946 2
a947 2
   H-0.. see below), the lower 11 bits are stored in the other (identified 
   by H-1). 
d949 1
a949 1
   Combine together and shifted left by 1 (it's a half word address) and 
d957 1
a957 1
   They can be ordered either way, but the arm tools I've seen always put 
a976 1

d1011 1
a1011 1
  
d1014 1
a1014 1
  
d1019 1
a1019 1
  
d1040 1
a1040 1
  
d1048 1
a1048 1
  
d1085 1
a1085 1
					        .word	func 
d1128 1
a1128 1
/* The standard COFF backend linker does not cope with the special 
d1131 1
a1131 1
   bit simpler simply providing our own relocation driver. */
d1179 1
a1179 1
	{    
a1193 1

d1211 1
a1211 1
          static reloc_howto_type fake_arm26_reloc = 
d1223 1
a1223 1
    	       0x00ffffff, 
d1232 1
a1232 1
	 the next opcode's pc, so is off by one. */
d1236 1
a1236 1
      
d1283 1
a1283 1
	     for an undefined name... */
d1290 1
a1290 1
	      
d1306 1
a1306 1
		      struct coff_link_hash_entry *     myh; 
d1308 1
a1308 1
		      
d1317 1
a1317 1
			
d1319 2
a1320 2
		      
		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner, 
d1347 1
a1347 1
			  
d1350 1
a1350 1
			  
d1356 1
a1356 1
                            arm_emit_base_file_entry (info, output_bfd, s, 
d1365 1
a1365 1
		      
d1368 1
a1368 1
		      /* Somehow these are both 4 too far, so subtract 8. */
d1371 1
a1371 1
			+ my_offset 
d1374 1
a1374 1
			   + input_section->output_section->vma 
d1379 1
a1379 1
		      
d1385 1
a1385 1
	      
d1390 1
a1390 1
                  if (   h->class == C_EXT 
d1407 1
a1407 1
		      
d1410 1
a1410 1
		      
d1412 2
a1413 2
		      
		      s = bfd_get_section_by_name (globals->bfd_of_glue_owner, 
d1415 1
a1415 1
		      
d1419 1
a1419 1
		      
d1438 1
a1438 1
			  
d1446 1
a1446 1
			      
d1455 1
a1455 1
			      
d1458 1
a1458 1
			      
d1461 1
a1461 1
			      
d1473 1
a1473 1
		      
d1476 1
a1476 1
		      
d1485 1
a1485 1
			      
d1503 1
a1503 1
		      
d1511 1
a1511 1
		      
d1517 1
a1517 1
	  
d1520 1
a1520 1
             perform a direct link. */
d1524 1
a1524 1
	  else 
d1548 1
a1548 1
	  /* Emit a reloc if the backend thinks it needs it. */
d1552 1
a1552 1
  
d1568 1
a1568 1
	  
d1570 1
a1570 1
	  
d1589 1
a1589 1
	      
d1593 1
a1593 1
	      
d1596 2
a1597 2
	      
	      /* No need to negate the relocation with BRANCH23. */
d1601 1
a1601 1
	      
d1603 1
a1603 1
		
d1612 1
a1612 1
	      
d1631 1
a1631 1
	      
d1633 1
a1633 1
	      
d1636 1
a1636 1
	      
d1640 1
a1640 1
	      
d1650 1
a1650 1
	      
d1652 1
a1652 1
	      
d1661 1
a1661 1
	      
d1679 1
a1679 1
      /* FIXME: 
d1688 1
a1688 1
	     
d1690 1
a1690 1
	  
d1715 2
a1716 2
#endif /* THUMBEXTENSION */      
      
d1760 1
a1760 1
bfd_arm_allocate_interworking_sections (info) 
d1771 1
a1771 1
  
d1777 1
a1777 1
      
d1782 1
a1782 1
      
d1788 1
a1788 1
      
d1796 1
a1796 1
      
d1801 1
a1801 1
      
d1807 1
a1807 1
      
d1842 1
a1842 1
  
d1845 1
a1845 1
  
d1857 1
a1857 1
				BSF_GLOBAL, 
d1859 1
a1859 1
				NULL, true, false, 
d1861 1
a1861 1
  
d1863 1
a1863 1
  
a1879 1
  
d1881 1
a1881 1
  
d1898 1
a1898 1
  
d1907 1
a1907 1
				NULL, true, false, 
d1909 1
a1909 1
  
d1916 1
a1916 1
      
d1919 1
a1919 1
  
d1921 1
a1921 1
  
d1923 1
a1923 1
  
d1927 1
a1927 1
  
d1931 1
a1931 1
				NULL, true, false, 
d1934 2
a1935 2
  free (tmp_name);  
  
d1953 1
a1953 1
    
d1958 1
a1958 1
  
d1960 1
a1960 1
  
d1965 1
a1965 1
  
d1967 2
a1968 2
  
  if (sec == NULL) 
d1971 1
a1971 1
      
d1973 1
a1973 1
      
d1982 1
a1982 1
  if (sec == NULL) 
d1985 1
a1985 1
      
d1987 1
a1987 1
      
d1993 1
a1993 1
  
d1996 1
a1996 1
  
d2013 1
a2013 1
  
d2020 1
a2020 1
  
d2025 1
a2025 1
  
d2037 1
a2037 1
      if (sec->reloc_count == 0) 
d2041 2
a2042 2
      /* FIXME: there may be a storage leak here. */
      
d2044 1
a2044 1
    
d2047 1
a2047 1
      for (rel = i; rel < i + sec->reloc_count; ++rel) 
d2055 1
a2055 1
	  /* If the relocation is not against a symbol it cannot concern us. */
d2066 1
a2066 1
	  
d2080 1
a2080 1
	      
d2084 1
a2084 1
	      
d2107 1
a2107 1
	      
a2130 1

d2198 1
a2198 1
	  
d2209 1
a2209 1
	      
d2216 1
a2216 1
	  
d2237 1
a2237 1
	  
d2259 1
a2259 1
	      
a2272 1

d2281 1
a2281 1
  
d2283 1
a2283 1
  
d2286 1
a2286 1
  
d2302 1
a2302 1
  
d2309 1
a2309 1
  
d2311 1
a2311 1
  
a2314 1

d2332 1
a2332 1
  
d2343 1
a2343 1
  
d2347 1
a2347 1
  
a2369 1

d2379 1
a2379 1
 
d2396 1
a2396 1
	  
d2399 1
a2399 1
	  
d2423 1
a2423 1
	      
d2463 2
a2464 2
     If the prefix exists, but it is empty, then ignore the test. */
  
d2468 1
a2468 1
      
d2471 1
a2471 1
      
d2476 1
a2476 1
  
d2481 1
a2481 1
   the glue section is written last. 
d2484 1
a2484 1
   end of the section list for the bfd. 
d2505 1
a2505 1
  
d2507 1
a2507 1
  
d2512 1
a2512 1
      
d2515 1
a2515 1
  
@


1.16
log
@Fix building with --enable-targets=all
@
text
@d1249 6
d1257 1
@


1.15
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d2048 1
a2048 1
	  unsigned long                  symndx;
@


1.14
log
@Add WinCE support.
@
text
@d1538 1
a1538 1
		      rel->r_vaddr - input_section->vma)))
@


1.13
log
@catch bad arm relocs
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d202 1
a202 2
   the manifest constants in the code. */

d219 16
d238 102
d523 2
a524 1
	PCRELOFFSET),
d567 1
a567 1
    *addendp -= pe_data(sec->output_section->owner)->pe_opthdr.ImageBase;
d840 6
d857 1
d1234 7
d1383 1
d1512 1
d1553 1
d1668 1
d2057 1
d2083 1
d2104 1
a2519 64

#if 0
#define coff_SWAP_sym_in  arm_bfd_coff_swap_sym_in

static void coff_swap_sym_in PARAMS ((bfd *, PTR, PTR));

/* Sepcial version of symbol swapper, used to grab a bfd
   onto which the glue sections can be attached.  */
static void
arm_bfd_coff_swap_sym_in (abfd, ext1, in1)
     bfd * abfd;
     PTR   ext1;
     PTR   in1;
{
  flagword flags;
  register asection * s;

  /* Do the normal swap in.  */
  coff_swap_sym_in (abfd, ext1, in1);

  if (bfd_of_glue_owner != NULL) /* we already have a toc, so go home */
    return;

  /* Save the bfd for later allocation.  */
  bfd_of_glue_owner = abfd;

  s = bfd_get_section_by_name (bfd_of_glue_owner , 
			       ARM2THUMB_GLUE_SECTION_NAME);

  if (s == NULL) 
    {
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY ;
      
      s = bfd_make_section (bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);

      if (s == NULL
	  || !bfd_set_section_flags (bfd_of_glue_owner, s, flags)
	  || !bfd_set_section_alignment (bfd_of_glue_owner, s, 2))
	{
	  /* FIXME: set appropriate bfd error */
	  abort();
	}
    }

  s = bfd_get_section_by_name (bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

  if (s == NULL) 
    {
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY ;
      
      s = bfd_make_section (bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);
      
      if (s == NULL
	  || !bfd_set_section_flags (bfd_of_glue_owner, s, flags)
	  || !bfd_set_section_alignment (bfd_of_glue_owner, s, 2))
	{
	  /* FIXME: set appropriate bfd error krk@@cygnus.com */
	  abort();
	}
    }
  
  return;
}
#endif
@


1.12
log
@Add SEC_CODE and SEC_READONLY flags to glue sections.
@
text
@d50 4
d409 2
d424 5
a428 3

#define RTYPE2HOWTO(cache_ptr, dst) \
	    (cache_ptr)->howto = aoutarm_std_reloc_howto + (dst)->r_type;
d441 1
a441 1
  reloc_howto_type *howto;
d443 3
d449 1
a449 3
    {
      *addendp -= pe_data(sec->output_section->owner)->pe_opthdr.ImageBase;
    }
a451 1

d709 2
a710 1
#define ASTD(i,j)       case i: return &aoutarm_std_reloc_howto[j]
d1912 1
a1912 1
	  long                           symndx;
d1921 7
@


1.11
log
@Change to strip	out only symbols that start with LOCAL_LABEL_PREFIX followed
by 'L'.
@
text
@d1823 1
a1823 1
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
d1837 1
a1837 1
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
@


1.10
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d2290 5
d2300 8
d2314 3
a2316 8
      if (strncmp (name, LOCAL_LABEL_PREFIX, strlen (LOCAL_LABEL_PREFIX)) == 0)
	return true;
    }
#endif
#ifdef USER_LABEL_PREFIX
  if (USER_LABEL_PREFIX[0] != 0)
    {
      if (strncmp (name, USER_LABEL_PREFIX, strlen (USER_LABEL_PREFIX)) == 0)
d2318 3
d2324 1
a2324 11
  /* devo/gcc/config/dbxcoff.h defines ASM_OUTPUT_SOURCE_LINE to generate
     local line numbers as .LM<number>, so treat these as local.  */
  
  switch (name[0])
    {
    case 'L': return true;
    case '.': return (name[1] == 'L' && name[2] == 'M') ? true : false;
    default:  return false;     /* Cannot make our minds up - default to
				   false so that it will not be stripped
				   by accident.  */ 
    }
@


1.9
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d2431 2
a2432 5
const bfd_target
#ifdef TARGET_LITTLE_SYM
TARGET_LITTLE_SYM =
#else
armcoff_little_vec =
d2434 2
a2435 5
{
#ifdef TARGET_LITTLE_NAME
  TARGET_LITTLE_NAME,
#else
  "coff-arm-little",
d2437 2
a2438 13
  bfd_target_coff_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),

#ifndef COFF_WITH_PE
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
d2440 2
a2441 5

#ifdef TARGET_UNDERSCORE
  TARGET_UNDERSCORE,		/* leading underscore */
#else
  0,				/* leading underscore */
a2442 27
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */

  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */

/* Note that we allow an object file to be treated as a core file as well. */
    {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
       bfd_generic_archive_p, coff_object_p},
    {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
       bfd_false},
    {bfd_false, coff_write_object_contents, /* bfd_write_contents */
       _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (coff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
d2444 2
a2445 8
  (PTR) & bfd_coff_std_swap_table,
};

const bfd_target
#ifdef TARGET_BIG_SYM
TARGET_BIG_SYM =
#else
armcoff_big_vec =
a2446 13
{
#ifdef TARGET_BIG_NAME
  TARGET_BIG_NAME,
#else
  "coff-arm-big",
#endif
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
d2448 2
a2449 2
#ifndef COFF_WITH_PE
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
d2451 1
a2451 2
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
d2454 2
a2455 22
#ifdef TARGET_UNDERSCORE
  TARGET_UNDERSCORE,		/* leading underscore */
#else
  0,				/* leading underscore */
#endif
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen */

  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */

/* Note that we allow an object file to be treated as a core file as well. */
    {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
       bfd_generic_archive_p, coff_object_p},
    {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
       bfd_false},
    {bfd_false, coff_write_object_contents, /* bfd_write_contents */
       _bfd_write_archive_contents, bfd_false},
d2457 3
a2459 9
     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (coff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
a2460 2
  (PTR) & bfd_coff_std_swap_table,
};
@


1.8
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d131 1
a131 1
     asymbol *symbol;
d133 1
a133 1
     asection *input_section;
d135 1
a135 1
     char **error_message;
d324 1
a324 1
  {-1},
d411 1
a411 1
     bfd * abfd;
d426 1
a426 1
     bfd *abfd;
d429 2
a430 2
     struct coff_link_hash_entry *h;
     struct internal_syment *sym;
d450 7
a456 7
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d473 1
a473 1
     char **error_message;
d533 1
a533 1
     char **error_message;
d1980 2
a1981 2
     bfd *obfd;
     struct bfd_link_info *info;
d2292 1
a2292 1
     bfd *        abfd;
d2345 1
a2345 1
     bfd * abfd;
@


1.7
log
@	* coff-arm.c (arm_emit_base_file_entry): Explicitly declare return
	type.
@
text
@d92 1
d97 1
d1609 2
a1610 3
#ifdef COFF_IMAGE_WITH_PE
static
#endif
d1797 1
a1797 3
#ifdef COFF_IMAGE_WITH_PE
static
#endif
a1852 3
#ifdef COFF_IMAGE_WITH_PE
static
#endif
d1959 2
@


1.6
log
@        * coff-arm.c (coff_arm_relocate_section): Don't emit
        base file entries for pc-relative values.
@
text
@d786 1
a786 1
static
@


1.5
log
@        * coff-arm.c (coff_arm_relocate_section):  Account for
        multiple glue sections when generating base file entries.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
a936 2
#define A2T3_OFFSET 8

a959 2
#define T2A3_OFFSET 8

d1211 1
a1211 1
                                                            my_offset + A2T3_OFFSET);
d1318 3
a1342 3
                              if (info->base_file)
                                arm_emit_base_file_entry (info, output_bfd, s,
                                                           my_offset + T2A3_OFFSET);
a1364 3
                      if (info->base_file)
                        arm_emit_base_file_entry (info, output_bfd, input_section, rel->r_vaddr);

@


1.4
log
@Use renamed ARM cpu flag bits
@
text
@d1214 2
a1215 1
                            arm_emit_base_file_entry (info, output_bfd, s, A2T3_OFFSET);
a1239 1
		      
d1345 2
a1346 1
                                arm_emit_base_file_entry (info, output_bfd, s, T2A3_OFFSET);
@


1.3
log
@        * bfd-in.h (bfd_arm_allocate_interworking_sections):  Static
        if COFF_IMAGE_WITH_PE.
        (bfd_arm_process_before_allocation): Likewise.
        (bfd_arm_get_bfd_for_interworking): Likewise.
        * coff-arm.c: Likewise.
        * bfd-in2.h: Regenerate.
        * configure.in (armpe_little_vec): Remove coff-arm.lo.
        (armpe_big_vec): Likewise.
        * configure: Rebuild.
@
text
@d2192 1
a2192 1
	  || (PIC_FLAG        (abfd) != (flags & F_PIC_INT ? F_PIC : 0))
@


1.2
log
@        * coff-arm.c (coff_arm_relocate_section):  Add one to
        address of ARM_RVA32 thumb functions.
@
text
@d1613 3
a1615 1
#ifndef COFF_WITH_PE
d1802 3
d1860 3
a1968 2

#endif /* ! COFF_WITH_PE */
@


1.1
log
@Initial revision
@
text
@d1540 1
a1540 1
	  && rel->r_type == ARM_32)
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

