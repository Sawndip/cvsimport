head	1.29;
access;
symbols
	sid-snapshot-20180601:1.29
	sid-snapshot-20180501:1.29
	sid-snapshot-20180401:1.29
	sid-snapshot-20180301:1.29
	sid-snapshot-20180201:1.29
	sid-snapshot-20180101:1.29
	sid-snapshot-20171201:1.29
	sid-snapshot-20171101:1.29
	sid-snapshot-20171001:1.29
	sid-snapshot-20170901:1.29
	sid-snapshot-20170801:1.29
	sid-snapshot-20170701:1.29
	sid-snapshot-20170601:1.29
	sid-snapshot-20170501:1.29
	sid-snapshot-20170401:1.29
	sid-snapshot-20170301:1.29
	sid-snapshot-20170201:1.29
	sid-snapshot-20170101:1.29
	sid-snapshot-20161201:1.29
	sid-snapshot-20161101:1.29
	sid-snapshot-20160901:1.29
	sid-snapshot-20160801:1.29
	sid-snapshot-20160701:1.29
	sid-snapshot-20160601:1.29
	sid-snapshot-20160501:1.29
	sid-snapshot-20160401:1.29
	sid-snapshot-20160301:1.29
	sid-snapshot-20160201:1.29
	sid-snapshot-20160101:1.29
	sid-snapshot-20151201:1.29
	sid-snapshot-20151101:1.29
	sid-snapshot-20151001:1.29
	sid-snapshot-20150901:1.29
	sid-snapshot-20150801:1.29
	sid-snapshot-20150701:1.29
	sid-snapshot-20150601:1.29
	sid-snapshot-20150501:1.29
	sid-snapshot-20150401:1.29
	sid-snapshot-20150301:1.29
	sid-snapshot-20150201:1.29
	sid-snapshot-20150101:1.29
	sid-snapshot-20141201:1.29
	sid-snapshot-20141101:1.29
	sid-snapshot-20141001:1.29
	sid-snapshot-20140901:1.29
	sid-snapshot-20140801:1.29
	sid-snapshot-20140701:1.29
	sid-snapshot-20140601:1.29
	sid-snapshot-20140501:1.29
	sid-snapshot-20140401:1.29
	sid-snapshot-20140301:1.29
	sid-snapshot-20140201:1.29
	sid-snapshot-20140101:1.29
	sid-snapshot-20131201:1.29
	sid-snapshot-20131101:1.29
	sid-snapshot-20131001:1.29
	binutils-2_24-branch:1.29.0.2
	binutils-2_24-branchpoint:1.29
	binutils-2_21_1:1.22
	sid-snapshot-20130901:1.29
	gdb_7_6_1-2013-08-30-release:1.26
	sid-snapshot-20130801:1.29
	sid-snapshot-20130701:1.28
	sid-snapshot-20130601:1.28
	sid-snapshot-20130501:1.27
	gdb_7_6-2013-04-26-release:1.26
	sid-snapshot-20130401:1.27
	binutils-2_23_2:1.24
	gdb_7_6-branch:1.26.0.2
	gdb_7_6-2013-03-12-branchpoint:1.26
	sid-snapshot-20130301:1.26
	sid-snapshot-20130201:1.26
	sid-snapshot-20130101:1.24
	sid-snapshot-20121201:1.24
	gdb_7_5_1-2012-11-29-release:1.24
	binutils-2_23_1:1.24
	sid-snapshot-20121101:1.24
	binutils-2_23:1.24
	sid-snapshot-20121001:1.24
	sid-snapshot-20120901:1.24
	gdb_7_5-2012-08-17-release:1.24
	sid-snapshot-20120801:1.24
	binutils-2_23-branch:1.24.0.4
	binutils-2_23-branchpoint:1.24
	gdb_7_5-branch:1.24.0.2
	gdb_7_5-2012-07-18-branchpoint:1.24
	sid-snapshot-20120701:1.24
	sid-snapshot-20120601:1.24
	sid-snapshot-20120501:1.23
	binutils-2_22_branch:1.22.0.10
	gdb_7_4_1-2012-04-26-release:1.22
	sid-snapshot-20120401:1.22
	sid-snapshot-20120301:1.22
	sid-snapshot-20120201:1.22
	gdb_7_4-2012-01-24-release:1.22
	sid-snapshot-20120101:1.22
	gdb_7_4-branch:1.22.0.8
	gdb_7_4-2011-12-13-branchpoint:1.22
	sid-snapshot-20111201:1.22
	binutils-2_22:1.22
	sid-snapshot-20111101:1.22
	sid-snapshot-20111001:1.22
	binutils-2_22-branch:1.22.0.6
	binutils-2_22-branchpoint:1.22
	gdb_7_3_1-2011-09-04-release:1.22
	sid-snapshot-20110901:1.22
	sid-snapshot-20110801:1.22
	gdb_7_3-2011-07-26-release:1.22
	sid-snapshot-20110701:1.22
	sid-snapshot-20110601:1.22
	sid-snapshot-20110501:1.22
	gdb_7_3-branch:1.22.0.4
	gdb_7_3-2011-04-01-branchpoint:1.22
	sid-snapshot-20110401:1.22
	sid-snapshot-20110301:1.22
	sid-snapshot-20110201:1.22
	sid-snapshot-20110101:1.22
	binutils-2_21:1.22
	sid-snapshot-20101201:1.22
	binutils-2_21-branch:1.22.0.2
	binutils-2_21-branchpoint:1.22
	sid-snapshot-20101101:1.22
	sid-snapshot-20101001:1.21
	binutils-2_20_1:1.20
	gdb_7_2-2010-09-02-release:1.21
	sid-snapshot-20100901:1.21
	sid-snapshot-20100801:1.21
	gdb_7_2-branch:1.21.0.2
	gdb_7_2-2010-07-07-branchpoint:1.21
	sid-snapshot-20100701:1.21
	sid-snapshot-20100601:1.20
	sid-snapshot-20100501:1.20
	sid-snapshot-20100401:1.20
	gdb_7_1-2010-03-18-release:1.20
	sid-snapshot-20100301:1.20
	gdb_7_1-branch:1.20.0.32
	gdb_7_1-2010-02-18-branchpoint:1.20
	sid-snapshot-20100201:1.20
	sid-snapshot-20100101:1.20
	gdb_7_0_1-2009-12-22-release:1.20
	sid-snapshot-20091201:1.20
	sid-snapshot-20091101:1.20
	binutils-2_20:1.20
	gdb_7_0-2009-10-06-release:1.20
	sid-snapshot-20091001:1.20
	gdb_7_0-branch:1.20.0.30
	gdb_7_0-2009-09-16-branchpoint:1.20
	arc-sim-20090309:1.20
	binutils-arc-20081103-branch:1.20.0.28
	binutils-arc-20081103-branchpoint:1.20
	binutils-2_20-branch:1.20.0.26
	binutils-2_20-branchpoint:1.20
	sid-snapshot-20090901:1.20
	sid-snapshot-20090801:1.20
	msnyder-checkpoint-072509-branch:1.20.0.24
	msnyder-checkpoint-072509-branchpoint:1.20
	sid-snapshot-20090701:1.20
	dje-cgen-play1-branch:1.20.0.22
	dje-cgen-play1-branchpoint:1.20
	sid-snapshot-20090601:1.20
	sid-snapshot-20090501:1.20
	sid-snapshot-20090401:1.20
	arc-20081103-branch:1.20.0.20
	arc-20081103-branchpoint:1.20
	arc-insight_6_8-branch:1.20.0.18
	arc-insight_6_8-branchpoint:1.20
	insight_6_8-branch:1.20.0.16
	insight_6_8-branchpoint:1.20
	sid-snapshot-20090301:1.20
	binutils-2_19_1:1.20
	sid-snapshot-20090201:1.20
	sid-snapshot-20090101:1.20
	reverse-20081226-branch:1.20.0.14
	reverse-20081226-branchpoint:1.20
	sid-snapshot-20081201:1.20
	multiprocess-20081120-branch:1.20.0.12
	multiprocess-20081120-branchpoint:1.20
	sid-snapshot-20081101:1.20
	binutils-2_19:1.20
	sid-snapshot-20081001:1.20
	reverse-20080930-branch:1.20.0.10
	reverse-20080930-branchpoint:1.20
	binutils-2_19-branch:1.20.0.8
	binutils-2_19-branchpoint:1.20
	sid-snapshot-20080901:1.20
	sid-snapshot-20080801:1.20
	reverse-20080717-branch:1.20.0.6
	reverse-20080717-branchpoint:1.20
	sid-snapshot-20080701:1.20
	msnyder-reverse-20080609-branch:1.20.0.4
	msnyder-reverse-20080609-branchpoint:1.20
	drow-reverse-20070409-branch:1.17.0.2
	drow-reverse-20070409-branchpoint:1.17
	sid-snapshot-20080601:1.20
	sid-snapshot-20080501:1.20
	sid-snapshot-20080403:1.20
	sid-snapshot-20080401:1.20
	gdb_6_8-2008-03-27-release:1.20
	sid-snapshot-20080301:1.20
	gdb_6_8-branch:1.20.0.2
	gdb_6_8-2008-02-26-branchpoint:1.20
	sid-snapshot-20080201:1.20
	sid-snapshot-20080101:1.20
	sid-snapshot-20071201:1.20
	sid-snapshot-20071101:1.20
	gdb_6_7_1-2007-10-29-release:1.19
	gdb_6_7-2007-10-10-release:1.19
	sid-snapshot-20071001:1.20
	gdb_6_7-branch:1.19.0.4
	gdb_6_7-2007-09-07-branchpoint:1.19
	binutils-2_18:1.19
	binutils-2_18-branch:1.19.0.2
	binutils-2_18-branchpoint:1.19
	insight_6_6-20070208-release:1.14
	binutils-csl-coldfire-4_1-32:1.13
	binutils-csl-sourcerygxx-4_1-32:1.13
	gdb_6_6-2006-12-18-release:1.14
	binutils-csl-innovasic-fido-3_4_4-33:1.13
	binutils-csl-sourcerygxx-3_4_4-32:1.8
	binutils-csl-coldfire-4_1-30:1.13
	binutils-csl-sourcerygxx-4_1-30:1.13
	binutils-csl-coldfire-4_1-28:1.13
	binutils-csl-sourcerygxx-4_1-29:1.13
	binutils-csl-sourcerygxx-4_1-28:1.13
	gdb_6_6-branch:1.14.0.2
	gdb_6_6-2006-11-15-branchpoint:1.14
	binutils-csl-arm-2006q3-27:1.13
	binutils-csl-sourcerygxx-4_1-27:1.13
	binutils-csl-arm-2006q3-26:1.13
	binutils-csl-sourcerygxx-4_1-26:1.13
	binutils-csl-sourcerygxx-4_1-25:1.13
	binutils-csl-sourcerygxx-4_1-24:1.13
	binutils-csl-sourcerygxx-4_1-23:1.13
	insight_6_5-20061003-release:1.13
	gdb-csl-symbian-6_4_50_20060226-12:1.13
	binutils-csl-sourcerygxx-4_1-21:1.13
	binutils-csl-arm-2006q3-21:1.13
	binutils-csl-sourcerygxx-4_1-22:1.13
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.13
	binutils-csl-sourcerygxx-4_1-20:1.13
	binutils-csl-arm-2006q3-19:1.13
	binutils-csl-sourcerygxx-4_1-19:1.13
	binutils-csl-sourcerygxx-4_1-18:1.13
	binutils-csl-renesas-4_1-9:1.13
	gdb-csl-sourcerygxx-3_4_4-25:1.13
	binutils-csl-sourcerygxx-3_4_4-25:1.8
	nickrob-async-20060828-mergepoint:1.13
	gdb-csl-symbian-6_4_50_20060226-11:1.13
	binutils-csl-renesas-4_1-8:1.13
	binutils-csl-renesas-4_1-7:1.13
	binutils-csl-renesas-4_1-6:1.13
	gdb-csl-sourcerygxx-4_1-17:1.13
	binutils-csl-sourcerygxx-4_1-17:1.13
	gdb-csl-20060226-branch-local-2:1.13
	gdb-csl-sourcerygxx-4_1-14:1.13
	binutils-csl-sourcerygxx-4_1-14:1.13
	binutils-csl-sourcerygxx-4_1-15:1.13
	gdb-csl-sourcerygxx-4_1-13:1.13
	binutils-csl-sourcerygxx-4_1-13:1.13
	binutils-2_17:1.13
	gdb-csl-sourcerygxx-4_1-12:1.13
	binutils-csl-sourcerygxx-4_1-12:1.13
	gdb-csl-sourcerygxx-3_4_4-21:1.13
	binutils-csl-sourcerygxx-3_4_4-21:1.13
	gdb_6_5-20060621-release:1.13
	binutils-csl-wrs-linux-3_4_4-24:1.8
	binutils-csl-wrs-linux-3_4_4-23:1.8
	gdb-csl-sourcerygxx-4_1-9:1.13
	binutils-csl-sourcerygxx-4_1-9:1.13
	gdb-csl-sourcerygxx-4_1-8:1.13
	binutils-csl-sourcerygxx-4_1-8:1.13
	gdb-csl-sourcerygxx-4_1-7:1.13
	binutils-csl-sourcerygxx-4_1-7:1.13
	gdb-csl-arm-2006q1-6:1.13
	binutils-csl-arm-2006q1-6:1.13
	gdb-csl-sourcerygxx-4_1-6:1.13
	binutils-csl-sourcerygxx-4_1-6:1.13
	binutils-csl-wrs-linux-3_4_4-22:1.8
	gdb-csl-symbian-6_4_50_20060226-10:1.13
	gdb-csl-symbian-6_4_50_20060226-9:1.13
	gdb-csl-symbian-6_4_50_20060226-8:1.13
	gdb-csl-coldfire-4_1-11:1.13
	binutils-csl-coldfire-4_1-11:1.13
	gdb-csl-sourcerygxx-3_4_4-19:1.13
	binutils-csl-sourcerygxx-3_4_4-19:1.13
	gdb-csl-coldfire-4_1-10:1.13
	gdb_6_5-branch:1.13.0.28
	gdb_6_5-2006-05-14-branchpoint:1.13
	binutils-csl-coldfire-4_1-10:1.13
	gdb-csl-sourcerygxx-4_1-5:1.13
	binutils-csl-sourcerygxx-4_1-5:1.13
	nickrob-async-20060513-branch:1.13.0.26
	nickrob-async-20060513-branchpoint:1.13
	gdb-csl-sourcerygxx-4_1-4:1.13
	binutils-csl-sourcerygxx-4_1-4:1.13
	msnyder-reverse-20060502-branch:1.13.0.24
	msnyder-reverse-20060502-branchpoint:1.13
	binutils-csl-wrs-linux-3_4_4-21:1.8
	gdb-csl-morpho-4_1-4:1.13
	binutils-csl-morpho-4_1-4:1.13
	gdb-csl-sourcerygxx-3_4_4-17:1.13
	binutils-csl-sourcerygxx-3_4_4-17:1.13
	binutils-csl-wrs-linux-3_4_4-20:1.8
	readline_5_1-import-branch:1.13.0.22
	readline_5_1-import-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.13
	binutils-2_17-branch:1.13.0.20
	binutils-2_17-branchpoint:1.13
	gdb-csl-symbian-20060226-branch:1.13.0.18
	gdb-csl-symbian-20060226-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.13
	msnyder-reverse-20060331-branch:1.13.0.16
	msnyder-reverse-20060331-branchpoint:1.13
	binutils-csl-2_17-branch:1.13.0.14
	binutils-csl-2_17-branchpoint:1.13
	gdb-csl-available-20060303-branch:1.13.0.12
	gdb-csl-available-20060303-branchpoint:1.13
	gdb-csl-20060226-branch:1.13.0.10
	gdb-csl-20060226-branchpoint:1.13
	gdb_6_4-20051202-release:1.13
	msnyder-fork-checkpoint-branch:1.13.0.8
	msnyder-fork-checkpoint-branchpoint:1.13
	gdb-csl-gxxpro-6_3-branch:1.13.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.13
	gdb_6_4-branch:1.13.0.4
	gdb_6_4-2005-11-01-branchpoint:1.13
	gdb-csl-arm-20051020-branch:1.13.0.2
	gdb-csl-arm-20051020-branchpoint:1.13
	binutils-csl-gxxpro-3_4-branch:1.8.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.8
	binutils-2_16_1:1.8
	msnyder-tracepoint-checkpoint-branch:1.10.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.10
	gdb-csl-arm-20050325-2005-q1b:1.8
	binutils-csl-arm-2005q1b:1.8
	binutils-2_16:1.8
	gdb-csl-arm-20050325-2005-q1a:1.8
	binutils-csl-arm-2005q1a:1.8
	csl-arm-20050325-branch:1.8.0.6
	csl-arm-20050325-branchpoint:1.8
	binutils-csl-arm-2005q1-branch:1.8.0.4
	binutils-csl-arm-2005q1-branchpoint:1.8
	binutils-2_16-branch:1.8.0.2
	binutils-2_16-branchpoint:1.8
	csl-arm-2004-q3d:1.8
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.2
	gdb_6_3-20041019-branchpoint:1.7
	csl-arm-2004-q3:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.6.0.8
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.4
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.4
	binutils-2_15:1.4.8.1
	binutils-2_15-branchpoint:1.4
	csl-arm-2004-q1a:1.6
	csl-arm-2004-q1:1.6
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.2
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.4.0.14
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.12
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.10
	drow_intercu-20040221-branchpoint:1.4
	binutils-2_15-branch:1.4.0.8
	cagney_bfdfile-20040213-branch:1.4.0.6
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.4
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	csl-arm-2003-q4:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-branch:1.4.0.2
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.1
	kettenis_sparc-20030918-branch:1.3.0.6
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.4
	cagney_x86i386-20030821-branch:1.3.0.2
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.1.0.38
	gdb_6_0-2003-06-23-branchpoint:1.1
	jimb-ppc64-linux-20030613-branch:1.1.0.36
	jimb-ppc64-linux-20030613-branchpoint:1.1
	binutils-2_14:1.1
	cagney_convert-20030606-branch:1.1.0.34
	cagney_convert-20030606-branchpoint:1.1
	cagney_writestrings-20030508-branch:1.1.0.32
	cagney_writestrings-20030508-branchpoint:1.1
	jimb-ppc64-linux-20030528-branch:1.1.0.30
	jimb-ppc64-linux-20030528-branchpoint:1.1
	carlton_dictionary-20030523-merge:1.1
	cagney_fileio-20030521-branch:1.1.0.28
	cagney_fileio-20030521-branchpoint:1.1
	kettenis_i386newframe-20030517-mergepoint:1.1
	jimb-ppc64-linux-20030509-branch:1.1.0.26
	jimb-ppc64-linux-20030509-branchpoint:1.1
	kettenis_i386newframe-20030504-mergepoint:1.1
	carlton_dictionary-20030430-merge:1.1
	binutils-2_14-branch:1.1.0.24
	binutils-2_14-branchpoint:1.1
	kettenis_i386newframe-20030419-branch:1.1.0.22
	kettenis_i386newframe-20030419-branchpoint:1.1
	carlton_dictionary-20030416-merge:1.1
	cagney_frameaddr-20030409-mergepoint:1.1
	kettenis_i386newframe-20030406-branch:1.1.0.20
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.18
	cagney_framebase-20030330-mergepoint:1.1
	cagney_framebase-20030326-branch:1.1.0.16
	cagney_framebase-20030326-branchpoint:1.1
	cagney_lazyid-20030317-branch:1.1.0.14
	cagney_lazyid-20030317-branchpoint:1.1
	kettenis-i386newframe-20030316-mergepoint:1.1
	offbyone-20030313-branch:1.1.0.12
	offbyone-20030313-branchpoint:1.1
	kettenis-i386newframe-20030308-branch:1.1.0.10
	kettenis-i386newframe-20030308-branchpoint:1.1
	carlton_dictionary-20030305-merge:1.1
	cagney_offbyone-20030303-branch:1.1.0.8
	cagney_offbyone-20030303-branchpoint:1.1
	carlton_dictionary-branch:1.1.0.6
	carlton_dictionary-20030207-merge:1.1
	interps-20030202-branch:1.1.0.4
	interps-20030202-branchpoint:1.1
	cagney-unwind-20030108-branch:1.1.0.2
	cagney-unwind-20030108-branchpoint:1.1
	binutils_latest_snapshot:1.29;
locks; strict;
comment	@ * @;


1.29
date	2013.07.18.14.08.42;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.02.21.06.13;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.30.10.14.14;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.15.08.35.39;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.10.20.03.53;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2012.05.07.03.27.50;	author macro;	state Exp;
branches;
next	1.23;

1.23
date	2012.04.24.05.12.34;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches
	1.22.6.1;
next	1.21;

1.21
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.28.08.43.45;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.14.02.56.45;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.01.11.27.15;	author diwil;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.12.11.45.26;	author diwil;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.20.18.12.07;	author hjl;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.04.15.53.17;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.04.07.19.23;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.21.15.28.23;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.25.12.54.14;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.22.02.28.16;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.20.23.16.41;	author hjl;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches
	1.4.2.1
	1.4.8.1
	1.4.10.1
	1.4.14.1;
next	1.3;

1.3
date	2003.08.08.10.14.50;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.25.06.40.24;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.30.19.25.10;	author nickc;	state Exp;
branches
	1.1.6.1;
next	;

1.22.6.1
date	2012.05.11.12.24.25;	author nickc;	state Exp;
branches;
next	;

1.4.2.1
date	2003.12.14.20.26.40;	author drow;	state Exp;
branches;
next	;

1.4.8.1
date	2004.04.08.12.41.42;	author amodra;	state Exp;
branches;
next	;

1.4.10.1
date	2004.03.27.17.37.33;	author drow;	state Exp;
branches;
next	1.4.10.2;

1.4.10.2
date	2004.09.16.17.00.25;	author drow;	state Exp;
branches;
next	;

1.4.14.1
date	2004.03.21.23.57.27;	author cagney;	state Exp;
branches;
next	;

1.1.6.1
date	2003.02.07.19.17.38;	author carlton;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2003.06.27.21.49.15;	author carlton;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2003.09.17.21.27.52;	author carlton;	state Exp;
branches;
next	1.1.6.4;

1.1.6.4
date	2003.11.11.23.50.18;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.29
log
@	PR ld/15721
	* elf32-msp430.c (R_MSP430_10_PCREL): Use 10-bit source and
	destination masks.
	* R_MSP430_2X_PCREL: Likewise.
	* R_MSP430X_10_PCREL: Likewise.
	* R_MSP430X_2X_PCREL: Likewise.
@
text
@/*  MSP430-specific support for 32-bit ELF
    Copyright (C) 2002-2013 Free Software Foundation, Inc.
    Contributed by Dmitry Diky <diwil@@mail.ru>

    This file is part of BFD, the Binary File Descriptor library.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
    MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/msp430.h"

static reloc_howto_type elf_msp430_howto_table[] =
{
  HOWTO (R_MSP430_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_NONE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MSP430_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 10 bit PC relative relocation.  */
  HOWTO (R_MSP430_10_PCREL,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_10_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x3ff,			/* src_mask */
	 0x3ff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 16 bit absolute relocation.  */
  HOWTO (R_MSP430_16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit PC relative relocation for command address.  */
  HOWTO (R_MSP430_16_PCREL,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_16_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 16 bit absolute relocation, byte operations.  */
  HOWTO (R_MSP430_16_BYTE,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_16_BYTE",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit absolute relocation for command address.  */
  HOWTO (R_MSP430_16_PCREL_BYTE,/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_16_PCREL_BYTE",/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 10 bit PC relative relocation for complicated polymorphs.  */
  HOWTO (R_MSP430_2X_PCREL,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_2X_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x3ff,			/* src_mask */
	 0x3ff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 16 bit relaxable relocation for command address.  */
  HOWTO (R_MSP430_RL_PCREL,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_RL_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE)			/* pcrel_offset */

  /* A 8-bit absolute relocation.  */
  , HOWTO (R_MSP430_8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_8",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Together with a following reloc, allows for the difference
     between two symbols to be the real addend of the second reloc.  */
  HOWTO (R_MSP430_SYM_DIFF,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 NULL, 			/* special handler.  */
	 "R_MSP430_SYM_DIFF",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE)			/* pcrel_offset */  
};

static reloc_howto_type elf_msp430x_howto_table[] =
{
  HOWTO (R_MSP430_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_NONE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MSP430_ABS32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_ABS32",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MSP430_ABS16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_ABS16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MSP430_ABS8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_ABS8",	/* name */
	 FALSE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MSP430_PCR16,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_PCR16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430X_PCR20_EXT_SRC,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_PCR20_EXT_SRC",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430X_PCR20_EXT_DST,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_PCR20_EXT_DST",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430X_PCR20_EXT_ODST,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_PCR20_EXT_ODST",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430X_ABS20_EXT_SRC,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_ABS20_EXT_SRC",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430X_ABS20_EXT_DST,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_ABS20_EXT_DST",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430X_ABS20_EXT_ODST,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_ABS20_EXT_ODST",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430X_ABS20_ADR_SRC,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_ABS20_ADR_SRC",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430X_ABS20_ADR_DST,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_ABS20_ADR_DST",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430X_PCR16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_PCR16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430X_PCR20_CALL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_PCR20_CALL",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430X_ABS16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_ABS16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430_ABS_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_ABS_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MSP430_PREL31,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_PREL31",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  EMPTY_HOWTO (R_MSP430_EHTYPE),
  
  /* A 10 bit PC relative relocation.  */
  HOWTO (R_MSP430X_10_PCREL,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_10_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x3ff,			/* src_mask */
	 0x3ff,			/* dst_mask */
	 TRUE),  		/* pcrel_offset */

  /* A 10 bit PC relative relocation for complicated polymorphs.  */
  HOWTO (R_MSP430X_2X_PCREL,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430X_2X_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x3ff,			/* src_mask */
	 0x3ff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Together with a following reloc, allows for the difference
     between two symbols to be the real addend of the second reloc.  */
  HOWTO (R_MSP430X_SYM_DIFF,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 NULL, 			/* special handler.  */
	 "R_MSP430X_SYM_DIFF",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE)			/* pcrel_offset */  
};

/* Map BFD reloc types to MSP430 ELF reloc types.  */

struct msp430_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned int elf_reloc_val;
};

static const struct msp430_reloc_map msp430_reloc_map[] =
{
  {BFD_RELOC_NONE,                 R_MSP430_NONE},
  {BFD_RELOC_32,                   R_MSP430_32},
  {BFD_RELOC_MSP430_10_PCREL,      R_MSP430_10_PCREL},
  {BFD_RELOC_16,                   R_MSP430_16_BYTE},
  {BFD_RELOC_MSP430_16_PCREL,      R_MSP430_16_PCREL},
  {BFD_RELOC_MSP430_16,            R_MSP430_16},
  {BFD_RELOC_MSP430_16_PCREL_BYTE, R_MSP430_16_PCREL_BYTE},
  {BFD_RELOC_MSP430_16_BYTE,       R_MSP430_16_BYTE},
  {BFD_RELOC_MSP430_2X_PCREL,      R_MSP430_2X_PCREL},
  {BFD_RELOC_MSP430_RL_PCREL,      R_MSP430_RL_PCREL},
  {BFD_RELOC_8,                    R_MSP430_8},
  {BFD_RELOC_MSP430_SYM_DIFF,      R_MSP430_SYM_DIFF}
};

static const struct msp430_reloc_map msp430x_reloc_map[] =
{
  {BFD_RELOC_NONE,                    R_MSP430_NONE},
  {BFD_RELOC_32,                      R_MSP430_ABS32},
  {BFD_RELOC_16,                      R_MSP430_ABS16},
  {BFD_RELOC_8,                       R_MSP430_ABS8},
  {BFD_RELOC_MSP430_ABS8,             R_MSP430_ABS8},
  {BFD_RELOC_MSP430X_PCR20_EXT_SRC,   R_MSP430X_PCR20_EXT_SRC},
  {BFD_RELOC_MSP430X_PCR20_EXT_DST,   R_MSP430X_PCR20_EXT_DST},
  {BFD_RELOC_MSP430X_PCR20_EXT_ODST,  R_MSP430X_PCR20_EXT_ODST},
  {BFD_RELOC_MSP430X_ABS20_EXT_SRC,   R_MSP430X_ABS20_EXT_SRC},
  {BFD_RELOC_MSP430X_ABS20_EXT_DST,   R_MSP430X_ABS20_EXT_DST},
  {BFD_RELOC_MSP430X_ABS20_EXT_ODST,  R_MSP430X_ABS20_EXT_ODST},
  {BFD_RELOC_MSP430X_ABS20_ADR_SRC,   R_MSP430X_ABS20_ADR_SRC},
  {BFD_RELOC_MSP430X_ABS20_ADR_DST,   R_MSP430X_ABS20_ADR_DST},
  {BFD_RELOC_MSP430X_PCR16,           R_MSP430X_PCR16},
  {BFD_RELOC_MSP430X_PCR20_CALL,      R_MSP430X_PCR20_CALL},
  {BFD_RELOC_MSP430X_ABS16,           R_MSP430X_ABS16},
  {BFD_RELOC_MSP430_ABS_HI16,         R_MSP430_ABS_HI16},
  {BFD_RELOC_MSP430_PREL31,           R_MSP430_PREL31},
  {BFD_RELOC_MSP430_10_PCREL,         R_MSP430X_10_PCREL},
  {BFD_RELOC_MSP430_2X_PCREL,         R_MSP430X_2X_PCREL},
  {BFD_RELOC_MSP430_RL_PCREL,         R_MSP430X_PCR16},
  {BFD_RELOC_MSP430_SYM_DIFF,         R_MSP430X_SYM_DIFF}
};

static inline bfd_boolean
uses_msp430x_relocs (bfd * abfd)
{
  extern const bfd_target bfd_elf32_msp430_ti_vec;

  return bfd_get_mach (abfd) == bfd_mach_msp430x
    || abfd->xvec == & bfd_elf32_msp430_ti_vec;
}

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
				 bfd_reloc_code_real_type code)
{
  unsigned int i;

  if (uses_msp430x_relocs (abfd))
    {
      for (i = ARRAY_SIZE (msp430x_reloc_map); i--;)
	if (msp430x_reloc_map[i].bfd_reloc_val == code)
	  return elf_msp430x_howto_table + msp430x_reloc_map[i].elf_reloc_val;
    }
  else
    {
      for (i = 0; i < ARRAY_SIZE (msp430_reloc_map); i++)
	if (msp430_reloc_map[i].bfd_reloc_val == code)
	  return &elf_msp430_howto_table[msp430_reloc_map[i].elf_reloc_val];
    }

  return NULL;
}

static reloc_howto_type *
bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 const char *r_name)
{
  unsigned int i;

  if (uses_msp430x_relocs (abfd))
    {
      for (i = ARRAY_SIZE (elf_msp430x_howto_table); i--;)
	if (elf_msp430x_howto_table[i].name != NULL
	    && strcasecmp (elf_msp430x_howto_table[i].name, r_name) == 0)
	  return elf_msp430x_howto_table + i;
    }
  else
    {
      for (i = 0;
	   i < (sizeof (elf_msp430_howto_table)
		/ sizeof (elf_msp430_howto_table[0]));
	   i++)
	if (elf_msp430_howto_table[i].name != NULL
	    && strcasecmp (elf_msp430_howto_table[i].name, r_name) == 0)
	  return &elf_msp430_howto_table[i];
    }

  return NULL;
}

/* Set the howto pointer for an MSP430 ELF reloc.  */

static void
msp430_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
			   arelent * cache_ptr,
			   Elf_Internal_Rela * dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);

  if (uses_msp430x_relocs (abfd))
    {
      BFD_ASSERT (r_type < (unsigned int) R_MSP430x_max);
      cache_ptr->howto = elf_msp430x_howto_table + r_type;
      return;
    }

  BFD_ASSERT (r_type < (unsigned int) R_MSP430_max);
  cache_ptr->howto = &elf_msp430_howto_table[r_type];
}

/* Look through the relocs for a section during the first phase.
   Since we don't do .gots or .plts, we just need to consider the
   virtual table relocs for gc.  */

static bfd_boolean
elf32_msp430_check_relocs (bfd * abfd, struct bfd_link_info * info,
			   asection * sec, const Elf_Internal_Rela * relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;

  if (info->relocatable)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}
    }

  return TRUE;
}

/* Perform a single relocation.  By default we use the standard BFD
   routines, but a few relocs, we have to do them ourselves.  */

static bfd_reloc_status_type
msp430_final_link_relocate (reloc_howto_type *     howto,
			    bfd *                  input_bfd,
			    asection *             input_section,
			    bfd_byte *             contents,
			    Elf_Internal_Rela *    rel,
			    bfd_vma                relocation,
			    struct bfd_link_info * info)
{
  static asection *  sym_diff_section;
  static bfd_vma     sym_diff_value;

  struct bfd_elf_section_data * esd = elf_section_data (input_section);
  bfd_reloc_status_type r = bfd_reloc_ok;
  bfd_vma x;
  bfd_signed_vma srel;
  bfd_boolean is_rel_reloc = FALSE;

  if (uses_msp430x_relocs (input_bfd))
    {
      /* See if we have a REL type relocation.  */
      is_rel_reloc = (esd->rel.hdr != NULL);
      /* Sanity check - only one type of relocation per section.
	 FIXME: Theoretically it is possible to have both types,
	 but if that happens how can we distinguish between the two ?  */
      BFD_ASSERT (! is_rel_reloc || ! esd->rela.hdr);
      /* If we are using a REL relocation then the addend should be empty.  */
      BFD_ASSERT (! is_rel_reloc || rel->r_addend == 0);
    }

  if (sym_diff_section != NULL)
    {
      BFD_ASSERT (sym_diff_section == input_section);
 
     if (uses_msp430x_relocs (input_bfd))
       switch (howto->type)
	 {
	 case R_MSP430_ABS32:
	  /* If we are computing a 32-bit value for the location lists
	     and the result is 0 then we add one to the value.  A zero
	     value can result because of linker relaxation deleteing
	     prologue instructions and using a value of 1 (for the begin
	     and end offsets in the location list entry) results in a
	     nul entry which does not prevent the following entries from
	     being parsed.  */
	   if (relocation == sym_diff_value
	       && strcmp (input_section->name, ".debug_loc") == 0)
	     ++ relocation;
	   /* Fall through.  */
	 case R_MSP430_ABS16:
	 case R_MSP430X_ABS16:
	 case R_MSP430_ABS8:
	   BFD_ASSERT (! is_rel_reloc);
	   relocation -= sym_diff_value;
	  break;

	 default:
	   return bfd_reloc_dangerous;
	 }
     else
       switch (howto->type)
	 {
	 case R_MSP430_32:
	 case R_MSP430_16:
	 case R_MSP430_16_BYTE:
	 case R_MSP430_8:
	   relocation -= sym_diff_value;
	  break;

	 default:
	   return bfd_reloc_dangerous;
	 }
       
      sym_diff_section = NULL;
    }

  if (uses_msp430x_relocs (input_bfd))
    switch (howto->type)
      {
      case R_MSP430X_SYM_DIFF:
	/* Cache the input section and value.
	   The offset is unreliable, since relaxation may
	   have reduced the following reloc's offset.  */
	BFD_ASSERT (! is_rel_reloc);
	sym_diff_section = input_section;
	sym_diff_value = relocation;
	return bfd_reloc_ok;

      case R_MSP430_ABS16:
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  srel += bfd_get_16 (input_bfd, contents);
	else
	  srel += rel->r_addend;
	bfd_put_16 (input_bfd, srel & 0xffff, contents);
	break;

      case R_MSP430X_10_PCREL:
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  srel += bfd_get_16 (input_bfd, contents) & 0x3ff;
	else
	  srel += rel->r_addend;
	srel -= rel->r_offset;
	srel -= 2;		/* Branch instructions add 2 to the PC...  */
	srel -= (input_section->output_section->vma +
		 input_section->output_offset);
	if (srel & 1)
	  return bfd_reloc_outofrange;

	/* MSP430 addresses commands as words.  */
	srel >>= 1;

	/* Check for an overflow.  */
	if (srel < -512 || srel > 511)
	  {
	    if (info->disable_target_specific_optimizations < 0)
	      {
		static bfd_boolean warned = FALSE;
		if (! warned)
		  {
		    info->callbacks->warning
		      (info,
		       _("Try enabling relaxation to avoid relocation truncations"),
		       NULL, input_bfd, input_section, relocation);
		    warned = TRUE;
		  }
	      }
	    return bfd_reloc_overflow;
	  }

	x = bfd_get_16 (input_bfd, contents);
	x = (x & 0xfc00) | (srel & 0x3ff);
	bfd_put_16 (input_bfd, x, contents);
	break;

      case R_MSP430X_PCR20_EXT_ODST:
	/* [0,4]+[48,16] = ---F ---- FFFF */
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  {
	    bfd_vma addend;
	    addend = (bfd_get_16 (input_bfd, contents) & 0xf) << 16;
	    addend |= bfd_get_16 (input_bfd, contents+4);
	    srel += addend;
	    
	  }
	else
	  srel += rel->r_addend;
	srel -= rel->r_offset;
	srel -= (input_section->output_section->vma +
		 input_section->output_offset);
	bfd_put_16 (input_bfd, (srel & 0xffff), contents + 6);
	x = bfd_get_16 (input_bfd, contents);
	x = (x & 0xfff0) | ((srel >> 16) & 0xf);
	bfd_put_16 (input_bfd, x, contents);
	break;

      case R_MSP430X_ABS20_EXT_SRC:
	/* [7,4]+[32,16] = -78- FFFF */
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  {
	    bfd_vma addend;
	    addend = (bfd_get_16 (input_bfd, contents) & 0x0780) << 9;
	    addend |= bfd_get_16 (input_bfd, contents+2);
	    srel += addend;
	  }
	else
	  srel += rel->r_addend;
	bfd_put_16 (input_bfd, (srel & 0xffff), contents + 4);
	srel >>= 16;
	x = bfd_get_16 (input_bfd, contents);
	x = (x & 0xf87f) | ((srel << 7) & 0x0780);
	bfd_put_16 (input_bfd, x, contents);
	break;

      case R_MSP430_16_PCREL:
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  srel += bfd_get_16 (input_bfd, contents);
	else
	  srel += rel->r_addend;
	srel -= rel->r_offset;
	/* Only branch instructions add 2 to the PC...  */
	srel -= (input_section->output_section->vma +
		 input_section->output_offset);
	if (srel & 1)
	  return bfd_reloc_outofrange;
	bfd_put_16 (input_bfd, srel & 0xffff, contents);
	break;

      case R_MSP430X_PCR20_EXT_DST:
	/* [0,4]+[32,16] = ---F FFFF */
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  {
	    bfd_vma addend;
	    addend = (bfd_get_16 (input_bfd, contents) & 0xf) << 16;
	    addend |= bfd_get_16 (input_bfd, contents+2);
	    srel += addend;
	  }
	else
	  srel += rel->r_addend;
	srel -= rel->r_offset;
	srel -= (input_section->output_section->vma +
		 input_section->output_offset);
	bfd_put_16 (input_bfd, (srel & 0xffff), contents + 4);
	srel >>= 16;
	x = bfd_get_16 (input_bfd, contents);
	x = (x & 0xfff0) | (srel & 0xf);
	bfd_put_16 (input_bfd, x, contents);
	break;

      case R_MSP430X_PCR20_EXT_SRC:
	/* [7,4]+32,16] = -78- FFFF */
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  {
	    bfd_vma addend;
	    addend = ((bfd_get_16 (input_bfd, contents) & 0x0780) << 9);
	    addend |= bfd_get_16 (input_bfd, contents+2);
	    srel += addend;;
	  }
	else
	  srel += rel->r_addend;
	srel -= rel->r_offset;
	/* Only branch instructions add 2 to the PC...  */
	srel -= (input_section->output_section->vma +
		 input_section->output_offset);
	bfd_put_16 (input_bfd, (srel & 0xffff), contents + 4);
	srel >>= 16;
	x = bfd_get_16 (input_bfd, contents);
	x = (x & 0xf87f) | ((srel << 7) & 0x0780);
	bfd_put_16 (input_bfd, x, contents);
	break;

      case R_MSP430_ABS8:
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  srel += bfd_get_8 (input_bfd, contents);
	else
	  srel += rel->r_addend;
	bfd_put_8 (input_bfd, srel & 0xff, contents);
	break;

      case R_MSP430X_ABS20_EXT_DST:
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  srel += bfd_get_16 (input_bfd, contents) & 0xf;
	else
	  srel += rel->r_addend;
	bfd_put_16 (input_bfd, (srel & 0xffff), contents + 4);
	srel >>= 16;
	x = bfd_get_16 (input_bfd, contents);
	x = (x & 0xfff0) | (srel & 0xf);
	bfd_put_16 (input_bfd, x, contents);
	break;

      case R_MSP430X_ABS20_EXT_ODST:
	/* [0,4]+[48,16] = ---F ---- FFFF */
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  {
	    bfd_vma addend;
	    addend = (bfd_get_16 (input_bfd, contents) & 0xf) << 16;
	    addend |= bfd_get_16 (input_bfd, contents+4);
	    srel += addend;
	  }
	else
	  srel += rel->r_addend;
	bfd_put_16 (input_bfd, (srel & 0xffff), contents + 6);
	srel >>= 16;
	x = bfd_get_16 (input_bfd, contents);
	x = (x & 0xfff0) | (srel & 0xf);
	bfd_put_16 (input_bfd, x, contents);
	break;

      case R_MSP430X_ABS20_ADR_SRC:
	/* [8,4]+[32,16] = -F-- FFFF */
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  {
	    bfd_vma addend;

	    addend = ((bfd_get_16 (input_bfd, contents) & 0xf00) << 8);
	    addend |= bfd_get_16 (input_bfd, contents+2);
	    srel += addend;
	  }
	else
	  srel += rel->r_addend;
	bfd_put_16 (input_bfd, (srel & 0xffff), contents + 2);
	srel >>= 16;
	x = bfd_get_16 (input_bfd, contents);
	x = (x & 0xf0ff) | ((srel << 8) & 0x0f00);
	bfd_put_16 (input_bfd, x, contents);
	break;

      case R_MSP430X_ABS20_ADR_DST:
	/* [0,4]+[32,16] = ---F FFFF */
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  {
	    bfd_vma addend;
	    addend = ((bfd_get_16 (input_bfd, contents) & 0xf) << 16);
	    addend |= bfd_get_16 (input_bfd, contents+2);
	    srel += addend;
	  }
	else
	  srel += rel->r_addend;
	bfd_put_16 (input_bfd, (srel & 0xffff), contents + 2);
	srel >>= 16;
	x = bfd_get_16 (input_bfd, contents);
	x = (x & 0xfff0) | (srel & 0xf);
	bfd_put_16 (input_bfd, x, contents);
	break;

      case R_MSP430X_ABS16:
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  srel += bfd_get_16 (input_bfd, contents);
	else
	  srel += rel->r_addend;
	x = srel;
	if (x > 0xffff)
	  return bfd_reloc_overflow;	
	bfd_put_16 (input_bfd, srel & 0xffff, contents);
	break;

      case R_MSP430_ABS_HI16:
	/* The EABI specifies that this must be a RELA reloc.  */
	BFD_ASSERT (! is_rel_reloc);
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	srel += rel->r_addend;
	bfd_put_16 (input_bfd, (srel >> 16) & 0xffff, contents);
	break;
      
      case R_MSP430X_PCR20_CALL:
	/* [0,4]+[32,16] = ---F FFFF*/
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  {
	    bfd_vma addend;
	    addend = (bfd_get_16 (input_bfd, contents) & 0xf) << 16;
	    addend |= bfd_get_16 (input_bfd, contents+2);
	    srel += addend;
	  }
	else
	  srel += rel->r_addend;
	srel -= rel->r_offset;
	srel -= (input_section->output_section->vma +
		 input_section->output_offset);
	bfd_put_16 (input_bfd, srel & 0xffff, contents + 2);
	srel >>= 16;
	x = bfd_get_16 (input_bfd, contents);
	x = (x & 0xfff0) | (srel & 0xf);
	bfd_put_16 (input_bfd, x, contents);
	break;
	
      case R_MSP430X_PCR16:
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  srel += bfd_get_16 (input_bfd, contents);
	else
	  srel += rel->r_addend;
	srel -= rel->r_offset;
	srel -= (input_section->output_section->vma +
		 input_section->output_offset);
	bfd_put_16 (input_bfd, srel & 0xffff, contents);
	break;
      
      case R_MSP430_PREL31:
	contents += rel->r_offset;
	srel = (bfd_signed_vma) relocation;
	if (is_rel_reloc)
	  srel += (bfd_get_32 (input_bfd, contents) & 0x7fffffff);
	else
	  srel += rel->r_addend;
	srel += rel->r_addend;
	x = bfd_get_32 (input_bfd, contents);
	x = (x & 0x80000000) | ((srel >> 31) & 0x7fffffff);
	bfd_put_32 (input_bfd, x, contents);
	break;
	
      default:
	r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				      contents, rel->r_offset,
				      relocation, rel->r_addend);
      }
  else
    switch (howto->type)
      {
    case R_MSP430_10_PCREL:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      srel -= rel->r_offset;
      srel -= 2;		/* Branch instructions add 2 to the PC...  */
      srel -= (input_section->output_section->vma +
	       input_section->output_offset);

      if (srel & 1)
	return bfd_reloc_outofrange;

      /* MSP430 addresses commands as words.  */
      srel >>= 1;

      /* Check for an overflow.  */
      if (srel < -512 || srel > 511)
	{
	  if (info->disable_target_specific_optimizations < 0)
	    {
	      static bfd_boolean warned = FALSE;
	      if (! warned)
		{
		  info->callbacks->warning
		    (info,
		     _("Try enabling relaxation to avoid relocation truncations"),
		     NULL, input_bfd, input_section, relocation);
		  warned = TRUE;
		}
	    }
	  return bfd_reloc_overflow;
	}
      
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xfc00) | (srel & 0x3ff);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_MSP430_2X_PCREL:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      srel -= rel->r_offset;
      srel -= 2;		/* Branch instructions add 2 to the PC...  */
      srel -= (input_section->output_section->vma +
	       input_section->output_offset);

      if (srel & 1)
	return bfd_reloc_outofrange;

      /* MSP430 addresses commands as words.  */
      srel >>= 1;

      /* Check for an overflow.  */
      if (srel < -512 || srel > 511)
	return bfd_reloc_overflow;

      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xfc00) | (srel & 0x3ff);
      bfd_put_16 (input_bfd, x, contents);
      /* Handle second jump instruction.  */
      x = bfd_get_16 (input_bfd, contents - 2);
      srel += 1;
      x = (x & 0xfc00) | (srel & 0x3ff);
      bfd_put_16 (input_bfd, x, contents - 2);
      break;

    case R_MSP430_RL_PCREL:
    case R_MSP430_16_PCREL:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      srel -= rel->r_offset;
      /* Only branch instructions add 2 to the PC...  */
      srel -= (input_section->output_section->vma +
	       input_section->output_offset);

      if (srel & 1)
	return bfd_reloc_outofrange;

      bfd_put_16 (input_bfd, srel & 0xffff, contents);
      break;

    case R_MSP430_16_PCREL_BYTE:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      srel -= rel->r_offset;
      /* Only branch instructions add 2 to the PC...  */
      srel -= (input_section->output_section->vma +
	       input_section->output_offset);

      bfd_put_16 (input_bfd, srel & 0xffff, contents);
      break;

    case R_MSP430_16_BYTE:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      bfd_put_16 (input_bfd, srel & 0xffff, contents);
      break;

    case R_MSP430_16:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;

      if (srel & 1)
	return bfd_reloc_notsupported;

      bfd_put_16 (input_bfd, srel & 0xffff, contents);
      break;

    case R_MSP430_8:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;

      bfd_put_8 (input_bfd, srel & 0xff, contents);
      break;
	 
    case R_MSP430_SYM_DIFF:
      /* Cache the input section and value.
	 The offset is unreliable, since relaxation may
	 have reduced the following reloc's offset.  */
      sym_diff_section = input_section;
      sym_diff_value = relocation;
      return bfd_reloc_ok;

      default:
	r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				      contents, rel->r_offset,
				      relocation, rel->r_addend);
      }

  return r;
}

/* Relocate an MSP430 ELF section.  */

static bfd_boolean
elf32_msp430_relocate_section (bfd * output_bfd ATTRIBUTE_UNUSED,
			       struct bfd_link_info * info,
			       bfd * input_bfd,
			       asection * input_section,
			       bfd_byte * contents,
			       Elf_Internal_Rela * relocs,
			       Elf_Internal_Sym * local_syms,
			       asection ** local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend = relocs + input_section->reloc_count;

  for (rel = relocs; rel < relend; rel++)
    {
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char *name = NULL;
      int r_type;

      r_type = ELF32_R_TYPE (rel->r_info);
      r_symndx = ELF32_R_SYM (rel->r_info);

      if (uses_msp430x_relocs (input_bfd))
	howto = elf_msp430x_howto_table + r_type;
      else
	howto = elf_msp430_howto_table + r_type;

      h = NULL;
      sym = NULL;
      sec = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

	  name = bfd_elf_string_from_elf_section
	      (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL || * name == 0) ? bfd_section_name (input_bfd, sec) : name;
	}
      else
	{
	  bfd_boolean unresolved_reloc, warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	  name = h->root.root.string;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      r = msp430_final_link_relocate (howto, input_bfd, input_section,
				      contents, rel, relocation, info);

      if (r != bfd_reloc_ok)
	{
	  const char *msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, (h ? &h->root : NULL), name, howto->name,
		   (bfd_vma) 0, input_bfd, input_section,
		   rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		  (info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: branch/jump to an odd address detected");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
		(info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (!r)
	    return FALSE;
	}

    }

  return TRUE;
}

/* The final processing done just before writing out a MSP430 ELF object
   file.  This gets the MSP430 architecture right based on the machine
   number.  */

static void
bfd_elf_msp430_final_write_processing (bfd * abfd,
				       bfd_boolean linker ATTRIBUTE_UNUSED)
{
  unsigned long val;

  switch (bfd_get_mach (abfd))
    {
    default:
    case bfd_mach_msp110: val = E_MSP430_MACH_MSP430x11x1; break;
    case bfd_mach_msp11: val = E_MSP430_MACH_MSP430x11; break;
    case bfd_mach_msp12: val = E_MSP430_MACH_MSP430x12; break;
    case bfd_mach_msp13: val = E_MSP430_MACH_MSP430x13; break;
    case bfd_mach_msp14: val = E_MSP430_MACH_MSP430x14; break;
    case bfd_mach_msp15: val = E_MSP430_MACH_MSP430x15; break;
    case bfd_mach_msp16: val = E_MSP430_MACH_MSP430x16; break;
    case bfd_mach_msp31: val = E_MSP430_MACH_MSP430x31; break;
    case bfd_mach_msp32: val = E_MSP430_MACH_MSP430x32; break;
    case bfd_mach_msp33: val = E_MSP430_MACH_MSP430x33; break;
    case bfd_mach_msp41: val = E_MSP430_MACH_MSP430x41; break;
    case bfd_mach_msp42: val = E_MSP430_MACH_MSP430x42; break;
    case bfd_mach_msp43: val = E_MSP430_MACH_MSP430x43; break;
    case bfd_mach_msp44: val = E_MSP430_MACH_MSP430x44; break;
    case bfd_mach_msp20: val = E_MSP430_MACH_MSP430x20; break;
    case bfd_mach_msp22: val = E_MSP430_MACH_MSP430x22; break;
    case bfd_mach_msp23: val = E_MSP430_MACH_MSP430x23; break;
    case bfd_mach_msp24: val = E_MSP430_MACH_MSP430x24; break;
    case bfd_mach_msp26: val = E_MSP430_MACH_MSP430x26; break;
    case bfd_mach_msp46: val = E_MSP430_MACH_MSP430x46; break;
    case bfd_mach_msp47: val = E_MSP430_MACH_MSP430x47; break;
    case bfd_mach_msp54: val = E_MSP430_MACH_MSP430x54; break;
    case bfd_mach_msp430x: val = E_MSP430_MACH_MSP430X; break;
    }

  elf_elfheader (abfd)->e_machine = EM_MSP430;
  elf_elfheader (abfd)->e_flags &= ~EF_MSP430_MACH;
  elf_elfheader (abfd)->e_flags |= val;
}

/* Set the right machine number.  */

static bfd_boolean
elf32_msp430_object_p (bfd * abfd)
{
  int e_set = bfd_mach_msp14;

  if (elf_elfheader (abfd)->e_machine == EM_MSP430
      || elf_elfheader (abfd)->e_machine == EM_MSP430_OLD)
    {
      int e_mach = elf_elfheader (abfd)->e_flags & EF_MSP430_MACH;

      switch (e_mach)
	{
	default:
	case E_MSP430_MACH_MSP430x11: e_set = bfd_mach_msp11; break;
	case E_MSP430_MACH_MSP430x11x1: e_set = bfd_mach_msp110; break;
	case E_MSP430_MACH_MSP430x12: e_set = bfd_mach_msp12; break;
	case E_MSP430_MACH_MSP430x13: e_set = bfd_mach_msp13; break;
	case E_MSP430_MACH_MSP430x14: e_set = bfd_mach_msp14; break;
	case E_MSP430_MACH_MSP430x15: e_set = bfd_mach_msp15; break;
	case E_MSP430_MACH_MSP430x16: e_set = bfd_mach_msp16; break;
	case E_MSP430_MACH_MSP430x31: e_set = bfd_mach_msp31; break;
	case E_MSP430_MACH_MSP430x32: e_set = bfd_mach_msp32; break;
	case E_MSP430_MACH_MSP430x33: e_set = bfd_mach_msp33; break;
	case E_MSP430_MACH_MSP430x41: e_set = bfd_mach_msp41; break;
	case E_MSP430_MACH_MSP430x42: e_set = bfd_mach_msp42; break;
	case E_MSP430_MACH_MSP430x43: e_set = bfd_mach_msp43; break;
	case E_MSP430_MACH_MSP430x44: e_set = bfd_mach_msp44; break;
	case E_MSP430_MACH_MSP430x20: e_set = bfd_mach_msp20; break;
	case E_MSP430_MACH_MSP430x22: e_set = bfd_mach_msp22; break;
	case E_MSP430_MACH_MSP430x23: e_set = bfd_mach_msp23; break;
	case E_MSP430_MACH_MSP430x24: e_set = bfd_mach_msp24; break;
	case E_MSP430_MACH_MSP430x26: e_set = bfd_mach_msp26; break;
	case E_MSP430_MACH_MSP430x46: e_set = bfd_mach_msp46; break;
	case E_MSP430_MACH_MSP430x47: e_set = bfd_mach_msp47; break;
	case E_MSP430_MACH_MSP430x54: e_set = bfd_mach_msp54; break;
	case E_MSP430_MACH_MSP430X: e_set = bfd_mach_msp430x; break;
	}
    }
  
  return bfd_default_set_arch_mach (abfd, bfd_arch_msp430, e_set);
}

/* These functions handle relaxing for the msp430.
   Relaxation required only in two cases:
    - Bad hand coding like jumps from one section to another or
      from file to file.
    - Sibling calls. This will affect only 'jump label' polymorph. Without
      relaxing this enlarges code by 2 bytes. Sibcalls implemented but
      do not work in gcc's port by the reason I do not know.
    - To convert out of range conditional jump instructions (found inside
      a function) into inverted jumps over an unconditional branch instruction.
   Anyway, if a relaxation required, user should pass -relax option to the
   linker.

   There are quite a few relaxing opportunities available on the msp430:

   ================================================================

   1. 3 words -> 1 word

   eq      ==      jeq label    		jne +4; br lab
   ne      !=      jne label    		jeq +4; br lab
   lt      <       jl  label    		jge +4; br lab
   ltu     <       jlo label    		lhs +4; br lab
   ge      >=      jge label    		jl  +4; br lab
   geu     >=      jhs label    		jlo +4; br lab

   2. 4 words -> 1 word

   ltn     <       jn                      jn  +2; jmp +4; br lab

   3. 4 words -> 2 words

   gt      >       jeq +2; jge label       jeq +6; jl  +4; br label
   gtu     >       jeq +2; jhs label       jeq +6; jlo +4; br label

   4. 4 words -> 2 words and 2 labels

   leu     <=      jeq label; jlo label    jeq +2; jhs +4; br label
   le      <=      jeq label; jl  label    jeq +2; jge +4; br label
   =================================================================

   codemap for first cases is (labels masked ):
	      eq:	0x2002,0x4010,0x0000 -> 0x2400
	      ne:	0x2402,0x4010,0x0000 -> 0x2000
	      lt:	0x3402,0x4010,0x0000 -> 0x3800
	      ltu:	0x2c02,0x4010,0x0000 -> 0x2800
	      ge:	0x3802,0x4010,0x0000 -> 0x3400
	      geu:	0x2802,0x4010,0x0000 -> 0x2c00

  second case:
	      ltn:	0x3001,0x3c02,0x4010,0x0000 -> 0x3000

  third case:
	      gt:	0x2403,0x3802,0x4010,0x0000 -> 0x2401,0x3400
	      gtu:	0x2403,0x2802,0x4010,0x0000 -> 0x2401,0x2c00

  fourth case:
	      leu:	0x2401,0x2c02,0x4010,0x0000 -> 0x2400,0x2800
	      le:	0x2401,0x3402,0x4010,0x0000 -> 0x2400,0x3800

  Unspecified case :)
	      jump:	0x4010,0x0000 -> 0x3c00.  */

#define NUMB_RELAX_CODES	12
static struct rcodes_s
{
  int f0, f1;			/* From code.  */
  int t0, t1;			/* To code.  */
  int labels;			/* Position of labels: 1 - one label at first
				   word, 2 - one at second word, 3 - two
				   labels at both.  */
  int cdx;			/* Words to match.  */
  int bs;			/* Shrink bytes.  */
  int off;			/* Offset from old label for new code.  */
  int ncl;			/* New code length.  */
} rcode[] =
{/*                               lab,cdx,bs,off,ncl */
  { 0x0000, 0x0000, 0x3c00, 0x0000, 1, 0, 2, 2,	 2},	/* jump */
  { 0x0000, 0x2002, 0x2400, 0x0000, 1, 1, 4, 4,	 2},	/* eq */
  { 0x0000, 0x2402, 0x2000, 0x0000, 1, 1, 4, 4,	 2},	/* ne */
  { 0x0000, 0x3402, 0x3800, 0x0000, 1, 1, 4, 4,	 2},	/* lt */
  { 0x0000, 0x2c02, 0x2800, 0x0000, 1, 1, 4, 4,	 2},	/* ltu */
  { 0x0000, 0x3802, 0x3400, 0x0000, 1, 1, 4, 4,	 2},	/* ge */
  { 0x0000, 0x2802, 0x2c00, 0x0000, 1, 1, 4, 4,	 2},	/* geu */
  { 0x3001, 0x3c02, 0x3000, 0x0000, 1, 2, 6, 6,	 2},	/* ltn */
  { 0x2403, 0x3802, 0x2401, 0x3400, 2, 2, 4, 6,	 4},	/* gt */
  { 0x2403, 0x2802, 0x2401, 0x2c00, 2, 2, 4, 6,	 4},	/* gtu */
  { 0x2401, 0x2c02, 0x2400, 0x2800, 3, 2, 4, 6,	 4},	/* leu , 2 labels */
  { 0x2401, 0x2c02, 0x2400, 0x2800, 3, 2, 4, 6,	 4},	/* le  , 2 labels */
  { 0, 	    0, 	    0, 	    0, 	    0, 0, 0, 0,  0}
};

/* Return TRUE if a symbol exists at the given address.  */

static bfd_boolean
msp430_elf_symbol_address_p (bfd * abfd,
			     asection * sec,
			     Elf_Internal_Sym * isym,
			     bfd_vma addr)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  Elf_Internal_Sym *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  /* Examine all the local symbols.  */
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
    if (isym->st_shndx == sec_shndx && isym->st_value == addr)
      return TRUE;

  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value == addr)
	return TRUE;
    }

  return FALSE;
}

/* Adjust all local symbols defined as '.section + 0xXXXX' (.section has
   sec_shndx) referenced from current and other sections.  */

static bfd_boolean
msp430_elf_relax_adjust_locals (bfd * abfd, asection * sec, bfd_vma addr,
				int count, unsigned int sec_shndx,
				bfd_vma toaddr)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *irel;
  Elf_Internal_Rela *irelend;
  Elf_Internal_Sym *isym;

  irel = elf_section_data (sec)->relocs;
  if (irel == NULL)
    return TRUE;

  irelend = irel + sec->reloc_count;
  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  
  for (;irel < irelend; irel++)
    {
      int sidx = ELF32_R_SYM(irel->r_info);
      Elf_Internal_Sym *lsym = isym + sidx;
      
      /* Adjust symbols referenced by .sec+0xXX */
      if (irel->r_addend > addr && irel->r_addend < toaddr 
	  && lsym->st_shndx == sec_shndx)
	irel->r_addend -= count;
    }
  
  return TRUE;
}

/* Delete some bytes from a section while relaxing.  */

static bfd_boolean
msp430_elf_relax_delete_bytes (bfd * abfd, asection * sec, bfd_vma addr,
			       int count)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel;
  Elf_Internal_Rela *irelend;
  bfd_vma toaddr;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;
  asection *p;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  contents = elf_section_data (sec)->this_hdr.contents;

  toaddr = sec->size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   (size_t) (toaddr - addr - count));
  sec->size -= count;

  /* Adjust all the relocs.  */
  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  for (; irel < irelend; irel++)
    {
      /* Get the new reloc address.  */
      if ((irel->r_offset > addr && irel->r_offset < toaddr))
	irel->r_offset -= count;
    }

  for (p = abfd->sections; p != NULL; p = p->next)
    msp430_elf_relax_adjust_locals (abfd,p,addr,count,sec_shndx,toaddr);
  
  /* Adjust the local symbols defined in this section.  */
  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
    if (isym->st_shndx == sec_shndx
	&& isym->st_value > addr && isym->st_value < toaddr)
      isym->st_value -= count;

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value > addr
	  && sym_hash->root.u.def.value < toaddr)
	sym_hash->root.u.def.value -= count;
    }

  return TRUE;
}

/* Insert two words into a section whilst relaxing.  */

static bfd_byte *
msp430_elf_relax_add_two_words (bfd * abfd, asection * sec, bfd_vma addr,
				int word1, int word2)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel;
  Elf_Internal_Rela *irelend;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;
  bfd_vma sec_end;
  asection *p;

  contents = elf_section_data (sec)->this_hdr.contents;
  sec_end = sec->size;

  /* Make space for the new words.  */
  contents = bfd_realloc (contents, sec_end + 4);
  memmove (contents + addr + 4, contents + addr, sec_end - addr);

  /* Insert the new words.  */
  bfd_put_16 (abfd, word1, contents + addr);
  bfd_put_16 (abfd, word2, contents + addr + 2);

  /* Update the section information.  */
  sec->size += 4;
  elf_section_data (sec)->this_hdr.contents = contents;  

  /* Adjust all the relocs.  */
  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  for (; irel < irelend; irel++)
    if ((irel->r_offset >= addr && irel->r_offset < sec_end))
      irel->r_offset += 4;

  /* Adjust the local symbols defined in this section.  */
  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
  for (p = abfd->sections; p != NULL; p = p->next)
    msp430_elf_relax_adjust_locals (abfd, p, addr, -4,
				    sec_shndx, sec_end);

  /* Adjust the global symbols affected by the move.  */
  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
    if (isym->st_shndx == sec_shndx
	&& isym->st_value >= addr && isym->st_value < sec_end)
      isym->st_value += 4;

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value >= addr
	  && sym_hash->root.u.def.value < sec_end)
	sym_hash->root.u.def.value += 4;
    }

  return contents;
}
   
static bfd_boolean
msp430_elf_relax_section (bfd * abfd, asection * sec,
			  struct bfd_link_info * link_info,
			  bfd_boolean * again)
{
  Elf_Internal_Shdr * symtab_hdr;
  Elf_Internal_Rela * internal_relocs;
  Elf_Internal_Rela * irel;
  Elf_Internal_Rela * irelend;
  bfd_byte *          contents = NULL;
  Elf_Internal_Sym *  isymbuf = NULL;


  /* Assume nothing changes.  */
  *again = FALSE;

  /* We don't have to do anything for a relocatable link, if
     this section does not have relocs, or if this is not a
     code section.  */
  if (link_info->relocatable
    || (sec->flags & SEC_RELOC) == 0
    || sec->reloc_count == 0 || (sec->flags & SEC_CODE) == 0)
    return TRUE;

  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs =
    _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL, link_info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;

  /* Walk through them looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;

  /* Do code size growing relocs first.  */
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;

      /* If this isn't something that can be relaxed, then ignore
         this reloc.  */
      if (uses_msp430x_relocs (abfd)
          && ELF32_R_TYPE (irel->r_info) == (int) R_MSP430X_10_PCREL)
	;
      else if (! uses_msp430x_relocs (abfd)
               && ELF32_R_TYPE (irel->r_info) == (int) R_MSP430_10_PCREL)
	;
      else
	continue;

      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else if (! bfd_malloc_and_get_section (abfd, sec, &contents))
	    goto error_return;
	}

      /* Read this BFD's local symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;
	  asection *sym_sec;

	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
	    sym_sec = bfd_und_section_ptr;
	  else if (isym->st_shndx == SHN_ABS)
	    sym_sec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    sym_sec = bfd_com_section_ptr;
	  else
	    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
		    + sym_sec->output_section->vma + sym_sec->output_offset);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);

	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    /* This appears to be a reference to an undefined
	       symbol.  Just ignore it--it will be caught by the
	       regular reloc processing.  */
	    continue;

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}

      /* For simplicity of coding, we are going to modify the section
         contents, the section relocs, and the BFD symbol table.  We
         must tell the rest of the code not to free up this
         information.  It would be possible to instead create a table
         of changes which have to be made, as is done in coff-mips.c;
         that would be more work, but would require less memory when
         the linker is run.  */

      bfd_signed_vma value = symval;
      int opcode;

      /* Compute the value that will be relocated.  */
      value += irel->r_addend;
      /* Convert to PC relative.  */
      value -= (sec->output_section->vma + sec->output_offset);
      value -= irel->r_offset;
      value -= 2;
      /* Scale.  */
      value >>= 1;

      /* If it is in range then no modifications are needed.  */
      if (value >= -512 && value <= 511)
	continue;

      /* Get the opcode.  */
      opcode = bfd_get_16 (abfd, contents + irel->r_offset);
	  
      /* Compute the new opcode.  We are going to convert:
	 J<cond> label
	 into:
	 J<inv-cond> 1f
	 BR[A] #label
	 1:                     */
      switch (opcode & 0xfc00)
	{
	case 0x3800: opcode = 0x3402; break; /* Jl  -> Jge +2 */  
	case 0x3400: opcode = 0x3802; break; /* Jge -> Jl  +2 */
	case 0x2c00: opcode = 0x2802; break; /* Jhs -> Jlo +2 */
	case 0x2800: opcode = 0x2c02; break; /* Jlo -> Jhs +2 */
	case 0x2400: opcode = 0x2002; break; /* Jeq -> Jne +2 */
	case 0x2000: opcode = 0x2402; break; /* jne -> Jeq +2 */
	case 0x3000: /* jn    */
	  /* There is no direct inverse of the Jn insn.
	     FIXME: we could do this as:
	        Jn 1f
	        br 2f
	     1: br label
	     2:                */
	  continue;
	default:
	  /* Not a conditional branch instruction.  */
	  /* fprintf (stderr, "unrecog: %x\n", opcode); */
	  goto error_return;
	}

      /* Note that we've changed the relocs, section contents, etc.  */
      elf_section_data (sec)->relocs = internal_relocs;
      elf_section_data (sec)->this_hdr.contents = contents;
      symtab_hdr->contents = (unsigned char *) isymbuf;

      /* Install the new opcode.  */
      bfd_put_16 (abfd, opcode, contents + irel->r_offset);

      /* Insert the new branch instruction.  */
      if (uses_msp430x_relocs (abfd))
	{
	  /* Insert an absolute branch (aka MOVA) instruction.  */	  
	  contents = msp430_elf_relax_add_two_words
	    (abfd, sec, irel->r_offset + 2, 0x0080, 0x0000);

	  /* Update the relocation to point to the inserted branch
	     instruction.  Note - we are changing a PC-relative reloc
	     into an absolute reloc, but this is OK because we have
	     arranged with the assembler to have the reloc's value be
	     a (local) symbol, not a section+offset value.  */
	  irel->r_offset += 2;
	  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				       R_MSP430X_ABS20_ADR_SRC);
	}
      else
	{
	  contents = msp430_elf_relax_add_two_words
	    (abfd, sec, irel->r_offset + 2, 0x4030, 0x0000);

	  /* See comment above about converting a 10-bit PC-rel
	     relocation into a 16-bit absolute relocation.  */
	  irel->r_offset += 4;
	  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				       R_MSP430_16);
	}

      /* Growing the section may mean that other
	 conditional branches need to be fixed.  */
      *again = TRUE;
    }

  if (! uses_msp430x_relocs (abfd))
    /* Now perform the relocations that shrink the code size.
       We only do this for non msp430x as gas only generates the RL
       reloc for the msp430.  */
    for (irel = internal_relocs; irel < irelend; irel++)
      {
	bfd_vma symval;

	/* Get the section contents if we haven't done so already.  */
	if (contents == NULL)
	  {
	    /* Get cached copy if it exists.  */
	    if (elf_section_data (sec)->this_hdr.contents != NULL)
	      contents = elf_section_data (sec)->this_hdr.contents;
	    else if (! bfd_malloc_and_get_section (abfd, sec, &contents))
	      goto error_return;
	  }

	/* Read this BFD's local symbols if we haven't done so already.  */
	if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	  {
	    isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	    if (isymbuf == NULL)
	      isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					      symtab_hdr->sh_info, 0,
					      NULL, NULL, NULL);
	    if (isymbuf == NULL)
	      goto error_return;
	  }

	/* Get the value of the symbol referred to by the reloc.  */
	if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	  {
	    /* A local symbol.  */
	    Elf_Internal_Sym *isym;
	    asection *sym_sec;

	    isym = isymbuf + ELF32_R_SYM (irel->r_info);
	    if (isym->st_shndx == SHN_UNDEF)
	      sym_sec = bfd_und_section_ptr;
	    else if (isym->st_shndx == SHN_ABS)
	      sym_sec = bfd_abs_section_ptr;
	    else if (isym->st_shndx == SHN_COMMON)
	      sym_sec = bfd_com_section_ptr;
	    else
	      sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	    symval = (isym->st_value
		      + sym_sec->output_section->vma + sym_sec->output_offset);
	  }
	else
	  {
	    unsigned long indx;
	    struct elf_link_hash_entry *h;

	    /* An external symbol.  */
	    indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	    h = elf_sym_hashes (abfd)[indx];
	    BFD_ASSERT (h != NULL);

	    if (h->root.type != bfd_link_hash_defined
		&& h->root.type != bfd_link_hash_defweak)
	      /* This appears to be a reference to an undefined
		 symbol.  Just ignore it--it will be caught by the
		 regular reloc processing.  */
	      continue;

	    symval = (h->root.u.def.value
		      + h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset);
	  }

	/* For simplicity of coding, we are going to modify the section
	   contents, the section relocs, and the BFD symbol table.  We
	   must tell the rest of the code not to free up this
	   information.  It would be possible to instead create a table
	   of changes which have to be made, as is done in coff-mips.c;
	   that would be more work, but would require less memory when
	   the linker is run.  */

	/* Try to turn a 16bit pc-relative branch into a 10bit pc-relative
	   branch.  */
	/* Paranoia? paranoia...  */      
	if (ELF32_R_TYPE (irel->r_info) == (int) R_MSP430_RL_PCREL)
	  {
	    bfd_vma value = symval;

	    /* Deal with pc-relative gunk.  */
	    value -= (sec->output_section->vma + sec->output_offset);
	    value -= irel->r_offset;
	    value += irel->r_addend;

	    /* See if the value will fit in 10 bits, note the high value is
	       1016 as the target will be two bytes closer if we are
	       able to relax.  */
	    if ((long) value < 1016 && (long) value > -1016)
	      {
		int code0 = 0, code1 = 0, code2 = 0;
		int i;
		struct rcodes_s *rx;

		/* Get the opcode.  */
		if (irel->r_offset >= 6)
		  code0 = bfd_get_16 (abfd, contents + irel->r_offset - 6);

		if (irel->r_offset >= 4)
		  code1 = bfd_get_16 (abfd, contents + irel->r_offset - 4);

		code2 = bfd_get_16 (abfd, contents + irel->r_offset - 2);

		if (code2 != 0x4010)
		  continue;

		/* Check r4 and r3.  */
		for (i = NUMB_RELAX_CODES - 1; i >= 0; i--)
		  {
		    rx = &rcode[i];
		    if (rx->cdx == 2 && rx->f0 == code0 && rx->f1 == code1)
		      break;
		    else if (rx->cdx == 1 && rx->f1 == code1)
		      break;
		    else if (rx->cdx == 0)	/* This is an unconditional jump.  */
		      break;
		  }

		/* Check labels:
		   .Label0:       ; we do not care about this label
		   jeq    +6
		   .Label1:       ; make sure there is no label here
		   jl     +4
		   .Label2:       ; make sure there is no label here
		   br .Label_dst

		   So, if there is .Label1 or .Label2 we cannot relax this code.
		   This actually should not happen, cause for relaxable
		   instructions we use RL_PCREL reloc instead of 16_PCREL.
		   Will change this in the future. */

		if (rx->cdx > 0
		    && msp430_elf_symbol_address_p (abfd, sec, isymbuf,
						    irel->r_offset - 2))
		  continue;
		if (rx->cdx > 1
		    && msp430_elf_symbol_address_p (abfd, sec, isymbuf,
						    irel->r_offset - 4))
		  continue;

		/* Note that we've changed the relocs, section contents, etc.  */
		elf_section_data (sec)->relocs = internal_relocs;
		elf_section_data (sec)->this_hdr.contents = contents;
		symtab_hdr->contents = (unsigned char *) isymbuf;

		/* Fix the relocation's type.  */
		if (uses_msp430x_relocs (abfd))
		  {
		    if (rx->labels == 3)	/* Handle special cases.  */
		      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
						   R_MSP430X_2X_PCREL);
		    else
		      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
						   R_MSP430X_10_PCREL);
		  }
		else
		  {
		    if (rx->labels == 3)	/* Handle special cases.  */
		      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
						   R_MSP430_2X_PCREL);
		    else
		      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
						   R_MSP430_10_PCREL);
		  }

		/* Fix the opcode right way.  */
		bfd_put_16 (abfd, rx->t0, contents + irel->r_offset - rx->off);
		if (rx->t1)
		  bfd_put_16 (abfd, rx->t1,
			      contents + irel->r_offset - rx->off + 2);

		/* Delete bytes. */
		if (!msp430_elf_relax_delete_bytes (abfd, sec,
						    irel->r_offset - rx->off +
						    rx->ncl, rx->bs))
		  goto error_return;

		/* Handle unconditional jumps.  */
		if (rx->cdx == 0)
		  irel->r_offset -= 2;

		/* That will change things, so, we should relax again.
		   Note that this is not required, and it may be slow.  */
		*again = TRUE;
	      }
	  }
      }

  if (isymbuf != NULL && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (!link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (!link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
    }

  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return TRUE;

error_return:
  if (isymbuf != NULL && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return FALSE;
}

/* Handle an MSP430 specific section when reading an object file.
   This is called when bfd_section_from_shdr finds a section with
   an unknown type.  */

static bfd_boolean
elf32_msp430_section_from_shdr (bfd *abfd,
				Elf_Internal_Shdr * hdr,
				const char *name,
				int shindex)
{
  switch (hdr->sh_type)
    {
    case SHT_MSP430_SEC_FLAGS:
    case SHT_MSP430_SYM_ALIASES:
    case SHT_MSP430_ATTRIBUTES:
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
    default:
      return FALSE;
    }
}

static bfd_boolean
elf32_msp430_obj_attrs_handle_unknown (bfd *abfd, int tag)
{
  _bfd_error_handler
    (_("Warning: %B: Unknown MSPABI object attribute %d"),
     abfd, tag);
  return TRUE;
}

/* Determine whether an object attribute tag takes an integer, a
   string or both.  */

static int
elf32_msp430_obj_attrs_arg_type (int tag)
{
  if (tag == Tag_compatibility)
    return ATTR_TYPE_FLAG_INT_VAL | ATTR_TYPE_FLAG_STR_VAL;

  if (tag < 32)
    return ATTR_TYPE_FLAG_INT_VAL;

  return (tag & 1) != 0 ? ATTR_TYPE_FLAG_STR_VAL : ATTR_TYPE_FLAG_INT_VAL;
}

static inline const char *
isa_type (int isa)
{
  switch (isa)
    {
    case 1: return "MSP430";
    case 2: return "MSP430X";
    default: return "unknown";
    }
}

static inline const char *
code_model (int model)
{
  switch (model)
    {
    case 1: return "small";
    case 2: return "large";
    default: return "unknown";
    }
}

static inline const char *
data_model (int model)
{
  switch (model)
    {
    case 1: return "small";
    case 2: return "large";
    case 3: return "restricted large";
    default: return "unknown";
    }
}

/* Merge MSPABI object attributes from IBFD into OBFD.
   Raise an error if there are conflicting attributes.  */

static bfd_boolean
elf32_msp430_merge_mspabi_attributes (bfd *ibfd, bfd *obfd)
{
  obj_attribute *in_attr;
  obj_attribute *out_attr;
  bfd_boolean result = TRUE;
  static bfd * first_input_bfd = NULL;

  /* Skip linker created files.  */
  if (ibfd->flags & BFD_LINKER_CREATED)
    return TRUE;

  /* If this is the first real object just copy the attributes.  */
  if (!elf_known_obj_attributes_proc (obfd)[0].i)
    {
      _bfd_elf_copy_obj_attributes (ibfd, obfd);

      out_attr = elf_known_obj_attributes_proc (obfd);

      /* Use the Tag_null value to indicate that
	 the attributes have been initialized.  */
      out_attr[0].i = 1;

      first_input_bfd = ibfd;
      return TRUE;
    }

  in_attr = elf_known_obj_attributes_proc (ibfd);
  out_attr = elf_known_obj_attributes_proc (obfd);

  /* The ISAs must be the same.  */
  if (in_attr[OFBA_MSPABI_Tag_ISA].i != out_attr[OFBA_MSPABI_Tag_ISA].i)
    {
      _bfd_error_handler
	(_("error: %B uses %s instructions but %B uses %s"),
	 ibfd, first_input_bfd,
	 isa_type (in_attr[OFBA_MSPABI_Tag_ISA].i),
	 isa_type (out_attr[OFBA_MSPABI_Tag_ISA].i));
      result = FALSE;
    }

  /* The code models must be the same.  */
  if (in_attr[OFBA_MSPABI_Tag_Code_Model].i !=
      out_attr[OFBA_MSPABI_Tag_Code_Model].i)
    {
      _bfd_error_handler
	(_("error: %B uses the %s code model whereas %B uses the %s code model"),
	 ibfd, first_input_bfd,
	 code_model (in_attr[OFBA_MSPABI_Tag_Code_Model].i),
	 code_model (out_attr[OFBA_MSPABI_Tag_Code_Model].i));
      result = FALSE;
    }

  /* The large code model is only supported by the MSP430X.  */
  if (in_attr[OFBA_MSPABI_Tag_Code_Model].i == 2
      && out_attr[OFBA_MSPABI_Tag_ISA].i != 2)
    {
      _bfd_error_handler
	(_("error: %B uses the large code model but %B uses MSP430 instructions"),
	 ibfd, first_input_bfd);
      result = FALSE;
    }

  /* The data models must be the same.  */
  if (in_attr[OFBA_MSPABI_Tag_Data_Model].i !=
      out_attr[OFBA_MSPABI_Tag_Data_Model].i)
    {
      _bfd_error_handler
	(_("error: %B uses the %s data model whereas %B uses the %s data model"),
	 ibfd, first_input_bfd,
	 data_model (in_attr[OFBA_MSPABI_Tag_Data_Model].i),
	 data_model (out_attr[OFBA_MSPABI_Tag_Data_Model].i));
      result = FALSE;
    }

  /* The small code model requires the use of the small data model.  */
  if (in_attr[OFBA_MSPABI_Tag_Code_Model].i == 1
      && out_attr[OFBA_MSPABI_Tag_Data_Model].i != 1)
    {
      _bfd_error_handler
	(_("error: %B uses the small code model but %B uses the %s data model"),
	 ibfd, first_input_bfd,
	 data_model (out_attr[OFBA_MSPABI_Tag_Data_Model].i));
      result = FALSE;
    }

  /* The large data models are only supported by the MSP430X.  */
  if (in_attr[OFBA_MSPABI_Tag_Data_Model].i > 1
      && out_attr[OFBA_MSPABI_Tag_ISA].i != 2)
    {
      _bfd_error_handler
	(_("error: %B uses the %s data model but %B only uses MSP430 instructions"),
	 ibfd, first_input_bfd,
	 data_model (in_attr[OFBA_MSPABI_Tag_Data_Model].i));
      result = FALSE;
    }
  
  return result;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
elf32_msp430_merge_private_bfd_data (bfd * ibfd, bfd * obfd)
{
  /* Make sure that the machine number reflects the most
     advanced version of the MSP architecture required.  */
#define max(a,b) ((a) > (b) ? (a) : (b))
  if (bfd_get_mach (ibfd) != bfd_get_mach (obfd))
    bfd_default_set_arch_mach (obfd, bfd_get_arch (obfd),
			       max (bfd_get_mach (ibfd), bfd_get_mach (obfd)));
#undef max

  return elf32_msp430_merge_mspabi_attributes (ibfd, obfd);
}

/* Copy backend specific data from one object module to another.  */

static bfd_boolean
elf32_msp430_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  /* Copy object attributes.  */
  _bfd_elf_copy_obj_attributes (ibfd, obfd);

  return TRUE;
}

static bfd_boolean
msp430_elf_is_target_special_symbol (bfd *abfd, asymbol *sym)
{
  return _bfd_elf_is_local_label_name (abfd, sym->name);
}

/* This is gross.  The MSP430 EABI says that (sec 11.5):

     "An implementation may choose to use Rel or Rela
      type relocations for other relocations."

   But it also says that:
   
     "Certain relocations are identified as Rela only. [snip]
      Where Rela is specified, an implementation must honor
      this requirement."

  There is one relocation marked as requiring RELA - R_MSP430_ABS_HI16 - but
  to keep things simple we choose to use RELA relocations throughout.  The
  problem is that the TI compiler generates REL relocations, so we have to
  be able to accept those as well.  */

#define elf_backend_may_use_rel_p  1
#define elf_backend_may_use_rela_p 1
#define elf_backend_default_use_rela_p 1

#undef  elf_backend_obj_attrs_vendor
#define elf_backend_obj_attrs_vendor		"mspabi"
#undef  elf_backend_obj_attrs_section
#define elf_backend_obj_attrs_section		".MSP430.attributes"
#undef  elf_backend_obj_attrs_section_type
#define elf_backend_obj_attrs_section_type	SHT_MSP430_ATTRIBUTES
#define elf_backend_section_from_shdr  		elf32_msp430_section_from_shdr
#define elf_backend_obj_attrs_handle_unknown 	elf32_msp430_obj_attrs_handle_unknown
#undef  elf_backend_obj_attrs_arg_type
#define elf_backend_obj_attrs_arg_type		elf32_msp430_obj_attrs_arg_type
#define bfd_elf32_bfd_copy_private_bfd_data	elf32_msp430_copy_private_bfd_data
#define bfd_elf32_bfd_merge_private_bfd_data	elf32_msp430_merge_private_bfd_data

#define ELF_ARCH		bfd_arch_msp430
#define ELF_MACHINE_CODE	EM_MSP430
#define ELF_MACHINE_ALT1	EM_MSP430_OLD
#define ELF_MAXPAGESIZE		4
#define	ELF_OSABI		ELFOSABI_STANDALONE

#define TARGET_LITTLE_SYM       bfd_elf32_msp430_vec
#define TARGET_LITTLE_NAME	"elf32-msp430"

#define elf_info_to_howto	             msp430_info_to_howto_rela
#define elf_info_to_howto_rel	             NULL
#define elf_backend_relocate_section         elf32_msp430_relocate_section
#define elf_backend_check_relocs             elf32_msp430_check_relocs
#define elf_backend_can_gc_sections          1
#define elf_backend_final_write_processing   bfd_elf_msp430_final_write_processing
#define elf_backend_object_p		     elf32_msp430_object_p
#define elf_backend_post_process_headers     _bfd_elf_set_osabi
#define bfd_elf32_bfd_relax_section	     msp430_elf_relax_section
#define bfd_elf32_bfd_is_target_special_symbol	msp430_elf_is_target_special_symbol

#undef  elf32_bed
#define elf32_bed		elf32_msp430_bed

#include "elf32-target.h"

/* The TI compiler sets the OSABI field to ELFOSABI_NONE.  */
#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM       bfd_elf32_msp430_ti_vec

#undef  elf32_bed
#define elf32_bed		elf32_msp430_ti_bed

#undef	ELF_OSABI		
#define	ELF_OSABI		ELFOSABI_NONE

static const struct bfd_elf_special_section msp430_ti_elf_special_sections[] =
{
  /* prefix, prefix_length,        suffix_len, type,               attributes.  */
  { STRING_COMMA_LEN (".TI.symbol.alias"),  0, SHT_MSP430_SYM_ALIASES, 0 },
  { STRING_COMMA_LEN (".TI.section.flags"), 0, SHT_MSP430_SEC_FLAGS,   0 },
  { STRING_COMMA_LEN ("_TI_build_attrib"),  0, SHT_MSP430_ATTRIBUTES,  0 },
  { NULL, 0,                                0, 0,                      0 }
};

#include "elf32-target.h"
@


1.28
log
@	* archures.c: Add some more MSP430 machine numbers.
	* config.bfd (msp430): Define targ_selvecs.
	* configure.in: Add bfd_elf32_msp430_ti_vec.
	* cpu-msp430.c: Add some more MSP430 machine numbers.
	* elf32-msp430.c Add support for MSP430X relocations.
	Add support for TI compiler generated relocations.
	Add support for sym_diff relocations.
	Add support for relaxing out of range short branches into long
	branches.
	Add support for MSP430 attribute section.
	* reloc.c: Add MSP430X relocations.
	* targets.c: Add bfd_elf32_msp430_ti_vec.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.
	* libbfd.h: Regenerate.

	* readelf.c: Add support for MSP430X architecture.

	* readelf.exp: Expect -wi test to fail for the MSP430.

	* config/tc-msp430.c: Add support for the MSP430X architecture.
	Add code to insert a NOP instruction after any instruction that
	might change the interrupt state.
	Add support for the LARGE memory model.
	Add code to initialise the .MSP430.attributes section.
	* config/tc-msp430.h: Add support for the MSP430X architecture.
	* doc/c-msp430.texi: Document the new -mL and -mN command line
	options.
	* NEWS: Mention support for the MSP430X architecture.

	* gas/all/gas.exp: Skip the DIFF1 test for the MSP430.
	Expect the FORWARD test to pass for the MSP430.
	Skip the REDEF tests for the MSP430.
	Expect the 930509A test to fail for the MSP430.
	* gas/all/sleb128-4.d: Skip for the MSP430.
	* gas/elf/elf.exp: Set target_machine to msp430 for the MSP430.
	Skip the EHOPT0 test for the MSP430.
	Skip the REDEF and EQU-RELOC tests for the MSP430.
	* gas/elf/section2.e-msp430: New file.
	* gas/lns/lns-big-delta.d: Remove expectation of 20-bit
	addresses.
	* gas/lns/lns.exp: Use alternate LNS COMMON test for the MSP430.
	* gas/msp430/msp430x.s: New test.
	* gas/msp430/msp430x.d: Expected disassembly.
	* gas/msp430/msp430.exp: Run new test.
	* gas/msp430/opcode.d: Update expected disassembly.

	* msp430.h: Add MSP430X relocs.
	Add some more MSP430 machine numbers.
	Add values used by .MSP430.attributes section.

	* msp430.h: Add patterns for MSP430X instructions.

	* Makefile.am: Add emsp430X.c
	* Makefine.in: Regenerate.
	* configure.tgt (msp430): Add msp430X emulation.
	* ldmain.c (multiple_definition): Only disable relaxation if it
	was enabled by the user.
	* ldmain.h (RELAXATION_ENABLED_BY_USER): New macro.
	* emulparams/msp430all.sh: Add support for MSP430X.
	* emultempl/generic.em: (before_parse): Enable relaxation for the
	MSP430.
	* scripttempl/msp430.sc: Reorganize sections.  Add .rodata
	section.
	* scripttempl/msp430_3.sc: Likewise.
	* NEWS: Mention support for MSP430X.

	* ld-elf/flags1.d: Expect this test to pass on the MSP430.
	* ld-elf/init-fini-arrays.d: Expect this test to fail on the
	MSP430.
	* ld-elf/merge.d: Expect this test to pass on the MSP430.
	* ld-elf/sec64k.exp: Skip these tests for the MSP430.
	* ld-gc/pr13683.d: Expect this test to fail on the MSP430.
	* ld-srec/srec.exp: Expect these tests to fail on the MSP430.
	* ld-undefined/undefined.exp: Expect the UNDEFINED LINE test to
	fail on the MSP430.

	* msp430-dis.c: Add support for MSP430X instructions.
@
text
@d59 1
a59 1
  /* A 13 bit PC relative relocation.  */
d70 2
a71 2
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
d134 1
a134 1
  /* A 13 bit PC relative relocation for complicated polymorphs.  */
d145 2
a146 2
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
d452 1
a452 1
  /* A 13 bit PC relative relocation.  */
d463 2
a464 2
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
d467 1
a467 1
  /* A 13 bit PC relative relocation for complicated polymorphs.  */
d478 2
a479 2
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
@


1.27
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d2 1
a2 2
    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2010, 2012
    Free Software Foundation, Inc.
a28 3
/* Use RELA instead of REL.  */
#undef USE_REL

d68 1
a68 1
	 "R_MSP430_13_PCREL",	/* name */
d89 1
a89 1
  /* A 16 bit absolute relocation for command address.  */
d163 334
d508 49
a556 12
  {
    {BFD_RELOC_NONE,                 R_MSP430_NONE},
    {BFD_RELOC_32,                   R_MSP430_32},
    {BFD_RELOC_MSP430_10_PCREL,      R_MSP430_10_PCREL},
    {BFD_RELOC_16,                   R_MSP430_16_BYTE},
    {BFD_RELOC_MSP430_16_PCREL,      R_MSP430_16_PCREL},
    {BFD_RELOC_MSP430_16,            R_MSP430_16},
    {BFD_RELOC_MSP430_16_PCREL_BYTE, R_MSP430_16_PCREL_BYTE},
    {BFD_RELOC_MSP430_16_BYTE,       R_MSP430_16_BYTE},
    {BFD_RELOC_MSP430_2X_PCREL,      R_MSP430_2X_PCREL},
    {BFD_RELOC_MSP430_RL_PCREL,      R_MSP430_RL_PCREL}
  };
d564 12
a575 3
  for (i = 0; i < ARRAY_SIZE (msp430_reloc_map); i++)
    if (msp430_reloc_map[i].bfd_reloc_val == code)
      return &elf_msp430_howto_table[msp430_reloc_map[i].elf_reloc_val];
d586 17
a602 7
  for (i = 0;
       i < (sizeof (elf_msp430_howto_table)
	    / sizeof (elf_msp430_howto_table[0]));
       i++)
    if (elf_msp430_howto_table[i].name != NULL
	&& strcasecmp (elf_msp430_howto_table[i].name, r_name) == 0)
      return &elf_msp430_howto_table[i];
d617 8
d677 7
a683 3
msp430_final_link_relocate (reloc_howto_type * howto, bfd * input_bfd,
			    asection * input_section, bfd_byte * contents,
			    Elf_Internal_Rela * rel, bfd_vma relocation)
d685 4
d692 13
d706 1
a706 1
  switch (howto->type)
d708 376
d1101 16
a1116 2
	return bfd_reloc_overflow;

d1197 21
a1217 5
    default:
      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, rel->r_addend);
    }
d1257 6
a1262 1
      howto = elf_msp430_howto_table + r_type;
d1275 1
a1275 1
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
d1285 1
d1296 1
a1296 1
				      contents, rel, relocation);
d1306 1
a1306 1
		  (info, (h ? &h->root : NULL), name, howto->name,
d1317 1
a1317 1
	      msg = _("internal error: out of range error");
d1359 23
a1381 55
    case bfd_mach_msp110:
      val = E_MSP430_MACH_MSP430x11x1;
      break;

    case bfd_mach_msp11:
      val = E_MSP430_MACH_MSP430x11;
      break;

    case bfd_mach_msp12:
      val = E_MSP430_MACH_MSP430x12;
      break;

    case bfd_mach_msp13:
      val = E_MSP430_MACH_MSP430x13;
      break;

    case bfd_mach_msp14:
      val = E_MSP430_MACH_MSP430x14;
      break;

    case bfd_mach_msp15:
      val = E_MSP430_MACH_MSP430x15;
      break;

    case bfd_mach_msp16:
      val = E_MSP430_MACH_MSP430x16;
      break;

    case bfd_mach_msp31:
      val = E_MSP430_MACH_MSP430x31;
      break;

    case bfd_mach_msp32:
      val = E_MSP430_MACH_MSP430x32;
      break;

    case bfd_mach_msp33:
      val = E_MSP430_MACH_MSP430x33;
      break;

    case bfd_mach_msp41:
      val = E_MSP430_MACH_MSP430x41;
      break;

    case bfd_mach_msp42:
      val = E_MSP430_MACH_MSP430x42;
      break;

    case bfd_mach_msp43:
      val = E_MSP430_MACH_MSP430x43;
      break;

    case bfd_mach_msp44:
      val = E_MSP430_MACH_MSP430x44;
      break;
d1404 23
a1426 55
	case E_MSP430_MACH_MSP430x11:
	  e_set = bfd_mach_msp11;
	  break;

	case E_MSP430_MACH_MSP430x11x1:
	  e_set = bfd_mach_msp110;
	  break;

	case E_MSP430_MACH_MSP430x12:
	  e_set = bfd_mach_msp12;
	  break;

	case E_MSP430_MACH_MSP430x13:
	  e_set = bfd_mach_msp13;
	  break;

	case E_MSP430_MACH_MSP430x14:
	  e_set = bfd_mach_msp14;
	  break;

	case E_MSP430_MACH_MSP430x15:
	  e_set = bfd_mach_msp15;
	  break;

	case E_MSP430_MACH_MSP430x16:
	  e_set = bfd_mach_msp16;
	  break;

	case E_MSP430_MACH_MSP430x31:
	  e_set = bfd_mach_msp31;
	  break;

	case E_MSP430_MACH_MSP430x32:
	  e_set = bfd_mach_msp32;
	  break;

	case E_MSP430_MACH_MSP430x33:
	  e_set = bfd_mach_msp33;
	  break;

	case E_MSP430_MACH_MSP430x41:
	  e_set = bfd_mach_msp41;
	  break;

	case E_MSP430_MACH_MSP430x42:
	  e_set = bfd_mach_msp42;
	  break;

	case E_MSP430_MACH_MSP430x43:
	  e_set = bfd_mach_msp43;
	  break;

	case E_MSP430_MACH_MSP430x44:
	  e_set = bfd_mach_msp44;
	  break;
d1429 1
a1429 1

d1440 2
d1565 3
a1567 2
/* Adjust all local symbols defined as '.section + 0xXXXX' (.section has sec_shndx)
    referenced from current and other sections.  */
d1569 3
a1571 2
msp430_elf_relax_adjust_locals(bfd * abfd, asection * sec, bfd_vma addr,
    int count, unsigned int sec_shndx, bfd_vma toaddr)
d1579 3
d1585 2
a1586 2

  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
d1590 1
a1590 1

d1592 1
a1592 1
      if (irel->r_addend > addr && irel->r_addend < toaddr
d1596 1
a1596 1

d1636 1
a1636 1
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
d1644 2
a1645 2
    msp430_elf_relax_adjust_locals(abfd,p,addr,count,sec_shndx,toaddr);

d1674 76
d1762 1
d1770 2
a1771 2
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0 || (sec->flags & SEC_CODE) == 0)
d1784 2
d1792 7
a1798 1
      if (ELF32_R_TYPE (irel->r_info) != (int) R_MSP430_RL_PCREL)
d1872 26
a1897 4
      /* Try to turn a 16bit pc-relative branch into a 10bit pc-relative
         branch.  */
      /* Paranoia? paranoia...  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_MSP430_RL_PCREL)
d1899 19
a1917 1
	  bfd_vma value = symval;
d1919 4
a1922 13
	  /* Deal with pc-relative gunk.  */
	  value -= (sec->output_section->vma + sec->output_offset);
	  value -= irel->r_offset;
	  value += irel->r_addend;

	  /* See if the value will fit in 10 bits, note the high value is
	     1016 as the target will be two bytes closer if we are
	     able to relax. */
	  if ((long) value < 1016 && (long) value > -1016)
	    {
	      int code0 = 0, code1 = 0, code2 = 0;
	      int i;
	      struct rcodes_s *rx;
d1924 2
a1925 3
	      /* Get the opcode.  */
	      if (irel->r_offset >= 6)
		code0 = bfd_get_16 (abfd, contents + irel->r_offset - 6);
d1927 20
a1946 2
	      if (irel->r_offset >= 4)
		code1 = bfd_get_16 (abfd, contents + irel->r_offset - 4);
d1948 6
a1953 1
	      code2 = bfd_get_16 (abfd, contents + irel->r_offset - 2);
d1955 4
a1958 2
	      if (code2 != 0x4010)
		continue;
d1960 123
a2082 11
	      /* Check r4 and r3.  */
	      for (i = NUMB_RELAX_CODES - 1; i >= 0; i--)
		{
		  rx = &rcode[i];
		  if (rx->cdx == 2 && rx->f0 == code0 && rx->f1 == code1)
		    break;
		  else if (rx->cdx == 1 && rx->f1 == code1)
		    break;
		  else if (rx->cdx == 0)	/* This is an unconditional jump.  */
		    break;
		}
d2084 1
a2084 1
	      /* Check labels:
d2086 1
a2086 1
		      jeq    +6
d2088 1
a2088 1
		      jl     +4
d2090 1
a2090 1
		      br .Label_dst
d2092 61
a2152 49
	         So, if there is .Label1 or .Label2 we cannot relax this code.
	         This actually should not happen, cause for relaxable
		 instructions we use RL_PCREL reloc instead of 16_PCREL.
		 Will change this in the future. */

	      if (rx->cdx > 0
		  && msp430_elf_symbol_address_p (abfd, sec, isymbuf,
						  irel->r_offset - 2))
		continue;
	      if (rx->cdx > 1
		  && msp430_elf_symbol_address_p (abfd, sec, isymbuf,
						  irel->r_offset - 4))
		continue;

	      /* Note that we've changed the relocs, section contents, etc.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      elf_section_data (sec)->this_hdr.contents = contents;
	      symtab_hdr->contents = (unsigned char *) isymbuf;

	      /* Fix the relocation's type.  */
	      if (rx->labels == 3)	/* Handle special cases.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					   R_MSP430_2X_PCREL);
	      else
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					   R_MSP430_10_PCREL);

	      /* Fix the opcode right way.  */
	      bfd_put_16 (abfd, rx->t0, contents + irel->r_offset - rx->off);
	      if (rx->t1)
		bfd_put_16 (abfd, rx->t1,
			    contents + irel->r_offset - rx->off + 2);

	      /* Delete bytes. */
	      if (!msp430_elf_relax_delete_bytes (abfd, sec,
						  irel->r_offset - rx->off +
						  rx->ncl, rx->bs))
		goto error_return;

	      /* Handle unconditional jumps.  */
	      if (rx->cdx == 0)
		irel->r_offset -= 2;

	      /* That will change things, so, we should relax again.
	         Note that this is not required, and it may be slow.  */
	      *again = TRUE;
	    }
	}
    }
d2196 248
d2448 1
a2448 1
#define ELF_MAXPAGESIZE		1
d2463 25
@


1.26
log
@Fix spelling typo.
@
text
@d269 4
@


1.25
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d342 1
a343 1
    case R_MSP430_RL_PCREL:
d670 1
a670 1
    - Sibling calls. This will affect onlu 'jump label' polymorph. Without
d797 1
a797 1
    referenced from current and other sections */
a899 1

@


1.24
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d811 1
a811 1
  
d816 1
a816 1
      
d818 1
a818 1
      if (irel->r_addend > addr && irel->r_addend < toaddr 
d822 1
a822 1
  
d871 1
a871 1
  
d1016 1
a1016 1
      /* Paranoia? paranoia...  */      
@


1.23
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d459 1
a459 1
					 rel, relend, howto, contents);
@


1.22
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d2 1
a2 1
    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2010
d457 1
a457 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.22.6.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d457 1
a457 1
      if (sec != NULL && discarded_section (sec))
@


1.21
log
@fix set but unused variable warnings
@
text
@d458 2
a459 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.20
log
@	* elf-m10300.c (mn10300_elf_check_relocs): Delete dead code.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-bfin.c (bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (_frvfdpic_check_discarded_relocs): Likewise.
	(elf32_frv_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	(score_elf_local_relocation_p): Likewise.
	(_bfd_score_elf_relocate_section): Likewise.
	(score_elf_final_link_relocate): Likewise.
@
text
@d2 1
a2 1
    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007
d432 1
a432 1
      howto = elf_msp430_howto_table + ELF32_R_TYPE (rel->r_info);
a843 1
  Elf_Internal_Rela *irelalign;
a855 4
  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */

  irelalign = NULL;
@


1.19
log
@Switch sources over to use the GPL version 3
@
text
@d244 1
a244 1
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
a252 4
  sym_hashes_end =
      sym_hashes + symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
@


1.18
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
    the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.17
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d22 1
a23 1
#include "sysdep.h"
@


1.16
log
@2007-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3826
	* elf-bfd.h (elf_backend_data): Add elf_osabi.
	(_bfd_elf_set_osabi): New.

	* elf.c (_bfd_elf_set_osabi): New.

	* elf32-hppa.c (elf32_hppa_post_process_headers): Removed.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.
	(ELF_OSABI): Properly defined for each target.

	* elf32-i370.c (i370_elf_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf32-i386.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf_i386_post_process_headers): Set EI_OSABI with elf_osabi.

	* elf32-msp430.c (elf32_msp430_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-alpha.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf64_alpha_fbsd_post_process_headers): Set EI_OSABI with
	elf_osabi.

	* elf64-hppa.c (elf64_hppa_post_process_headers): Set EI_OSABI
	with elf_osabi.
	(ELF_OSABI): Properly defined for each target.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi for Linux.

	* elf64-sparc.c (elf64_sparc_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-x86-64.c (elf64_x86_64_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elfcode.h (elf_object_p): Match the ELFOSABI_NONE ELF target
	with any ELF target of the compatible machine for which we do not
	have a specific backend.

	* elfxx-ia64.c (elfNN_hpux_post_process_headers): Set EI_OSABI
	with elf_osabi.

	* elfxx-target.h (ELF_OSABI): Default to ELFOSABI_NONE.
	(elfNN_bed): Initialize elf_osabi with ELF_OSABI.
@
text
@d203 17
@


1.15
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@a658 15
static void
elf32_msp430_post_process_headers (bfd * abfd,
				   struct bfd_link_info * link_info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */

  i_ehdrp = elf_elfheader (abfd);

#ifndef ELFOSABI_STANDALONE
#define ELFOSABI_STANDALONE	255
#endif

  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_STANDALONE;
}

d1162 1
d1174 1
a1174 1
#define elf_backend_post_process_headers     elf32_msp430_post_process_headers
@


1.14
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2 1
a2 1
    Copyright (C) 2002, 2003, 2004, 2005, 2006
a415 2
      /* This is a final link.  */

d443 14
@


1.13
log
@2005-09-01  Dmitry Diky <diwil@@spec.ru>

	* elf32-msp430.c (msp430_elf_relax_delete_bytes): Do not adjust
	local symbols and move it to
	(msp430_elf_relax_adjust_locals): New function - walk over the
	sections in the bfd and adjust relocations as necessary.
@
text
@d2 2
a3 1
    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
a216 42
static asection *
elf32_msp430_gc_mark_hook (asection * sec,
			   struct bfd_link_info * info ATTRIBUTE_UNUSED,
			   Elf_Internal_Rela * rel,
			   struct elf_link_hash_entry * h,
			   Elf_Internal_Sym * sym)
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

static bfd_boolean
elf32_msp430_gc_sweep_hook (bfd * abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info * info ATTRIBUTE_UNUSED,
			    asection * sec ATTRIBUTE_UNUSED,
			    const Elf_Internal_Rela * relocs ATTRIBUTE_UNUSED)
{
  /* We don't use got and plt entries for msp430.  */
  return TRUE;
}

a1171 2
#define elf_backend_gc_mark_hook             elf32_msp430_gc_mark_hook
#define elf_backend_gc_sweep_hook            elf32_msp430_gc_sweep_hook
@


1.12
log
@2005-08-12  Dmitry Diky  <diwil@@spec.ru>

	* elf32-msp430.c (msp430_elf_relax_delete_bytes): Adjust relocations
	referenced by .section + DISPLACEMENT.
@
text
@d833 30
d881 1
a905 3
      int sidx = ELF32_R_SYM(irel->r_info);
      Elf_Internal_Sym *lsym = isym + sidx;
      
a908 5

      /* Adjust symbols referenced by .sec+0xXX */
      if (irel->r_addend > addr && irel->r_addend < toaddr 
	  && lsym->st_shndx == sec_shndx)
	irel->r_addend -= count;
d911 3
@


1.11
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d871 2
d874 13
a886 3
    /* Get the new reloc address.  */
    if ((irel->r_offset > addr && irel->r_offset < toaddr))
      irel->r_offset -= count;
@


1.10
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d291 6
a296 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.9
log
@Update the FSF address in the copyright/GPL notice
@
text
@d19 1
a19 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.8
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d19 1
a19 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.7
log
@Apply Dmitry Diky's patches to add relaxation to msp430.
@
text
@d492 3
a494 2
		  (info, name, howto->name, (bfd_vma) 0,
		   input_bfd, input_section, rel->r_offset);
@


1.6
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@a27 35
static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));

static void msp430_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));

static asection *elf32_msp430_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));

static bfd_boolean elf32_msp430_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));

static bfd_boolean elf32_msp430_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));

static bfd_reloc_status_type msp430_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));

static bfd_boolean elf32_msp430_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));

static void bfd_elf_msp430_final_write_processing
  PARAMS ((bfd *, bfd_boolean));

static bfd_boolean elf32_msp430_object_p
  PARAMS ((bfd *));

static void elf32_msp430_post_process_headers
  PARAMS ((bfd *, struct bfd_link_info *));

d39 1
a39 1
	 complain_overflow_bitfield,	/* complain_on_overflow */
d53 1
a53 1
	 complain_overflow_bitfield,	/* complain_on_overflow */
d68 1
a68 1
	 complain_overflow_bitfield,	/* complain_on_overflow */
d87 1
a87 1
	 0xffff,		/* src_mask */
d102 1
a102 1
	 0xffff,		/* src_mask */
d130 1
a130 1
	 "R_MSP430_16_PCREL_BYTE",	/* name */
d134 30
d177 6
a182 6
    {BFD_RELOC_NONE, R_MSP430_NONE},
    {BFD_RELOC_32, R_MSP430_32},
    {BFD_RELOC_MSP430_10_PCREL, R_MSP430_10_PCREL},
    {BFD_RELOC_16, R_MSP430_16_BYTE},
    {BFD_RELOC_MSP430_16_PCREL, R_MSP430_16_PCREL},
    {BFD_RELOC_MSP430_16, R_MSP430_16},
d184 3
a186 1
    {BFD_RELOC_MSP430_16_BYTE, R_MSP430_16_BYTE}
d190 2
a191 3
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d205 3
a207 4
msp430_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d217 5
a221 6
elf32_msp430_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d249 4
a252 5
elf32_msp430_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d263 2
a264 5
elf32_msp430_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d301 3
a303 8
msp430_final_link_relocate (howto, input_bfd, input_section,
			    contents, rel, relocation)
     reloc_howto_type *howto;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *rel;
     bfd_vma relocation;
d335 29
d365 1
d422 8
a429 10
elf32_msp430_relocate_section (output_bfd, info, input_bfd, input_section,
			       contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d536 2
a537 3
bfd_elf_msp430_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d609 1
a609 2
elf32_msp430_object_p (abfd)
     bfd *abfd;
d683 2
a684 3
elf32_msp430_post_process_headers (abfd, link_info)
     bfd *abfd;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
d686 1
a686 1
  Elf_Internal_Ehdr *i_ehdrp;	/* ELF file header, internal form.  */
d697 460
d1176 1
@


1.5
log
@bfd/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Report error if
	unresolved symbols in objects aren't allowed.

	* elf-hppa.h (elf_hppa_relocate_section): Properly handle
	unresolved symbols.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_unmark_useless_dynamic_symbols):
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

	* elf-m10200.c (mn10200_elf_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.

include/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Correct comments for the
	unresolved_syms_in_objects field.

ld/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (parse_args): Don't set unresolved_syms_in_objects
	or unresolved_syms_in_shared_libs for -Bdynamic and -Bstatic.
@
text
@d2 1
a2 1
    Copyright (C) 2002, 2003 Free Software Foundation, Inc.
d462 4
a465 3
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr,
				   relocation, sec, unresolved_reloc,
				   info, warned);
@


1.4
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d460 1
a460 1
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d462 3
a464 25
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  name = h->root.root.string;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
	      relocation = 0;
	    }
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->root.root.string, input_bfd,
		     input_section, rel->r_offset, TRUE)))
		return FALSE;
	      relocation = 0;
	    }
@


1.4.8.1
log
@Merge from mainline
@
text
@d2 1
a2 1
    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
d460 1
a460 1
	  bfd_boolean unresolved_reloc, warned;
d462 25
a486 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.4.10.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
d460 1
a460 1
	  bfd_boolean unresolved_reloc, warned;
d462 25
a486 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.4.10.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d28 35
d74 1
a74 1
	 complain_overflow_bitfield,/* complain_on_overflow */
d88 1
a88 1
	 complain_overflow_bitfield,/* complain_on_overflow */
d103 1
a103 1
	 complain_overflow_bitfield,/* complain_on_overflow */
d122 1
a122 1
	 0,			/* src_mask */
d137 1
a137 1
	 0,			/* src_mask */
d165 1
a165 1
	 "R_MSP430_16_PCREL_BYTE",/* name */
a168 30
	 TRUE),			/* pcrel_offset */

  /* A 13 bit PC relative relocation for complicated polymorphs.  */
  HOWTO (R_MSP430_2X_PCREL,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_2X_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 16 bit relaxable relocation for command address.  */
  HOWTO (R_MSP430_RL_PCREL,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MSP430_RL_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
d182 6
a187 6
    {BFD_RELOC_NONE,                 R_MSP430_NONE},
    {BFD_RELOC_32,                   R_MSP430_32},
    {BFD_RELOC_MSP430_10_PCREL,      R_MSP430_10_PCREL},
    {BFD_RELOC_16,                   R_MSP430_16_BYTE},
    {BFD_RELOC_MSP430_16_PCREL,      R_MSP430_16_PCREL},
    {BFD_RELOC_MSP430_16,            R_MSP430_16},
d189 1
a189 3
    {BFD_RELOC_MSP430_16_BYTE,       R_MSP430_16_BYTE},
    {BFD_RELOC_MSP430_2X_PCREL,      R_MSP430_2X_PCREL},
    {BFD_RELOC_MSP430_RL_PCREL,      R_MSP430_RL_PCREL}
d193 3
a195 2
bfd_elf32_bfd_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
				 bfd_reloc_code_real_type code)
d209 4
a212 3
msp430_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
			   arelent * cache_ptr,
			   Elf_Internal_Rela * dst)
d222 6
a227 5
elf32_msp430_gc_mark_hook (asection * sec,
			   struct bfd_link_info * info ATTRIBUTE_UNUSED,
			   Elf_Internal_Rela * rel,
			   struct elf_link_hash_entry * h,
			   Elf_Internal_Sym * sym)
d255 5
a259 4
elf32_msp430_gc_sweep_hook (bfd * abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info * info ATTRIBUTE_UNUSED,
			    asection * sec ATTRIBUTE_UNUSED,
			    const Elf_Internal_Rela * relocs ATTRIBUTE_UNUSED)
d270 5
a274 2
elf32_msp430_check_relocs (bfd * abfd, struct bfd_link_info * info,
			   asection * sec, const Elf_Internal_Rela * relocs)
d311 8
a318 3
msp430_final_link_relocate (reloc_howto_type * howto, bfd * input_bfd,
			    asection * input_section, bfd_byte * contents,
			    Elf_Internal_Rela * rel, bfd_vma relocation)
a349 29
    case R_MSP430_2X_PCREL:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      srel -= rel->r_offset;
      srel -= 2;		/* Branch instructions add 2 to the PC...  */
      srel -= (input_section->output_section->vma +
	       input_section->output_offset);

      if (srel & 1)
	return bfd_reloc_outofrange;

      /* MSP430 addresses commands as words.  */
      srel >>= 1;

      /* Check for an overflow.  */
      if (srel < -512 || srel > 511)
	return bfd_reloc_overflow;

      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xfc00) | (srel & 0x3ff);
      bfd_put_16 (input_bfd, x, contents);
      /* Handle second jump instruction.  */
      x = bfd_get_16 (input_bfd, contents - 2);
      srel += 1;
      x = (x & 0xfc00) | (srel & 0x3ff);
      bfd_put_16 (input_bfd, x, contents - 2);
      break;

a350 1
    case R_MSP430_RL_PCREL:
d407 10
a416 8
elf32_msp430_relocate_section (bfd * output_bfd ATTRIBUTE_UNUSED,
			       struct bfd_link_info * info,
			       bfd * input_bfd,
			       asection * input_section,
			       bfd_byte * contents,
			       Elf_Internal_Rela * relocs,
			       Elf_Internal_Sym * local_syms,
			       asection ** local_sections)
d523 3
a525 2
bfd_elf_msp430_final_write_processing (bfd * abfd,
				       bfd_boolean linker ATTRIBUTE_UNUSED)
d597 2
a598 1
elf32_msp430_object_p (bfd * abfd)
d672 3
a674 2
elf32_msp430_post_process_headers (bfd * abfd,
				   struct bfd_link_info * link_info ATTRIBUTE_UNUSED)
d676 1
a676 1
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */
a686 460
/* These functions handle relaxing for the msp430.
   Relaxation required only in two cases:
    - Bad hand coding like jumps from one section to another or
      from file to file.
    - Sibling calls. This will affect onlu 'jump label' polymorph. Without
      relaxing this enlarges code by 2 bytes. Sibcalls implemented but
      do not work in gcc's port by the reason I do not know.
   Anyway, if a relaxation required, user should pass -relax option to the
   linker.

   There are quite a few relaxing opportunities available on the msp430:

   ================================================================

   1. 3 words -> 1 word

   eq      ==      jeq label    		jne +4; br lab
   ne      !=      jne label    		jeq +4; br lab
   lt      <       jl  label    		jge +4; br lab
   ltu     <       jlo label    		lhs +4; br lab
   ge      >=      jge label    		jl  +4; br lab
   geu     >=      jhs label    		jlo +4; br lab

   2. 4 words -> 1 word

   ltn     <       jn                      jn  +2; jmp +4; br lab

   3. 4 words -> 2 words

   gt      >       jeq +2; jge label       jeq +6; jl  +4; br label
   gtu     >       jeq +2; jhs label       jeq +6; jlo +4; br label

   4. 4 words -> 2 words and 2 labels

   leu     <=      jeq label; jlo label    jeq +2; jhs +4; br label
   le      <=      jeq label; jl  label    jeq +2; jge +4; br label
   =================================================================

   codemap for first cases is (labels masked ):
	      eq:	0x2002,0x4010,0x0000 -> 0x2400
	      ne:	0x2402,0x4010,0x0000 -> 0x2000
	      lt:	0x3402,0x4010,0x0000 -> 0x3800
	      ltu:	0x2c02,0x4010,0x0000 -> 0x2800
	      ge:	0x3802,0x4010,0x0000 -> 0x3400
	      geu:	0x2802,0x4010,0x0000 -> 0x2c00

  second case:
	      ltn:	0x3001,0x3c02,0x4010,0x0000 -> 0x3000

  third case:
	      gt:	0x2403,0x3802,0x4010,0x0000 -> 0x2401,0x3400
	      gtu:	0x2403,0x2802,0x4010,0x0000 -> 0x2401,0x2c00

  fourth case:
	      leu:	0x2401,0x2c02,0x4010,0x0000 -> 0x2400,0x2800
	      le:	0x2401,0x3402,0x4010,0x0000 -> 0x2400,0x3800

  Unspecified case :)
	      jump:	0x4010,0x0000 -> 0x3c00.  */

#define NUMB_RELAX_CODES	12
static struct rcodes_s
{
  int f0, f1;			/* From code.  */
  int t0, t1;			/* To code.  */
  int labels;			/* Position of labels: 1 - one label at first
				   word, 2 - one at second word, 3 - two
				   labels at both.  */
  int cdx;			/* Words to match.  */
  int bs;			/* Shrink bytes.  */
  int off;			/* Offset from old label for new code.  */
  int ncl;			/* New code length.  */
} rcode[] =
{/*                               lab,cdx,bs,off,ncl */
  { 0x0000, 0x0000, 0x3c00, 0x0000, 1, 0, 2, 2,	 2},	/* jump */
  { 0x0000, 0x2002, 0x2400, 0x0000, 1, 1, 4, 4,	 2},	/* eq */
  { 0x0000, 0x2402, 0x2000, 0x0000, 1, 1, 4, 4,	 2},	/* ne */
  { 0x0000, 0x3402, 0x3800, 0x0000, 1, 1, 4, 4,	 2},	/* lt */
  { 0x0000, 0x2c02, 0x2800, 0x0000, 1, 1, 4, 4,	 2},	/* ltu */
  { 0x0000, 0x3802, 0x3400, 0x0000, 1, 1, 4, 4,	 2},	/* ge */
  { 0x0000, 0x2802, 0x2c00, 0x0000, 1, 1, 4, 4,	 2},	/* geu */
  { 0x3001, 0x3c02, 0x3000, 0x0000, 1, 2, 6, 6,	 2},	/* ltn */
  { 0x2403, 0x3802, 0x2401, 0x3400, 2, 2, 4, 6,	 4},	/* gt */
  { 0x2403, 0x2802, 0x2401, 0x2c00, 2, 2, 4, 6,	 4},	/* gtu */
  { 0x2401, 0x2c02, 0x2400, 0x2800, 3, 2, 4, 6,	 4},	/* leu , 2 labels */
  { 0x2401, 0x2c02, 0x2400, 0x2800, 3, 2, 4, 6,	 4},	/* le  , 2 labels */
  { 0, 	    0, 	    0, 	    0, 	    0, 0, 0, 0,  0}
};

/* Return TRUE if a symbol exists at the given address.  */

static bfd_boolean
msp430_elf_symbol_address_p (bfd * abfd,
			     asection * sec,
			     Elf_Internal_Sym * isym,
			     bfd_vma addr)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  Elf_Internal_Sym *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  /* Examine all the local symbols.  */
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
    if (isym->st_shndx == sec_shndx && isym->st_value == addr)
      return TRUE;

  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value == addr)
	return TRUE;
    }

  return FALSE;
}

/* Delete some bytes from a section while relaxing.  */

static bfd_boolean
msp430_elf_relax_delete_bytes (bfd * abfd, asection * sec, bfd_vma addr,
			       int count)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel;
  Elf_Internal_Rela *irelend;
  Elf_Internal_Rela *irelalign;
  bfd_vma toaddr;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  contents = elf_section_data (sec)->this_hdr.contents;

  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */

  irelalign = NULL;
  toaddr = sec->size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   (size_t) (toaddr - addr - count));
  sec->size -= count;

  /* Adjust all the relocs.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
    /* Get the new reloc address.  */
    if ((irel->r_offset > addr && irel->r_offset < toaddr))
      irel->r_offset -= count;

  /* Adjust the local symbols defined in this section.  */
  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
    if (isym->st_shndx == sec_shndx
	&& isym->st_value > addr && isym->st_value < toaddr)
      isym->st_value -= count;

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value > addr
	  && sym_hash->root.u.def.value < toaddr)
	sym_hash->root.u.def.value -= count;
    }

  return TRUE;
}


static bfd_boolean
msp430_elf_relax_section (bfd * abfd, asection * sec,
			  struct bfd_link_info * link_info,
			  bfd_boolean * again)
{
  Elf_Internal_Shdr * symtab_hdr;
  Elf_Internal_Rela * internal_relocs;
  Elf_Internal_Rela * irel;
  Elf_Internal_Rela * irelend;
  bfd_byte *          contents = NULL;
  Elf_Internal_Sym *  isymbuf = NULL;

  /* Assume nothing changes.  */
  *again = FALSE;

  /* We don't have to do anything for a relocatable link, if
     this section does not have relocs, or if this is not a
     code section.  */
  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0 || (sec->flags & SEC_CODE) == 0)
    return TRUE;

  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs =
    _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL, link_info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;

  /* Walk through them looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;

      /* If this isn't something that can be relaxed, then ignore
         this reloc.  */
      if (ELF32_R_TYPE (irel->r_info) != (int) R_MSP430_RL_PCREL)
	continue;

      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else if (! bfd_malloc_and_get_section (abfd, sec, &contents))
	    goto error_return;
	}

      /* Read this BFD's local symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;
	  asection *sym_sec;

	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
	    sym_sec = bfd_und_section_ptr;
	  else if (isym->st_shndx == SHN_ABS)
	    sym_sec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    sym_sec = bfd_com_section_ptr;
	  else
	    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
		    + sym_sec->output_section->vma + sym_sec->output_offset);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);

	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    /* This appears to be a reference to an undefined
	       symbol.  Just ignore it--it will be caught by the
	       regular reloc processing.  */
	    continue;

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}

      /* For simplicity of coding, we are going to modify the section
         contents, the section relocs, and the BFD symbol table.  We
         must tell the rest of the code not to free up this
         information.  It would be possible to instead create a table
         of changes which have to be made, as is done in coff-mips.c;
         that would be more work, but would require less memory when
         the linker is run.  */

      /* Try to turn a 16bit pc-relative branch into a 10bit pc-relative
         branch.  */
      /* Paranoia? paranoia...  */      
      if (ELF32_R_TYPE (irel->r_info) == (int) R_MSP430_RL_PCREL)
	{
	  bfd_vma value = symval;

	  /* Deal with pc-relative gunk.  */
	  value -= (sec->output_section->vma + sec->output_offset);
	  value -= irel->r_offset;
	  value += irel->r_addend;

	  /* See if the value will fit in 10 bits, note the high value is
	     1016 as the target will be two bytes closer if we are
	     able to relax. */
	  if ((long) value < 1016 && (long) value > -1016)
	    {
	      int code0 = 0, code1 = 0, code2 = 0;
	      int i;
	      struct rcodes_s *rx;

	      /* Get the opcode.  */
	      if (irel->r_offset >= 6)
		code0 = bfd_get_16 (abfd, contents + irel->r_offset - 6);

	      if (irel->r_offset >= 4)
		code1 = bfd_get_16 (abfd, contents + irel->r_offset - 4);

	      code2 = bfd_get_16 (abfd, contents + irel->r_offset - 2);

	      if (code2 != 0x4010)
		continue;

	      /* Check r4 and r3.  */
	      for (i = NUMB_RELAX_CODES - 1; i >= 0; i--)
		{
		  rx = &rcode[i];
		  if (rx->cdx == 2 && rx->f0 == code0 && rx->f1 == code1)
		    break;
		  else if (rx->cdx == 1 && rx->f1 == code1)
		    break;
		  else if (rx->cdx == 0)	/* This is an unconditional jump.  */
		    break;
		}

	      /* Check labels:
		   .Label0:       ; we do not care about this label
		      jeq    +6
		   .Label1:       ; make sure there is no label here
		      jl     +4
		   .Label2:       ; make sure there is no label here
		      br .Label_dst

	         So, if there is .Label1 or .Label2 we cannot relax this code.
	         This actually should not happen, cause for relaxable
		 instructions we use RL_PCREL reloc instead of 16_PCREL.
		 Will change this in the future. */

	      if (rx->cdx > 0
		  && msp430_elf_symbol_address_p (abfd, sec, isymbuf,
						  irel->r_offset - 2))
		continue;
	      if (rx->cdx > 1
		  && msp430_elf_symbol_address_p (abfd, sec, isymbuf,
						  irel->r_offset - 4))
		continue;

	      /* Note that we've changed the relocs, section contents, etc.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      elf_section_data (sec)->this_hdr.contents = contents;
	      symtab_hdr->contents = (unsigned char *) isymbuf;

	      /* Fix the relocation's type.  */
	      if (rx->labels == 3)	/* Handle special cases.  */
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					   R_MSP430_2X_PCREL);
	      else
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					   R_MSP430_10_PCREL);

	      /* Fix the opcode right way.  */
	      bfd_put_16 (abfd, rx->t0, contents + irel->r_offset - rx->off);
	      if (rx->t1)
		bfd_put_16 (abfd, rx->t1,
			    contents + irel->r_offset - rx->off + 2);

	      /* Delete bytes. */
	      if (!msp430_elf_relax_delete_bytes (abfd, sec,
						  irel->r_offset - rx->off +
						  rx->ncl, rx->bs))
		goto error_return;

	      /* Handle unconditional jumps.  */
	      if (rx->cdx == 0)
		irel->r_offset -= 2;

	      /* That will change things, so, we should relax again.
	         Note that this is not required, and it may be slow.  */
	      *again = TRUE;
	    }
	}
    }

  if (isymbuf != NULL && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (!link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (!link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
    }

  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return TRUE;

error_return:
  if (isymbuf != NULL && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return FALSE;
}

a705 1
#define bfd_elf32_bfd_relax_section	     msp430_elf_relax_section
@


1.4.14.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d460 1
a460 1
	  bfd_boolean unresolved_reloc, warned;
d462 25
a486 3
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr,
				   relocation, sec, unresolved_reloc,
				   info, warned);
@


1.4.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.3
log
@Add MSP430 variants
@
text
@d452 1
a452 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.2
log
@Correct spelling of "relocatable".
@
text
@a552 4
    case bfd_mach_msp12:
      val = E_MSP430_MACH_MSP430x12;
      break;

d561 4
d573 2
a574 2
    case bfd_mach_msp41:
      val = E_MSP430_MACH_MSP430x41;
d577 2
a578 6
    case bfd_mach_msp43:
      val = E_MSP430_MACH_MSP430x43;
      break;

    case bfd_mach_msp44:
      val = E_MSP430_MACH_MSP430x44;
d593 10
a602 2
    case bfd_mach_msp15:
      val = E_MSP430_MACH_MSP430x15;
d605 2
a606 2
    case bfd_mach_msp16:
      val = E_MSP430_MACH_MSP430x16;
a630 4
	case E_MSP430_MACH_MSP430x12:
	  e_set = bfd_mach_msp12;
	  break;

d639 4
d651 6
a656 2
	case E_MSP430_MACH_MSP430x41:
	  e_set = bfd_mach_msp41;
d671 8
a684 8
	  break;

	case E_MSP430_MACH_MSP430x15:
	  e_set = bfd_mach_msp15;
	  break;

	case E_MSP430_MACH_MSP430x16:
	  e_set = bfd_mach_msp16;
@


1.1
log
@Add support for msp430.
@
text
@d2 1
a2 1
    Copyright (C) 2002 Free Software Foundation, Inc.
d281 1
a281 1
  if (info->relocateable)
@


1.1.6.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@@


1.1.6.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
    Copyright (C) 2002, 2003 Free Software Foundation, Inc.
d281 1
a281 1
  if (info->relocatable)
@


1.1.6.3
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d553 4
a564 4
    case bfd_mach_msp12:
      val = E_MSP430_MACH_MSP430x12;
      break;

d573 6
a578 2
    case bfd_mach_msp15:
      val = E_MSP430_MACH_MSP430x15;
d581 2
a582 2
    case bfd_mach_msp16:
      val = E_MSP430_MACH_MSP430x16;
d597 2
a598 2
    case bfd_mach_msp41:
      val = E_MSP430_MACH_MSP430x41;
d601 2
a602 10
    case bfd_mach_msp42:
      val = E_MSP430_MACH_MSP430x42;
      break;

    case bfd_mach_msp43:
      val = E_MSP430_MACH_MSP430x43;
      break;

    case bfd_mach_msp44:
      val = E_MSP430_MACH_MSP430x44;
d627 4
a638 4
	case E_MSP430_MACH_MSP430x12:
	  e_set = bfd_mach_msp12;
	  break;

d647 2
a648 6
	case E_MSP430_MACH_MSP430x15:
	  e_set = bfd_mach_msp15;
	  break;

	case E_MSP430_MACH_MSP430x16:
	  e_set = bfd_mach_msp16;
d663 2
a664 2
	case E_MSP430_MACH_MSP430x41:
	  e_set = bfd_mach_msp41;
d667 2
a668 2
	case E_MSP430_MACH_MSP430x42:
	  e_set = bfd_mach_msp42;
d671 2
a672 2
	case E_MSP430_MACH_MSP430x43:
	  e_set = bfd_mach_msp43;
d675 2
a676 2
	case E_MSP430_MACH_MSP430x44:
	  e_set = bfd_mach_msp44;
@


1.1.6.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d452 1
a452 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
@


