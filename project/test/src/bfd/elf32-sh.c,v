head	1.189;
access;
symbols
	sid-snapshot-20180601:1.189
	sid-snapshot-20180501:1.189
	sid-snapshot-20180401:1.189
	sid-snapshot-20180301:1.189
	sid-snapshot-20180201:1.189
	sid-snapshot-20180101:1.189
	sid-snapshot-20171201:1.189
	sid-snapshot-20171101:1.189
	sid-snapshot-20171001:1.189
	sid-snapshot-20170901:1.189
	sid-snapshot-20170801:1.189
	sid-snapshot-20170701:1.189
	sid-snapshot-20170601:1.189
	sid-snapshot-20170501:1.189
	sid-snapshot-20170401:1.189
	sid-snapshot-20170301:1.189
	sid-snapshot-20170201:1.189
	sid-snapshot-20170101:1.189
	sid-snapshot-20161201:1.189
	sid-snapshot-20161101:1.189
	sid-snapshot-20160901:1.189
	sid-snapshot-20160801:1.189
	sid-snapshot-20160701:1.189
	sid-snapshot-20160601:1.189
	sid-snapshot-20160501:1.189
	sid-snapshot-20160401:1.189
	sid-snapshot-20160301:1.189
	sid-snapshot-20160201:1.189
	sid-snapshot-20160101:1.189
	sid-snapshot-20151201:1.189
	sid-snapshot-20151101:1.189
	sid-snapshot-20151001:1.189
	sid-snapshot-20150901:1.189
	sid-snapshot-20150801:1.189
	sid-snapshot-20150701:1.189
	sid-snapshot-20150601:1.189
	sid-snapshot-20150501:1.189
	sid-snapshot-20150401:1.189
	sid-snapshot-20150301:1.189
	sid-snapshot-20150201:1.189
	sid-snapshot-20150101:1.189
	sid-snapshot-20141201:1.189
	sid-snapshot-20141101:1.189
	sid-snapshot-20141001:1.189
	sid-snapshot-20140901:1.189
	sid-snapshot-20140801:1.189
	sid-snapshot-20140701:1.189
	sid-snapshot-20140601:1.189
	sid-snapshot-20140501:1.189
	sid-snapshot-20140401:1.189
	sid-snapshot-20140301:1.189
	sid-snapshot-20140201:1.189
	sid-snapshot-20140101:1.189
	sid-snapshot-20131201:1.189
	sid-snapshot-20131101:1.189
	sid-snapshot-20131001:1.189
	binutils-2_24-branch:1.189.0.2
	binutils-2_24-branchpoint:1.189
	binutils-2_21_1:1.170
	sid-snapshot-20130901:1.189
	gdb_7_6_1-2013-08-30-release:1.186
	sid-snapshot-20130801:1.189
	sid-snapshot-20130701:1.189
	sid-snapshot-20130601:1.189
	sid-snapshot-20130501:1.189
	gdb_7_6-2013-04-26-release:1.186
	sid-snapshot-20130401:1.189
	binutils-2_23_2:1.181.4.1
	gdb_7_6-branch:1.186.0.2
	gdb_7_6-2013-03-12-branchpoint:1.186
	sid-snapshot-20130301:1.186
	sid-snapshot-20130201:1.184
	sid-snapshot-20130101:1.183
	sid-snapshot-20121201:1.183
	gdb_7_5_1-2012-11-29-release:1.181
	binutils-2_23_1:1.181
	sid-snapshot-20121101:1.183
	binutils-2_23:1.181
	sid-snapshot-20121001:1.182
	sid-snapshot-20120901:1.181
	gdb_7_5-2012-08-17-release:1.181
	sid-snapshot-20120801:1.181
	binutils-2_23-branch:1.181.0.4
	binutils-2_23-branchpoint:1.181
	gdb_7_5-branch:1.181.0.2
	gdb_7_5-2012-07-18-branchpoint:1.181
	sid-snapshot-20120701:1.181
	sid-snapshot-20120601:1.179
	sid-snapshot-20120501:1.178
	binutils-2_22_branch:1.172.0.4
	gdb_7_4_1-2012-04-26-release:1.173
	sid-snapshot-20120401:1.175
	sid-snapshot-20120301:1.174
	sid-snapshot-20120201:1.173
	gdb_7_4-2012-01-24-release:1.173
	sid-snapshot-20120101:1.173
	gdb_7_4-branch:1.173.0.2
	gdb_7_4-2011-12-13-branchpoint:1.173
	sid-snapshot-20111201:1.173
	binutils-2_22:1.172
	sid-snapshot-20111101:1.173
	sid-snapshot-20111001:1.172
	binutils-2_22-branch:1.172.0.2
	binutils-2_22-branchpoint:1.172
	gdb_7_3_1-2011-09-04-release:1.170
	sid-snapshot-20110901:1.172
	sid-snapshot-20110801:1.172
	gdb_7_3-2011-07-26-release:1.170
	sid-snapshot-20110701:1.172
	sid-snapshot-20110601:1.170
	sid-snapshot-20110501:1.170
	gdb_7_3-branch:1.170.0.4
	gdb_7_3-2011-04-01-branchpoint:1.170
	sid-snapshot-20110401:1.170
	sid-snapshot-20110301:1.170
	sid-snapshot-20110201:1.170
	sid-snapshot-20110101:1.170
	binutils-2_21:1.170
	sid-snapshot-20101201:1.170
	binutils-2_21-branch:1.170.0.2
	binutils-2_21-branchpoint:1.170
	sid-snapshot-20101101:1.170
	sid-snapshot-20101001:1.169
	binutils-2_20_1:1.161
	gdb_7_2-2010-09-02-release:1.165
	sid-snapshot-20100901:1.168
	sid-snapshot-20100801:1.165
	gdb_7_2-branch:1.165.0.2
	gdb_7_2-2010-07-07-branchpoint:1.165
	sid-snapshot-20100701:1.165
	sid-snapshot-20100601:1.164
	sid-snapshot-20100501:1.163
	sid-snapshot-20100401:1.163
	gdb_7_1-2010-03-18-release:1.163
	sid-snapshot-20100301:1.163
	gdb_7_1-branch:1.163.0.2
	gdb_7_1-2010-02-18-branchpoint:1.163
	sid-snapshot-20100201:1.162
	sid-snapshot-20100101:1.162
	gdb_7_0_1-2009-12-22-release:1.161
	sid-snapshot-20091201:1.161
	sid-snapshot-20091101:1.161
	binutils-2_20:1.161
	gdb_7_0-2009-10-06-release:1.161
	sid-snapshot-20091001:1.161
	gdb_7_0-branch:1.161.0.4
	gdb_7_0-2009-09-16-branchpoint:1.161
	arc-sim-20090309:1.156
	binutils-arc-20081103-branch:1.157.0.14
	binutils-arc-20081103-branchpoint:1.157
	binutils-2_20-branch:1.161.0.2
	binutils-2_20-branchpoint:1.161
	sid-snapshot-20090901:1.160
	sid-snapshot-20090801:1.160
	msnyder-checkpoint-072509-branch:1.160.0.4
	msnyder-checkpoint-072509-branchpoint:1.160
	sid-snapshot-20090701:1.160
	dje-cgen-play1-branch:1.160.0.2
	dje-cgen-play1-branchpoint:1.160
	sid-snapshot-20090601:1.158
	sid-snapshot-20090501:1.158
	sid-snapshot-20090401:1.158
	arc-20081103-branch:1.157.0.12
	arc-20081103-branchpoint:1.157
	arc-insight_6_8-branch:1.156.0.6
	arc-insight_6_8-branchpoint:1.156
	insight_6_8-branch:1.156.0.4
	insight_6_8-branchpoint:1.156
	sid-snapshot-20090301:1.158
	binutils-2_19_1:1.157
	sid-snapshot-20090201:1.158
	sid-snapshot-20090101:1.158
	reverse-20081226-branch:1.158.0.2
	reverse-20081226-branchpoint:1.158
	sid-snapshot-20081201:1.158
	multiprocess-20081120-branch:1.157.0.10
	multiprocess-20081120-branchpoint:1.157
	sid-snapshot-20081101:1.157
	binutils-2_19:1.157
	sid-snapshot-20081001:1.157
	reverse-20080930-branch:1.157.0.8
	reverse-20080930-branchpoint:1.157
	binutils-2_19-branch:1.157.0.6
	binutils-2_19-branchpoint:1.157
	sid-snapshot-20080901:1.157
	sid-snapshot-20080801:1.157
	reverse-20080717-branch:1.157.0.4
	reverse-20080717-branchpoint:1.157
	sid-snapshot-20080701:1.157
	msnyder-reverse-20080609-branch:1.157.0.2
	msnyder-reverse-20080609-branchpoint:1.157
	drow-reverse-20070409-branch:1.147.0.2
	drow-reverse-20070409-branchpoint:1.147
	sid-snapshot-20080601:1.157
	sid-snapshot-20080501:1.157
	sid-snapshot-20080403:1.157
	sid-snapshot-20080401:1.157
	gdb_6_8-2008-03-27-release:1.156
	sid-snapshot-20080301:1.156
	gdb_6_8-branch:1.156.0.2
	gdb_6_8-2008-02-26-branchpoint:1.156
	sid-snapshot-20080201:1.155
	sid-snapshot-20080101:1.154
	sid-snapshot-20071201:1.154
	sid-snapshot-20071101:1.153
	gdb_6_7_1-2007-10-29-release:1.151
	gdb_6_7-2007-10-10-release:1.151
	sid-snapshot-20071001:1.153
	gdb_6_7-branch:1.151.0.4
	gdb_6_7-2007-09-07-branchpoint:1.151
	binutils-2_18:1.151
	binutils-2_18-branch:1.151.0.2
	binutils-2_18-branchpoint:1.151
	insight_6_6-20070208-release:1.145
	binutils-csl-coldfire-4_1-32:1.136
	binutils-csl-sourcerygxx-4_1-32:1.136
	gdb_6_6-2006-12-18-release:1.145
	binutils-csl-innovasic-fido-3_4_4-33:1.136
	binutils-csl-sourcerygxx-3_4_4-32:1.120
	binutils-csl-coldfire-4_1-30:1.136
	binutils-csl-sourcerygxx-4_1-30:1.136
	binutils-csl-coldfire-4_1-28:1.136
	binutils-csl-sourcerygxx-4_1-29:1.136
	binutils-csl-sourcerygxx-4_1-28:1.136
	gdb_6_6-branch:1.145.0.2
	gdb_6_6-2006-11-15-branchpoint:1.145
	binutils-csl-arm-2006q3-27:1.136
	binutils-csl-sourcerygxx-4_1-27:1.136
	binutils-csl-arm-2006q3-26:1.136
	binutils-csl-sourcerygxx-4_1-26:1.136
	binutils-csl-sourcerygxx-4_1-25:1.136
	binutils-csl-sourcerygxx-4_1-24:1.136
	binutils-csl-sourcerygxx-4_1-23:1.136
	insight_6_5-20061003-release:1.136
	gdb-csl-symbian-6_4_50_20060226-12:1.134
	binutils-csl-sourcerygxx-4_1-21:1.136
	binutils-csl-arm-2006q3-21:1.136
	binutils-csl-sourcerygxx-4_1-22:1.136
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.136
	binutils-csl-sourcerygxx-4_1-20:1.136
	binutils-csl-arm-2006q3-19:1.136
	binutils-csl-sourcerygxx-4_1-19:1.136
	binutils-csl-sourcerygxx-4_1-18:1.136
	binutils-csl-renesas-4_1-9:1.136
	gdb-csl-sourcerygxx-3_4_4-25:1.131
	binutils-csl-sourcerygxx-3_4_4-25:1.120
	nickrob-async-20060828-mergepoint:1.141
	gdb-csl-symbian-6_4_50_20060226-11:1.134
	binutils-csl-renesas-4_1-8:1.136
	binutils-csl-renesas-4_1-7:1.136
	binutils-csl-renesas-4_1-6:1.136
	gdb-csl-sourcerygxx-4_1-17:1.134
	binutils-csl-sourcerygxx-4_1-17:1.136
	gdb-csl-20060226-branch-local-2:1.134
	gdb-csl-sourcerygxx-4_1-14:1.134
	binutils-csl-sourcerygxx-4_1-14:1.136
	binutils-csl-sourcerygxx-4_1-15:1.136
	gdb-csl-sourcerygxx-4_1-13:1.134
	binutils-csl-sourcerygxx-4_1-13:1.136
	binutils-2_17:1.136
	gdb-csl-sourcerygxx-4_1-12:1.134
	binutils-csl-sourcerygxx-4_1-12:1.136
	gdb-csl-sourcerygxx-3_4_4-21:1.134
	binutils-csl-sourcerygxx-3_4_4-21:1.136
	gdb_6_5-20060621-release:1.136
	binutils-csl-wrs-linux-3_4_4-24:1.120
	binutils-csl-wrs-linux-3_4_4-23:1.120
	gdb-csl-sourcerygxx-4_1-9:1.134
	binutils-csl-sourcerygxx-4_1-9:1.136
	gdb-csl-sourcerygxx-4_1-8:1.134
	binutils-csl-sourcerygxx-4_1-8:1.136
	gdb-csl-sourcerygxx-4_1-7:1.134
	binutils-csl-sourcerygxx-4_1-7:1.136
	gdb-csl-arm-2006q1-6:1.134
	binutils-csl-arm-2006q1-6:1.136
	gdb-csl-sourcerygxx-4_1-6:1.134
	binutils-csl-sourcerygxx-4_1-6:1.136
	binutils-csl-wrs-linux-3_4_4-22:1.120
	gdb-csl-symbian-6_4_50_20060226-10:1.134
	gdb-csl-symbian-6_4_50_20060226-9:1.134
	gdb-csl-symbian-6_4_50_20060226-8:1.134
	gdb-csl-coldfire-4_1-11:1.134
	binutils-csl-coldfire-4_1-11:1.136
	gdb-csl-sourcerygxx-3_4_4-19:1.134
	binutils-csl-sourcerygxx-3_4_4-19:1.136
	gdb-csl-coldfire-4_1-10:1.134
	gdb_6_5-branch:1.136.0.14
	gdb_6_5-2006-05-14-branchpoint:1.136
	binutils-csl-coldfire-4_1-10:1.136
	gdb-csl-sourcerygxx-4_1-5:1.134
	binutils-csl-sourcerygxx-4_1-5:1.136
	nickrob-async-20060513-branch:1.136.0.12
	nickrob-async-20060513-branchpoint:1.136
	gdb-csl-sourcerygxx-4_1-4:1.134
	binutils-csl-sourcerygxx-4_1-4:1.136
	msnyder-reverse-20060502-branch:1.136.0.10
	msnyder-reverse-20060502-branchpoint:1.136
	binutils-csl-wrs-linux-3_4_4-21:1.120
	gdb-csl-morpho-4_1-4:1.134
	binutils-csl-morpho-4_1-4:1.136
	gdb-csl-sourcerygxx-3_4_4-17:1.134
	binutils-csl-sourcerygxx-3_4_4-17:1.136
	binutils-csl-wrs-linux-3_4_4-20:1.120
	readline_5_1-import-branch:1.136.0.8
	readline_5_1-import-branchpoint:1.136
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.134
	binutils-2_17-branch:1.136.0.6
	binutils-2_17-branchpoint:1.136
	gdb-csl-symbian-20060226-branch:1.134.0.4
	gdb-csl-symbian-20060226-branchpoint:1.134
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.134
	msnyder-reverse-20060331-branch:1.136.0.4
	msnyder-reverse-20060331-branchpoint:1.136
	binutils-csl-2_17-branch:1.136.0.2
	binutils-csl-2_17-branchpoint:1.136
	gdb-csl-available-20060303-branch:1.135.0.2
	gdb-csl-available-20060303-branchpoint:1.135
	gdb-csl-20060226-branch:1.134.0.2
	gdb-csl-20060226-branchpoint:1.134
	gdb_6_4-20051202-release:1.131
	msnyder-fork-checkpoint-branch:1.131.0.6
	msnyder-fork-checkpoint-branchpoint:1.131
	gdb-csl-gxxpro-6_3-branch:1.131.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.131
	gdb_6_4-branch:1.131.0.2
	gdb_6_4-2005-11-01-branchpoint:1.131
	gdb-csl-arm-20051020-branch:1.130.0.2
	gdb-csl-arm-20051020-branchpoint:1.130
	binutils-csl-gxxpro-3_4-branch:1.120.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.120
	binutils-2_16_1:1.120
	msnyder-tracepoint-checkpoint-branch:1.124.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.124
	gdb-csl-arm-20050325-2005-q1b:1.120
	binutils-csl-arm-2005q1b:1.120
	binutils-2_16:1.120
	gdb-csl-arm-20050325-2005-q1a:1.120
	binutils-csl-arm-2005q1a:1.120
	csl-arm-20050325-branch:1.120.0.6
	csl-arm-20050325-branchpoint:1.120
	binutils-csl-arm-2005q1-branch:1.120.0.4
	binutils-csl-arm-2005q1-branchpoint:1.120
	binutils-2_16-branch:1.120.0.2
	binutils-2_16-branchpoint:1.120
	csl-arm-2004-q3d:1.117
	gdb_6_3-20041109-release:1.115
	gdb_6_3-branch:1.115.0.2
	gdb_6_3-20041019-branchpoint:1.115
	csl-arm-2004-q3:1.115
	drow_intercu-merge-20040921:1.115
	drow_intercu-merge-20040915:1.113
	jimb-gdb_6_2-e500-branch:1.111.0.6
	jimb-gdb_6_2-e500-branchpoint:1.111
	gdb_6_2-20040730-release:1.111
	gdb_6_2-branch:1.111.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.111
	gdb_6_1_1-20040616-release:1.100
	binutils-2_15:1.100.6.1
	binutils-2_15-branchpoint:1.100
	csl-arm-2004-q1a:1.105
	csl-arm-2004-q1:1.104
	gdb_6_1-2004-04-05-release:1.100
	drow_intercu-merge-20040402:1.104
	drow_intercu-merge-20040327:1.103
	ezannoni_pie-20040323-branch:1.102.0.2
	ezannoni_pie-20040323-branchpoint:1.102
	cagney_tramp-20040321-mergepoint:1.102
	cagney_tramp-20040309-branch:1.101.0.2
	cagney_tramp-20040309-branchpoint:1.101
	gdb_6_1-branch:1.100.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.100
	drow_intercu-20040221-branch:1.100.0.8
	drow_intercu-20040221-branchpoint:1.100
	binutils-2_15-branch:1.100.0.6
	cagney_bfdfile-20040213-branch:1.100.0.4
	cagney_bfdfile-20040213-branchpoint:1.100
	drow-cplus-merge-20040208:1.100
	carlton_dictionary-20040126-merge:1.100
	cagney_bigcore-20040122-branch:1.100.0.2
	cagney_bigcore-20040122-branchpoint:1.100
	drow-cplus-merge-20040113:1.100
	csl-arm-2003-q4:1.100
	drow-cplus-merge-20031224:1.100
	drow-cplus-merge-20031220:1.100
	carlton_dictionary-20031215-merge:1.100
	drow-cplus-merge-20031214:1.100
	carlton-dictionary-20031111-merge:1.97
	gdb_6_0-2003-10-04-release:1.80
	kettenis_sparc-20030918-branch:1.91.0.6
	kettenis_sparc-20030918-branchpoint:1.91
	carlton_dictionary-20030917-merge:1.91
	ezannoni_pie-20030916-branchpoint:1.91
	ezannoni_pie-20030916-branch:1.91.0.4
	cagney_x86i386-20030821-branch:1.91.0.2
	cagney_x86i386-20030821-branchpoint:1.91
	carlton_dictionary-20030805-merge:1.88
	carlton_dictionary-20030627-merge:1.81
	gdb_6_0-branch:1.80.0.6
	gdb_6_0-2003-06-23-branchpoint:1.80
	jimb-ppc64-linux-20030613-branch:1.80.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.80
	binutils-2_14:1.77
	cagney_convert-20030606-branch:1.80.0.2
	cagney_convert-20030606-branchpoint:1.80
	cagney_writestrings-20030508-branch:1.78.0.4
	cagney_writestrings-20030508-branchpoint:1.78
	jimb-ppc64-linux-20030528-branch:1.79.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.79
	carlton_dictionary-20030523-merge:1.79
	cagney_fileio-20030521-branch:1.79.0.2
	cagney_fileio-20030521-branchpoint:1.79
	kettenis_i386newframe-20030517-mergepoint:1.79
	jimb-ppc64-linux-20030509-branch:1.78.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.78
	kettenis_i386newframe-20030504-mergepoint:1.77
	carlton_dictionary-20030430-merge:1.77
	binutils-2_14-branch:1.77.0.2
	binutils-2_14-branchpoint:1.77
	kettenis_i386newframe-20030419-branch:1.75.0.2
	kettenis_i386newframe-20030419-branchpoint:1.75
	carlton_dictionary-20030416-merge:1.75
	cagney_frameaddr-20030409-mergepoint:1.74
	kettenis_i386newframe-20030406-branch:1.74.0.12
	kettenis_i386newframe-20030406-branchpoint:1.74
	cagney_frameaddr-20030403-branchpoint:1.74
	cagney_frameaddr-20030403-branch:1.74.0.10
	cagney_framebase-20030330-mergepoint:1.74
	cagney_framebase-20030326-branch:1.74.0.8
	cagney_framebase-20030326-branchpoint:1.74
	cagney_lazyid-20030317-branch:1.74.0.6
	cagney_lazyid-20030317-branchpoint:1.74
	kettenis-i386newframe-20030316-mergepoint:1.74
	offbyone-20030313-branch:1.74.0.4
	offbyone-20030313-branchpoint:1.74
	kettenis-i386newframe-20030308-branch:1.74.0.2
	kettenis-i386newframe-20030308-branchpoint:1.74
	carlton_dictionary-20030305-merge:1.74
	cagney_offbyone-20030303-branch:1.73.0.2
	cagney_offbyone-20030303-branchpoint:1.73
	carlton_dictionary-20030207-merge:1.70
	interps-20030202-branch:1.70.0.2
	interps-20030202-branchpoint:1.70
	cagney-unwind-20030108-branch:1.68.0.2
	cagney-unwind-20030108-branchpoint:1.68
	binutils-2_13_2_1:1.52.2.4
	binutils-2_13_2:1.52.2.4
	carlton_dictionary-20021223-merge:1.68
	gdb_5_3-2002-12-12-release:1.58
	carlton_dictionary-20021115-merge:1.65
	binutils-2_13_1:1.52.2.3
	kseitz_interps-20021105-merge:1.64
	kseitz_interps-20021103-merge:1.64
	drow-cplus-merge-20021020:1.64
	drow-cplus-merge-20021025:1.64
	carlton_dictionary-20021025-merge:1.64
	carlton_dictionary-20021011-merge:1.62
	drow-cplus-branch:1.59.0.2
	drow-cplus-branchpoint:1.59
	kseitz_interps-20020930-merge:1.58
	carlton_dictionary-20020927-merge:1.58
	carlton_dictionary-branch:1.58.0.8
	carlton_dictionary-20020920-branchpoint:1.58
	sid-20020905-branchpoint:1.58
	sid-20020905-branch:1.58.0.6
	gdb_5_3-branch:1.58.0.4
	gdb_5_3-2002-09-04-branchpoint:1.58
	kseitz_interps-20020829-merge:1.58
	cagney_sysregs-20020825-branch:1.58.0.2
	cagney_sysregs-20020825-branchpoint:1.58
	readline_4_3-import-branch:1.57.0.2
	readline_4_3-import-branchpoint:1.57
	binutils-2_13:1.52
	gdb_5_2_1-2002-07-23-release:1.45
	binutils-2_13-branchpoint:1.52
	binutils-2_13-branch:1.52.0.2
	kseitz_interps-20020528-branch:1.47.0.6
	kseitz_interps-20020528-branchpoint:1.47
	cagney_regbuf-20020515-branch:1.47.0.4
	cagney_regbuf-20020515-branchpoint:1.47
	binutils-2_12_1:1.42.2.4
	jimb-macro-020506-branch:1.47.0.2
	jimb-macro-020506-branchpoint:1.47
	gdb_5_2-2002-04-29-release:1.45
	binutils-2_12:1.42.2.3
	gdb_5_2-branch:1.45.0.2
	gdb_5_2-2002-03-03-branchpoint:1.45
	binutils-2_12-branch:1.42.0.2
	binutils-2_12-branchpoint:1.42
	gdb_5_1_1-2002-01-24-release:1.29
	gdb_5_1_0_1-2002-01-03-release:1.29
	cygnus_cvs_20020108_pre:1.41
	gdb_5_1_0_1-2002-01-03-branch:1.29.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.29
	gdb_5_1-2001-11-21-release:1.29
	gdb_s390-2001-09-26-branch:1.29.0.4
	gdb_s390-2001-09-26-branchpoint:1.29
	gdb_5_1-2001-07-29-branch:1.29.0.2
	gdb_5_1-2001-07-29-branchpoint:1.29
	binutils-2_11_2:1.26.2.1
	binutils-2_11_1:1.26.2.1
	binutils-2_11:1.26
	x86_64versiong3:1.26
	binutils-2_11-branch:1.26.0.2
	insight-precleanup-2001-01-01:1.25
	binutils-2_10_1:1.9
	binutils-2_10:1.9
	gdb-premipsmulti-2000-06-06-branch:1.11.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.11
	gdb_5_0-2000-05-19-release:1.10
	gdb_4_18_2-2000-05-18-release:1.10
	gdb_4_95_1-2000-05-11-snapshot:1.10
	gdb_4_95_0-2000-04-27-snapshot:1.10
	gdb_5_0-2000-04-10-branch:1.10.0.2
	gdb_5_0-2000-04-10-branchpoint:1.10
	binutils-2_10-branch:1.9.0.2
	binutils-2_10-branchpoint:1.9
	binutils_latest_snapshot:1.189
	repo-unification-2000-02-06:1.6
	binu_ss_19990721:1.6
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.189
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.188;

1.188
date	2013.03.28.23.52.44;	author kkojima;	state Exp;
branches;
next	1.187;

1.187
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.186;

1.186
date	2013.02.21.03.02.29;	author amodra;	state Exp;
branches;
next	1.185;

1.185
date	2013.02.10.02.19.18;	author amodra;	state Exp;
branches;
next	1.184;

1.184
date	2013.01.10.20.03.53;	author hjl;	state Exp;
branches;
next	1.183;

1.183
date	2012.10.23.09.33.54;	author nathan;	state Exp;
branches;
next	1.182;

1.182
date	2012.09.02.12.17.26;	author hjl;	state Exp;
branches;
next	1.181;

1.181
date	2012.06.29.14.46.00;	author amodra;	state Exp;
branches
	1.181.4.1;
next	1.180;

1.180
date	2012.06.29.07.37.48;	author amodra;	state Exp;
branches;
next	1.179;

1.179
date	2012.05.07.03.27.50;	author macro;	state Exp;
branches;
next	1.178;

1.178
date	2012.04.24.05.12.35;	author amodra;	state Exp;
branches;
next	1.177;

1.177
date	2012.04.19.09.50.24;	author tschwinge;	state Exp;
branches;
next	1.176;

1.176
date	2012.04.17.21.58.51;	author kkojima;	state Exp;
branches;
next	1.175;

1.175
date	2012.03.13.06.04.35;	author amodra;	state Exp;
branches;
next	1.174;

1.174
date	2012.02.27.06.48.10;	author amodra;	state Exp;
branches;
next	1.173;

1.173
date	2011.10.19.07.17.14;	author amodra;	state Exp;
branches;
next	1.172;

1.172
date	2011.06.22.22.02.16;	author kkojima;	state Exp;
branches
	1.172.2.1;
next	1.171;

1.171
date	2011.06.13.00.59.11;	author amodra;	state Exp;
branches;
next	1.170;

1.170
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches;
next	1.169;

1.169
date	2010.09.24.12.14.24;	author tschwinge;	state Exp;
branches;
next	1.168;

1.168
date	2010.08.25.14.53.43;	author hjl;	state Exp;
branches;
next	1.167;

1.167
date	2010.08.20.21.15.03;	author macro;	state Exp;
branches;
next	1.166;

1.166
date	2010.08.18.12.24.06;	author palves;	state Exp;
branches;
next	1.165;

1.165
date	2010.06.27.04.07.52;	author amodra;	state Exp;
branches;
next	1.164;

1.164
date	2010.05.25.14.12.37;	author nickc;	state Exp;
branches;
next	1.163;

1.163
date	2010.02.04.09.16.40;	author nickc;	state Exp;
branches;
next	1.162;

1.162
date	2009.12.11.13.42.03;	author nickc;	state Exp;
branches;
next	1.161;

1.161
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.160;

1.160
date	2009.06.18.14.18.29;	author amodra;	state Exp;
branches;
next	1.159;

1.159
date	2009.06.17.18.08.35;	author hjl;	state Exp;
branches;
next	1.158;

1.158
date	2008.11.25.13.03.55;	author nickc;	state Exp;
branches;
next	1.157;

1.157
date	2008.03.25.18.56.01;	author nathan;	state Exp;
branches;
next	1.156;

1.156
date	2008.02.12.11.32.30;	author nickc;	state Exp;
branches;
next	1.155;

1.155
date	2008.01.11.09.07.03;	author gingold;	state Exp;
branches;
next	1.154;

1.154
date	2007.11.08.13.51.06;	author nathan;	state Exp;
branches;
next	1.153;

1.153
date	2007.09.28.08.43.45;	author amodra;	state Exp;
branches;
next	1.152;

1.152
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.151;

1.151
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.150;

1.150
date	2007.06.29.16.29.15;	author jsm28;	state Exp;
branches;
next	1.149;

1.149
date	2007.05.15.13.55.53;	author hjl;	state Exp;
branches;
next	1.148;

1.148
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2006.11.03.00.58.09;	author drow;	state Exp;
branches;
next	1.144;

1.144
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.143;

1.143
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.141;

1.141
date	2006.08.08.17.21.55;	author dj;	state Exp;
branches;
next	1.140;

1.140
date	2006.08.07.14.03.35;	author nickc;	state Exp;
branches;
next	1.139;

1.139
date	2006.08.04.13.13.55;	author rsandifo;	state Exp;
branches;
next	1.138;

1.138
date	2006.06.23.02.58.00;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2006.05.30.16.45.31;	author hjl;	state Exp;
branches;
next	1.136;

1.136
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.135;

1.135
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.134;

1.134
date	2006.02.25.09.23.30;	author rsandifo;	state Exp;
branches;
next	1.133;

1.133
date	2006.02.21.01.51.58;	author amodra;	state Exp;
branches;
next	1.132;

1.132
date	2005.12.31.16.23.13;	author kkojima;	state Exp;
branches;
next	1.131;

1.131
date	2005.10.25.16.19.06;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2005.10.06.19.21.14;	author drow;	state Exp;
branches;
next	1.129;

1.129
date	2005.08.25.05.10.22;	author kkojima;	state Exp;
branches;
next	1.128;

1.128
date	2005.08.25.02.32.10;	author hjl;	state Exp;
branches;
next	1.127;

1.127
date	2005.08.18.01.28.24;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2005.07.08.06.20.00;	author amodra;	state Exp;
branches;
next	1.125;

1.125
date	2005.06.20.18.12.07;	author hjl;	state Exp;
branches;
next	1.124;

1.124
date	2005.05.05.14.33.52;	author hjl;	state Exp;
branches;
next	1.123;

1.123
date	2005.05.04.15.53.19;	author nickc;	state Exp;
branches;
next	1.122;

1.122
date	2005.05.04.11.00.14;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2005.05.04.07.19.24;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches;
next	1.119;

1.119
date	2005.01.31.23.13.21;	author bje;	state Exp;
branches;
next	1.118;

1.118
date	2005.01.11.09.32.50;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2004.10.28.12.00.17;	author kkojima;	state Exp;
branches;
next	1.116;

1.116
date	2004.10.21.15.28.24;	author hjl;	state Exp;
branches;
next	1.115;

1.115
date	2004.09.17.07.14.28;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2004.09.16.14.52.05;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2004.08.13.03.15.57;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2004.07.29.05.17.39;	author aoliva;	state Exp;
branches;
next	1.111;

1.111
date	2004.07.09.12.32.35;	author nickc;	state Exp;
branches;
next	1.110;

1.110
date	2004.07.06.16.58.42;	author nickc;	state Exp;
branches;
next	1.109;

1.109
date	2004.07.05.13.35.43;	author amylaar;	state Exp;
branches;
next	1.108;

1.108
date	2004.06.29.13.46.32;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2004.06.24.04.46.21;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2004.05.28.12.32.01;	author amylaar;	state Exp;
branches;
next	1.105;

1.105
date	2004.04.23.02.47.38;	author kkojima;	state Exp;
branches;
next	1.104;

1.104
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2004.03.25.12.48.36;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2004.03.20.23.16.41;	author hjl;	state Exp;
branches;
next	1.101;

1.101
date	2004.03.03.18.01.49;	author amylaar;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2003.12.04.03.03.27;	author amodra;	state Exp;
branches
	1.100.6.1
	1.100.8.1;
next	1.99;

1.99
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches;
next	1.98;

1.98
date	2003.11.17.21.31.10;	author drow;	state Exp;
branches;
next	1.97;

1.97
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2003.11.04.06.16.35;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2003.11.03.15.17.39;	author drow;	state Exp;
branches;
next	1.94;

1.94
date	2003.10.21.15.49.45;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2003.10.15.06.23.55;	author kkojima;	state Exp;
branches;
next	1.92;

1.92
date	2003.09.24.02.27.57;	author dj;	state Exp;
branches;
next	1.91;

1.91
date	2003.08.20.08.37.17;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	2003.08.11.14.26.10;	author jakub;	state Exp;
branches;
next	1.89;

1.89
date	2003.08.07.08.38.07;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2003.08.02.13.46.43;	author kkojima;	state Exp;
branches;
next	1.87;

1.87
date	2003.07.25.06.19.20;	author kkojima;	state Exp;
branches;
next	1.86;

1.86
date	2003.07.24.11.37.02;	author kkojima;	state Exp;
branches;
next	1.85;

1.85
date	2003.07.12.11.16.46;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2003.07.04.08.41.57;	author kkojima;	state Exp;
branches;
next	1.83;

1.83
date	2003.07.04.07.38.33;	author kkojima;	state Exp;
branches;
next	1.82;

1.82
date	2003.07.04.04.58.03;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2003.06.25.06.40.20;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.03.04.50.19;	author kkojima;	state Exp;
branches;
next	1.79;

1.79
date	2003.05.13.12.13.37;	author kkojima;	state Exp;
branches;
next	1.78;

1.78
date	2003.05.09.02.27.04;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2003.04.24.05.19.09;	author kkojima;	state Exp;
branches;
next	1.76;

1.76
date	2003.04.23.21.09.02;	author amylaar;	state Exp;
branches;
next	1.75;

1.75
date	2003.04.15.08.51.51;	author nickc;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2003.03.03.21.04.01;	author amylaar;	state Exp;
branches;
next	1.73;

1.73
date	2003.02.19.14.14.16;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2003.02.17.18.24.39;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2003.02.10.22.17.18;	author kkojima;	state Exp;
branches;
next	1.70;

1.70
date	2003.01.23.18.50.56;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2003.01.20.18.06.21;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2002.11.28.11.55.40;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2002.11.28.08.37.14;	author kkojima;	state Exp;
branches;
next	1.65;

1.65
date	2002.11.06.11.38.35;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2002.10.16.08.39.37;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2002.10.14.19.29.54;	author sclarke;	state Exp;
branches;
next	1.62;

1.62
date	2002.10.11.14.32.03;	author kkojima;	state Exp;
branches;
next	1.61;

1.61
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2002.10.10.21.45.14;	author sclarke;	state Exp;
branches;
next	1.59;

1.59
date	2002.10.02.21.53.40;	author sclarke;	state Exp;
branches
	1.59.2.1;
next	1.58;

1.58
date	2002.08.24.01.44.56;	author amodra;	state Exp;
branches
	1.58.8.1;
next	1.57;

1.57
date	2002.08.23.08.26.13;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2002.08.23.08.13.12;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2002.08.23.04.23.37;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2002.08.22.17.27.19;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.16.18.40.54;	author sclarke;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.07.09.10.39;	author amodra;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2002.07.01.08.06.44;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.25.06.21.52;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.06.00.29.21;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.05.13.31.59;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2002.04.04.19.53.36;	author drow;	state Exp;
branches
	1.47.4.1
	1.47.6.1;
next	1.46;

1.46
date	2002.03.28.03.27.44;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.19.12.40.26;	author jakub;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.11.06.17.43;	author aoliva;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.11.02.17.39;	author drow;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.08.05.33.23;	author aoliva;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2001.12.07.11.12.17;	author jakub;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.23.12.17.16;	author jakub;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.10.00.23.34;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.17.12.01.05;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.01.00.16.27;	author hp;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.20.23.30.35;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.26.18.03.19;	author aj;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.25.09.47.35;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.23.16.38.36;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.13.04.43.40;	author dj;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.08.21.04.00;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.23.11.45.53;	author kazu;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2000.12.12.19.23.16;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.08.18.34.31;	author kazu;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.21.19.47.10;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.11.06.43.42;	author aoliva;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.18.16.19.15;	author aoliva;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.16.23.09.35;	author aoliva;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.14.04.59.14;	author aoliva;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.07.04.23.43;	author aoliva;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.02.02.33.26;	author aoliva;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.31.22.15.42;	author amylaar;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.22.04.58.25;	author aoliva;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.11.14.35.41;	author aoliva;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.10.10.00.56;	author crux;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.03.09.30.50;	author aoliva;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.15.23.10.59;	author amylaar;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.05.21.23.04;	author amylaar;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.01.20.39.07;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.01.19.40.54;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.17.00.33.34;	author amylaar;	state Exp;
branches;
next	1.6;

1.6
date	99.07.12.10.29.31;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.07.12.07.35.09;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.03.19.12.54;	author amylaar;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.18.54.32;	author amylaar;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.18.48.21;	author amylaar;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.181.4.1
date	2013.02.10.02.30.21;	author amodra;	state Exp;
branches;
next	;

1.172.2.1
date	2012.05.11.12.24.27;	author nickc;	state Exp;
branches;
next	;

1.101.2.1
date	2004.03.21.23.57.27;	author cagney;	state Exp;
branches;
next	;

1.100.6.1
date	2004.04.08.12.41.43;	author amodra;	state Exp;
branches;
next	;

1.100.8.1
date	2004.03.27.17.37.34;	author drow;	state Exp;
branches;
next	1.100.8.2;

1.100.8.2
date	2004.04.02.16.47.35;	author drow;	state Exp;
branches;
next	1.100.8.3;

1.100.8.3
date	2004.09.16.17.00.27;	author drow;	state Exp;
branches;
next	1.100.8.4;

1.100.8.4
date	2004.09.21.20.44.02;	author drow;	state Exp;
branches;
next	;

1.75.2.1
date	2003.05.04.11.37.36;	author kettenis;	state Exp;
branches;
next	1.75.2.2;

1.75.2.2
date	2003.05.18.09.43.43;	author kettenis;	state Exp;
branches;
next	;

1.59.2.1
date	2002.10.26.17.11.58;	author drow;	state Exp;
branches;
next	1.59.2.2;

1.59.2.2
date	2003.12.14.20.26.41;	author drow;	state Exp;
branches;
next	;

1.58.8.1
date	2002.10.11.22.22.48;	author carlton;	state Exp;
branches;
next	1.58.8.2;

1.58.8.2
date	2002.10.25.23.49.48;	author carlton;	state Exp;
branches;
next	1.58.8.3;

1.58.8.3
date	2002.11.15.19.18.26;	author carlton;	state Exp;
branches;
next	1.58.8.4;

1.58.8.4
date	2002.12.23.19.37.44;	author carlton;	state Exp;
branches;
next	1.58.8.5;

1.58.8.5
date	2003.02.07.19.17.38;	author carlton;	state Exp;
branches;
next	1.58.8.6;

1.58.8.6
date	2003.03.06.00.56.15;	author carlton;	state Exp;
branches;
next	1.58.8.7;

1.58.8.7
date	2003.04.16.19.56.43;	author carlton;	state Exp;
branches;
next	1.58.8.8;

1.58.8.8
date	2003.05.01.00.46.41;	author carlton;	state Exp;
branches;
next	1.58.8.9;

1.58.8.9
date	2003.05.23.18.40.24;	author carlton;	state Exp;
branches;
next	1.58.8.10;

1.58.8.10
date	2003.06.27.21.49.16;	author carlton;	state Exp;
branches;
next	1.58.8.11;

1.58.8.11
date	2003.08.05.17.12.49;	author carlton;	state Exp;
branches;
next	1.58.8.12;

1.58.8.12
date	2003.09.17.21.27.52;	author carlton;	state Exp;
branches;
next	1.58.8.13;

1.58.8.13
date	2003.11.11.23.50.19;	author carlton;	state Exp;
branches;
next	1.58.8.14;

1.58.8.14
date	2003.12.15.23.59.29;	author carlton;	state Exp;
branches;
next	;

1.52.2.1
date	2002.09.23.22.12.40;	author drow;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2002.10.11.08.56.13;	author amodra;	state Exp;
branches;
next	1.52.2.3;

1.52.2.3
date	2002.10.28.18.45.43;	author drow;	state Exp;
branches;
next	1.52.2.4;

1.52.2.4
date	2002.12.15.22.31.45;	author drow;	state Exp;
branches;
next	;

1.47.4.1
date	2002.06.15.16.42.37;	author cagney;	state Exp;
branches;
next	;

1.47.6.1
date	2002.06.20.01.30.20;	author kseitz;	state Exp;
branches;
next	1.47.6.2;

1.47.6.2
date	2002.07.22.21.46.44;	author kseitz;	state Exp;
branches;
next	1.47.6.3;

1.47.6.3
date	2002.08.30.22.52.36;	author kseitz;	state Exp;
branches;
next	1.47.6.4;

1.47.6.4
date	2002.11.03.22.01.35;	author ezannoni;	state Exp;
branches;
next	;

1.42.2.1
date	2002.02.10.22.16.35;	author drow;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	2002.02.11.06.18.12;	author aoliva;	state Exp;
branches;
next	1.42.2.3;

1.42.2.3
date	2002.02.19.13.10.23;	author jakub;	state Exp;
branches;
next	1.42.2.4;

1.42.2.4
date	2002.04.04.14.52.58;	author amodra;	state Exp;
branches;
next	;

1.26.2.1
date	2001.06.07.03.08.25;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches;
next	;


desc
@@


1.189
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@/* Renesas / SuperH SH specific support for 32-bit ELF
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
   Free Software Foundation, Inc.
   Contributed by Ian Lance Taylor, Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf-vxworks.h"
#include "elf/sh.h"
#include "dwarf2.h"
#include "libiberty.h"
#include "../opcodes/sh-opc.h"

static bfd_reloc_status_type sh_elf_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type sh_elf_ignore_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_boolean sh_elf_relax_delete_bytes
  (bfd *, asection *, bfd_vma, int);
static bfd_boolean sh_elf_align_loads
  (bfd *, asection *, Elf_Internal_Rela *, bfd_byte *, bfd_boolean *);
#ifndef SH64_ELF
static bfd_boolean sh_elf_swap_insns
  (bfd *, asection *, void *, bfd_byte *, bfd_vma);
#endif
static int sh_elf_optimized_tls_reloc
  (struct bfd_link_info *, int, int);
static bfd_vma dtpoff_base
  (struct bfd_link_info *);
static bfd_vma tpoff
  (struct bfd_link_info *, bfd_vma);

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"

/* FDPIC binaries have a default 128K stack.  */
#define DEFAULT_STACK_SIZE 0x20000

#define MINUS_ONE ((bfd_vma) 0 - 1)

/* Decide whether a reference to a symbol can be resolved locally or
   not.  If the symbol is protected, we want the local address, but
   its function descriptor must be assigned by the dynamic linker.  */
#define SYMBOL_FUNCDESC_LOCAL(INFO, H) \
  (SYMBOL_REFERENCES_LOCAL (INFO, H) \
   || ! elf_hash_table (INFO)->dynamic_sections_created)

#define SH_PARTIAL32 TRUE
#define SH_SRC_MASK32 0xffffffff
#define SH_ELF_RELOC sh_elf_reloc
static reloc_howto_type sh_elf_howto_table[] =
{
#include "elf32-sh-relocs.h"
};

#define SH_PARTIAL32 FALSE
#define SH_SRC_MASK32 0
#define SH_ELF_RELOC bfd_elf_generic_reloc
static reloc_howto_type sh_vxworks_howto_table[] =
{
#include "elf32-sh-relocs.h"
};

/* Return true if OUTPUT_BFD is a VxWorks object.  */

static bfd_boolean
vxworks_object_p (bfd *abfd ATTRIBUTE_UNUSED)
{
#if !defined INCLUDE_SHMEDIA && !defined SH_TARGET_ALREADY_DEFINED
  extern const bfd_target bfd_elf32_shlvxworks_vec;
  extern const bfd_target bfd_elf32_shvxworks_vec;

  return (abfd->xvec == &bfd_elf32_shlvxworks_vec
	  || abfd->xvec == &bfd_elf32_shvxworks_vec);
#else
  return FALSE;
#endif
}

/* Return true if OUTPUT_BFD is an FDPIC object.  */

static bfd_boolean
fdpic_object_p (bfd *abfd ATTRIBUTE_UNUSED)
{
#if !defined INCLUDE_SHMEDIA && !defined SH_TARGET_ALREADY_DEFINED
  extern const bfd_target bfd_elf32_shfd_vec;
  extern const bfd_target bfd_elf32_shbfd_vec;

  return (abfd->xvec == &bfd_elf32_shfd_vec
	  || abfd->xvec == &bfd_elf32_shbfd_vec);
#else
  return FALSE;
#endif
}

/* Return the howto table for ABFD.  */

static reloc_howto_type *
get_howto_table (bfd *abfd)
{
  if (vxworks_object_p (abfd))
    return sh_vxworks_howto_table;
  return sh_elf_howto_table;
}

static bfd_reloc_status_type
sh_elf_reloc_loop (int r_type ATTRIBUTE_UNUSED, bfd *input_bfd,
		   asection *input_section, bfd_byte *contents,
		   bfd_vma addr, asection *symbol_section,
		   bfd_vma start, bfd_vma end)
{
  static bfd_vma last_addr;
  static asection *last_symbol_section;
  bfd_byte *start_ptr, *ptr, *last_ptr;
  int diff, cum_diff;
  bfd_signed_vma x;
  int insn;

  /* Sanity check the address.  */
  if (addr > bfd_get_section_limit (input_bfd, input_section))
    return bfd_reloc_outofrange;

  /* We require the start and end relocations to be processed consecutively -
     although we allow then to be processed forwards or backwards.  */
  if (! last_addr)
    {
      last_addr = addr;
      last_symbol_section = symbol_section;
      return bfd_reloc_ok;
    }
  if (last_addr != addr)
    abort ();
  last_addr = 0;

  if (! symbol_section || last_symbol_section != symbol_section || end < start)
    return bfd_reloc_outofrange;

  /* Get the symbol_section contents.  */
  if (symbol_section != input_section)
    {
      if (elf_section_data (symbol_section)->this_hdr.contents != NULL)
	contents = elf_section_data (symbol_section)->this_hdr.contents;
      else
	{
	  if (!bfd_malloc_and_get_section (input_bfd, symbol_section,
					   &contents))
	    {
	      if (contents != NULL)
		free (contents);
	      return bfd_reloc_outofrange;
	    }
	}
    }
#define IS_PPI(PTR) ((bfd_get_16 (input_bfd, (PTR)) & 0xfc00) == 0xf800)
  start_ptr = contents + start;
  for (cum_diff = -6, ptr = contents + end; cum_diff < 0 && ptr > start_ptr;)
    {
      for (last_ptr = ptr, ptr -= 4; ptr >= start_ptr && IS_PPI (ptr);)
	ptr -= 2;
      ptr += 2;
      diff = (last_ptr - ptr) >> 1;
      cum_diff += diff & 1;
      cum_diff += diff;
    }
  /* Calculate the start / end values to load into rs / re minus four -
     so that will cancel out the four we would otherwise have to add to
     addr to get the value to subtract in order to get relative addressing.  */
  if (cum_diff >= 0)
    {
      start -= 4;
      end = (ptr + cum_diff * 2) - contents;
    }
  else
    {
      bfd_vma start0 = start - 4;

      while (start0 && IS_PPI (contents + start0))
	start0 -= 2;
      start0 = start - 2 - ((start - start0) & 2);
      start = start0 - cum_diff - 2;
      end = start0;
    }

  if (contents != NULL
      && elf_section_data (symbol_section)->this_hdr.contents != contents)
    free (contents);

  insn = bfd_get_16 (input_bfd, contents + addr);

  x = (insn & 0x200 ? end : start) - addr;
  if (input_section != symbol_section)
    x += ((symbol_section->output_section->vma + symbol_section->output_offset)
	  - (input_section->output_section->vma
	     + input_section->output_offset));
  x >>= 1;
  if (x < -128 || x > 127)
    return bfd_reloc_overflow;

  x = (insn & ~0xff) | (x & 0xff);
  bfd_put_16 (input_bfd, (bfd_vma) x, contents + addr);

  return bfd_reloc_ok;
}

/* This function is used for normal relocs.  This used to be like the COFF
   function, and is almost certainly incorrect for other ELF targets.  */

static bfd_reloc_status_type
sh_elf_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol_in,
	      void *data, asection *input_section, bfd *output_bfd,
	      char **error_message ATTRIBUTE_UNUSED)
{
  unsigned long insn;
  bfd_vma sym_value;
  enum elf_sh_reloc_type r_type;
  bfd_vma addr = reloc_entry->address;
  bfd_byte *hit_data = addr + (bfd_byte *) data;

  r_type = (enum elf_sh_reloc_type) reloc_entry->howto->type;

  if (output_bfd != NULL)
    {
      /* Partial linking--do nothing.  */
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Almost all relocs have to do with relaxing.  If any work must be
     done for them, it has been done in sh_relax_section.  */
  if (r_type == R_SH_IND12W && (symbol_in->flags & BSF_LOCAL) != 0)
    return bfd_reloc_ok;

  if (symbol_in != NULL
      && bfd_is_und_section (symbol_in->section))
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol_in->section))
    sym_value = 0;
  else
    sym_value = (symbol_in->value +
		 symbol_in->section->output_section->vma +
		 symbol_in->section->output_offset);

  switch (r_type)
    {
    case R_SH_DIR32:
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
      bfd_put_32 (abfd, (bfd_vma) insn, hit_data);
      break;
    case R_SH_IND12W:
      insn = bfd_get_16 (abfd, hit_data);
      sym_value += reloc_entry->addend;
      sym_value -= (input_section->output_section->vma
		    + input_section->output_offset
		    + addr
		    + 4);
      sym_value += (insn & 0xfff) << 1;
      if (insn & 0x800)
	sym_value -= 0x1000;
      insn = (insn & 0xf000) | (sym_value & 0xfff);
      bfd_put_16 (abfd, (bfd_vma) insn, hit_data);
      if (sym_value < (bfd_vma) -0x1000 || sym_value >= 0x1000)
	return bfd_reloc_overflow;
      break;
    default:
      abort ();
      break;
    }

  return bfd_reloc_ok;
}

/* This function is used for relocs which are only used for relaxing,
   which the linker should otherwise ignore.  */

static bfd_reloc_status_type
sh_elf_ignore_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		     asymbol *symbol ATTRIBUTE_UNUSED,
		     void *data ATTRIBUTE_UNUSED, asection *input_section,
		     bfd *output_bfd,
		     char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

/* This structure is used to map BFD reloc codes to SH ELF relocs.  */

struct elf_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char elf_reloc_val;
};

/* An array mapping BFD reloc codes to SH ELF relocs.  */

static const struct elf_reloc_map sh_reloc_map[] =
{
  { BFD_RELOC_NONE, R_SH_NONE },
  { BFD_RELOC_32, R_SH_DIR32 },
  { BFD_RELOC_16, R_SH_DIR16 },
  { BFD_RELOC_8, R_SH_DIR8 },
  { BFD_RELOC_CTOR, R_SH_DIR32 },
  { BFD_RELOC_32_PCREL, R_SH_REL32 },
  { BFD_RELOC_SH_PCDISP8BY2, R_SH_DIR8WPN },
  { BFD_RELOC_SH_PCDISP12BY2, R_SH_IND12W },
  { BFD_RELOC_SH_PCRELIMM8BY2, R_SH_DIR8WPZ },
  { BFD_RELOC_SH_PCRELIMM8BY4, R_SH_DIR8WPL },
  { BFD_RELOC_8_PCREL, R_SH_SWITCH8 },
  { BFD_RELOC_SH_SWITCH16, R_SH_SWITCH16 },
  { BFD_RELOC_SH_SWITCH32, R_SH_SWITCH32 },
  { BFD_RELOC_SH_USES, R_SH_USES },
  { BFD_RELOC_SH_COUNT, R_SH_COUNT },
  { BFD_RELOC_SH_ALIGN, R_SH_ALIGN },
  { BFD_RELOC_SH_CODE, R_SH_CODE },
  { BFD_RELOC_SH_DATA, R_SH_DATA },
  { BFD_RELOC_SH_LABEL, R_SH_LABEL },
  { BFD_RELOC_VTABLE_INHERIT, R_SH_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY, R_SH_GNU_VTENTRY },
  { BFD_RELOC_SH_LOOP_START, R_SH_LOOP_START },
  { BFD_RELOC_SH_LOOP_END, R_SH_LOOP_END },
  { BFD_RELOC_SH_TLS_GD_32, R_SH_TLS_GD_32 },
  { BFD_RELOC_SH_TLS_LD_32, R_SH_TLS_LD_32 },
  { BFD_RELOC_SH_TLS_LDO_32, R_SH_TLS_LDO_32 },
  { BFD_RELOC_SH_TLS_IE_32, R_SH_TLS_IE_32 },
  { BFD_RELOC_SH_TLS_LE_32, R_SH_TLS_LE_32 },
  { BFD_RELOC_SH_TLS_DTPMOD32, R_SH_TLS_DTPMOD32 },
  { BFD_RELOC_SH_TLS_DTPOFF32, R_SH_TLS_DTPOFF32 },
  { BFD_RELOC_SH_TLS_TPOFF32, R_SH_TLS_TPOFF32 },
  { BFD_RELOC_32_GOT_PCREL, R_SH_GOT32 },
  { BFD_RELOC_32_PLT_PCREL, R_SH_PLT32 },
  { BFD_RELOC_SH_COPY, R_SH_COPY },
  { BFD_RELOC_SH_GLOB_DAT, R_SH_GLOB_DAT },
  { BFD_RELOC_SH_JMP_SLOT, R_SH_JMP_SLOT },
  { BFD_RELOC_SH_RELATIVE, R_SH_RELATIVE },
  { BFD_RELOC_32_GOTOFF, R_SH_GOTOFF },
  { BFD_RELOC_SH_GOTPC, R_SH_GOTPC },
  { BFD_RELOC_SH_GOTPLT32, R_SH_GOTPLT32 },
  { BFD_RELOC_SH_GOT20, R_SH_GOT20 },
  { BFD_RELOC_SH_GOTOFF20, R_SH_GOTOFF20 },
  { BFD_RELOC_SH_GOTFUNCDESC, R_SH_GOTFUNCDESC },
  { BFD_RELOC_SH_GOTFUNCDESC20, R_SH_GOTFUNCDESC20 },
  { BFD_RELOC_SH_GOTOFFFUNCDESC, R_SH_GOTOFFFUNCDESC },
  { BFD_RELOC_SH_GOTOFFFUNCDESC20, R_SH_GOTOFFFUNCDESC20 },
  { BFD_RELOC_SH_FUNCDESC, R_SH_FUNCDESC },
#ifdef INCLUDE_SHMEDIA
  { BFD_RELOC_SH_GOT_LOW16, R_SH_GOT_LOW16 },
  { BFD_RELOC_SH_GOT_MEDLOW16, R_SH_GOT_MEDLOW16 },
  { BFD_RELOC_SH_GOT_MEDHI16, R_SH_GOT_MEDHI16 },
  { BFD_RELOC_SH_GOT_HI16, R_SH_GOT_HI16 },
  { BFD_RELOC_SH_GOTPLT_LOW16, R_SH_GOTPLT_LOW16 },
  { BFD_RELOC_SH_GOTPLT_MEDLOW16, R_SH_GOTPLT_MEDLOW16 },
  { BFD_RELOC_SH_GOTPLT_MEDHI16, R_SH_GOTPLT_MEDHI16 },
  { BFD_RELOC_SH_GOTPLT_HI16, R_SH_GOTPLT_HI16 },
  { BFD_RELOC_SH_PLT_LOW16, R_SH_PLT_LOW16 },
  { BFD_RELOC_SH_PLT_MEDLOW16, R_SH_PLT_MEDLOW16 },
  { BFD_RELOC_SH_PLT_MEDHI16, R_SH_PLT_MEDHI16 },
  { BFD_RELOC_SH_PLT_HI16, R_SH_PLT_HI16 },
  { BFD_RELOC_SH_GOTOFF_LOW16, R_SH_GOTOFF_LOW16 },
  { BFD_RELOC_SH_GOTOFF_MEDLOW16, R_SH_GOTOFF_MEDLOW16 },
  { BFD_RELOC_SH_GOTOFF_MEDHI16, R_SH_GOTOFF_MEDHI16 },
  { BFD_RELOC_SH_GOTOFF_HI16, R_SH_GOTOFF_HI16 },
  { BFD_RELOC_SH_GOTPC_LOW16, R_SH_GOTPC_LOW16 },
  { BFD_RELOC_SH_GOTPC_MEDLOW16, R_SH_GOTPC_MEDLOW16 },
  { BFD_RELOC_SH_GOTPC_MEDHI16, R_SH_GOTPC_MEDHI16 },
  { BFD_RELOC_SH_GOTPC_HI16, R_SH_GOTPC_HI16 },
  { BFD_RELOC_SH_COPY64, R_SH_COPY64 },
  { BFD_RELOC_SH_GLOB_DAT64, R_SH_GLOB_DAT64 },
  { BFD_RELOC_SH_JMP_SLOT64, R_SH_JMP_SLOT64 },
  { BFD_RELOC_SH_RELATIVE64, R_SH_RELATIVE64 },
  { BFD_RELOC_SH_GOT10BY4, R_SH_GOT10BY4 },
  { BFD_RELOC_SH_GOT10BY8, R_SH_GOT10BY8 },
  { BFD_RELOC_SH_GOTPLT10BY4, R_SH_GOTPLT10BY4 },
  { BFD_RELOC_SH_GOTPLT10BY8, R_SH_GOTPLT10BY8 },
  { BFD_RELOC_SH_PT_16, R_SH_PT_16 },
  { BFD_RELOC_SH_SHMEDIA_CODE, R_SH_SHMEDIA_CODE },
  { BFD_RELOC_SH_IMMU5, R_SH_DIR5U },
  { BFD_RELOC_SH_IMMS6, R_SH_DIR6S },
  { BFD_RELOC_SH_IMMU6, R_SH_DIR6U },
  { BFD_RELOC_SH_IMMS10, R_SH_DIR10S },
  { BFD_RELOC_SH_IMMS10BY2, R_SH_DIR10SW },
  { BFD_RELOC_SH_IMMS10BY4, R_SH_DIR10SL },
  { BFD_RELOC_SH_IMMS10BY8, R_SH_DIR10SQ },
  { BFD_RELOC_SH_IMMS16, R_SH_IMMS16 },
  { BFD_RELOC_SH_IMMU16, R_SH_IMMU16 },
  { BFD_RELOC_SH_IMM_LOW16, R_SH_IMM_LOW16 },
  { BFD_RELOC_SH_IMM_LOW16_PCREL, R_SH_IMM_LOW16_PCREL },
  { BFD_RELOC_SH_IMM_MEDLOW16, R_SH_IMM_MEDLOW16 },
  { BFD_RELOC_SH_IMM_MEDLOW16_PCREL, R_SH_IMM_MEDLOW16_PCREL },
  { BFD_RELOC_SH_IMM_MEDHI16, R_SH_IMM_MEDHI16 },
  { BFD_RELOC_SH_IMM_MEDHI16_PCREL, R_SH_IMM_MEDHI16_PCREL },
  { BFD_RELOC_SH_IMM_HI16, R_SH_IMM_HI16 },
  { BFD_RELOC_SH_IMM_HI16_PCREL, R_SH_IMM_HI16_PCREL },
  { BFD_RELOC_64, R_SH_64 },
  { BFD_RELOC_64_PCREL, R_SH_64_PCREL },
#endif /* not INCLUDE_SHMEDIA */
};

/* Given a BFD reloc code, return the howto structure for the
   corresponding SH ELF reloc.  */

static reloc_howto_type *
sh_elf_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = 0; i < sizeof (sh_reloc_map) / sizeof (struct elf_reloc_map); i++)
    {
      if (sh_reloc_map[i].bfd_reloc_val == code)
	return get_howto_table (abfd) + (int) sh_reloc_map[i].elf_reloc_val;
    }

  return NULL;
}

static reloc_howto_type *
sh_elf_reloc_name_lookup (bfd *abfd, const char *r_name)
{
  unsigned int i;

  if (vxworks_object_p (abfd))
    {
      for (i = 0;
	   i < (sizeof (sh_vxworks_howto_table)
		/ sizeof (sh_vxworks_howto_table[0]));
	   i++)
	if (sh_vxworks_howto_table[i].name != NULL
	    && strcasecmp (sh_vxworks_howto_table[i].name, r_name) == 0)
	  return &sh_vxworks_howto_table[i];
    }
  else
    {
      for (i = 0;
	   i < (sizeof (sh_elf_howto_table)
		/ sizeof (sh_elf_howto_table[0]));
	   i++)
	if (sh_elf_howto_table[i].name != NULL
	    && strcasecmp (sh_elf_howto_table[i].name, r_name) == 0)
	  return &sh_elf_howto_table[i];
    }

  return NULL;
}

/* Given an ELF reloc, fill in the howto field of a relent.  */

static void
sh_elf_info_to_howto (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  unsigned int r;

  r = ELF32_R_TYPE (dst->r_info);

  BFD_ASSERT (r < (unsigned int) R_SH_max);
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC || r > R_SH_LAST_INVALID_RELOC);
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC_2 || r > R_SH_LAST_INVALID_RELOC_2);
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC_3 || r > R_SH_LAST_INVALID_RELOC_3);
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC_4 || r > R_SH_LAST_INVALID_RELOC_4);
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC_5 || r > R_SH_LAST_INVALID_RELOC_5);
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC_6 || r > R_SH_LAST_INVALID_RELOC_6);

  cache_ptr->howto = get_howto_table (abfd) + r;
}

/* This function handles relaxing for SH ELF.  See the corresponding
   function in coff-sh.c for a description of what this does.  FIXME:
   There is a lot of duplication here between this code and the COFF
   specific code.  The format of relocs and symbols is wound deeply
   into this code, but it would still be better if the duplication
   could be eliminated somehow.  Note in particular that although both
   functions use symbols like R_SH_CODE, those symbols have different
   values; in coff-sh.c they come from include/coff/sh.h, whereas here
   they come from enum elf_sh_reloc_type in include/elf/sh.h.  */

static bfd_boolean
sh_elf_relax_section (bfd *abfd, asection *sec,
		      struct bfd_link_info *link_info, bfd_boolean *again)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  bfd_boolean have_code;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;
  Elf_Internal_Sym *isymbuf = NULL;

  *again = FALSE;

  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0)
    return TRUE;

#ifdef INCLUDE_SHMEDIA
  if (elf_section_data (sec)->this_hdr.sh_flags
      & (SHF_SH5_ISA32 | SHF_SH5_ISA32_MIXED))
    {
      return TRUE;
    }
#endif

  symtab_hdr = &elf_symtab_hdr (abfd);

  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;

  have_code = FALSE;

  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma laddr, paddr, symval;
      unsigned short insn;
      Elf_Internal_Rela *irelfn, *irelscan, *irelcount;
      bfd_signed_vma foff;

      if (ELF32_R_TYPE (irel->r_info) == (int) R_SH_CODE)
	have_code = TRUE;

      if (ELF32_R_TYPE (irel->r_info) != (int) R_SH_USES)
	continue;

      /* Get the section contents.  */
      if (contents == NULL)
	{
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
		goto error_return;
	    }
	}

      /* The r_addend field of the R_SH_USES reloc will point us to
	 the register load.  The 4 is because the r_addend field is
	 computed as though it were a jump offset, which are based
	 from 4 bytes after the jump instruction.  */
      laddr = irel->r_offset + 4 + irel->r_addend;
      if (laddr >= sec->size)
	{
	  (*_bfd_error_handler) (_("%B: 0x%lx: warning: bad R_SH_USES offset"),
				 abfd,
				 (unsigned long) irel->r_offset);
	  continue;
	}
      insn = bfd_get_16 (abfd, contents + laddr);

      /* If the instruction is not mov.l NN,rN, we don't know what to
	 do.  */
      if ((insn & 0xf000) != 0xd000)
	{
	  ((*_bfd_error_handler)
	   (_("%B: 0x%lx: warning: R_SH_USES points to unrecognized insn 0x%x"),
	    abfd, (unsigned long) irel->r_offset, insn));
	  continue;
	}

      /* Get the address from which the register is being loaded.  The
	 displacement in the mov.l instruction is quadrupled.  It is a
	 displacement from four bytes after the movl instruction, but,
	 before adding in the PC address, two least significant bits
	 of the PC are cleared.  We assume that the section is aligned
	 on a four byte boundary.  */
      paddr = insn & 0xff;
      paddr *= 4;
      paddr += (laddr + 4) &~ (bfd_vma) 3;
      if (paddr >= sec->size)
	{
	  ((*_bfd_error_handler)
	   (_("%B: 0x%lx: warning: bad R_SH_USES load offset"),
	    abfd, (unsigned long) irel->r_offset));
	  continue;
	}

      /* Get the reloc for the address from which the register is
	 being loaded.  This reloc will tell us which function is
	 actually being called.  */
      for (irelfn = internal_relocs; irelfn < irelend; irelfn++)
	if (irelfn->r_offset == paddr
	    && ELF32_R_TYPE (irelfn->r_info) == (int) R_SH_DIR32)
	  break;
      if (irelfn >= irelend)
	{
	  ((*_bfd_error_handler)
	   (_("%B: 0x%lx: warning: could not find expected reloc"),
	    abfd, (unsigned long) paddr));
	  continue;
	}

      /* Read this BFD's symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irelfn->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;

	  isym = isymbuf + ELF32_R_SYM (irelfn->r_info);
	  if (isym->st_shndx
	      != (unsigned int) _bfd_elf_section_from_bfd_section (abfd, sec))
	    {
	      ((*_bfd_error_handler)
	       (_("%B: 0x%lx: warning: symbol in unexpected section"),
		abfd, (unsigned long) paddr));
	      continue;
	    }

	  symval = (isym->st_value
		    + sec->output_section->vma
		    + sec->output_offset);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  indx = ELF32_R_SYM (irelfn->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);
	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    {
	      /* This appears to be a reference to an undefined
		 symbol.  Just ignore it--it will be caught by the
		 regular reloc processing.  */
	      continue;
	    }

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}

      if (get_howto_table (abfd)[R_SH_DIR32].partial_inplace)
	symval += bfd_get_32 (abfd, contents + paddr);
      else
	symval += irelfn->r_addend;

      /* See if this function call can be shortened.  */
      foff = (symval
	      - (irel->r_offset
		 + sec->output_section->vma
		 + sec->output_offset
		 + 4));
      /* A branch to an address beyond ours might be increased by an
	 .align that doesn't move when bytes behind us are deleted.
	 So, we add some slop in this calculation to allow for
	 that.  */
      if (foff < -0x1000 || foff >= 0x1000 - 8)
	{
	  /* After all that work, we can't shorten this function call.  */
	  continue;
	}

      /* Shorten the function call.  */

      /* For simplicity of coding, we are going to modify the section
	 contents, the section relocs, and the BFD symbol table.  We
	 must tell the rest of the code not to free up this
	 information.  It would be possible to instead create a table
	 of changes which have to be made, as is done in coff-mips.c;
	 that would be more work, but would require less memory when
	 the linker is run.  */

      elf_section_data (sec)->relocs = internal_relocs;
      elf_section_data (sec)->this_hdr.contents = contents;
      symtab_hdr->contents = (unsigned char *) isymbuf;

      /* Replace the jsr with a bsr.  */

      /* Change the R_SH_USES reloc into an R_SH_IND12W reloc, and
	 replace the jsr with a bsr.  */
      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irelfn->r_info), R_SH_IND12W);
      /* We used to test (ELF32_R_SYM (irelfn->r_info) < symtab_hdr->sh_info)
	 here, but that only checks if the symbol is an external symbol,
	 not if the symbol is in a different section.  Besides, we need
	 a consistent meaning for the relocation, so we just assume here that
	 the value of the symbol is not available.  */

      /* We can't fully resolve this yet, because the external
	 symbol value may be changed by future relaxing.  We let
	 the final link phase handle it.  */
      bfd_put_16 (abfd, (bfd_vma) 0xb000, contents + irel->r_offset);

      irel->r_addend = -4;

      /* When we calculated the symbol "value" we had an offset in the
	 DIR32's word in memory (we read and add it above).  However,
	 the jsr we create does NOT have this offset encoded, so we
	 have to add it to the addend to preserve it.  */
      irel->r_addend += bfd_get_32 (abfd, contents + paddr);

      /* See if there is another R_SH_USES reloc referring to the same
	 register load.  */
      for (irelscan = internal_relocs; irelscan < irelend; irelscan++)
	if (ELF32_R_TYPE (irelscan->r_info) == (int) R_SH_USES
	    && laddr == irelscan->r_offset + 4 + irelscan->r_addend)
	  break;
      if (irelscan < irelend)
	{
	  /* Some other function call depends upon this register load,
	     and we have not yet converted that function call.
	     Indeed, we may never be able to convert it.  There is
	     nothing else we can do at this point.  */
	  continue;
	}

      /* Look for a R_SH_COUNT reloc on the location where the
	 function address is stored.  Do this before deleting any
	 bytes, to avoid confusion about the address.  */
      for (irelcount = internal_relocs; irelcount < irelend; irelcount++)
	if (irelcount->r_offset == paddr
	    && ELF32_R_TYPE (irelcount->r_info) == (int) R_SH_COUNT)
	  break;

      /* Delete the register load.  */
      if (! sh_elf_relax_delete_bytes (abfd, sec, laddr, 2))
	goto error_return;

      /* That will change things, so, just in case it permits some
	 other function call to come within range, we should relax
	 again.  Note that this is not required, and it may be slow.  */
      *again = TRUE;

      /* Now check whether we got a COUNT reloc.  */
      if (irelcount >= irelend)
	{
	  ((*_bfd_error_handler)
	   (_("%B: 0x%lx: warning: could not find expected COUNT reloc"),
	    abfd, (unsigned long) paddr));
	  continue;
	}

      /* The number of uses is stored in the r_addend field.  We've
	 just deleted one.  */
      if (irelcount->r_addend == 0)
	{
	  ((*_bfd_error_handler) (_("%B: 0x%lx: warning: bad count"),
				  abfd,
				  (unsigned long) paddr));
	  continue;
	}

      --irelcount->r_addend;

      /* If there are no more uses, we can delete the address.  Reload
	 the address from irelfn, in case it was changed by the
	 previous call to sh_elf_relax_delete_bytes.  */
      if (irelcount->r_addend == 0)
	{
	  if (! sh_elf_relax_delete_bytes (abfd, sec, irelfn->r_offset, 4))
	    goto error_return;
	}

      /* We've done all we can with that function call.  */
    }

  /* Look for load and store instructions that we can align on four
     byte boundaries.  */
  if ((elf_elfheader (abfd)->e_flags & EF_SH_MACH_MASK) != EF_SH4
      && have_code)
    {
      bfd_boolean swapped;

      /* Get the section contents.  */
      if (contents == NULL)
	{
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
		goto error_return;
	    }
	}

      if (! sh_elf_align_loads (abfd, sec, internal_relocs, contents,
				&swapped))
	goto error_return;

      if (swapped)
	{
	  elf_section_data (sec)->relocs = internal_relocs;
	  elf_section_data (sec)->this_hdr.contents = contents;
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (! link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
    }

  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return TRUE;

 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return FALSE;
}

/* Delete some bytes from a section while relaxing.  FIXME: There is a
   lot of duplication between this function and sh_relax_delete_bytes
   in coff-sh.c.  */

static bfd_boolean
sh_elf_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr,
			   int count)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Rela *irelalign;
  bfd_vma toaddr;
  Elf_Internal_Sym *isymbuf, *isym, *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;
  asection *o;

  symtab_hdr = &elf_symtab_hdr (abfd);
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  contents = elf_section_data (sec)->this_hdr.contents;

  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */

  irelalign = NULL;
  toaddr = sec->size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;
  for (; irel < irelend; irel++)
    {
      if (ELF32_R_TYPE (irel->r_info) == (int) R_SH_ALIGN
	  && irel->r_offset > addr
	  && count < (1 << irel->r_addend))
	{
	  irelalign = irel;
	  toaddr = irel->r_offset;
	  break;
	}
    }

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   (size_t) (toaddr - addr - count));
  if (irelalign == NULL)
    sec->size -= count;
  else
    {
      int i;

#define NOP_OPCODE (0x0009)

      BFD_ASSERT ((count & 1) == 0);
      for (i = 0; i < count; i += 2)
	bfd_put_16 (abfd, (bfd_vma) NOP_OPCODE, contents + toaddr - count + i);
    }

  /* Adjust all the relocs.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
    {
      bfd_vma nraddr, stop;
      bfd_vma start = 0;
      int insn = 0;
      int off, adjust, oinsn;
      bfd_signed_vma voff = 0;
      bfd_boolean overflow;

      /* Get the new reloc address.  */
      nraddr = irel->r_offset;
      if ((irel->r_offset > addr
	   && irel->r_offset < toaddr)
	  || (ELF32_R_TYPE (irel->r_info) == (int) R_SH_ALIGN
	      && irel->r_offset == toaddr))
	nraddr -= count;

      /* See if this reloc was for the bytes we have deleted, in which
	 case we no longer care about it.  Don't delete relocs which
	 represent addresses, though.  */
      if (irel->r_offset >= addr
	  && irel->r_offset < addr + count
	  && ELF32_R_TYPE (irel->r_info) != (int) R_SH_ALIGN
	  && ELF32_R_TYPE (irel->r_info) != (int) R_SH_CODE
	  && ELF32_R_TYPE (irel->r_info) != (int) R_SH_DATA
	  && ELF32_R_TYPE (irel->r_info) != (int) R_SH_LABEL)
	irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				     (int) R_SH_NONE);

      /* If this is a PC relative reloc, see if the range it covers
	 includes the bytes we have deleted.  */
      switch ((enum elf_sh_reloc_type) ELF32_R_TYPE (irel->r_info))
	{
	default:
	  break;

	case R_SH_DIR8WPN:
	case R_SH_IND12W:
	case R_SH_DIR8WPZ:
	case R_SH_DIR8WPL:
	  start = irel->r_offset;
	  insn = bfd_get_16 (abfd, contents + nraddr);
	  break;
	}

      switch ((enum elf_sh_reloc_type) ELF32_R_TYPE (irel->r_info))
	{
	default:
	  start = stop = addr;
	  break;

	case R_SH_DIR32:
	  /* If this reloc is against a symbol defined in this
	     section, and the symbol will not be adjusted below, we
	     must check the addend to see it will put the value in
	     range to be adjusted, and hence must be changed.  */
	  if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	    {
	      isym = isymbuf + ELF32_R_SYM (irel->r_info);
	      if (isym->st_shndx == sec_shndx
		  && (isym->st_value <= addr
		      || isym->st_value >= toaddr))
		{
		  bfd_vma val;

		  if (get_howto_table (abfd)[R_SH_DIR32].partial_inplace)
		    {
		      val = bfd_get_32 (abfd, contents + nraddr);
		      val += isym->st_value;
		      if (val > addr && val < toaddr)
			bfd_put_32 (abfd, val - count, contents + nraddr);
		    }
		  else
		    {
		      val = isym->st_value + irel->r_addend;
		      if (val > addr && val < toaddr)
			irel->r_addend -= count;
		    }
		}
	    }
	  start = stop = addr;
	  break;

	case R_SH_DIR8WPN:
	  off = insn & 0xff;
	  if (off & 0x80)
	    off -= 0x100;
	  stop = (bfd_vma) ((bfd_signed_vma) start + 4 + off * 2);
	  break;

	case R_SH_IND12W:
	  off = insn & 0xfff;
	  if (! off)
	    {
	      /* This has been made by previous relaxation.  Since the
		 relocation will be against an external symbol, the
		 final relocation will just do the right thing.  */
	      start = stop = addr;
	    }
	  else
	    {
	      if (off & 0x800)
		off -= 0x1000;
	      stop = (bfd_vma) ((bfd_signed_vma) start + 4 + off * 2);

	      /* The addend will be against the section symbol, thus
		 for adjusting the addend, the relevant start is the
		 start of the section.
		 N.B. If we want to abandon in-place changes here and
		 test directly using symbol + addend, we have to take into
		 account that the addend has already been adjusted by -4.  */
	      if (stop > addr && stop < toaddr)
		irel->r_addend -= count;
	    }
	  break;

	case R_SH_DIR8WPZ:
	  off = insn & 0xff;
	  stop = start + 4 + off * 2;
	  break;

	case R_SH_DIR8WPL:
	  off = insn & 0xff;
	  stop = (start & ~(bfd_vma) 3) + 4 + off * 4;
	  break;

	case R_SH_SWITCH8:
	case R_SH_SWITCH16:
	case R_SH_SWITCH32:
	  /* These relocs types represent
	       .word L2-L1
	     The r_addend field holds the difference between the reloc
	     address and L1.  That is the start of the reloc, and
	     adding in the contents gives us the top.  We must adjust
	     both the r_offset field and the section contents.
	     N.B. in gas / coff bfd, the elf bfd r_addend is called r_offset,
	     and the elf bfd r_offset is called r_vaddr.  */

	  stop = irel->r_offset;
	  start = (bfd_vma) ((bfd_signed_vma) stop - (long) irel->r_addend);

	  if (start > addr
	      && start < toaddr
	      && (stop <= addr || stop >= toaddr))
	    irel->r_addend += count;
	  else if (stop > addr
		   && stop < toaddr
		   && (start <= addr || start >= toaddr))
	    irel->r_addend -= count;

	  if (ELF32_R_TYPE (irel->r_info) == (int) R_SH_SWITCH16)
	    voff = bfd_get_signed_16 (abfd, contents + nraddr);
	  else if (ELF32_R_TYPE (irel->r_info) == (int) R_SH_SWITCH8)
	    voff = bfd_get_8 (abfd, contents + nraddr);
	  else
	    voff = bfd_get_signed_32 (abfd, contents + nraddr);
	  stop = (bfd_vma) ((bfd_signed_vma) start + voff);

	  break;

	case R_SH_USES:
	  start = irel->r_offset;
	  stop = (bfd_vma) ((bfd_signed_vma) start
			    + (long) irel->r_addend
			    + 4);
	  break;
	}

      if (start > addr
	  && start < toaddr
	  && (stop <= addr || stop >= toaddr))
	adjust = count;
      else if (stop > addr
	       && stop < toaddr
	       && (start <= addr || start >= toaddr))
	adjust = - count;
      else
	adjust = 0;

      if (adjust != 0)
	{
	  oinsn = insn;
	  overflow = FALSE;
	  switch ((enum elf_sh_reloc_type) ELF32_R_TYPE (irel->r_info))
	    {
	    default:
	      abort ();
	      break;

	    case R_SH_DIR8WPN:
	    case R_SH_DIR8WPZ:
	      insn += adjust / 2;
	      if ((oinsn & 0xff00) != (insn & 0xff00))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
	      break;

	    case R_SH_IND12W:
	      insn += adjust / 2;
	      if ((oinsn & 0xf000) != (insn & 0xf000))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
	      break;

	    case R_SH_DIR8WPL:
	      BFD_ASSERT (adjust == count || count >= 4);
	      if (count >= 4)
		insn += adjust / 4;
	      else
		{
		  if ((irel->r_offset & 3) == 0)
		    ++insn;
		}
	      if ((oinsn & 0xff00) != (insn & 0xff00))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);
	      break;

	    case R_SH_SWITCH8:
	      voff += adjust;
	      if (voff < 0 || voff >= 0xff)
		overflow = TRUE;
	      bfd_put_8 (abfd, voff, contents + nraddr);
	      break;

	    case R_SH_SWITCH16:
	      voff += adjust;
	      if (voff < - 0x8000 || voff >= 0x8000)
		overflow = TRUE;
	      bfd_put_signed_16 (abfd, (bfd_vma) voff, contents + nraddr);
	      break;

	    case R_SH_SWITCH32:
	      voff += adjust;
	      bfd_put_signed_32 (abfd, (bfd_vma) voff, contents + nraddr);
	      break;

	    case R_SH_USES:
	      irel->r_addend += adjust;
	      break;
	    }

	  if (overflow)
	    {
	      ((*_bfd_error_handler)
	       (_("%B: 0x%lx: fatal: reloc overflow while relaxing"),
		abfd, (unsigned long) irel->r_offset));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}

      irel->r_offset = nraddr;
    }

  /* Look through all the other sections.  If there contain any IMM32
     relocs against internal symbols which we are not going to adjust
     below, we may need to adjust the addends.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      Elf_Internal_Rela *internal_relocs;
      Elf_Internal_Rela *irelscan, *irelscanend;
      bfd_byte *ocontents;

      if (o == sec
	  || (o->flags & SEC_RELOC) == 0
	  || o->reloc_count == 0)
	continue;

      /* We always cache the relocs.  Perhaps, if info->keep_memory is
	 FALSE, we should free them, if we are permitted to, when we
	 leave sh_coff_relax_section.  */
      internal_relocs = (_bfd_elf_link_read_relocs
			 (abfd, o, NULL, (Elf_Internal_Rela *) NULL, TRUE));
      if (internal_relocs == NULL)
	return FALSE;

      ocontents = NULL;
      irelscanend = internal_relocs + o->reloc_count;
      for (irelscan = internal_relocs; irelscan < irelscanend; irelscan++)
	{
	  /* Dwarf line numbers use R_SH_SWITCH32 relocs.  */
	  if (ELF32_R_TYPE (irelscan->r_info) == (int) R_SH_SWITCH32)
	    {
	      bfd_vma start, stop;
	      bfd_signed_vma voff;

	      if (ocontents == NULL)
		{
		  if (elf_section_data (o)->this_hdr.contents != NULL)
		    ocontents = elf_section_data (o)->this_hdr.contents;
		  else
		    {
		      /* We always cache the section contents.
			 Perhaps, if info->keep_memory is FALSE, we
			 should free them, if we are permitted to,
			 when we leave sh_coff_relax_section.  */
		      if (!bfd_malloc_and_get_section (abfd, o, &ocontents))
			{
			  if (ocontents != NULL)
			    free (ocontents);
			  return FALSE;
			}

		      elf_section_data (o)->this_hdr.contents = ocontents;
		    }
		}

	      stop = irelscan->r_offset;
	      start
		= (bfd_vma) ((bfd_signed_vma) stop - (long) irelscan->r_addend);

	      /* STOP is in a different section, so it won't change.  */
	      if (start > addr && start < toaddr)
		irelscan->r_addend += count;

	      voff = bfd_get_signed_32 (abfd, ocontents + irelscan->r_offset);
	      stop = (bfd_vma) ((bfd_signed_vma) start + voff);

	      if (start > addr
		  && start < toaddr
		  && (stop <= addr || stop >= toaddr))
		bfd_put_signed_32 (abfd, (bfd_vma) voff + count,
				   ocontents + irelscan->r_offset);
	      else if (stop > addr
		       && stop < toaddr
		       && (start <= addr || start >= toaddr))
		bfd_put_signed_32 (abfd, (bfd_vma) voff - count,
				   ocontents + irelscan->r_offset);
	    }

	  if (ELF32_R_TYPE (irelscan->r_info) != (int) R_SH_DIR32)
	    continue;

	  if (ELF32_R_SYM (irelscan->r_info) >= symtab_hdr->sh_info)
	    continue;


	  isym = isymbuf + ELF32_R_SYM (irelscan->r_info);
	  if (isym->st_shndx == sec_shndx
	      && (isym->st_value <= addr
		  || isym->st_value >= toaddr))
	    {
	      bfd_vma val;

	      if (ocontents == NULL)
		{
		  if (elf_section_data (o)->this_hdr.contents != NULL)
		    ocontents = elf_section_data (o)->this_hdr.contents;
		  else
		    {
		      /* We always cache the section contents.
			 Perhaps, if info->keep_memory is FALSE, we
			 should free them, if we are permitted to,
			 when we leave sh_coff_relax_section.  */
		      if (!bfd_malloc_and_get_section (abfd, o, &ocontents))
			{
			  if (ocontents != NULL)
			    free (ocontents);
			  return FALSE;
			}

		      elf_section_data (o)->this_hdr.contents = ocontents;
		    }
		}

	      val = bfd_get_32 (abfd, ocontents + irelscan->r_offset);
	      val += isym->st_value;
	      if (val > addr && val < toaddr)
		bfd_put_32 (abfd, val - count,
			    ocontents + irelscan->r_offset);
	    }
	}
    }

  /* Adjust the local symbols defined in this section.  */
  isymend = isymbuf + symtab_hdr->sh_info;
  for (isym = isymbuf; isym < isymend; isym++)
    {
      if (isym->st_shndx == sec_shndx
	  && isym->st_value > addr
	  && isym->st_value < toaddr)
	isym->st_value -= count;
    }

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;
      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value > addr
	  && sym_hash->root.u.def.value < toaddr)
	{
	  sym_hash->root.u.def.value -= count;
	}
    }

  /* See if we can move the ALIGN reloc forward.  We have adjusted
     r_offset for it already.  */
  if (irelalign != NULL)
    {
      bfd_vma alignto, alignaddr;

      alignto = BFD_ALIGN (toaddr, 1 << irelalign->r_addend);
      alignaddr = BFD_ALIGN (irelalign->r_offset,
			     1 << irelalign->r_addend);
      if (alignto != alignaddr)
	{
	  /* Tail recursion.  */
	  return sh_elf_relax_delete_bytes (abfd, sec, alignaddr,
					    (int) (alignto - alignaddr));
	}
    }

  return TRUE;
}

/* Look for loads and stores which we can align to four byte
   boundaries.  This is like sh_align_loads in coff-sh.c.  */

static bfd_boolean
sh_elf_align_loads (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
		    Elf_Internal_Rela *internal_relocs,
		    bfd_byte *contents ATTRIBUTE_UNUSED,
		    bfd_boolean *pswapped)
{
  Elf_Internal_Rela *irel, *irelend;
  bfd_vma *labels = NULL;
  bfd_vma *label, *label_end;
  bfd_size_type amt;

  *pswapped = FALSE;

  irelend = internal_relocs + sec->reloc_count;

  /* Get all the addresses with labels on them.  */
  amt = sec->reloc_count;
  amt *= sizeof (bfd_vma);
  labels = (bfd_vma *) bfd_malloc (amt);
  if (labels == NULL)
    goto error_return;
  label_end = labels;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      if (ELF32_R_TYPE (irel->r_info) == (int) R_SH_LABEL)
	{
	  *label_end = irel->r_offset;
	  ++label_end;
	}
    }

  /* Note that the assembler currently always outputs relocs in
     address order.  If that ever changes, this code will need to sort
     the label values and the relocs.  */

  label = labels;

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma start, stop;

      if (ELF32_R_TYPE (irel->r_info) != (int) R_SH_CODE)
	continue;

      start = irel->r_offset;

      for (irel++; irel < irelend; irel++)
	if (ELF32_R_TYPE (irel->r_info) == (int) R_SH_DATA)
	  break;
      if (irel < irelend)
	stop = irel->r_offset;
      else
	stop = sec->size;

      if (! _bfd_sh_align_load_span (abfd, sec, contents, sh_elf_swap_insns,
				     internal_relocs, &label,
				     label_end, start, stop, pswapped))
	goto error_return;
    }

  free (labels);

  return TRUE;

 error_return:
  if (labels != NULL)
    free (labels);
  return FALSE;
}

#ifndef SH64_ELF
/* Swap two SH instructions.  This is like sh_swap_insns in coff-sh.c.  */

static bfd_boolean
sh_elf_swap_insns (bfd *abfd, asection *sec, void *relocs,
		   bfd_byte *contents, bfd_vma addr)
{
  Elf_Internal_Rela *internal_relocs = (Elf_Internal_Rela *) relocs;
  unsigned short i1, i2;
  Elf_Internal_Rela *irel, *irelend;

  /* Swap the instructions themselves.  */
  i1 = bfd_get_16 (abfd, contents + addr);
  i2 = bfd_get_16 (abfd, contents + addr + 2);
  bfd_put_16 (abfd, (bfd_vma) i2, contents + addr);
  bfd_put_16 (abfd, (bfd_vma) i1, contents + addr + 2);

  /* Adjust all reloc addresses.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      enum elf_sh_reloc_type type;
      int add;

      /* There are a few special types of relocs that we don't want to
	 adjust.  These relocs do not apply to the instruction itself,
	 but are only associated with the address.  */
      type = (enum elf_sh_reloc_type) ELF32_R_TYPE (irel->r_info);
      if (type == R_SH_ALIGN
	  || type == R_SH_CODE
	  || type == R_SH_DATA
	  || type == R_SH_LABEL)
	continue;

      /* If an R_SH_USES reloc points to one of the addresses being
	 swapped, we must adjust it.  It would be incorrect to do this
	 for a jump, though, since we want to execute both
	 instructions after the jump.  (We have avoided swapping
	 around a label, so the jump will not wind up executing an
	 instruction it shouldn't).  */
      if (type == R_SH_USES)
	{
	  bfd_vma off;

	  off = irel->r_offset + 4 + irel->r_addend;
	  if (off == addr)
	    irel->r_offset += 2;
	  else if (off == addr + 2)
	    irel->r_offset -= 2;
	}

      if (irel->r_offset == addr)
	{
	  irel->r_offset += 2;
	  add = -2;
	}
      else if (irel->r_offset == addr + 2)
	{
	  irel->r_offset -= 2;
	  add = 2;
	}
      else
	add = 0;

      if (add != 0)
	{
	  bfd_byte *loc;
	  unsigned short insn, oinsn;
	  bfd_boolean overflow;

	  loc = contents + irel->r_offset;
	  overflow = FALSE;
	  switch (type)
	    {
	    default:
	      break;

	    case R_SH_DIR8WPN:
	    case R_SH_DIR8WPZ:
	      insn = bfd_get_16 (abfd, loc);
	      oinsn = insn;
	      insn += add / 2;
	      if ((oinsn & 0xff00) != (insn & 0xff00))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, loc);
	      break;

	    case R_SH_IND12W:
	      insn = bfd_get_16 (abfd, loc);
	      oinsn = insn;
	      insn += add / 2;
	      if ((oinsn & 0xf000) != (insn & 0xf000))
		overflow = TRUE;
	      bfd_put_16 (abfd, (bfd_vma) insn, loc);
	      break;

	    case R_SH_DIR8WPL:
	      /* This reloc ignores the least significant 3 bits of
		 the program counter before adding in the offset.
		 This means that if ADDR is at an even address, the
		 swap will not affect the offset.  If ADDR is an at an
		 odd address, then the instruction will be crossing a
		 four byte boundary, and must be adjusted.  */
	      if ((addr & 3) != 0)
		{
		  insn = bfd_get_16 (abfd, loc);
		  oinsn = insn;
		  insn += add / 2;
		  if ((oinsn & 0xff00) != (insn & 0xff00))
		    overflow = TRUE;
		  bfd_put_16 (abfd, (bfd_vma) insn, loc);
		}

	      break;
	    }

	  if (overflow)
	    {
	      ((*_bfd_error_handler)
	       (_("%B: 0x%lx: fatal: reloc overflow while relaxing"),
		abfd, (unsigned long) irel->r_offset));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}
    }

  return TRUE;
}
#endif /* defined SH64_ELF */

/* Describes one of the various PLT styles.  */

struct elf_sh_plt_info
{
  /* The template for the first PLT entry, or NULL if there is no special
     first entry.  */
  const bfd_byte *plt0_entry;

  /* The size of PLT0_ENTRY in bytes, or 0 if PLT0_ENTRY is NULL.  */
  bfd_vma plt0_entry_size;

  /* Index I is the offset into PLT0_ENTRY of a pointer to
     _GLOBAL_OFFSET_TABLE_ + I * 4.  The value is MINUS_ONE
     if there is no such pointer.  */
  bfd_vma plt0_got_fields[3];

  /* The template for a symbol's PLT entry.  */
  const bfd_byte *symbol_entry;

  /* The size of SYMBOL_ENTRY in bytes.  */
  bfd_vma symbol_entry_size;

  /* Byte offsets of fields in SYMBOL_ENTRY.  Not all fields are used
     on all targets.  The comments by each member indicate the value
     that the field must hold.  */
  struct {
    bfd_vma got_entry; /* the address of the symbol's .got.plt entry */
    bfd_vma plt; /* .plt (or a branch to .plt on VxWorks) */
    bfd_vma reloc_offset; /* the offset of the symbol's JMP_SLOT reloc */
    bfd_boolean got20; /* TRUE if got_entry points to a movi20
			  instruction (instead of a constant pool
			  entry).  */
  } symbol_fields;

  /* The offset of the resolver stub from the start of SYMBOL_ENTRY.  */
  bfd_vma symbol_resolve_offset;

  /* A different PLT layout which can be used for the first
     MAX_SHORT_PLT entries.  It must share the same plt0.  NULL in
     other cases.  */
  const struct elf_sh_plt_info *short_plt;
};

#ifdef INCLUDE_SHMEDIA

/* The size in bytes of an entry in the procedure linkage table.  */

#define ELF_PLT_ENTRY_SIZE 64

/* First entry in an absolute procedure linkage table look like this.  */

static const bfd_byte elf_sh_plt0_entry_be[ELF_PLT_ENTRY_SIZE] =
{
  0xcc, 0x00, 0x01, 0x10, /* movi  .got.plt >> 16, r17 */
  0xc8, 0x00, 0x01, 0x10, /* shori .got.plt & 65535, r17 */
  0x89, 0x10, 0x09, 0x90, /* ld.l  r17, 8, r25 */
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
  0x89, 0x10, 0x05, 0x10, /* ld.l  r17, 4, r17 */
  0x44, 0x01, 0xff, 0xf0, /* blink tr0, r63 */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
};

static const bfd_byte elf_sh_plt0_entry_le[ELF_PLT_ENTRY_SIZE] =
{
  0x10, 0x01, 0x00, 0xcc, /* movi  .got.plt >> 16, r17 */
  0x10, 0x01, 0x00, 0xc8, /* shori .got.plt & 65535, r17 */
  0x90, 0x09, 0x10, 0x89, /* ld.l  r17, 8, r25 */
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
  0x10, 0x05, 0x10, 0x89, /* ld.l  r17, 4, r17 */
  0xf0, 0xff, 0x01, 0x44, /* blink tr0, r63 */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
};

/* Sebsequent entries in an absolute procedure linkage table look like
   this.  */

static const bfd_byte elf_sh_plt_entry_be[ELF_PLT_ENTRY_SIZE] =
{
  0xcc, 0x00, 0x01, 0x90, /* movi  nameN-in-GOT >> 16, r25 */
  0xc8, 0x00, 0x01, 0x90, /* shori nameN-in-GOT & 65535, r25 */
  0x89, 0x90, 0x01, 0x90, /* ld.l  r25, 0, r25 */
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
  0x44, 0x01, 0xff, 0xf0, /* blink tr0, r63 */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0xcc, 0x00, 0x01, 0x90, /* movi  .PLT0 >> 16, r25 */
  0xc8, 0x00, 0x01, 0x90, /* shori .PLT0 & 65535, r25 */
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
  0xcc, 0x00, 0x01, 0x50, /* movi  reloc-offset >> 16, r21 */
  0xc8, 0x00, 0x01, 0x50, /* shori reloc-offset & 65535, r21 */
  0x44, 0x01, 0xff, 0xf0, /* blink tr0, r63 */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
};

static const bfd_byte elf_sh_plt_entry_le[ELF_PLT_ENTRY_SIZE] =
{
  0x90, 0x01, 0x00, 0xcc, /* movi  nameN-in-GOT >> 16, r25 */
  0x90, 0x01, 0x00, 0xc8, /* shori nameN-in-GOT & 65535, r25 */
  0x90, 0x01, 0x90, 0x89, /* ld.l  r25, 0, r25 */
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
  0xf0, 0xff, 0x01, 0x44, /* blink tr0, r63 */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0x90, 0x01, 0x00, 0xcc, /* movi  .PLT0 >> 16, r25 */
  0x90, 0x01, 0x00, 0xc8, /* shori .PLT0 & 65535, r25 */
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
  0x50, 0x01, 0x00, 0xcc, /* movi  reloc-offset >> 16, r21 */
  0x50, 0x01, 0x00, 0xc8, /* shori reloc-offset & 65535, r21 */
  0xf0, 0xff, 0x01, 0x44, /* blink tr0, r63 */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
};

/* Entries in a PIC procedure linkage table look like this.  */

static const bfd_byte elf_sh_pic_plt_entry_be[ELF_PLT_ENTRY_SIZE] =
{
  0xcc, 0x00, 0x01, 0x90, /* movi  nameN@@GOT >> 16, r25 */
  0xc8, 0x00, 0x01, 0x90, /* shori nameN@@GOT & 65535, r25 */
  0x40, 0xc2, 0x65, 0x90, /* ldx.l r12, r25, r25 */
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
  0x44, 0x01, 0xff, 0xf0, /* blink tr0, r63 */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0xce, 0x00, 0x01, 0x10, /* movi  -GOT_BIAS, r17 */
  0x00, 0xc8, 0x45, 0x10, /* add.l r12, r17, r17 */
  0x89, 0x10, 0x09, 0x90, /* ld.l  r17, 8, r25 */
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
  0x89, 0x10, 0x05, 0x10, /* ld.l  r17, 4, r17 */
  0xcc, 0x00, 0x01, 0x50, /* movi  reloc-offset >> 16, r21 */
  0xc8, 0x00, 0x01, 0x50, /* shori reloc-offset & 65535, r21 */
  0x44, 0x01, 0xff, 0xf0, /* blink tr0, r63 */
};

static const bfd_byte elf_sh_pic_plt_entry_le[ELF_PLT_ENTRY_SIZE] =
{
  0x90, 0x01, 0x00, 0xcc, /* movi  nameN@@GOT >> 16, r25 */
  0x90, 0x01, 0x00, 0xc8, /* shori nameN@@GOT & 65535, r25 */
  0x90, 0x65, 0xc2, 0x40, /* ldx.l r12, r25, r25 */
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
  0xf0, 0xff, 0x01, 0x44, /* blink tr0, r63 */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0x10, 0x01, 0x00, 0xce, /* movi  -GOT_BIAS, r17 */
  0x10, 0x45, 0xc8, 0x00, /* add.l r12, r17, r17 */
  0x90, 0x09, 0x10, 0x89, /* ld.l  r17, 8, r25 */
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
  0x10, 0x05, 0x10, 0x89, /* ld.l  r17, 4, r17 */
  0x50, 0x01, 0x00, 0xcc, /* movi  reloc-offset >> 16, r21 */
  0x50, 0x01, 0x00, 0xc8, /* shori reloc-offset & 65535, r21 */
  0xf0, 0xff, 0x01, 0x44, /* blink tr0, r63 */
};

static const struct elf_sh_plt_info elf_sh_plts[2][2] = {
  {
    {
      /* Big-endian non-PIC.  */
      elf_sh_plt0_entry_be,
      ELF_PLT_ENTRY_SIZE,
      { 0, MINUS_ONE, MINUS_ONE },
      elf_sh_plt_entry_be,
      ELF_PLT_ENTRY_SIZE,
      { 0, 32, 48, FALSE },
      33, /* includes ISA encoding */
      NULL
    },
    {
      /* Little-endian non-PIC.  */
      elf_sh_plt0_entry_le,
      ELF_PLT_ENTRY_SIZE,
      { 0, MINUS_ONE, MINUS_ONE },
      elf_sh_plt_entry_le,
      ELF_PLT_ENTRY_SIZE,
      { 0, 32, 48, FALSE },
      33, /* includes ISA encoding */
      NULL
    },
  },
  {
    {
      /* Big-endian PIC.  */
      elf_sh_plt0_entry_be,
      ELF_PLT_ENTRY_SIZE,
      { MINUS_ONE, MINUS_ONE, MINUS_ONE },
      elf_sh_pic_plt_entry_be,
      ELF_PLT_ENTRY_SIZE,
      { 0, MINUS_ONE, 52, FALSE },
      33, /* includes ISA encoding */
      NULL
    },
    {
      /* Little-endian PIC.  */
      elf_sh_plt0_entry_le,
      ELF_PLT_ENTRY_SIZE,
      { MINUS_ONE, MINUS_ONE, MINUS_ONE },
      elf_sh_pic_plt_entry_le,
      ELF_PLT_ENTRY_SIZE,
      { 0, MINUS_ONE, 52, FALSE },
      33, /* includes ISA encoding */
      NULL
    },
  }
};

/* Return offset of the linker in PLT0 entry.  */
#define elf_sh_plt0_gotplt_offset(info) 0

/* Install a 32-bit PLT field starting at ADDR, which occurs in OUTPUT_BFD.
   VALUE is the field's value and CODE_P is true if VALUE refers to code,
   not data.

   On SH64, each 32-bit field is loaded by a movi/shori pair.  */

inline static void
install_plt_field (bfd *output_bfd, bfd_boolean code_p,
		   unsigned long value, bfd_byte *addr)
{
  value |= code_p;
  bfd_put_32 (output_bfd,
	      bfd_get_32 (output_bfd, addr)
	      | ((value >> 6) & 0x3fffc00),
	      addr);
  bfd_put_32 (output_bfd,
	      bfd_get_32 (output_bfd, addr + 4)
	      | ((value << 10) & 0x3fffc00),
	      addr + 4);
}

/* Return the type of PLT associated with ABFD.  PIC_P is true if
   the object is position-independent.  */

static const struct elf_sh_plt_info *
get_plt_info (bfd *abfd ATTRIBUTE_UNUSED, bfd_boolean pic_p)
{
  return &elf_sh_plts[pic_p][!bfd_big_endian (abfd)];
}
#else
/* The size in bytes of an entry in the procedure linkage table.  */

#define ELF_PLT_ENTRY_SIZE 28

/* First entry in an absolute procedure linkage table look like this.  */

/* Note - this code has been "optimised" not to use r2.  r2 is used by
   GCC to return the address of large structures, so it should not be
   corrupted here.  This does mean however, that this PLT does not conform
   to the SH PIC ABI.  That spec says that r0 contains the type of the PLT
   and r2 contains the GOT id.  This version stores the GOT id in r0 and
   ignores the type.  Loaders can easily detect this difference however,
   since the type will always be 0 or 8, and the GOT ids will always be
   greater than or equal to 12.  */
static const bfd_byte elf_sh_plt0_entry_be[ELF_PLT_ENTRY_SIZE] =
{
  0xd0, 0x05,	/* mov.l 2f,r0 */
  0x60, 0x02,	/* mov.l @@r0,r0 */
  0x2f, 0x06,	/* mov.l r0,@@-r15 */
  0xd0, 0x03,	/* mov.l 1f,r0 */
  0x60, 0x02,	/* mov.l @@r0,r0 */
  0x40, 0x2b,	/* jmp @@r0 */
  0x60, 0xf6,	/*  mov.l @@r15+,r0 */
  0x00, 0x09,	/* nop */
  0x00, 0x09,	/* nop */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with address of .got.plt + 8.  */
  0, 0, 0, 0,	/* 2: replaced with address of .got.plt + 4.  */
};

static const bfd_byte elf_sh_plt0_entry_le[ELF_PLT_ENTRY_SIZE] =
{
  0x05, 0xd0,	/* mov.l 2f,r0 */
  0x02, 0x60,	/* mov.l @@r0,r0 */
  0x06, 0x2f,	/* mov.l r0,@@-r15 */
  0x03, 0xd0,	/* mov.l 1f,r0 */
  0x02, 0x60,	/* mov.l @@r0,r0 */
  0x2b, 0x40,	/* jmp @@r0 */
  0xf6, 0x60,	/*  mov.l @@r15+,r0 */
  0x09, 0x00,	/* nop */
  0x09, 0x00,	/* nop */
  0x09, 0x00,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with address of .got.plt + 8.  */
  0, 0, 0, 0,	/* 2: replaced with address of .got.plt + 4.  */
};

/* Sebsequent entries in an absolute procedure linkage table look like
   this.  */

static const bfd_byte elf_sh_plt_entry_be[ELF_PLT_ENTRY_SIZE] =
{
  0xd0, 0x04,	/* mov.l 1f,r0 */
  0x60, 0x02,	/* mov.l @@(r0,r12),r0 */
  0xd1, 0x02,	/* mov.l 0f,r1 */
  0x40, 0x2b,   /* jmp @@r0 */
  0x60, 0x13,	/*  mov r1,r0 */
  0xd1, 0x03,	/* mov.l 2f,r1 */
  0x40, 0x2b,	/* jmp @@r0 */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0,	/* 0: replaced with address of .PLT0.  */
  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
  0, 0, 0, 0,	/* 2: replaced with offset into relocation table.  */
};

static const bfd_byte elf_sh_plt_entry_le[ELF_PLT_ENTRY_SIZE] =
{
  0x04, 0xd0,	/* mov.l 1f,r0 */
  0x02, 0x60,	/* mov.l @@r0,r0 */
  0x02, 0xd1,	/* mov.l 0f,r1 */
  0x2b, 0x40,   /* jmp @@r0 */
  0x13, 0x60,	/*  mov r1,r0 */
  0x03, 0xd1,	/* mov.l 2f,r1 */
  0x2b, 0x40,	/* jmp @@r0 */
  0x09, 0x00,	/*  nop */
  0, 0, 0, 0,	/* 0: replaced with address of .PLT0.  */
  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
  0, 0, 0, 0,	/* 2: replaced with offset into relocation table.  */
};

/* Entries in a PIC procedure linkage table look like this.  */

static const bfd_byte elf_sh_pic_plt_entry_be[ELF_PLT_ENTRY_SIZE] =
{
  0xd0, 0x04,	/* mov.l 1f,r0 */
  0x00, 0xce,	/* mov.l @@(r0,r12),r0 */
  0x40, 0x2b,	/* jmp @@r0 */
  0x00, 0x09,	/*  nop */
  0x50, 0xc2,	/* mov.l @@(8,r12),r0 */
  0xd1, 0x03,	/* mov.l 2f,r1 */
  0x40, 0x2b,	/* jmp @@r0 */
  0x50, 0xc1,	/*  mov.l @@(4,r12),r0 */
  0x00, 0x09,	/* nop */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
  0, 0, 0, 0    /* 2: replaced with offset into relocation table.  */
};

static const bfd_byte elf_sh_pic_plt_entry_le[ELF_PLT_ENTRY_SIZE] =
{
  0x04, 0xd0,	/* mov.l 1f,r0 */
  0xce, 0x00,	/* mov.l @@(r0,r12),r0 */
  0x2b, 0x40,	/* jmp @@r0 */
  0x09, 0x00,	/*  nop */
  0xc2, 0x50,	/* mov.l @@(8,r12),r0 */
  0x03, 0xd1,	/* mov.l 2f,r1 */
  0x2b, 0x40,	/* jmp @@r0 */
  0xc1, 0x50,	/*  mov.l @@(4,r12),r0 */
  0x09, 0x00,	/*  nop */
  0x09, 0x00,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
  0, 0, 0, 0    /* 2: replaced with offset into relocation table.  */
};

static const struct elf_sh_plt_info elf_sh_plts[2][2] = {
  {
    {
      /* Big-endian non-PIC.  */
      elf_sh_plt0_entry_be,
      ELF_PLT_ENTRY_SIZE,
      { MINUS_ONE, 24, 20 },
      elf_sh_plt_entry_be,
      ELF_PLT_ENTRY_SIZE,
      { 20, 16, 24, FALSE },
      8,
      NULL
    },
    {
      /* Little-endian non-PIC.  */
      elf_sh_plt0_entry_le,
      ELF_PLT_ENTRY_SIZE,
      { MINUS_ONE, 24, 20 },
      elf_sh_plt_entry_le,
      ELF_PLT_ENTRY_SIZE,
      { 20, 16, 24, FALSE },
      8,
      NULL
    },
  },
  {
    {
      /* Big-endian PIC.  */
      elf_sh_plt0_entry_be,
      ELF_PLT_ENTRY_SIZE,
      { MINUS_ONE, MINUS_ONE, MINUS_ONE },
      elf_sh_pic_plt_entry_be,
      ELF_PLT_ENTRY_SIZE,
      { 20, MINUS_ONE, 24, FALSE },
      8,
      NULL
    },
    {
      /* Little-endian PIC.  */
      elf_sh_plt0_entry_le,
      ELF_PLT_ENTRY_SIZE,
      { MINUS_ONE, MINUS_ONE, MINUS_ONE },
      elf_sh_pic_plt_entry_le,
      ELF_PLT_ENTRY_SIZE,
      { 20, MINUS_ONE, 24, FALSE },
      8,
      NULL
    },
  }
};

#define VXWORKS_PLT_HEADER_SIZE 12
#define VXWORKS_PLT_ENTRY_SIZE 24

static const bfd_byte vxworks_sh_plt0_entry_be[VXWORKS_PLT_HEADER_SIZE] =
{
  0xd1, 0x01,	/* mov.l @@(8,pc),r1 */
  0x61, 0x12,	/* mov.l @@r1,r1 */
  0x41, 0x2b,	/* jmp @@r1 */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0	/* 0: replaced with _GLOBAL_OFFSET_TABLE+8.  */
};

static const bfd_byte vxworks_sh_plt0_entry_le[VXWORKS_PLT_HEADER_SIZE] =
{
  0x01, 0xd1,	/* mov.l @@(8,pc),r1 */
  0x12, 0x61,	/* mov.l @@r1,r1 */
  0x2b, 0x41,	/* jmp @@r1 */
  0x09, 0x00,	/* nop */
  0, 0, 0, 0	/* 0: replaced with _GLOBAL_OFFSET_TABLE+8.  */
};

static const bfd_byte vxworks_sh_plt_entry_be[VXWORKS_PLT_ENTRY_SIZE] =
{
  0xd0, 0x01,	/* mov.l @@(8,pc),r0 */
  0x60, 0x02,	/* mov.l @@r0,r0 */
  0x40, 0x2b,	/* jmp @@r0 */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0,	/* 0: replaced with address of this symbol in .got.  */
  0xd0, 0x01,	/* mov.l @@(8,pc),r0 */
  0xa0, 0x00,	/* bra PLT (We need to fix the offset.)  */
  0x00, 0x09,	/* nop */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with offset into relocation table.  */
};

static const bfd_byte vxworks_sh_plt_entry_le[VXWORKS_PLT_ENTRY_SIZE] =
{
  0x01, 0xd0,	/* mov.l @@(8,pc),r0 */
  0x02, 0x60,	/* mov.l @@r0,r0 */
  0x2b, 0x40,	/* jmp @@r0 */
  0x09, 0x00,	/* nop */
  0, 0, 0, 0,	/* 0: replaced with address of this symbol in .got.  */
  0x01, 0xd0,	/* mov.l @@(8,pc),r0 */
  0x00, 0xa0,	/* bra PLT (We need to fix the offset.)  */
  0x09, 0x00,	/* nop */
  0x09, 0x00,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with offset into relocation table.  */
};

static const bfd_byte vxworks_sh_pic_plt_entry_be[VXWORKS_PLT_ENTRY_SIZE] =
{
  0xd0, 0x01,	/* mov.l @@(8,pc),r0 */
  0x00, 0xce,	/* mov.l @@(r0,r12),r0 */
  0x40, 0x2b,	/* jmp @@r0 */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0,	/* 0: replaced with offset of this symbol in .got.  */
  0xd0, 0x01,	/* mov.l @@(8,pc),r0 */
  0x51, 0xc2,	/* mov.l @@(8,r12),r1 */
  0x41, 0x2b,	/* jmp @@r1 */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with offset into relocation table.  */
};

static const bfd_byte vxworks_sh_pic_plt_entry_le[VXWORKS_PLT_ENTRY_SIZE] =
{
  0x01, 0xd0,	/* mov.l @@(8,pc),r0 */
  0xce, 0x00,	/* mov.l @@(r0,r12),r0 */
  0x2b, 0x40,	/* jmp @@r0 */
  0x09, 0x00,	/* nop */
  0, 0, 0, 0,	/* 0: replaced with offset of this symbol in .got.  */
  0x01, 0xd0,	/* mov.l @@(8,pc),r0 */
  0xc2, 0x51,	/* mov.l @@(8,r12),r1 */
  0x2b, 0x41,	/* jmp @@r1 */
  0x09, 0x00,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with offset into relocation table.  */
};

static const struct elf_sh_plt_info vxworks_sh_plts[2][2] = {
  {
    {
      /* Big-endian non-PIC.  */
      vxworks_sh_plt0_entry_be,
      VXWORKS_PLT_HEADER_SIZE,
      { MINUS_ONE, MINUS_ONE, 8 },
      vxworks_sh_plt_entry_be,
      VXWORKS_PLT_ENTRY_SIZE,
      { 8, 14, 20, FALSE },
      12,
      NULL
    },
    {
      /* Little-endian non-PIC.  */
      vxworks_sh_plt0_entry_le,
      VXWORKS_PLT_HEADER_SIZE,
      { MINUS_ONE, MINUS_ONE, 8 },
      vxworks_sh_plt_entry_le,
      VXWORKS_PLT_ENTRY_SIZE,
      { 8, 14, 20, FALSE },
      12,
      NULL
    },
  },
  {
    {
      /* Big-endian PIC.  */
      NULL,
      0,
      { MINUS_ONE, MINUS_ONE, MINUS_ONE },
      vxworks_sh_pic_plt_entry_be,
      VXWORKS_PLT_ENTRY_SIZE,
      { 8, MINUS_ONE, 20, FALSE },
      12,
      NULL
    },
    {
      /* Little-endian PIC.  */
      NULL,
      0,
      { MINUS_ONE, MINUS_ONE, MINUS_ONE },
      vxworks_sh_pic_plt_entry_le,
      VXWORKS_PLT_ENTRY_SIZE,
      { 8, MINUS_ONE, 20, FALSE },
      12,
      NULL
    },
  }
};

/* FDPIC PLT entries.  Two unimplemented optimizations for lazy
   binding are to omit the lazy binding stub when linking with -z now
   and to move lazy binding stubs into a separate region for better
   cache behavior.  */

#define FDPIC_PLT_ENTRY_SIZE 28
#define FDPIC_PLT_LAZY_OFFSET 20

/* FIXME: The lazy binding stub requires a plt0 - which may need to be
   duplicated if it is out of range, or which can be inlined.  So
   right now it is always inlined, which wastes a word per stub.  It
   might be easier to handle the duplication if we put the lazy
   stubs separately.  */

static const bfd_byte fdpic_sh_plt_entry_be[FDPIC_PLT_ENTRY_SIZE] =
{
  0xd0, 0x02,	/* mov.l @@(12,pc),r0 */
  0x01, 0xce,	/* mov.l @@(r0,r12),r1 */
  0x70, 0x04,	/* add #4, r0 */
  0x41, 0x2b,	/* jmp @@r1 */
  0x0c, 0xce,	/* mov.l @@(r0,r12),r12 */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0,	/* 0: replaced with offset of this symbol's funcdesc */
  0, 0, 0, 0,	/* 1: replaced with offset into relocation table.  */
  0x60, 0xc2,	/* mov.l @@r12,r0 */
  0x40, 0x2b,	/* jmp @@r0 */
  0x53, 0xc1,	/*  mov.l @@(4,r12),r3 */
  0x00, 0x09,	/* nop */
};

static const bfd_byte fdpic_sh_plt_entry_le[FDPIC_PLT_ENTRY_SIZE] =
{
  0x02, 0xd0,	/* mov.l @@(12,pc),r0 */
  0xce, 0x01,	/* mov.l @@(r0,r12),r1 */
  0x04, 0x70,	/* add #4, r0 */
  0x2b, 0x41,	/* jmp @@r1 */
  0xce, 0x0c,	/* mov.l @@(r0,r12),r12 */
  0x09, 0x00,	/* nop */
  0, 0, 0, 0,	/* 0: replaced with offset of this symbol's funcdesc */
  0, 0, 0, 0,	/* 1: replaced with offset into relocation table.  */
  0xc2, 0x60,	/* mov.l @@r12,r0 */
  0x2b, 0x40,	/* jmp @@r0 */
  0xc1, 0x53,	/*  mov.l @@(4,r12),r3 */
  0x09, 0x00,	/* nop */
};

static const struct elf_sh_plt_info fdpic_sh_plts[2] = {
  {
    /* Big-endian PIC.  */
    NULL,
    0,
    { MINUS_ONE, MINUS_ONE, MINUS_ONE },
    fdpic_sh_plt_entry_be,
    FDPIC_PLT_ENTRY_SIZE,
    { 12, MINUS_ONE, 16, FALSE },
    FDPIC_PLT_LAZY_OFFSET,
    NULL
  },
  {
    /* Little-endian PIC.  */
    NULL,
    0,
    { MINUS_ONE, MINUS_ONE, MINUS_ONE },
    fdpic_sh_plt_entry_le,
    FDPIC_PLT_ENTRY_SIZE,
    { 12, MINUS_ONE, 16, FALSE },
    FDPIC_PLT_LAZY_OFFSET,
    NULL
  },
};

/* On SH2A, we can use the movi20 instruction to generate shorter PLT
   entries for the first 64K slots.  We use the normal FDPIC PLT entry
   past that point; we could also use movi20s, which might be faster,
   but would not be any smaller.  */

#define FDPIC_SH2A_PLT_ENTRY_SIZE 24
#define FDPIC_SH2A_PLT_LAZY_OFFSET 16

static const bfd_byte fdpic_sh2a_plt_entry_be[FDPIC_SH2A_PLT_ENTRY_SIZE] =
{
  0, 0, 0, 0,	/* movi20 #gotofffuncdesc,r0 */
  0x01, 0xce,	/* mov.l @@(r0,r12),r1 */
  0x70, 0x04,	/* add #4, r0 */
  0x41, 0x2b,	/* jmp @@r1 */
  0x0c, 0xce,	/* mov.l @@(r0,r12),r12 */
  0, 0, 0, 0,	/* 1: replaced with offset into relocation table.  */
  0x60, 0xc2,	/* mov.l @@r12,r0 */
  0x40, 0x2b,	/* jmp @@r0 */
  0x53, 0xc1,	/*  mov.l @@(4,r12),r3 */
  0x00, 0x09,	/* nop */
};

static const bfd_byte fdpic_sh2a_plt_entry_le[FDPIC_SH2A_PLT_ENTRY_SIZE] =
{
  0, 0, 0, 0,	/* movi20 #gotofffuncdesc,r0 */
  0xce, 0x01,	/* mov.l @@(r0,r12),r1 */
  0x04, 0x70,	/* add #4, r0 */
  0x2b, 0x41,	/* jmp @@r1 */
  0xce, 0x0c,	/* mov.l @@(r0,r12),r12 */
  0, 0, 0, 0,	/* 1: replaced with offset into relocation table.  */
  0xc2, 0x60,	/* mov.l @@r12,r0 */
  0x2b, 0x40,	/* jmp @@r0 */
  0xc1, 0x53,	/*  mov.l @@(4,r12),r3 */
  0x09, 0x00,	/* nop */
};

static const struct elf_sh_plt_info fdpic_sh2a_short_plt_be = {
  /* Big-endian FDPIC, max index 64K.  */
  NULL,
  0,
  { MINUS_ONE, MINUS_ONE, MINUS_ONE },
  fdpic_sh2a_plt_entry_be,
  FDPIC_SH2A_PLT_ENTRY_SIZE,
  { 0, MINUS_ONE, 12, TRUE },
  FDPIC_SH2A_PLT_LAZY_OFFSET,
  NULL
};

static const struct elf_sh_plt_info fdpic_sh2a_short_plt_le = {
  /* Little-endian FDPIC, max index 64K.  */
  NULL,
  0,
  { MINUS_ONE, MINUS_ONE, MINUS_ONE },
  fdpic_sh2a_plt_entry_le,
  FDPIC_SH2A_PLT_ENTRY_SIZE,
  { 0, MINUS_ONE, 12, TRUE },
  FDPIC_SH2A_PLT_LAZY_OFFSET,
  NULL
};

static const struct elf_sh_plt_info fdpic_sh2a_plts[2] = {
  {
    /* Big-endian PIC.  */
    NULL,
    0,
    { MINUS_ONE, MINUS_ONE, MINUS_ONE },
    fdpic_sh_plt_entry_be,
    FDPIC_PLT_ENTRY_SIZE,
    { 12, MINUS_ONE, 16, FALSE },
    FDPIC_PLT_LAZY_OFFSET,
    &fdpic_sh2a_short_plt_be
  },
  {
    /* Little-endian PIC.  */
    NULL,
    0,
    { MINUS_ONE, MINUS_ONE, MINUS_ONE },
    fdpic_sh_plt_entry_le,
    FDPIC_PLT_ENTRY_SIZE,
    { 12, MINUS_ONE, 16, FALSE },
    FDPIC_PLT_LAZY_OFFSET,
    &fdpic_sh2a_short_plt_le
  },
};

/* Return the type of PLT associated with ABFD.  PIC_P is true if
   the object is position-independent.  */

static const struct elf_sh_plt_info *
get_plt_info (bfd *abfd, bfd_boolean pic_p)
{
  if (fdpic_object_p (abfd))
    {
      /* If any input file requires SH2A we can use a shorter PLT
	 sequence.  */
      if (sh_get_arch_from_bfd_mach (bfd_get_mach (abfd)) & arch_sh2a_base)
	return &fdpic_sh2a_plts[!bfd_big_endian (abfd)];
      else
	return &fdpic_sh_plts[!bfd_big_endian (abfd)];
    }
  if (vxworks_object_p (abfd))
    return &vxworks_sh_plts[pic_p][!bfd_big_endian (abfd)];
  return &elf_sh_plts[pic_p][!bfd_big_endian (abfd)];
}

/* Install a 32-bit PLT field starting at ADDR, which occurs in OUTPUT_BFD.
   VALUE is the field's value and CODE_P is true if VALUE refers to code,
   not data.  */

inline static void
install_plt_field (bfd *output_bfd, bfd_boolean code_p ATTRIBUTE_UNUSED,
		   unsigned long value, bfd_byte *addr)
{
  bfd_put_32 (output_bfd, value, addr);
}
#endif

/* The number of PLT entries which can use a shorter PLT, if any.
   Currently always 64K, since only SH-2A FDPIC uses this; a
   20-bit movi20 can address that many function descriptors below
   _GLOBAL_OFFSET_TABLE_.  */
#define MAX_SHORT_PLT 65536

/* Return the index of the PLT entry at byte offset OFFSET.  */

static bfd_vma
get_plt_index (const struct elf_sh_plt_info *info, bfd_vma offset)
{
  bfd_vma plt_index = 0;

  offset -= info->plt0_entry_size;
  if (info->short_plt != NULL)
    {
      if (offset > MAX_SHORT_PLT * info->short_plt->symbol_entry_size)
	{
	  plt_index = MAX_SHORT_PLT;
	  offset -= MAX_SHORT_PLT * info->short_plt->symbol_entry_size;
	}
      else
	info = info->short_plt;
    }
  return plt_index + offset / info->symbol_entry_size;
}

/* Do the inverse operation.  */

static bfd_vma
get_plt_offset (const struct elf_sh_plt_info *info, bfd_vma plt_index)
{
  bfd_vma offset = 0;

  if (info->short_plt != NULL)
    {
      if (plt_index > MAX_SHORT_PLT)
	{
	  offset = MAX_SHORT_PLT * info->short_plt->symbol_entry_size;
	  plt_index -= MAX_SHORT_PLT;
	}
      else
	info = info->short_plt;
    }
  return (offset + info->plt0_entry_size
	  + (plt_index * info->symbol_entry_size));
}

/* The sh linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct elf_sh_dyn_relocs
{
  struct elf_sh_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};

union gotref
{
  bfd_signed_vma refcount;
  bfd_vma offset;
};

/* sh ELF linker hash entry.  */

struct elf_sh_link_hash_entry
{
  struct elf_link_hash_entry root;

#ifdef INCLUDE_SHMEDIA
  union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } datalabel_got;
#endif

  /* Track dynamic relocs copied for this symbol.  */
  struct elf_sh_dyn_relocs *dyn_relocs;

  bfd_signed_vma gotplt_refcount;

  /* A local function descriptor, for FDPIC.  The refcount counts
     R_SH_FUNCDESC, R_SH_GOTOFFFUNCDESC, and R_SH_GOTOFFFUNCDESC20
     relocations; the PLT and GOT entry are accounted
     for separately.  After adjust_dynamic_symbol, the offset is
     MINUS_ONE if there is no local descriptor (dynamic linker
     managed and no PLT entry, or undefined weak non-dynamic).
     During check_relocs we do not yet know whether the local
     descriptor will be canonical.  */
  union gotref funcdesc;

  /* How many of the above refcounted relocations were R_SH_FUNCDESC,
     and thus require fixups or relocations.  */
  bfd_signed_vma abs_funcdesc_refcount;

  enum got_type {
    GOT_UNKNOWN = 0, GOT_NORMAL, GOT_TLS_GD, GOT_TLS_IE, GOT_FUNCDESC
  } got_type;
};

#define sh_elf_hash_entry(ent) ((struct elf_sh_link_hash_entry *)(ent))

struct sh_elf_obj_tdata
{
  struct elf_obj_tdata root;

  /* got_type for each local got entry.  */
  char *local_got_type;

  /* Function descriptor refcount and offset for each local symbol.  */
  union gotref *local_funcdesc;
};

#define sh_elf_tdata(abfd) \
  ((struct sh_elf_obj_tdata *) (abfd)->tdata.any)

#define sh_elf_local_got_type(abfd) \
  (sh_elf_tdata (abfd)->local_got_type)

#define sh_elf_local_funcdesc(abfd) \
  (sh_elf_tdata (abfd)->local_funcdesc)

#define is_sh_elf(bfd) \
  (bfd_get_flavour (bfd) == bfd_target_elf_flavour \
   && elf_tdata (bfd) != NULL \
   && elf_object_id (bfd) == SH_ELF_DATA)

/* Override the generic function because we need to store sh_elf_obj_tdata
   as the specific tdata.  */

static bfd_boolean
sh_elf_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct sh_elf_obj_tdata),
				  SH_ELF_DATA);
}

/* sh ELF linker hash table.  */

struct elf_sh_link_hash_table
{
  struct elf_link_hash_table root;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;
  asection *sfuncdesc;
  asection *srelfuncdesc;
  asection *srofixup;

  /* The (unloaded but important) VxWorks .rela.plt.unloaded section.  */
  asection *srelplt2;

  /* Small local sym cache.  */
  struct sym_cache sym_cache;

  /* A counter or offset to track a TLS got entry.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } tls_ldm_got;

  /* The type of PLT to use.  */
  const struct elf_sh_plt_info *plt_info;

  /* True if the target system is VxWorks.  */
  bfd_boolean vxworks_p;

  /* True if the target system uses FDPIC.  */
  bfd_boolean fdpic_p;
};

/* Traverse an sh ELF linker hash table.  */

#define sh_elf_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func), \
    (info)))

/* Get the sh ELF linker hash table from a link_info structure.  */

#define sh_elf_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == SH_ELF_DATA ? ((struct elf_sh_link_hash_table *) ((p)->hash)) : NULL)

/* Create an entry in an sh ELF linker hash table.  */

static struct bfd_hash_entry *
sh_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			  struct bfd_hash_table *table,
			  const char *string)
{
  struct elf_sh_link_hash_entry *ret =
    (struct elf_sh_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct elf_sh_link_hash_entry *) NULL)
    ret = ((struct elf_sh_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf_sh_link_hash_entry)));
  if (ret == (struct elf_sh_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf_sh_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct elf_sh_link_hash_entry *) NULL)
    {
      ret->dyn_relocs = NULL;
      ret->gotplt_refcount = 0;
#ifdef INCLUDE_SHMEDIA
      ret->datalabel_got.refcount = ret->root.got.refcount;
#endif
      ret->funcdesc.refcount = 0;
      ret->abs_funcdesc_refcount = 0;
      ret->got_type = GOT_UNKNOWN;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create an sh ELF linker hash table.  */

static struct bfd_link_hash_table *
sh_elf_link_hash_table_create (bfd *abfd)
{
  struct elf_sh_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_sh_link_hash_table);

  ret = (struct elf_sh_link_hash_table *) bfd_zmalloc (amt);
  if (ret == (struct elf_sh_link_hash_table *) NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
				      sh_elf_link_hash_newfunc,
				      sizeof (struct elf_sh_link_hash_entry),
				      SH_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  ret->vxworks_p = vxworks_object_p (abfd);
  ret->fdpic_p = fdpic_object_p (abfd);

  return &ret->root.root;
}

static bfd_boolean
sh_elf_omit_section_dynsym (bfd *output_bfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info, asection *p)
{
  struct elf_sh_link_hash_table *htab = sh_elf_hash_table (info);

  /* Non-FDPIC binaries do not need dynamic symbols for sections.  */
  if (!htab->fdpic_p)
    return TRUE;

  /* We need dynamic symbols for every section, since segments can
     relocate independently.  */
  switch (elf_section_data (p)->this_hdr.sh_type)
    {
    case SHT_PROGBITS:
    case SHT_NOBITS:
      /* If sh_type is yet undecided, assume it could be
	 SHT_PROGBITS/SHT_NOBITS.  */
    case SHT_NULL:
      return FALSE;

      /* There shouldn't be section relative relocations
	 against any other section.  */
    default:
      return TRUE;
    }
}

/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static bfd_boolean
create_got_section (bfd *dynobj, struct bfd_link_info *info)
{
  struct elf_sh_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = sh_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  htab->sgot = bfd_get_linker_section (dynobj, ".got");
  htab->sgotplt = bfd_get_linker_section (dynobj, ".got.plt");
  htab->srelgot = bfd_get_linker_section (dynobj, ".rela.got");
  if (! htab->sgot || ! htab->sgotplt || ! htab->srelgot)
    abort ();

  htab->sfuncdesc = bfd_make_section_anyway_with_flags (dynobj, ".got.funcdesc",
							(SEC_ALLOC | SEC_LOAD
							 | SEC_HAS_CONTENTS
							 | SEC_IN_MEMORY
							 | SEC_LINKER_CREATED));
  if (htab->sfuncdesc == NULL
      || ! bfd_set_section_alignment (dynobj, htab->sfuncdesc, 2))
    return FALSE;

  htab->srelfuncdesc = bfd_make_section_anyway_with_flags (dynobj,
							   ".rela.got.funcdesc",
							   (SEC_ALLOC | SEC_LOAD
							    | SEC_HAS_CONTENTS
							    | SEC_IN_MEMORY
							    | SEC_LINKER_CREATED
							    | SEC_READONLY));
  if (htab->srelfuncdesc == NULL
      || ! bfd_set_section_alignment (dynobj, htab->srelfuncdesc, 2))
    return FALSE;

  /* Also create .rofixup.  */
  htab->srofixup = bfd_make_section_anyway_with_flags (dynobj, ".rofixup",
						       (SEC_ALLOC | SEC_LOAD
							| SEC_HAS_CONTENTS
							| SEC_IN_MEMORY
							| SEC_LINKER_CREATED
							| SEC_READONLY));
  if (htab->srofixup == NULL
      || ! bfd_set_section_alignment (dynobj, htab->srofixup, 2))
    return FALSE;

  return TRUE;
}

/* Create dynamic sections when linking against a dynamic object.  */

static bfd_boolean
sh_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  struct elf_sh_link_hash_table *htab;
  flagword flags, pltflags;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int ptralign = 0;

  switch (bed->s->arch_size)
    {
    case 32:
      ptralign = 2;
      break;

    case 64:
      ptralign = 3;
      break;

    default:
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  htab = sh_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (htab->root.dynamic_sections_created)
    return TRUE;

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  pltflags = flags;
  pltflags |= SEC_CODE;
  if (bed->plt_not_loaded)
    pltflags &= ~ (SEC_LOAD | SEC_HAS_CONTENTS);
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  s = bfd_make_section_anyway_with_flags (abfd, ".plt", pltflags);
  htab->splt = s;
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;

  if (bed->want_plt_sym)
    {
      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
	 .plt section.  */
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s,
	      (bfd_vma) 0, (const char *) NULL, FALSE,
	      get_elf_backend_data (abfd)->collect, &bh)))
	return FALSE;

      h = (struct elf_link_hash_entry *) bh;
      h->def_regular = 1;
      h->type = STT_OBJECT;
      htab->root.hplt = h;

      if (info->shared
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }

  s = bfd_make_section_anyway_with_flags (abfd,
					  bed->default_use_rela_p
					  ? ".rela.plt" : ".rel.plt",
					  flags | SEC_READONLY);
  htab->srelplt = s;
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, ptralign))
    return FALSE;

  if (htab->sgot == NULL
      && !create_got_section (abfd, info))
    return FALSE;

  if (bed->want_dynbss)
    {
      /* The .dynbss section is a place to put symbols which are defined
	 by dynamic objects, are referenced by regular objects, and are
	 not functions.  We must allocate space for them in the process
	 image and use a R_*_COPY reloc to tell the dynamic linker to
	 initialize them at run time.  The linker script puts the .dynbss
	 section into the .bss section of the final image.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".dynbss",
					      SEC_ALLOC | SEC_LINKER_CREATED);
      htab->sdynbss = s;
      if (s == NULL)
	return FALSE;

      /* The .rel[a].bss section holds copy relocs.  This section is not
	 normally needed.  We need to create it here, though, so that the
	 linker will map it to an output section.  We can't just create it
	 only if we need it, because we will not know whether we need it
	 until we have seen all the input files, and the first time the
	 main linker code calls BFD after examining all the input files
	 (size_dynamic_sections) the input sections have already been
	 mapped to the output sections.  If the section turns out not to
	 be needed, we can discard it later.  We will never need this
	 section when generating a shared object, since they do not use
	 copy relocs.  */
      if (! info->shared)
	{
	  s = bfd_make_section_anyway_with_flags (abfd,
						  (bed->default_use_rela_p
						   ? ".rela.bss" : ".rel.bss"),
						  flags | SEC_READONLY);
	  htab->srelbss = s;
	  if (s == NULL
	      || ! bfd_set_section_alignment (abfd, s, ptralign))
	    return FALSE;
	}
    }

  if (htab->vxworks_p)
    {
      if (!elf_vxworks_create_dynamic_sections (abfd, info, &htab->srelplt2))
	return FALSE;
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
sh_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
			      struct elf_link_hash_entry *h)
{
  struct elf_sh_link_hash_table *htab;
  struct elf_sh_link_hash_entry *eh;
  struct elf_sh_dyn_relocs *p;
  asection *s;

  htab = sh_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (htab->root.dynobj != NULL
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC
      || h->needs_plt)
    {
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
	{
	  /* This case can occur if we saw a PLT reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object.  In such a case, we don't actually need to build
	     a procedure linkage table, and we can just do a REL32
	     reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}

      return TRUE;
    }
  else
    h->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      if (info->nocopyreloc)
	h->non_got_ref = h->u.weakdef->non_got_ref;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!h->non_got_ref)
    return TRUE;

  /* If -z nocopyreloc was given, we won't generate them either.  */
  if (info->nocopyreloc)
    {
      h->non_got_ref = 0;
      return TRUE;
    }

  eh = (struct elf_sh_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      s = p->sec->output_section;
      if (s != NULL && (s->flags & (SEC_READONLY | SEC_HAS_CONTENTS)) != 0)
	break;
    }

  /* If we didn't find any dynamic relocs in sections which needs the
     copy reloc, then we'll be keeping the dynamic relocs and avoiding
     the copy reloc.  */
  if (p == NULL)
    {
      h->non_got_ref = 0;
      return TRUE;
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  s = htab->sdynbss;
  BFD_ASSERT (s != NULL);

  /* We must generate a R_SH_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
    {
      asection *srel;

      srel = htab->srelbss;
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf32_External_Rela);
      h->needs_copy = 1;
    }

  return _bfd_elf_adjust_dynamic_copy (h, s);
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info;
  struct elf_sh_link_hash_table *htab;
  struct elf_sh_link_hash_entry *eh;
  struct elf_sh_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  info = (struct bfd_link_info *) inf;
  htab = sh_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  eh = (struct elf_sh_link_hash_entry *) h;
  if ((h->got.refcount > 0
       || h->forced_local)
      && eh->gotplt_refcount > 0)
    {
      /* The symbol has been forced local, or we have some direct got refs,
	 so treat all the gotplt refs as got refs. */
      h->got.refcount += eh->gotplt_refcount;
      if (h->plt.refcount >= eh->gotplt_refcount)
	h->plt.refcount -= eh->gotplt_refcount;
    }

  if (htab->root.dynamic_sections_created
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  asection *s = htab->splt;
	  const struct elf_sh_plt_info *plt_info;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->size == 0)
	    s->size += htab->plt_info->plt0_entry_size;

	  h->plt.offset = s->size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  Skip this for FDPIC, since the
	     function's address will be the address of the canonical
	     function descriptor.  */
	  if (!htab->fdpic_p && !info->shared && !h->def_regular)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  plt_info = htab->plt_info;
	  if (plt_info->short_plt != NULL
	      && (get_plt_index (plt_info->short_plt, s->size) < MAX_SHORT_PLT))
	    plt_info = plt_info->short_plt;
	  s->size += plt_info->symbol_entry_size;

	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  if (!htab->fdpic_p)
	    htab->sgotplt->size += 4;
	  else
	    htab->sgotplt->size += 8;

	  /* We also need to make an entry in the .rel.plt section.  */
	  htab->srelplt->size += sizeof (Elf32_External_Rela);

	  if (htab->vxworks_p && !info->shared)
	    {
	      /* VxWorks executables have a second set of relocations
		 for each PLT entry.  They go in a separate relocation
		 section, which is processed by the kernel loader.  */

	      /* There is a relocation for the initial PLT entry:
		 an R_SH_DIR32 relocation for _GLOBAL_OFFSET_TABLE_.  */
	      if (h->plt.offset == htab->plt_info->plt0_entry_size)
		htab->srelplt2->size += sizeof (Elf32_External_Rela);

	      /* There are two extra relocations for each subsequent
		 PLT entry: an R_SH_DIR32 relocation for the GOT entry,
		 and an R_SH_DIR32 relocation for the PLT entry.  */
	      htab->srelplt2->size += sizeof (Elf32_External_Rela) * 2;
	    }
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->needs_plt = 0;
    }

  if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;
      enum got_type got_type = sh_elf_hash_entry (h)->got_type;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = htab->sgot;
      h->got.offset = s->size;
      s->size += 4;
      /* R_SH_TLS_GD needs 2 consecutive GOT slots.  */
      if (got_type == GOT_TLS_GD)
	s->size += 4;
      dyn = htab->root.dynamic_sections_created;
      if (!dyn)
	{
	  /* No dynamic relocations required.  */
	  if (htab->fdpic_p && !info->shared
	      && h->root.type != bfd_link_hash_undefweak
	      && (got_type == GOT_NORMAL || got_type == GOT_FUNCDESC))
	    htab->srofixup->size += 4;
	}
      /* No dynamic relocations required when IE->LE conversion happens.  */
      else if (got_type == GOT_TLS_IE && !h->def_dynamic && !info->shared)
	;
      /* R_SH_TLS_IE_32 needs one dynamic relocation if dynamic,
	 R_SH_TLS_GD needs one if local symbol and two if global.  */
      else if ((got_type == GOT_TLS_GD && h->dynindx == -1)
	       || got_type == GOT_TLS_IE)
	htab->srelgot->size += sizeof (Elf32_External_Rela);
      else if (got_type == GOT_TLS_GD)
	htab->srelgot->size += 2 * sizeof (Elf32_External_Rela);
      else if (got_type == GOT_FUNCDESC)
	{
	  if (!info->shared && SYMBOL_FUNCDESC_LOCAL (info, h))
	    htab->srofixup->size += 4;
	  else
	    htab->srelgot->size += sizeof (Elf32_External_Rela);
	}
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	htab->srelgot->size += sizeof (Elf32_External_Rela);
      else if (htab->fdpic_p && !info->shared && got_type == GOT_NORMAL
	       && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak))
	htab->srofixup->size += 4;
    }
  else
    h->got.offset = (bfd_vma) -1;

#ifdef INCLUDE_SHMEDIA
  if (eh->datalabel_got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = htab->sgot;
      eh->datalabel_got.offset = s->size;
      s->size += 4;
      dyn = htab->root.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h))
	htab->srelgot->size += sizeof (Elf32_External_Rela);
    }
  else
    eh->datalabel_got.offset = (bfd_vma) -1;
#endif

  /* Allocate space for any dynamic relocations to function
     descriptors, canonical or otherwise.  We need to relocate the
     reference unless it resolves to zero, which only happens for
     undefined weak symbols (either non-default visibility, or when
     static linking).  Any GOT slot is accounted for elsewhere.  */
  if (eh->abs_funcdesc_refcount > 0
      && (h->root.type != bfd_link_hash_undefweak
	  || (htab->root.dynamic_sections_created
	      && ! SYMBOL_CALLS_LOCAL (info, h))))
    {
      if (!info->shared && SYMBOL_FUNCDESC_LOCAL (info, h))
	htab->srofixup->size += eh->abs_funcdesc_refcount * 4;
      else
	htab->srelgot->size
	  += eh->abs_funcdesc_refcount * sizeof (Elf32_External_Rela);
    }

  /* We must allocate a function descriptor if there are references to
     a canonical descriptor (R_SH_GOTFUNCDESC or R_SH_FUNCDESC) and
     the dynamic linker isn't going to allocate it.  None of this
     applies if we already created one in .got.plt, but if the
     canonical function descriptor can be in this object, there
     won't be a PLT entry at all.  */
  if ((eh->funcdesc.refcount > 0
       || (h->got.offset != MINUS_ONE && eh->got_type == GOT_FUNCDESC))
      && h->root.type != bfd_link_hash_undefweak
      && SYMBOL_FUNCDESC_LOCAL (info, h))
    {
      /* Make room for this function descriptor.  */
      eh->funcdesc.offset = htab->sfuncdesc->size;
      htab->sfuncdesc->size += 8;

      /* We will need a relocation or two fixups to initialize the
	 function descriptor, so allocate those too.  */
      if (!info->shared && SYMBOL_CALLS_LOCAL (info, h))
	htab->srofixup->size += 8;
      else
	htab->srelfuncdesc->size += sizeof (Elf32_External_Rela);
    }

  if (eh->dyn_relocs == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf_sh_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      if (htab->vxworks_p)
	{
	  struct elf_sh_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      if (strcmp (p->sec->output_section->name, ".tls_vars") == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (eh->dyn_relocs != NULL
	  && h->root.type == bfd_link_hash_undefweak)
	{
	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	    eh->dyn_relocs = NULL;

	  /* Make sure undefined weak symbols are output as a dynamic
	     symbol in PIEs.  */
	  else if (h->dynindx == -1
		   && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
	}
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
	      || (htab->root.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->size += p->count * sizeof (Elf32_External_Rela);

      /* If we need relocations, we do not need fixups.  */
      if (htab->fdpic_p && !info->shared)
	htab->srofixup->size -= 4 * (p->count - p->pc_count);
    }

  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
{
  struct elf_sh_link_hash_entry *eh;
  struct elf_sh_dyn_relocs *p;

  eh = (struct elf_sh_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
}

/* This function is called after all the input files have been read,
   and the input sections have been assigned to output sections.
   It's a convenient place to determine the PLT style.  */

static bfd_boolean
sh_elf_always_size_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  sh_elf_hash_table (info)->plt_info = get_plt_info (output_bfd, info->shared);

  if (sh_elf_hash_table (info)->fdpic_p && !info->relocatable
      && !bfd_elf_stack_segment_size (output_bfd, info,
				      "__stacksize", DEFAULT_STACK_SIZE))
    return FALSE;
  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
sh_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
			      struct bfd_link_info *info)
{
  struct elf_sh_link_hash_table *htab;
  bfd *dynobj;
  asection *s;
  bfd_boolean relocs;
  bfd *ibfd;

  htab = sh_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = htab->root.dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (htab->root.dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      union gotref *local_funcdesc, *end_local_funcdesc;
      char *local_got_type;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

      if (! is_sh_elf (ibfd))
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf_sh_dyn_relocs *p;

	  for (p = ((struct elf_sh_dyn_relocs *)
		    elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
	    {
	      if (! bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (htab->vxworks_p
		       && strcmp (p->sec->output_section->name,
				  ".tls_vars") == 0)
		{
		  /* Relocations in vxworks .tls_vars sections are
		     handled specially by the loader.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->sec)->sreloc;
		  srel->size += p->count * sizeof (Elf32_External_Rela);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;

		  /* If we need relocations, we do not need fixups.  */
		  if (htab->fdpic_p && !info->shared)
		    htab->srofixup->size -= 4 * (p->count - p->pc_count);
		}
	    }
	}

      symtab_hdr = &elf_symtab_hdr (ibfd);
      locsymcount = symtab_hdr->sh_info;
#ifdef INCLUDE_SHMEDIA
      /* Count datalabel local GOT.  */
      locsymcount *= 2;
#endif
      s = htab->sgot;
      srel = htab->srelgot;

      local_got = elf_local_got_refcounts (ibfd);
      if (local_got)
	{
	  end_local_got = local_got + locsymcount;
	  local_got_type = sh_elf_local_got_type (ibfd);
	  local_funcdesc = sh_elf_local_funcdesc (ibfd);
	  for (; local_got < end_local_got; ++local_got)
	    {
	      if (*local_got > 0)
		{
		  *local_got = s->size;
		  s->size += 4;
		  if (*local_got_type == GOT_TLS_GD)
		    s->size += 4;
		  if (info->shared)
		    srel->size += sizeof (Elf32_External_Rela);
		  else
		    htab->srofixup->size += 4;

		  if (*local_got_type == GOT_FUNCDESC)
		    {
		      if (local_funcdesc == NULL)
			{
			  bfd_size_type size;

			  size = locsymcount * sizeof (union gotref);
			  local_funcdesc = (union gotref *) bfd_zalloc (ibfd,
									size);
			  if (local_funcdesc == NULL)
			    return FALSE;
			  sh_elf_local_funcdesc (ibfd) = local_funcdesc;
			  local_funcdesc += (local_got
					     - elf_local_got_refcounts (ibfd));
			}
		      local_funcdesc->refcount++;
		      ++local_funcdesc;
		    }
		}
	      else
		*local_got = (bfd_vma) -1;
	      ++local_got_type;
	    }
	}

      local_funcdesc = sh_elf_local_funcdesc (ibfd);
      if (local_funcdesc)
	{
	  end_local_funcdesc = local_funcdesc + locsymcount;

	  for (; local_funcdesc < end_local_funcdesc; ++local_funcdesc)
	    {
	      if (local_funcdesc->refcount > 0)
		{
		  local_funcdesc->offset = htab->sfuncdesc->size;
		  htab->sfuncdesc->size += 8;
		  if (!info->shared)
		    htab->srofixup->size += 8;
		  else
		    htab->srelfuncdesc->size += sizeof (Elf32_External_Rela);
		}
	      else
		local_funcdesc->offset = MINUS_ONE;
	    }
	}

    }

  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_SH_TLS_LD_32
	 relocs.  */
      htab->tls_ldm_got.offset = htab->sgot->size;
      htab->sgot->size += 8;
      htab->srelgot->size += sizeof (Elf32_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

  /* Only the reserved entries should be present.  For FDPIC, they go at
     the end of .got.plt.  */
  if (htab->fdpic_p)
    {
      BFD_ASSERT (htab->sgotplt && htab->sgotplt->size == 12);
      htab->sgotplt->size = 0;
    }

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, info);

  /* Move the reserved entries and the _GLOBAL_OFFSET_TABLE_ symbol to the
     end of the FDPIC .got.plt.  */
  if (htab->fdpic_p)
    {
      htab->root.hgot->root.u.def.value = htab->sgotplt->size;
      htab->sgotplt->size += 12;
    }

  /* At the very end of the .rofixup section is a pointer to the GOT.  */
  if (htab->fdpic_p && htab->srofixup != NULL)
    htab->srofixup->size += 4;

  /* We now have determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (s == htab->splt
	  || s == htab->sgot
	  || s == htab->sgotplt
	  || s == htab->sfuncdesc
	  || s == htab->srofixup
	  || s == htab->sdynbss)
	{
	  /* Strip this section if we don't need it; see the
	     comment below.  */
	}
      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rela"))
	{
	  if (s->size != 0 && s != htab->srelplt && s != htab->srelplt2)
	    relocs = TRUE;

	  /* We use the reloc_count field as a counter if we need
	     to copy relocs into the output file.  */
	  s->reloc_count = 0;
	}
      else
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */

	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  We use bfd_zalloc
	 here in case unused entries are not reclaimed before the
	 section's contents are written out.  This should not happen,
	 but this way if it does, we get a R_SH_NONE reloc instead
	 of garbage.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }

  if (htab->root.dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in sh_elf_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (info->executable)
	{
	  if (! add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (htab->splt->size != 0)
	{
	  if (! add_dynamic_entry (DT_PLTGOT, 0)
	      || ! add_dynamic_entry (DT_PLTRELSZ, 0)
	      || ! add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || ! add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}
      else if ((elf_elfheader (output_bfd)->e_flags & EF_SH_FDPIC)
	       && htab->sgot->size != 0)
	{
	  if (! add_dynamic_entry (DT_PLTGOT, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (! add_dynamic_entry (DT_RELA, 0)
	      || ! add_dynamic_entry (DT_RELASZ, 0)
	      || ! add_dynamic_entry (DT_RELAENT,
				      sizeof (Elf32_External_Rela)))
	    return FALSE;

	  /* If any dynamic relocs apply to a read-only section,
	     then we need a DT_TEXTREL entry.  */
	  if ((info->flags & DF_TEXTREL) == 0)
	    elf_link_hash_traverse (&htab->root, readonly_dynrelocs, info);

	  if ((info->flags & DF_TEXTREL) != 0)
	    {
	      if (! add_dynamic_entry (DT_TEXTREL, 0))
		return FALSE;
	    }
	}
      if (htab->vxworks_p
	  && !elf_vxworks_add_dynamic_entries (output_bfd, info))
	return FALSE;
    }
#undef add_dynamic_entry

  return TRUE;
}

/* Add a dynamic relocation to the SRELOC section.  */

inline static bfd_vma
sh_elf_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
		      int reloc_type, long dynindx, bfd_vma addend)
{
  Elf_Internal_Rela outrel;
  bfd_vma reloc_offset;

  outrel.r_offset = offset;
  outrel.r_info = ELF32_R_INFO (dynindx, reloc_type);
  outrel.r_addend = addend;

  reloc_offset = sreloc->reloc_count * sizeof (Elf32_External_Rela);
  BFD_ASSERT (reloc_offset < sreloc->size);
  bfd_elf32_swap_reloca_out (output_bfd, &outrel,
			     sreloc->contents + reloc_offset);
  sreloc->reloc_count++;

  return reloc_offset;
}

/* Add an FDPIC read-only fixup.  */

inline static void
sh_elf_add_rofixup (bfd *output_bfd, asection *srofixup, bfd_vma offset)
{
  bfd_vma fixup_offset;

  fixup_offset = srofixup->reloc_count++ * 4;
  BFD_ASSERT (fixup_offset < srofixup->size);
  bfd_put_32 (output_bfd, offset, srofixup->contents + fixup_offset);
}

/* Return the offset of the generated .got section from the
   _GLOBAL_OFFSET_TABLE_ symbol.  */

static bfd_signed_vma
sh_elf_got_offset (struct elf_sh_link_hash_table *htab)
{
  return (htab->sgot->output_offset - htab->sgotplt->output_offset
	  - htab->root.hgot->root.u.def.value);
}

/* Find the segment number in which OSEC, and output section, is
   located.  */

static unsigned
sh_elf_osec_to_segment (bfd *output_bfd, asection *osec)
{
  Elf_Internal_Phdr *p = NULL;

  if (output_bfd->xvec->flavour == bfd_target_elf_flavour)
    p = _bfd_elf_find_segment_containing_section (output_bfd, osec);

  /* FIXME: Nothing ever says what this index is relative to.  The kernel
     supplies data in terms of the number of load segments but this is
     a phdr index and the first phdr may not be a load segment.  */
  return (p != NULL) ? p - elf_tdata (output_bfd)->phdr : -1;
}

static bfd_boolean
sh_elf_osec_readonly_p (bfd *output_bfd, asection *osec)
{
  unsigned seg = sh_elf_osec_to_segment (output_bfd, osec);

  return (seg != (unsigned) -1
	  && ! (elf_tdata (output_bfd)->phdr[seg].p_flags & PF_W));
}

/* Generate the initial contents of a local function descriptor, along
   with any relocations or fixups required.  */
static bfd_boolean
sh_elf_initialize_funcdesc (bfd *output_bfd,
			    struct bfd_link_info *info,
			    struct elf_link_hash_entry *h,
			    bfd_vma offset,
			    asection *section,
			    bfd_vma value)
{
  struct elf_sh_link_hash_table *htab;
  int dynindx;
  bfd_vma addr, seg;

  htab = sh_elf_hash_table (info);

  /* FIXME: The ABI says that the offset to the function goes in the
     descriptor, along with the segment index.  We're RELA, so it could
     go in the reloc instead... */

  if (h != NULL && SYMBOL_CALLS_LOCAL (info, h))
    {
      section = h->root.u.def.section;
      value = h->root.u.def.value;
    }

  if (h == NULL || SYMBOL_CALLS_LOCAL (info, h))
    {
      dynindx = elf_section_data (section->output_section)->dynindx;
      addr = value + section->output_offset;
      seg = sh_elf_osec_to_segment (output_bfd, section->output_section);
    }
  else
    {
      BFD_ASSERT (h->dynindx != -1);
      dynindx = h->dynindx;
      addr = seg = 0;
    }

  if (!info->shared && SYMBOL_CALLS_LOCAL (info, h))
    {
      if (h == NULL || h->root.type != bfd_link_hash_undefweak)
	{
	  sh_elf_add_rofixup (output_bfd, htab->srofixup,
			      offset
			      + htab->sfuncdesc->output_section->vma
			      + htab->sfuncdesc->output_offset);
	  sh_elf_add_rofixup (output_bfd, htab->srofixup,
			      offset + 4
			      + htab->sfuncdesc->output_section->vma
			      + htab->sfuncdesc->output_offset);
	}

      /* There are no dynamic relocations so fill in the final
	 address and gp value (barring fixups).  */
      addr += section->output_section->vma;
      seg = htab->root.hgot->root.u.def.value
	+ htab->root.hgot->root.u.def.section->output_section->vma
	+ htab->root.hgot->root.u.def.section->output_offset;
    }
  else
    sh_elf_add_dyn_reloc (output_bfd, htab->srelfuncdesc,
			  offset
			  + htab->sfuncdesc->output_section->vma
			  + htab->sfuncdesc->output_offset,
			  R_SH_FUNCDESC_VALUE, dynindx, 0);

  bfd_put_32 (output_bfd, addr, htab->sfuncdesc->contents + offset);
  bfd_put_32 (output_bfd, seg, htab->sfuncdesc->contents + offset + 4);

  return TRUE;
}

/* Install a 20-bit movi20 field starting at ADDR, which occurs in OUTPUT_BFD.
   VALUE is the field's value.  Return bfd_reloc_ok if successful or an error
   otherwise.  */

static bfd_reloc_status_type
install_movi20_field (bfd *output_bfd, unsigned long relocation,
		      bfd *input_bfd, asection *input_section,
		      bfd_byte *contents, bfd_vma offset)
{
  unsigned long cur_val;
  bfd_byte *addr;
  bfd_reloc_status_type r;

  if (offset > bfd_get_section_limit (input_bfd, input_section))
    return bfd_reloc_outofrange;

  r = bfd_check_overflow (complain_overflow_signed, 20, 0,
			  bfd_arch_bits_per_address (input_bfd), relocation);
  if (r != bfd_reloc_ok)
    return r;

  addr = contents + offset;
  cur_val = bfd_get_16 (output_bfd, addr);
  bfd_put_16 (output_bfd, cur_val | ((relocation & 0xf0000) >> 12), addr);
  bfd_put_16 (output_bfd, relocation & 0xffff, addr + 2);

  return bfd_reloc_ok;
}

/* Relocate an SH ELF section.  */

static bfd_boolean
sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
			 bfd *input_bfd, asection *input_section,
			 bfd_byte *contents, Elf_Internal_Rela *relocs,
			 Elf_Internal_Sym *local_syms,
			 asection **local_sections)
{
  struct elf_sh_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel, *relend;
  bfd *dynobj = NULL;
  bfd_vma *local_got_offsets;
  asection *sgot = NULL;
  asection *sgotplt = NULL;
  asection *splt = NULL;
  asection *sreloc = NULL;
  asection *srelgot = NULL;
  bfd_boolean is_vxworks_tls;
  unsigned isec_segment, got_segment, plt_segment, check_segment[2];
  bfd_boolean fdpic_p = FALSE;

  BFD_ASSERT (is_sh_elf (input_bfd));

  htab = sh_elf_hash_table (info);
  if (htab != NULL)
    {
      dynobj = htab->root.dynobj;
      sgot = htab->sgot;
      sgotplt = htab->sgotplt;
      splt = htab->splt;
      fdpic_p = htab->fdpic_p;
    }
  symtab_hdr = &elf_symtab_hdr (input_bfd);
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);

  isec_segment = sh_elf_osec_to_segment (output_bfd,
					 input_section->output_section);
  if (fdpic_p && sgot)
    got_segment = sh_elf_osec_to_segment (output_bfd,
					  sgot->output_section);
  else
    got_segment = -1;
  if (fdpic_p && splt)
    plt_segment = sh_elf_osec_to_segment (output_bfd,
					  splt->output_section);
  else
    plt_segment = -1;

  /* We have to handle relocations in vxworks .tls_vars sections
     specially, because the dynamic loader is 'weird'.  */
  is_vxworks_tls = (htab && htab->vxworks_p && info->shared
		    && !strcmp (input_section->output_section->name,
				".tls_vars"));

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_vma addend = (bfd_vma) 0;
      bfd_reloc_status_type r;
      int seen_stt_datalabel = 0;
      bfd_vma off;
      enum got_type got_type;
      const char *symname = NULL;

      r_symndx = ELF32_R_SYM (rel->r_info);

      r_type = ELF32_R_TYPE (rel->r_info);

      /* Many of the relocs are only used for relaxing, and are
	 handled entirely by the relaxation code.  */
      if (r_type >= (int) R_SH_GNU_VTINHERIT
	  && r_type <= (int) R_SH_LABEL)
	continue;
      if (r_type == (int) R_SH_NONE)
	continue;

      if (r_type < 0
	  || r_type >= R_SH_max
	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC)
	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC_2
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC_2)
	  || (   r_type >= (int) R_SH_FIRST_INVALID_RELOC_3
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC_3)
	  || (   r_type >= (int) R_SH_FIRST_INVALID_RELOC_4
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC_4)
	  || (   r_type >= (int) R_SH_FIRST_INVALID_RELOC_5
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC_5)
	  || (   r_type >= (int) R_SH_FIRST_INVALID_RELOC_6
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC_6))
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      howto = get_howto_table (output_bfd) + r_type;

      /* For relocs that aren't partial_inplace, we get the addend from
	 the relocation.  */
      if (! howto->partial_inplace)
	addend = rel->r_addend;

      h = NULL;
      sym = NULL;
      sec = NULL;
      check_segment[0] = -1;
      check_segment[1] = -1;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];

	  symname = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  if (symname == NULL || *symname == '\0')
	    symname = bfd_section_name (input_bfd, sec);

	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
	  /* A local symbol never has STO_SH5_ISA32, so we don't need
	     datalabel processing here.  Make sure this does not change
	     without notice.  */
	  if ((sym->st_other & STO_SH5_ISA32) != 0)
	    ((*info->callbacks->reloc_dangerous)
	     (info,
	      _("Unexpected STO_SH5_ISA32 on local symbol is not handled"),
	      input_bfd, input_section, rel->r_offset));

	  if (sec != NULL && discarded_section (sec))
	    /* Handled below.  */
	    ;
	  else if (info->relocatable)
	    {
	      /* This is a relocatable link.  We don't have to change
		 anything, unless the reloc is against a section symbol,
		 in which case we have to adjust according to where the
		 section symbol winds up in the output section.  */
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  if (! howto->partial_inplace)
		    {
		      /* For relocations with the addend in the
			 relocation, we need just to update the addend.
			 All real relocs are of type partial_inplace; this
			 code is mostly for completeness.  */
		      rel->r_addend += sec->output_offset;

		      continue;
		    }

		  /* Relocs of type partial_inplace need to pick up the
		     contents in the contents and add the offset resulting
		     from the changed location of the section symbol.
		     Using _bfd_final_link_relocate (e.g. goto
		     final_link_relocate) here would be wrong, because
		     relocations marked pc_relative would get the current
		     location subtracted, and we must only do that at the
		     final link.  */
		  r = _bfd_relocate_contents (howto, input_bfd,
					      sec->output_offset
					      + sym->st_value,
					      contents + rel->r_offset);
		  goto relocation_done;
		}

	      continue;
	    }
	  else if (! howto->partial_inplace)
	    {
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	      addend = rel->r_addend;
	    }
	  else if ((sec->flags & SEC_MERGE)
		   && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      asection *msec;

	      if (howto->rightshift || howto->src_mask != 0xffffffff)
		{
		  (*_bfd_error_handler)
		    (_("%B(%A+0x%lx): %s relocation against SEC_MERGE section"),
		     input_bfd, input_section,
		     (long) rel->r_offset, howto->name);
		  return FALSE;
		}

	      addend = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      msec = sec;
	      addend =
		_bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend)
		- relocation;
	      addend += msec->output_section->vma + msec->output_offset;
	      bfd_put_32 (input_bfd, addend, contents + rel->r_offset);
	      addend = 0;
	    }
	}
      else
	{
	  /* FIXME: Ought to make use of the RELOC_FOR_GLOBAL_SYMBOL macro.  */

	  relocation = 0;
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  symname = h->root.root.string;
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    {
#ifdef INCLUDE_SHMEDIA
	      /* If the reference passes a symbol marked with
		 STT_DATALABEL, then any STO_SH5_ISA32 on the final value
		 doesn't count.  */
	      seen_stt_datalabel |= h->type == STT_DATALABEL;
#endif
	      h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      bfd_boolean dyn;

	      dyn = htab ? htab->root.dynamic_sections_created : FALSE;
	      sec = h->root.u.def.section;
	      /* In these cases, we don't need the relocation value.
		 We check specially because in some obscure cases
		 sec->output_section will be NULL.  */
	      if (r_type == R_SH_GOTPC
		  || r_type == R_SH_GOTPC_LOW16
		  || r_type == R_SH_GOTPC_MEDLOW16
		  || r_type == R_SH_GOTPC_MEDHI16
		  || r_type == R_SH_GOTPC_HI16
		  || ((r_type == R_SH_PLT32
		       || r_type == R_SH_PLT_LOW16
		       || r_type == R_SH_PLT_MEDLOW16
		       || r_type == R_SH_PLT_MEDHI16
		       || r_type == R_SH_PLT_HI16)
		      && h->plt.offset != (bfd_vma) -1)
		  || ((r_type == R_SH_GOT32
		       || r_type == R_SH_GOT20
		       || r_type == R_SH_GOTFUNCDESC
		       || r_type == R_SH_GOTFUNCDESC20
		       || r_type == R_SH_GOTOFFFUNCDESC
		       || r_type == R_SH_GOTOFFFUNCDESC20
		       || r_type == R_SH_FUNCDESC
		       || r_type == R_SH_GOT_LOW16
		       || r_type == R_SH_GOT_MEDLOW16
		       || r_type == R_SH_GOT_MEDHI16
		       || r_type == R_SH_GOT_HI16)
		      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		      && (! info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || !h->def_regular))
		  /* The cases above are those in which relocation is
		     overwritten in the switch block below.  The cases
		     below are those in which we must defer relocation
		     to run-time, because we can't resolve absolute
		     addresses when creating a shared library.  */
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || !h->def_regular)
		      && ((r_type == R_SH_DIR32
			   && !h->forced_local)
			  || (r_type == R_SH_REL32
			      && !SYMBOL_CALLS_LOCAL (info, h)))
		      && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_SH_DIR32 relocations in its
			     sections against symbols defined externally
			     in shared libraries.  We can't do anything
			     with them here.  */
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && h->def_dynamic)))
		  /* Dynamic relocs are not propagated for SEC_DEBUGGING
		     sections because such sections are not SEC_ALLOC and
		     thus ld.so will not process them.  */
		  || (sec->output_section == NULL
		      && ((input_section->flags & SEC_DEBUGGING) != 0
			  && h->def_dynamic))
		  || (sec->output_section == NULL
		      && (sh_elf_hash_entry (h)->got_type == GOT_TLS_IE
			  || sh_elf_hash_entry (h)->got_type == GOT_TLS_GD)))
		;
	      else if (sec->output_section != NULL)
		relocation = ((h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset)
			      /* A STO_SH5_ISA32 causes a "bitor 1" to the
				 symbol value, unless we've seen
				 STT_DATALABEL on the way to it.  */
			      | ((h->other & STO_SH5_ISA32) != 0
				 && ! seen_stt_datalabel));
	      else if (!info->relocatable
		       && (_bfd_elf_section_offset (output_bfd, info,
						    input_section,
						    rel->r_offset)
			   != (bfd_vma) -1))
		{
		  (*_bfd_error_handler)
		    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
		     input_bfd,
		     input_section,
		     (long) rel->r_offset,
		     howto->name,
		     h->root.root.string);
		  return FALSE;
		}
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    ;
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    ;
	  else if (!info->relocatable)
	    {
	      if (! info->callbacks->undefined_symbol
		  (info, h->root.root.string, input_bfd,
		   input_section, rel->r_offset,
		   (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		    || ELF_ST_VISIBILITY (h->other))))
		return FALSE;
	    }
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      /* Check for inter-segment relocations in FDPIC files.  Most
	 relocations connect the relocation site to the location of
	 the target symbol, but there are some exceptions below.  */
      check_segment[0] = isec_segment;
      if (sec != NULL)
	check_segment[1] = sh_elf_osec_to_segment (output_bfd,
						   sec->output_section);
      else
	check_segment[1] = -1;

      switch ((int) r_type)
	{
	final_link_relocate:
	  /* COFF relocs don't use the addend. The addend is used for
	     R_SH_DIR32 to be compatible with other compilers.  */
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset,
					relocation, addend);
	  break;

	case R_SH_IND12W:
	  goto final_link_relocate;

	case R_SH_DIR8WPN:
	case R_SH_DIR8WPZ:
	case R_SH_DIR8WPL:
	  /* If the reloc is against the start of this section, then
	     the assembler has already taken care of it and the reloc
	     is here only to assist in relaxing.  If the reloc is not
	     against the start of this section, then it's against an
	     external symbol and we must deal with it ourselves.  */
	  if (input_section->output_section->vma + input_section->output_offset
	      != relocation)
	    {
	      int disp = (relocation
			  - input_section->output_section->vma
			  - input_section->output_offset
			  - rel->r_offset);
	      int mask = 0;
	      switch (r_type)
		{
		case R_SH_DIR8WPN:
		case R_SH_DIR8WPZ: mask = 1; break;
		case R_SH_DIR8WPL: mask = 3; break;
		default: mask = 0; break;
		}
	      if (disp & mask)
		{
		  ((*_bfd_error_handler)
		   (_("%B: 0x%lx: fatal: unaligned branch target for relax-support relocation"),
		    input_section->owner,
		    (unsigned long) rel->r_offset));
		  bfd_set_error (bfd_error_bad_value);
		  return FALSE;
		}
	      relocation -= 4;
	      goto final_link_relocate;
	    }
	  r = bfd_reloc_ok;
	  break;

	default:
#ifdef INCLUDE_SHMEDIA
	  if (shmedia_prepare_reloc (info, input_bfd, input_section,
				     contents, rel, &relocation))
	    goto final_link_relocate;
#endif
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;

	case R_SH_DIR16:
	case R_SH_DIR8:
	case R_SH_DIR8U:
	case R_SH_DIR8S:
	case R_SH_DIR4U:
	  goto final_link_relocate;

	case R_SH_DIR8UL:
	case R_SH_DIR4UL:
	  if (relocation & 3)
	    {
	      ((*_bfd_error_handler)
	       (_("%B: 0x%lx: fatal: unaligned %s relocation 0x%lx"),
		input_section->owner,
		(unsigned long) rel->r_offset, howto->name,
		(unsigned long) relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;

	case R_SH_DIR8UW:
	case R_SH_DIR8SW:
	case R_SH_DIR4UW:
	  if (relocation & 1)
	    {
	      ((*_bfd_error_handler)
	       (_("%B: 0x%lx: fatal: unaligned %s relocation 0x%lx"),
		input_section->owner,
		(unsigned long) rel->r_offset, howto->name,
		(unsigned long) relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;

	case R_SH_PSHA:
	  if ((signed int)relocation < -32
	      || (signed int)relocation > 32)
	    {
	      ((*_bfd_error_handler)
	       (_("%B: 0x%lx: fatal: R_SH_PSHA relocation %d not in range -32..32"),
		input_section->owner,
		(unsigned long) rel->r_offset,
		(unsigned long) relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;

	case R_SH_PSHL:
	  if ((signed int)relocation < -16
	      || (signed int)relocation > 16)
	    {
	      ((*_bfd_error_handler)
	       (_("%B: 0x%lx: fatal: R_SH_PSHL relocation %d not in range -32..32"),
		input_section->owner,
		(unsigned long) rel->r_offset,
		(unsigned long) relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;

	case R_SH_DIR32:
	case R_SH_REL32:
#ifdef INCLUDE_SHMEDIA
	case R_SH_IMM_LOW16_PCREL:
	case R_SH_IMM_MEDLOW16_PCREL:
	case R_SH_IMM_MEDHI16_PCREL:
	case R_SH_IMM_HI16_PCREL:
#endif
	  if (info->shared
	      && (h == NULL
		  || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		  || h->root.type != bfd_link_hash_undefweak)
	      && r_symndx != STN_UNDEF
	      && (input_section->flags & SEC_ALLOC) != 0
	      && !is_vxworks_tls
	      && (r_type == R_SH_DIR32
		  || !SYMBOL_CALLS_LOCAL (info, h)))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */

	      if (sreloc == NULL)
		{
		  sreloc = _bfd_elf_get_dynamic_reloc_section
		    (input_bfd, input_section, /*rela?*/ TRUE);
		  if (sreloc == NULL)
		    return FALSE;
		}

	      skip = FALSE;
	      relocate = FALSE;

	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1)
		skip = TRUE;
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = TRUE, relocate = TRUE;
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);

	      if (skip)
		memset (&outrel, 0, sizeof outrel);
	      else if (r_type == R_SH_REL32)
		{
		  BFD_ASSERT (h != NULL && h->dynindx != -1);
		  outrel.r_info = ELF32_R_INFO (h->dynindx, R_SH_REL32);
		  outrel.r_addend
		    = (howto->partial_inplace
		       ? bfd_get_32 (input_bfd, contents + rel->r_offset)
		       : addend);
		}
#ifdef INCLUDE_SHMEDIA
	      else if (r_type == R_SH_IMM_LOW16_PCREL
		       || r_type == R_SH_IMM_MEDLOW16_PCREL
		       || r_type == R_SH_IMM_MEDHI16_PCREL
		       || r_type == R_SH_IMM_HI16_PCREL)
		{
		  BFD_ASSERT (h != NULL && h->dynindx != -1);
		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
		  outrel.r_addend = addend;
		}
#endif
	      else if (fdpic_p
		       && (h == NULL
			   || ((info->symbolic || h->dynindx == -1)
			       && h->def_regular)))
		{
		  int dynindx;

		  BFD_ASSERT (sec != NULL);
		  BFD_ASSERT (sec->output_section != NULL);
		  dynindx = elf_section_data (sec->output_section)->dynindx;
		  outrel.r_info = ELF32_R_INFO (dynindx, R_SH_DIR32);
		  outrel.r_addend = relocation;
		  outrel.r_addend
		    += (howto->partial_inplace
			? bfd_get_32 (input_bfd, contents + rel->r_offset)
			: addend);
		  outrel.r_addend -= sec->output_section->vma;
		}
	      else
		{
		  /* h->dynindx may be -1 if this symbol was marked to
		     become local.  */
		  if (h == NULL
		      || ((info->symbolic || h->dynindx == -1)
			  && h->def_regular))
		    {
		      relocate = howto->partial_inplace;
		      outrel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
		    }
		  else
		    {
		      BFD_ASSERT (h->dynindx != -1);
		      outrel.r_info = ELF32_R_INFO (h->dynindx, R_SH_DIR32);
		    }
		  outrel.r_addend = relocation;
		  outrel.r_addend
		    += (howto->partial_inplace
			? bfd_get_32 (input_bfd, contents + rel->r_offset)
			: addend);
		}

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      check_segment[0] = check_segment[1] = -1;

	      /* If this reloc is against an external symbol, we do
		 not want to fiddle with the addend.  Otherwise, we
		 need to include the symbol value so that it becomes
		 an addend for the dynamic reloc.  */
	      if (! relocate)
		continue;
	    }
	  else if (fdpic_p && !info->shared
		   && r_type == R_SH_DIR32
		   && (input_section->flags & SEC_ALLOC) != 0)
	    {
	      bfd_vma offset;

	      BFD_ASSERT (htab);

		if (sh_elf_osec_readonly_p (output_bfd,
					    input_section->output_section))
		  {
		    (*_bfd_error_handler)
		      (_("%B(%A+0x%lx): cannot emit fixup to `%s' in read-only section"),
		       input_bfd,
		       input_section,
		       (long) rel->r_offset,
		       symname);
		    return FALSE;
		  }

	      offset = _bfd_elf_section_offset (output_bfd, info,
						input_section, rel->r_offset);
	      if (offset != (bfd_vma)-1)
		sh_elf_add_rofixup (output_bfd, htab->srofixup,
				    input_section->output_section->vma
				    + input_section->output_offset
				    + rel->r_offset);

	      check_segment[0] = check_segment[1] = -1;
	    }
	    /* We don't want warnings for non-NULL tests on undefined weak
	       symbols.  */
	    else if (r_type == R_SH_REL32
		     && h
		     && h->root.type == bfd_link_hash_undefweak) 
	      check_segment[0] = check_segment[1] = -1;
	  goto final_link_relocate;

	case R_SH_GOTPLT32:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOTPLT_LOW16:
	case R_SH_GOTPLT_MEDLOW16:
	case R_SH_GOTPLT_MEDHI16:
	case R_SH_GOTPLT_HI16:
	case R_SH_GOTPLT10BY4:
	case R_SH_GOTPLT10BY8:
#endif
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  if (h == NULL
	      || h->forced_local
	      || ! info->shared
	      || info->symbolic
	      || h->dynindx == -1
	      || h->plt.offset == (bfd_vma) -1
	      || h->got.offset != (bfd_vma) -1)
	    goto force_got;

	  /* Relocation is to the entry for this symbol in the global
	     offset table extension for the procedure linkage table.  */

	  BFD_ASSERT (htab);
	  BFD_ASSERT (sgotplt != NULL);
	  relocation = (sgotplt->output_offset
			+ (get_plt_index (htab->plt_info, h->plt.offset)
			   + 3) * 4);

#ifdef GOT_BIAS
	  relocation -= GOT_BIAS;
#endif

	  goto final_link_relocate;

	force_got:
	case R_SH_GOT32:
	case R_SH_GOT20:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOT_LOW16:
	case R_SH_GOT_MEDLOW16:
	case R_SH_GOT_MEDHI16:
	case R_SH_GOT_HI16:
	case R_SH_GOT10BY4:
	case R_SH_GOT10BY8:
#endif
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */

	  BFD_ASSERT (htab);
	  BFD_ASSERT (sgot != NULL);
	  check_segment[0] = check_segment[1] = -1;

	  if (h != NULL)
	    {
	      bfd_boolean dyn;

	      off = h->got.offset;
#ifdef INCLUDE_SHMEDIA
	      if (seen_stt_datalabel)
		{
		  struct elf_sh_link_hash_entry *hsh;

		  hsh = (struct elf_sh_link_hash_entry *)h;
		  off = hsh->datalabel_got.offset;
		}
#endif
	      BFD_ASSERT (off != (bfd_vma) -1);

	      dyn = htab->root.dynamic_sections_created;
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		  || (info->shared
		      && SYMBOL_REFERENCES_LOCAL (info, h))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 4, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_32 (output_bfd, relocation,
				  sgot->contents + off);
#ifdef INCLUDE_SHMEDIA
		      if (seen_stt_datalabel)
			{
			  struct elf_sh_link_hash_entry *hsh;

			  hsh = (struct elf_sh_link_hash_entry *)h;
			  hsh->datalabel_got.offset |= 1;
			}
		      else
#endif
			h->got.offset |= 1;

		      /* If we initialize the GOT entry here with a valid
			 symbol address, also add a fixup.  */
		      if (fdpic_p && !info->shared
			  && sh_elf_hash_entry (h)->got_type == GOT_NORMAL
			  && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
			      || h->root.type != bfd_link_hash_undefweak))
			sh_elf_add_rofixup (output_bfd, htab->srofixup,
					    sgot->output_section->vma
					    + sgot->output_offset
					    + off);
		    }
		}

	      relocation = sh_elf_got_offset (htab) + off;
	    }
	  else
	    {
#ifdef INCLUDE_SHMEDIA
	      if (rel->r_addend)
		{
		  BFD_ASSERT (local_got_offsets != NULL
			      && (local_got_offsets[symtab_hdr->sh_info
						    + r_symndx]
				  != (bfd_vma) -1));

		  off = local_got_offsets[symtab_hdr->sh_info
					  + r_symndx];
		}
	      else
		{
#endif
	      BFD_ASSERT (local_got_offsets != NULL
			  && local_got_offsets[r_symndx] != (bfd_vma) -1);

	      off = local_got_offsets[r_symndx];
#ifdef INCLUDE_SHMEDIA
		}
#endif

	      /* The offset must always be a multiple of 4.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_32 (output_bfd, relocation, sgot->contents + off);

		  if (info->shared)
		    {
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;

		      if (srelgot == NULL)
			{
			  srelgot = bfd_get_linker_section (dynobj,
							    ".rela.got");
			  BFD_ASSERT (srelgot != NULL);
			}

		      outrel.r_offset = (sgot->output_section->vma
					 + sgot->output_offset
					 + off);
		      if (fdpic_p)
			{
			  int dynindx
			    = elf_section_data (sec->output_section)->dynindx;
			  outrel.r_info = ELF32_R_INFO (dynindx, R_SH_DIR32);
			  outrel.r_addend = relocation;
			  outrel.r_addend -= sec->output_section->vma;
			}
		      else
			{
			  outrel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
			  outrel.r_addend = relocation;
			}
		      loc = srelgot->contents;
		      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }
		  else if (fdpic_p
			   && (sh_elf_local_got_type (input_bfd) [r_symndx]
			       == GOT_NORMAL))
		    sh_elf_add_rofixup (output_bfd, htab->srofixup,
					sgot->output_section->vma
					+ sgot->output_offset
					+ off);

#ifdef INCLUDE_SHMEDIA
		  if (rel->r_addend)
		    local_got_offsets[symtab_hdr->sh_info + r_symndx] |= 1;
		  else
#endif
		    local_got_offsets[r_symndx] |= 1;
		}

	      relocation = sh_elf_got_offset (htab) + off;
	    }

#ifdef GOT_BIAS
	  relocation -= GOT_BIAS;
#endif

	  if (r_type == R_SH_GOT20)
	    {
	      r = install_movi20_field (output_bfd, relocation + addend,
					input_bfd, input_section, contents,
					rel->r_offset);
	      break;
	    }
	  else
	    goto final_link_relocate;

	case R_SH_GOTOFF:
	case R_SH_GOTOFF20:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOTOFF_LOW16:
	case R_SH_GOTOFF_MEDLOW16:
	case R_SH_GOTOFF_MEDHI16:
	case R_SH_GOTOFF_HI16:
#endif
	  /* GOTOFF relocations are relative to _GLOBAL_OFFSET_TABLE_, which
	     we place at the start of the .got.plt section.  This is the same
	     as the start of the output .got section, unless there are function
	     descriptors in front of it.  */
	  BFD_ASSERT (htab);
	  BFD_ASSERT (sgotplt != NULL);
	  check_segment[0] = got_segment;
	  relocation -= sgotplt->output_section->vma + sgotplt->output_offset
	    + htab->root.hgot->root.u.def.value;

#ifdef GOT_BIAS
	  relocation -= GOT_BIAS;
#endif

	  addend = rel->r_addend;

	  if (r_type == R_SH_GOTOFF20)
	    {
	      r = install_movi20_field (output_bfd, relocation + addend,
					input_bfd, input_section, contents,
					rel->r_offset);
	      break;
	    }
	  else
	    goto final_link_relocate;

	case R_SH_GOTPC:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOTPC_LOW16:
	case R_SH_GOTPC_MEDLOW16:
	case R_SH_GOTPC_MEDHI16:
	case R_SH_GOTPC_HI16:
#endif
	  /* Use global offset table as symbol value.  */

	  BFD_ASSERT (sgotplt != NULL);
	  relocation = sgotplt->output_section->vma + sgotplt->output_offset;

#ifdef GOT_BIAS
	  relocation += GOT_BIAS;
#endif

	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_PLT32:
#ifdef INCLUDE_SHMEDIA
	case R_SH_PLT_LOW16:
	case R_SH_PLT_MEDLOW16:
	case R_SH_PLT_MEDHI16:
	case R_SH_PLT_HI16:
#endif
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLT reloc against a local symbol directly,
	     without using the procedure linkage table.  */
	  if (h == NULL)
	    goto final_link_relocate;

	  /* We don't want to warn on calls to undefined weak symbols,
	     as calls to them must be protected by non-NULL tests
	     anyway, and unprotected calls would invoke undefined
	     behavior.  */
	  if (h->root.type == bfd_link_hash_undefweak)
	    check_segment[0] = check_segment[1] = -1;

	  if (h->forced_local)
	    goto final_link_relocate;

	  if (h->plt.offset == (bfd_vma) -1)
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      goto final_link_relocate;
	    }

	  BFD_ASSERT (splt != NULL);
	  check_segment[1] = plt_segment;
	  relocation = (splt->output_section->vma
			+ splt->output_offset
			+ h->plt.offset);

#ifdef INCLUDE_SHMEDIA
	  relocation++;
#endif

	  addend = rel->r_addend;

	  goto final_link_relocate;

	/* Relocation is to the canonical function descriptor for this
	   symbol, possibly via the GOT.  Initialize the GOT
	   entry and function descriptor if necessary.  */
	case R_SH_GOTFUNCDESC:
	case R_SH_GOTFUNCDESC20:
	case R_SH_FUNCDESC:
	  {
	    int dynindx = -1;
	    asection *reloc_section;
	    bfd_vma reloc_offset;
	    int reloc_type = R_SH_FUNCDESC;

	    BFD_ASSERT (htab);

	    check_segment[0] = check_segment[1] = -1;

	    /* FIXME: See what FRV does for global symbols in the
	       executable, with --export-dynamic.  Do they need ld.so
	       to allocate official descriptors?  See what this code
	       does.  */

	    relocation = 0;
	    addend = 0;

	    if (r_type == R_SH_FUNCDESC)
	      {
		reloc_section = input_section;
		reloc_offset = rel->r_offset;
	      }
	    else
	      {
		reloc_section = sgot;

		if (h != NULL)
		  reloc_offset = h->got.offset;
		else
		  {
		    BFD_ASSERT (local_got_offsets != NULL);
		    reloc_offset = local_got_offsets[r_symndx];
		  }
		BFD_ASSERT (reloc_offset != MINUS_ONE);

		if (reloc_offset & 1)
		  {
		    reloc_offset &= ~1;
		    goto funcdesc_done_got;
		  }
	      }

	    if (h && h->root.type == bfd_link_hash_undefweak
		&& (SYMBOL_CALLS_LOCAL (info, h)
		    || !htab->root.dynamic_sections_created))
	      /* Undefined weak symbol which will not be dynamically
		 resolved later; leave it at zero.  */
	      goto funcdesc_leave_zero;
	    else if (SYMBOL_CALLS_LOCAL (info, h)
		     && ! SYMBOL_FUNCDESC_LOCAL (info, h))
	      {
		/* If the symbol needs a non-local function descriptor
		   but binds locally (i.e., its visibility is
		   protected), emit a dynamic relocation decayed to
		   section+offset.  This is an optimization; the dynamic
		   linker would resolve our function descriptor request
		   to our copy of the function anyway.  */
		dynindx = elf_section_data (h->root.u.def.section
					    ->output_section)->dynindx;
		relocation += h->root.u.def.section->output_offset
		  + h->root.u.def.value;
	      }
	    else if (! SYMBOL_FUNCDESC_LOCAL (info, h))
	      {
		/* If the symbol is dynamic and there will be dynamic
		   symbol resolution because we are or are linked with a
		   shared library, emit a FUNCDESC relocation such that
		   the dynamic linker will allocate the function
		   descriptor.  */
		BFD_ASSERT (h->dynindx != -1);
		dynindx = h->dynindx;
	      }
	    else
	      {
		bfd_vma offset;

		/* Otherwise, we know we have a private function
		   descriptor, so reference it directly.  */
		reloc_type = R_SH_DIR32;
		dynindx = elf_section_data (htab->sfuncdesc
					    ->output_section)->dynindx;

		if (h)
		  {
		    offset = sh_elf_hash_entry (h)->funcdesc.offset;
		    BFD_ASSERT (offset != MINUS_ONE);
		    if ((offset & 1) == 0)
		      {
			if (!sh_elf_initialize_funcdesc (output_bfd, info, h,
							 offset, NULL, 0))
			  return FALSE;
			sh_elf_hash_entry (h)->funcdesc.offset |= 1;
		      }
		  }
		else
		  {
		    union gotref *local_funcdesc;

		    local_funcdesc = sh_elf_local_funcdesc (input_bfd);
		    offset = local_funcdesc[r_symndx].offset;
		    BFD_ASSERT (offset != MINUS_ONE);
		    if ((offset & 1) == 0)
		      {
			if (!sh_elf_initialize_funcdesc (output_bfd, info, NULL,
							 offset, sec,
							 sym->st_value))
			  return FALSE;
			local_funcdesc[r_symndx].offset |= 1;
		      }
		  }

		relocation = htab->sfuncdesc->output_offset + (offset & ~1);
	      }

	    if (!info->shared && SYMBOL_FUNCDESC_LOCAL (info, h))
	      {
		bfd_vma offset;

		if (sh_elf_osec_readonly_p (output_bfd,
					    reloc_section->output_section))
		  {
		    (*_bfd_error_handler)
		      (_("%B(%A+0x%lx): cannot emit fixup to `%s' in read-only section"),
		       input_bfd,
		       input_section,
		       (long) rel->r_offset,
		       symname);
		    return FALSE;
		  }

		offset = _bfd_elf_section_offset (output_bfd, info,
						  reloc_section, reloc_offset);

		if (offset != (bfd_vma)-1)
		  sh_elf_add_rofixup (output_bfd, htab->srofixup,
				      offset
				      + reloc_section->output_section->vma
				      + reloc_section->output_offset);
	      }
	    else if ((reloc_section->output_section->flags
		      & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
	      {
		bfd_vma offset;

		if (sh_elf_osec_readonly_p (output_bfd,
					    reloc_section->output_section))
		  {
		    info->callbacks->warning
		      (info,
		       _("cannot emit dynamic relocations in read-only section"),
		       symname, input_bfd, reloc_section, reloc_offset);
		    return FALSE;
		  }

		if (srelgot == NULL)
		  {
		    srelgot = bfd_get_linker_section (dynobj, ".rela.got");
		    BFD_ASSERT (srelgot != NULL);
		  }

		offset = _bfd_elf_section_offset (output_bfd, info,
						  reloc_section, reloc_offset);

		if (offset != (bfd_vma)-1)
		  sh_elf_add_dyn_reloc (output_bfd, srelgot,
					offset
					+ reloc_section->output_section->vma
					+ reloc_section->output_offset,
					reloc_type, dynindx, relocation);

		if (r_type == R_SH_FUNCDESC)
		  {
		    r = bfd_reloc_ok;
		    break;
		  }
		else
		  {
		    relocation = 0;
		    goto funcdesc_leave_zero;
		  }
	      }

	    if (SYMBOL_FUNCDESC_LOCAL (info, h))
	      relocation += htab->sfuncdesc->output_section->vma;
	  funcdesc_leave_zero:
	    if (r_type != R_SH_FUNCDESC)
	      {
		bfd_put_32 (output_bfd, relocation,
			    reloc_section->contents + reloc_offset);
		if (h != NULL)
		  h->got.offset |= 1;
		else
		  local_got_offsets[r_symndx] |= 1;

	      funcdesc_done_got:

		relocation = sh_elf_got_offset (htab) + reloc_offset;
#ifdef GOT_BIAS
		relocation -= GOT_BIAS;
#endif
	      }
	    if (r_type == R_SH_GOTFUNCDESC20)
	      {
		r = install_movi20_field (output_bfd, relocation + addend,
					  input_bfd, input_section, contents,
					  rel->r_offset);
		break;
	      }
	    else
	      goto final_link_relocate;
	  }
	  break;

	case R_SH_GOTOFFFUNCDESC:
	case R_SH_GOTOFFFUNCDESC20:
	  /* FIXME: See R_SH_FUNCDESC comment about global symbols in the
	     executable and --export-dynamic.  If such symbols get
	     ld.so-allocated descriptors we can not use R_SH_GOTOFFFUNCDESC
	     for them.  */
	  BFD_ASSERT (htab);

	  check_segment[0] = check_segment[1] = -1;
	  relocation = 0;
	  addend = rel->r_addend;

	  if (h && (h->root.type == bfd_link_hash_undefweak
		    || !SYMBOL_FUNCDESC_LOCAL (info, h)))
	    {
	      _bfd_error_handler
		(_("%B(%A+0x%lx): %s relocation against external symbol \"%s\""),
		 input_bfd, input_section, (long) rel->r_offset, howto->name,
		 h->root.root.string);
	      return FALSE;
	    }
	  else
	    {
	      bfd_vma offset;

	      /* Otherwise, we know we have a private function
		 descriptor, so reference it directly.  */
	      if (h)
		{
		  offset = sh_elf_hash_entry (h)->funcdesc.offset;
		  BFD_ASSERT (offset != MINUS_ONE);
		  if ((offset & 1) == 0)
		    {
		      if (!sh_elf_initialize_funcdesc (output_bfd, info, h,
						       offset, NULL, 0))
			return FALSE;
		      sh_elf_hash_entry (h)->funcdesc.offset |= 1;
		    }
		}
	      else
		{
		  union gotref *local_funcdesc;

		  local_funcdesc = sh_elf_local_funcdesc (input_bfd);
		  offset = local_funcdesc[r_symndx].offset;
		  BFD_ASSERT (offset != MINUS_ONE);
		  if ((offset & 1) == 0)
		    {
		      if (!sh_elf_initialize_funcdesc (output_bfd, info, NULL,
						       offset, sec,
						       sym->st_value))
			return FALSE;
		      local_funcdesc[r_symndx].offset |= 1;
		    }
		}

	      relocation = htab->sfuncdesc->output_offset + (offset & ~1);
	    }

	  relocation -= (htab->root.hgot->root.u.def.value
			 + sgotplt->output_offset);
#ifdef GOT_BIAS
	  relocation -= GOT_BIAS;
#endif

	  if (r_type == R_SH_GOTOFFFUNCDESC20)
	    {
	      r = install_movi20_field (output_bfd, relocation + addend,
					input_bfd, input_section, contents,
					rel->r_offset);
	      break;
	    }
	  else
	    goto final_link_relocate;

	case R_SH_LOOP_START:
	  {
	    static bfd_vma start, end;

	    start = (relocation + rel->r_addend
		     - (sec->output_section->vma + sec->output_offset));
	    r = sh_elf_reloc_loop (r_type, input_bfd, input_section, contents,
				   rel->r_offset, sec, start, end);
	    break;

	case R_SH_LOOP_END:
	    end = (relocation + rel->r_addend
		   - (sec->output_section->vma + sec->output_offset));
	    r = sh_elf_reloc_loop (r_type, input_bfd, input_section, contents,
				   rel->r_offset, sec, start, end);
	    break;
	  }

	case R_SH_TLS_GD_32:
	case R_SH_TLS_IE_32:
	  BFD_ASSERT (htab);
	  check_segment[0] = check_segment[1] = -1;
	  r_type = sh_elf_optimized_tls_reloc (info, r_type, h == NULL);
	  got_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    got_type = sh_elf_local_got_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      got_type = sh_elf_hash_entry (h)->got_type;
	      if (! info->shared
		  && (h->dynindx == -1
		      || h->def_regular))
		r_type = R_SH_TLS_LE_32;
	    }

	  if (r_type == R_SH_TLS_GD_32 && got_type == GOT_TLS_IE)
	    r_type = R_SH_TLS_IE_32;

	  if (r_type == R_SH_TLS_LE_32)
	    {
	      bfd_vma offset;
	      unsigned short insn;

	      if (ELF32_R_TYPE (rel->r_info) == R_SH_TLS_GD_32)
		{
		  /* GD->LE transition:
		       mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		       jsr @@r1; add r12,r4; bra 3f; nop; .align 2;
		       1: .long x$TLSGD; 2: .long __tls_get_addr@@PLT; 3:
		     We change it into:
		       mov.l 1f,r4; stc gbr,r0; add r4,r0; nop;
		       nop; nop; ...
		       1: .long x@@TPOFF; 2: .long __tls_get_addr@@PLT; 3:.  */

		  offset = rel->r_offset;
		  BFD_ASSERT (offset >= 16);
		  /* Size of GD instructions is 16 or 18.  */
		  offset -= 16;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		  if ((insn & 0xff00) == 0xc700)
		    {
		      BFD_ASSERT (offset >= 2);
		      offset -= 2;
		      insn = bfd_get_16 (input_bfd, contents + offset + 0);
		    }

		  BFD_ASSERT ((insn & 0xff00) == 0xd400);
		  insn = bfd_get_16 (input_bfd, contents + offset + 2);
		  BFD_ASSERT ((insn & 0xff00) == 0xc700);
		  insn = bfd_get_16 (input_bfd, contents + offset + 4);
		  BFD_ASSERT ((insn & 0xff00) == 0xd100);
		  insn = bfd_get_16 (input_bfd, contents + offset + 6);
		  BFD_ASSERT (insn == 0x310c);
		  insn = bfd_get_16 (input_bfd, contents + offset + 8);
		  BFD_ASSERT (insn == 0x410b);
		  insn = bfd_get_16 (input_bfd, contents + offset + 10);
		  BFD_ASSERT (insn == 0x34cc);

		  bfd_put_16 (output_bfd, 0x0012, contents + offset + 2);
		  bfd_put_16 (output_bfd, 0x304c, contents + offset + 4);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 6);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);
		}
	      else
		{
		  int target;

		  /* IE->LE transition:
		     mov.l 1f,r0; stc gbr,rN; mov.l @@(r0,r12),rM;
		     bra 2f; add ...; .align 2; 1: x@@GOTTPOFF; 2:
		     We change it into:
		     mov.l .Ln,rM; stc gbr,rN; nop; ...;
		     1: x@@TPOFF; 2:.  */

		  offset = rel->r_offset;
		  BFD_ASSERT (offset >= 16);
		  /* Size of IE instructions is 10 or 12.  */
		  offset -= 10;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		  if ((insn & 0xf0ff) == 0x0012)
		    {
		      BFD_ASSERT (offset >= 2);
		      offset -= 2;
		      insn = bfd_get_16 (input_bfd, contents + offset + 0);
		    }

		  BFD_ASSERT ((insn & 0xff00) == 0xd000);
		  target = insn & 0x00ff;
		  insn = bfd_get_16 (input_bfd, contents + offset + 2);
		  BFD_ASSERT ((insn & 0xf0ff) == 0x0012);
		  insn = bfd_get_16 (input_bfd, contents + offset + 4);
		  BFD_ASSERT ((insn & 0xf0ff) == 0x00ce);
		  insn = 0xd000 | (insn & 0x0f00) | target;
		  bfd_put_16 (output_bfd, insn, contents + offset + 0);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 4);
		}

	      bfd_put_32 (output_bfd, tpoff (info, relocation),
			  contents + rel->r_offset);
	      continue;
	    }

	  if (sgot == NULL || sgotplt == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	  /* Relocate R_SH_TLS_IE_32 directly when statically linking.  */
	  if (r_type == R_SH_TLS_IE_32
	      && ! htab->root.dynamic_sections_created)
	    {
	      off &= ~1;
	      bfd_put_32 (output_bfd, tpoff (info, relocation),
			  sgot->contents + off);
	      bfd_put_32 (output_bfd, sh_elf_got_offset (htab) + off,
			  contents + rel->r_offset);
	      continue;
	    }

	  if ((off & 1) != 0)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      int dr_type, indx;

	      if (srelgot == NULL)
		{
		  srelgot = bfd_get_linker_section (dynobj, ".rela.got");
		  BFD_ASSERT (srelgot != NULL);
		}

	      outrel.r_offset = (sgot->output_section->vma
				 + sgot->output_offset + off);

	      if (h == NULL || h->dynindx == -1)
		indx = 0;
	      else
		indx = h->dynindx;

	      dr_type = (r_type == R_SH_TLS_GD_32 ? R_SH_TLS_DTPMOD32 :
			 R_SH_TLS_TPOFF32);
	      if (dr_type == R_SH_TLS_TPOFF32 && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      outrel.r_info = ELF32_R_INFO (indx, dr_type);
	      loc = srelgot->contents;
	      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      if (r_type == R_SH_TLS_GD_32)
		{
		  if (indx == 0)
		    {
		      bfd_put_32 (output_bfd,
				  relocation - dtpoff_base (info),
				  sgot->contents + off + 4);
		    }
		  else
		    {
		      outrel.r_info = ELF32_R_INFO (indx,
						    R_SH_TLS_DTPOFF32);
		      outrel.r_offset += 4;
		      outrel.r_addend = 0;
		      srelgot->reloc_count++;
		      loc += sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }
		}

	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();

	  if (r_type == (int) ELF32_R_TYPE (rel->r_info))
	    relocation = sh_elf_got_offset (htab) + off;
	  else
	    {
	      bfd_vma offset;
	      unsigned short insn;

	      /* GD->IE transition:
		   mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		   jsr @@r1; add r12,r4; bra 3f; nop; .align 2;
		   1: .long x$TLSGD; 2: .long __tls_get_addr@@PLT; 3:
		 We change it into:
		   mov.l 1f,r0; stc gbr,r4; mov.l @@(r0,r12),r0; add r4,r0;
		   nop; nop; bra 3f; nop; .align 2;
		   1: .long x@@TPOFF; 2:...; 3:.  */

	      offset = rel->r_offset;
	      BFD_ASSERT (offset >= 16);
	      /* Size of GD instructions is 16 or 18.  */
	      offset -= 16;
	      insn = bfd_get_16 (input_bfd, contents + offset + 0);
	      if ((insn & 0xff00) == 0xc700)
		{
		  BFD_ASSERT (offset >= 2);
		  offset -= 2;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		}

	      BFD_ASSERT ((insn & 0xff00) == 0xd400);

	      /* Replace mov.l 1f,R4 with mov.l 1f,r0.  */
	      bfd_put_16 (output_bfd, insn & 0xf0ff, contents + offset);

	      insn = bfd_get_16 (input_bfd, contents + offset + 2);
	      BFD_ASSERT ((insn & 0xff00) == 0xc700);
	      insn = bfd_get_16 (input_bfd, contents + offset + 4);
	      BFD_ASSERT ((insn & 0xff00) == 0xd100);
	      insn = bfd_get_16 (input_bfd, contents + offset + 6);
	      BFD_ASSERT (insn == 0x310c);
	      insn = bfd_get_16 (input_bfd, contents + offset + 8);
	      BFD_ASSERT (insn == 0x410b);
	      insn = bfd_get_16 (input_bfd, contents + offset + 10);
	      BFD_ASSERT (insn == 0x34cc);

	      bfd_put_16 (output_bfd, 0x0412, contents + offset + 2);
	      bfd_put_16 (output_bfd, 0x00ce, contents + offset + 4);
	      bfd_put_16 (output_bfd, 0x304c, contents + offset + 6);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);

	      bfd_put_32 (output_bfd, sh_elf_got_offset (htab) + off,
			  contents + rel->r_offset);

	      continue;
	  }

	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_TLS_LD_32:
	  BFD_ASSERT (htab);
	  check_segment[0] = check_segment[1] = -1;
	  if (! info->shared)
	    {
	      bfd_vma offset;
	      unsigned short insn;

	      /* LD->LE transition:
		   mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		   jsr @@r1; add r12,r4; bra 3f; nop; .align 2;
		   1: .long x$TLSLD; 2: .long __tls_get_addr@@PLT; 3:
		 We change it into:
		   stc gbr,r0; nop; nop; nop;
		   nop; nop; bra 3f; ...; 3:.  */

	      offset = rel->r_offset;
	      BFD_ASSERT (offset >= 16);
	      /* Size of LD instructions is 16 or 18.  */
	      offset -= 16;
	      insn = bfd_get_16 (input_bfd, contents + offset + 0);
	      if ((insn & 0xff00) == 0xc700)
		{
		  BFD_ASSERT (offset >= 2);
		  offset -= 2;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		}

	      BFD_ASSERT ((insn & 0xff00) == 0xd400);
	      insn = bfd_get_16 (input_bfd, contents + offset + 2);
	      BFD_ASSERT ((insn & 0xff00) == 0xc700);
	      insn = bfd_get_16 (input_bfd, contents + offset + 4);
	      BFD_ASSERT ((insn & 0xff00) == 0xd100);
	      insn = bfd_get_16 (input_bfd, contents + offset + 6);
	      BFD_ASSERT (insn == 0x310c);
	      insn = bfd_get_16 (input_bfd, contents + offset + 8);
	      BFD_ASSERT (insn == 0x410b);
	      insn = bfd_get_16 (input_bfd, contents + offset + 10);
	      BFD_ASSERT (insn == 0x34cc);

	      bfd_put_16 (output_bfd, 0x0012, contents + offset + 0);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 2);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 4);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 6);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);

	      continue;
	    }

	  if (sgot == NULL || sgotplt == NULL)
	    abort ();

	  off = htab->tls_ldm_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;

	      srelgot = htab->srelgot;
	      if (srelgot == NULL)
		abort ();

	      outrel.r_offset = (sgot->output_section->vma
				 + sgot->output_offset + off);
	      outrel.r_addend = 0;
	      outrel.r_info = ELF32_R_INFO (0, R_SH_TLS_DTPMOD32);
	      loc = srelgot->contents;
	      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ldm_got.offset |= 1;
	    }

	  relocation = sh_elf_got_offset (htab) + off;
	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_TLS_LDO_32:
	  check_segment[0] = check_segment[1] = -1;
	  if (! info->shared)
	    relocation = tpoff (info, relocation);
	  else
	    relocation -= dtpoff_base (info);

	  addend = rel->r_addend;
	  goto final_link_relocate;

	case R_SH_TLS_LE_32:
	  {
	    int indx;
	    Elf_Internal_Rela outrel;
	    bfd_byte *loc;

	    check_segment[0] = check_segment[1] = -1;

	    if (! info->shared || info->pie)
	      {
		relocation = tpoff (info, relocation);
		addend = rel->r_addend;
		goto final_link_relocate;
	      }

	    if (sreloc == NULL)
	      {
		sreloc = _bfd_elf_get_dynamic_reloc_section
		  (input_bfd, input_section, /*rela?*/ TRUE);
		if (sreloc == NULL)
		  return FALSE;
	      }

	    if (h == NULL || h->dynindx == -1)
	      indx = 0;
	    else
	      indx = h->dynindx;

	    outrel.r_offset = (input_section->output_section->vma
			       + input_section->output_offset
			       + rel->r_offset);
	    outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	    if (indx == 0)
	      outrel.r_addend = relocation - dtpoff_base (info);
	    else
	      outrel.r_addend = 0;

	    loc = sreloc->contents;
	    loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	    bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	    continue;
	  }
	}

    relocation_done:
      if (fdpic_p && check_segment[0] != (unsigned) -1
	  && check_segment[0] != check_segment[1])
	{
	  /* We don't want duplicate errors for undefined symbols.  */
	  if (!h || h->root.type != bfd_link_hash_undefined)
	    {
	      if (info->shared)
		{
		  info->callbacks->einfo
		    (_("%X%C: relocation to \"%s\" references a different segment\n"),
		     input_bfd, input_section, rel->r_offset, symname);
		  return FALSE;
		}
	      else
		info->callbacks->einfo
		  (_("%C: warning: relocation to \"%s\" references a different segment\n"),
		   input_bfd, input_section, rel->r_offset, symname);
	    }

	  elf_elfheader (output_bfd)->e_flags &= ~EF_SH_PIC;
	}

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = NULL;
		else
		  {
		    name = (bfd_elf_string_from_elf_section
			    (input_bfd, symtab_hdr->sh_link, sym->st_name));
		    if (name == NULL)
		      return FALSE;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, (h ? &h->root : NULL), name, howto->name,
			(bfd_vma) 0, input_bfd, input_section,
			rel->r_offset)))
		  return FALSE;
	      }
	      break;
	    }
	}
    }

  return TRUE;
}

/* This is a version of bfd_generic_get_relocated_section_contents
   which uses sh_elf_relocate_section.  */

static bfd_byte *
sh_elf_get_relocated_section_contents (bfd *output_bfd,
				       struct bfd_link_info *link_info,
				       struct bfd_link_order *link_order,
				       bfd_byte *data,
				       bfd_boolean relocatable,
				       asymbol **symbols)
{
  Elf_Internal_Shdr *symtab_hdr;
  asection *input_section = link_order->u.indirect.section;
  bfd *input_bfd = input_section->owner;
  asection **sections = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Sym *isymbuf = NULL;

  /* We only need to handle the case of relaxing, or of having a
     particular set of section contents, specially.  */
  if (relocatable
      || elf_section_data (input_section)->this_hdr.contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
						       link_order, data,
						       relocatable,
						       symbols);

  symtab_hdr = &elf_symtab_hdr (input_bfd);

  memcpy (data, elf_section_data (input_section)->this_hdr.contents,
	  (size_t) input_section->size);

  if ((input_section->flags & SEC_RELOC) != 0
      && input_section->reloc_count > 0)
    {
      asection **secpp;
      Elf_Internal_Sym *isym, *isymend;
      bfd_size_type amt;

      internal_relocs = (_bfd_elf_link_read_relocs
			 (input_bfd, input_section, NULL,
			  (Elf_Internal_Rela *) NULL, FALSE));
      if (internal_relocs == NULL)
	goto error_return;

      if (symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      amt = symtab_hdr->sh_info;
      amt *= sizeof (asection *);
      sections = (asection **) bfd_malloc (amt);
      if (sections == NULL && amt != 0)
	goto error_return;

      isymend = isymbuf + symtab_hdr->sh_info;
      for (isym = isymbuf, secpp = sections; isym < isymend; ++isym, ++secpp)
	{
	  asection *isec;

	  if (isym->st_shndx == SHN_UNDEF)
	    isec = bfd_und_section_ptr;
	  else if (isym->st_shndx == SHN_ABS)
	    isec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    isec = bfd_com_section_ptr;
	  else
	    isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);

	  *secpp = isec;
	}

      if (! sh_elf_relocate_section (output_bfd, link_info, input_bfd,
				     input_section, data, internal_relocs,
				     isymbuf, sections))
	goto error_return;

      if (sections != NULL)
	free (sections);
      if (isymbuf != NULL
	  && symtab_hdr->contents != (unsigned char *) isymbuf)
	free (isymbuf);
      if (elf_section_data (input_section)->relocs != internal_relocs)
	free (internal_relocs);
    }

  return data;

 error_return:
  if (sections != NULL)
    free (sections);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (input_section)->relocs != internal_relocs)
    free (internal_relocs);
  return NULL;
}

/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for R_SH_TLS_TPOFF32..  */

static bfd_vma
tpoff (struct bfd_link_info *info, bfd_vma address)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  /* SH TLS ABI is variant I and static TLS block start just after tcbhead
     structure which has 2 pointer fields.  */
  return (address - elf_hash_table (info)->tls_sec->vma
	  + align_power ((bfd_vma) 8,
			 elf_hash_table (info)->tls_sec->alignment_power));
}

static asection *
sh_elf_gc_mark_hook (asection *sec,
		     struct bfd_link_info *info,
		     Elf_Internal_Rela *rel,
		     struct elf_link_hash_entry *h,
		     Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_SH_GNU_VTINHERIT:
      case R_SH_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
sh_elf_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
		      asection *sec, const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  union gotref *local_funcdesc;
  const Elf_Internal_Rela *rel, *relend;

  if (info->relocatable)
    return TRUE;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);
  local_funcdesc = sh_elf_local_funcdesc (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;
#ifdef INCLUDE_SHMEDIA
      int seen_stt_datalabel = 0;
#endif

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf_sh_link_hash_entry *eh;
	  struct elf_sh_dyn_relocs **pp;
	  struct elf_sh_dyn_relocs *p;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    {
#ifdef INCLUDE_SHMEDIA
	      seen_stt_datalabel |= h->type == STT_DATALABEL;
#endif
	      h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
	  eh = (struct elf_sh_link_hash_entry *) h;
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      r_type = ELF32_R_TYPE (rel->r_info);
      switch (sh_elf_optimized_tls_reloc (info, r_type, h != NULL))
	{
	case R_SH_TLS_LD_32:
	  if (sh_elf_hash_table (info)->tls_ldm_got.refcount > 0)
	    sh_elf_hash_table (info)->tls_ldm_got.refcount -= 1;
	  break;

	case R_SH_GOT32:
	case R_SH_GOT20:
	case R_SH_GOTOFF:
	case R_SH_GOTOFF20:
	case R_SH_GOTPC:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOT_LOW16:
	case R_SH_GOT_MEDLOW16:
	case R_SH_GOT_MEDHI16:
	case R_SH_GOT_HI16:
	case R_SH_GOT10BY4:
	case R_SH_GOT10BY8:
	case R_SH_GOTOFF_LOW16:
	case R_SH_GOTOFF_MEDLOW16:
	case R_SH_GOTOFF_MEDHI16:
	case R_SH_GOTOFF_HI16:
	case R_SH_GOTPC_LOW16:
	case R_SH_GOTPC_MEDLOW16:
	case R_SH_GOTPC_MEDHI16:
	case R_SH_GOTPC_HI16:
#endif
	case R_SH_TLS_GD_32:
	case R_SH_TLS_IE_32:
	case R_SH_GOTFUNCDESC:
	case R_SH_GOTFUNCDESC20:
	  if (h != NULL)
	    {
#ifdef INCLUDE_SHMEDIA
	      if (seen_stt_datalabel)
		{
		  struct elf_sh_link_hash_entry *eh;
		  eh = (struct elf_sh_link_hash_entry *) h;
		  if (eh->datalabel_got.refcount > 0)
		    eh->datalabel_got.refcount -= 1;
		}
	      else
#endif
		if (h->got.refcount > 0)
		  h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
#ifdef INCLUDE_SHMEDIA
	      if (rel->r_addend & 1)
		{
		  if (local_got_refcounts[symtab_hdr->sh_info + r_symndx] > 0)
		    local_got_refcounts[symtab_hdr->sh_info + r_symndx] -= 1;
		}
	      else
#endif
		if (local_got_refcounts[r_symndx] > 0)
		  local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	case R_SH_FUNCDESC:
	  if (h != NULL)
	    sh_elf_hash_entry (h)->abs_funcdesc_refcount -= 1;
	  else if (sh_elf_hash_table (info)->fdpic_p && !info->shared)
	    sh_elf_hash_table (info)->srofixup->size -= 4;

	  /* Fall through.  */

	case R_SH_GOTOFFFUNCDESC:
	case R_SH_GOTOFFFUNCDESC20:
	  if (h != NULL)
	    sh_elf_hash_entry (h)->funcdesc.refcount -= 1;
	  else
	    local_funcdesc[r_symndx].refcount -= 1;
	  break;

	case R_SH_DIR32:
	  if (sh_elf_hash_table (info)->fdpic_p && !info->shared
	      && (sec->flags & SEC_ALLOC) != 0)
	    sh_elf_hash_table (info)->srofixup->size -= 4;
	  /* Fall thru */

	case R_SH_REL32:
	  if (info->shared)
	    break;
	  /* Fall thru */

	case R_SH_PLT32:
#ifdef INCLUDE_SHMEDIA
	case R_SH_PLT_LOW16:
	case R_SH_PLT_MEDLOW16:
	case R_SH_PLT_MEDHI16:
	case R_SH_PLT_HI16:
#endif
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;

	case R_SH_GOTPLT32:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOTPLT_LOW16:
	case R_SH_GOTPLT_MEDLOW16:
	case R_SH_GOTPLT_MEDHI16:
	case R_SH_GOTPLT_HI16:
	case R_SH_GOTPLT10BY4:
	case R_SH_GOTPLT10BY8:
#endif
	  if (h != NULL)
	    {
	      struct elf_sh_link_hash_entry *eh;
	      eh = (struct elf_sh_link_hash_entry *) h;
	      if (eh->gotplt_refcount > 0)
		{
		  eh->gotplt_refcount -= 1;
		  if (h->plt.refcount > 0)
		    h->plt.refcount -= 1;
		}
#ifdef INCLUDE_SHMEDIA
	      else if (seen_stt_datalabel)
		{
		  if (eh->datalabel_got.refcount > 0)
		    eh->datalabel_got.refcount -= 1;
		}
#endif
	      else if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
#ifdef INCLUDE_SHMEDIA
	      if (rel->r_addend & 1)
		{
		  if (local_got_refcounts[symtab_hdr->sh_info + r_symndx] > 0)
		    local_got_refcounts[symtab_hdr->sh_info + r_symndx] -= 1;
		}
	      else
#endif
		if (local_got_refcounts[r_symndx] > 0)
		  local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
sh_elf_copy_indirect_symbol (struct bfd_link_info *info,
			     struct elf_link_hash_entry *dir,
			     struct elf_link_hash_entry *ind)
{
  struct elf_sh_link_hash_entry *edir, *eind;

  edir = (struct elf_sh_link_hash_entry *) dir;
  eind = (struct elf_sh_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf_sh_dyn_relocs **pp;
	  struct elf_sh_dyn_relocs *p;

	  /* Add reloc counts against the indirect sym to the direct sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf_sh_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }
  edir->gotplt_refcount = eind->gotplt_refcount;
  eind->gotplt_refcount = 0;
#ifdef INCLUDE_SHMEDIA
  edir->datalabel_got.refcount += eind->datalabel_got.refcount;
  eind->datalabel_got.refcount = 0;
#endif
  edir->funcdesc.refcount += eind->funcdesc.refcount;
  eind->funcdesc.refcount = 0;
  edir->abs_funcdesc_refcount += eind->abs_funcdesc_refcount;
  eind->abs_funcdesc_refcount = 0;

  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->got_type = eind->got_type;
      eind->got_type = GOT_UNKNOWN;
    }

  if (ind->root.type != bfd_link_hash_indirect
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
    }
  else
    _bfd_elf_link_hash_copy_indirect (info, dir, ind);
}

static int
sh_elf_optimized_tls_reloc (struct bfd_link_info *info, int r_type,
			    int is_local)
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_SH_TLS_GD_32:
    case R_SH_TLS_IE_32:
      if (is_local)
	return R_SH_TLS_LE_32;
      return R_SH_TLS_IE_32;
    case R_SH_TLS_LD_32:
      return R_SH_TLS_LE_32;
    }

  return r_type;
}

/* Look through the relocs for a section during the first phase.
   Since we don't do .gots or .plts, we just need to consider the
   virtual table relocs for gc.  */

static bfd_boolean
sh_elf_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
		     const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_sh_link_hash_table *htab;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sreloc;
  unsigned int r_type;
  enum got_type got_type, old_got_type;

  sreloc = NULL;

  if (info->relocatable)
    return TRUE;

  BFD_ASSERT (is_sh_elf (abfd));

  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);

  htab = sh_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;
#ifdef INCLUDE_SHMEDIA
      int seen_stt_datalabel = 0;
#endif

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);

      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    {
#ifdef INCLUDE_SHMEDIA
	      seen_stt_datalabel |= h->type == STT_DATALABEL;
#endif
	      h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      r_type = sh_elf_optimized_tls_reloc (info, r_type, h == NULL);
      if (! info->shared
	  && r_type == R_SH_TLS_IE_32
	  && h != NULL
	  && h->root.type != bfd_link_hash_undefined
	  && h->root.type != bfd_link_hash_undefweak
	  && (h->dynindx == -1
	      || h->def_regular))
	r_type = R_SH_TLS_LE_32;

      if (htab->fdpic_p)
	switch (r_type)
	  {
	  case R_SH_GOTOFFFUNCDESC:
	  case R_SH_GOTOFFFUNCDESC20:
	  case R_SH_FUNCDESC:
	  case R_SH_GOTFUNCDESC:
	  case R_SH_GOTFUNCDESC20:
	    if (h != NULL)
	      {
		if (h->dynindx == -1)
		  switch (ELF_ST_VISIBILITY (h->other))
		    {
		    case STV_INTERNAL:
		    case STV_HIDDEN:
		      break;
		    default:
		      bfd_elf_link_record_dynamic_symbol (info, h);
		      break;
		    }
	      }
	    break;
	  }

      /* Some relocs require a global offset table.  */
      if (htab->sgot == NULL)
	{
	  switch (r_type)
	    {
	    case R_SH_DIR32:
	      /* This may require an rofixup.  */
	      if (!htab->fdpic_p)
		break;
	    case R_SH_GOTPLT32:
	    case R_SH_GOT32:
	    case R_SH_GOT20:
	    case R_SH_GOTOFF:
	    case R_SH_GOTOFF20:
	    case R_SH_FUNCDESC:
	    case R_SH_GOTFUNCDESC:
	    case R_SH_GOTFUNCDESC20:
	    case R_SH_GOTOFFFUNCDESC:
	    case R_SH_GOTOFFFUNCDESC20:
	    case R_SH_GOTPC:
#ifdef INCLUDE_SHMEDIA
	    case R_SH_GOTPLT_LOW16:
	    case R_SH_GOTPLT_MEDLOW16:
	    case R_SH_GOTPLT_MEDHI16:
	    case R_SH_GOTPLT_HI16:
	    case R_SH_GOTPLT10BY4:
	    case R_SH_GOTPLT10BY8:
	    case R_SH_GOT_LOW16:
	    case R_SH_GOT_MEDLOW16:
	    case R_SH_GOT_MEDHI16:
	    case R_SH_GOT_HI16:
	    case R_SH_GOT10BY4:
	    case R_SH_GOT10BY8:
	    case R_SH_GOTOFF_LOW16:
	    case R_SH_GOTOFF_MEDLOW16:
	    case R_SH_GOTOFF_MEDHI16:
	    case R_SH_GOTOFF_HI16:
	    case R_SH_GOTPC_LOW16:
	    case R_SH_GOTPC_MEDLOW16:
	    case R_SH_GOTPC_MEDHI16:
	    case R_SH_GOTPC_HI16:
#endif
	    case R_SH_TLS_GD_32:
	    case R_SH_TLS_LD_32:
	    case R_SH_TLS_IE_32:
	      if (htab->root.dynobj == NULL)
		htab->root.dynobj = abfd;
	      if (!create_got_section (htab->root.dynobj, info))
		return FALSE;
	      break;

	    default:
	      break;
	    }
	}

      switch (r_type)
	{
	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_SH_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_SH_GNU_VTENTRY:
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;

	case R_SH_TLS_IE_32:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;

	  /* FALLTHROUGH */
	force_got:
	case R_SH_TLS_GD_32:
	case R_SH_GOT32:
	case R_SH_GOT20:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOT_LOW16:
	case R_SH_GOT_MEDLOW16:
	case R_SH_GOT_MEDHI16:
	case R_SH_GOT_HI16:
	case R_SH_GOT10BY4:
	case R_SH_GOT10BY8:
#endif
	case R_SH_GOTFUNCDESC:
	case R_SH_GOTFUNCDESC20:
	  switch (r_type)
	    {
	    default:
	      got_type = GOT_NORMAL;
	      break;
	    case R_SH_TLS_GD_32:
	      got_type = GOT_TLS_GD;
	      break;
	    case R_SH_TLS_IE_32:
	      got_type = GOT_TLS_IE;
	      break;
	    case R_SH_GOTFUNCDESC:
	    case R_SH_GOTFUNCDESC20:
	      got_type = GOT_FUNCDESC;
	      break;
	    }

	  if (h != NULL)
	    {
#ifdef INCLUDE_SHMEDIA
	      if (seen_stt_datalabel)
		{
		  struct elf_sh_link_hash_entry *eh
		    = (struct elf_sh_link_hash_entry *) h;

		  eh->datalabel_got.refcount += 1;
		}
	      else
#endif
		h->got.refcount += 1;
	      old_got_type = sh_elf_hash_entry (h)->got_type;
	    }
	  else
	    {
	      bfd_signed_vma *local_got_refcounts;

	      /* This is a global offset table entry for a local
		 symbol.  */
	      local_got_refcounts = elf_local_got_refcounts (abfd);
	      if (local_got_refcounts == NULL)
		{
		  bfd_size_type size;

		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_signed_vma);
#ifdef INCLUDE_SHMEDIA
		  /* Reserve space for both the datalabel and
		     codelabel local GOT offsets.  */
		  size *= 2;
#endif
		  size += symtab_hdr->sh_info;
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
#ifdef 	INCLUDE_SHMEDIA
		  /* Take care of both the datalabel and codelabel local
		     GOT offsets.  */
		  sh_elf_local_got_type (abfd)
		    = (char *) (local_got_refcounts + 2 * symtab_hdr->sh_info);
#else
		  sh_elf_local_got_type (abfd)
		    = (char *) (local_got_refcounts + symtab_hdr->sh_info);
#endif
		}
#ifdef INCLUDE_SHMEDIA
	      if (rel->r_addend & 1)
		local_got_refcounts[symtab_hdr->sh_info + r_symndx] += 1;
	      else
#endif
		local_got_refcounts[r_symndx] += 1;
	      old_got_type = sh_elf_local_got_type (abfd) [r_symndx];
	    }

	  /* If a TLS symbol is accessed using IE at least once,
	     there is no point to use dynamic model for it.  */
	  if (old_got_type != got_type && old_got_type != GOT_UNKNOWN
	      && (old_got_type != GOT_TLS_GD || got_type != GOT_TLS_IE))
	    {
	      if (old_got_type == GOT_TLS_IE && got_type == GOT_TLS_GD)
		got_type = GOT_TLS_IE;
	      else
		{
		  if ((old_got_type == GOT_FUNCDESC || got_type == GOT_FUNCDESC)
		      && (old_got_type == GOT_NORMAL || got_type == GOT_NORMAL))
		    (*_bfd_error_handler)
		      (_("%B: `%s' accessed both as normal and FDPIC symbol"),
		       abfd, h->root.root.string);
		  else if (old_got_type == GOT_FUNCDESC
			   || got_type == GOT_FUNCDESC)
		    (*_bfd_error_handler)
		      (_("%B: `%s' accessed both as FDPIC and thread local symbol"),
		       abfd, h->root.root.string);
		  else
		    (*_bfd_error_handler)
		    (_("%B: `%s' accessed both as normal and thread local symbol"),
		     abfd, h->root.root.string);
		  return FALSE;
		}
	    }

	  if (old_got_type != got_type)
	    {
	      if (h != NULL)
		sh_elf_hash_entry (h)->got_type = got_type;
	      else
		sh_elf_local_got_type (abfd) [r_symndx] = got_type;
	    }

	  break;

	case R_SH_TLS_LD_32:
	  sh_elf_hash_table(info)->tls_ldm_got.refcount += 1;
	  break;

	case R_SH_FUNCDESC:
	case R_SH_GOTOFFFUNCDESC:
	case R_SH_GOTOFFFUNCDESC20:
	  if (rel->r_addend)
	    {
	      (*_bfd_error_handler)
		(_("%B: Function descriptor relocation with non-zero addend"),
		 abfd);
	      return FALSE;
	    }

	  if (h == NULL)
	    {
	      union gotref *local_funcdesc;

	      /* We need a function descriptor for a local symbol.  */
	      local_funcdesc = sh_elf_local_funcdesc (abfd);
	      if (local_funcdesc == NULL)
		{
		  bfd_size_type size;

		  size = symtab_hdr->sh_info * sizeof (union gotref);
#ifdef INCLUDE_SHMEDIA
		  /* Count datalabel local GOT.  */
		  size *= 2;
#endif
		  local_funcdesc = (union gotref *) bfd_zalloc (abfd, size);
		  if (local_funcdesc == NULL)
		    return FALSE;
		  sh_elf_local_funcdesc (abfd) = local_funcdesc;
		}
	      local_funcdesc[r_symndx].refcount += 1;

	      if (r_type == R_SH_FUNCDESC)
		{
		  if (!info->shared)
		    htab->srofixup->size += 4;
		  else
		    htab->srelgot->size += sizeof (Elf32_External_Rela);
		}
	    }
	  else
	    {
	      sh_elf_hash_entry (h)->funcdesc.refcount++;
	      if (r_type == R_SH_FUNCDESC)
		sh_elf_hash_entry (h)->abs_funcdesc_refcount++;

	      /* If there is a function descriptor reference, then
		 there should not be any non-FDPIC references.  */
	      old_got_type = sh_elf_hash_entry (h)->got_type;
	      if (old_got_type != GOT_FUNCDESC && old_got_type != GOT_UNKNOWN)
		{
		  if (old_got_type == GOT_NORMAL)
		    (*_bfd_error_handler)
		      (_("%B: `%s' accessed both as normal and FDPIC symbol"),
		       abfd, h->root.root.string);
		  else
		    (*_bfd_error_handler)
		      (_("%B: `%s' accessed both as FDPIC and thread local symbol"),
		       abfd, h->root.root.string);
		}
	    }
	  break;

	case R_SH_GOTPLT32:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOTPLT_LOW16:
	case R_SH_GOTPLT_MEDLOW16:
	case R_SH_GOTPLT_MEDHI16:
	case R_SH_GOTPLT_HI16:
	case R_SH_GOTPLT10BY4:
	case R_SH_GOTPLT10BY8:
#endif
	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.  */

	  if (h == NULL
	      || h->forced_local
	      || ! info->shared
	      || info->symbolic
	      || h->dynindx == -1)
	    goto force_got;

	  h->needs_plt = 1;
	  h->plt.refcount += 1;
	  ((struct elf_sh_link_hash_entry *) h)->gotplt_refcount += 1;

	  break;

	case R_SH_PLT32:
#ifdef INCLUDE_SHMEDIA
	case R_SH_PLT_LOW16:
	case R_SH_PLT_MEDLOW16:
	case R_SH_PLT_MEDHI16:
	case R_SH_PLT_HI16:
#endif
	  /* This symbol requires a procedure linkage table entry.  We
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code which is
	     never referenced by a dynamic object, in which case we
	     don't need to generate a procedure linkage table entry
	     after all.  */

	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.  */
	  if (h == NULL)
	    continue;

	  if (h->forced_local)
	    break;

	  h->needs_plt = 1;
	  h->plt.refcount += 1;
	  break;

	case R_SH_DIR32:
	case R_SH_REL32:
#ifdef INCLUDE_SHMEDIA
	case R_SH_IMM_LOW16_PCREL:
	case R_SH_IMM_MEDLOW16_PCREL:
	case R_SH_IMM_MEDHI16_PCREL:
	case R_SH_IMM_HI16_PCREL:
#endif
	  if (h != NULL && ! info->shared)
	    {
	      h->non_got_ref = 1;
	      h->plt.refcount += 1;
	    }

	  /* If we are creating a shared library, and this is a reloc
	     against a global symbol, or a non PC relative reloc
	     against a local symbol, then we need to copy the reloc
	     into the shared library.  However, if we are linking with
	     -Bsymbolic, we do not need to copy a reloc against a
	     global symbol which is defined in an object we are
	     including in the link (i.e., DEF_REGULAR is set).  At
	     this point we have not seen all the input files, so it is
	     possible that DEF_REGULAR is not set now but will be set
	     later (it is never cleared).  We account for that
	     possibility below by storing information in the
	     dyn_relocs field of the hash table entry. A similar
	     situation occurs when creating shared libraries and symbol
	     visibility changes render the symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (sec->flags & SEC_ALLOC) != 0
	       && (r_type != R_SH_REL32
		   || (h != NULL
		       && (! info->symbolic
			   || h->root.type == bfd_link_hash_defweak
			   || !h->def_regular))))
	      || (! info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || !h->def_regular)))
	    {
	      struct elf_sh_dyn_relocs *p;
	      struct elf_sh_dyn_relocs **head;

	      if (htab->root.dynobj == NULL)
		htab->root.dynobj = abfd;

	      /* When creating a shared object, we must copy these
		 reloc types into the output file.  We create a reloc
		 section in dynobj and make room for this reloc.  */
	      if (sreloc == NULL)
		{
		  sreloc = _bfd_elf_make_dynamic_reloc_section
		    (sec, htab->root.dynobj, 2, abfd, /*rela?*/ TRUE);

		  if (sreloc == NULL)
		    return FALSE;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		head = &((struct elf_sh_link_hash_entry *) h)->dyn_relocs;
	      else
		{
		  /* Track dynamic relocs needed for local syms too.  */
		  asection *s;
		  void *vpp;
		  Elf_Internal_Sym *isym;

		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
						abfd, r_symndx);
		  if (isym == NULL)
		    return FALSE;

		  s = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  if (s == NULL)
		    s = sec;

		  vpp = &elf_section_data (s)->local_dynrel;
		  head = (struct elf_sh_dyn_relocs **) vpp;
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof (*p);
		  p = bfd_alloc (htab->root.dynobj, amt);
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		}

	      p->count += 1;
	      if (r_type == R_SH_REL32
#ifdef INCLUDE_SHMEDIA
		  || r_type == R_SH_IMM_LOW16_PCREL
		  || r_type == R_SH_IMM_MEDLOW16_PCREL
		  || r_type == R_SH_IMM_MEDHI16_PCREL
		  || r_type == R_SH_IMM_HI16_PCREL
#endif
		  )
		p->pc_count += 1;
	    }

	  /* Allocate the fixup regardless of whether we need a relocation.
	     If we end up generating the relocation, we'll unallocate the
	     fixup.  */
	  if (htab->fdpic_p && !info->shared
	      && r_type == R_SH_DIR32
	      && (sec->flags & SEC_ALLOC) != 0)
	    htab->srofixup->size += 4;
	  break;

	case R_SH_TLS_LE_32:
	  if (info->shared && !info->pie)
	    {
	      (*_bfd_error_handler)
		(_("%B: TLS local exec code cannot be linked into shared objects"),
		 abfd);
	      return FALSE;
	    }

	  break;

	case R_SH_TLS_LDO_32:
	  /* Nothing to do.  */
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

#ifndef sh_elf_set_mach_from_flags
static unsigned int sh_ef_bfd_table[] = { EF_SH_BFD_TABLE };

static bfd_boolean
sh_elf_set_mach_from_flags (bfd *abfd)
{
  flagword flags = elf_elfheader (abfd)->e_flags & EF_SH_MACH_MASK;

  if (flags >= sizeof(sh_ef_bfd_table))
    return FALSE;

  if (sh_ef_bfd_table[flags] == 0)
    return FALSE;

  bfd_default_set_arch_mach (abfd, bfd_arch_sh, sh_ef_bfd_table[flags]);

  return TRUE;
}


/* Reverse table lookup for sh_ef_bfd_table[].
   Given a bfd MACH value from archures.c
   return the equivalent ELF flags from the table.
   Return -1 if no match is found.  */

int
sh_elf_get_flags_from_mach (unsigned long mach)
{
  int i = ARRAY_SIZE (sh_ef_bfd_table) - 1;

  for (; i>0; i--)
    if (sh_ef_bfd_table[i] == mach)
      return i;

  /* shouldn't get here */
  BFD_FAIL();

  return -1;
}
#endif /* not sh_elf_set_mach_from_flags */

#ifndef sh_elf_set_private_flags
/* Function to keep SH specific file flags.  */

static bfd_boolean
sh_elf_set_private_flags (bfd *abfd, flagword flags)
{
  BFD_ASSERT (! elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return sh_elf_set_mach_from_flags (abfd);
}
#endif /* not sh_elf_set_private_flags */

#ifndef sh_elf_copy_private_data
/* Copy backend specific data from one object module to another */

static bfd_boolean
sh_elf_copy_private_data (bfd * ibfd, bfd * obfd)
{
  /* Copy object attributes.  */
  _bfd_elf_copy_obj_attributes (ibfd, obfd);

  if (! is_sh_elf (ibfd) || ! is_sh_elf (obfd))
    return TRUE;

  return sh_elf_set_private_flags (obfd, elf_elfheader (ibfd)->e_flags);
}
#endif /* not sh_elf_copy_private_data */

#ifndef sh_elf_merge_private_data

/* This function returns the ELF architecture number that
   corresponds to the given arch_sh* flags.  */

int
sh_find_elf_flags (unsigned int arch_set)
{
  extern unsigned long sh_get_bfd_mach_from_arch_set (unsigned int);
  unsigned long bfd_mach = sh_get_bfd_mach_from_arch_set (arch_set);

  return sh_elf_get_flags_from_mach (bfd_mach);
}

/* This routine initialises the elf flags when required and
   calls sh_merge_bfd_arch() to check dsp/fpu compatibility.  */

static bfd_boolean
sh_elf_merge_private_data (bfd *ibfd, bfd *obfd)
{
  extern bfd_boolean sh_merge_bfd_arch (bfd *, bfd *);

  if (! is_sh_elf (ibfd) || ! is_sh_elf (obfd))
    return TRUE;

  if (! elf_flags_init (obfd))
    {
      /* This happens when ld starts out with a 'blank' output file.  */
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
      sh_elf_set_mach_from_flags (obfd);
      if (elf_elfheader (obfd)->e_flags & EF_SH_FDPIC)
	elf_elfheader (obfd)->e_flags |= EF_SH_PIC;
    }

  if (! sh_merge_bfd_arch (ibfd, obfd))
    {
      _bfd_error_handler ("%B: uses instructions which are incompatible "
			  "with instructions used in previous modules",
			  ibfd);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  elf_elfheader (obfd)->e_flags &= ~EF_SH_MACH_MASK;
  elf_elfheader (obfd)->e_flags |=
    sh_elf_get_flags_from_mach (bfd_get_mach (obfd));

  if (fdpic_object_p (ibfd) != fdpic_object_p (obfd))
    {
      _bfd_error_handler ("%B: attempt to mix FDPIC and non-FDPIC objects",
			  ibfd);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  return TRUE;
}
#endif /* not sh_elf_merge_private_data */

/* Override the generic function because we need to store sh_elf_obj_tdata
   as the specific tdata.  We set also the machine architecture from flags
   here.  */

static bfd_boolean
sh_elf_object_p (bfd *abfd)
{
  if (! sh_elf_set_mach_from_flags (abfd))
    return FALSE;

  return (((elf_elfheader (abfd)->e_flags & EF_SH_FDPIC) != 0)
	  == fdpic_object_p (abfd));
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
sh_elf_finish_dynamic_symbol (bfd *output_bfd, struct bfd_link_info *info,
			      struct elf_link_hash_entry *h,
			      Elf_Internal_Sym *sym)
{
  struct elf_sh_link_hash_table *htab;

  htab = sh_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection *splt;
      asection *sgotplt;
      asection *srelplt;

      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rel;
      bfd_byte *loc;
      const struct elf_sh_plt_info *plt_info;

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */

      BFD_ASSERT (h->dynindx != -1);

      splt = htab->splt;
      sgotplt = htab->sgotplt;
      srelplt = htab->srelplt;
      BFD_ASSERT (splt != NULL && sgotplt != NULL && srelplt != NULL);

      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first entry in the procedure linkage table is reserved.  */
      plt_index = get_plt_index (htab->plt_info, h->plt.offset);

      plt_info = htab->plt_info;
      if (plt_info->short_plt != NULL && plt_index <= MAX_SHORT_PLT)
	plt_info = plt_info->short_plt;

      /* Get the offset into the .got table of the entry that
	 corresponds to this function.  */
      if (htab->fdpic_p)
	/* The offset must be relative to the GOT symbol, twelve bytes
	   before the end of .got.plt.  Each descriptor is eight
	   bytes.  */
	got_offset = plt_index * 8 + 12 - sgotplt->size;
      else
	/* Each .got entry is 4 bytes.  The first three are
	   reserved.  */
	got_offset = (plt_index + 3) * 4;

#ifdef GOT_BIAS
      if (info->shared)
	got_offset -= GOT_BIAS;
#endif

      /* Fill in the entry in the procedure linkage table.  */
      memcpy (splt->contents + h->plt.offset,
	      plt_info->symbol_entry,
	      plt_info->symbol_entry_size);

      if (info->shared || htab->fdpic_p)
	{
	  if (plt_info->symbol_fields.got20)
	    {
	      bfd_reloc_status_type r;
	      r = install_movi20_field (output_bfd, got_offset,
					splt->owner, splt, splt->contents,
					h->plt.offset
					+ plt_info->symbol_fields.got_entry);
	      BFD_ASSERT (r == bfd_reloc_ok);
	    }
	  else
	    install_plt_field (output_bfd, FALSE, got_offset,
			       (splt->contents
				+ h->plt.offset
				+ plt_info->symbol_fields.got_entry));
	}
      else
	{
	  BFD_ASSERT (!plt_info->symbol_fields.got20);

	  install_plt_field (output_bfd, FALSE,
			     (sgotplt->output_section->vma
			      + sgotplt->output_offset
			      + got_offset),
			     (splt->contents
			      + h->plt.offset
			      + plt_info->symbol_fields.got_entry));
	  if (htab->vxworks_p)
	    {
	      unsigned int reachable_plts, plts_per_4k;
	      int distance;

	      /* Divide the PLT into groups.  The first group contains
		 REACHABLE_PLTS entries and the other groups contain
		 PLTS_PER_4K entries.  Entries in the first group can
		 branch directly to .plt; those in later groups branch
		 to the last element of the previous group.  */
	      /* ??? It would be better to create multiple copies of
		 the common resolver stub.  */
	      reachable_plts = ((4096
				 - plt_info->plt0_entry_size
				 - (plt_info->symbol_fields.plt + 4))
				/ plt_info->symbol_entry_size) + 1;
	      plts_per_4k = (4096 / plt_info->symbol_entry_size);
	      if (plt_index < reachable_plts)
		distance = -(h->plt.offset
			     + plt_info->symbol_fields.plt);
	      else
		distance = -(((plt_index - reachable_plts) % plts_per_4k + 1)
			     * plt_info->symbol_entry_size);

	      /* Install the 'bra' with this offset.  */
	      bfd_put_16 (output_bfd,
			  0xa000 | (0x0fff & ((distance - 4) / 2)),
			  (splt->contents
			   + h->plt.offset
			   + plt_info->symbol_fields.plt));
	    }
	  else
	    install_plt_field (output_bfd, TRUE,
			       splt->output_section->vma + splt->output_offset,
			       (splt->contents
				+ h->plt.offset
				+ plt_info->symbol_fields.plt));
	}

      /* Make got_offset relative to the start of .got.plt.  */
#ifdef GOT_BIAS
      if (info->shared)
	got_offset += GOT_BIAS;
#endif
      if (htab->fdpic_p)
	got_offset = plt_index * 8;

      if (plt_info->symbol_fields.reloc_offset != MINUS_ONE)
	install_plt_field (output_bfd, FALSE,
			   plt_index * sizeof (Elf32_External_Rela),
			   (splt->contents
			    + h->plt.offset
			    + plt_info->symbol_fields.reloc_offset));

      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd,
		  (splt->output_section->vma
		   + splt->output_offset
		   + h->plt.offset
		   + plt_info->symbol_resolve_offset),
		  sgotplt->contents + got_offset);
      if (htab->fdpic_p)
	bfd_put_32 (output_bfd,
		    sh_elf_osec_to_segment (output_bfd,
					    htab->splt->output_section),
		    sgotplt->contents + got_offset + 4);

      /* Fill in the entry in the .rela.plt section.  */
      rel.r_offset = (sgotplt->output_section->vma
		      + sgotplt->output_offset
		      + got_offset);
      if (htab->fdpic_p)
	rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_FUNCDESC_VALUE);
      else
	rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_JMP_SLOT);
      rel.r_addend = 0;
#ifdef GOT_BIAS
      rel.r_addend = GOT_BIAS;
#endif
      loc = srelplt->contents + plt_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);

      if (htab->vxworks_p && !info->shared)
	{
	  /* Create the .rela.plt.unloaded relocations for this PLT entry.
	     Begin by pointing LOC to the first such relocation.  */
	  loc = (htab->srelplt2->contents
		 + (plt_index * 2 + 1) * sizeof (Elf32_External_Rela));

	  /* Create a .rela.plt.unloaded R_SH_DIR32 relocation
	     for the PLT entry's pointer to the .got.plt entry.  */
	  rel.r_offset = (htab->splt->output_section->vma
			  + htab->splt->output_offset
			  + h->plt.offset
			  + plt_info->symbol_fields.got_entry);
	  rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_SH_DIR32);
	  rel.r_addend = got_offset;
	  bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
	  loc += sizeof (Elf32_External_Rela);

	  /* Create a .rela.plt.unloaded R_SH_DIR32 relocation for
	     the .got.plt entry, which initially points to .plt.  */
	  rel.r_offset = (sgotplt->output_section->vma
			  + sgotplt->output_offset
			  + got_offset);
	  rel.r_info = ELF32_R_INFO (htab->root.hplt->indx, R_SH_DIR32);
	  rel.r_addend = 0;
	  bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
	}

      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}
    }

  if (h->got.offset != (bfd_vma) -1
      && sh_elf_hash_entry (h)->got_type != GOT_TLS_GD
      && sh_elf_hash_entry (h)->got_type != GOT_TLS_IE
      && sh_elf_hash_entry (h)->got_type != GOT_FUNCDESC)
    {
      asection *sgot;
      asection *srelgot;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */

      sgot = htab->sgot;
      srelgot = htab->srelgot;
      BFD_ASSERT (sgot != NULL && srelgot != NULL);

      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + (h->got.offset &~ (bfd_vma) 1));

      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (info->shared
	  && SYMBOL_REFERENCES_LOCAL (info, h))
	{
	  if (htab->fdpic_p)
	    {
	      asection *sec = h->root.u.def.section;
	      int dynindx
		= elf_section_data (sec->output_section)->dynindx;

	      rel.r_info = ELF32_R_INFO (dynindx, R_SH_DIR32);
	      rel.r_addend = (h->root.u.def.value
			      + h->root.u.def.section->output_offset);
	    }
	  else
	    {
	      rel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
	      rel.r_addend = (h->root.u.def.value
			      + h->root.u.def.section->output_section->vma
			      + h->root.u.def.section->output_offset);
	    }
	}
      else
	{
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_GLOB_DAT);
	  rel.r_addend = 0;
	}

      loc = srelgot->contents;
      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
    }

#ifdef INCLUDE_SHMEDIA
  {
    struct elf_sh_link_hash_entry *eh;

    eh = (struct elf_sh_link_hash_entry *) h;
    if (eh->datalabel_got.offset != (bfd_vma) -1)
      {
	asection *sgot;
	asection *srelgot;
	Elf_Internal_Rela rel;
	bfd_byte *loc;

	/* This symbol has a datalabel entry in the global offset table.
	   Set it up.  */

	sgot = htab->sgot;
	srelgot = htab->srelgot;
	BFD_ASSERT (sgot != NULL && srelgot != NULL);

	rel.r_offset = (sgot->output_section->vma
			+ sgot->output_offset
			+ (eh->datalabel_got.offset &~ (bfd_vma) 1));

	/* If this is a static link, or it is a -Bsymbolic link and the
	   symbol is defined locally or was forced to be local because
	   of a version file, we just want to emit a RELATIVE reloc.
	   The entry in the global offset table will already have been
	   initialized in the relocate_section function.  */
	if (info->shared
	    && SYMBOL_REFERENCES_LOCAL (info, h))
	  {
	    if (htab->fdpic_p)
	      {
		asection *sec = h->root.u.def.section;
		int dynindx
		  = elf_section_data (sec->output_section)->dynindx;

		rel.r_info = ELF32_R_INFO (dynindx, R_SH_DIR32);
		rel.r_addend = (h->root.u.def.value
				+ h->root.u.def.section->output_offset);
	      }
	    else
	      {
		rel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
		rel.r_addend = (h->root.u.def.value
				+ h->root.u.def.section->output_section->vma
				+ h->root.u.def.section->output_offset);
	      }
	  }
	else
	  {
	    bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents
			+ eh->datalabel_got.offset);
	    rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_GLOB_DAT);
	    rel.r_addend = 0;
	  }

	loc = srelgot->contents;
	loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
	bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
      }
  }
#endif

  if (h->needs_copy)
    {
      asection *s;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol needs a copy reloc.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));

      s = bfd_get_linker_section (htab->root.dynobj, ".rela.bss");
      BFD_ASSERT (s != NULL);

      rel.r_offset = (h->root.u.def.value
		      + h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset);
      rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_COPY);
      rel.r_addend = 0;
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  On VxWorks,
     _GLOBAL_OFFSET_TABLE_ is not absolute: it is relative to the
     ".got" section.  */
  if (h == htab->root.hdynamic
      || (!htab->vxworks_p && h == htab->root.hgot))
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

/* Finish up the dynamic sections.  */

static bfd_boolean
sh_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_sh_link_hash_table *htab;
  asection *sgotplt;
  asection *sdyn;

  htab = sh_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  sgotplt = htab->sgotplt;
  sdyn = bfd_get_linker_section (htab->root.dynobj, ".dynamic");

  if (htab->root.dynamic_sections_created)
    {
      asection *splt;
      Elf32_External_Dyn *dyncon, *dynconend;

      BFD_ASSERT (sgotplt != NULL && sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;
#ifdef INCLUDE_SHMEDIA
	  const char *name;
#endif

	  bfd_elf32_swap_dyn_in (htab->root.dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      if (htab->vxworks_p
		  && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))
		bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

#ifdef INCLUDE_SHMEDIA
	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;

	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      if (dyn.d_un.d_val != 0)
		{
		  struct elf_link_hash_entry *h;

		  h = elf_link_hash_lookup (&htab->root, name,
					    FALSE, FALSE, TRUE);
		  if (h != NULL && (h->other & STO_SH5_ISA32))
		    {
		      dyn.d_un.d_val |= 1;
		      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		    }
		}
	      break;
#endif

	    case DT_PLTGOT:
	      BFD_ASSERT (htab->root.hgot != NULL);
	      s = htab->root.hgot->root.u.def.section;
	      dyn.d_un.d_ptr = htab->root.hgot->root.u.def.value
		+ s->output_section->vma + s->output_offset;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_JMPREL:
	      s = htab->srelplt->output_section;
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      s = htab->srelplt->output_section;
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_RELASZ:
	      /* My reading of the SVR4 ABI indicates that the
		 procedure linkage table relocs (DT_JMPREL) should be
		 included in the overall relocs (DT_RELA).  This is
		 what Solaris does.  However, UnixWare can not handle
		 that case.  Therefore, we override the DT_RELASZ entry
		 here to make it not include the JMPREL relocs.  Since
		 the linker script arranges for .rela.plt to follow all
		 other relocation sections, we don't have to worry
		 about changing the DT_RELA entry.  */
	      if (htab->srelplt != NULL)
		{
		  s = htab->srelplt->output_section;
		  dyn.d_un.d_val -= s->size;
		}
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	    }
	}

      /* Fill in the first entry in the procedure linkage table.  */
      splt = htab->splt;
      if (splt && splt->size > 0 && htab->plt_info->plt0_entry)
	{
	  unsigned int i;

	  memcpy (splt->contents,
		  htab->plt_info->plt0_entry,
		  htab->plt_info->plt0_entry_size);
	  for (i = 0; i < ARRAY_SIZE (htab->plt_info->plt0_got_fields); i++)
	    if (htab->plt_info->plt0_got_fields[i] != MINUS_ONE)
	      install_plt_field (output_bfd, FALSE,
				 (sgotplt->output_section->vma
				  + sgotplt->output_offset
				  + (i * 4)),
				 (splt->contents
				  + htab->plt_info->plt0_got_fields[i]));

	  if (htab->vxworks_p)
	    {
	      /* Finalize the .rela.plt.unloaded contents.  */
	      Elf_Internal_Rela rel;
	      bfd_byte *loc;

	      /* Create a .rela.plt.unloaded R_SH_DIR32 relocation for the
		 first PLT entry's pointer to _GLOBAL_OFFSET_TABLE_ + 8.  */
	      loc = htab->srelplt2->contents;
	      rel.r_offset = (splt->output_section->vma
			      + splt->output_offset
			      + htab->plt_info->plt0_got_fields[2]);
	      rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_SH_DIR32);
	      rel.r_addend = 8;
	      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
	      loc += sizeof (Elf32_External_Rela);

	      /* Fix up the remaining .rela.plt.unloaded relocations.
		 They may have the wrong symbol index for _G_O_T_ or
		 _P_L_T_ depending on the order in which symbols were
		 output.  */
	      while (loc < htab->srelplt2->contents + htab->srelplt2->size)
		{
		  /* The PLT entry's pointer to the .got.plt slot.  */
		  bfd_elf32_swap_reloc_in (output_bfd, loc, &rel);
		  rel.r_info = ELF32_R_INFO (htab->root.hgot->indx,
					     R_SH_DIR32);
		  bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
		  loc += sizeof (Elf32_External_Rela);

		  /* The .got.plt slot's pointer to .plt.  */
		  bfd_elf32_swap_reloc_in (output_bfd, loc, &rel);
		  rel.r_info = ELF32_R_INFO (htab->root.hplt->indx,
					     R_SH_DIR32);
		  bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
		  loc += sizeof (Elf32_External_Rela);
		}
	    }

	  /* UnixWare sets the entsize of .plt to 4, although that doesn't
	     really seem like the right value.  */
	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;
	}
    }

  /* Fill in the first three entries in the global offset table.  */
  if (sgotplt && sgotplt->size > 0 && !htab->fdpic_p)
    {
      if (sdyn == NULL)
	bfd_put_32 (output_bfd, (bfd_vma) 0, sgotplt->contents);
      else
	bfd_put_32 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgotplt->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgotplt->contents + 4);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgotplt->contents + 8);
    }

  if (sgotplt && sgotplt->size > 0)
    elf_section_data (sgotplt->output_section)->this_hdr.sh_entsize = 4;

  /* At the very end of the .rofixup section is a pointer to the GOT.  */
  if (htab->fdpic_p && htab->srofixup != NULL)
    {
      struct elf_link_hash_entry *hgot = htab->root.hgot;
      bfd_vma got_value = hgot->root.u.def.value
	+ hgot->root.u.def.section->output_section->vma
	+ hgot->root.u.def.section->output_offset;

      sh_elf_add_rofixup (output_bfd, htab->srofixup, got_value);

      /* Make sure we allocated and generated the same number of fixups.  */
      BFD_ASSERT (htab->srofixup->reloc_count * 4 == htab->srofixup->size);
    }

  if (htab->srelfuncdesc)
    BFD_ASSERT (htab->srelfuncdesc->reloc_count * sizeof (Elf32_External_Rela)
		== htab->srelfuncdesc->size);

  if (htab->srelgot)
    BFD_ASSERT (htab->srelgot->reloc_count * sizeof (Elf32_External_Rela)
		== htab->srelgot->size);

  return TRUE;
}

static enum elf_reloc_type_class
sh_elf_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 const asection *rel_sec ATTRIBUTE_UNUSED,
			 const Elf_Internal_Rela *rela)
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_SH_RELATIVE:
      return reloc_class_relative;
    case R_SH_JMP_SLOT:
      return reloc_class_plt;
    case R_SH_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

#if !defined SH_TARGET_ALREADY_DEFINED
/* Support for Linux core dump NOTE sections.  */

static bfd_boolean
elf32_shlin_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  unsigned int size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 168:		/* Linux/SH */
	/* pr_cursig */
	elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	size = 92;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
elf32_shlin_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      case 124:		/* Linux/SH elf_prpsinfo */
	elf_tdata (abfd)->core->program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
	elf_tdata (abfd)->core->command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}
#endif /* not SH_TARGET_ALREADY_DEFINED */


/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
sh_elf_plt_sym_val (bfd_vma i, const asection *plt,
		    const arelent *rel ATTRIBUTE_UNUSED)
{
  const struct elf_sh_plt_info *plt_info;

  plt_info = get_plt_info (plt->owner, (plt->owner->flags & DYNAMIC) != 0);
  return plt->vma + get_plt_offset (plt_info, i);
}

/* Decide whether to attempt to turn absptr or lsda encodings in
   shared libraries into pcrel within the given input section.  */

static bfd_boolean
sh_elf_use_relative_eh_frame (bfd *input_bfd ATTRIBUTE_UNUSED,
			      struct bfd_link_info *info,
			      asection *eh_frame_section ATTRIBUTE_UNUSED)
{
  struct elf_sh_link_hash_table *htab = sh_elf_hash_table (info);

  /* We can't use PC-relative encodings in FDPIC binaries, in general.  */
  if (htab->fdpic_p)
    return FALSE;

  return TRUE;
}

/* Adjust the contents of an eh_frame_hdr section before they're output.  */

static bfd_byte
sh_elf_encode_eh_address (bfd *abfd,
			  struct bfd_link_info *info,
			  asection *osec, bfd_vma offset,
			  asection *loc_sec, bfd_vma loc_offset,
			  bfd_vma *encoded)
{
  struct elf_sh_link_hash_table *htab = sh_elf_hash_table (info);
  struct elf_link_hash_entry *h;

  if (!htab->fdpic_p)
    return _bfd_elf_encode_eh_address (abfd, info, osec, offset, loc_sec,
				       loc_offset, encoded);

  h = htab->root.hgot;
  BFD_ASSERT (h && h->root.type == bfd_link_hash_defined);

  if (! h || (sh_elf_osec_to_segment (abfd, osec)
	      == sh_elf_osec_to_segment (abfd, loc_sec->output_section)))
    return _bfd_elf_encode_eh_address (abfd, info, osec, offset,
				       loc_sec, loc_offset, encoded);

  BFD_ASSERT (sh_elf_osec_to_segment (abfd, osec)
	      == (sh_elf_osec_to_segment
		  (abfd, h->root.u.def.section->output_section)));

  *encoded = osec->vma + offset
    - (h->root.u.def.value
       + h->root.u.def.section->output_section->vma
       + h->root.u.def.section->output_offset);

  return DW_EH_PE_datarel | DW_EH_PE_sdata4;
}

#if !defined SH_TARGET_ALREADY_DEFINED
#define TARGET_BIG_SYM		bfd_elf32_sh_vec
#define TARGET_BIG_NAME		"elf32-sh"
#define TARGET_LITTLE_SYM	bfd_elf32_shl_vec
#define TARGET_LITTLE_NAME	"elf32-shl"
#endif

#define ELF_ARCH		bfd_arch_sh
#define ELF_TARGET_ID		SH_ELF_DATA
#define ELF_MACHINE_CODE	EM_SH
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE		0x1000
#else
#define ELF_MAXPAGESIZE		0x80
#endif

#define elf_symbol_leading_char '_'

#define bfd_elf32_bfd_reloc_type_lookup	sh_elf_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup \
					sh_elf_reloc_name_lookup
#define elf_info_to_howto		sh_elf_info_to_howto
#define bfd_elf32_bfd_relax_section	sh_elf_relax_section
#define elf_backend_relocate_section	sh_elf_relocate_section
#define bfd_elf32_bfd_get_relocated_section_contents \
					sh_elf_get_relocated_section_contents
#define bfd_elf32_mkobject		sh_elf_mkobject
#define elf_backend_object_p		sh_elf_object_p
#define bfd_elf32_bfd_set_private_bfd_flags \
					sh_elf_set_private_flags
#define bfd_elf32_bfd_copy_private_bfd_data \
					sh_elf_copy_private_data
#define bfd_elf32_bfd_merge_private_bfd_data \
					sh_elf_merge_private_data

#define elf_backend_gc_mark_hook	sh_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	sh_elf_gc_sweep_hook
#define elf_backend_check_relocs	sh_elf_check_relocs
#define elf_backend_copy_indirect_symbol \
					sh_elf_copy_indirect_symbol
#define elf_backend_create_dynamic_sections \
					sh_elf_create_dynamic_sections
#define bfd_elf32_bfd_link_hash_table_create \
					sh_elf_link_hash_table_create
#define elf_backend_adjust_dynamic_symbol \
					sh_elf_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
					sh_elf_always_size_sections
#define elf_backend_size_dynamic_sections \
					sh_elf_size_dynamic_sections
#define elf_backend_omit_section_dynsym	sh_elf_omit_section_dynsym
#define elf_backend_finish_dynamic_symbol \
					sh_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					sh_elf_finish_dynamic_sections
#define elf_backend_reloc_type_class	sh_elf_reloc_type_class
#define elf_backend_plt_sym_val		sh_elf_plt_sym_val
#define elf_backend_can_make_relative_eh_frame \
					sh_elf_use_relative_eh_frame
#define elf_backend_can_make_lsda_relative_eh_frame \
					sh_elf_use_relative_eh_frame
#define elf_backend_encode_eh_address \
					sh_elf_encode_eh_address

#define elf_backend_stack_align		8
#define elf_backend_can_gc_sections	1
#define elf_backend_can_refcount	1
#define elf_backend_want_got_plt	1
#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_got_header_size	12

#if !defined INCLUDE_SHMEDIA && !defined SH_TARGET_ALREADY_DEFINED

#include "elf32-target.h"

/* NetBSD support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shnbsd_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-sh-nbsd"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf32_shlnbsd_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-shl-nbsd"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x10000
#undef	ELF_COMMONPAGESIZE
#undef	elf_symbol_leading_char
#define	elf_symbol_leading_char		0
#undef	elf32_bed
#define	elf32_bed			elf32_sh_nbsd_bed

#include "elf32-target.h"


/* Linux support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shblin_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-shbig-linux"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf32_shlin_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-sh-linux"
#undef	ELF_COMMONPAGESIZE
#define	ELF_COMMONPAGESIZE		0x1000

#undef	elf_backend_grok_prstatus
#define	elf_backend_grok_prstatus	elf32_shlin_grok_prstatus
#undef	elf_backend_grok_psinfo
#define	elf_backend_grok_psinfo		elf32_shlin_grok_psinfo
#undef	elf32_bed
#define	elf32_bed			elf32_sh_lin_bed

#include "elf32-target.h"


/* FDPIC support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shbfd_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-shbig-fdpic"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf32_shfd_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-sh-fdpic"

#undef	elf32_bed
#define	elf32_bed			elf32_sh_fd_bed

#include "elf32-target.h"

#undef elf_backend_modify_program_headers

/* VxWorks support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shvxworks_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-sh-vxworks"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf32_shlvxworks_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-shl-vxworks"
#undef	elf32_bed
#define	elf32_bed			elf32_sh_vxworks_bed

#undef	elf_backend_want_plt_sym
#define	elf_backend_want_plt_sym	1
#undef	elf_symbol_leading_char
#define	elf_symbol_leading_char		'_'
#define	elf_backend_want_got_underscore 1
#undef	elf_backend_grok_prstatus
#undef	elf_backend_grok_psinfo
#undef	elf_backend_add_symbol_hook
#define	elf_backend_add_symbol_hook	elf_vxworks_add_symbol_hook
#undef	elf_backend_link_output_symbol_hook
#define	elf_backend_link_output_symbol_hook \
					elf_vxworks_link_output_symbol_hook
#undef	elf_backend_emit_relocs
#define	elf_backend_emit_relocs		elf_vxworks_emit_relocs
#undef	elf_backend_final_write_processing
#define	elf_backend_final_write_processing \
					elf_vxworks_final_write_processing
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x1000
#undef	ELF_COMMONPAGESIZE

#include "elf32-target.h"

#endif /* neither INCLUDE_SHMEDIA nor SH_TARGET_ALREADY_DEFINED */
@


1.188
log
@	* elf32-sh.c (sh_elf_relocate_section): Suppress warnings for
	R_SH_REL32 relocations against undefined weak symbols.
@
text
@d6034 4
@


1.187
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009, 2010, 2011, 2012
d4428 6
@


1.186
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d7264 3
a7266 1
sh_elf_reloc_type_class (const Elf_Internal_Rela *rela)
@


1.185
log
@	PR ld/15113
	* elf32-sh.c (sh_elf_link_hash_table_create): Use bfd_zmalloc.
@
text
@d7295 1
a7295 1
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d7298 1
a7298 1
	elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 24);
d7321 1
a7321 1
	elf_tdata (abfd)->core_program
d7323 1
a7323 1
	elf_tdata (abfd)->core_command
d7332 1
a7332 1
    char *command = elf_tdata (abfd)->core_command;
@


1.184
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d2552 1
a2552 1
  ret = (struct elf_sh_link_hash_table *) bfd_malloc (amt);
a2564 11
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->srelplt2 = NULL;
  ret->sym_cache.abfd = NULL;
  ret->tls_ldm_got.refcount = 0;
  ret->plt_info = NULL;
@


1.183
log
@	bfd/
	* bfd-in.h (bfd_elf_stack_segment_size): Declare.
	* bfd-in2.h: Rebuilt.
	* elfxx-target.h (elf_backend_stack_align): New.
	(elfNN_bed): Add it.
	* elf-bfd.h (struct elf_backend_data): Add stack_align field.
	* elf.c (bfd_elf_map_sections_to_segments): Pay attention to
	stack_align and stacksize for PT_GNU_STACK segment.
	(assign_file_positions_for_non_load_sections): Set p_memsz for
	PT_GNU_STACK segment.
	(copy_elf_program_header): Copy PT_GNU_STACK size.
	* elflink.c (bfd_elf_stack_segment_size): New function, taken from
	uclinux backends.
	(bfd_elf_size_dynamic_sections): Determine
	PT_GNU_STACK requirements after calling backend.  Pay attention to
	stacksize.
	* elf32-bfin.c (elf32_bfinfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_bfinfdpic_modify_program_headers): Delete.
	(elf32_bfingfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-frv.c (frvfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_frvfdpic_modify_program_headers): Delete.
	(elf32_frvfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-lm32.c (lm32_elf_always_size_sections): Leave
	PT_GNU_STACK creation to underlying elf support.  Check
	__stacksize here for backwards compatibility, and set it if
	needed.
	(lm32_elf_modify_segment_map): Delete.
	(lm32_elf_modify_program_headers): Delete.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_segment_map): Don't override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-sh.c (sh_elf_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(sh_elf_modify_program_headers): Delete.
	(sh_elf_copy_private_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-tic6x.c (elf32_tic6x_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_tic6x_modify_program_headers): Delete.
	(elf32_tic6x_copy_private_data): Delete.
	(elf_backend_stack_align): Override.
	(bfd_elf32_bfd_copy_private_bfd_data): Don't override.
	(elf_backend_modify_program_headers): Don't override.

	include/
	* bfdlink.h (struct bfd_link_info): Add stacksize option.

	ld/
	* ld.texinfo (stack-size): New option.
	* emultempl/elf32.em: Add stack-size option.

	ld/testsuite/
	* ld-elf/binutils.exp: Add -z stack-size=0.
	* ld-elf/elf.exp: Add stack-exec and stack-size tests.
	* ld-elf/orphan-region.d: Add stack-size option. Remove xfail.
	* ld-elf/stack-exec.rd: New.
	* ld-elf/stack-size.rd: New.
	* ld-elf/stack.s: New.
	* ld-scripts/empty-aligned.d: Add stack-size option.
	* ld-sh/fdpic-stack-set.d: New.
	* ld-tic6x/shlib-1.rd: Remove __stacksize symbol.
	* ld-tic6x/shlib-1b.rd: Likewise.
	* ld-tic6x/shlib-1r.rd: Likewise.
	* ld-tic6x/shlib-1rb.rd: Likewise.
	* ld-tic6x/shlib-app-1.rd: Likewise.
	* ld-tic6x/shlib-app-1b.rd: Likewise.
	* ld-tic6x/shlib-app-1r.rd: Likewise.
	* ld-tic6x/shlib-app-1rb.rd: Likewise.
	* ld-tic6x/shlib-noindex.rd: Likewise.
	* ld-tic6x/static-app-1.rd: Likewise.
	* ld-tic6x/static-app-1b.rd: Likewise.
	* ld-tic6x/static-app-1r.rd: Likewise.
	* ld-tic6x/static-app-1rb.rd: Likewise.
@
text
@d4236 1
a4236 1
		(unsigned long) rel->r_offset, howto->name, 
d4251 1
a4251 1
		(unsigned long) rel->r_offset, howto->name, 
d5936 1
a5936 1
  eind->funcdesc.refcount = 0;  
d5938 1
a5938 1
  eind->abs_funcdesc_refcount = 0;  
d6558 1
a6558 1
  
d6574 1
a6574 1
  
d6578 1
a6578 1
  
d7248 1
a7248 1
    
d7354 1
a7354 1
 
@


1.182
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d3317 4
a3320 75
  if (sh_elf_hash_table (info)->fdpic_p && !info->relocatable)
    {
      struct elf_link_hash_entry *h;

      /* Force a PT_GNU_STACK segment to be created.  */
      if (! elf_tdata (output_bfd)->stack_flags)
	elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;

      /* Define __stacksize if it's not defined yet.  */
      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				FALSE, FALSE, FALSE);
      if (! h || h->root.type != bfd_link_hash_defined
	  || h->type != STT_OBJECT
	  || !h->def_regular)
	{
	  struct bfd_link_hash_entry *bh = NULL;

	  if (!(_bfd_generic_link_add_one_symbol
		(info, output_bfd, "__stacksize",
		 BSF_GLOBAL, bfd_abs_section_ptr, DEFAULT_STACK_SIZE,
		 (const char *) NULL, FALSE,
		 get_elf_backend_data (output_bfd)->collect, &bh)))
	    return FALSE;

	  h = (struct elf_link_hash_entry *) bh;
	  h->def_regular = 1;
	  h->type = STT_OBJECT;
	}
    }
  return TRUE;
}

#if !defined INCLUDE_SHMEDIA && !defined SH_TARGET_ALREADY_DEFINED

static bfd_boolean
sh_elf_modify_program_headers (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_obj_tdata *tdata = elf_tdata (output_bfd);
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;

  /* objcopy and strip preserve what's already there using
     sh_elf_copy_private_bfd_data ().  */
  if (! info)
    return TRUE;

  for (p = tdata->phdr, m = tdata->segment_map; m != NULL; m = m->next, p++)
    if (m->p_type == PT_GNU_STACK)
      break;

  if (m)
    {
      struct elf_link_hash_entry *h;

      /* Obtain the pointer to the __stacksize symbol.  */
      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				FALSE, FALSE, FALSE);
      if (h)
	{
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  BFD_ASSERT (h->root.type == bfd_link_hash_defined);
	}

      /* Set the header p_memsz from the symbol value.  We
	 intentionally ignore the symbol section.  */
      if (h && h->root.type == bfd_link_hash_defined)
	p->p_memsz = h->root.u.def.value;
      else
	p->p_memsz = DEFAULT_STACK_SIZE;

      p->p_align = 8;
    }

a3323 2
#endif

a6612 32
  /* Copy the stack size.  */
  if (elf_tdata (ibfd)->phdr && elf_tdata (obfd)->phdr
      && fdpic_object_p (ibfd) && fdpic_object_p (obfd))
    {
      unsigned i;

      for (i = 0; i < elf_elfheader (ibfd)->e_phnum; i++)
	if (elf_tdata (ibfd)->phdr[i].p_type == PT_GNU_STACK)
	  {
	    Elf_Internal_Phdr *iphdr = &elf_tdata (ibfd)->phdr[i];

	    for (i = 0; i < elf_elfheader (obfd)->e_phnum; i++)
	      if (elf_tdata (obfd)->phdr[i].p_type == PT_GNU_STACK)
		{
		  memcpy (&elf_tdata (obfd)->phdr[i], iphdr, sizeof (*iphdr));

		  /* Rewrite the phdrs, since we're only called after they
		     were first written.  */
		  if (bfd_seek (obfd,
				(bfd_signed_vma) get_elf_backend_data (obfd)
				->s->sizeof_ehdr, SEEK_SET) != 0
		      || get_elf_backend_data (obfd)->s
		      ->write_out_phdrs (obfd, elf_tdata (obfd)->phdr,
					 elf_elfheader (obfd)->e_phnum) != 0)
		    return FALSE;
		  break;
		}

	    break;
	  }
    }

d7485 1
a7547 3
#undef elf_backend_modify_program_headers
#define elf_backend_modify_program_headers \
					sh_elf_modify_program_headers
@


1.181
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d7160 1
a7160 1
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
@


1.181.4.1
log
@	PR ld/15113
	* elf32-sh.c (sh_elf_link_hash_table_create): Use bfd_zmalloc.
@
text
@d2552 1
a2552 1
  ret = (struct elf_sh_link_hash_table *) bfd_zmalloc (amt);
d2565 11
@


1.180
log
@	* elf32-sh.c (sh_elf_create_dynamic_sections): Don't create .rela
	section for bss type sections, except for .rela.bss.
	* elf-m10300.c (_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_create_dynamic_sections): Likewise.
	* elf32-lm32.c (lm32_elf_create_dynamic_sections): Likewise.
	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_create_dynamic_sections): Likewise.
@
text
@d2625 3
a2627 3
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  htab->srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d2631 5
a2635 5
  htab->sfuncdesc = bfd_make_section_with_flags (dynobj, ".got.funcdesc",
						 (SEC_ALLOC | SEC_LOAD
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_LINKER_CREATED));
d2640 7
a2646 7
  htab->srelfuncdesc = bfd_make_section_with_flags (dynobj,
						    ".rela.got.funcdesc",
						    (SEC_ALLOC | SEC_LOAD
						     | SEC_HAS_CONTENTS
						     | SEC_IN_MEMORY
						     | SEC_LINKER_CREATED
						     | SEC_READONLY));
d2652 6
a2657 6
  htab->srofixup = bfd_make_section_with_flags (dynobj, ".rofixup",
						(SEC_ALLOC | SEC_LOAD
						 | SEC_HAS_CONTENTS
						 | SEC_IN_MEMORY
						 | SEC_LINKER_CREATED
						 | SEC_READONLY));
d2711 1
a2711 1
  s = bfd_make_section_with_flags (abfd, ".plt", pltflags);
d2740 4
a2743 3
  s = bfd_make_section_with_flags (abfd,
				   bed->default_use_rela_p ? ".rela.plt" : ".rel.plt",
				   flags | SEC_READONLY);
d2761 2
a2762 2
      s = bfd_make_section_with_flags (abfd, ".dynbss",
				       SEC_ALLOC | SEC_LINKER_CREATED);
d2780 4
a2783 4
	  s = bfd_make_section_with_flags (abfd,
					   (bed->default_use_rela_p
					    ? ".rela.bss" : ".rel.bss"),
					   flags | SEC_READONLY);
d3421 1
a3421 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d4676 2
a4677 2
			  srelgot = bfd_get_section_by_name (dynobj,
							     ".rela.got");
d4998 1
a4998 1
		    srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d5288 1
a5288 1
		  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d7145 1
a7145 2
      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rela.bss");
d7181 1
a7181 1
  sdyn = bfd_get_section_by_name (htab->root.dynobj, ".dynamic");
@


1.179
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@a2751 26
  {
    const char *secname;
    char *relname;
    flagword secflags;
    asection *sec;

    for (sec = abfd->sections; sec; sec = sec->next)
      {
	secflags = bfd_get_section_flags (abfd, sec);
	if ((secflags & (SEC_DATA | SEC_LINKER_CREATED))
	    || ((secflags & SEC_HAS_CONTENTS) != SEC_HAS_CONTENTS))
	  continue;
	secname = bfd_get_section_name (abfd, sec);
	relname = (char *) bfd_malloc ((bfd_size_type) strlen (secname) + 6);
	strcpy (relname, ".rela");
	strcat (relname, secname);
	if (bfd_get_section_by_name (abfd, secname))
	  continue;
	s = bfd_make_section_with_flags (abfd, relname,
					 flags | SEC_READONLY);
	if (s == NULL
	    || ! bfd_set_section_alignment (abfd, s, ptralign))
	  return FALSE;
      }
  }

@


1.178
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d4245 1
a4245 1
					 rel, relend, howto, contents);
@


1.177
log
@bfd/
	* elf32-sh.c (elf_sh_link_hash_entry): Specify an enum identifier for
	got_type.
	(allocate_dynrelocs, sh_elf_relocate_section, sh_elf_check_relocs): Use
	it.
@
text
@d4051 1
a4051 1
	  if (sec != NULL && elf_discarded_section (sec))
d4243 1
a4243 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.176
log
@	* elf32-sh.c (allocate_dynrelocs): Don't allocate dynamic
	relocations when LE conversion happens on the IE tls symbol.
@
text
@d2409 1
a2409 1
  enum {
d3081 1
a3081 1
      int got_type = sh_elf_hash_entry (h)->got_type;
d3983 1
a3983 1
      int got_type;
d6096 1
a6096 1
  int got_type, old_got_type;
@


1.175
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@d3107 3
@


1.174
log
@	* elf32-sh.c (sh_elf_osec_to_segment): Check for elf flavour bfd
	before calling elf specific function.
	(sh_elf_osec_readonly_p): Test for error return from above.
@
text
@a2929 7
  if (h->size == 0)
    {
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     h->root.root.string);
      return TRUE;
    }

d2947 1
a2947 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.173
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d3 2
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d3792 4
a3795 2
  Elf_Internal_Phdr *p = _bfd_elf_find_segment_containing_section (output_bfd,
								   osec);
d3808 2
a3809 1
  return ! (elf_tdata (output_bfd)->phdr[seg].p_flags & PF_W);
@


1.172
log
@	* elf32-sh.c (sh_elf_relocate_section): Allow R_SH_TLS_LE_32 for PIE.
	(sh_elf_check_relocs): Likewise.
@
text
@d4211 5
a4215 1
	      else if (!info->relocatable)
@


1.172.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d4051 1
a4051 1
	  if (sec != NULL && discarded_section (sec))
d4239 1
a4239 1
      if (sec != NULL && discarded_section (sec))
@


1.171
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d5519 1
a5519 1
	    if (! info->shared)
d6617 1
a6617 1
	  if (info->shared)
@


1.170
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
a2979 6
  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a3317 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.169
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d4249 2
a4250 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.168
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d4408 1
a4408 1
	      && r_symndx != 0
@


1.167
log
@	* elf32-sh.c (sh_elf_relocate_section): Handle non-ELF output
	BFD.
@
text
@d7572 1
@


1.166
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d3932 1
a3932 1
  bfd *dynobj;
d3934 5
a3938 5
  asection *sgot;
  asection *sgotplt;
  asection *splt;
  asection *sreloc;
  asection *srelgot;
d3941 1
d3946 8
a3953 2
  if (htab == NULL)
    return FALSE;
a3955 1
  dynobj = htab->root.dynobj;
d3960 1
a3960 1
  if (htab->fdpic_p && htab->sgot)
d3962 1
a3962 1
					  htab->sgot->output_section);
d3965 1
a3965 1
  if (htab->fdpic_p && htab->splt)
d3967 1
a3967 1
					  htab->splt->output_section);
a3970 5
  sgot = htab->sgot;
  sgotplt = htab->sgotplt;
  splt = htab->splt;
  sreloc = NULL;
  srelgot = NULL;
d3973 1
a3973 1
  is_vxworks_tls = (htab->vxworks_p && info->shared
d4151 1
a4151 1
	      dyn = htab->root.dynamic_sections_created;
d4465 1
a4465 1
	      else if (htab->fdpic_p
d4519 1
a4519 1
	  else if (htab->fdpic_p && !info->shared
d4525 2
d4575 1
d4601 1
d4660 1
a4660 1
		      if (htab->fdpic_p && !info->shared
d4721 1
a4721 1
		      if (htab->fdpic_p)
d4738 1
a4738 1
		  else if (htab->fdpic_p
d4783 1
d4884 2
d4903 1
a4903 1
		reloc_section = htab->sgot;
d5098 1
d5151 2
a5152 2
	  relocation -= htab->root.hgot->root.u.def.value
	    + htab->sgotplt->output_offset;
d5187 1
d5438 1
d5572 1
a5572 1
      if (htab->fdpic_p && check_segment[0] != (unsigned) -1
@


1.165
log
@fix set but unused variable warnings
@
text
@d7441 1
a7441 1
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
@


1.164
log
@2010-05-21  Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Andrew Stubbs  <ams@@codesourcery.com>

        bfd/
        * config.bfd (sh-*-uclinux* | sh[12]-*-uclinux*): Add
        bfd_elf32_shl_vec, and FDPIC vectors to targ_selvecs.
        * configure.in: Handle FDPIC vectors.
        * elf32-sh-relocs.h: Add FDPIC and movi20 relocations.
        * elf32-sh.c (DEFAULT_STACK_SIZE): Define.
        (SYMBOL_FUNCDESC_LOCAL): Define.  Use it instead of
        SYMBOL_REFERENCES_LOCAL for function descriptors.
        (fdpic_object_p): New.
        (sh_reloc_map): Add FDPIC and movi20 relocations.
        (sh_elf_info_to_howto, sh_elf_relocate_section): Handle new invalid
        range.
        (struct elf_sh_plt_info): Add got20 and short_plt.  Update all
        definitions.
        (FDPIC_PLT_ENTRY_SIZE, FDPIC_PLT_LAZY_OFFSET): Define.
        (fdpic_sh_plt_entry_be, fdpic_sh_plt_entry_le, fdpic_sh_plts): New.
        (FDPIC_SH2A_PLT_ENTRY_SIZE, FDPIC_SH2A_PLT_LAZY_OFFSET): Define.
        (fdpic_sh2a_plt_entry_be, fdpic_sh2a_plt_entry_le)
        (fdpic_sh2a_short_plt_be, fdpic_sh2a_short_plt_le, fdpic_sh2a_plts):
        New.
        (get_plt_info): Handle FDPIC.
        (MAX_SHORT_PLT): Define.
        (get_plt_index, get_plt_offset): Handle short_plt.
        (union gotref): New.
        (struct elf_sh_link_hash_entry): Add funcdesc, rename tls_type to
        got_type and adjust all uses.  Add GOT_FUNCDESC.
        (struct sh_elf_obj_tdata): Add local_funcdesc.  Rename
        local_got_tls_type to local_got_type.
        (sh_elf_local_got_type): Renamed from sh_elf_local_got_tls_type.  All
        users changed.
        (sh_elf_local_funcdesc): Define.
        (struct elf_sh_link_hash_table): Add sfuncdesc, srelfuncdesc, fdpic_p,
        and srofixup.
        (sh_elf_link_hash_newfunc): Initialize new fields.
        (sh_elf_link_hash_table_create): Set fdpic_p.
        (sh_elf_omit_section_dynsym): New.
        (create_got_section): Create .got.funcdesc, .rela.got.funcdesc
        and .rofixup.
        (allocate_dynrelocs): Allocate local function descriptors and space
        for R_SH_FUNCDESC-related relocations, and for rofixups.
        Handle GOT_FUNCDESC.  Create fixups.  Handle GOT entries which
        require function descriptors.
        (sh_elf_always_size_sections): Handle PT_GNU_STACK and __stacksize.
        (sh_elf_modify_program_headers): New.
        (sh_elf_size_dynamic_sections): Allocate function descriptors for
        local symbols.  Allocate .got.funcdesc contents.  Allocate rofixups.
        Handle local GOT entries of type GOT_FUNCDESC.  Create fixups for
        local GOT entries.  Ensure that FDPIC libraries always have a PLTGOT
        entry in the .dynamic section.
        (sh_elf_add_dyn_reloc, sh_elf_got_offset, sh_elf_initialize_funcdesc)
        (sh_elf_add_rofixup, sh_elf_osec_to_segment)
        (sh_elf_osec_readonly_p, install_movi20_field): New functions.
        (sh_elf_relocate_section): Handle new relocations, R_SH_FUNCDESC,
        R_SH_GOTFUNCDESC and R_SH_GOTOFFFUNCDESC.  Use sh_elf_got_offset
        and .got.plt throughout to find _GLOBAL_OFFSET_TABLE_.  Add rofixup
        read-only section warnings.  Handle undefined weak symbols.  Generate
        fixups for R_SH_DIR32 and GOT entries.  Check for cross-segment
        relocations and clear EF_SH_PIC.  Handle 20-bit relocations.
        Always generate R_SH_DIR32 for FDPIC instead of R_SH_RELATIVE.
        (sh_elf_gc_sweep_hook): Handle R_SH_FUNCDESC, R_SH_GOTOFF20,
        R_SH_GOTFUNCDESC, R_SH_GOTFUNCDESC20, and R_SH_GOTOFFFUNCDESC.
        Handle 20-bit relocations.
        (sh_elf_copy_indirect_symbol): Copy function descriptor reference
        counts.
        (sh_elf_check_relocs): Handle new relocations.  Make symbols
        dynamic for FDPIC relocs.  Account for rofixups.  Error for FDPIC
        symbol mismatches.  Allocate a GOT for R_SH_DIR32. Allocate fixups
        for R_SH_DIR32.
        (sh_elf_copy_private_data): Copy PT_GNU_STACK size.
        (sh_elf_merge_private_data): Copy initial flags.  Do not clobber
        non-mach flags.  Set EF_SH_PIC for FDPIC.  Reject FDPIC mismatches.
        (sh_elf_finish_dynamic_symbol): Do not handle got_funcdesc entries
        here.  Rename sgot to sgotplt and srel to srelplt.  Handle short_plt,
        FDPIC descriptors, and got20.  Create R_SH_FUNCDESC_VALUE for FDPIC.
        Use install_movi20_field.  Rename srel to srelgot.  Always generate
        R_SH_DIR32 for FDPIC instead of R_SH_RELATIVE.
        (sh_elf_finish_dynamic_sections): Fill in the GOT pointer in rofixup.
        Do not fill in reserved GOT entries for FDPIC.  Correct DT_PLTGOT.
        Rename sgot to sgotplt.  Assert that the right number of rofixups
        and dynamic relocations were allocated.
        (sh_elf_use_relative_eh_frame, sh_elf_encode_eh_address): New.
        (elf_backend_omit_section_dynsym): Use sh_elf_omit_section_dynsym.
        (elf_backend_can_make_relative_eh_frame)
        (elf_backend_can_make_lsda_relative_eh_frame)
        (elf_backend_encode_eh_address): Define.
        (TARGET_BIG_SYM, TARGET_BIG_NAME, TARGET_LITTLE_SYM)
        (TARGET_LITTLE_NAME, elf_backend_modify_program_headers, elf32_bed):
        Redefine for FDPIC vector.
        * reloc.c: Add SH FDPIC and movi20 relocations.
        * targets.c (_bfd_target_vector): Add FDPIC vectors.
        * configure, bfd-in2.h, libbfd.h: Regenerated.

        binutils/
        * readelf.c (get_machine_flags): Handle EF_SH_PIC and EF_SH_FDPIC.

        gas/
        * config/tc-sh.c (sh_fdpic): New.
        (sh_check_fixup): Handle relocations on movi20.
        (parse_exp): Do not reject PIC operators here.
        (build_Mytes): Check for unhandled PIC operators here.  Use
        sh_check_fixup for movi20.
        (enum options): Add OPTION_FDPIC.
        (md_longopts, md_parse_option, md_show_usage): Add --fdpic.
        (sh_fix_adjustable, md_apply_fix): Handle FDPIC and movi20 relocations.
        (sh_elf_final_processing): Handle --fdpic.
        (sh_uclinux_target_format): New.
        (sh_parse_name): Handle FDPIC relocation operators.
        * config/tc-sh.h (TARGET_FORMAT): Define specially for TE_UCLINUX.
        (sh_uclinux_target_format): Declare for TE_UCLINUX.
        * configure.tgt (sh-*-uclinux* | sh[12]-*-uclinux*): Set
        em=uclinux.
        * doc/c-sh.texi (SH Options): Document --fdpic.

        gas/testsuite/
        * gas/sh/basic.exp: Run new tests.  Handle uClinux like Linux.
        * gas/sh/fdpic.d: New file.
        * gas/sh/fdpic.s: New file.
        * gas/sh/reg-prefix.d: Force big-endian.
        * gas/sh/sh2a-pic.d: New file.
        * gas/sh/sh2a-pic.s: New file.
        * lib/gas-defs.exp (is_elf_format): Include sh*-*-uclinux*.

        include/elf/
        * sh.h (EF_SH_PIC, EF_SH_FDPIC): Define.
        (R_SH_FIRST_INVALID_RELOC_6, R_SH_LAST_INVALID_RELOC_6): New.  Adjust
        other invalid ranges.
        (R_SH_GOT20, R_SH_GOTOFF20, R_SH_GOTFUNCDESC, R_SH_GOTFUNCDESC20)
        (R_SH_GOTOFFFUNCDESC, R_SH_GOTOFFFUNCDESC20, R_SH_FUNCDESC)
        (R_SH_FUNCDESC_VALUE): New.

        ld/
        * Makefile.am (ALL_EMULATIONS): Add eshelf_fd.o and eshlelf_fd.o.
        (eshelf_fd.c, eshlelf_fd.c): New rules.
        * Makefile.in: Regenerate.
        * configure.tgt (sh-*-uclinux*): Add shelf_fd and shlelf_fd
        emulations.
        * emulparams/shelf_fd.sh: New file.
        * emulparams/shlelf_fd.sh: New file.
        * emulparams/shlelf_linux.sh: Update comment.

        ld/testsuite/
        * ld-sh/sh.exp: Handle uClinux like Linux.
        * lib/ld-lib.exp (is_elf_format): Include sh*-*-uclinux*.
        * ld-sh/fdpic-funcdesc-shared.d: New file.
        * ld-sh/fdpic-funcdesc-shared.s: New file.
        * ld-sh/fdpic-funcdesc-static.d: New file.
        * ld-sh/fdpic-funcdesc-static.s: New file.
        * ld-sh/fdpic-gotfuncdesc-shared.d: New file.
        * ld-sh/fdpic-gotfuncdesc-shared.s: New file.
        * ld-sh/fdpic-gotfuncdesc-static.d: New file.
        * ld-sh/fdpic-gotfuncdesc-static.s: New file.
        * ld-sh/fdpic-gotfuncdesci20-shared.d: New file.
        * ld-sh/fdpic-gotfuncdesci20-shared.s: New file.
        * ld-sh/fdpic-gotfuncdesci20-static.d: New file.
        * ld-sh/fdpic-gotfuncdesci20-static.s: New file.
        * ld-sh/fdpic-goti20-shared.d: New file.
        * ld-sh/fdpic-goti20-shared.s: New file.
        * ld-sh/fdpic-goti20-static.d: New file.
        * ld-sh/fdpic-goti20-static.s: New file.
        * ld-sh/fdpic-gotofffuncdesc-shared.d: New file.
        * ld-sh/fdpic-gotofffuncdesc-shared.s: New file.
        * ld-sh/fdpic-gotofffuncdesc-static.d: New file.
        * ld-sh/fdpic-gotofffuncdesc-static.s: New file.
        * ld-sh/fdpic-gotofffuncdesci20-shared.d: New file.
        * ld-sh/fdpic-gotofffuncdesci20-shared.s: New file.
        * ld-sh/fdpic-gotofffuncdesci20-static.d: New file.
        * ld-sh/fdpic-gotofffuncdesci20-static.s: New file.
        * ld-sh/fdpic-gotoffi20-shared.d: New file.
        * ld-sh/fdpic-gotoffi20-shared.s: New file.
        * ld-sh/fdpic-gotoffi20-static.d: New file.
        * ld-sh/fdpic-gotoffi20-static.s: New file.
        * ld-sh/fdpic-plt-be.d: New file.
        * ld-sh/fdpic-plt-le.d: New file.
        * ld-sh/fdpic-plt.s: New file.
        * ld-sh/fdpic-plti20-be.d: New file.
        * ld-sh/fdpic-plti20-le.d: New file.
        * ld-sh/fdpic-stack-default.d: New file.
        * ld-sh/fdpic-stack-size.d: New file.
        * ld-sh/fdpic-stack.s: New file.
@
text
@a6094 3
  bfd_vma *local_got_offsets;
  asection *sgot;
  asection *srelgot;
a6098 2
  sgot = NULL;
  srelgot = NULL;
a6112 2
  local_got_offsets = elf_local_got_offsets (abfd);

@


1.163
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d30 1
d58 3
d62 7
d102 16
d363 7
d484 1
d1590 3
d1597 5
d1746 3
a1748 2
      { 0, 32, 48 },
      33 /* includes ISA encoding */
d1757 3
a1759 2
      { 0, 32, 48 },
      33 /* includes ISA encoding */
d1770 3
a1772 2
      { 0, MINUS_ONE, 52 },
      33 /* includes ISA encoding */
d1781 3
a1783 2
      { 0, MINUS_ONE, 52 },
      33 /* includes ISA encoding */
d1943 3
a1945 2
      { 20, 16, 24 },
      8
d1954 3
a1956 2
      { 20, 16, 24 },
      8
d1967 3
a1969 2
      { 20, MINUS_ONE, 24 },
      8
d1978 3
a1980 2
      { 20, MINUS_ONE, 24 },
      8
d2071 3
a2073 2
      { 8, 14, 20 },
      12
d2082 3
a2084 2
      { 8, 14, 20 },
      12
d2095 3
a2097 2
      { 8, MINUS_ONE, 20 },
      12
d2106 3
a2108 2
      { 8, MINUS_ONE, 20 },
      12
d2113 156
d2273 1
a2273 1
get_plt_info (bfd *abfd ATTRIBUTE_UNUSED, bfd_boolean pic_p)
d2275 9
d2301 6
d2312 14
a2325 1
  return (offset - info->plt0_entry_size) / info->symbol_entry_size;
d2333 14
a2346 1
  return info->plt0_entry_size + (plt_index * info->symbol_entry_size);
d2369 6
d2394 14
d2409 2
a2410 2
    GOT_UNKNOWN = 0, GOT_NORMAL, GOT_TLS_GD, GOT_TLS_IE
  } tls_type;
d2419 5
a2423 2
  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
d2429 5
a2433 2
#define sh_elf_local_got_tls_type(abfd) \
  (sh_elf_tdata (abfd)->local_got_tls_type)
d2464 3
d2486 3
d2535 3
a2537 1
      ret->tls_type = GOT_UNKNOWN;
d2576 1
d2581 28
d2629 32
d3021 1
d3034 4
a3037 3
	     the shared library.  */
	  if (! info->shared
	      && !h->def_regular)
d3044 5
a3048 1
	  s->size += htab->plt_info->symbol_entry_size;
d3052 4
a3055 1
	  htab->sgotplt->size += 4;
d3093 1
a3093 1
      int tls_type = sh_elf_hash_entry (h)->tls_type;
d3108 1
a3108 1
      if (tls_type == GOT_TLS_GD)
d3111 8
d3121 2
a3122 2
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || (tls_type == GOT_TLS_IE && dyn))
d3124 1
a3124 1
      else if (tls_type == GOT_TLS_GD)
d3126 7
d3138 4
d3172 40
d3307 4
d3353 76
d3432 2
d3471 2
a3472 1
      char *local_tls_type;
d3510 4
a3517 4
      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

a3523 2
      end_local_got = local_got + locsymcount;
      local_tls_type = sh_elf_local_got_tls_type (ibfd);
d3526 47
a3572 1
      for (; local_got < end_local_got; ++local_got)
d3574 3
a3576 1
	  if (*local_got > 0)
d3578 11
a3588 6
	      *local_got = s->size;
	      s->size += 4;
	      if (*local_tls_type == GOT_TLS_GD)
		s->size += 4;
	      if (info->shared)
		srel->size += sizeof (Elf32_External_Rela);
a3589 3
	  else
	    *local_got = (bfd_vma) -1;
	  ++local_tls_type;
d3591 1
d3605 8
d3617 12
d3640 2
d3715 6
d3750 169
d3940 1
d3952 13
d3991 2
a3992 1
      int tls_type;
d4010 2
d4018 2
a4019 2
	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC_2
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC_2))
d4035 2
d4041 6
d4133 1
d4167 6
d4207 2
a4208 2
		      && (sh_elf_hash_entry (h)->tls_type == GOT_TLS_IE
			  || sh_elf_hash_entry (h)->tls_type == GOT_TLS_GD)))
d4261 10
d4464 18
d4509 2
d4518 28
d4585 1
d4598 1
d4652 11
d4666 1
a4666 1
	      relocation = sgot->output_offset + off;
d4716 13
a4728 2
		      outrel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
		      outrel.r_addend = relocation;
d4733 7
d4749 1
a4749 1
	      relocation = sgot->output_offset + off;
d4756 9
a4764 1
	  goto final_link_relocate;
d4767 1
d4774 8
a4781 11
	  /* Relocation is relative to the start of the global offset
	     table.  */

	  BFD_ASSERT (sgot != NULL);

	  /* Note that sgot->output_offset is not involved in this
	     calculation.  We always want the start of .got.  If we
	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
	     permitted by the ABI, we might have to change this
	     calculation.  */
	  relocation -= sgot->output_section->vma;
d4789 9
a4797 1
	  goto final_link_relocate;
d4808 2
a4809 2
	  BFD_ASSERT (sgot != NULL);
	  relocation = sgot->output_section->vma;
d4834 7
d4853 1
d4866 292
d5178 1
d5180 1
a5180 1
	  tls_type = GOT_UNKNOWN;
d5182 1
a5182 1
	    tls_type = sh_elf_local_got_tls_type (input_bfd) [r_symndx];
d5185 1
a5185 1
	      tls_type = sh_elf_hash_entry (h)->tls_type;
d5192 1
a5192 1
	  if (r_type == R_SH_TLS_GD_32 && tls_type == GOT_TLS_IE)
d5280 1
a5280 2
	  sgot = htab->sgot;
	  if (sgot == NULL)
d5300 1
a5300 1
	      bfd_put_32 (output_bfd, sgot->output_offset + off,
d5368 1
a5368 1
	    relocation = sgot->output_offset + off;
d5417 1
a5417 1
	      bfd_put_32 (output_bfd, sgot->output_offset + off,
d5428 1
d5476 1
a5476 2
	  sgot = htab->sgot;
	  if (sgot == NULL)
d5501 1
a5501 1
	  relocation = sgot->output_offset + off;
d5507 1
d5522 2
d5561 22
d5781 1
d5792 1
d5839 1
d5841 1
d5861 2
d5893 16
d5910 5
d6034 4
d6042 2
a6043 2
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
d6100 1
a6100 1
  int tls_type, old_tls_type;
d6157 24
d6186 4
d6192 1
d6194 6
d6226 4
a6229 7
	      if (htab->sgot == NULL)
		{
		  if (htab->root.dynobj == NULL)
		    htab->root.dynobj = abfd;
		  if (!create_got_section (htab->root.dynobj, info))
		    return FALSE;
		}
d6263 1
d6272 2
d6277 1
a6277 1
	      tls_type = GOT_NORMAL;
d6280 1
a6280 1
	      tls_type = GOT_TLS_GD;
d6283 5
a6287 1
	      tls_type = GOT_TLS_IE;
d6304 1
a6304 1
	      old_tls_type = sh_elf_hash_entry (h)->tls_type;
d6333 1
a6333 1
		  sh_elf_local_got_tls_type (abfd)
d6336 1
a6336 1
		  sh_elf_local_got_tls_type (abfd)
d6346 1
a6346 1
	      old_tls_type = sh_elf_local_got_tls_type (abfd) [r_symndx];
d6351 2
a6352 2
	  if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN
	      && (old_tls_type != GOT_TLS_GD || tls_type != GOT_TLS_IE))
d6354 2
a6355 2
	      if (old_tls_type == GOT_TLS_IE && tls_type == GOT_TLS_GD)
		tls_type = GOT_TLS_IE;
d6358 12
a6369 1
		  (*_bfd_error_handler)
d6376 1
a6376 1
	  if (old_tls_type != tls_type)
d6379 1
a6379 1
		sh_elf_hash_entry (h)->tls_type = tls_type;
d6381 1
a6381 1
		sh_elf_local_got_tls_type (abfd) [r_symndx] = tls_type;
d6390 64
d6619 7
d6719 32
d6784 1
a6784 1
      elf_elfheader (obfd)->e_flags = EF_SH1;
d6786 2
d6799 2
a6800 1
  elf_elfheader (obfd)->e_flags =
d6802 9
a6810 1
  
d6822 5
a6826 1
  return sh_elf_set_mach_from_flags (abfd);
d6846 2
a6847 2
      asection *sgot;
      asection *srel;
d6853 1
d6861 3
a6863 3
      sgot = htab->sgotplt;
      srel = htab->srelplt;
      BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);
d6871 4
d6876 10
a6885 3
	 corresponds to this function.  Each .got entry is 4 bytes.
	 The first three are reserved.  */
      got_offset = (plt_index + 3) * 4;
d6894 2
a6895 2
	      htab->plt_info->symbol_entry,
	      htab->plt_info->symbol_entry_size);
d6897 17
a6913 5
      if (info->shared)
	install_plt_field (output_bfd, FALSE, got_offset,
			   (splt->contents
			    + h->plt.offset
			    + htab->plt_info->symbol_fields.got_entry));
d6916 2
d6919 2
a6920 2
			     (sgot->output_section->vma
			      + sgot->output_offset
d6924 1
a6924 1
			      + htab->plt_info->symbol_fields.got_entry));
d6938 4
a6941 4
				 - htab->plt_info->plt0_entry_size
				 - (htab->plt_info->symbol_fields.plt + 4))
				/ htab->plt_info->symbol_entry_size) + 1;
	      plts_per_4k = (4096 / htab->plt_info->symbol_entry_size);
d6944 1
a6944 1
			     + htab->plt_info->symbol_fields.plt);
d6947 1
a6947 1
			     * htab->plt_info->symbol_entry_size);
d6954 1
a6954 1
			   + htab->plt_info->symbol_fields.plt));
d6961 1
a6961 1
				+ htab->plt_info->symbol_fields.plt));
d6964 1
d6969 2
d6972 6
a6977 5
      install_plt_field (output_bfd, FALSE,
			 plt_index * sizeof (Elf32_External_Rela),
			 (splt->contents
			  + h->plt.offset
			  + htab->plt_info->symbol_fields.reloc_offset));
d6984 7
a6990 2
		   + htab->plt_info->symbol_resolve_offset),
		  sgot->contents + got_offset);
d6993 2
a6994 2
      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
d6996 4
a6999 1
      rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_JMP_SLOT);
d7004 1
a7004 1
      loc = srel->contents + plt_index * sizeof (Elf32_External_Rela);
d7019 1
a7019 1
			  + htab->plt_info->symbol_fields.got_entry);
d7027 2
a7028 2
	  rel.r_offset = (htab->sgotplt->output_section->vma
			  + htab->sgotplt->output_offset
d7044 3
a7046 2
      && sh_elf_hash_entry (h)->tls_type != GOT_TLS_GD
      && sh_elf_hash_entry (h)->tls_type != GOT_TLS_IE)
d7049 1
a7049 1
      asection *srel;
d7057 2
a7058 2
      srel = htab->srelgot;
      BFD_ASSERT (sgot != NULL && srel != NULL);
d7072 17
a7088 4
	  rel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
	  rel.r_addend = (h->root.u.def.value
			  + h->root.u.def.section->output_section->vma
			  + h->root.u.def.section->output_offset);
d7097 2
a7098 2
      loc = srel->contents;
      loc += srel->reloc_count++ * sizeof (Elf32_External_Rela);
d7110 1
a7110 1
	asection *srel;
d7118 2
a7119 2
	srel = htab->srelgot;
	BFD_ASSERT (sgot != NULL && srel != NULL);
d7133 17
a7149 4
	    rel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
	    rel.r_addend = (h->root.u.def.value
			    + h->root.u.def.section->output_section->vma
			    + h->root.u.def.section->output_offset);
d7159 2
a7160 2
	loc = srel->contents;
	loc += srel->reloc_count++ * sizeof (Elf32_External_Rela);
d7207 1
a7207 1
  asection *sgot;
d7214 1
a7214 1
  sgot = htab->sgotplt;
d7222 1
a7222 1
      BFD_ASSERT (sgot != NULL && sdyn != NULL);
d7268 6
a7273 2
	      s = htab->sgot->output_section;
	      goto get_vma;
a7276 1
	    get_vma:
d7321 2
a7322 2
				 (sgot->output_section->vma
				  + sgot->output_offset
d7373 1
a7373 1
  if (sgot && sgot->size > 0)
d7376 1
a7376 1
	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
d7380 4
a7383 3
		    sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
d7385 15
a7399 1
      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
d7402 8
d7507 53
d7609 1
a7609 2
#define elf_backend_omit_section_dynsym \
  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
d7616 6
d7675 22
@


1.162
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d2160 1
a2160 1
   && elf_object_id (bfd) == SH_ELF_TDATA)
d2169 1
a2169 1
				  SH_ELF_TDATA);
d2218 2
a2219 1
  ((struct elf_sh_link_hash_table *) ((p)->hash))
d2271 2
a2272 1
				      sizeof (struct elf_sh_link_hash_entry)))
d2306 3
d2344 3
d2493 2
d2641 2
d2950 3
d3200 2
d4880 3
d5437 2
d5743 3
@


1.161
log
@update copyright dates
@
text
@d2092 1
a2092 1
get_plt_offset (const struct elf_sh_plt_info *info, bfd_vma index)
d2094 1
a2094 1
  return info->plt0_entry_size + (index * info->symbol_entry_size);
d2319 1
a2319 1
  register asection *s;
d4046 1
a4046 1
		  int index;
d4068 1
a4068 1
		  index = insn & 0x00ff;
d4073 1
a4073 1
		  insn = 0xd000 | (insn & 0x0f00) | index;
@


1.160
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@d3 1
a3 1
   2006, 2007, 2008 Free Software Foundation, Inc.
@


1.159
log
@2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-arm.c (create_got_section): Get existing .rela.got
	section.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	* elf32-lm32.c (create_got_section): Likewise.
	* elf32-m32r.c (create_got_section): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.

	* elflink.c (_bfd_elf_create_got_section): Properly initialize
	the GOT size.
@
text
@d2190 2
a2191 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d2284 1
a2284 1
  ret->sym_sec.abfd = NULL;
d5206 1
d5209 6
d5216 1
a5216 3
		  /* Track dynamic relocs needed for local syms too.  */
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
d5218 1
a5218 1
		    return FALSE;
@


1.158
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d2306 2
a2307 1
  if (! htab->sgot || ! htab->sgotplt)
a2308 10

  htab->srelgot = bfd_make_section_with_flags (dynobj, ".rela.got",
					       (SEC_ALLOC | SEC_LOAD
						| SEC_HAS_CONTENTS
						| SEC_IN_MEMORY
						| SEC_LINKER_CREATED
						| SEC_READONLY));
  if (htab->srelgot == NULL
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return FALSE;
@


1.157
log
@	bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Skip dynamic relocs
	in vxworks tls_vars sections.
	(allocate_dynrelocs, elf32_arm_size_dynamic_sections): Likewise.
	* elf32-i386.c (allocate_dynrelocs,
	elf_i386_size_dynamic_sections, elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (allocate_dynrelocs, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs,
	_bfd_sparc_elf_size_dynamic_sections,
	_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-vxworks/tls-3.s: New.
	* ld-vxworks/tls-3.d: New.
@
text
@d3629 3
a3631 7
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
a3632 8

		  BFD_ASSERT (CONST_STRNEQ (name, ".rela")
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
d4343 3
a4345 7
		const char *name;

		name = (bfd_elf_string_from_elf_section
			(input_bfd,
			 elf_elfheader (input_bfd)->e_shstrndx,
			 elf_section_data (input_section)->rel_hdr.sh_name));
		if (name == NULL)
a4346 8

		BFD_ASSERT (CONST_STRNEQ (name, ".rela")
			    && strcmp (bfd_get_section_name (input_bfd,
							     input_section),
				       name + 5) == 0);

		sreloc = bfd_get_section_by_name (dynobj, name);
		BFD_ASSERT (sreloc != NULL);
d5202 2
a5203 1
		  const char *name;
d5205 1
a5205 5
		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
a5206 23

		  BFD_ASSERT (CONST_STRNEQ (name, ".rela")
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (htab->root.dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      sreloc = bfd_make_section_with_flags (htab->root.dynobj,
							    name,
							    flags);
		      if (sreloc == NULL
			  || ! bfd_set_section_alignment (htab->root.dynobj,
							  sreloc, 2))
			return FALSE;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
@


1.156
log
@PR ld/5692
   * elf-bfd.h (enum elf_object_id): New enum, used to identify
   target specific extensions to the elf_obj_tdata structure.
   (struct elf_obj_tdata): New field 'object_id'.
   (elf_object_id, elf_program_header_size, elf_symtab_hdr): New
   macros for accessing fields in the elf_obj_tdata structure.
   (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object.
   (bfd_elf_allocate_object): New function.
   * elf.c (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object
   and implement by calling bfd_elf_allocate_object.
   (bfd_elf_allocate_object): New function: Allocates an
   elf_obj_tdata structure, possibly with a target specific
   extension.
   * elfxx-target.h (bfd_elfNN_mkobject): Use
   bfd_elf_make_generic_object as the default value.
   * elf32-arm.c (elf32_arm_obj_tdata): Rename to elf_arm_obj_tdata
   for consistency with other, similar structures.
   (is_arm_elf): New macro.  Checks a BFD to make sure that is an ARM
   ELF bfd.
   (elf32_arm_mkobject): Call bfd_elf_allocate_object.
   (bfd_elf32_arm_vfp11_erratum_scan): Use is_arm_elf macro to check
   the bfd being processed.
   (bfd_elf32_arm_vfp11_fix_veneer_locations): Likewise.
   (bfd_elf32_arm_set_target_relocs): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_copy_private_bfd_data): Likewise.
   (bfd_elf32_arm_merge_eabi_attributes): Likewise.
   (bfd_elf32_arm_merge_private_bfd_data): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_gc_mark_extra_sections): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   (bfd_elf32_arm_process_before_allocation): Use elf_symtab_hdr.
   (bfd_elf32_arm_init_maps): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_relocate_section): Likewise.
   (bfd_elf32_arm_gc_sweep_hook): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   * elf32-i386.c (elf_i386_mkobject): Call bfd_elf_allocate_object.
   (is_i386_elf): New macro.  Checks a BFD to make sure that is an x86
   ELF bfd.
   (elf_i386_check_relocs): Use is_i386_elf macro to check    the bfd
   being processed.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   (elf_i386_check_relocs): Use elf_symtab_hdr.
   (elf_i386_gc_sweep_hook): Likewise.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   * elf32-ppc.c (ppc_elf_mkobject): Call bfd_elf_allocate_object.
   (elf_create_pointer_linker_section): Use is_ppc_elf_target to
   verify that the bfd before accessing target specific fields.
   (ppc_elf_check_relocs): Likewise.
   (elf_finish_pointer_linker_section): Likewise.
   (elf_create_pointer_linker_section): Use elf_symtab_hdr.
   (ppc_elf_check_relocs): Likewise.
   (ppc_elf_gc_sweep_hook): Likewise.
   (ppc_elf_tls_optimize): Likewise.
   (ppc_elf_size_dynamic_sections): Likewise.
   (ppc_elf_relax_section): Likewise.
   (ppc_elf_relocate_section): Likewise.
   * elf32-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf64-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf32-sh.c (sh_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sh_elf): New macro.  Checks a BFD to make sure that is an SH
   ELF bfd.
   (sh_elf_size_dynamic_sections): Use is_sh_elf macro to check the
   bfd being processed.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_check_relocs): Likewise.
   (sh_elf_copy_private_data): Likewise.
   (sh_elf_relax_section): Use elf_symtab_hdr.
   (sh_elf_size_dynamic_sections): Likewise.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_get_relocated_section_contents): Likewise.
   (sh_elf_gc_sweep_hook): Likewise.
   (sh_elf_check_relocs): Likewise.
   * elf64-alpha.c (elf64_alpha_mkobject): Call bfd_elf_allocate_object.
   (is_alpha_elf): New macro.  Checks a BFD to make sure that is an
   Alpha ELF bfd.
   (elf64_alpha_create_got_section): Use is_alpha_elf macro to check
   the bfd being processed.
   (elf64_alpha_create_dynamic_section): Likewise.
   (elf64_alpha_check_relocs): Likewise.
   (elf64_alpha_size_got_sections): Likewise.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   (elf64_alpha_final_link): Likewise.
   (elf64_alpha_check_relocs): Use elf_symtab_hdr.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section_r): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   * elf64-ppc.c (ppc64_elf_mkobject): Call bfd_elf_allocate_object.
   (ppc64_elf_check_relocs): Use is_ppc64_elf_target to check the bfd
   being processed.
   (opd_entry_value): Likewise.
   (allocate_dynrelocs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   (ppc64_elf_check_relocs): Use elf_symtab_hdr.
   (opd_entry_value): Likewise.
   (ppc64_elf_gc_sweep_hook): Likewise.
   (get_sym_h): Likewise.
   (ppc64_elf_edit_opd): Likewise.
   (ppc64_elf_tls_optimize): Likewise.
   (ppc64_elf_edit_toc): Likewise.
   (ppc64_elf_size_dynamic_sections): Likewise.
   (toc_adjusting_stub_needed): Likewise.
   (ppc64_elf_size_stubs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   * elf64-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf32-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf64-x86_64.c (elf64_x86_64_mkobject): Call bfd_elf_allocate_object.
   (is_x86_64_elf): New macro.  Checks a BFD to make sure that is an
   x86_64 ELF bfd.
   (elf64_x86_64_check_relocs): Use is_x86_64_elf macro to check the bfd
   being processed.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   (elf64_x86_64_check_relocs): Use elf_symtab_hdr.
   (elf64_x86_64_gc_sweep_hook): Likewise.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   * elfxx-sparc.c (_bfd_sparc_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sparc_elf): New macro.  Checks a BFD to make sure that is a Sparc
   ELF bfd.
   (_bfd_sparc_elf_check_relocs): Use is_sparc_elf macro to check the
   bfd being processed.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_check_relocs): Use elf_symtab_hdr.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d2820 13
d2993 7
d3189 1
d3204 5
d3615 1
@


1.155
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d3 1
a3 1
   2006, 2007 Free Software Foundation, Inc.
d490 1
a490 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d855 1
a855 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d2157 5
d2168 2
a2169 8
  if (abfd->tdata.any == NULL)
    {
      bfd_size_type amt = sizeof (struct sh_elf_obj_tdata);
      abfd->tdata.any = bfd_zalloc (abfd, amt);
      if (abfd->tdata.any == NULL)
	return FALSE;
    }
  return bfd_elf_mkobject (abfd);
d2960 1
a2960 1
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
d2994 1
a2994 1
      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d3170 2
d3173 1
a3173 1
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
d4431 1
a4431 1
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
d4573 1
a4573 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d4863 3
a4865 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
a5363 4
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

d5367 3
d5396 1
a5396 2
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
@


1.154
log
@	include/elf/
	* vxworks.h: New.

	bfd/
	* elf-vxworks.h (elf_vxworks_add_dynamic_entries): Declare.
	(elf_vxworks_finish_dynamic_entry): Declare.
	* elf-vxworks.c: Include elf/vxworks.h.
	(elf_vxworks_add_dynamic_entries): New.
	(elf_vxworks_finish_dynamic_entry): New.
	* Makefile.am (elf-vxworks.lo): Add dependency.
	* Makefile.in (elf-vxworks.lo): Add dependency.
	* elf32-i386.c (elf_i386_size_dynamic_sections,
	elf_i386_finish_dynamic_sections): Call
	elf_vxworks_add_dynamic_entries and
	elf_vxworks_finish_dynamic_entry.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections,
	sparc_finish_dyn): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections,
	sh_elf_finish_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elf32-arm.c (elf32_arm_size_dynamic_sections,
	elf32_arm_finish_dynamic_sections): Likewise.

	ld/
	* ld-vxworks/tls-2.d: New.
	* ld-vxworks/tls-2.s: New.
@
text
@d4567 3
@


1.153
log
@	* elf-m10300.c (mn10300_elf_check_relocs): Delete dead code.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-bfin.c (bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (_frvfdpic_check_discarded_relocs): Likewise.
	(elf32_frv_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	(score_elf_local_relocation_p): Likewise.
	(_bfd_score_elf_relocate_section): Likewise.
	(score_elf_final_link_relocate): Likewise.
@
text
@d3141 3
d5769 3
@


1.152
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d4838 1
a4838 1
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
a4857 3
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof (Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
@


1.151
log
@Switch sources over to use the GPL version 3
@
text
@d4962 3
a4964 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.150
log
@bfd:
	* elf-attrs.c: New.
	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
	(elf-attrs.lo): Generate dependencies.
	* Makefile.in: Regenerate.
	* configure.in (elf): Add elf-attrs.lo.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add entries for object
	attributes.
	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
	New.
	(struct elf_obj_tdata): Add entries for object attributes.
	(elf_known_obj_attributes, elf_other_obj_attributes,
	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
	New.
	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
	(bfd_section_from_shdr): Handle attributes sections.
	* elflink.c (bfd_elf_final_link): Handle attributes sections.
	* elfxx-target.h (elf_backend_obj_attrs_vendor,
	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	(elfNN_bed): Update.
	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
	aeabi_attribute_list): Remove.
	(struct elf32_arm_obj_tdata): Remove object attributes fields.
	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
	Update for new object attributes interfaces.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
	elf32_arm_add_eabi_attr_int, attr_strdup,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
	to generic code in elf-attrs.c.
	(elf32_arm_obj_attrs_arg_type): New.
	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
	(bfd_elf32_bfd_final_link): Remove.
	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
	attributes.
	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.

binutils:
	* readelf.c (display_gnu_attribute): New.
	(process_arm_specific): Rearrange as process_attributes.
	(process_arm_specific): Replace by wrapper of process_attributes.

gas:
	* as.c (create_obj_attrs_section): New.
	(main): Call create_obj_attrs_section for ELF.
	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
	skip_past_comma, s_vendor_attribute): New.
	(potable): Add gnu_attribute for ELF.
	* read.h (s_vendor_attribute): Declare.
	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
	round s_vendor_attribute.
	(aeabi_set_public_attributes): Update for new attributes
	interfaces.
	(arm_md_end): Remove attributes contents setting now done
	generically.

include/elf:
	* arm.h (elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
	Tag_Symbol, Tag_compatibility): Remove.
	* common.h (SHT_GNU_ATTRIBUTES): Define.

ld:
	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
	(ATTRS_SECTIONS): Define.
	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.149
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d5359 3
@


1.148
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@a2491 1
  unsigned int power_of_two;
d2615 1
a2615 22
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (htab->root.dynobj, s))
    {
      if (! bfd_set_section_alignment (htab->root.dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
@


1.147
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d22 1
a23 1
#include "sysdep.h"
@


1.146
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d405 29
d6042 2
@


1.145
log
@bfd/
	* libbfd-in.h (_bfd_clear_contents): New prototype.
	* reloc.c (_bfd_clear_contents): New.
	* libbfd.h: Regenerated.

	* elf32-arm.c (elf32_arm_final_link_relocate): Use
	_bfd_clear_contents.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set value to
	zero for discarded symbols.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
ld/testsuite/
	* ld-discard/zero-rel.d, ld-discard/zero-rel.s: New files.
@
text
@d3 1
a3 1
   2006 Free Software Foundation, Inc.
d3243 5
a3247 1
	  if (info->relocatable)
a3252 1
	      sym = local_syms + r_symndx;
d3261 1
a3261 1
		      rel->r_addend += sec->output_offset + sym->st_value;
d3316 1
a3316 6
	  /* Section symbol are never (?) placed in the hash table, so
	     we can just ignore hash relocations when creating a
	     relocatable object file.  */
	  if (info->relocatable)
	    continue;

d3387 11
a3397 2
		relocation = 0;
	      else if (sec->output_section == NULL)
a3407 9
	      else
		relocation = ((h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset)
			      /* A STO_SH5_ISA32 causes a "bitor 1" to the
				 symbol value, unless we've seen
				 STT_DATALABEL on the way to it.  */
			      | ((h->other & STO_SH5_ISA32) != 0
				 && ! seen_stt_datalabel));
d3410 1
a3410 1
	    relocation = 0;
d3413 2
a3414 2
	    relocation = 0;
	  else
a3421 1
	      relocation = 0;
d3425 14
a3570 9
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	  if (r_symndx == 0)
	    {
	      _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	      continue;
	    }

@


1.144
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d3560 9
@


1.143
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d6031 2
@


1.142
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d4518 3
a4520 2
		     struct bfd_link_info *info ATTRIBUTE_UNUSED,
		     Elf_Internal_Rela *rel, struct elf_link_hash_entry *h,
d4524 6
a4529 29
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_SH_GNU_VTINHERIT:
	case R_SH_GNU_VTENTRY:
	  break;

	default:
#ifdef INCLUDE_SHMEDIA
	  while (h->root.type == bfd_link_hash_indirect
		 && h->root.u.i.link)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
#endif
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d4531 1
a4531 1
  return NULL;
@


1.141
log
@* elf32-sh.c (sh_elf_relax_section): Allow for branches across
non-moving .align directives.  Preserve any DIR32 offset when
converting bsr's to jsr's.
@
text
@d3045 1
a3045 1
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
d3588 1
a3588 1
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
d4314 1
a4314 1
		BFD_ASSERT (strncmp (name, ".rela", 5) == 0
d5203 1
a5203 1
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
@


1.140
log
@* elf32-sh.c (vxworks_object_p): Only check for vxworks target vectors if
  they are going to be created.
@
text
@d617 5
a621 1
      if (foff < -0x1000 || foff >= 0x1000)
d659 6
@


1.139
log
@bfd/
2006-08-02  Richard Sandiford  <richard@@codesourcery.com>
	    Kazu Hirata  <kazu@@codesourcery.com>
	    Phil Edwards  <phil@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* config.bfd (sh-*-vxworks): Use bfd_elf32_shvxworks_vec and
	bfd_elf32_shlvxworks_vec.
	* configure.in (bfd_elf32_sh64_vec): Add elf-vxworks.lo.
	(bfd_elf32_sh64l_vec, bfd_elf32_sh64lin_vec): Likewise.
	(bfd_elf32_sh64blin_vec, bfd_elf32_sh64lnbsd_vec): Likewise.
	(bfd_elf32_sh64nbsd_vec, bfd_elf32_sh_vec): Likewise.
	(bfd_elf32_shblin_vec, bfd_elf32_shl_vec): Likewise.
	(bfd_elf32_shl_symbian_vec, bfd_elf32_shlin_vec): Likewise.
	(bfd_elf32_shlnbsd_vec, bfd_elf32_shnbsd_vec): Likewise.
	(bfd_elf32_shlvxworks_vec, bfd_elf32_shvxworks_vec): New stanzas.
	* configure: Regenerate.
	* Makefile.am: Regenerate dependencies.
	* Makefile.in: Regenerate.
	* elf-vxworks.c (elf_vxworks_gott_symbol_p): New function.
	(elf_vxworks_add_symbol_hook): Use it.
	(elf_vxworks_link_output_symbol_hook): Likewise.  Use the hash
	table entry to check for weak undefined symbols and to obtain
	the original bfd.
	(elf_vxworks_emit_relocs): Use target_index instead of this_idx.
	* elf32-sh-relocs.h: New file, split from elf32-sh.c.
	(R_SH_DIR32): Use SH_PARTIAL32 for the partial_inplace field,
	SH_SRC_MASK32 for the src_mask field, and SH_ELF_RELOC for the
	special_function field.
	(R_SH_REL32): Use SH_PARTIAL32 and SH_SRC_MASK32 here too.
	(R_SH_REL32, R_SH_TLS_GD_32, R_SH_TLS_LD_32): Likewise.
	(R_SH_TLS_LDO_32, R_SH_TLS_IE_32, R_SH_TLS_LE_32): Likewise.
	(R_SH_TLS_DTPMOD32, R_SH_TLS_DTPOFF32, R_SH_TLS_TPOFF32): Likewise.
	(R_SH_GOT32, R_SH_PLT32, R_SH_COPY, R_SH_GLOB_DAT): Likewise.
	(R_SH_JMP_SLOT, R_SH_RELATIVE, R_SH_GOTOFF, R_SH_GOTPC): Likewise.
	(SH_PARTIAL32, SH_SRC_MASK32, SH_ELF_RELOC): Undefine at end of file.
	* elf32-sh.c: Include elf32-vxworks.h.
	(MINUS_ONE): Define.
	(sh_elf_howto_table): Include elf32-sh-relocs.h with SH_PARTIAL32
	set to TRUE, SH_SRC_MASK32 set to 0xffffffff, and SH_ELF_RELOC set
	to sh_elf_reloc.
	(sh_vxworks_howto_table): New variable.  Include elf32-sh-relocs.h
	with SH_PARTIAL32 set to FALSE, SH_SRC_MASK32 set to 0, and
	SH_ELF_RELOC set to bfd_elf_generic_reloc.
	(vxworks_object_p, get_howto_table): New functions.
	(sh_elf_reloc_type_lookup): Fix typo.  Use get_howto_table.
	(sh_elf_info_to_howto): Use get_howto_table.
	(sh_elf_relax_section): Honor the partial_inplace field of the
	R_SH_DIR32 howto.
	(sh_elf_relax_delete_bytes): Likewise.
	(elf_sh_plt_info): New structure.
	(PLT_ENTRY_SIZE): Replace both definitions with...
	(ELF_PLT_ENTRY_SIZE): ...this new macro, with separate definitions for
	INCLUDE_SHMEDIA and !INCLUDE_SHMEDIA.
	(elf_sh_plt0_entry_be): Update sizes of both definitions accordingly.
	(elf_sh_plt0_entry_le): Likewise.
	(elf_sh_plt_entry_be, elf_sh_plt_entry_le): Likewise.
	(elf_sh_pic_plt_entry_be, elf_sh_pic_plt_entry_le): Likewise.
	(elf_sh_plts): New structure, with separate definitions for
	INCLUDE_SHMEDIA and !INCLUDE_SHMEDIA.
	(elf_sh_plt0_entry): Delete both definitions.
	(elf_sh_plt_entry, elf_sh_pic_plt_entry): Likewise.
	(elf_sh_sizeof_plt, elf_sh_plt_plt0_offset): Likewise.
	(elf_sh_plt_temp_offset, elf_sh_plt_symbol_offset): Likewise.
	(elf_sh_plt_reloc_offset): Likewise.
	(movi_shori_putval): Delete in favor of...
	(install_plt_field): ...this new function, with separate definitions
	for INCLUDE_SHMEDIA and !INCLUDE_SHMEDIA.
	(get_plt_info): New function, with separate definitions
	for INCLUDE_SHMEDIA and !INCLUDE_SHMEDIA.
	(elf_sh_plt0_linker_offset, elf_sh_plt0_gotid_offset): Delete.
	(VXWORKS_PLT_HEADER_SIZE, VXWORKS_PLT_ENTRY_SIZE): New macros.
	(vxworks_sh_plt0_entry_be, vxworks_sh_plt0_entry_le): New constants.
	(vxworks_sh_plt_entry_be, vxworks_sh_plt_entry_le): Likewise.
	(vxworks_sh_pic_plt_entry_be, vxworks_sh_pic_plt_entry_le): Likewise.
	(get_plt_index, get_plt_offset): New functions.
	(elf_sh_link_hash_table): Add srelplt2, plt_info and vxworks_p fields.
	(sh_elf_link_hash_table_create): Initialize them.
	(sh_elf_create_dynamic_sections): Call
	elf_vxworks_create_dynamic_sections for VxWorks.
	(allocate_dynrelocs): Use htab->plt_info to get the size of PLT
	entries.  Allocate relocation entries in .rela.plt.unloaded if
	generating a VxWorks executable.
	(sh_elf_always_size_sections): New function.
	(sh_elf_size_dynamic_sections): Extend .rela.plt handling to
	.rela.plt.unloaded.
	(sh_elf_relocate_section): Use get_howto_table.  Honor
	partial_inplace when calculating the addend for dynamic
	relocations.  Use get_plt_index.
	(sh_elf_finish_dynamic_symbol): Use get_plt_index, install_plt_field
	and htab->plt_info.  Fill in the bra .plt offset for VxWorks
	executables.  Populate .rela.plt.unloaded.  Do not make
	_GLOBAL_OFFSET_TABLE_ absolute on VxWorks.
	(sh_elf_finish_dynamic_sections): Use install_plt_field and
	htab->plt_info.  Handle cases where there is no special PLT header.
	Populate the first relocation in .rela.plt.unloaded and fix up
	the remaining entries.
	(sh_elf_plt_sym_val): Use get_plt_info.
	(elf_backend_always_size_sections): Define.
	(TARGET_BIG_SYM, TARGET_BIG_NAME): Override for VxWorks.
	(TARGET_LITTLE_SYM, TARGET_BIG_SYM): Likewise.
	(elf32_bed, elf_backend_want_plt_sym): Likewise.
	(elf_symbol_leading_char, elf_backend_want_got_underscore): Likewise.
	(elf_backend_grok_prstatus, elf_backend_grok_psinfo): Likewise.
	(elf_backend_add_symbol_hook): Likewise.
	(elf_backend_link_output_symbol_hook): Likewise.
	(elf_backend_emit_relocs): Likewise.
	(elf_backend_final_write_processing): Likewise.
	(ELF_MAXPAGESIZE, ELF_COMMONPAGESIZE): Likewise.
	* targets.c (bfd_elf32_shlvxworks_vec): Declare.
	(bfd_elf32_shvxworks_vec): Likewise.
	(_bfd_target_vector): Include bfd_elf32_shlvxworks_vec and
	bfd_elf32_shvxworks_vec.

gas/
	* config/tc-sh.c (apply_full_field_fix): New function.
	(md_apply_fix): Use it instead of md_number_to_chars.  Do not fill
	in fx_addnumber for BFD_RELOC_32_PLT_PCREL.
	(tc_gen_reloc): Use fx_addnumber rather than 0 as the default case.
	* config/tc-sh.h (TARGET_FORMAT): Override for TE_VXWORKS.

ld/
2006-08-02  Richard Sandiford  <richard@@codesourcery.com>
	    Kazu Hirata  <kazu@@codesourcery.com>
	    Phil Edwards  <phil@@codesourcery.com>

	* Makefile.am (ALL_EMULATIONS): Add eshelf_vxworks.o and
	eshlelf_vxworks.o.
	(eshelf_vxworks.c, eshlelf_vxworks.c): New rules.
	* Makefile.in: Regenerate.
	* configure.tgt (sh-*-vxworks): Use shelf_vxworks and
	shlelf_vxworks.
	* emulparams/shelf_vxworks.sh: New file.
	* emulparams/shlelf_vxworks.sh: Likewise.
	* emulparams/vxworks.sh (FINI): Prefix _etext with ${SYMPREFIX}.
	(OTHER_END_SYMBOLS): Likewise _ehdr.
	(DATA_END_SYMBOLS): Likewise _edata.
	* emultempl/vxworks.em (vxworks_after_open): Check whether output_bfd
	is indeed an ELF file before dealing with --force-dynamic.

ld/testsuite/
	* ld-sh/rd-sh.exp: Treat vxworks1-static.d specially.
	* ld-sh/sh-vxworks.exp: New file.
	* ld-sh/sh.exp: Extend sh-linux SIZEOF_HEADERS handling to
	sh-*-vxworks.
	* ld-sh/vxworks1-le.dd, ld-sh/vxworks1-lib-le.dd,
	* ld-sh/vxworks1-lib.dd, ld-sh/vxworks1-lib.nd,
	* ld-sh/vxworks1-lib.rd, ld-sh/vxworks1-lib.s,
	* ld-sh/vxworks1-static.d, ld-sh/vxworks1.dd,
	* ld-sh/vxworks1.ld, ld-sh/vxworks1.rd, ld-sh/vxworks1.s,
	* ld-sh/vxworks2-static.sd, ld-sh/vxworks2.s,
	* ld-sh/vxworks2.sd, ld-sh/vxworks3-le.dd,
	* ld-sh/vxworks3-lib-le.dd, ld-sh/vxworks3-lib.dd,
	* ld-sh/vxworks3-lib.s, ld-sh/vxworks3.dd, ld-sh/vxworks3.s,
	* ld-sh/vxworks4.d, ld-sh/vxworks4a.s, ld-sh/vxworks4b.s,
	* ld-sh/reloc1.s, ld-sh/reloc1.d: New tests.
@
text
@d77 1
a77 1
vxworks_object_p (bfd *abfd)
d79 1
d85 3
@


1.138
log
@	PR ld/2754
	* elf.c (bfd_elf_mkobject): Don't alloc if already done.  Set
	program_header_size to -1.
	(_bfd_elf_map_sections_to_segments): Adjust program_header_size check.
	(assign_file_positions_for_load_sections ): Likewise.
	(_bfd_elf_sizeof_headers): Use saved program_header_size if
	available.
	* elf32-arm.c (elf32_arm_mkobject): Call bfd_elf_mkobject, don't
	alloc if already done.
	* elf32-i386.c (elf_i386_mkobject): Likewise.
	* elf32-ppc.c (ppc_elf_mkobject): Likewise.
	* elf32-s390.c (elf_s390_mkobject): Likewise.
	* elf32-sh.c (sh_elf_mkobject): Likewise.
	* elf64-alpha.c (elf64_alpha_mkobject): Likewise.
	* elf64-ppc.c (ppc64_elf_mkobject): Likewise.
	* elf64-s390.c (elf_s390_mkobject): Likewise.
	* elf64-x86-64.c (elf64_x86_64_mkobject): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_mkobject): Likewise.
@
text
@d27 1
d56 5
d63 22
a84 663
  /* No relocation.  */
  HOWTO (R_SH_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit absolute relocation.  Setting partial_inplace to TRUE and
     src_mask to a non-zero value is similar to the COFF toolchain.  */
  HOWTO (R_SH_DIR32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_elf_reloc,		/* special_function */
	 "R_SH_DIR32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit PC relative relocation.  */
  HOWTO (R_SH_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_REL32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 8 bit PC relative branch divided by 2.  */
  HOWTO (R_SH_DIR8WPN,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_DIR8WPN",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 12 bit PC relative branch divided by 2.  */
  /* This cannot be partial_inplace because relaxation can't know the
     eventual value of a symbol.  */
  HOWTO (R_SH_IND12W,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_SH_IND12W",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xfff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 8 bit unsigned PC relative divided by 4.  */
  HOWTO (R_SH_DIR8WPL,		/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_DIR8WPL",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 8 bit unsigned PC relative divided by 2.  */
  HOWTO (R_SH_DIR8WPZ,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_DIR8WPZ",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 8 bit GBR relative.  FIXME: This only makes sense if we have some
     special symbol for the GBR relative area, and that is not
     implemented.  */
  HOWTO (R_SH_DIR8BP,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_DIR8BP",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 8 bit GBR relative divided by 2.  FIXME: This only makes sense if
     we have some special symbol for the GBR relative area, and that
     is not implemented.  */
  HOWTO (R_SH_DIR8W,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_DIR8W",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 8 bit GBR relative divided by 4.  FIXME: This only makes sense if
     we have some special symbol for the GBR relative area, and that
     is not implemented.  */
  HOWTO (R_SH_DIR8L,		/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_DIR8L",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 8 bit PC relative divided by 2 - but specified in a very odd way.  */
  HOWTO (R_SH_LOOP_START,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_LOOP_START",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 8 bit PC relative divided by 2 - but specified in a very odd way.  */
  HOWTO (R_SH_LOOP_END,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_LOOP_END",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  EMPTY_HOWTO (12),
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  EMPTY_HOWTO (20),
  EMPTY_HOWTO (21),

  /* The remaining relocs are a GNU extension used for relaxing.  The
     final pass of the linker never needs to do anything with any of
     these relocs.  Any required operations are handled by the
     relaxation code.  */

  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_SH_GNU_VTINHERIT, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_SH_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_SH_GNU_VTENTRY,     /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn,	/* special_function */
	 "R_SH_GNU_VTENTRY",   /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An 8 bit switch table entry.  This is generated for an expression
     such as ``.word L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_SH_SWITCH8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_SWITCH8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 16 bit switch table entry.  This is generated for an expression
     such as ``.word L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_SH_SWITCH16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_SWITCH16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 32 bit switch table entry.  This is generated for an expression
     such as ``.long L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_SH_SWITCH32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_SWITCH32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Indicates a .uses pseudo-op.  The compiler will generate .uses
     pseudo-ops when it finds a function call which can be relaxed.
     The offset field holds the PC relative offset to the instruction
     which loads the register used in the function call.  */
  HOWTO (R_SH_USES,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_USES",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The assembler will generate this reloc for addresses referred to
     by the register loads associated with USES relocs.  The offset
     field holds the number of times the address is referenced in the
     object file.  */
  HOWTO (R_SH_COUNT,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_COUNT",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Indicates an alignment statement.  The offset field is the power
     of 2 to which subsequent portions of the object file must be
     aligned.  */
  HOWTO (R_SH_ALIGN,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_ALIGN",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The assembler will generate this reloc before a block of
     instructions.  A section should be processed as assuming it
     contains data, unless this reloc is seen.  */
  HOWTO (R_SH_CODE,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_CODE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The assembler will generate this reloc after a block of
     instructions when it sees data that is not instructions.  */
  HOWTO (R_SH_DATA,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_DATA",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The assembler generates this reloc for each label within a block
     of instructions.  This permits the linker to avoid swapping
     instructions which are the targets of branches.  */
  HOWTO (R_SH_LABEL,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_LABEL",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The next 12 are only supported via linking in SHC-generated objects.  */
  HOWTO (R_SH_DIR16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR8UL,		/* type */
	 2,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8UL",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR8UW,		/* type */
	 1,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8UW",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR8U,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8U",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR8SW,		/* type */
	 1,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8SW",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR8S,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8S",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR4UL,		/* type */
	 2,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 4,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR4UL",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR4UW,		/* type */
	 1,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 4,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR4UW",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR4U,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 4,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR4U",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_PSHA,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 FALSE,			/* pc_relative */
	 4,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PSHA",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_PSHL,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 FALSE,			/* pc_relative */
	 4,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PSHL",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

#ifdef INCLUDE_SHMEDIA
  /* Used in SHLLI.L and SHLRI.L.  */
  HOWTO (R_SH_DIR5U,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 5,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR5U",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in SHARI, SHLLI et al.  */
  HOWTO (R_SH_DIR6U,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR6U",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in BxxI, LDHI.L et al.  */
  HOWTO (R_SH_DIR6S,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR6S",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in ADDI, ANDI et al.  */
  HOWTO (R_SH_DIR10S,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR10S",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in LD.UW, ST.W et al.	 */
  HOWTO (R_SH_DIR10SW,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 11,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR10SW",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in LD.L, FLD.S et al.	 */
  HOWTO (R_SH_DIR10SL,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR10SL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in FLD.D, FST.P et al.  */
  HOWTO (R_SH_DIR10SQ,	/* type */
	 3,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR10SQ",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d86 1
a86 1046
#else
  EMPTY_HOWTO (45),
  EMPTY_HOWTO (46),
  EMPTY_HOWTO (47),
  EMPTY_HOWTO (48),
  EMPTY_HOWTO (49),
  EMPTY_HOWTO (50),
  EMPTY_HOWTO (51),
#endif

  EMPTY_HOWTO (52),

  HOWTO (R_SH_DIR16S,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR16S",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (54),
  EMPTY_HOWTO (55),
  EMPTY_HOWTO (56),
  EMPTY_HOWTO (57),
  EMPTY_HOWTO (58),
  EMPTY_HOWTO (59),
  EMPTY_HOWTO (60),
  EMPTY_HOWTO (61),
  EMPTY_HOWTO (62),
  EMPTY_HOWTO (63),
  EMPTY_HOWTO (64),
  EMPTY_HOWTO (65),
  EMPTY_HOWTO (66),
  EMPTY_HOWTO (67),
  EMPTY_HOWTO (68),
  EMPTY_HOWTO (69),
  EMPTY_HOWTO (70),
  EMPTY_HOWTO (71),
  EMPTY_HOWTO (72),
  EMPTY_HOWTO (73),
  EMPTY_HOWTO (74),
  EMPTY_HOWTO (75),
  EMPTY_HOWTO (76),
  EMPTY_HOWTO (77),
  EMPTY_HOWTO (78),
  EMPTY_HOWTO (79),
  EMPTY_HOWTO (80),
  EMPTY_HOWTO (81),
  EMPTY_HOWTO (82),
  EMPTY_HOWTO (83),
  EMPTY_HOWTO (84),
  EMPTY_HOWTO (85),
  EMPTY_HOWTO (86),
  EMPTY_HOWTO (87),
  EMPTY_HOWTO (88),
  EMPTY_HOWTO (89),
  EMPTY_HOWTO (90),
  EMPTY_HOWTO (91),
  EMPTY_HOWTO (92),
  EMPTY_HOWTO (93),
  EMPTY_HOWTO (94),
  EMPTY_HOWTO (95),
  EMPTY_HOWTO (96),
  EMPTY_HOWTO (97),
  EMPTY_HOWTO (98),
  EMPTY_HOWTO (99),
  EMPTY_HOWTO (100),
  EMPTY_HOWTO (101),
  EMPTY_HOWTO (102),
  EMPTY_HOWTO (103),
  EMPTY_HOWTO (104),
  EMPTY_HOWTO (105),
  EMPTY_HOWTO (106),
  EMPTY_HOWTO (107),
  EMPTY_HOWTO (108),
  EMPTY_HOWTO (109),
  EMPTY_HOWTO (110),
  EMPTY_HOWTO (111),
  EMPTY_HOWTO (112),
  EMPTY_HOWTO (113),
  EMPTY_HOWTO (114),
  EMPTY_HOWTO (115),
  EMPTY_HOWTO (116),
  EMPTY_HOWTO (117),
  EMPTY_HOWTO (118),
  EMPTY_HOWTO (119),
  EMPTY_HOWTO (120),
  EMPTY_HOWTO (121),
  EMPTY_HOWTO (122),
  EMPTY_HOWTO (123),
  EMPTY_HOWTO (124),
  EMPTY_HOWTO (125),
  EMPTY_HOWTO (126),
  EMPTY_HOWTO (127),
  EMPTY_HOWTO (128),
  EMPTY_HOWTO (129),
  EMPTY_HOWTO (130),
  EMPTY_HOWTO (131),
  EMPTY_HOWTO (132),
  EMPTY_HOWTO (133),
  EMPTY_HOWTO (134),
  EMPTY_HOWTO (135),
  EMPTY_HOWTO (136),
  EMPTY_HOWTO (137),
  EMPTY_HOWTO (138),
  EMPTY_HOWTO (139),
  EMPTY_HOWTO (140),
  EMPTY_HOWTO (141),
  EMPTY_HOWTO (142),
  EMPTY_HOWTO (143),

  HOWTO (R_SH_TLS_GD_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_GD_32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LD_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LD_32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LDO_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LDO_32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_TLS_IE_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_IE_32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LE_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LE_32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_TLS_DTPMOD32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_DTPMOD32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_TLS_DTPOFF32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_DTPOFF32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_TLS_TPOFF32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_TPOFF32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (152),
  EMPTY_HOWTO (153),
  EMPTY_HOWTO (154),
  EMPTY_HOWTO (155),
  EMPTY_HOWTO (156),
  EMPTY_HOWTO (157),
  EMPTY_HOWTO (158),
  EMPTY_HOWTO (159),

  HOWTO (R_SH_GOT32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_GOT32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_PLT32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_PLT32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_SH_COPY,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_COPY",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_GLOB_DAT,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_GLOB_DAT",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_JMP_SLOT,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_JMP_SLOT",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_RELATIVE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_RELATIVE",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_GOTOFF,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_GOTOFF",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_GOTPC,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_GOTPC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_SH_GOTPLT32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_GOTPLT32",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

#ifdef INCLUDE_SHMEDIA
  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_GOT_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT_LOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_GOT_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT_MEDLOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_GOT_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_GOT_HI16,		/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_GOTPLT_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT_LOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_GOTPLT_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT_MEDLOW16", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_GOTPLT_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_GOTPLT_HI16,	/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_PLT_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PLT_LOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_PLT_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PLT_MEDLOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_PLT_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PLT_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_PLT_HI16,		/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PLT_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_GOTOFF_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTOFF_LOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_GOTOFF_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTOFF_MEDLOW16", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_GOTOFF_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTOFF_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_GOTOFF_HI16,	/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTOFF_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_GOTPC_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPC_LOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_GOTPC_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPC_MEDLOW16", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_GOTPC_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPC_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_GOTPC_HI16,	/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPC_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in LD.L, FLD.S et al.	 */
  HOWTO (R_SH_GOT10BY4,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT10BY4",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in LD.L, FLD.S et al.	 */
  HOWTO (R_SH_GOTPLT10BY4,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT10BY4",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in FLD.D, FST.P et al.  */
  HOWTO (R_SH_GOT10BY8,		/* type */
	 3,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT10BY8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in FLD.D, FST.P et al.  */
  HOWTO (R_SH_GOTPLT10BY8,	/* type */
	 3,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT10BY8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_COPY64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_COPY64",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_GLOB_DAT64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GLOB_DAT64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_JMP_SLOT64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_JMP_SLOT64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_RELATIVE64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_RELATIVE64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (197),
  EMPTY_HOWTO (198),
  EMPTY_HOWTO (199),
  EMPTY_HOWTO (200),
  EMPTY_HOWTO (201),
  EMPTY_HOWTO (202),
  EMPTY_HOWTO (203),
  EMPTY_HOWTO (204),
  EMPTY_HOWTO (205),
  EMPTY_HOWTO (206),
  EMPTY_HOWTO (207),
  EMPTY_HOWTO (208),
  EMPTY_HOWTO (209),
  EMPTY_HOWTO (210),
  EMPTY_HOWTO (211),
  EMPTY_HOWTO (212),
  EMPTY_HOWTO (213),
  EMPTY_HOWTO (214),
  EMPTY_HOWTO (215),
  EMPTY_HOWTO (216),
  EMPTY_HOWTO (217),
  EMPTY_HOWTO (218),
  EMPTY_HOWTO (219),
  EMPTY_HOWTO (220),
  EMPTY_HOWTO (221),
  EMPTY_HOWTO (222),
  EMPTY_HOWTO (223),
  EMPTY_HOWTO (224),
  EMPTY_HOWTO (225),
  EMPTY_HOWTO (226),
  EMPTY_HOWTO (227),
  EMPTY_HOWTO (228),
  EMPTY_HOWTO (229),
  EMPTY_HOWTO (230),
  EMPTY_HOWTO (231),
  EMPTY_HOWTO (232),
  EMPTY_HOWTO (233),
  EMPTY_HOWTO (234),
  EMPTY_HOWTO (235),
  EMPTY_HOWTO (236),
  EMPTY_HOWTO (237),
  EMPTY_HOWTO (238),
  EMPTY_HOWTO (239),
  EMPTY_HOWTO (240),
  EMPTY_HOWTO (241),

  /* Relocations for SHmedia code.  None of these are partial_inplace or
     use the field being relocated (except R_SH_PT_16).  */

  /* The assembler will generate this reloc before a block of SHmedia
     instructions.  A section should be processed as assuming it contains
     data, unless this reloc is seen.  Note that a block of SHcompact
     instructions are instead preceded by R_SH_CODE.
     This is currently not implemented, but should be used for SHmedia
     linker relaxation.  */
  HOWTO (R_SH_SHMEDIA_CODE,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_SHMEDIA_CODE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The assembler will generate this reloc at a PTA or PTB instruction,
     and the linker checks the right type of target, or changes a PTA to a
     PTB, if the original insn was PT.  */
  HOWTO (R_SH_PT_16,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 18,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PT_16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in unexpanded MOVI.  */
  HOWTO (R_SH_IMMS16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMMS16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in SHORI.  */
  HOWTO (R_SH_IMMU16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMMU16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_IMM_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_LOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI ((x - $) & 65536).  */
  HOWTO (R_SH_IMM_LOW16_PCREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_LOW16_PCREL", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_IMM_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_MEDLOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI (((x - $) >> 16) & 65536).  */
  HOWTO (R_SH_IMM_MEDLOW16_PCREL, /* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_MEDLOW16_PCREL", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_IMM_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI (((x - $) >> 32) & 65536).  */
  HOWTO (R_SH_IMM_MEDHI16_PCREL, /* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_MEDHI16_PCREL", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_IMM_HI16,		/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used in MOVI and SHORI (((x - $) >> 48) & 65536).  */
  HOWTO (R_SH_IMM_HI16_PCREL,	/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_HI16_PCREL", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* For the .uaquad pseudo.  */
  HOWTO (R_SH_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_64",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* For the .uaquad pseudo, (x - $).  */
  HOWTO (R_SH_64_PCREL,		/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_64_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 TRUE),			/* pcrel_offset */
d88 7
a94 2
#endif
};
d385 1
a385 1
   corresponding SH ELf reloc.  */
d388 1
a388 2
sh_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			  bfd_reloc_code_real_type code)
d395 1
a395 1
	return &sh_elf_howto_table[(int) sh_reloc_map[i].elf_reloc_val];
d404 1
a404 2
sh_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
		      Elf_Internal_Rela *dst)
d417 1
a417 1
  cache_ptr->howto = &sh_elf_howto_table[r];
d602 4
a605 1
      symval += bfd_get_32 (abfd, contents + paddr);
d920 13
a932 4
		  val = bfd_get_32 (abfd, contents + nraddr);
		  val += isym->st_value;
		  if (val > addr && val < toaddr)
		    bfd_put_32 (abfd, val - count, contents + nraddr);
d1482 35
d1521 1
a1521 1
#define PLT_ENTRY_SIZE 64
d1525 1
a1525 1
static const bfd_byte elf_sh_plt0_entry_be[PLT_ENTRY_SIZE] =
d1545 1
a1545 1
static const bfd_byte elf_sh_plt0_entry_le[PLT_ENTRY_SIZE] =
d1568 1
a1568 1
static const bfd_byte elf_sh_plt_entry_be[PLT_ENTRY_SIZE] =
d1588 1
a1588 1
static const bfd_byte elf_sh_plt_entry_le[PLT_ENTRY_SIZE] =
d1610 1
a1610 1
static const bfd_byte elf_sh_pic_plt_entry_be[PLT_ENTRY_SIZE] =
d1630 1
a1630 1
static const bfd_byte elf_sh_pic_plt_entry_le[PLT_ENTRY_SIZE] =
d1650 46
a1695 9
static const bfd_byte *elf_sh_plt0_entry;
static const bfd_byte *elf_sh_plt_entry;
static const bfd_byte *elf_sh_pic_plt_entry;

/* Return size of a PLT entry.  */
#define elf_sh_sizeof_plt(info) PLT_ENTRY_SIZE

/* Return offset of the PLT0 address in an absolute PLT entry.  */
#define elf_sh_plt_plt0_offset(info) 32
d1700 3
a1702 2
/* Return offset of the trampoline in PLT entry */
#define elf_sh_plt_temp_offset(info) 33 /* Add one because it's SHmedia.  */
d1704 1
a1704 5
/* Return offset of the symbol in PLT entry.  */
#define elf_sh_plt_symbol_offset(info) 0

/* Return offset of the relocation in PLT entry.  */
#define elf_sh_plt_reloc_offset(info) (info->shared ? 52 : 44)
d1707 2
a1708 1
movi_shori_putval (bfd *output_bfd, unsigned long value, bfd_byte *addr)
d1710 1
d1721 8
d1732 1
a1732 1
#define PLT_ENTRY_SIZE 28
d1744 1
a1744 1
static const bfd_byte elf_sh_plt0_entry_be[PLT_ENTRY_SIZE] =
d1760 1
a1760 1
static const bfd_byte elf_sh_plt0_entry_le[PLT_ENTRY_SIZE] =
d1779 1
a1779 1
static const bfd_byte elf_sh_plt_entry_be[PLT_ENTRY_SIZE] =
d1782 1
a1782 1
  0x60, 0x02,	/* mov.l @@r0,r0 */
d1794 1
a1794 1
static const bfd_byte elf_sh_plt_entry_le[PLT_ENTRY_SIZE] =
d1811 1
a1811 1
static const bfd_byte elf_sh_pic_plt_entry_be[PLT_ENTRY_SIZE] =
d1827 1
a1827 1
static const bfd_byte elf_sh_pic_plt_entry_le[PLT_ENTRY_SIZE] =
d1843 95
a1937 3
static const bfd_byte *elf_sh_plt0_entry;
static const bfd_byte *elf_sh_plt_entry;
static const bfd_byte *elf_sh_pic_plt_entry;
d1939 13
a1951 2
/* Return size of a PLT entry.  */
#define elf_sh_sizeof_plt(info) PLT_ENTRY_SIZE
d1953 13
a1965 2
/* Return offset of the PLT0 address in an absolute PLT entry.  */
#define elf_sh_plt_plt0_offset(info) 16
d1967 46
a2012 2
/* Return offset of the linker in PLT0 entry.  */
#define elf_sh_plt0_linker_offset(info) 20
d2014 2
a2015 2
/* Return offset of the GOT id in PLT0 entry.  */
#define elf_sh_plt0_gotid_offset(info) 24
d2017 7
a2023 2
/* Return offset of the temporary in PLT entry */
#define elf_sh_plt_temp_offset(info) 8
d2025 3
a2027 2
/* Return offset of the symbol in PLT entry.  */
#define elf_sh_plt_symbol_offset(info) 20
d2029 6
a2034 2
/* Return offset of the relocation in PLT entry.  */
#define elf_sh_plt_reloc_offset(info) 24
d2037 16
d2144 3
d2156 6
d2240 1
d2243 2
d2426 6
d2654 1
a2654 1
	    s->size += PLT_ENTRY_SIZE;
d2671 1
a2671 1
	  s->size += PLT_ENTRY_SIZE;
d2679 17
d2889 11
d3033 1
a3033 1
	  if (s->size != 0 && s != htab->srelplt)
d3204 1
a3204 1
      howto = sh_elf_howto_table + r_type;
d3603 3
a3605 1
		    = bfd_get_32 (input_bfd, contents + rel->r_offset);
d3626 1
a3626 1
		      relocate = TRUE;
a3627 3
		      outrel.r_addend
			= relocation + bfd_get_32 (input_bfd,
						   contents + rel->r_offset);
a3632 3
		      outrel.r_addend
			= relocation + bfd_get_32 (input_bfd,
						   contents + rel->r_offset);
d3634 5
d3680 2
a3681 2
			+ ((h->plt.offset / elf_sh_sizeof_plt (info)
			    - 1 + 3) * 4));
d5450 1
a5450 1
      plt_index = h->plt.offset / elf_sh_sizeof_plt (info) - 1;
d5463 10
a5472 1
      if (! info->shared)
d5474 1
a5474 9
	  if (elf_sh_plt_entry == NULL)
	    {
	      elf_sh_plt_entry = (bfd_big_endian (output_bfd) ?
				  elf_sh_plt_entry_be : elf_sh_plt_entry_le);
	    }
	  memcpy (splt->contents + h->plt.offset, elf_sh_plt_entry,
		  elf_sh_sizeof_plt (info));
#ifdef INCLUDE_SHMEDIA
	  movi_shori_putval (output_bfd,
d5478 26
a5503 2
			     (splt->contents + h->plt.offset
			      + elf_sh_plt_symbol_offset (info)));
d5505 13
a5517 39
	  /* Set bottom bit because its for a branch to SHmedia */
	  movi_shori_putval (output_bfd,
			     (splt->output_section->vma + splt->output_offset)
			     | 1,
			     (splt->contents + h->plt.offset
			      + elf_sh_plt_plt0_offset (info)));
#else
	  bfd_put_32 (output_bfd,
		      (sgot->output_section->vma
		       + sgot->output_offset
		       + got_offset),
		      (splt->contents + h->plt.offset
		       + elf_sh_plt_symbol_offset (info)));

	  bfd_put_32 (output_bfd,
		      (splt->output_section->vma + splt->output_offset),
		      (splt->contents + h->plt.offset
		       + elf_sh_plt_plt0_offset (info)));
#endif
	}
      else
	{
	  if (elf_sh_pic_plt_entry == NULL)
	    {
	      elf_sh_pic_plt_entry = (bfd_big_endian (output_bfd) ?
				      elf_sh_pic_plt_entry_be :
				      elf_sh_pic_plt_entry_le);
	    }
	  memcpy (splt->contents + h->plt.offset, elf_sh_pic_plt_entry,
		  elf_sh_sizeof_plt (info));
#ifdef INCLUDE_SHMEDIA
	  movi_shori_putval (output_bfd, got_offset,
			     (splt->contents + h->plt.offset
			      + elf_sh_plt_symbol_offset (info)));
#else
	  bfd_put_32 (output_bfd, got_offset,
		      (splt->contents + h->plt.offset
		       + elf_sh_plt_symbol_offset (info)));
#endif
d5525 1
a5525 2
#ifdef INCLUDE_SHMEDIA
      movi_shori_putval (output_bfd,
d5527 3
a5529 7
			 (splt->contents + h->plt.offset
			  + elf_sh_plt_reloc_offset (info)));
#else
      bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rela),
		  (splt->contents + h->plt.offset
		   + elf_sh_plt_reloc_offset (info)));
#endif
d5536 1
a5536 1
		   + elf_sh_plt_temp_offset (info)),
d5551 28
d5708 3
a5710 1
  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
d5712 1
a5712 1
      || h == htab->root.hgot)
d5819 1
a5819 1
      if (splt && splt->size > 0)
d5821 15
a5835 1
	  if (info->shared)
d5837 34
a5870 5
	      if (elf_sh_pic_plt_entry == NULL)
		{
		  elf_sh_pic_plt_entry = (bfd_big_endian (output_bfd) ?
					  elf_sh_pic_plt_entry_be :
					  elf_sh_pic_plt_entry_le);
a5871 26
	      memcpy (splt->contents, elf_sh_pic_plt_entry,
		      elf_sh_sizeof_plt (info));
	    }
	  else
	    {
	      if (elf_sh_plt0_entry == NULL)
		{
		  elf_sh_plt0_entry = (bfd_big_endian (output_bfd) ?
				       elf_sh_plt0_entry_be :
				       elf_sh_plt0_entry_le);
		}
	      memcpy (splt->contents, elf_sh_plt0_entry, PLT_ENTRY_SIZE);
#ifdef INCLUDE_SHMEDIA
	      movi_shori_putval (output_bfd,
				 sgot->output_section->vma
				 + sgot->output_offset,
				 splt->contents
				 + elf_sh_plt0_gotplt_offset (info));
#else
	      bfd_put_32 (output_bfd,
			  sgot->output_section->vma + sgot->output_offset + 4,
			  splt->contents + elf_sh_plt0_gotid_offset (info));
	      bfd_put_32 (output_bfd,
			  sgot->output_section->vma + sgot->output_offset + 8,
			  splt->contents + elf_sh_plt0_linker_offset (info));
#endif
d5986 4
a5989 1
  return plt->vma + (i + 1) * PLT_ENTRY_SIZE;
d6035 2
d6098 34
@


1.137
log
@bfd/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_emul_get_maxpagesize): New.
	(bfd_elf_set_pagesize): Likewise.
	(bfd_emul_set_maxpagesize): Likewise.
	(bfd_emul_get_commonpagesize): Likewise.
	(bfd_emul_set_commonpagesize): Likewise.
	* bfd-in2.h: Regenerated.

	* elf-bfd.h (elf_backend_data): Add commonpagesize.
	(xvec_get_elf_backend_data): New.
	(get_elf_backend_data): Use xvec_get_elf_backend_data.

	* elf32-arm.c (elf32_arm_vxworks_bed): Remove const.
	* elfxx-target.h (elfNN_bed): Likewise.

	* elf32-arm.c (ELF_COMMONPAGESIZE): Defined.
	* elf32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh64.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-alpha.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-x86-64.c (ELF_COMMONPAGESIZE): Likewise.
	* elfn32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elfxx-ia64.c (ELF_COMMONPAGESIZE): Likewise.

	* elfxx-target.h (ELF_COMMONPAGESIZE): Define if not defined.
	(elfNN_bed): Initialize commonpagesize with ELF_COMMONPAGESIZE.

	* targets.c (bfd_find_target): Support NULL abfd.

ld/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/arcelf.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	* emulparams/armelf_nbsd.sh: Likewise.
	* emulparams/armelf_vxworks.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/armsymbian.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32_i960.sh: Likewise.
	* emulparams/elf32am33lin.sh: Likewise.
	* emulparams/elf32bfinfd.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32frvfd.sh: Likewise.
	* emulparams/elf32i370.sh: Likewise.
	* emulparams/elf32lppcnto.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32openrisc.sh: Likewise.
	* emulparams/elf32ppcnto.sh: Likewise.
	* emulparams/elf32ppcwindiss.sh: Likewise.
	* emulparams/elf32vax.sh: Likewise.
	* emulparams/elf32xc16x.sh: Likewise.
	* emulparams/elf32xc16xl.sh: Likewise.
	* emulparams/elf32xc16xs.sh: Likewise.
	* emulparams/elf64_aix.sh: Likewise.
	* emulparams/elf64hppa.sh: Likewise.
	* emulparams/elf64mmix.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* emulparams/hppalinux.sh: Likewise.
	* emulparams/hppaobsd.sh: Likewise.
	* emulparams/i386lynx.sh: Likewise.
	* emulparams/i386moss.sh: Likewise.
	* emulparams/i386nto.sh: Likewise.
	* emulparams/i386nw.sh: Likewise.
	* emulparams/m32relf_linux.sh: Likewise.
	* emulparams/m68kpsos.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/pjlelf.sh: Likewise.
	* emulparams/ppclynx.sh: Likewise.
	* emulparams/ppcnw.sh: Likewise.
	* emulparams/shelf32_nbsd.sh : Likewise.
	* emulparams/shelf_nbsd.sh: Likewise.
	* emulparams/shelf_nto.sh: Likewise.
	* emulparams/shlelf_nto.sh: Likewise.
	* emulparams/xtensa-config.sh: Likewise.

	* emulparams/armelf_linux.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	(COMMONPAGESIZE): Changed to "CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32_sparc.sh: Likewise.
	* emulparams/elf32bmip.sh: Likewise.
	* emulparams/elf32ppccommon.sh: Likewise.
	* emulparams/elf64_ia64.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/shlelf32_linux.sh: Likewise.
	* emulparams/shlelf_linux.sh: Likewise.

	* emulparams/elf32bmipn32.sh (COMMONPAGESIZE): Changed to
	"CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32btsmipn32.sh: Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	"-z max-page-size=" and "-z common-page-size=".
	(gld${EMULATION_NAME}_list_options): Likewise.

	* ld.h (ld_config_type): Add maxpagesize and commonpagesize.

	* ld.texinfo: Document "-z max-page-size=" and
	"-z common-page-size=".

	* ldexp.c (exp_print_token): Handle CONSTANT.
	(fold_name): Likewise.
	* ldgram.y: Likewise.
	* ldlex.l: Likewise.

	* ldmain.c (main): Initiliaze config.maxpagesize and
	config.commonpagesize. Call bfd_emul_set_maxpagesize if
	config.maxpagesize isn't 0. Call bfd_emul_set_commonpagesize if
	config.commonpagesize config.maxpagesize isn't 0.
ld/testsuite/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/binutils.exp: New file.
	* ld-elf/commonpage1.d: Likewise.
	* ld-elf/maxpage1.d: Likewise.
	* ld-elf/maxpage1.s: Likewise.
@
text
@a3520 2
  bfd_size_type amt = sizeof (struct sh_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
d3522 7
a3528 2
    return FALSE;
  return TRUE;
@


1.136
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d7374 1
d7392 2
@


1.135
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d3615 3
a3617 2
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       sh_elf_link_hash_newfunc))
@


1.134
log
@bfd/
	* elf-bfd.h (elf_link_hash_table): Add hplt field.
	* elflink.c (_bfd_elf_create_dynamic_sections): Initialize it.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Likewise.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_create_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_create_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_create_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table): Remove hgot and hplt.
	(elf_i386_link_hash_table_create): Don't initialize them.
	(elf_i386_size_dynamic_sections): Use the generic ELF hplt and
	hgot fields.
	(elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_link_hash_table): Remove hplt.
	(ppc_elf_size_dynamic_sections): Use the generic ELF hplt fields.
	(ppc_elf_finish_dynamic_symbol): Likewise.
@
text
@d7039 1
a7039 1
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
@


1.133
log
@	PR ld/2218
	* elf32-arm.c (allocate_dynrelocs): Ensure undef weak sym in pie
	is dynamic.
	* elf32-hppa.c (allocate_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	* elf32-sh.c (allocate_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	* elf32-m32r.c (allocate_dynrelocs): Likewise.  Discard relocs
	on undef weak with non-default visibility too.
	* elfxx-sparc.c (allocate_dynrelocs): Ditto.
@
text
@d3729 1
@


1.132
log
@	* elf32-sh.c (sh_elf_relocate_section): Don't reset relocation
	for R_SH_REL32 in shared objects if the symbol is locally called.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d4163 1
a4163 1
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
d4165 13
a4177 1
	eh->dyn_relocs = NULL;
@


1.131
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d4696 2
a4697 1
			  || r_type == R_SH_REL32)
@


1.130
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d6066 1
a6066 1
sh_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
a6070 3
#ifdef INCLUDE_SHMEDIA
  bfd_signed_vma tmp;
#endif
d6082 1
a6082 3
	  BFD_ASSERT (ind->root.type != bfd_link_hash_indirect);

	  /* Add reloc counts against the weak sym to the strong sym
d6108 2
a6109 8
  tmp = edir->datalabel_got.refcount;
  if (tmp < 1)
    {
      edir->datalabel_got.refcount = eind->datalabel_got.refcount;
      eind->datalabel_got.refcount = tmp;
    }
  else
    BFD_ASSERT (eind->datalabel_got.refcount < 1);
d6131 1
a6131 1
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.129
log
@	* elf32-sh.c (sh_elf_get_flags_from_mach): Fix off-by-one error.
@
text
@d6568 1
d6576 2
a6577 2
		  head = ((struct elf_sh_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
@


1.128
log
@2005-08-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1208
	* elf-hppa.h (elf_hppa_relocate_section): Print out the name
	of unresolvable relocation.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d6658 1
a6658 1
  int i = ARRAY_SIZE (sh_ef_bfd_table);
@


1.127
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d4717 6
a4722 2
		    (_("%B(%A): unresolvable relocation against symbol `%s'"),
		     input_bfd, input_section, h->root.root.string);
@


1.126
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d3918 7
@


1.125
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d4357 2
a4358 1
	  || s == htab->sgotplt)
d4394 3
@


1.124
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@a6203 1
#ifdef INCLUDE_SHMEDIA
d6207 1
d6209 1
a6211 1
#endif
@


1.123
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3652 6
a3657 1
  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
a3658 7
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC
				   | SEC_LOAD
				   | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY
				   | SEC_LINKER_CREATED
				   | SEC_READONLY))
d3707 1
a3707 1
  s = bfd_make_section (abfd, ".plt");
a3709 1
      || ! bfd_set_section_flags (abfd, s, pltflags)
d3735 3
a3737 2
  s = bfd_make_section (abfd,
			bed->default_use_rela_p ? ".rela.plt" : ".rel.plt");
a3739 1
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d3765 2
a3766 1
	s = bfd_make_section (abfd, relname);
a3767 1
	    || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d3781 2
a3782 1
      s = bfd_make_section (abfd, ".dynbss");
d3784 1
a3784 2
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
d3800 4
a3803 3
	  s = bfd_make_section (abfd,
				(bed->default_use_rela_p
				 ? ".rela.bss" : ".rel.bss"));
a3805 1
	      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
a6530 1
		      sreloc = bfd_make_section (htab->root.dynobj, name);
d6535 3
a6538 2
			  || ! bfd_set_section_flags (htab->root.dynobj,
						      sreloc, flags)
@


1.122
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.121
log
@Update the FSF address in the copyright/GPL notice
@
text
@d4392 1
a4392 1
	  _bfd_strip_section_from_output (info, s);
@


1.120
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.119
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@a34 14
static reloc_howto_type *sh_elf_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type);
static void sh_elf_info_to_howto
  (bfd *, arelent *, Elf_Internal_Rela *);
static bfd_boolean sh_elf_set_private_flags
  (bfd *, flagword);
static bfd_boolean sh_elf_copy_private_data
  (bfd *, bfd *);
static bfd_boolean sh_elf_merge_private_data
  (bfd *, bfd *);
static bfd_boolean sh_elf_set_mach_from_flags
  (bfd *);
static bfd_boolean sh_elf_relax_section
  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
a42 9
static bfd_boolean sh_elf_relocate_section
  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
static bfd_byte *sh_elf_get_relocated_section_contents
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);
static void sh_elf_copy_indirect_symbol
  (const struct elf_backend_data *, struct elf_link_hash_entry *,
   struct elf_link_hash_entry *);
a44 26
static bfd_boolean sh_elf_mkobject
  (bfd *);
static bfd_boolean sh_elf_object_p
  (bfd *);
static bfd_boolean sh_elf_check_relocs
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
static struct bfd_hash_entry *sh_elf_link_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
static struct bfd_link_hash_table *sh_elf_link_hash_table_create
  (bfd *);
static bfd_boolean sh_elf_adjust_dynamic_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *);
static bfd_boolean sh_elf_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
static bfd_boolean sh_elf_finish_dynamic_symbol
  (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
   Elf_Internal_Sym *);
static bfd_boolean sh_elf_finish_dynamic_sections
  (bfd *, struct bfd_link_info *);
static bfd_reloc_status_type sh_elf_reloc_loop
  (int, bfd *, asection *, bfd_byte *, bfd_vma, asection *, bfd_vma,
   bfd_vma);
static bfd_boolean create_got_section
  (bfd *, struct bfd_link_info *);
static bfd_boolean sh_elf_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
a48 20
static asection * sh_elf_gc_mark_hook
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);
static bfd_boolean sh_elf_gc_sweep_hook
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
static bfd_boolean allocate_dynrelocs
  (struct elf_link_hash_entry *, void *);
static bfd_boolean readonly_dynrelocs
  (struct elf_link_hash_entry *, void *);
static enum elf_reloc_type_class sh_elf_reloc_type_class
  (const Elf_Internal_Rela *);
#ifdef INCLUDE_SHMEDIA
inline static void movi_shori_putval (bfd *, unsigned long, char *);
#endif
#if !defined SH_TARGET_ALREADY_DEFINED
static bfd_boolean elf32_shlin_grok_prstatus
  (bfd *abfd, Elf_Internal_Note *note);
static bfd_boolean elf32_shlin_grok_psinfo
  (bfd *abfd, Elf_Internal_Note *note);
#endif
d3303 1
a3303 1
movi_shori_putval (bfd *output_bfd, unsigned long value, char *addr)
@


1.118
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@d2386 6
a2391 18
#if 0
      if (ELF32_R_SYM (irelfn->r_info) < symtab_hdr->sh_info)
	{
	  /* If this needs to be changed because of future relaxing,
	     it will be handled here like other internal IND12W
	     relocs.  */
	  bfd_put_16 (abfd,
		      (bfd_vma) 0xb000 | ((foff >> 1) & 0xfff),
		      contents + irel->r_offset);
	}
      else
#endif
	{
	  /* We can't fully resolve this yet, because the external
	     symbol value may be changed by future relaxing.  We let
	     the final link phase handle it.  */
	  bfd_put_16 (abfd, (bfd_vma) 0xb000, contents + irel->r_offset);
	}
a3390 1
#if 1
a3497 101
#else /* These are the old style PLT entries.  */
static const bfd_byte elf_sh_plt0_entry_be[PLT_ENTRY_SIZE] =
{
  0xd0, 0x04,	/* mov.l 1f,r0 */
  0xd2, 0x05,	/* mov.l 2f,r2 */
  0x60, 0x02,	/* mov.l @@r0,r0 */
  0x62, 0x22,	/* mov.l @@r2,r2 */
  0x40, 0x2b,	/* jmp @@r0 */
  0xe0, 0x00,	/*  mov #0,r0 */
  0x00, 0x09,	/* nop */
  0x00, 0x09,	/* nop */
  0x00, 0x09,	/* nop */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with address of .got.plt + 8.  */
  0, 0, 0, 0,	/* 2: replaced with address of .got.plt + 4.  */
};

static const bfd_byte elf_sh_plt0_entry_le[PLT_ENTRY_SIZE] =
{
  0x04, 0xd0,	/* mov.l 1f,r0 */
  0x05, 0xd2,	/* mov.l 2f,r2 */
  0x02, 0x60,	/* mov.l @@r0,r0 */
  0x22, 0x62,	/* mov.l @@r2,r2 */
  0x2b, 0x40,	/* jmp @@r0 */
  0x00, 0xe0,	/*  mov #0,r0 */
  0x09, 0x00,	/* nop */
  0x09, 0x00,	/* nop */
  0x09, 0x00,	/* nop */
  0x09, 0x00,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with address of .got.plt + 8.  */
  0, 0, 0, 0,	/* 2: replaced with address of .got.plt + 4.  */
};

/* Sebsequent entries in an absolute procedure linkage table look like
   this.  */

static const bfd_byte elf_sh_plt_entry_be[PLT_ENTRY_SIZE] =
{
  0xd0, 0x04,	/* mov.l 1f,r0 */
  0x60, 0x02,	/* mov.l @@r0,r0 */
  0xd2, 0x02,	/* mov.l 0f,r2 */
  0x40, 0x2b,   /* jmp @@r0 */
  0x60, 0x23,	/*  mov r2,r0 */
  0xd1, 0x03,	/* mov.l 2f,r1 */
  0x40, 0x2b,	/* jmp @@r0 */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0,	/* 0: replaced with address of .PLT0.  */
  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
  0, 0, 0, 0,	/* 2: replaced with offset into relocation table.  */
};

static const bfd_byte elf_sh_plt_entry_le[PLT_ENTRY_SIZE] =
{
  0x04, 0xd0,	/* mov.l 1f,r0 */
  0x02, 0x60,	/* mov.l @@r0,r0 */
  0x02, 0xd2,	/* mov.l 0f,r2 */
  0x2b, 0x40,   /* jmp @@r0 */
  0x23, 0x60,	/*  mov r2,r0 */
  0x03, 0xd1,	/* mov.l 2f,r1 */
  0x2b, 0x40,	/* jmp @@r0 */
  0x09, 0x00,	/*  nop */
  0, 0, 0, 0,	/* 0: replaced with address of .PLT.  */
  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
  0, 0, 0, 0,	/* 2: replaced with offset into relocation table.  */
};

/* Entries in a PIC procedure linkage table look like this.  */

static const bfd_byte elf_sh_pic_plt_entry_be[PLT_ENTRY_SIZE] =
{
  0xd0, 0x04,	/* mov.l 1f,r0 */
  0x00, 0xce,	/* mov.l @@(r0,r12),r0 */
  0x40, 0x2b,	/* jmp @@r0 */
  0x00, 0x09,	/*  nop */
  0x50, 0xc2,	/* 0: mov.l @@(8,r12),r0 */
  0x52, 0xc1,	/* 1: mov.l @@(4,r12),r2 */
  0xd1, 0x02,	/* mov.l 2f,r1 */
  0x40, 0x2b,	/* jmp @@r0 */
  0xe0, 0x00,	/*  mov #0,r0 ! shows the type of PLT.  */
  0x00, 0x09,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
  0, 0, 0, 0    /* 2: replaced with offset into relocation table.  */
};

static const bfd_byte elf_sh_pic_plt_entry_le[PLT_ENTRY_SIZE] =
{
  0x04, 0xd0,	/* mov.l 1f,r0 */
  0xce, 0x00,	/* mov.l @@(r0,r12),r0 */
  0x2b, 0x40,	/* jmp @@r0 */
  0x09, 0x00,	/*  nop */
  0xc2, 0x50,	/* 0: mov.l @@(8,r12),r0 */
  0xc1, 0x52,	/* 1: mov.l @@(4,r12),r2 */
  0x02, 0xd1,	/* mov.l 2f,r1 */
  0x2b, 0x40,	/* jmp @@r0 */
  0x00, 0xe0,	/*  mov #0,r0 ! shows the type of PLT.  */
  0x09, 0x00,	/* nop */
  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
  0, 0, 0, 0    /* 2: replaced with offset into relocation table.  */
};
#endif /* old style PLT entries.  */

@


1.117
log
@	* elf32-sh.c (tpoff): Take alignment into account.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a6084 1
#ifdef INCLUDE_SHMEDIA
d6088 1
d6090 1
a6092 1
#endif
@


1.116
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d6005 3
a6007 1
  return address - elf_hash_table (info)->tls_sec->vma + 8;
@


1.115
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d5851 1
a5851 1
		  name = h->root.root.string;
d5862 3
a5864 2
		       (info, name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rel->r_offset)))
@


1.114
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d4021 1
a4021 1
		  || h->weakdef != NULL
d4054 1
a4054 1
  if (h->weakdef != NULL)
d4056 4
a4059 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
d4061 1
a4061 1
	h->non_got_ref = h->weakdef->non_got_ref;
@


1.113
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d3913 1
a3913 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d4020 1
a4020 1
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
d4022 3
a4024 6
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));
d4030 1
a4030 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d4043 1
a4043 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d4061 1
a4061 3
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d4077 1
a4077 1
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
d4083 1
a4083 1
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d4100 1
a4100 1
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d4128 1
a4128 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d4180 1
a4180 1
      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
d4198 1
a4198 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d4222 1
a4222 1
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d4241 1
a4241 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d4247 1
a4247 1
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d4259 1
a4259 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d4297 1
a4297 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d4352 3
a4354 3
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d4362 1
a4362 1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d4860 1
a4860 2
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
d4868 1
a4868 2
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0)
d4870 1
a4870 2
			   && (h->elf_link_hash_flags
			       & ELF_LINK_FORCED_LOCAL) == 0)
d4878 1
a4878 2
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0)))
d4884 1
a4884 2
			  && (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d5131 1
a5131 2
			  && (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) != 0))
d5175 1
a5175 1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d5403 1
a5403 1
	  if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d5456 1
a5456 1
		      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d6299 10
a6308 9
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
d6404 1
a6404 1
	      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d6601 1
a6601 1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d6607 1
a6607 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d6632 1
a6632 1
	  if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d6635 1
a6635 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d6649 1
a6649 1
	      h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d6678 1
a6678 2
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d6683 1
a6683 2
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d7072 1
a7072 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d7176 1
a7176 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
@


1.112
log
@include/elf/ChangeLog:
Introduce SH2a support.
2004-02-18  Corinna Vinschen  <vinschen@@redhat.com>
* sh.h (EF_SH2A_NOFPU): New.
2003-12-01  Michael Snyder  <msnyder@@redhat.com>
* sh.h (EF_SH2A): New.
bfd/ChangeLog:
Introduce SH2a support.
2004-02-18  Corinna Vinschen  <vinschen@@redhat.com>
* archures.c (bfd_mach_sh2a_nofpu): New.
* bfd-in2.h: Rebuilt.
* cpu-sh.c (SH2A_NOFPU_NEXT): New.
(arch_info_struct): Add sh2a_nofpu.
* elf32-sh.c (sh_elf_set_mach_from_flags): Handle sh2a_nofpu.
2003-12-29  DJ Delorie  <dj@@redhat.com>
* reloc.c: Add relocs for sh2a.
* bfd-in2.h: Regenerate.
* libbfd.hh: Regenerate.
2003-12-01  Michael Snyder  <msnyder@@redhat.com>
* archures.c (bfd_mach_sh2a): New.
* bfd-in2.h: Rebuilt.
* cpu-sh.c (SH_NEXT, SH2_NEXT, etc.): Change defines to enums.
(SH2A_NEXT): New.
(arch_info_struct): Add sh2a.
* elf32-sh.c (sh_elf_set_mach_from_flags): Handle sh2a.
binutils/ChangeLog:
* readelf.c (get_machine_flags <EM_SH>): Handle EF_SH2A and
EF_SH2A_NOFPU.
gas/ChangeLog:
Introduce SH2a support.
2004-02-24  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (get_specific): Change arch_sh2a_up to
arch_sh2a_nofpu_up.
2004-02-24  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (md_parse_option): Add sh2a-nofpu ISA handling.
2004-02-20  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (sh_elf_final_processing): Move sh2a recognition
to end of conditional expression.
2004-02-20  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c: Add sh2a-nofpu support.
2003-12-29  DJ Delorie  <dj@@redhat.com>
* tc-sh.c: Add sh2a support.
(parse_reg): Add tbr.
(parse_at): Support @@@@(disp,tbr).
(get_specific): Support sh2a opcodes.
(insert4): New, for 4 byte relocs.
(build_Mytes): Support sh2a opcodes.
(md_apply_fix3_Mytes): Support sh2a opcodes.
2003-12-02  Michael Snyder  <msnyder@@redhat.com>
* config/tc-sh.c (md_parse_option): Handle sh2a.
(sh_elf_final_processing): Ditto.
gas/testsuite/ChangeLog:
2003-12-30  DJ Delorie  <dj@@redhat.com>
* gas/sh/sh2a.s: New.
* gas/sh/sh2a.d: New.
* gas/sh/basic.exp: Add it.
@
text
@d2245 2
a2246 2
	  (*_bfd_error_handler) (_("%s: 0x%lx: warning: bad R_SH_USES offset"),
				 bfd_archive_filename (abfd),
d2257 2
a2258 2
	   (_("%s: 0x%lx: warning: R_SH_USES points to unrecognized insn 0x%x"),
	    bfd_archive_filename (abfd), (unsigned long) irel->r_offset, insn));
d2274 2
a2275 2
	   (_("%s: 0x%lx: warning: bad R_SH_USES load offset"),
	    bfd_archive_filename (abfd), (unsigned long) irel->r_offset));
d2289 2
a2290 2
	   (_("%s: 0x%lx: warning: could not find expected reloc"),
	    bfd_archive_filename (abfd), (unsigned long) paddr));
d2317 2
a2318 2
	       (_("%s: 0x%lx: warning: symbol in unexpected section"),
		bfd_archive_filename (abfd), (unsigned long) paddr));
d2442 2
a2443 2
	   (_("%s: 0x%lx: warning: could not find expected COUNT reloc"),
	    bfd_archive_filename (abfd), (unsigned long) paddr));
d2451 2
a2452 2
	  ((*_bfd_error_handler) (_("%s: 0x%lx: warning: bad count"),
				  bfd_archive_filename (abfd),
d2846 2
a2847 2
	       (_("%s: 0x%lx: fatal: reloc overflow while relaxing"),
		bfd_archive_filename (abfd), (unsigned long) irel->r_offset));
d3216 2
a3217 2
	       (_("%s: 0x%lx: fatal: reloc overflow while relaxing"),
		bfd_archive_filename (abfd), (unsigned long) irel->r_offset));
d4798 2
a4799 3
		    (_("%s(%s+0x%lx): %s relocation against SEC_MERGE section"),
		     bfd_archive_filename (input_bfd),
		     bfd_get_section_name (input_bfd, input_section),
d4902 2
a4903 3
		    (_("%s: unresolvable relocation against symbol `%s' from %s section"),
		     bfd_archive_filename (input_bfd), h->root.root.string,
		     bfd_get_section_name (input_bfd, input_section));
d4972 2
a4973 2
		   (_("%s: 0x%lx: fatal: unaligned branch target for relax-support relocation"),
		    bfd_archive_filename (input_section->owner),
d5005 2
a5006 2
	       (_("%s: 0x%lx: fatal: unaligned %s relocation 0x%lx"),
		bfd_archive_filename (input_section->owner),
d5008 1
a5008 1
		(unsigned long)relocation));
d5020 2
a5021 2
	       (_("%s: 0x%lx: fatal: unaligned %s relocation 0x%lx"),
		bfd_archive_filename (input_section->owner),
d5023 1
a5023 1
		(unsigned long)relocation));
d5034 2
a5035 2
	       (_("%s: 0x%lx: fatal: R_SH_PSHA relocation %d not in range -32..32"),
		bfd_archive_filename (input_section->owner),
d5037 1
a5037 1
		(unsigned long)relocation));
d5048 2
a5049 2
	       (_("%s: 0x%lx: fatal: R_SH_PSHL relocation %d not in range -32..32"),
		bfd_archive_filename (input_section->owner),
d5051 1
a5051 1
		(unsigned long)relocation));
d6578 2
a6579 2
		    (_("%s: `%s' accessed both as normal and thread local symbol"),
		     bfd_archive_filename (abfd), h->root.root.string);
d6790 3
a6792 2
	      (*_bfd_error_handler) (_("%s: TLS local exec code cannot be linked into shared objects"),
				     bfd_archive_filename (abfd));
d6916 1
a6916 1
      _bfd_error_handler ("%s: uses instructions which are incompatible "
d6918 1
a6918 1
			  bfd_archive_filename (ibfd));
@


1.111
log
@Rename sh-symbian-elf toolchain to sh-*-symbianelf
@
text
@d6916 7
a6922 1
    return FALSE;
@


1.110
log
@Add support for sh-symbian-elf target
@
text
@a6835 1
#ifndef SH_TARGET_ALREADY_DEFINED
a6849 1
#endif
a6885 1
#ifndef SH_TARGET_ALREADY_DEFINED
a6893 1
#endif
@


1.109
log
@2004-06-30  Andrew Stubbs <andrew.stubbs@@superh.com>

	bfd:
	* elf32-sh.c: Include ../opcodes/sh-opc.h .
	* Makefile.am: Ran make dep-am .
	* Makefile.in: Ran make dep-in .

	gas:
	* config/tc-sh.c (md_assemble): Change isspace to ISSPACE.
	(md_parse_option): Remove redundant -isa testing.
	Make bfd_arch variable const.
	(md_show_usage): Make bfd_arch variable const.
@
text
@d53 1
d56 1
d112 1
d117 1
d3097 1
d3226 1
d6836 1
d6851 1
d6887 2
d6892 1
d6897 1
a6897 1

d6905 2
d6919 1
a6919 1
  if ( ! sh_merge_bfd_arch (ibfd, obfd) )
d7399 1
d7401 1
d7461 1
d7474 1
d7479 2
d7533 1
a7533 1
#ifndef INCLUDE_SHMEDIA
d7575 1
a7575 1
#endif /* INCLUDE_SHMEDIA */
@


1.108
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d29 1
@


1.107
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a1845 1
  bfd_size_type sz;
d1849 1
a1849 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (addr > sz)
@


1.106
log
@2004-05-28  Andrew Stubbs <andrew.stubbs@@superh.com>

bfd:
	* Makefile.am: Regenerate dependencies.
	* Makefile.in: Regenerate.
	* archures.c: Add bfd_mach_sh3_nommu .
	* bfd-in2.h: Regenerate.
	* cpu-sh.c: Add sh3-nommu architecture.
	(bfd_to_arch_table): Create new table.
	(sh_get_arch_from_bfd_mach): Create new function.
	(sh_get_arch_up_from_bfd_mach): Create new function.
	(sh_merge_bfd_arch): Create new function.
	* elf32-sh.c (sh_ef_bfd_table): Add table.
	(sh_elf_check_relocs): Replace switch statement with
	use of sh_ef_bfd_table .
	(sh_elf_get_flags_from_mach): Add new function.
	(sh_find_elf_flags): Likewise.
	(sh_elf_copy_private_data): Replace most of non-elf contents
	with a call to sh_merge_bfd_arch() .

gas:
	* Makefile.am: Regenerate dependecies.
	* Makefile.in: Regenerate.
	* config/tc-sh.c (valid_arch): Make unsigned.
	(preset_target_arch): Likewise.
	(md_begin): Use new architecture flags system.
	(get_specific): Likewise.
	(assemble_ppi): Likewise.
	(md_assemble): Likewise. Also fix error check for bad opcodes.
	(md_parse_option): Likewise. Also generate -isa values according
	to the table in bfd/cpu-sh.c instead of just constants. Also
	allow <arch>-up ISA variants.
	(sh_elf_final_processing): Replace if-else chain with a call to
	sh_find_elf_flags().
	* testsuite/gas/sh/arch: New directory.
	* testsuite/gas/sh/arch/arch.exp: New test script.
	* testsuite/gas/sh/arch/arch_expected.txt: New file.
	* testsuite/gas/sh/arch/sh.s: New file.
	* testsuite/gas/sh/arch/sh2.s: New file.
	* testsuite/gas/sh/arch/sh-dsp.s: New file.
	* testsuite/gas/sh/arch/sh2e.s: New file.
	* testsuite/gas/sh/arch/sh3-nommu.s: New file.
	* testsuite/gas/sh/arch/sh3.s: New file.
	* testsuite/gas/sh/arch/sh3-dsp.s: New file.
	* testsuite/gas/sh/arch/sh3e.s: New file.
	* testsuite/gas/sh/arch/sh4-nommu-nofpu.s: New file.
	* testsuite/gas/sh/arch/sh4-nofpu.s: New file.
	* testsuite/gas/sh/arch/sh4.s: New file.
	* testsuite/gas/sh/arch/sh4a-nofpu.s: New file.
	* testsuite/gas/sh/arch/sh4al-dsp.s: New file.
	* testsuite/gas/sh/arch/sh4a.s: New file.

include/elf:
	* sh.h (EF_SH_HAS_DSP): Remove.
	(EF_SH_HAS_FP): Remove.
	(EF_SH_MERGE_MACH): Remove.
	(EF_SH4_NOFPU): Convert to decimal.
	(EF_SH4A_NOFPU): Likewise.
	(EF_SH4_NOMMU_NOFPU): Likewise.
	(EF_SH3_NOMMU): Add new macro.
	(EF_SH_BFD_TABLE): Likewise.
	(sh_find_elf_flags): Add prototype.
	(sh_elf_get_flags_from_mach): Likewise.

opcodes:
	* sh-dis.c (target_arch): Make unsigned.
	(print_insn_sh): Replace (most of) switch with a call to
	sh_get_arch_from_bfd_mach(). Also use new architecture flags system.
	* sh-opc.h: Redefine architecture flags values.
	Add sh3-nommu architecture.
	Reorganise <arch>_up macros so they make more visual sense.
	(SH_MERGE_ARCH_SET): Define new macro.
	(SH_VALID_BASE_ARCH_SET): Likewise.
	(SH_VALID_MMU_ARCH_SET): Likewise.
	(SH_VALID_CO_ARCH_SET): Likewise.
	(SH_VALID_ARCH_SET): Likewise.
	(SH_MERGE_ARCH_SET_VALID): Likewise.
	(SH_ARCH_SET_HAS_FPU): Likewise.
	(SH_ARCH_SET_HAS_DSP): Likewise.
	(SH_ARCH_UNKNOWN_ARCH): Likewise.
	(sh_get_arch_from_bfd_mach): Add prototype.
	(sh_get_arch_up_from_bfd_mach): Likewise.
	(sh_get_bfd_mach_from_arch_set): Likewise.
	(sh_merge_bfd_arc): Likewise.

ld:
	* testsuite/ld-sh/arch/arch.exp: New test script.
	* testsuite/ld-sh/arch/arch_expected.txt: New file.
	* testsuite/ld-sh/arch/sh.s: New file.
	* testsuite/ld-sh/arch/sh2.s: New file.
	* testsuite/ld-sh/arch/sh-dsp.s: New file.
	* testsuite/ld-sh/arch/sh2e.s: New file.
	* testsuite/ld-sh/arch/sh3-nommu.s: New file.
	* testsuite/ld-sh/arch/sh3.s: New file.
	* testsuite/ld-sh/arch/sh3-dsp.s: New file.
	* testsuite/ld-sh/arch/sh3e.s: New file.
	* testsuite/ld-sh/arch/sh4-nommu-nofpu.s: New file.
	* testsuite/ld-sh/arch/sh4-nofpu.s: New file.
	* testsuite/ld-sh/arch/sh4.s: New file.
	* testsuite/ld-sh/arch/sh4a-nofpu.s: New file.
	* testsuite/ld-sh/arch/sh4al-dsp.s: New file.
	* testsuite/ld-sh/arch/sh4a.s: New file.
@
text
@d1846 1
d1850 2
a1851 1
  if (addr > input_section->_raw_size)
d1876 2
a1877 6
	  contents = (bfd_byte *) bfd_malloc (symbol_section->_raw_size);
	  if (contents == NULL)
	    return bfd_reloc_outofrange;
	  if (! bfd_get_section_contents (input_bfd, symbol_section, contents,
					  (file_ptr) 0,
					  symbol_section->_raw_size))
d1879 2
a1880 1
	      free (contents);
a2198 5
  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

d2230 1
a2230 6
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
d2240 1
a2240 1
      if (laddr >= sec->_raw_size)
d2268 1
a2268 1
      if (paddr >= sec->_raw_size)
d2482 1
a2482 6
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
d2574 1
a2574 1
  toaddr = sec->_cooked_size;
d2594 1
a2594 1
    sec->_cooked_size -= count;
d2895 7
a2901 7
		      ocontents = (bfd_byte *) bfd_malloc (o->_raw_size);
		      if (ocontents == NULL)
			return FALSE;
		      if (! bfd_get_section_contents (abfd, o, ocontents,
						      (file_ptr) 0,
						      o->_raw_size))
			return FALSE;
d2953 7
a2959 7
		      ocontents = (bfd_byte *) bfd_malloc (o->_raw_size);
		      if (ocontents == NULL)
			return FALSE;
		      if (! bfd_get_section_contents (abfd, o, ocontents,
						      (file_ptr) 0,
						      o->_raw_size))
			return FALSE;
d3076 1
a3076 1
	stop = sec->_cooked_size;
d4127 1
a4127 1
      srel->_raw_size += sizeof (Elf32_External_Rela);
d4138 1
a4138 1
  s->_raw_size = BFD_ALIGN (s->_raw_size, (bfd_size_type) (1 << power_of_two));
d4147 1
a4147 1
  h->root.u.def.value = s->_raw_size;
d4150 1
a4150 1
  s->_raw_size += h->size;
d4211 2
a4212 2
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_ENTRY_SIZE;
d4214 1
a4214 1
	  h->plt.offset = s->_raw_size;
d4229 1
a4229 1
	  s->_raw_size += PLT_ENTRY_SIZE;
d4233 1
a4233 1
	  htab->sgotplt->_raw_size += 4;
d4236 1
a4236 1
	  htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
d4266 2
a4267 2
      h->got.offset = s->_raw_size;
      s->_raw_size += 4;
d4270 1
a4270 1
	s->_raw_size += 4;
d4276 1
a4276 1
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d4278 1
a4278 1
	htab->srelgot->_raw_size += 2 * sizeof (Elf32_External_Rela);
d4283 1
a4283 1
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d4304 2
a4305 2
      eh->datalabel_got.offset = s->_raw_size;
      s->_raw_size += 4;
d4308 1
a4308 1
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d4383 1
a4383 1
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
d4441 1
a4441 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d4480 1
a4480 1
		  srel->_raw_size += p->count * sizeof (Elf32_External_Rela);
d4505 2
a4506 2
	      *local_got = s->_raw_size;
	      s->_raw_size += 4;
d4508 1
a4508 1
		s->_raw_size += 4;
d4510 1
a4510 1
		srel->_raw_size += sizeof (Elf32_External_Rela);
d4522 3
a4524 3
      htab->tls_ldm_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 8;
      htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d4550 1
a4550 1
	  if (s->_raw_size != 0 && s != htab->srelplt)
d4563 1
a4563 1
      if (s->_raw_size == 0)
d4584 1
a4584 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d4605 1
a4605 1
      if (htab->splt->_raw_size != 0)
d5912 1
a5912 1
	  (size_t) input_section->_raw_size);
d7229 1
a7229 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d7283 1
a7283 4
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
d7300 1
a7300 4
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val -= s->_cooked_size;
		  else
		    dyn.d_un.d_val -= s->_raw_size;
d7309 1
a7309 1
      if (splt && splt->_raw_size > 0)
d7354 1
a7354 1
  if (sgot && sgot->_raw_size > 0)
d7392 1
a7392 1
  unsigned int raw_size;
d7408 1
a7408 1
	raw_size = 92;
d7415 1
a7415 1
					  raw_size, note->descpos + offset);
@


1.105
log
@bfd/
	* elf32-sh.c (sh_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.

opcodes/
	* sh-dis.c (print_insn_sh): Print the value in constant pool
	as a symbol if it looks like a symbol.

gas/testsuite/
	* gas/sh/pcrel2.d: Update.
	* gas/sh/tlsd.d: Update.
	* gas/sh/tlsnopic.d: Update.
	* gas/sh/tlspic.d: Update.

ld/testsuite/
	* ld-sh/tlsbin-1.d: Update
	* ld-sh/tlspic-1.d: Update.
@
text
@d28 1
d6823 2
d6828 9
a6836 1
  flagword flags = elf_elfheader (abfd)->e_flags;
a6837 45
  switch (flags & EF_SH_MACH_MASK)
    {
    case EF_SH1:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh);
      break;
    case EF_SH2:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh2);
      break;
    case EF_SH2E:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh2e);
      break;
    case EF_SH_DSP:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh_dsp);
      break;
    case EF_SH3:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh3);
      break;
    case EF_SH3_DSP:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh3_dsp);
      break;
    case EF_SH3E:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh3e);
      break;
    case EF_SH_UNKNOWN:
    case EF_SH4:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4);
      break;
    case EF_SH4_NOFPU:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4_nofpu);
      break;
    case EF_SH4A:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4a);
      break;
    case EF_SH4A_NOFPU:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4a_nofpu);
      break;
    case EF_SH4AL_DSP:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4al_dsp);
      break;
    case EF_SH4_NOMMU_NOFPU:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4_nommu_nofpu);
      break;
    default:
      return FALSE;
    }
d6840 21
d6893 14
a6906 2
/* This routine checks for linking big and little endian objects
   together, and for linking sh-dsp with sh3e / sh4 objects.  */
a6910 5
  flagword old_flags, new_flags;

  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

d6920 1
a6921 14
  old_flags = elf_elfheader (obfd)->e_flags;
  new_flags = elf_elfheader (ibfd)->e_flags;
  if ((EF_SH_HAS_DSP (old_flags) && EF_SH_HAS_FP (new_flags))
      || (EF_SH_HAS_DSP (new_flags) && EF_SH_HAS_FP (old_flags)))
    {
      (*_bfd_error_handler)
	("%s: uses %s instructions while previous modules use %s instructions",
	 bfd_archive_filename (ibfd),
	 EF_SH_HAS_DSP (new_flags) ? "dsp" : "floating point",
	 EF_SH_HAS_DSP (new_flags) ? "floating point" : "dsp");
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }
  elf_elfheader (obfd)->e_flags = EF_SH_MERGE_MACH (old_flags, new_flags);
d6923 7
a6929 1
  return sh_elf_set_mach_from_flags (obfd);
@


1.104
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d7483 11
d7541 1
@


1.103
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d3927 1
a3927 1
	  && ! _bfd_elf_link_record_dynamic_symbol (info, h))
a4169 11
/* This is the condition under which sh_elf_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in sh_elf_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d4215 1
a4215 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d4276 1
a4276 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d4314 1
a4314 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d4379 1
a4379 1
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d6482 1
a6482 1
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d6489 1
a6489 1
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.102
log
@bfd/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Report error if
	unresolved symbols in objects aren't allowed.

	* elf-hppa.h (elf_hppa_relocate_section): Properly handle
	unresolved symbols.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_unmark_useless_dynamic_symbols):
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

	* elf-m10200.c (mn10200_elf_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.

include/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Correct comments for the
	unresolved_syms_in_objects field.

ld/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (parse_args): Don't set unresolved_syms_in_objects
	or unresolved_syms_in_shared_libs for -Bdynamic and -Bstatic.
@
text
@d4623 1
a4623 1
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.101
log
@2003-03-03  Andrew Stubbs  <andrew.stubbs@@superh.com>

opcodes:
	* sh-dis.c (print_insn_sh): Don't disassemble fp instructions in
	nofpu mode.  Add BFD type bfd_mach_sh4_nommu_nofpu.
	* sh-opc.h: Add sh4_nommu_nofpu architecture and adjust instructions
	accordingly.
bfd:
	* archures.c: Add bfd_mach_sh4_nommu_nofpu.
	* cpu-sh.c: Ditto.
	* elf32-sh.c: Ditto.
	* bfd-in2.h: Regenerate.
include/elf:
	* sh.h: Add EF_SH4_NOMMU_NOFPU.
gas:
	* config/tc-sh.c (md_parse_option): Add -isa=sh4-nofpu and
	-isa=sh4-nommu-nofpu options. Adjust help messages accordingly.
	(sh_elf_final_processing): Output BFD type sh4_nofpu if that is
	the most general type or the user specifically requested it.
	(md_assemble): Add a new error message for when an instruction
	is understood, but is not allowed due to an -isa option.
@
text
@d4941 1
a4941 2
	  else if (! info->executable
		   && info->unresolved_syms_in_objects == RM_IGNORE
d4949 1
a4949 2
		   ((info->shared && info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)
		    || (!info->shared && info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
@


1.101.2.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d4941 2
a4942 1
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
d4950 2
a4951 1
		   (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
@


1.100
log
@	* elf32-i386.c (elf_i386_object_p): Delete.
	(elf_backend_object_p): Don't define.
	* elf32-s390.c (elf_s390_object_p): No need to alloc tdata here.
	* elf32-sh.c (sh_elf_object_p): Likewise.
	* elf32-sparc.c (elf32_sparc_object_p): Likewise.
	* elf64-alpha.c (elf64_alpha_object_p): Likewise.
	* elf64-s390.c (elf_s390_object_p): Likewise.
	* elf64-x86-64.c (elf64_x86_64_elf_object_p): Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6878 3
@


1.100.6.1
log
@Merge from mainline
@
text
@d3927 1
a3927 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d4170 11
d4226 1
a4226 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d4287 1
a4287 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d4325 1
a4325 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d4390 1
a4390 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d4623 1
a4623 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d4941 2
a4942 1
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
d4950 2
a4951 1
		   (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
d6495 1
a6495 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d6502 1
a6502 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.100.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d4623 1
a4623 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d4941 2
a4942 1
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
d4950 2
a4951 1
		   (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
a6877 3
      break;
    case EF_SH4_NOMMU_NOFPU:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4_nommu_nofpu);
@


1.100.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d3927 1
a3927 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d4170 11
d4226 1
a4226 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d4287 1
a4287 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d4325 1
a4325 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d4390 1
a4390 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d6493 1
a6493 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d6500 1
a6500 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.100.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a27 2
#include "libiberty.h"
#include "../opcodes/sh-opc.h"
a50 1
#ifndef SH64_ELF
a52 1
#endif
a107 1
#if !defined SH_TARGET_ALREADY_DEFINED
a111 1
#endif
d1848 1
a1848 1
  if (addr > bfd_get_section_limit (input_bfd, input_section))
d1873 6
a1878 2
	  if (!bfd_malloc_and_get_section (input_bfd, symbol_section,
					   &contents))
d1880 1
a1880 2
	      if (contents != NULL)
		free (contents);
d2199 5
d2235 6
a2240 1
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d2250 1
a2250 1
      if (laddr >= sec->size)
d2252 2
a2253 2
	  (*_bfd_error_handler) (_("%B: 0x%lx: warning: bad R_SH_USES offset"),
				 abfd,
d2264 2
a2265 2
	   (_("%B: 0x%lx: warning: R_SH_USES points to unrecognized insn 0x%x"),
	    abfd, (unsigned long) irel->r_offset, insn));
d2278 1
a2278 1
      if (paddr >= sec->size)
d2281 2
a2282 2
	   (_("%B: 0x%lx: warning: bad R_SH_USES load offset"),
	    abfd, (unsigned long) irel->r_offset));
d2296 2
a2297 2
	   (_("%B: 0x%lx: warning: could not find expected reloc"),
	    abfd, (unsigned long) paddr));
d2324 2
a2325 2
	       (_("%B: 0x%lx: warning: symbol in unexpected section"),
		abfd, (unsigned long) paddr));
d2449 2
a2450 2
	   (_("%B: 0x%lx: warning: could not find expected COUNT reloc"),
	    abfd, (unsigned long) paddr));
d2458 2
a2459 2
	  ((*_bfd_error_handler) (_("%B: 0x%lx: warning: bad count"),
				  abfd,
d2492 6
a2497 1
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d2589 1
a2589 1
  toaddr = sec->size;
d2609 1
a2609 1
    sec->size -= count;
d2858 2
a2859 2
	       (_("%B: 0x%lx: fatal: reloc overflow while relaxing"),
		abfd, (unsigned long) irel->r_offset));
d2910 7
a2916 7
		      if (!bfd_malloc_and_get_section (abfd, o, &ocontents))
			{
			  if (ocontents != NULL)
			    free (ocontents);
			  return FALSE;
			}

d2968 7
a2974 7
		      if (!bfd_malloc_and_get_section (abfd, o, &ocontents))
			{
			  if (ocontents != NULL)
			    free (ocontents);
			  return FALSE;
			}

d3091 1
a3091 1
	stop = sec->size;
a3108 1
#ifndef SH64_ELF
d3227 2
a3228 2
	       (_("%B: 0x%lx: fatal: reloc overflow while relaxing"),
		abfd, (unsigned long) irel->r_offset));
a3236 1
#endif /* defined SH64_ELF */
d4142 1
a4142 1
      srel->size += sizeof (Elf32_External_Rela);
d4153 1
a4153 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d4162 1
a4162 1
  h->root.u.def.value = s->size;
d4165 1
a4165 1
  s->size += h->size;
d4226 2
a4227 2
	  if (s->size == 0)
	    s->size += PLT_ENTRY_SIZE;
d4229 1
a4229 1
	  h->plt.offset = s->size;
d4244 1
a4244 1
	  s->size += PLT_ENTRY_SIZE;
d4248 1
a4248 1
	  htab->sgotplt->size += 4;
d4251 1
a4251 1
	  htab->srelplt->size += sizeof (Elf32_External_Rela);
d4281 2
a4282 2
      h->got.offset = s->size;
      s->size += 4;
d4285 1
a4285 1
	s->size += 4;
d4291 1
a4291 1
	htab->srelgot->size += sizeof (Elf32_External_Rela);
d4293 1
a4293 1
	htab->srelgot->size += 2 * sizeof (Elf32_External_Rela);
d4298 1
a4298 1
	htab->srelgot->size += sizeof (Elf32_External_Rela);
d4319 2
a4320 2
      eh->datalabel_got.offset = s->size;
      s->size += 4;
d4323 1
a4323 1
	htab->srelgot->size += sizeof (Elf32_External_Rela);
d4398 1
a4398 1
      sreloc->size += p->count * sizeof (Elf32_External_Rela);
d4456 1
a4456 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d4495 1
a4495 1
		  srel->size += p->count * sizeof (Elf32_External_Rela);
d4520 2
a4521 2
	      *local_got = s->size;
	      s->size += 4;
d4523 1
a4523 1
		s->size += 4;
d4525 1
a4525 1
		srel->size += sizeof (Elf32_External_Rela);
d4537 3
a4539 3
      htab->tls_ldm_got.offset = htab->sgot->size;
      htab->sgot->size += 8;
      htab->srelgot->size += sizeof (Elf32_External_Rela);
d4565 1
a4565 1
	  if (s->size != 0 && s != htab->srelplt)
d4578 1
a4578 1
      if (s->size == 0)
d4599 1
a4599 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
d4620 1
a4620 1
      if (htab->splt->size != 0)
d4808 3
a4810 2
		    (_("%B(%A+0x%lx): %s relocation against SEC_MERGE section"),
		     input_bfd, input_section,
d4913 3
a4915 2
		    (_("%B(%A): unresolvable relocation against symbol `%s'"),
		     input_bfd, input_section, h->root.root.string);
d4984 2
a4985 2
		   (_("%B: 0x%lx: fatal: unaligned branch target for relax-support relocation"),
		    input_section->owner,
d5017 2
a5018 2
	       (_("%B: 0x%lx: fatal: unaligned %s relocation 0x%lx"),
		input_section->owner,
d5020 1
a5020 1
		(unsigned long) relocation));
d5032 2
a5033 2
	       (_("%B: 0x%lx: fatal: unaligned %s relocation 0x%lx"),
		input_section->owner,
d5035 1
a5035 1
		(unsigned long) relocation));
d5046 2
a5047 2
	       (_("%B: 0x%lx: fatal: R_SH_PSHA relocation %d not in range -32..32"),
		input_section->owner,
d5049 1
a5049 1
		(unsigned long) relocation));
d5060 2
a5061 2
	       (_("%B: 0x%lx: fatal: R_SH_PSHL relocation %d not in range -32..32"),
		input_section->owner,
d5063 1
a5063 1
		(unsigned long) relocation));
d5927 1
a5927 1
	  (size_t) input_section->size);
d6590 2
a6591 2
		    (_("%B: `%s' accessed both as normal and thread local symbol"),
		     abfd, h->root.root.string);
d6802 2
a6803 3
	      (*_bfd_error_handler)
		(_("%B: TLS local exec code cannot be linked into shared objects"),
		 abfd);
a6821 2
static unsigned int sh_ef_bfd_table[] = { EF_SH_BFD_TABLE };

d6825 1
a6825 9
  flagword flags = elf_elfheader (abfd)->e_flags & EF_SH_MACH_MASK;

  if (flags >= sizeof(sh_ef_bfd_table))
    return FALSE;

  if (sh_ef_bfd_table[flags] == 0)
    return FALSE;
  
  bfd_default_set_arch_mach (abfd, bfd_arch_sh, sh_ef_bfd_table[flags]);
d6827 45
a6873 21


/* Reverse table lookup for sh_ef_bfd_table[].
   Given a bfd MACH value from archures.c
   return the equivalent ELF flags from the table.
   Return -1 if no match is found.  */

int
sh_elf_get_flags_from_mach (unsigned long mach)
{
  int i = ARRAY_SIZE (sh_ef_bfd_table);
  
  for (; i>0; i--)
    if (sh_ef_bfd_table[i] == mach)
      return i;
  
  /* shouldn't get here */
  BFD_FAIL();

  return -1;
}
d6906 2
a6907 15

/* This function returns the ELF architecture number that
   corresponds to the given arch_sh* flags.  */

int
sh_find_elf_flags (unsigned int arch_set)
{
  extern unsigned long sh_get_bfd_mach_from_arch_set (unsigned int);
  unsigned long bfd_mach = sh_get_bfd_mach_from_arch_set (arch_set);

  return sh_elf_get_flags_from_mach (bfd_mach);
}

/* This routine initialises the elf flags when required and
   calls sh_merge_bfd_arch() to check dsp/fpu compatibility.  */
d6912 4
a6915 1
  extern bfd_boolean sh_merge_bfd_arch (bfd *, bfd *);
a6925 1
      sh_elf_set_mach_from_flags (obfd);
d6927 10
a6936 6

  if (! sh_merge_bfd_arch (ibfd, obfd))
    {
      _bfd_error_handler ("%B: uses instructions which are incompatible "
			  "with instructions used in previous modules",
			  ibfd);
d6940 1
d6942 1
a6942 4
  elf_elfheader (obfd)->e_flags =
    sh_elf_get_flags_from_mach (bfd_get_mach (obfd));
  
  return TRUE;
d7258 1
a7258 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
d7312 4
a7315 1
	      dyn.d_un.d_val = s->size;
d7332 4
a7335 1
		  dyn.d_un.d_val -= s->size;
d7344 1
a7344 1
      if (splt && splt->size > 0)
d7389 1
a7389 1
  if (sgot && sgot->size > 0)
a7421 1
#if !defined SH_TARGET_ALREADY_DEFINED
a7422 1

d7427 1
a7427 1
  unsigned int size;
d7443 1
a7443 1
	size = 92;
d7450 1
a7450 1
					  size, note->descpos + offset);
a7481 12
#endif /* not SH_TARGET_ALREADY_DEFINED */

 
/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
sh_elf_plt_sym_val (bfd_vma i, const asection *plt,
		    const arelent *rel ATTRIBUTE_UNUSED)
{
  return plt->vma + (i + 1) * PLT_ENTRY_SIZE;
}
a7482 1
#if !defined SH_TARGET_ALREADY_DEFINED
a7486 2
#endif

a7529 1
#define elf_backend_plt_sym_val		sh_elf_plt_sym_val
d7538 1
a7538 1
#if !defined INCLUDE_SHMEDIA && !defined SH_TARGET_ALREADY_DEFINED
d7580 1
a7580 1
#endif /* neither INCLUDE_SHMEDIA nor SH_TARGET_ALREADY_DEFINED */
@


1.100.8.4
log
@Merge from mainline.
@
text
@d3913 1
a3913 1
      h->def_regular = 1;
d4020 8
a4027 5
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));
d4033 1
a4033 1
      || h->needs_plt)
d4046 1
a4046 1
	  h->needs_plt = 0;
d4057 1
a4057 1
  if (h->u.weakdef != NULL)
d4059 4
a4062 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d4064 3
a4066 1
	h->non_got_ref = h->u.weakdef->non_got_ref;
d4082 1
a4082 1
  if (!h->non_got_ref)
d4088 1
a4088 1
      h->non_got_ref = 0;
d4105 1
a4105 1
      h->non_got_ref = 0;
d4133 1
a4133 1
      h->needs_copy = 1;
d4185 1
a4185 1
       || h->forced_local)
d4203 1
a4203 1
	  && !h->forced_local)
d4227 1
a4227 1
	      && !h->def_regular)
d4246 1
a4246 1
	  h->needs_plt = 0;
d4252 1
a4252 1
      h->needs_plt = 0;
d4264 1
a4264 1
	  && !h->forced_local)
d4302 1
a4302 1
	  && !h->forced_local)
d4357 3
a4359 3
      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
d4367 1
a4367 1
	      && !h->forced_local)
d4865 2
a4866 1
			  || !h->def_regular))
d4874 2
a4875 1
			  || !h->def_regular)
d4877 2
a4878 1
			   && !h->forced_local)
d4886 2
a4887 1
			      && h->def_dynamic)))
d4893 2
a4894 1
			  && h->def_dynamic))
d5141 2
a5142 1
			  && h->def_regular))
d5186 1
a5186 1
	      || h->forced_local
d5414 1
a5414 1
	  if (h->forced_local)
d5467 1
a5467 1
		      || h->def_regular))
d6310 9
a6318 10
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
    }
d6414 1
a6414 1
	      || h->def_regular))
d6611 1
a6611 1
	      || h->forced_local
d6617 1
a6617 1
	  h->needs_plt = 1;
d6642 1
a6642 1
	  if (h->forced_local)
d6645 1
a6645 1
	  h->needs_plt = 1;
d6659 1
a6659 1
	      h->non_got_ref = 1;
d6688 2
a6689 1
			   || !h->def_regular))))
d6694 2
a6695 1
		      || !h->def_regular)))
d7084 1
a7084 1
      if (!h->def_regular)
d7188 1
a7188 1
  if (h->needs_copy)
@


1.99
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d6963 1
a6963 13
  struct sh_elf_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct sh_elf_obj_tdata);

  if (!sh_elf_set_mach_from_flags (abfd))
    return FALSE;

  /* Allocate our special target data.  */
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return FALSE;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;
  return TRUE;
@


1.98
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Copy
	ELF_LINK_HASH_NEEDS_PLT.  Fix formatting.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elf32-xtensa.c (elf_xtensa_copy_indirect_symbol): Remove.
	(elf_backend_copy_indirect_symbol): Don't define.
@
text
@d460 1
a460 1
     instructions.  A section should be processed as assumining it
d2721 1
a2721 1
		 N.B. If we want to abandom in-place changes here and
d3415 1
a3415 1
   GCC to return the address of large strutcures, so it should not be
d3638 1
a3638 1
/* Return offset of the tempoline in PLT entry */
@


1.97
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d6342 2
a6343 1
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
@


1.96
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d4808 1
a4808 1
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.95
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d6024 2
a6025 2
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
d6027 1
a6027 1
  return elf_hash_table (info)->tls_segment->start;
d6035 2
a6036 2
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
d6040 1
a6040 1
  return (address - dtpoff_base (info) + 8);
@


1.94
log
@	* archures.c (bfd_mach_sh4a, bfd_mach_sh4al_dsp, bfd_mach_sh4_nofpu,
	bfd_mach_sh4a_nofpu): New machine types.
	* bfd-in2.h: Rebuilt.
	* cpu-sh.c (compatible): Remove unused function.
	(SH4A_NEXT, SH4AL_DSP_NEXT, SH4_NOFPU_NEXT, SH4A_NOFPU_NEXT): New.
	(arch_info_struct): Add sh4a, sh4al_dsp, sh4-nofpu and sh4a-nofpu.
	* elf32-sh.c (sh_elf_set_mach_from_flags): Handle them.
@
text
@a7557 1
#define elf_backend_plt_header_size	PLT_ENTRY_SIZE
@


1.93
log
@[bfd]
	* elf32-sh.c (sh_elf_relocate_section): Handle R_SH_IMM_*_PCREL
	relocations.
	(sh_elf_check_relocs): Likewise.

	* elf32-sh64.c (elf_backend_merge_symbol_attribute): Define.
	(sh64_elf_merge_symbol_attribute): New.
	* elf64-sh64.c (elf_backend_merge_symbol_attribute): Define.
	(sh64_elf64_merge_symbol_attribute): New.

[ld/testsuite]
	* ld-sh/sh64/rd-sh64.exp: If the test matches *-dso.d, copy
	the output of linker to the file tmpdir/*-dso.so.
	* ld-sh/sh64/stobin-0-dso.d: New.
	* ld-sh/sh64/stobin-1.d: New.
	* ld-sh/sh64/stobin.s: New.
	* ld-sh/sh64/stolib.s: New.
@
text
@d6866 12
@


1.92
log
@* sh.h (R_SH_SWITCH8, R_SH_GNU_VTINHERIT, R_SH_GNU_VTENTRY,
R_SH_LOOP_START,R_SH_LOOP_END): Move to "reserved" spaces.
(R_SH_DIR16, R_SH_DIR8, R_SH_DIR8UL, R_SH_DIR8UW, R_SH_DIR8U,
R_SH_DIR8SW, R_SH_DIR8S, R_SH_DIR4UL, R_SH_DIR4UW, R_SH_DIR4U,
R_SH_PSHA, R_SH_PSHL): New.

* elf32-sh.c (sh_elf_howto_table): R_SH_SWITCH8,
R_SH_GNU_VTINHERIT, R_SH_GNU_VTENTRY,
R_SH_LOOP_START,R_SH_LOOP_END moved to "reserved" spaces,
R_SH_DIR16, R_SH_DIR8, R_SH_DIR8UL, R_SH_DIR8UW, R_SH_DIR8U,
R_SH_DIR8SW, R_SH_DIR8S, R_SH_DIR4UL, R_SH_DIR4UW, R_SH_DIR4U,
R_SH_PSHA, R_SH_PSHL added.
(sh_reloc_map): Add R_SH_DIR16 and R_SH_DIR8.
(sh_elf_relocate_section): Support new relocs.
@
text
@d5084 6
d5096 1
a5096 1
	      && (r_type != R_SH_REL32
d5149 11
d6675 6
d6798 8
a6805 1
	      if (r_type == R_SH_REL32)
@


1.91
log
@Better handking for unresolved symbols
@
text
@d279 30
a308 2
  EMPTY_HOWTO (10),
  EMPTY_HOWTO (11),
a318 3
  EMPTY_HOWTO (22),
  EMPTY_HOWTO (23),
  EMPTY_HOWTO (24),
d325 47
d509 16
a524 4
  /* An 8 bit switch table entry.  This is generated for an expression
     such as ``.word L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_SH_SWITCH8,		/* type */
d530 14
d545 2
a546 2
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_SWITCH8",	/* name */
d549 2
a550 2
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */
d552 4
a555 5
  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_SH_GNU_VTINHERIT, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d558 3
a560 3
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_SH_GNU_VTINHERIT", /* name */
d563 1
a563 1
	 0,			/* dst_mask */
d566 1
a566 2
  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_SH_GNU_VTENTRY,     /* type */
d568 2
a569 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d572 3
a574 3
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn,	/* special_function */
	 "R_SH_GNU_VTENTRY",   /* name */
d577 1
a577 1
	 0,			/* dst_mask */
d580 1
a580 2
  /* 8 bit PC relative divided by 2 - but specified in a very odd way.  */
  HOWTO (R_SH_LOOP_START,	/* type */
d582 1
a582 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d587 4
a590 4
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_LOOP_START",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
d592 1
a592 1
	 TRUE),			/* pcrel_offset */
d594 3
a596 4
  /* 8 bit PC relative divided by 2 - but specified in a very odd way.  */
  HOWTO (R_SH_LOOP_END,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d601 4
a604 4
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_LOOP_END",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
d606 57
a662 1
	 TRUE),			/* pcrel_offset */
d664 13
a676 7
  EMPTY_HOWTO (38),
  EMPTY_HOWTO (39),
  EMPTY_HOWTO (40),
  EMPTY_HOWTO (41),
  EMPTY_HOWTO (42),
  EMPTY_HOWTO (43),
  EMPTY_HOWTO (44),
d795 15
a809 1
  EMPTY_HOWTO (53),
d2034 2
d4721 2
a4722 2
      if (r_type > (int) R_SH_LAST_INVALID_RELOC
	  && r_type < (int) R_SH_LOOP_START)
d5017 64
@


1.90
log
@	* elf32-i386.c (elf_i386_relocate_section): Make undefined symbols
	fatal if -pie.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(ppc_elf_relocate_section) <case R_PPC_RELAX32>: Issue fatal error
	on undefined symbols if -pie.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
@
text
@d4666 2
d4770 1
a4770 1
		   && ! info->no_undefined
d4775 6
a4780 5
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset,
		      (info->executable || info->no_undefined
		       || ELF_ST_VISIBILITY (h->other)))))
@


1.89
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d4767 1
a4767 1
	  else if (info->shared
d4776 1
a4776 1
		      (!info->shared || info->no_undefined
@


1.88
log
@	* elf32-sh.c (sh_elf_check_relocs): Don't set DF_TEXTREL here.

	* ld-sh/shared-2.d, ld-sh/textrel1.s, ld-sh/textrel2.s: New test.
@
text
@d60 1
a60 1
  (struct elf_backend_data *, struct elf_link_hash_entry *,
d3695 1
a3695 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d6014 1
a6014 1
sh_elf_copy_indirect_symbol (struct elf_backend_data *bed,
@


1.87
log
@	* elf32-sh.c: Convert to C90.  Replace PTR with void *.
	* elf32-sh64-com.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sh64.h: Likewise.
	* elf64-sh64.c: Likewise.
@
text
@a6499 2
		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
@


1.86
log
@	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Use SYMBOL_CALLS_LOCAL.
	(allocate_dynrelocs): Likewise.
	(sh_elf_relocate_section): Likewise. Use SYMBOL_REFERENCES_LOCAL.
	(sh_elf_finish_dynamic_symbol): Use SYMBOL_REFERENCES_LOCAL.
@
text
@d30 1
a30 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d32 1
a32 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d34 1
a34 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d36 1
a36 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d38 1
a38 1
  PARAMS ((bfd *, flagword));
d40 1
a40 1
  PARAMS ((bfd *, bfd *));
d42 1
a42 1
  PARAMS ((bfd *, bfd *));
d44 1
a44 1
  PARAMS ((bfd *));
d46 1
a46 1
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
d48 1
a48 1
  PARAMS ((bfd *, asection *, bfd_vma, int));
d50 1
a50 1
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_byte *, bfd_boolean *));
d52 1
a52 1
  PARAMS ((bfd *, asection *, PTR, bfd_byte *, bfd_vma));
d54 2
a55 2
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d57 2
a58 2
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
	   bfd_byte *, bfd_boolean, asymbol **));
d60 2
a61 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d63 1
a63 1
  PARAMS ((struct bfd_link_info *, int, int));
d65 1
a65 1
  PARAMS ((bfd *));
d67 1
a67 1
  PARAMS ((bfd *));
d69 1
a69 2
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d71 1
a71 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d73 1
a73 1
  PARAMS ((bfd *));
d75 1
a75 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d77 1
a77 1
  PARAMS ((bfd *, struct bfd_link_info *));
d79 2
a80 2
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
d82 1
a82 1
  PARAMS ((bfd *, struct bfd_link_info *));
d84 2
a85 2
  PARAMS ((int, bfd *, asection *, bfd_byte *, bfd_vma, asection *,
	   bfd_vma, bfd_vma));
d87 1
a87 1
  PARAMS ((bfd *, struct bfd_link_info *));
d89 1
a89 1
  PARAMS ((bfd *, struct bfd_link_info *));
d91 1
a91 1
  PARAMS ((struct bfd_link_info *));
d93 1
a93 1
  PARAMS ((struct bfd_link_info *, bfd_vma));
d95 2
a96 2
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
d98 1
a98 2
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d100 1
a100 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d102 1
a102 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d104 1
a104 1
  PARAMS ((const Elf_Internal_Rela *));
d106 1
a106 1
inline static void movi_shori_putval PARAMS ((bfd *, unsigned long, char *));
d109 1
a109 1
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));
d111 1
a111 1
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));
d1665 4
a1668 9
sh_elf_reloc_loop (r_type, input_bfd, input_section, contents, addr,
		   symbol_section, start, end)
     int r_type ATTRIBUTE_UNUSED;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma addr;
     asection *symbol_section;
     bfd_vma start, end;
d1770 3
a1772 9
sh_elf_reloc (abfd, reloc_entry, symbol_in, data, input_section, output_bfd,
	      error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol_in;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1839 5
a1843 9
sh_elf_ignore_reloc (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1957 2
a1958 3
sh_elf_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1974 2
a1975 4
sh_elf_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d2002 2
a2003 5
sh_elf_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d2035 1
a2035 1
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
d2391 2
a2392 5
sh_elf_relax_delete_bytes (abfd, sec, addr, count)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     int count;
d2714 1
a2714 2
			 (abfd, o, (PTR) NULL, (Elf_Internal_Rela *) NULL,
			  TRUE));
d2868 4
a2871 6
sh_elf_align_loads (abfd, sec, internal_relocs, contents, pswapped)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     Elf_Internal_Rela *internal_relocs;
     bfd_byte *contents ATTRIBUTE_UNUSED;
     bfd_boolean *pswapped;
d2922 1
a2922 1
				     (PTR) internal_relocs, &label,
d2940 2
a2941 6
sh_elf_swap_insns (abfd, sec, relocs, contents, addr)
     bfd *abfd;
     asection *sec;
     PTR relocs;
     bfd_byte *contents;
     bfd_vma addr;
d3222 1
a3222 4
movi_shori_putval (output_bfd, value, addr)
     bfd *output_bfd;
     unsigned long value;
     char *addr;
d3540 1
a3540 2
sh_elf_mkobject (abfd)
     bfd *abfd;
d3580 1
a3580 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d3591 3
a3593 4
sh_elf_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d3627 1
a3627 2
sh_elf_link_hash_table_create (abfd)
     bfd *abfd;
d3660 1
a3660 3
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d3690 1
a3690 3
sh_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d3845 2
a3846 3
sh_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d4013 1
a4013 3
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d4246 1
a4246 3
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d4275 2
a4276 3
sh_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d4385 1
a4385 1
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);
d4479 1
a4479 2
	    elf_link_hash_traverse (&htab->root, readonly_dynrelocs,
				    (PTR) info);
d4496 5
a4500 10
sh_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			 contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d5658 6
a5663 8
sh_elf_get_relocated_section_contents (output_bfd, link_info, link_order,
				       data, relocatable, symbols)
     bfd *output_bfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     bfd_boolean relocatable;
     asymbol **symbols;
d5694 1
a5694 1
			 (input_bfd, input_section, (PTR) NULL,
d5766 1
a5766 2
dtpoff_base (info)
     struct bfd_link_info *info;
d5777 1
a5777 3
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
d5788 4
a5791 6
sh_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d5830 2
a5831 5
sh_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d6014 3
a6016 3
sh_elf_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
d6092 2
a6093 4
sh_elf_optimized_tls_reloc (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
d6117 2
a6118 5
sh_elf_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d6568 1
a6568 2
sh_elf_set_mach_from_flags (abfd)
     bfd *abfd;
d6610 1
a6610 3
sh_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
d6625 1
a6625 3
sh_elf_copy_private_data (ibfd, obfd)
     bfd * ibfd;
     bfd * obfd;
d6640 1
a6640 3
sh_elf_merge_private_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d6681 1
a6681 2
sh_elf_object_p (abfd)
  bfd *abfd;
d6702 3
a6704 5
sh_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d6982 1
a6982 3
sh_elf_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d7149 1
a7149 2
sh_elf_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d7166 1
a7166 3
elf32_shlin_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d7196 1
a7196 3
elf32_shlin_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
@


1.85
log
@Set maxpagesize for NTO targets to 4k
@
text
@d3918 3
a3920 5
	  || (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
	      && h->root.type != bfd_link_hash_undefweak
	      && h->root.type != bfd_link_hash_undefined))
d4225 1
a4225 3
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
d4907 1
a4907 5
		  || (h != NULL
		      && h->dynindx != -1
		      && (! info->symbolic
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d5066 1
a5066 3
		      && (info->symbolic || h->dynindx == -1
			  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d6956 1
a6956 4
	  && (info->symbolic
	      || h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d7004 1
a7004 4
	    && (info->symbolic
		|| h->dynindx == -1
		|| (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
	    && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
@


1.84
log
@	* elf32-sh.c (sh_elf_create_dynamic_sections): Return if dynamic
	sections were created already.  Remove unnecessary tests of
	the previous change.
@
text
@d7334 5
a7338 1
#define ELF_MAXPAGESIZE		128
@


1.83
log
@	* elf32-sh.c (sh_elf_create_dynamic_sections): Don't call
	bfd_make_section for existing sections.
@
text
@d3757 2
d3773 6
a3778 10
  s = htab->splt;
  if (s == NULL)
    {
      s = bfd_make_section (abfd, ".plt");
      htab->splt = s;
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, pltflags)
	  || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
	return FALSE;
    }
d3802 7
a3808 11
  if (htab->srelplt == NULL)
    {
      s = bfd_make_section (abfd,
			    (bed->default_use_rela_p ?
			     ".rela.plt" : ".rel.plt"));
      htab->srelplt = s;
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, ptralign))
	return FALSE;
    }
d3848 5
a3852 8
      if (htab->sdynbss == NULL)
	{
	  s = bfd_make_section (abfd, ".dynbss");
	  htab->sdynbss = s;
	  if (s == NULL
	      || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
	    return FALSE;
	}
d3865 1
a3865 1
      if (! info->shared && htab->srelbss == NULL)
@


1.82
log
@	* elf32-sparc.c (elf32_sparc_check_relocs): Don't call
	create_got_section if we already have done so.
	* elf32-sh.c (sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_adjust_dynamic_symbol): Delete "dynobj" var.  Use
	htab->root.dynobj instead.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_finish_dynamic_sections): Likewise.
@
text
@d3771 10
a3780 6
  s = bfd_make_section (abfd, ".plt");
  htab->splt = s;
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, pltflags)
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;
d3804 11
a3814 7
  s = bfd_make_section (abfd,
			bed->default_use_rela_p ? ".rela.plt" : ".rel.plt");
  htab->srelplt = s;
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, ptralign))
    return FALSE;
d3836 2
d3854 8
a3861 5
      s = bfd_make_section (abfd, ".dynbss");
      htab->sdynbss = s;
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
	return FALSE;
d3874 1
a3874 1
      if (! info->shared)
@


1.81
log
@Correct spelling of "relocatable".
@
text
@d3808 2
a3809 1
  if (! create_got_section (abfd, info))
a3890 1
  bfd *dynobj;
d3894 1
a3894 1
  dynobj = elf_hash_table (info)->dynobj;
d3897 1
a3897 1
  BFD_ASSERT (dynobj != NULL
a3998 1
  htab = sh_elf_hash_table (info);
d4024 1
a4024 1
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
d4026 1
a4026 1
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
a6200 1
  bfd *dynobj;
a6221 1
  dynobj = htab->root.dynobj;
d6295 7
a6301 4
	      if (dynobj == NULL)
		htab->root.dynobj = dynobj = abfd;
	      if (! create_got_section (dynobj, info))
		return FALSE;
d6538 2
a6539 2
	      if (dynobj == NULL)
		htab->root.dynobj = dynobj = abfd;
d6559 1
a6559 1
		  sreloc = bfd_get_section_by_name (dynobj, name);
d6564 1
a6564 1
		      sreloc = bfd_make_section (dynobj, name);
d6570 4
a6573 2
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
d6603 1
a6603 1
		  p = ((struct elf_sh_dyn_relocs *) bfd_alloc (dynobj, amt));
a6792 1
  bfd *dynobj;
a6794 1
  dynobj = htab->root.dynobj;
a7078 1
  bfd *dynobj;
a7082 2
  dynobj = htab->root.dynobj;

d7084 1
a7084 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d7103 1
a7103 1
	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
@


1.80
log
@	* elf32-sh.c (sh_elf_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewize.
@
text
@d2037 1
a2037 1
  if (link_info->relocateable
d4653 1
a4653 1
	  if (info->relocateable)
d4655 1
a4655 1
	      /* This is a relocateable link.  We don't have to change
d4724 2
a4725 2
	     relocateable object file.  */
	  if (info->relocateable)
d5721 1
a5721 1
				       data, relocateable, symbols)
d5726 1
a5726 1
     bfd_boolean relocateable;
d5738 1
a5738 1
  if (relocateable
d5742 1
a5742 1
						       relocateable,
d6214 1
a6214 1
  if (info->relocateable)
@


1.79
log
@	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): For weak symbols,
	copy ELF_LINK_NON_GOT_REF from weakdef.
	(allocate_dynrelocs):  For undef weak syms with non-default
	visibility, a) don't allocate plt entries, b) don't allocate
	.got relocs, c) discard dyn rel space
        (sh_elf_relocate_section): d) don't generate .got relocs, e)
        don't generate dynamic relocs.
	(sh_elf_copy_indirect_symbol): Don't copy ELF_LINK_NON_GOT_REF
	for weakdefs when symbol already adjusted.
@
text
@d4341 1
a4341 1
      if (! info->shared)
d4503 1
a4503 1
      if (! info->shared)
@


1.78
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d3943 4
d4090 3
a4092 1
      && h->plt.refcount > 0)
d4178 4
a4181 2
      else if (info->shared ||
	       WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
d4240 6
d4902 3
d5073 3
a5075 1
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d6150 11
a6160 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.77
log
@	* elf32-sh.c (tpoff): New.
	(struct elf_sh_dyn_relocs): Remove tls_tpoff32.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Pass SHARED instead of INFO.
        (allocate_dynrelocs): Don't make unnecessary dynamic TLS
	relocations.  Adjust WILL_CALL_FINISH_DYNAMIC_SYMBOL uses.
        (sh_elf_relocate_section): Likewise. Remove unnecessary tests.
	(dtpoff_base): Fix wrong indentation.
	(sh_elf_check_relocs): Don't set DF_STATIC_TLS flag with non-TLS
	relocations.  Don't set tls_tpoff32 flag.  Don't make unnecessary
	R_SH_TLS_TPOFF32 relocations.

	* ld-sh/tlsbin-1.d, ld-sh/tlsbin-2.d, ld-sh/tlsbin-3.d,
	ld-sh/tlstpoff-1.d, ld-sh/tlstpoff-2.d: Update for removing
	unnecessary TLS relocs.
@
text
@d2057 1
a2057 1
  internal_relocs = (_bfd_elf32_link_read_relocs
d2739 1
a2739 1
      internal_relocs = (_bfd_elf32_link_read_relocs
d5738 1
a5738 1
      internal_relocs = (_bfd_elf32_link_read_relocs
@


1.76
log
@bfd:
        * archures.c (enum bfd_architecture): Amend comment to refer to SuperH.
        * cpu-sh.c: Likewise.
        * elf32-sh.c: Likewise.
        * reloc.c (bfd_reloc_code_real): Likewise.
        * elf32-sh64-com.c: Change comment to refer to SuperH.
        * elf32-sh64.c: Likewise.
        * elf64-sh64.c: Likewise.
        * bfd-in2.h (enum bfd_architecture): Regenerate.
binutils:
        * readelf.c (get_machine_name) <EM_SH>: Amend return value
        to refer to SuperH.
gas:
        * config/tc-sh.c: Amend comment to refer to SuperH.
        * config/tc-sh.h: Likewise.
        (LISTING_HEADER): Amend to refer to SuperH.
        * config/tc-sh64.c: Change comment to refer to SuperH.
        * config/tc-sh64.h (LISTING_HEADER): Change to refer to SuperH.
        * doc/as.texinfo [SH, GENERIC]: Amend / Change to refer to SuperH.
        * doc/c-sh.texi: Amend to refer to SuperH.
        Add SuperH architecture documentation references.
        * doc/c-sh64.texi: Change to refer to SuperH.
include/elf:
        * common.h (EM_SH): Amend comment to refer to SuperH.
ld/testsuite:
        * ld-sh/sh64/crange3-cmpct.rd (Machine): Change to refer to SuperH.
        * ld-sh/sh64/crange3-media.rd (Machine): Likewise.
@
text
@d93 2
a3529 3

  /* If TRUE, R_SH_TLS_TPOFF32 relocation is generated.  */
  bfd_boolean tls_tpoff32;
d4041 1
a4041 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
d4043 1
a4043 1
   && ((INFO)->shared							\
d4097 2
a4098 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d4165 1
a4165 1
      /* R_SH_TLS_IE_32 needs one dynamic relocation,
d4168 1
a4168 1
	  || tls_type == GOT_TLS_IE)
d4172 2
a4173 1
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d4198 1
a4198 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
a4234 4
      for (p = eh->dyn_relocs; p; p = p->next)
	if (p->tls_tpoff32)
	  goto keep;

d4752 1
a4752 1
		      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d5052 1
a5052 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d5280 1
a5280 11
		{
		  struct elf_sh_dyn_relocs *p;

		  /* If TPOFF32 relocation can be created, convert it.  */
		  for (p = sh_elf_hash_entry (h)->dyn_relocs; p; p = p->next)
		    if (p->sec == input_section && p->tls_tpoff32)
		      {
			r_type = R_SH_TLS_LE_32;
			break;
		      }
		}
a5289 3
	      int indx;
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
d5366 2
a5367 39
	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
		}

	      if (h == NULL
		  || h->dynindx == -1
		  || (! info->shared
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
		indx = 0;
	      else
		indx = h->dynindx;
	      outrel.r_offset = (input_section->output_section->vma
				 + input_section->output_offset
				 + rel->r_offset);
	      outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d5385 12
d5414 1
a5414 4
	      if (h == NULL
		  || h->dynindx == -1
		  || (! info->shared
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d5418 1
d5600 1
a5600 40
	    {
	      int indx;
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
		}

	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	      outrel.r_offset = (input_section->output_section->vma
				 + input_section->output_offset
				 + rel->r_offset);
	      outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	      continue;
	    }
d5613 7
d5640 5
a5644 1
	    indx = (h && h->dynindx != -1) ? h->dynindx : 0;
d5814 3
a5816 3
 /* If tls_segment is NULL, we should have signalled an error already.  */
 if (elf_hash_table (info)->tls_segment == NULL)
   return 0;
d5820 15
a6295 1
	force_got:
d6301 1
a6579 1
		  p->tls_tpoff32 = FALSE;
d6597 1
a6597 2
	  if (ELF32_R_TYPE (rel->r_info) == R_SH_TLS_LD_32)
	    break;
a6598 1
	  /* FALLTHROUGH */
d6600 1
a6600 81
	  /* We make a R_SH_TLS_TPOFF32 relocation. Count it as a
	     copy relocation.  */
	  if (! info->shared)
	    {
	      struct elf_sh_dyn_relocs *p;
	      struct elf_sh_dyn_relocs **head;

	      if (dynobj == NULL)
		htab->root.dynobj = dynobj = abfd;

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      sreloc = bfd_make_section (dynobj, name);
		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
			return FALSE;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		head = &((struct elf_sh_link_hash_entry *) h)->dyn_relocs;
	      else
		{
		  asection *s;

		  /* Track dynamic relocs needed for local syms too.  */
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return FALSE;

		  head = ((struct elf_sh_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof (*p);
		  p = ((struct elf_sh_dyn_relocs *) bfd_alloc (dynobj, amt));
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		  p->tls_tpoff32 = FALSE;
		}

	      p->count += 1;
	      p->tls_tpoff32 = TRUE;
	    }
@


1.75
log
@Replace occurrances of 'Hitachi' with 'Renesas'.
@
text
@d1 1
a1 1
/* Renesas SH specific support for 32-bit ELF
@


1.75.2.1
log
@Merge from mainline.
@
text
@d1 1
a1 1
/* Renesas / SuperH SH specific support for 32-bit ELF
a92 2
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
d3528 3
d4042 1
a4042 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d4044 1
a4044 1
   && ((SHARED)								\
d4098 1
a4098 2
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d4165 1
a4165 1
      /* R_SH_TLS_IE_32 needs one dynamic relocation if dynamic,
d4168 1
a4168 1
	  || (tls_type == GOT_TLS_IE && dyn))
d4172 1
a4172 2
      else if (info->shared ||
	       WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
d4197 1
a4197 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h))
d4234 4
d4755 1
a4755 1
		      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d5055 1
a5055 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d5283 11
a5293 1
		r_type = R_SH_TLS_LE_32;
d5303 3
d5382 39
a5420 2
	      bfd_put_32 (output_bfd, tpoff (info, relocation),
			  contents + rel->r_offset);
a5437 12
	  /* Relocate R_SH_TLS_IE_32 directly when statically linking.  */
	  if (r_type == R_SH_TLS_IE_32
	      && ! htab->root.dynamic_sections_created)
	    {
	      off &= ~1;
	      bfd_put_32 (output_bfd, tpoff (info, relocation),
			  sgot->contents + off);
	      bfd_put_32 (output_bfd, sgot->output_offset + off,
			  contents + rel->r_offset);
	      continue;
	    }

d5455 4
a5458 1
	      if (h == NULL || h->dynindx == -1)
a5461 1

d5643 40
a5682 1
	    relocation = tpoff (info, relocation);
a5694 7
	    if (! info->shared)
	      {
		relocation = tpoff (info, relocation);
		addend = rel->r_addend;
		goto final_link_relocate;
	      }

d5715 1
a5715 5
	    if (h == NULL || h->dynindx == -1)
	      indx = 0;
	    else
	      indx = h->dynindx;

d5885 3
a5887 3
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
    return 0;
a5890 15
/* Return the relocation value for R_SH_TLS_TPOFF32..  */

static bfd_vma
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
{
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
    return 0;
  /* SH TLS ABI is variant I and static TLS block start just after tcbhead
     structure which has 2 pointer fields.  */
  return (address - dtpoff_base (info) + 8);
}

d6352 1
a6357 1
	force_got:
d6636 1
d6654 2
a6655 1
	  break;
d6657 1
d6659 81
a6739 1
	  /* Nothing to do.  */
@


1.75.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d2057 1
a2057 1
  internal_relocs = (_bfd_elf_link_read_relocs
d2739 1
a2739 1
      internal_relocs = (_bfd_elf_link_read_relocs
a3942 4
      if (info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d4086 1
a4086 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d4172 2
a4173 4
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
a4231 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
a4887 3
	      && (h == NULL
		  || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		  || h->root.type != bfd_link_hash_undefweak)
d5056 1
a5056 3
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
d5738 1
a5738 1
      internal_relocs = (_bfd_elf_link_read_relocs
d6131 1
a6131 11
  if (ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.74
log
@Fix sh-elf linker relaxation:

gcc:
	* config/sh/sh.h (EXTRA_SPECS): Add subtarget_asm_relax_spec and
	subtarget_asm_isa_spec.
	(SUBTARGET_ASM_RELAX_SPEC, SUBTARGET_ASM_ISA_SPEC): Define.
	(ASM_SPEC): Define as SH_ASM_SPEC.
	(SH_ASM_SPEC): New; take the role of ASM_SPEC, but safe from svr4.h.
	Use subtarget_asm_relax_spec and subtarget_asm_isa_spec.
	* config/sh/elf.h (ASM_SPEC): Use SH_ASM_SPEC.
	(SUBTARGET_ASM_ISA_SPEC): Undef / define.
gcc/testsuite:
	gcc.dg/sh-relax.c: New test.

include/elf:
	* sh.h (EF_SH_MERGE_MACH): Make sure SH2E & SH3/SH3E merge to SH3E,
	and SH2E & SH4 merge to SH4, not SH2E.

gas:
	* config/tc-sh.c (sh_dsp): Replace with preset_target_arch.
	(md_begin): Use preset_target_arch.
	(md_longopts): Make isa option unconditional.
	(md_parse_option): Make OPTION_DSP and OPTION_ISA sh4 / any
	set preset_target_arch.
	(md_apply_fix3): If BFD_ASSEMBLER, adjust SWITCH_TABLE fixups
	by -S_GET_VALUE  (fixP->fx_subsy).
	(tc_gen_reloc): For SWITCH_TABLE fixups, the symbol is fixp->fx_subsy,
	and the addend is 0.
	Adjust addend of R_SH_IND12W relocations by fixp->fx_offset - 4.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_LOCAL): Define.

bfd:
	elf32-sh.c (sh_elf_howto_tab): Make R_SH_IND12W into an ordinary
	relocation (no special function), and make it non-partial_inplace.
	(sh_elf_relax_section): When creating a bsr, use a consistent value
	no matter if the symbol is extern or not;  set addend to -4.
	Don't swap load / non-load instructions for SH4.
	(sh_elf_relax_delete_bytes): In R_SH_IND12W case, check the offset
	rather than if the symbol is external to determine if adjusting the
	offset makes sense.  Adjust the addend too if appropriate.
	(sh_elf_relocate_section): In R_SH_IND12W, don't fiddle with the
	relocation.
@
text
@d1 1
a1 1
/* Hitachi SH specific support for 32-bit ELF
@


1.73
log
@	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Simplify dynamic reloc
	removal.  Localize vars.  Remove unnecessary dynobj test.
	* elf32-i386 (WILL_CALL_FINISH_DYNAMIC_SYMBOL): Pass SHARED instead
	of INFO.
	(allocate_dynrelocs): Adjust WILL_CALL_FINISH_DYNAMIC_SYMBOL uses,
	and optimize.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_gc_sweep_hook): Simplify dyn reloc removal.  Localize vars.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.  Remove
	local_dynrel for section too.  Don't touch HIPLT22, LOPLT10, PCPLT32
	or PCPLT10 relocs.  Don't subtract twice on PLT32 relocs.
	Formatting.
@
text
@d182 2
d191 1
a191 1
	 sh_elf_reloc,		/* special_function */
d193 2
a194 2
	 TRUE,			/* partial_inplace */
	 0xfff,			/* src_mask */
d2237 6
d2253 1
d2260 1
d2329 2
a2330 1
  if (have_code)
d2556 8
a2563 2
	  if (ELF32_R_SYM (irel->r_info) >= symtab_hdr->sh_info)
	    start = stop = addr;
a2565 1
	      off = insn & 0xfff;
d2569 9
a4838 1
	  relocation -= 4;
@


1.72
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@d4055 1
a4055 1
         so treat all the gotplt refs as got refs. */
d5416 1
a5416 1
          else
a5921 3
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
  struct elf_sh_link_hash_entry *eh;
d5932 3
d5940 1
a5940 3
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
d5942 4
d5955 8
a5963 1
      eh = (struct elf_sh_link_hash_entry *) h;
d5965 2
a5966 3
      switch (sh_elf_optimized_tls_reloc (info, ELF32_R_TYPE (rel->r_info),
					  ELF32_R_SYM (rel->r_info)
					  >= symtab_hdr->sh_info))
d5999 2
d6026 3
a6028 21
	  if (h != NULL)
	    {
	      struct elf_sh_dyn_relocs **pp;
	      struct elf_sh_dyn_relocs *p;


	      if (!info->shared && h->plt.refcount > 0)
		h->plt.refcount -= 1;

	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    if (ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
		      p->pc_count -= 1;
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	    }
	  break;
d6055 2
@


1.71
log
@	* elf32-sh.c (elf_sh_dyn_relocs): Add tls_tpoff32 field.
	(elf_sh_link_hash_entry): Remove tls_tpoff32 field.
	(sh_elf_link_hash_newfunc): Remove the initialization of
	tls_tpoff32 field.
	(allocate_dynrelocs): Keep dyn_relocs if it includes the entry
	for which tls_tpoff32 flag is set.
	(sh_elf_relocate_section): Covert to LE only if the dyn_relocs
	of the symbol includes the entry matched with the input_section
	and having tls_tpoff32 flag on.	 When linking statically, set
	symbol index of R_SH_TLS_TPOFF32 relocation to zero if the symbol
	is defined in this executable.
	(sh_elf_check_relocs): Set tls_tpoff32 flag appropriately.
@
text
@a4787 1
		   && (! info->symbolic || info->allow_shlib_undefined)
@


1.70
log
@Add SH2E support
@
text
@d3503 3
a3529 3

  /* If TRUE, R_SH_TLS_TPOFF32 relocation is generated.  */
  bfd_boolean tls_tpoff32;
a3632 1
      ret->tls_tpoff32 = FALSE;
d4209 3
a4211 2
      if (sh_elf_hash_entry (h)->tls_tpoff32)
	goto keep;
d5259 12
a5270 4
		      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  && (tls_type == GOT_TLS_IE
		      || sh_elf_hash_entry (h)->tls_tpoff32))
		r_type = R_SH_TLS_LE_32;
d5379 7
a5385 1
	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
d5432 7
a5438 1
	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
d6619 1
d6717 1
d6721 1
a6721 2
	      if (h)
		sh_elf_hash_entry (h)->tls_tpoff32 = TRUE;
@


1.69
log
@Treat elfNN_bed like other macros defined in elfxx-target.h and #undef it
before #define'ing it.
@
text
@d6727 3
@


1.68
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d65 1
a65 1
  PARAMS((bfd *));
d67 1
a67 1
  PARAMS((bfd *));
d88 1
a88 1
  PARAMS((bfd *, struct bfd_link_info *));
d7331 1
a7331 1
/* Support for Linux core dump NOTE sections */
d7465 1
a7465 1

a7469 1
#undef	elf32_bed
d7485 1
a7485 1

a7488 4

#undef	elf_backend_grok_prstatus
#undef	elf_backend_grok_psinfo
#undef	elf32_bed
@


1.67
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d37 1
a37 1
static boolean sh_elf_set_private_flags
d39 1
a39 1
static boolean sh_elf_copy_private_data
d41 1
a41 1
static boolean sh_elf_merge_private_data
d43 1
a43 1
static boolean sh_elf_set_mach_from_flags
d45 3
a47 3
static boolean sh_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, boolean *));
static boolean sh_elf_relax_delete_bytes
d49 3
a51 3
static boolean sh_elf_align_loads
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_byte *, boolean *));
static boolean sh_elf_swap_insns
d53 1
a53 1
static boolean sh_elf_relocate_section
d58 1
a58 1
	   bfd_byte *, boolean, asymbol **));
d64 1
a64 1
static boolean sh_elf_mkobject
d66 1
a66 1
static boolean sh_elf_object_p
d68 1
a68 1
static boolean sh_elf_check_relocs
d75 1
a75 1
static boolean sh_elf_adjust_dynamic_symbol
d77 1
a77 1
static boolean sh_elf_size_dynamic_sections
d79 1
a79 1
static boolean sh_elf_finish_dynamic_symbol
d82 1
a82 1
static boolean sh_elf_finish_dynamic_sections
d87 1
a87 1
static boolean create_got_section
d89 1
a89 1
static boolean sh_elf_create_dynamic_sections
d96 1
a96 1
static boolean sh_elf_gc_sweep_hook
d99 1
a99 1
static boolean allocate_dynrelocs
d101 1
a101 1
static boolean readonly_dynrelocs
d108 1
a108 1
static boolean elf32_shlin_grok_prstatus
d110 1
a110 1
static boolean elf32_shlin_grok_psinfo
d125 1
a125 1
	 false,			/* pc_relative */
d130 1
a130 1
	 false,			/* partial_inplace */
d133 1
a133 1
	 false),		/* pcrel_offset */
d135 1
a135 1
  /* 32 bit absolute relocation.  Setting partial_inplace to true and
d141 1
a141 1
	 false,			/* pc_relative */
d146 1
a146 1
	 true,			/* partial_inplace */
d149 1
a149 1
	 false),		/* pcrel_offset */
d156 1
a156 1
	 true,			/* pc_relative */
d161 1
a161 1
	 true,			/* partial_inplace */
d164 1
a164 1
	 true),			/* pcrel_offset */
d171 1
a171 1
	 true,			/* pc_relative */
d176 1
a176 1
	 true,			/* partial_inplace */
d179 1
a179 1
	 true),			/* pcrel_offset */
d186 1
a186 1
	 true,			/* pc_relative */
d191 1
a191 1
	 true,			/* partial_inplace */
d194 1
a194 1
	 true),			/* pcrel_offset */
d201 1
a201 1
	 true,			/* pc_relative */
d206 1
a206 1
	 true,			/* partial_inplace */
d209 1
a209 1
	 true),			/* pcrel_offset */
d216 1
a216 1
	 true,			/* pc_relative */
d221 1
a221 1
	 true,			/* partial_inplace */
d224 1
a224 1
	 true),			/* pcrel_offset */
d233 1
a233 1
	 false,			/* pc_relative */
d238 1
a238 1
	 false,			/* partial_inplace */
d241 1
a241 1
	 true),			/* pcrel_offset */
d250 1
a250 1
	 false,			/* pc_relative */
d255 1
a255 1
	 false,			/* partial_inplace */
d258 1
a258 1
	 true),			/* pcrel_offset */
d267 1
a267 1
	 false,			/* pc_relative */
d272 1
a272 1
	 false,			/* partial_inplace */
d275 1
a275 1
	 true),			/* pcrel_offset */
d305 1
a305 1
	 false,			/* pc_relative */
d310 1
a310 1
	 false,			/* partial_inplace */
d313 1
a313 1
	 true),			/* pcrel_offset */
d322 1
a322 1
	 false,			/* pc_relative */
d327 1
a327 1
	 false,			/* partial_inplace */
d330 1
a330 1
	 true),			/* pcrel_offset */
d340 1
a340 1
	 false,			/* pc_relative */
d345 1
a345 1
	 false,			/* partial_inplace */
d348 1
a348 1
	 true),			/* pcrel_offset */
d358 1
a358 1
	 false,			/* pc_relative */
d363 1
a363 1
	 false,			/* partial_inplace */
d366 1
a366 1
	 true),			/* pcrel_offset */
d375 1
a375 1
	 false,			/* pc_relative */
d380 1
a380 1
	 false,			/* partial_inplace */
d383 1
a383 1
	 true),			/* pcrel_offset */
d392 1
a392 1
	 false,			/* pc_relative */
d397 1
a397 1
	 false,			/* partial_inplace */
d400 1
a400 1
	 true),			/* pcrel_offset */
d408 1
a408 1
	 false,			/* pc_relative */
d413 1
a413 1
	 false,			/* partial_inplace */
d416 1
a416 1
	 true),			/* pcrel_offset */
d425 1
a425 1
	 false,			/* pc_relative */
d430 1
a430 1
	 false,			/* partial_inplace */
d433 1
a433 1
	 true),			/* pcrel_offset */
d442 1
a442 1
	 false,			/* pc_relative */
d447 1
a447 1
	 false,			/* partial_inplace */
d450 1
a450 1
	 true),			/* pcrel_offset */
d457 1
a457 1
	 false,			/* pc_relative */
d462 1
a462 1
	 false,			/* partial_inplace */
d465 1
a465 1
	 false),		/* pcrel_offset */
d472 1
a472 1
	 false,			/* pc_relative */
d477 1
a477 1
	 false,			/* partial_inplace */
d480 1
a480 1
	 false),		/* pcrel_offset */
d487 1
a487 1
	 false,			/* pc_relative */
d492 1
a492 1
	 true,			/* partial_inplace */
d495 1
a495 1
	 true),			/* pcrel_offset */
d502 1
a502 1
	 false,			/* pc_relative */
d507 1
a507 1
	 true,			/* partial_inplace */
d510 1
a510 1
	 true),			/* pcrel_offset */
d526 1
a526 1
	 false,			/* pc_relative */
d531 1
a531 1
	 false,			/* partial_inplace */
d534 1
a534 1
	 false),		/* pcrel_offset */
d541 1
a541 1
	 false,			/* pc_relative */
d546 1
a546 1
	 false,			/* partial_inplace */
d549 1
a549 1
	 false),		/* pcrel_offset */
d556 1
a556 1
	 false,			/* pc_relative */
d561 1
a561 1
	 false,			/* partial_inplace */
d564 1
a564 1
	 false),		/* pcrel_offset */
d571 1
a571 1
	 false,			/* pc_relative */
d576 1
a576 1
	 false,			/* partial_inplace */
d579 1
a579 1
	 false),		/* pcrel_offset */
d586 1
a586 1
	 false,			/* pc_relative */
d591 1
a591 1
	 false,			/* partial_inplace */
d594 1
a594 1
	 false),		/* pcrel_offset */
d601 1
a601 1
	 false,			/* pc_relative */
d606 1
a606 1
	 false,			/* partial_inplace */
d609 1
a609 1
	 false),		/* pcrel_offset */
d616 1
a616 1
	 false,			/* pc_relative */
d621 1
a621 1
	 false,			/* partial_inplace */
d624 1
a624 1
	 false),		/* pcrel_offset */
d733 1
a733 1
	 false,			/* pc_relative */
d738 1
a738 1
	 true,			/* partial_inplace */
d741 1
a741 1
	 false),		/* pcrel_offset */
d747 1
a747 1
	 false,			/* pc_relative */
d752 1
a752 1
	 true,			/* partial_inplace */
d755 1
a755 1
	 false),		/* pcrel_offset */
d761 1
a761 1
	 false,			/* pc_relative */
d766 1
a766 1
	 true,			/* partial_inplace */
d769 1
a769 1
	 false),		/* pcrel_offset */
d775 1
a775 1
	 false,			/* pc_relative */
d780 1
a780 1
	 true,			/* partial_inplace */
d783 1
a783 1
	 false),		/* pcrel_offset */
d789 1
a789 1
	 false,			/* pc_relative */
d794 1
a794 1
	 true,			/* partial_inplace */
d797 1
a797 1
	 false),		/* pcrel_offset */
d803 1
a803 1
	 false,			/* pc_relative */
d808 1
a808 1
	 true,			/* partial_inplace */
d811 1
a811 1
	 false),		/* pcrel_offset */
d817 1
a817 1
	 false,			/* pc_relative */
d822 1
a822 1
	 true,			/* partial_inplace */
d825 1
a825 1
	 false),		/* pcrel_offset */
d831 1
a831 1
	 false,			/* pc_relative */
d836 1
a836 1
	 true,			/* partial_inplace */
d839 1
a839 1
	 false),		/* pcrel_offset */
d854 1
a854 1
	 false,			/* pc_relative */
d859 1
a859 1
	 true,			/* partial_inplace */
d862 1
a862 1
	 false),		/* pcrel_offset */
d868 1
a868 1
	 true,			/* pc_relative */
d873 1
a873 1
	 true,			/* partial_inplace */
d876 1
a876 1
	 true),			/* pcrel_offset */
d882 1
a882 1
	 false,			/* pc_relative */
d887 1
a887 1
	 true,			/* partial_inplace */
d890 1
a890 1
	 false),		/* pcrel_offset */
d896 1
a896 1
	 false,			/* pc_relative */
d901 1
a901 1
	 true,			/* partial_inplace */
d904 1
a904 1
	 false),		/* pcrel_offset */
d910 1
a910 1
	 false,			/* pc_relative */
d915 1
a915 1
	 true,			/* partial_inplace */
d918 1
a918 1
	 false),		/* pcrel_offset */
d924 1
a924 1
	 false,			/* pc_relative */
d929 1
a929 1
	 true,			/* partial_inplace */
d932 1
a932 1
	 false),		/* pcrel_offset */
d938 1
a938 1
	 false,			/* pc_relative */
d943 1
a943 1
	 true,			/* partial_inplace */
d946 1
a946 1
	 false),		/* pcrel_offset */
d952 1
a952 1
	 true,			/* pc_relative */
d957 1
a957 1
	 true,			/* partial_inplace */
d960 1
a960 1
	 true),			/* pcrel_offset */
d966 1
a966 1
	 false,			/* pc_relative */
d971 1
a971 1
	 false,			/* partial_inplace */
d974 1
a974 1
	 false),		/* pcrel_offset */
d982 1
a982 1
	 false,			/* pc_relative */
d987 1
a987 1
	 false,			/* partial_inplace */
d990 1
a990 1
	 false),		/* pcrel_offset */
d997 1
a997 1
	 false,			/* pc_relative */
d1002 1
a1002 1
	 false,			/* partial_inplace */
d1005 1
a1005 1
	 false),		/* pcrel_offset */
d1012 1
a1012 1
	 false,			/* pc_relative */
d1017 1
a1017 1
	 false,			/* partial_inplace */
d1020 1
a1020 1
	 false),		/* pcrel_offset */
d1027 1
a1027 1
	 false,			/* pc_relative */
d1032 1
a1032 1
	 false,			/* partial_inplace */
d1035 1
a1035 1
	 false),		/* pcrel_offset */
d1042 1
a1042 1
	 false,			/* pc_relative */
d1047 1
a1047 1
	 false,			/* partial_inplace */
d1050 1
a1050 1
	 false),		/* pcrel_offset */
d1057 1
a1057 1
	 false,			/* pc_relative */
d1062 1
a1062 1
	 false,			/* partial_inplace */
d1065 1
a1065 1
	 false),		/* pcrel_offset */
d1072 1
a1072 1
	 false,			/* pc_relative */
d1077 1
a1077 1
	 false,			/* partial_inplace */
d1080 1
a1080 1
	 false),		/* pcrel_offset */
d1087 1
a1087 1
	 false,			/* pc_relative */
d1092 1
a1092 1
	 false,			/* partial_inplace */
d1095 1
a1095 1
	 false),		/* pcrel_offset */
d1102 1
a1102 1
	 true,			/* pc_relative */
d1107 1
a1107 1
	 false,			/* partial_inplace */
d1110 1
a1110 1
	 true),			/* pcrel_offset */
d1117 1
a1117 1
	 true,			/* pc_relative */
d1122 1
a1122 1
	 false,			/* partial_inplace */
d1125 1
a1125 1
	 true),			/* pcrel_offset */
d1132 1
a1132 1
	 true,			/* pc_relative */
d1137 1
a1137 1
	 false,			/* partial_inplace */
d1140 1
a1140 1
	 true),			/* pcrel_offset */
d1147 1
a1147 1
	 true,			/* pc_relative */
d1152 1
a1152 1
	 false,			/* partial_inplace */
d1155 1
a1155 1
	 true),			/* pcrel_offset */
d1162 1
a1162 1
	 false,			/* pc_relative */
d1167 1
a1167 1
	 false,			/* partial_inplace */
d1170 1
a1170 1
	 false),		/* pcrel_offset */
d1177 1
a1177 1
	 false,			/* pc_relative */
d1182 1
a1182 1
	 false,			/* partial_inplace */
d1185 1
a1185 1
	 false),		/* pcrel_offset */
d1192 1
a1192 1
	 false,			/* pc_relative */
d1197 1
a1197 1
	 false,			/* partial_inplace */
d1200 1
a1200 1
	 false),		/* pcrel_offset */
d1207 1
a1207 1
	 false,			/* pc_relative */
d1212 1
a1212 1
	 false,			/* partial_inplace */
d1215 1
a1215 1
	 false),		/* pcrel_offset */
d1222 1
a1222 1
	 true,			/* pc_relative */
d1227 1
a1227 1
	 false,			/* partial_inplace */
d1230 1
a1230 1
	 true),			/* pcrel_offset */
d1237 1
a1237 1
	 true,			/* pc_relative */
d1242 1
a1242 1
	 false,			/* partial_inplace */
d1245 1
a1245 1
	 true),			/* pcrel_offset */
d1252 1
a1252 1
	 true,			/* pc_relative */
d1257 1
a1257 1
	 false,			/* partial_inplace */
d1260 1
a1260 1
	 true),			/* pcrel_offset */
d1267 1
a1267 1
	 true,			/* pc_relative */
d1272 1
a1272 1
	 false,			/* partial_inplace */
d1275 1
a1275 1
	 true),			/* pcrel_offset */
d1282 1
a1282 1
	 false,			/* pc_relative */
d1287 1
a1287 1
	 false,			/* partial_inplace */
d1290 1
a1290 1
	 false),		/* pcrel_offset */
d1297 1
a1297 1
	 false,			/* pc_relative */
d1302 1
a1302 1
	 false,			/* partial_inplace */
d1305 1
a1305 1
	 false),		/* pcrel_offset */
d1312 1
a1312 1
	 false,			/* pc_relative */
d1317 1
a1317 1
	 false,			/* partial_inplace */
d1320 1
a1320 1
	 false),		/* pcrel_offset */
d1327 1
a1327 1
	 false,			/* pc_relative */
d1332 1
a1332 1
	 false,			/* partial_inplace */
d1335 1
a1335 1
	 false),		/* pcrel_offset */
d1341 1
a1341 1
	 false,			/* pc_relative */
d1346 1
a1346 1
	 false,			/* partial_inplace */
d1349 1
a1349 1
	 false),		/* pcrel_offset */
d1355 1
a1355 1
	 false,			/* pc_relative */
d1360 1
a1360 1
	 false,			/* partial_inplace */
d1363 1
a1363 1
	 false),		/* pcrel_offset */
d1369 1
a1369 1
	 false,			/* pc_relative */
d1374 1
a1374 1
	 false,			/* partial_inplace */
d1377 1
a1377 1
	 false),		/* pcrel_offset */
d1383 1
a1383 1
	 false,			/* pc_relative */
d1388 1
a1388 1
	 false,			/* partial_inplace */
d1391 1
a1391 1
	 false),		/* pcrel_offset */
d1452 1
a1452 1
	 false,			/* pc_relative */
d1457 1
a1457 1
	 false,			/* partial_inplace */
d1460 1
a1460 1
	 false),		/* pcrel_offset */
d1469 1
a1469 1
	 true,			/* pc_relative */
d1474 1
a1474 1
	 false,			/* partial_inplace */
d1477 1
a1477 1
	 true),			/* pcrel_offset */
d1484 1
a1484 1
	 false,			/* pc_relative */
d1489 1
a1489 1
	 false,			/* partial_inplace */
d1492 1
a1492 1
	 false),		/* pcrel_offset */
d1499 1
a1499 1
	 false,			/* pc_relative */
d1504 1
a1504 1
	 false,			/* partial_inplace */
d1507 1
a1507 1
	 false),		/* pcrel_offset */
d1514 1
a1514 1
	 false,			/* pc_relative */
d1519 1
a1519 1
	 false,			/* partial_inplace */
d1522 1
a1522 1
	 false),		/* pcrel_offset */
d1529 1
a1529 1
	 true,			/* pc_relative */
d1534 1
a1534 1
	 false,			/* partial_inplace */
d1537 1
a1537 1
	 true),			/* pcrel_offset */
d1544 1
a1544 1
	 false,			/* pc_relative */
d1549 1
a1549 1
	 false,			/* partial_inplace */
d1552 1
a1552 1
	 false),		/* pcrel_offset */
d1559 1
a1559 1
	 true,			/* pc_relative */
d1564 1
a1564 1
	 false,			/* partial_inplace */
d1567 1
a1567 1
	 true),			/* pcrel_offset */
d1574 1
a1574 1
	 false,			/* pc_relative */
d1579 1
a1579 1
	 false,			/* partial_inplace */
d1582 1
a1582 1
	 false),		/* pcrel_offset */
d1589 1
a1589 1
	 true,			/* pc_relative */
d1594 1
a1594 1
	 false,			/* partial_inplace */
d1597 1
a1597 1
	 true),			/* pcrel_offset */
d1604 1
a1604 1
	 false,			/* pc_relative */
d1609 1
a1609 1
	 false,			/* partial_inplace */
d1612 1
a1612 1
	 false),		/* pcrel_offset */
d1619 1
a1619 1
	 true,			/* pc_relative */
d1624 1
a1624 1
	 false,			/* partial_inplace */
d1627 1
a1627 1
	 true),			/* pcrel_offset */
d1634 1
a1634 1
	 false,			/* pc_relative */
d1639 1
a1639 1
	 false,			/* partial_inplace */
d1642 1
a1642 1
	 false),		/* pcrel_offset */
d1649 1
a1649 1
	 true,			/* pc_relative */
d1654 1
a1654 1
	 false,			/* partial_inplace */
d1657 1
a1657 1
	 true),			/* pcrel_offset */
d2017 1
a2017 1
static boolean
d2022 1
a2022 1
     boolean *again;
d2026 1
a2026 1
  boolean have_code;
d2031 1
a2031 1
  *again = false;
d2036 1
a2036 1
    return true;
d2042 1
a2042 1
      return true;
d2059 1
a2059 1
  have_code = false;
d2070 1
a2070 1
	have_code = true;
d2282 1
a2282 1
      *again = true;
d2321 1
a2321 1
      boolean swapped;
d2380 1
a2380 1
  return true;
d2393 1
a2393 1
  return false;
d2400 1
a2400 1
static boolean
d2470 1
a2470 1
      boolean overflow;
d2622 1
a2622 1
	  overflow = false;
d2633 1
a2633 1
		overflow = true;
d2640 1
a2640 1
		overflow = true;
d2654 1
a2654 1
		overflow = true;
d2661 1
a2661 1
		overflow = true;
d2668 1
a2668 1
		overflow = true;
d2688 1
a2688 1
	      return false;
d2710 1
a2710 1
	 false, we should free them, if we are permitted to, when we
d2714 1
a2714 1
			  true));
d2716 1
a2716 1
	return false;
d2735 1
a2735 1
			 Perhaps, if info->keep_memory is false, we
d2740 1
a2740 1
			return false;
d2744 1
a2744 1
			return false;
d2793 1
a2793 1
			 Perhaps, if info->keep_memory is false, we
d2798 1
a2798 1
			return false;
d2802 1
a2802 1
			return false;
d2861 1
a2861 1
  return true;
d2867 1
a2867 1
static boolean
d2873 1
a2873 1
     boolean *pswapped;
d2880 1
a2880 1
  *pswapped = false;
d2931 1
a2931 1
  return true;
d2936 1
a2936 1
  return false;
d2941 1
a2941 1
static boolean
d3010 1
a3010 1
	  boolean overflow;
d3013 1
a3013 1
	  overflow = false;
d3025 1
a3025 1
		overflow = true;
d3034 1
a3034 1
		overflow = true;
d3051 1
a3051 1
		    overflow = true;
d3064 1
a3064 1
	      return false;
d3069 1
a3069 1
  return true;
d3528 2
a3529 2
  /* If true, R_SH_TLS_TPOFF32 relocation is generated.  */
  boolean tls_tpoff32;
d3551 1
a3551 1
static boolean
d3558 2
a3559 2
    return false;
  return true;
d3561 1
a3561 1
                 
d3593 1
a3593 1
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
d3633 1
a3633 1
      ret->tls_tpoff32 = false;
d3675 1
a3675 1
static boolean
d3683 1
a3683 1
    return false;
d3701 2
a3702 2
    return false;
  return true;
d3707 1
a3707 1
static boolean
d3730 1
a3730 1
      return false;
d3753 1
a3753 1
    return false;
d3764 1
a3764 1
	      (bfd_vma) 0, (const char *) NULL, false,
d3766 1
a3766 1
	return false;
d3774 1
a3774 1
	return false;
d3783 1
a3783 1
    return false;
d3786 1
a3786 1
    return false;
d3808 1
a3808 1
	  return false;
d3824 1
a3824 1
	return false;
d3846 1
a3846 1
	    return false;
d3850 1
a3850 1
  return true;
d3859 1
a3859 1
static boolean
d3906 1
a3906 1
      return true;
d3920 1
a3920 1
      return true;
d3931 1
a3931 1
    return true;
d3936 1
a3936 1
    return true;
d3942 1
a3942 1
      return true;
d3959 1
a3959 1
      return true;
d4001 1
a4001 1
	return false;
d4011 1
a4011 1
  return true;
d4028 1
a4028 1
static boolean
d4039 1
a4039 1
    return true;
d4071 1
a4071 1
	    return false;
d4122 1
a4122 1
      boolean dyn;
d4131 1
a4131 1
	    return false;
d4158 1
a4158 1
      boolean dyn;
d4166 1
a4166 1
	    return false;
d4181 1
a4181 1
    return true;
d4230 1
a4230 1
		return false;
d4251 1
a4251 1
  return true;
d4256 1
a4256 1
static boolean
d4279 1
a4279 1
	  return false;
d4282 1
a4282 1
  return true;
d4287 1
a4287 1
static boolean
d4295 1
a4295 1
  boolean relocs;
d4403 1
a4403 1
  relocs = false;
d4419 1
a4419 1
	    relocs = true;
d4454 1
a4454 1
	return false;
d4470 1
a4470 1
	    return false;
d4479 1
a4479 1
	    return false;
d4488 1
a4488 1
	    return false;
d4499 1
a4499 1
		return false;
d4505 1
a4505 1
  return true;
d4510 1
a4510 1
static boolean
d4589 1
a4589 1
	  return false;
d4671 1
a4671 1
		  return false;
d4707 1
a4707 1
	      boolean dyn;
d4773 1
a4773 1
		  return false;
d4799 1
a4799 1
		return false;
d4848 1
a4848 1
		  return false;
d4863 1
a4863 1
	  return false;
d4879 1
a4879 1
	      boolean skip, relocate;
d4894 1
a4894 1
		    return false;
d4905 2
a4906 2
	      skip = false;
	      relocate = false;
d4912 1
a4912 1
		skip = true;
d4914 1
a4914 1
		skip = true, relocate = true;
d4936 1
a4936 1
		      relocate = true;
d5017 1
a5017 1
	      boolean dyn;
d5280 1
a5280 1
		       jsr @@r1; add r12,r4; bra 3f; nop; .align 2; 
d5360 1
a5360 1
		    return false;
d5614 1
a5614 1
		    return false;
d5661 1
a5661 1
		  return false;
d5708 1
a5708 1
		      return false;
d5715 1
a5715 1
		  return false;
d5722 1
a5722 1
  return true;
d5735 1
a5735 1
     boolean relocateable;
d5768 1
a5768 1
			  (Elf_Internal_Rela *) NULL, false));
d5892 1
a5892 1
static boolean
d6080 1
a6080 1
  return true;
d6180 1
a6180 1
static boolean
d6205 1
a6205 1
    return true;
d6291 1
a6291 1
		return false;
d6305 1
a6305 1
	    return false;
d6312 1
a6312 1
	    return false;
d6349 2
a6350 2
		  struct elf_sh_link_hash_entry *eh = 
		    (struct elf_sh_link_hash_entry *)h;
d6381 1
a6381 1
		    return false;
d6414 1
a6414 1
		  return false;
d6543 1
a6543 1
		    return false;
d6562 1
a6562 1
			return false;
d6581 1
a6581 1
		    return false;
d6593 1
a6593 1
		    return false;
d6613 1
a6613 1
	      return false;
d6640 1
a6640 1
		    return false;
d6659 1
a6659 1
			return false;
d6678 1
a6678 1
		    return false;
d6690 1
a6690 1
		    return false;
d6700 1
a6700 1
		sh_elf_hash_entry (h)->tls_tpoff32 = true;
d6709 1
a6709 1
  return true;
d6713 1
a6713 1
static boolean
d6744 1
a6744 1
      return false;
d6746 1
a6746 1
  return true;
d6753 1
a6753 1
static boolean
d6762 1
a6762 1
  elf_flags_init (abfd) = true;
d6770 1
a6770 1
static boolean
d6777 1
a6777 1
    return true;
d6787 1
a6787 1
static boolean
d6795 1
a6795 1
    return false;
d6799 1
a6799 1
    return true;
d6804 1
a6804 1
      elf_flags_init (obfd) = true;
d6818 1
a6818 1
      return false;
d6830 1
a6830 1
static boolean
d6837 2
a6838 2
  if (sh_elf_set_mach_from_flags (abfd) == false)
    return false;
d6843 1
a6843 1
    return false;
d6846 1
a6846 1
  return true;
d6852 1
a6852 1
static boolean
d7137 1
a7137 1
  return true;
d7142 1
a7142 1
static boolean
d7195 1
a7195 1
					    false, false, true);
d7311 1
a7311 1
  return true;
d7332 1
a7332 1
static boolean
d7343 1
a7343 1
	return false;
d7364 1
a7364 1
static boolean
d7372 1
a7372 1
	return false;
d7393 1
a7393 1
  return true;
@


1.66
log
@	* elf32-sh.c (sh_elf_relocate_section): Don't complain about
        unresolved debugging relocs in dynamic applications.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* ld-sh/refdbg-0-dso.d: New test.
	* ld-sh/refdbg-1.d: Likewise.
	* ld-sh/refdbg.s: Likewise.
	* ld-sh/refdbglib.s: Likewise.
@
text
@d4878 1
d4952 3
a4954 5
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;
d5108 1
d5122 3
a5124 5
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						(((Elf32_External_Rela *)
						  srelgot->contents)
						 + srelgot->reloc_count));
		      ++srelgot->reloc_count;
d5274 1
a5379 5
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;
d5381 3
d5406 1
a5406 1
	      Elf32_External_Rela *loc;
d5426 2
a5427 2
	      loc = (Elf32_External_Rela *) srelgot->contents;
	      loc += srelgot->reloc_count++;
d5445 2
a5446 3
		      loc++;
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						loc);
d5577 1
a5577 1
	      Elf32_External_Rela *loc;
d5587 2
a5588 2
	      loc = (Elf32_External_Rela *) srelgot->contents;
	      loc += srelgot->reloc_count++;
d5603 1
a5633 5
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;
d5635 3
d5650 1
a5680 5
	    bfd_elf32_swap_reloca_out (output_bfd, &outrel,
				       (((Elf32_External_Rela *)
					 sreloc->contents)
					+ sreloc->reloc_count));
	    ++sreloc->reloc_count;
d5682 3
d6874 1
d6994 2
a6995 3
      bfd_elf32_swap_reloca_out (output_bfd, &rel,
				((Elf32_External_Rela *) srel->contents
				 + plt_index));
d7012 1
d7048 3
a7050 4
      bfd_elf32_swap_reloca_out (output_bfd, &rel,
				 ((Elf32_External_Rela *) srel->contents
				  + srel->reloc_count));
      ++srel->reloc_count;
d7063 1
d7100 3
a7102 4
	bfd_elf32_swap_reloca_out (output_bfd, &rel,
				   ((Elf32_External_Rela *) srel->contents
				    + srel->reloc_count));
	++srel->reloc_count;
d7111 1
d7128 2
a7129 4
      bfd_elf32_swap_reloca_out (output_bfd, &rel,
				 ((Elf32_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
@


1.65
log
@	* Makefile.am: Remove entries for elf32-qnx.[ch].
	* Makefile.in: Regenerate.
	* config.bfd: Change arm-nto to use bfd_elf32_{big|little}arm_vec,
	ppc-nto to use bfd_elf32_powerpc{le}_vec, sh-nto to use
	bfd_elf32_sh{l}_vec, and i386-nto to use bfd_elf32_i386_vec.
	* configure.in: Remove support for bfd_elf32_sh{l}qnx_vec,
	bfd_elf32_powerpc{le}qnx_vec, bfd_elf32_{big|little}armqnx_vec,
	and bfd_elf32_i386qnx_vec, and removed elf32-qnx.lo from other targets.
	bfd_elf32_sh{l}_vec, and i386-nto to use bfd_elf32_i386_vec.
	* configure: Regenerate.
	* elf32-qnx.c: Remove.
	* elf32-qnx.h: Remove.
	* elf.c: Remove calls to QNX specific set_nonloadable_filepos,
	is_contained_by_filepos, and copy_private_bfd_data_p.
	* elf32-i386.c: Remove QNX extended bfd support.
	* elf32-ppc.c: Remove QNX extended bfd support.
	* elf32-sh.c: Remove QNX extended bfd support.
	* elfarm-nabi.c: Remove QNX extended bfd support.
	* targets.c: Remove qnx vectors.
	* elfxx-target.h (elf_backend_set_nonloadable_filepos): Remove
	(elf_backend_is_contained_by_filepos): Remove.
	(elf_backend_copy_private_bfd_data_p): Remove.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@d4756 7
@


1.64
log
@	* Makefile.am (BFD32_BACKENDS): Remove elfarmqnx-nabi.lo,
	elf32-i386-fbsd.lo, elf32-i386qnx.lo, elf32-ppcqnx.lo,
	elf32-sh-lin.lo, elf32-sh64-lin.lo, elf32-sh-nbsd.lo,
	elf32-sh64-nbsd.lo, elf32-shqnx.lo.  Add elf32-qnx.lo.
	(BFD32_BACKENDS_CFILES): Likewise for corresponding C files.
	(BFD64_BACKENDS): Remove elf64-sh64-lin.lo, elf64-sh64-nbsd.lo.
	(BFD64_BACKENDS_CFILES): Likewise for corresponding C files.
	(SOURCE_HFILES): Add elf32-qnx.h.
	(BUILD_HFILES): Add bfdver.h.
	Run "make dep-am".
	* Makefile.in: Regenerate.
	* configure.in Update bfd vector dependencies.
	* configure: Regenerate.
	* elf32-i386-fbsd.c: Delete.  Move code to elf32-i386.c.
	* elf32-i386qnx.c: Likewise.
	* elf32-ppcqnx.c: Delete.  Move code to elf32-ppc.c.
	* elf32-sh-nbsd.c: Delete.  Move code to elf32-sh.c.
	* elf32-sh-lin.c: Likewise.
	* elf32-shqnx.c: Likewise.
	* elf32-sh64-lin.c: Delete.  Move code to elf32-sh64.c.
	* elf32-sh64-nbsd.c: Likewise.
	* elf64-sh64-lin.c: Delete.  Move code to elf64-sh64.c.
	* elf64-sh64-nbsd.c: Likewise.
	* elfarmqnx-nabi.c: Delete.  Move code to elfarm-nabi.c.
	* elf32-arm.h (ELF_MAXPAGESIZE): Always define.
	* elf32-i386.c: Remove ELF_ARCH and ELF32_I386_C_INCLUDED tests.
	* elf32-ppc.c: Remove ELF32_PPC_C_INCLUDED tests.
	* elf32-qnx.h (elf_backend_set_nonloadable_filepos): Always define.
	(elf_backend_is_contained_by_filepos): Likewise.
	(elf_backend_copy_private_bfd_data_p): Likewise.
	Globalize and move functions to..
	* elf32-qnx.c: ..here.  New file.
	* elf32-sh.c: Remove ELF_ARCH and ELF32_SH_C_INCLUDED tests.  Don't
	emit target vectors when INCLUDE_SHMEDIA.
	* elf32-sh64.c: Remove ELF_ARCH test.  Move TARGET_* etc. defines to
	end of file.
	* elf64-sh64.c: Remove ELF_ARCH test.
	* elfarm-nabi.c: Remove ELFARM_NABI_C_INCLUDED test.
	* po/BLD-POTFILES.in: Regenerate.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@a7451 23
/* QNX support.  */
#include "elf32-qnx.h"

#undef	TARGET_LITTLE_SYM 
#define	TARGET_LITTLE_SYM		bfd_elf32_shlqnx_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-shl-nto"
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shqnx_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-sh-nto"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x1000

#define	elf32_bed			elf32_sh_qnx_bed

#include "elf32-target.h"

#undef	elf_backend_set_nonloadable_filepos
#undef	elf_backend_is_contained_by_filepos
#undef	elf_backend_copy_private_bfd_data_p
#undef	elf32_bed

@


1.63
log
@* elf32-sh.c (elf_sh_link_hash_entry): Replace
datalabel_got_offset with union of datalabel_got
offset and refcount.
(sh_elf_link_hash_newfunc): Initialize datalabel_got.refcount.
(allocate_dynrelocs): Delete unnecessary code for
STT_DATALABEL type.  Create entry in got for
datalabel version of symbol if datalabel_got.refcount > 0.
(sh_elf_relocate_section): Use datalabel_got union.
(sh_elf_gc_sweep_hook): Pull common code to initialize
h and eh out of switch statement.  Declare seen_stt_datalabel.
Initialize it.  Decrement datalabel_got.refcount for
got relocs when seen_stt_datalabel is true.
Decrement local_got_refcounts entry for datalabel got relocs
of local symbols.
(sh_elf_copy_indirect_symbol): Copy datalabel_got field over.
(sh_elf_check_relocs): Declare seen_stt_datalabel.
Initialize it.  When seen_stt_datalabel is true, increment
datalabel_got refcount rather than got.refcount.
(sh_elf_finish_dynamic_symbol): Create relocs to
initialize got entry for datalabel version of symbol.
@
text
@d108 4
d7331 65
a7395 1
#ifndef ELF_ARCH
a7404 1
#endif /* ELF_ARCH */
d7448 20
a7467 1
#ifndef ELF32_SH_C_INCLUDED
a7468 1
#endif
d7470 49
@


1.62
log
@	* elf32-sh.c (sh_elf_optimized_tls_reloc, sh_elf_mkobject,
	sh_elf_object_p, dtpoff_base): New functions.
	(sh_elf_howto_table): Add TLS relocs.
	(sh_reloc_map): Likewise.
	(sh_elf_info_to_howto): Support TLS relocs.
	(elf_sh_link_hash_entry): Add tls_type and tls_tpoff32.
	(sh_elf_hash_entry, sh_elf_tdata, sh_elf_local_got_tls_type):
	New macros.
	(sh_elf_obj_tdata): New.
	(elf_sh_link_hash_table): Add tls_ldm_got.
	(sh_elf_link_hash_table_create): Clear refcount of tls_ldm_got.
	(allocate_dynrelocs): Support TLS relocs.
	(sh_elf_size_dynamic_sections): Likewise.
	(sh_elf_relocate_section): Support TLS relocs.  Don't try to find
	.rela.got section when found already.  Return false after printing
	error about unresolvable relocation.
	(sh_elf_gc_sweep_hook): Support TLS relocs.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define for TLS case.
	* reloc.c: Add SH TLS relocs.
	* libbfd.h: Regenerate.
@
text
@d3508 5
a3512 1
  bfd_vma datalabel_got_offset;
d3623 2
a3624 5
      struct elf_sh_link_hash_entry *eh;

      eh = (struct elf_sh_link_hash_entry *) ret;
      eh->dyn_relocs = NULL;
      eh->gotplt_refcount = 0;
d3626 1
a3626 1
      ret->datalabel_got_offset = (bfd_vma) -1;
a4130 12
#ifdef INCLUDE_SHMEDIA
      if (h->type == STT_DATALABEL)
	{
	  struct elf_sh_link_hash_entry *hsh;

	  h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  hsh = (struct elf_sh_link_hash_entry *)h;
	  hsh->datalabel_got_offset = s->_raw_size;
	}
      else
	h->got.offset = s->_raw_size;
#else
a4131 1
#endif
d4150 26
d5016 1
a5016 1
		  off = hsh->datalabel_got_offset;
d5052 1
a5052 1
			  hsh->datalabel_got_offset |= 1;
d5910 79
a5988 8
    switch (sh_elf_optimized_tls_reloc (info, ELF32_R_TYPE (rel->r_info),
				   ELF32_R_SYM (rel->r_info)
				   >= symtab_hdr->sh_info))
      {
      case R_SH_TLS_LD_32:
	if (sh_elf_hash_table (info)->tls_ldm_got.refcount > 0)
	  sh_elf_hash_table (info)->tls_ldm_got.refcount -= 1;
	break;
d5990 6
a5995 34
      case R_SH_GOT32:
      case R_SH_GOTOFF:
      case R_SH_GOTPC:
#ifdef INCLUDE_SHMEDIA
      case R_SH_GOT_LOW16:
      case R_SH_GOT_MEDLOW16:
      case R_SH_GOT_MEDHI16:
      case R_SH_GOT_HI16:
      case R_SH_GOT10BY4:
      case R_SH_GOT10BY8:
      case R_SH_GOTOFF_LOW16:
      case R_SH_GOTOFF_MEDLOW16:
      case R_SH_GOTOFF_MEDHI16:
      case R_SH_GOTOFF_HI16:
      case R_SH_GOTPC_LOW16:
      case R_SH_GOTPC_MEDLOW16:
      case R_SH_GOTPC_MEDHI16:
      case R_SH_GOTPC_HI16:
#endif
      case R_SH_TLS_GD_32:
      case R_SH_TLS_IE_32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;
a5996 8
      case R_SH_DIR32:
      case R_SH_REL32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf_sh_link_hash_entry *eh;
	    struct elf_sh_dyn_relocs **pp;
	    struct elf_sh_dyn_relocs *p;
d5998 2
a5999 1
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d6001 12
a6012 2
	    if (!info->shared && h->plt.refcount > 0)
	      h->plt.refcount -= 1;
d6014 13
a6026 1
	    eh = (struct elf_sh_link_hash_entry *) h;
d6028 12
a6039 2
	    for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	      if (p->sec == sec)
d6041 3
a6043 6
		  if (ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
		    p->pc_count -= 1;
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
a6044 4
	  }
	break;

      case R_SH_PLT32:
d6046 5
a6050 4
      case R_SH_PLT_LOW16:
      case R_SH_PLT_MEDLOW16:
      case R_SH_PLT_MEDHI16:
      case R_SH_PLT_HI16:
d6052 5
a6056 10
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	break;

      case R_SH_GOTPLT32:
d6058 6
a6063 6
      case R_SH_GOTPLT_LOW16:
      case R_SH_GOTPLT_MEDLOW16:
      case R_SH_GOTPLT_MEDHI16:
      case R_SH_GOTPLT_HI16:
      case R_SH_GOTPLT10BY4:
      case R_SH_GOTPLT10BY8:
d6065 4
a6068 20
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    eh = (struct elf_sh_link_hash_entry *) h;
	    if (eh->gotplt_refcount > 0)
	      {
		eh->gotplt_refcount -= 1;
		if (h->plt.refcount > 0)
		  h->plt.refcount -= 1;
	      }
	    else if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;
d6070 4
a6073 3
      default:
	break;
      }
d6086 3
d6127 10
d6217 3
d6227 11
a6237 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d6341 11
a6351 1
	      h->got.refcount += 1;
d6388 6
a6393 1
	      local_got_refcounts[r_symndx] += 1;
d7047 54
@


1.61
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d62 6
d91 2
d724 113
a836 8
  EMPTY_HOWTO (144),
  EMPTY_HOWTO (145),
  EMPTY_HOWTO (146),
  EMPTY_HOWTO (147),
  EMPTY_HOWTO (148),
  EMPTY_HOWTO (149),
  EMPTY_HOWTO (150),
  EMPTY_HOWTO (151),
d1892 8
d1998 1
d3515 17
d3534 20
d3571 7
d3627 2
d3662 1
d4118 1
d4145 3
d4149 8
a4156 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d4192 3
d4302 1
d4348 1
d4357 2
d4364 1
d4368 11
d4514 1
d4526 1
d4542 2
d4565 2
d4737 4
a4740 1
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))))
d4745 1
a4745 1
		    (_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
d4748 1
a4748 1
		  relocation = 0;
a4992 1
	      bfd_vma off;
a5049 2
	      bfd_vma off;

a5082 1
		      asection *srelgot;
d5085 6
a5090 2
		      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
		      BFD_ASSERT (srelgot != NULL);
d5224 444
d5815 14
d5896 3
a5898 1
    switch (ELF32_R_TYPE (rel->r_info))
d5900 5
d5924 2
d6069 7
d6079 23
d6123 2
d6150 2
d6157 10
d6170 1
a6170 1
	  switch (ELF32_R_TYPE (rel->r_info))
d6198 3
d6212 1
a6212 1
      switch (ELF32_R_TYPE (rel->r_info))
d6229 6
d6244 13
d6258 4
a6261 1
	    h->got.refcount += 1;
d6280 1
d6286 9
d6297 25
d6323 5
d6410 1
a6410 1
	       && (ELF32_R_TYPE (rel->r_info) != R_SH_REL32
d6500 1
a6500 1
	      if (ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
d6505 99
d6724 23
d6903 3
a6905 1
  if (h->got.offset != (bfd_vma) -1)
d7194 2
a7195 1
#define elf_backend_object_p		sh_elf_set_mach_from_flags
@


1.60
log
@* elf32-sh.c (elf_sh_pic_plt_entry_be, elf_sh_pic_plt_entry_le):
Correct mistake in calculation of address of .got.
* elf64-sh64.c (elf_sh64_pic_plt_entry_be,
elf_sh64_pic_plt_entry_le): Likewise.
@
text
@d3585 3
a3587 1
      struct elf_link_hash_entry *h = NULL;
d3591 1
a3591 2
	      get_elf_backend_data (abfd)->collect,
	      (struct bfd_link_hash_entry **) &h)))
d3593 2
@


1.59
log
@* elf32-sh.c (elf_sh_link_hash_entry): Add gotplt_refcount.
(sh_elf_link_hash_newfunc): Initialize it.
(allocate_dynrelocs): Transfer gotplt refs from plt.refcount
to got.refcount for symbols that are forced local or when
we have direct got refs.
(sh_elf_gc_sweep_hook): Adjust gotplt_refcount.  Use it
to correctly adjust got.refcount and plt.refcount.
(sh_elf_copy_indirect_symbol): Copy gotplt_refcount across.
(sh_elf_check_relocs): Increment gotplt_refcount.
@
text
@d3050 1
a3050 1
  0x00, 0xca, 0x45, 0x10, /* sub.l r12, r17, r17 */
d3070 1
a3070 1
  0x10, 0x45, 0xca, 0x00, /* sub.l r12, r17, r17 */
@


1.59.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a61 6
static int sh_elf_optimized_tls_reloc
  PARAMS ((struct bfd_link_info *, int, int));
static boolean sh_elf_mkobject
  PARAMS((bfd *));
static boolean sh_elf_object_p
  PARAMS((bfd *));
a84 2
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
a99 4
static boolean elf32_shlin_grok_prstatus
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));
static boolean elf32_shlin_grok_psinfo
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));
d716 8
a723 113

  HOWTO (R_SH_TLS_GD_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_GD_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LD_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LD_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LDO_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LDO_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_IE_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_IE_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LE_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LE_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_DTPMOD32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_DTPMOD32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_DTPOFF32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_DTPOFF32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_TPOFF32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_TPOFF32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

a1778 8
  { BFD_RELOC_SH_TLS_GD_32, R_SH_TLS_GD_32 },
  { BFD_RELOC_SH_TLS_LD_32, R_SH_TLS_LD_32 },
  { BFD_RELOC_SH_TLS_LDO_32, R_SH_TLS_LDO_32 },
  { BFD_RELOC_SH_TLS_IE_32, R_SH_TLS_IE_32 },
  { BFD_RELOC_SH_TLS_LE_32, R_SH_TLS_LE_32 },
  { BFD_RELOC_SH_TLS_DTPMOD32, R_SH_TLS_DTPMOD32 },
  { BFD_RELOC_SH_TLS_DTPOFF32, R_SH_TLS_DTPOFF32 },
  { BFD_RELOC_SH_TLS_TPOFF32, R_SH_TLS_TPOFF32 },
a1876 1
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC_5 || r > R_SH_LAST_INVALID_RELOC_5);
d3050 1
a3050 1
  0x00, 0xc8, 0x45, 0x10, /* add.l r12, r17, r17 */
d3070 1
a3070 1
  0x10, 0x45, 0xc8, 0x00, /* add.l r12, r17, r17 */
d3386 1
a3386 5
  union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } datalabel_got;
a3392 17

  enum {
    GOT_UNKNOWN = 0, GOT_NORMAL, GOT_TLS_GD, GOT_TLS_IE
  } tls_type;

  /* If true, R_SH_TLS_TPOFF32 relocation is generated.  */
  boolean tls_tpoff32;
};

#define sh_elf_hash_entry(ent) ((struct elf_sh_link_hash_entry *)(ent))

struct sh_elf_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
a3394 20
#define sh_elf_tdata(abfd) \
  ((struct sh_elf_obj_tdata *) (abfd)->tdata.any)

#define sh_elf_local_got_tls_type(abfd) \
  (sh_elf_tdata (abfd)->local_got_tls_type)

/* Override the generic function because we need to store sh_elf_obj_tdata
   as the specific tdata.  */

static boolean
sh_elf_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (struct sh_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return false;
  return true;
}
                 
a3411 7

  /* A counter or offset to track a TLS got entry.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } tls_ldm_got;
d3453 5
a3457 2
      ret->dyn_relocs = NULL;
      ret->gotplt_refcount = 0;
d3459 1
a3459 1
      ret->datalabel_got.refcount = ret->root.got.refcount;
a3460 2
      ret->tls_type = GOT_UNKNOWN;
      ret->tls_tpoff32 = false;
a3493 1
  ret->tls_ldm_got.refcount = 0;
d3585 1
a3585 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d3589 2
a3590 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a3591 2

      h = (struct elf_link_hash_entry *) bh;
a3945 1
      int tls_type = sh_elf_hash_entry (h)->tls_type;
a3956 19
      h->got.offset = s->_raw_size;
      s->_raw_size += 4;
      /* R_SH_TLS_GD needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->_raw_size += 4;
      dyn = htab->root.dynamic_sections_created;
      /* R_SH_TLS_IE_32 needs one dynamic relocation,
	 R_SH_TLS_GD needs one if local symbol and two if global.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type == GOT_TLS_IE)
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->srelgot->_raw_size += 2 * sizeof (Elf32_External_Rela);
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;

d3958 3
a3960 4
  if (eh->datalabel_got.refcount > 0)
    {
      asection *s;
      boolean dyn;
d3962 3
a3964 7
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
d3966 5
a3970 3

      s = htab->sgot;
      eh->datalabel_got.offset = s->_raw_size;
d3977 1
a3977 2
    eh->datalabel_got.offset = (bfd_vma) -1;
#endif
a4008 3
      if (sh_elf_hash_entry (h)->tls_tpoff32)
	goto keep;

a4115 1
      char *local_tls_type;
a4160 1
      local_tls_type = sh_elf_local_got_tls_type (ibfd);
a4168 2
	      if (*local_tls_type == GOT_TLS_GD)
		s->_raw_size += 4;
a4173 1
	  ++local_tls_type;
a4176 11
  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_SH_TLS_LD_32
	 relocs.  */
      htab->tls_ldm_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 8;
      htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

a4311 1
  asection *srelgot;
a4322 1
  srelgot = NULL;
a4337 2
      bfd_vma off;
      int tls_type;
a4358 2
	  || (   r_type >= (int) R_SH_FIRST_INVALID_RELOC_5
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC_5)
d4529 1
a4529 4
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0)))
		  || (sec->output_section == NULL
		      && (sh_elf_hash_entry (h)->tls_type == GOT_TLS_IE
			  || sh_elf_hash_entry (h)->tls_type == GOT_TLS_GD)))
d4534 1
a4534 1
		    (_("%s: unresolvable relocation against symbol `%s' from %s section"),
d4537 1
a4537 1
		  return false;
d4782 1
d4792 1
a4792 1
		  off = hsh->datalabel_got.offset;
d4828 1
a4828 1
			  hsh->datalabel_got.offset |= 1;
d4840 2
d4875 1
d4878 2
a4879 6
		      if (srelgot == NULL)
			{
			  srelgot = bfd_get_section_by_name (dynobj,
							     ".rela.got");
			  BFD_ASSERT (srelgot != NULL);
			}
d5013 13
d5027 20
a5046 26
	case R_SH_TLS_GD_32:
	case R_SH_TLS_IE_32:
	  r_type = sh_elf_optimized_tls_reloc (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = sh_elf_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = sh_elf_hash_entry (h)->tls_type;
	      if (! info->shared
		  && (h->dynindx == -1
		      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  && (tls_type == GOT_TLS_IE
		      || sh_elf_hash_entry (h)->tls_tpoff32))
		r_type = R_SH_TLS_LE_32;
	    }

	  if (r_type == R_SH_TLS_GD_32 && tls_type == GOT_TLS_IE)
	    r_type = R_SH_TLS_IE_32;

	  if (r_type == R_SH_TLS_LE_32)
	    {
	      bfd_vma offset;
	      unsigned short insn;
	      int indx;
	      Elf_Internal_Rela outrel;
d5048 2
a5049 22
	      if (ELF32_R_TYPE (rel->r_info) == R_SH_TLS_GD_32)
		{
		  /* GD->LE transition:
		       mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		       jsr @@r1; add r12,r4; bra 3f; nop; .align 2; 
		       1: .long x$TLSGD; 2: .long __tls_get_addr@@PLT; 3:
		     We change it into:
		       mov.l 1f,r4; stc gbr,r0; add r4,r0; nop;
		       nop; nop; ...
		       1: .long x@@TPOFF; 2: .long __tls_get_addr@@PLT; 3:.  */

		  offset = rel->r_offset;
		  BFD_ASSERT (offset >= 16);
		  /* Size of GD instructions is 16 or 18.  */
		  offset -= 16;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		  if ((insn & 0xff00) == 0xc700)
		    {
		      BFD_ASSERT (offset >= 2);
		      offset -= 2;
		      insn = bfd_get_16 (input_bfd, contents + offset + 0);
		    }
d5051 2
a5052 21
		  BFD_ASSERT ((insn & 0xff00) == 0xd400);
		  insn = bfd_get_16 (input_bfd, contents + offset + 2);
		  BFD_ASSERT ((insn & 0xff00) == 0xc700);
		  insn = bfd_get_16 (input_bfd, contents + offset + 4);
		  BFD_ASSERT ((insn & 0xff00) == 0xd100);
		  insn = bfd_get_16 (input_bfd, contents + offset + 6);
		  BFD_ASSERT (insn == 0x310c);
		  insn = bfd_get_16 (input_bfd, contents + offset + 8);
		  BFD_ASSERT (insn == 0x410b);
		  insn = bfd_get_16 (input_bfd, contents + offset + 10);
		  BFD_ASSERT (insn == 0x34cc);

		  bfd_put_16 (output_bfd, 0x0012, contents + offset + 2);
		  bfd_put_16 (output_bfd, 0x304c, contents + offset + 4);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 6);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);
		}
	      else
		{
		  int index;
d5054 16
a5069 18
		  /* IE->LE transition:
		     mov.l 1f,r0; stc gbr,rN; mov.l @@(r0,r12),rM;
		     bra 2f; add ...; .align 2; 1: x@@GOTTPOFF; 2:
		     We change it into:
		     mov.l .Ln,rM; stc gbr,rN; nop; ...;
		     1: x@@TPOFF; 2:.  */

		  offset = rel->r_offset;
		  BFD_ASSERT (offset >= 16);
		  /* Size of IE instructions is 10 or 12.  */
		  offset -= 10;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		  if ((insn & 0xf0ff) == 0x0012)
		    {
		      BFD_ASSERT (offset >= 2);
		      offset -= 2;
		      insn = bfd_get_16 (input_bfd, contents + offset + 0);
		    }
d5071 8
a5078 10
		  BFD_ASSERT ((insn & 0xff00) == 0xd000);
		  index = insn & 0x00ff;
		  insn = bfd_get_16 (input_bfd, contents + offset + 2);
		  BFD_ASSERT ((insn & 0xf0ff) == 0x0012);
		  insn = bfd_get_16 (input_bfd, contents + offset + 4);
		  BFD_ASSERT ((insn & 0xf0ff) == 0x00ce);
		  insn = 0xd000 | (insn & 0x0f00) | index;
		  bfd_put_16 (output_bfd, insn, contents + offset + 0);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 4);
		}
d5080 1
a5080 3
	      if (sreloc == NULL)
		{
		  const char *name;
d5082 2
a5083 6
		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;
d5085 6
a5090 4
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);
d5092 5
a5096 3
		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
		}
d5098 3
a5100 409
	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	      outrel.r_offset = (input_section->output_section->vma
				 + input_section->output_offset
				 + rel->r_offset);
	      outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;

	      continue;
	    }

	  sgot = htab->sgot;
	  if (sgot == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	  if ((off & 1) != 0)
	    off &= ~1;
          else
	    {
	      Elf_Internal_Rela outrel;
	      Elf32_External_Rela *loc;
	      int dr_type, indx;

	      if (srelgot == NULL)
		{
		  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
		  BFD_ASSERT (srelgot != NULL);
		}

	      outrel.r_offset = (sgot->output_section->vma
				 + sgot->output_offset + off);

	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	      dr_type = (r_type == R_SH_TLS_GD_32 ? R_SH_TLS_DTPMOD32 :
			 R_SH_TLS_TPOFF32);
	      if (dr_type == R_SH_TLS_TPOFF32 && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      outrel.r_info = ELF32_R_INFO (indx, dr_type);
	      loc = (Elf32_External_Rela *) srelgot->contents;
	      loc += srelgot->reloc_count++;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      if (r_type == R_SH_TLS_GD_32)
		{
		  if (indx == 0)
		    {
		      bfd_put_32 (output_bfd,
				  relocation - dtpoff_base (info),
				  sgot->contents + off + 4);
		    }
		  else
		    {
		      outrel.r_info = ELF32_R_INFO (indx,
						    R_SH_TLS_DTPOFF32);
		      outrel.r_offset += 4;
		      outrel.r_addend = 0;
		      srelgot->reloc_count++;
		      loc++;
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						loc);
		    }
		}

	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();

	  if (r_type == (int) ELF32_R_TYPE (rel->r_info))
	    relocation = sgot->output_offset + off;
	  else
	    {
	      bfd_vma offset;
	      unsigned short insn;

	      /* GD->IE transition:
		   mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		   jsr @@r1; add r12,r4; bra 3f; nop; .align 2;
		   1: .long x$TLSGD; 2: .long __tls_get_addr@@PLT; 3:
		 We change it into:
		   mov.l 1f,r0; stc gbr,r4; mov.l @@(r0,r12),r0; add r4,r0;
		   nop; nop; bra 3f; nop; .align 2;
		   1: .long x@@TPOFF; 2:...; 3:.  */

	      offset = rel->r_offset;
	      BFD_ASSERT (offset >= 16);
	      /* Size of GD instructions is 16 or 18.  */
	      offset -= 16;
	      insn = bfd_get_16 (input_bfd, contents + offset + 0);
	      if ((insn & 0xff00) == 0xc700)
		{
		  BFD_ASSERT (offset >= 2);
		  offset -= 2;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		}

	      BFD_ASSERT ((insn & 0xff00) == 0xd400);

	      /* Replace mov.l 1f,R4 with mov.l 1f,r0.  */
	      bfd_put_16 (output_bfd, insn & 0xf0ff, contents + offset);

	      insn = bfd_get_16 (input_bfd, contents + offset + 2);
	      BFD_ASSERT ((insn & 0xff00) == 0xc700);
	      insn = bfd_get_16 (input_bfd, contents + offset + 4);
	      BFD_ASSERT ((insn & 0xff00) == 0xd100);
	      insn = bfd_get_16 (input_bfd, contents + offset + 6);
	      BFD_ASSERT (insn == 0x310c);
	      insn = bfd_get_16 (input_bfd, contents + offset + 8);
	      BFD_ASSERT (insn == 0x410b);
	      insn = bfd_get_16 (input_bfd, contents + offset + 10);
	      BFD_ASSERT (insn == 0x34cc);

	      bfd_put_16 (output_bfd, 0x0412, contents + offset + 2);
	      bfd_put_16 (output_bfd, 0x00ce, contents + offset + 4);
	      bfd_put_16 (output_bfd, 0x304c, contents + offset + 6);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);

	      bfd_put_32 (output_bfd, sgot->output_offset + off,
			  contents + rel->r_offset);

	      continue;
	  }

	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_TLS_LD_32:
	  if (! info->shared)
	    {
	      bfd_vma offset;
	      unsigned short insn;

	      /* LD->LE transition:
		   mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		   jsr @@r1; add r12,r4; bra 3f; nop; .align 2;
		   1: .long x$TLSLD; 2: .long __tls_get_addr@@PLT; 3:
		 We change it into:
		   stc gbr,r0; nop; nop; nop;
		   nop; nop; bra 3f; ...; 3:.  */

	      offset = rel->r_offset;
	      BFD_ASSERT (offset >= 16);
	      /* Size of LD instructions is 16 or 18.  */
	      offset -= 16;
	      insn = bfd_get_16 (input_bfd, contents + offset + 0);
	      if ((insn & 0xff00) == 0xc700)
		{
		  BFD_ASSERT (offset >= 2);
		  offset -= 2;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		}

	      BFD_ASSERT ((insn & 0xff00) == 0xd400);
	      insn = bfd_get_16 (input_bfd, contents + offset + 2);
	      BFD_ASSERT ((insn & 0xff00) == 0xc700);
	      insn = bfd_get_16 (input_bfd, contents + offset + 4);
	      BFD_ASSERT ((insn & 0xff00) == 0xd100);
	      insn = bfd_get_16 (input_bfd, contents + offset + 6);
	      BFD_ASSERT (insn == 0x310c);
	      insn = bfd_get_16 (input_bfd, contents + offset + 8);
	      BFD_ASSERT (insn == 0x410b);
	      insn = bfd_get_16 (input_bfd, contents + offset + 10);
	      BFD_ASSERT (insn == 0x34cc);

	      bfd_put_16 (output_bfd, 0x0012, contents + offset + 0);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 2);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 4);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 6);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);

	      continue;
	    }

	  sgot = htab->sgot;
	  if (sgot == NULL)
	    abort ();

	  off = htab->tls_ldm_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      Elf32_External_Rela *loc;

	      srelgot = htab->srelgot;
	      if (srelgot == NULL)
		abort ();

	      outrel.r_offset = (sgot->output_section->vma
				 + sgot->output_offset + off);
	      outrel.r_addend = 0;
	      outrel.r_info = ELF32_R_INFO (0, R_SH_TLS_DTPMOD32);
	      loc = (Elf32_External_Rela *) srelgot->contents;
	      loc += srelgot->reloc_count++;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ldm_got.offset |= 1;
	    }

	  relocation = sgot->output_offset + off;
	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_TLS_LDO_32:
	  if (! info->shared)
	    {
	      int indx;
	      Elf_Internal_Rela outrel;

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
		}

	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	      outrel.r_offset = (input_section->output_section->vma
				 + input_section->output_offset
				 + rel->r_offset);
	      outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;

	      continue;
	    }
	  else
	    relocation -= dtpoff_base (info);

	  addend = rel->r_addend;
	  goto final_link_relocate;

	case R_SH_TLS_LE_32:
	  {
	    int indx;
	    Elf_Internal_Rela outrel;

	    if (sreloc == NULL)
	      {
		const char *name;

		name = (bfd_elf_string_from_elf_section
			(input_bfd,
			 elf_elfheader (input_bfd)->e_shstrndx,
			 elf_section_data (input_section)->rel_hdr.sh_name));
		if (name == NULL)
		  return false;

		BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			    && strcmp (bfd_get_section_name (input_bfd,
							     input_section),
				       name + 5) == 0);

		sreloc = bfd_get_section_by_name (dynobj, name);
		BFD_ASSERT (sreloc != NULL);
	      }

	    indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	    outrel.r_offset = (input_section->output_section->vma
			       + input_section->output_offset
			       + rel->r_offset);
	    outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	    if (indx == 0)
	      outrel.r_addend = relocation - dtpoff_base (info);
	    else
	      outrel.r_addend = 0;
	    bfd_elf32_swap_reloca_out (output_bfd, &outrel,
				       (((Elf32_External_Rela *)
					 sreloc->contents)
					+ sreloc->reloc_count));
	    ++sreloc->reloc_count;

	    continue;
	  }
	}

    relocation_done:
      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = h->root.root.string;
		else
		  {
		    name = (bfd_elf_string_from_elf_section
			    (input_bfd, symtab_hdr->sh_link, sym->st_name));
		    if (name == NULL)
		      return false;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rel->r_offset)))
		  return false;
	      }
	      break;
	    }
	}
    }

  return true;
}

/* This is a version of bfd_generic_get_relocated_section_contents
   which uses sh_elf_relocate_section.  */

static bfd_byte *
sh_elf_get_relocated_section_contents (output_bfd, link_info, link_order,
				       data, relocateable, symbols)
     bfd *output_bfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     boolean relocateable;
     asymbol **symbols;
{
  Elf_Internal_Shdr *symtab_hdr;
  asection *input_section = link_order->u.indirect.section;
  bfd *input_bfd = input_section->owner;
  asection **sections = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Sym *isymbuf = NULL;

  /* We only need to handle the case of relaxing, or of having a
     particular set of section contents, specially.  */
  if (relocateable
      || elf_section_data (input_section)->this_hdr.contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
						       link_order, data,
						       relocateable,
						       symbols);

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  memcpy (data, elf_section_data (input_section)->this_hdr.contents,
	  (size_t) input_section->_raw_size);

  if ((input_section->flags & SEC_RELOC) != 0
      && input_section->reloc_count > 0)
    {
      asection **secpp;
      Elf_Internal_Sym *isym, *isymend;
      bfd_size_type amt;

      internal_relocs = (_bfd_elf32_link_read_relocs
			 (input_bfd, input_section, (PTR) NULL,
			  (Elf_Internal_Rela *) NULL, false));
      if (internal_relocs == NULL)
	goto error_return;

      if (symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
a5159 14
/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (info)
     struct bfd_link_info *info;
{
 /* If tls_segment is NULL, we should have signalled an error already.  */
 if (elf_hash_table (info)->tls_segment == NULL)
   return 0;
  return elf_hash_table (info)->tls_segment->start;
}

d5227 20
a5246 3
    {
#ifdef INCLUDE_SHMEDIA
      int seen_stt_datalabel = 0;
d5248 24
d5273 2
a5274 16
      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
#ifdef INCLUDE_SHMEDIA
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    {
	      seen_stt_datalabel |= h->type == STT_DATALABEL;
	      h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
#endif
	}
      eh = (struct elf_sh_link_hash_entry *) h;
d5276 1
a5276 8
      switch (sh_elf_optimized_tls_reloc (info, ELF32_R_TYPE (rel->r_info),
					  ELF32_R_SYM (rel->r_info)
					  >= symtab_hdr->sh_info))
	{
	case R_SH_TLS_LD_32:
	  if (sh_elf_hash_table (info)->tls_ldm_got.refcount > 0)
	    sh_elf_hash_table (info)->tls_ldm_got.refcount -= 1;
	  break;
d5278 2
a5279 25
	case R_SH_GOT32:
	case R_SH_GOTOFF:
	case R_SH_GOTPC:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOT_LOW16:
	case R_SH_GOT_MEDLOW16:
	case R_SH_GOT_MEDHI16:
	case R_SH_GOT_HI16:
	case R_SH_GOT10BY4:
	case R_SH_GOT10BY8:
	case R_SH_GOTOFF_LOW16:
	case R_SH_GOTOFF_MEDLOW16:
	case R_SH_GOTOFF_MEDHI16:
	case R_SH_GOTOFF_HI16:
	case R_SH_GOTPC_LOW16:
	case R_SH_GOTPC_MEDLOW16:
	case R_SH_GOTPC_MEDHI16:
	case R_SH_GOTPC_HI16:
#endif
	case R_SH_TLS_GD_32:
	case R_SH_TLS_IE_32:
	  if (h != NULL)
	    {
#ifdef INCLUDE_SHMEDIA
	      if (seen_stt_datalabel)
d5281 6
a5286 2
		  if (eh->datalabel_got.refcount > 0)
		    eh->datalabel_got.refcount -= 1;
d5288 2
a5289 43
	      else
#endif
		if (h->got.refcount > 0)
		  h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
#ifdef INCLUDE_SHMEDIA
	      if (rel->r_addend & 1)
		{
		  if (local_got_refcounts[symtab_hdr->sh_info + r_symndx] > 0)
		    local_got_refcounts[symtab_hdr->sh_info + r_symndx] -= 1;
		}
	      else
#endif
		if (local_got_refcounts[r_symndx] > 0)
		  local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	case R_SH_DIR32:
	case R_SH_REL32:
	  if (h != NULL)
	    {
	      struct elf_sh_dyn_relocs **pp;
	      struct elf_sh_dyn_relocs *p;


	      if (!info->shared && h->plt.refcount > 0)
		h->plt.refcount -= 1;

	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    if (ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
		      p->pc_count -= 1;
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	    }
	  break;
d5291 1
a5291 1
	case R_SH_PLT32:
d5293 4
a5296 4
	case R_SH_PLT_LOW16:
	case R_SH_PLT_MEDLOW16:
	case R_SH_PLT_MEDHI16:
	case R_SH_PLT_HI16:
d5298 8
a5305 6
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;
d5307 1
a5307 29
	case R_SH_GOTPLT32:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOTPLT_LOW16:
	case R_SH_GOTPLT_MEDLOW16:
	case R_SH_GOTPLT_MEDHI16:
	case R_SH_GOTPLT_HI16:
	case R_SH_GOTPLT10BY4:
	case R_SH_GOTPLT10BY8:
#endif
	  if (h != NULL)
	    {
	      if (eh->gotplt_refcount > 0)
		{
		  eh->gotplt_refcount -= 1;
		  if (h->plt.refcount > 0)
		    h->plt.refcount -= 1;
		}
#ifdef INCLUDE_SHMEDIA
	      else if (seen_stt_datalabel)
		{
		  if (eh->datalabel_got.refcount > 0)
		    eh->datalabel_got.refcount -= 1;
		}
#endif
	      else if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
d5309 6
a5314 6
	      if (rel->r_addend & 1)
		{
		  if (local_got_refcounts[symtab_hdr->sh_info + r_symndx] > 0)
		    local_got_refcounts[symtab_hdr->sh_info + r_symndx] -= 1;
		}
	      else
d5316 20
a5335 4
		if (local_got_refcounts[r_symndx] > 0)
		  local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d5337 3
a5339 4
	default:
	  break;
	}
    }
a5351 3
#ifdef INCLUDE_SHMEDIA
  bfd_signed_vma tmp;
#endif
a5389 17
#ifdef INCLUDE_SHMEDIA
  tmp = edir->datalabel_got.refcount;
  if (tmp < 1)
    {
      edir->datalabel_got.refcount = eind->datalabel_got.refcount;
      eind->datalabel_got.refcount = tmp;
    }
  else
    BFD_ASSERT (eind->datalabel_got.refcount < 1);
#endif

  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }
a5393 23
static int
sh_elf_optimized_tls_reloc (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_SH_TLS_GD_32:
    case R_SH_TLS_IE_32:
      if (is_local)
	return R_SH_TLS_LE_32;
      return R_SH_TLS_IE_32;
    case R_SH_TLS_LD_32:
      return R_SH_TLS_LE_32;
    }

  return r_type;
}

a5414 2
  unsigned int r_type;
  int tls_type, old_tls_type;
a5437 3
#ifdef INCLUDE_SHMEDIA
      int seen_stt_datalabel = 0;
#endif
a5439 2
      r_type = ELF32_R_TYPE (rel->r_info);

d5443 1
a5443 21
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
#ifdef INCLUDE_SHMEDIA
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    {
	      seen_stt_datalabel |= h->type == STT_DATALABEL;
	      h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
#endif
	}

      r_type = sh_elf_optimized_tls_reloc (info, r_type, h == NULL);
      if (! info->shared
	  && r_type == R_SH_TLS_IE_32
	  && h != NULL
	  && h->root.type != bfd_link_hash_undefined
	  && h->root.type != bfd_link_hash_undefweak
	  && (h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	r_type = R_SH_TLS_LE_32;
d5448 1
a5448 1
	  switch (r_type)
a5475 3
	    case R_SH_TLS_GD_32:
	    case R_SH_TLS_LD_32:
	    case R_SH_TLS_IE_32:
d5487 1
a5487 1
      switch (r_type)
a5503 6
	case R_SH_TLS_IE_32:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;

	  /* FALLTHROUGH */
	case R_SH_TLS_GD_32:
a5512 13
	  switch (r_type)
	    {
	    default:
	      tls_type = GOT_NORMAL;
	      break;
	    case R_SH_TLS_GD_32:
	      tls_type = GOT_TLS_GD;
	      break;
	    case R_SH_TLS_IE_32:
	      tls_type = GOT_TLS_IE;
	      break;
	    }

d5514 1
a5514 14
	    {
#ifdef INCLUDE_SHMEDIA
	      if (seen_stt_datalabel)
		{
		  struct elf_sh_link_hash_entry *eh = 
		    (struct elf_sh_link_hash_entry *)h;

		  eh->datalabel_got.refcount += 1;
		}
	      else
#endif
		h->got.refcount += 1;
	      old_tls_type = sh_elf_hash_entry (h)->tls_type;
	    }
a5532 1
		  size += symtab_hdr->sh_info;
a5537 32
#ifdef 	INCLUDE_SHMEDIA
		  /* Take care of both the datalabel and codelabel local
		     GOT offsets.  */
		  sh_elf_local_got_tls_type (abfd)
		    = (char *) (local_got_refcounts + 2 * symtab_hdr->sh_info);
#else
		  sh_elf_local_got_tls_type (abfd)
		    = (char *) (local_got_refcounts + symtab_hdr->sh_info);
#endif
		}
#ifdef INCLUDE_SHMEDIA
	      if (rel->r_addend & 1)
		local_got_refcounts[symtab_hdr->sh_info + r_symndx] += 1;
	      else
#endif
		local_got_refcounts[r_symndx] += 1;
	      old_tls_type = sh_elf_local_got_tls_type (abfd) [r_symndx];
	    }

	  /* If a TLS symbol is accessed using IE at least once,
	     there is no point to use dynamic model for it.  */
	  if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN
	      && (old_tls_type != GOT_TLS_GD || tls_type != GOT_TLS_IE))
	    {
	      if (old_tls_type == GOT_TLS_IE && tls_type == GOT_TLS_GD)
		tls_type = GOT_TLS_IE;
	      else
		{
		  (*_bfd_error_handler)
		    (_("%s: `%s' accessed both as normal and thread local symbol"),
		     bfd_archive_filename (abfd), h->root.root.string);
		  return false;
d5539 1
a5540 13

	  if (old_tls_type != tls_type)
	    {
	      if (h != NULL)
		sh_elf_hash_entry (h)->tls_type = tls_type;
	      else
		sh_elf_local_got_tls_type (abfd) [r_symndx] = tls_type;
	    }

	  break;

	case R_SH_TLS_LD_32:
	  sh_elf_hash_table(info)->tls_ldm_got.refcount += 1;
d5623 1
a5623 1
	       && (r_type != R_SH_REL32
d5713 1
a5713 1
	      if (r_type == R_SH_REL32)
a5717 99

	case R_SH_TLS_LE_32:
	  if (info->shared)
	    {
	      (*_bfd_error_handler) (_("%s: TLS local exec code cannot be linked into shared objects"),
				     bfd_archive_filename (abfd));
	      return false;
	    }

	  if (ELF32_R_TYPE (rel->r_info) == R_SH_TLS_LD_32)
	    break;

	  /* FALLTHROUGH */
	case R_SH_TLS_LDO_32:
	  /* We make a R_SH_TLS_TPOFF32 relocation. Count it as a
	     copy relocation.  */
	  if (! info->shared)
	    {
	      struct elf_sh_dyn_relocs *p;
	      struct elf_sh_dyn_relocs **head;

	      if (dynobj == NULL)
		htab->root.dynobj = dynobj = abfd;

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      sreloc = bfd_make_section (dynobj, name);
		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
			return false;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		head = &((struct elf_sh_link_hash_entry *) h)->dyn_relocs;
	      else
		{
		  asection *s;

		  /* Track dynamic relocs needed for local syms too.  */
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return false;

		  head = ((struct elf_sh_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof (*p);
		  p = ((struct elf_sh_dyn_relocs *) bfd_alloc (dynobj, amt));
		  if (p == NULL)
		    return false;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		}

	      p->count += 1;
	      if (h)
		sh_elf_hash_entry (h)->tls_tpoff32 = true;
	    }
	  break;

	default:
	  break;
a5837 23
/* Override the generic function because we need to store sh_elf_obj_tdata
   as the specific tdata.  We set also the machine architecture from flags
   here.  */

static boolean
sh_elf_object_p (abfd)
  bfd *abfd;
{
  struct sh_elf_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct sh_elf_obj_tdata);

  if (sh_elf_set_mach_from_flags (abfd) == false)
    return false;

  /* Allocate our special target data.  */
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return false;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;
  return true;
}

d5994 1
a5994 3
  if (h->got.offset != (bfd_vma) -1
      && sh_elf_hash_entry (h)->tls_type != GOT_TLS_GD
      && sh_elf_hash_entry (h)->tls_type != GOT_TLS_IE)
a6039 54
#ifdef INCLUDE_SHMEDIA
  {
    struct elf_sh_link_hash_entry *eh;

    eh = (struct elf_sh_link_hash_entry *) h;
    if (eh->datalabel_got.offset != (bfd_vma) -1)
      {
	asection *sgot;
	asection *srel;
	Elf_Internal_Rela rel;

	/* This symbol has a datalabel entry in the global offset table.
	   Set it up.  */

	sgot = htab->sgot;
	srel = htab->srelgot;
	BFD_ASSERT (sgot != NULL && srel != NULL);

	rel.r_offset = (sgot->output_section->vma
			+ sgot->output_offset
			+ (eh->datalabel_got.offset &~ (bfd_vma) 1));

	/* If this is a static link, or it is a -Bsymbolic link and the
	   symbol is defined locally or was forced to be local because
	   of a version file, we just want to emit a RELATIVE reloc.
	   The entry in the global offset table will already have been
	   initialized in the relocate_section function.  */
	if (info->shared
	    && (info->symbolic
		|| h->dynindx == -1
		|| (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
	    && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	  {
	    rel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
	    rel.r_addend = (h->root.u.def.value
			    + h->root.u.def.section->output_section->vma
			    + h->root.u.def.section->output_offset);
	  }
	else
	  {
	    bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents
			+ eh->datalabel_got.offset);
	    rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_GLOB_DAT);
	    rel.r_addend = 0;
	  }

	bfd_elf32_swap_reloca_out (output_bfd, &rel,
				   ((Elf32_External_Rela *) srel->contents
				    + srel->reloc_count));
	++srel->reloc_count;
      }
  }
#endif

d6265 1
a6265 65
/* Support for Linux core dump NOTE sections */
static boolean
elf32_shlin_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  int offset;
  unsigned int raw_size;

  switch (note->descsz)
    {
      default:
	return false;

      case 168:		/* Linux/SH */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	raw_size = 92;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}

static boolean
elf32_shlin_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  switch (note->descsz)
    {
      default:
	return false;

      case 124:		/* Linux/SH elf_prpsinfo */
	elf_tdata (abfd)->core_program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
	elf_tdata (abfd)->core_command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return true;
}

d6275 1
d6283 1
a6283 2
#define bfd_elf32_mkobject		sh_elf_mkobject
#define elf_backend_object_p		sh_elf_object_p
d6318 1
a6318 2
#ifndef INCLUDE_SHMEDIA

d6320 1
a6321 67
/* QNX support.  */
#include "elf32-qnx.h"

#undef	TARGET_LITTLE_SYM 
#define	TARGET_LITTLE_SYM		bfd_elf32_shlqnx_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-shl-nto"
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shqnx_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-sh-nto"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x1000

#define	elf32_bed			elf32_sh_qnx_bed

#include "elf32-target.h"

#undef	elf_backend_set_nonloadable_filepos
#undef	elf_backend_is_contained_by_filepos
#undef	elf_backend_copy_private_bfd_data_p
#undef	elf32_bed

/* NetBSD support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shnbsd_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-sh-nbsd"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf32_shlnbsd_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-shl-nbsd"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x10000
#undef	elf_symbol_leading_char
#define	elf_symbol_leading_char		0

#define	elf32_bed			elf32_sh_nbsd_bed

#include "elf32-target.h"

#undef	elf32_bed

/* Linux support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shblin_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-shbig-linux"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf32_shlin_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-sh-linux"

#undef	elf_backend_grok_prstatus
#define	elf_backend_grok_prstatus	elf32_shlin_grok_prstatus
#undef	elf_backend_grok_psinfo
#define	elf_backend_grok_psinfo		elf32_shlin_grok_psinfo

#define	elf32_bed			elf32_sh_lin_bed

#include "elf32-target.h"

#undef	elf_backend_grok_prstatus
#undef	elf_backend_grok_psinfo
#undef	elf32_bed

#endif /* INCLUDE_SHMEDIA */
@


1.59.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 2
a2 2
/* Renesas / SuperH SH specific support for 32-bit ELF
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d30 1
a30 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d32 1
a32 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d34 1
a34 1
  (bfd *, bfd_reloc_code_real_type);
d36 20
a55 20
  (bfd *, arelent *, Elf_Internal_Rela *);
static bfd_boolean sh_elf_set_private_flags
  (bfd *, flagword);
static bfd_boolean sh_elf_copy_private_data
  (bfd *, bfd *);
static bfd_boolean sh_elf_merge_private_data
  (bfd *, bfd *);
static bfd_boolean sh_elf_set_mach_from_flags
  (bfd *);
static bfd_boolean sh_elf_relax_section
  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
static bfd_boolean sh_elf_relax_delete_bytes
  (bfd *, asection *, bfd_vma, int);
static bfd_boolean sh_elf_align_loads
  (bfd *, asection *, Elf_Internal_Rela *, bfd_byte *, bfd_boolean *);
static bfd_boolean sh_elf_swap_insns
  (bfd *, asection *, void *, bfd_byte *, bfd_vma);
static bfd_boolean sh_elf_relocate_section
  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
d57 2
a58 2
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);
d60 2
a61 2
  (const struct elf_backend_data *, struct elf_link_hash_entry *,
   struct elf_link_hash_entry *);
d63 8
a70 7
  (struct bfd_link_info *, int, int);
static bfd_boolean sh_elf_mkobject
  (bfd *);
static bfd_boolean sh_elf_object_p
  (bfd *);
static bfd_boolean sh_elf_check_relocs
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
d72 1
a72 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d74 10
a83 10
  (bfd *);
static bfd_boolean sh_elf_adjust_dynamic_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *);
static bfd_boolean sh_elf_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
static bfd_boolean sh_elf_finish_dynamic_symbol
  (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
   Elf_Internal_Sym *);
static bfd_boolean sh_elf_finish_dynamic_sections
  (bfd *, struct bfd_link_info *);
d85 6
a90 6
  (int, bfd *, asection *, bfd_byte *, bfd_vma, asection *, bfd_vma,
   bfd_vma);
static bfd_boolean create_got_section
  (bfd *, struct bfd_link_info *);
static bfd_boolean sh_elf_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
d92 1
a92 3
  (struct bfd_link_info *);
static bfd_vma tpoff
  (struct bfd_link_info *, bfd_vma);
d94 9
a102 8
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);
static bfd_boolean sh_elf_gc_sweep_hook
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
static bfd_boolean allocate_dynrelocs
  (struct elf_link_hash_entry *, void *);
static bfd_boolean readonly_dynrelocs
  (struct elf_link_hash_entry *, void *);
d104 1
a104 1
  (const Elf_Internal_Rela *);
d106 1
a106 1
inline static void movi_shori_putval (bfd *, unsigned long, char *);
d108 4
a111 4
static bfd_boolean elf32_shlin_grok_prstatus
  (bfd *abfd, Elf_Internal_Note *note);
static bfd_boolean elf32_shlin_grok_psinfo
  (bfd *abfd, Elf_Internal_Note *note);
d125 1
a125 1
	 FALSE,			/* pc_relative */
d130 1
a130 1
	 FALSE,			/* partial_inplace */
d133 1
a133 1
	 FALSE),		/* pcrel_offset */
d135 1
a135 1
  /* 32 bit absolute relocation.  Setting partial_inplace to TRUE and
d141 1
a141 1
	 FALSE,			/* pc_relative */
d146 1
a146 1
	 TRUE,			/* partial_inplace */
d149 1
a149 1
	 FALSE),		/* pcrel_offset */
d156 1
a156 1
	 TRUE,			/* pc_relative */
d161 1
a161 1
	 TRUE,			/* partial_inplace */
d164 1
a164 1
	 TRUE),			/* pcrel_offset */
d171 1
a171 1
	 TRUE,			/* pc_relative */
d176 1
a176 1
	 TRUE,			/* partial_inplace */
d179 1
a179 1
	 TRUE),			/* pcrel_offset */
a181 2
  /* This cannot be partial_inplace because relaxation can't know the
     eventual value of a symbol.  */
d186 1
a186 1
	 TRUE,			/* pc_relative */
d189 1
a189 1
	 NULL,			/* special_function */
d191 2
a192 2
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
d194 1
a194 1
	 TRUE),			/* pcrel_offset */
d201 1
a201 1
	 TRUE,			/* pc_relative */
d206 1
a206 1
	 TRUE,			/* partial_inplace */
d209 1
a209 1
	 TRUE),			/* pcrel_offset */
d216 1
a216 1
	 TRUE,			/* pc_relative */
d221 1
a221 1
	 TRUE,			/* partial_inplace */
d224 1
a224 1
	 TRUE),			/* pcrel_offset */
d233 1
a233 1
	 FALSE,			/* pc_relative */
d238 1
a238 1
	 FALSE,			/* partial_inplace */
d241 1
a241 1
	 TRUE),			/* pcrel_offset */
d250 1
a250 1
	 FALSE,			/* pc_relative */
d255 1
a255 1
	 FALSE,			/* partial_inplace */
d258 1
a258 1
	 TRUE),			/* pcrel_offset */
d267 1
a267 1
	 FALSE,			/* pc_relative */
d272 1
a272 1
	 FALSE,			/* partial_inplace */
d275 1
a275 31
	 TRUE),			/* pcrel_offset */

  /* 8 bit PC relative divided by 2 - but specified in a very odd way.  */
  HOWTO (R_SH_LOOP_START,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_LOOP_START",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 8 bit PC relative divided by 2 - but specified in a very odd way.  */
  HOWTO (R_SH_LOOP_END,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_LOOP_END",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */
d277 2
d289 3
a297 47
  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_SH_GNU_VTINHERIT, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_SH_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_SH_GNU_VTENTRY,     /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn,	/* special_function */
	 "R_SH_GNU_VTENTRY",   /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An 8 bit switch table entry.  This is generated for an expression
     such as ``.word L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_SH_SWITCH8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_SWITCH8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

d305 1
a305 1
	 FALSE,			/* pc_relative */
d310 1
a310 1
	 FALSE,			/* partial_inplace */
d313 1
a313 1
	 TRUE),			/* pcrel_offset */
d322 1
a322 1
	 FALSE,			/* pc_relative */
d327 1
a327 1
	 FALSE,			/* partial_inplace */
d330 1
a330 1
	 TRUE),			/* pcrel_offset */
d340 1
a340 1
	 FALSE,			/* pc_relative */
d345 1
a345 1
	 FALSE,			/* partial_inplace */
d348 1
a348 1
	 TRUE),			/* pcrel_offset */
d358 1
a358 1
	 FALSE,			/* pc_relative */
d363 1
a363 1
	 FALSE,			/* partial_inplace */
d366 1
a366 1
	 TRUE),			/* pcrel_offset */
d375 1
a375 1
	 FALSE,			/* pc_relative */
d380 1
a380 1
	 FALSE,			/* partial_inplace */
d383 1
a383 1
	 TRUE),			/* pcrel_offset */
d386 1
a386 1
     instructions.  A section should be processed as assuming it
d392 1
a392 1
	 FALSE,			/* pc_relative */
d397 1
a397 1
	 FALSE,			/* partial_inplace */
d400 1
a400 1
	 TRUE),			/* pcrel_offset */
d408 1
a408 1
	 FALSE,			/* pc_relative */
d413 1
a413 1
	 FALSE,			/* partial_inplace */
d416 1
a416 1
	 TRUE),			/* pcrel_offset */
d425 1
a425 1
	 FALSE,			/* pc_relative */
d430 1
a430 1
	 FALSE,			/* partial_inplace */
d433 1
a433 1
	 TRUE),			/* pcrel_offset */
d435 4
a438 16
  /* The next 12 are only supported via linking in SHC-generated objects.  */
  HOWTO (R_SH_DIR16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR8,		/* type */
d442 1
a442 15
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR8UL,		/* type */
	 2,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
d445 3
a447 3
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8UL",		/* name */
	 FALSE,			/* partial_inplace */
d449 2
a450 2
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d452 6
a457 5
  HOWTO (R_SH_DIR8UW,		/* type */
	 1,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
d459 4
a462 4
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8UW",		/* name */
	 FALSE,			/* partial_inplace */
d464 2
a465 2
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d467 2
a468 1
  HOWTO (R_SH_DIR8U,		/* type */
d470 3
a472 3
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
d474 4
a477 4
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8U",		/* name */
	 FALSE,			/* partial_inplace */
d479 2
a480 2
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d482 2
a483 1
  HOWTO (R_SH_DIR8SW,		/* type */
d485 1
a485 1
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
d487 1
a487 1
	 FALSE,			/* pc_relative */
d490 4
a493 4
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8SW",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
d495 1
a495 1
	 FALSE),		/* pcrel_offset */
d497 4
a500 3
  HOWTO (R_SH_DIR8S,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
d502 1
a502 1
	 FALSE,			/* pc_relative */
d505 4
a508 4
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8S",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
d510 1
a510 57
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR4UL,		/* type */
	 2,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 4,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR4UL",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR4UW,		/* type */
	 1,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 4,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR4UW",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR4U,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 4,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR4U",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_PSHA,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 FALSE,			/* pc_relative */
	 4,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PSHA",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d512 7
a518 13
  HOWTO (R_SH_PSHL,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 FALSE,			/* pc_relative */
	 4,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PSHL",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d526 1
a526 1
	 FALSE,			/* pc_relative */
d531 1
a531 1
	 FALSE,			/* partial_inplace */
d534 1
a534 1
	 FALSE),		/* pcrel_offset */
d541 1
a541 1
	 FALSE,			/* pc_relative */
d546 1
a546 1
	 FALSE,			/* partial_inplace */
d549 1
a549 1
	 FALSE),		/* pcrel_offset */
d556 1
a556 1
	 FALSE,			/* pc_relative */
d561 1
a561 1
	 FALSE,			/* partial_inplace */
d564 1
a564 1
	 FALSE),		/* pcrel_offset */
d571 1
a571 1
	 FALSE,			/* pc_relative */
d576 1
a576 1
	 FALSE,			/* partial_inplace */
d579 1
a579 1
	 FALSE),		/* pcrel_offset */
d586 1
a586 1
	 FALSE,			/* pc_relative */
d591 1
a591 1
	 FALSE,			/* partial_inplace */
d594 1
a594 1
	 FALSE),		/* pcrel_offset */
d601 1
a601 1
	 FALSE,			/* pc_relative */
d606 1
a606 1
	 FALSE,			/* partial_inplace */
d609 1
a609 1
	 FALSE),		/* pcrel_offset */
d616 1
a616 1
	 FALSE,			/* pc_relative */
d621 1
a621 1
	 FALSE,			/* partial_inplace */
d624 1
a624 1
	 FALSE),		/* pcrel_offset */
d637 1
a637 15

  HOWTO (R_SH_DIR16S,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR16S",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

d733 1
a733 1
	 FALSE,			/* pc_relative */
d738 1
a738 1
	 TRUE,			/* partial_inplace */
d741 1
a741 1
	 FALSE),		/* pcrel_offset */
d747 1
a747 1
	 FALSE,			/* pc_relative */
d752 1
a752 1
	 TRUE,			/* partial_inplace */
d755 1
a755 1
	 FALSE),		/* pcrel_offset */
d761 1
a761 1
	 FALSE,			/* pc_relative */
d766 1
a766 1
	 TRUE,			/* partial_inplace */
d769 1
a769 1
	 FALSE),		/* pcrel_offset */
d775 1
a775 1
	 FALSE,			/* pc_relative */
d780 1
a780 1
	 TRUE,			/* partial_inplace */
d783 1
a783 1
	 FALSE),		/* pcrel_offset */
d789 1
a789 1
	 FALSE,			/* pc_relative */
d794 1
a794 1
	 TRUE,			/* partial_inplace */
d797 1
a797 1
	 FALSE),		/* pcrel_offset */
d803 1
a803 1
	 FALSE,			/* pc_relative */
d808 1
a808 1
	 TRUE,			/* partial_inplace */
d811 1
a811 1
	 FALSE),		/* pcrel_offset */
d817 1
a817 1
	 FALSE,			/* pc_relative */
d822 1
a822 1
	 TRUE,			/* partial_inplace */
d825 1
a825 1
	 FALSE),		/* pcrel_offset */
d831 1
a831 1
	 FALSE,			/* pc_relative */
d836 1
a836 1
	 TRUE,			/* partial_inplace */
d839 1
a839 1
	 FALSE),		/* pcrel_offset */
d854 1
a854 1
	 FALSE,			/* pc_relative */
d859 1
a859 1
	 TRUE,			/* partial_inplace */
d862 1
a862 1
	 FALSE),		/* pcrel_offset */
d868 1
a868 1
	 TRUE,			/* pc_relative */
d873 1
a873 1
	 TRUE,			/* partial_inplace */
d876 1
a876 1
	 TRUE),			/* pcrel_offset */
d882 1
a882 1
	 FALSE,			/* pc_relative */
d887 1
a887 1
	 TRUE,			/* partial_inplace */
d890 1
a890 1
	 FALSE),		/* pcrel_offset */
d896 1
a896 1
	 FALSE,			/* pc_relative */
d901 1
a901 1
	 TRUE,			/* partial_inplace */
d904 1
a904 1
	 FALSE),		/* pcrel_offset */
d910 1
a910 1
	 FALSE,			/* pc_relative */
d915 1
a915 1
	 TRUE,			/* partial_inplace */
d918 1
a918 1
	 FALSE),		/* pcrel_offset */
d924 1
a924 1
	 FALSE,			/* pc_relative */
d929 1
a929 1
	 TRUE,			/* partial_inplace */
d932 1
a932 1
	 FALSE),		/* pcrel_offset */
d938 1
a938 1
	 FALSE,			/* pc_relative */
d943 1
a943 1
	 TRUE,			/* partial_inplace */
d946 1
a946 1
	 FALSE),		/* pcrel_offset */
d952 1
a952 1
	 TRUE,			/* pc_relative */
d957 1
a957 1
	 TRUE,			/* partial_inplace */
d960 1
a960 1
	 TRUE),			/* pcrel_offset */
d966 1
a966 1
	 FALSE,			/* pc_relative */
d971 1
a971 1
	 FALSE,			/* partial_inplace */
d974 1
a974 1
	 FALSE),		/* pcrel_offset */
d982 1
a982 1
	 FALSE,			/* pc_relative */
d987 1
a987 1
	 FALSE,			/* partial_inplace */
d990 1
a990 1
	 FALSE),		/* pcrel_offset */
d997 1
a997 1
	 FALSE,			/* pc_relative */
d1002 1
a1002 1
	 FALSE,			/* partial_inplace */
d1005 1
a1005 1
	 FALSE),		/* pcrel_offset */
d1012 1
a1012 1
	 FALSE,			/* pc_relative */
d1017 1
a1017 1
	 FALSE,			/* partial_inplace */
d1020 1
a1020 1
	 FALSE),		/* pcrel_offset */
d1027 1
a1027 1
	 FALSE,			/* pc_relative */
d1032 1
a1032 1
	 FALSE,			/* partial_inplace */
d1035 1
a1035 1
	 FALSE),		/* pcrel_offset */
d1042 1
a1042 1
	 FALSE,			/* pc_relative */
d1047 1
a1047 1
	 FALSE,			/* partial_inplace */
d1050 1
a1050 1
	 FALSE),		/* pcrel_offset */
d1057 1
a1057 1
	 FALSE,			/* pc_relative */
d1062 1
a1062 1
	 FALSE,			/* partial_inplace */
d1065 1
a1065 1
	 FALSE),		/* pcrel_offset */
d1072 1
a1072 1
	 FALSE,			/* pc_relative */
d1077 1
a1077 1
	 FALSE,			/* partial_inplace */
d1080 1
a1080 1
	 FALSE),		/* pcrel_offset */
d1087 1
a1087 1
	 FALSE,			/* pc_relative */
d1092 1
a1092 1
	 FALSE,			/* partial_inplace */
d1095 1
a1095 1
	 FALSE),		/* pcrel_offset */
d1102 1
a1102 1
	 TRUE,			/* pc_relative */
d1107 1
a1107 1
	 FALSE,			/* partial_inplace */
d1110 1
a1110 1
	 TRUE),			/* pcrel_offset */
d1117 1
a1117 1
	 TRUE,			/* pc_relative */
d1122 1
a1122 1
	 FALSE,			/* partial_inplace */
d1125 1
a1125 1
	 TRUE),			/* pcrel_offset */
d1132 1
a1132 1
	 TRUE,			/* pc_relative */
d1137 1
a1137 1
	 FALSE,			/* partial_inplace */
d1140 1
a1140 1
	 TRUE),			/* pcrel_offset */
d1147 1
a1147 1
	 TRUE,			/* pc_relative */
d1152 1
a1152 1
	 FALSE,			/* partial_inplace */
d1155 1
a1155 1
	 TRUE),			/* pcrel_offset */
d1162 1
a1162 1
	 FALSE,			/* pc_relative */
d1167 1
a1167 1
	 FALSE,			/* partial_inplace */
d1170 1
a1170 1
	 FALSE),		/* pcrel_offset */
d1177 1
a1177 1
	 FALSE,			/* pc_relative */
d1182 1
a1182 1
	 FALSE,			/* partial_inplace */
d1185 1
a1185 1
	 FALSE),		/* pcrel_offset */
d1192 1
a1192 1
	 FALSE,			/* pc_relative */
d1197 1
a1197 1
	 FALSE,			/* partial_inplace */
d1200 1
a1200 1
	 FALSE),		/* pcrel_offset */
d1207 1
a1207 1
	 FALSE,			/* pc_relative */
d1212 1
a1212 1
	 FALSE,			/* partial_inplace */
d1215 1
a1215 1
	 FALSE),		/* pcrel_offset */
d1222 1
a1222 1
	 TRUE,			/* pc_relative */
d1227 1
a1227 1
	 FALSE,			/* partial_inplace */
d1230 1
a1230 1
	 TRUE),			/* pcrel_offset */
d1237 1
a1237 1
	 TRUE,			/* pc_relative */
d1242 1
a1242 1
	 FALSE,			/* partial_inplace */
d1245 1
a1245 1
	 TRUE),			/* pcrel_offset */
d1252 1
a1252 1
	 TRUE,			/* pc_relative */
d1257 1
a1257 1
	 FALSE,			/* partial_inplace */
d1260 1
a1260 1
	 TRUE),			/* pcrel_offset */
d1267 1
a1267 1
	 TRUE,			/* pc_relative */
d1272 1
a1272 1
	 FALSE,			/* partial_inplace */
d1275 1
a1275 1
	 TRUE),			/* pcrel_offset */
d1282 1
a1282 1
	 FALSE,			/* pc_relative */
d1287 1
a1287 1
	 FALSE,			/* partial_inplace */
d1290 1
a1290 1
	 FALSE),		/* pcrel_offset */
d1297 1
a1297 1
	 FALSE,			/* pc_relative */
d1302 1
a1302 1
	 FALSE,			/* partial_inplace */
d1305 1
a1305 1
	 FALSE),		/* pcrel_offset */
d1312 1
a1312 1
	 FALSE,			/* pc_relative */
d1317 1
a1317 1
	 FALSE,			/* partial_inplace */
d1320 1
a1320 1
	 FALSE),		/* pcrel_offset */
d1327 1
a1327 1
	 FALSE,			/* pc_relative */
d1332 1
a1332 1
	 FALSE,			/* partial_inplace */
d1335 1
a1335 1
	 FALSE),		/* pcrel_offset */
d1341 1
a1341 1
	 FALSE,			/* pc_relative */
d1346 1
a1346 1
	 FALSE,			/* partial_inplace */
d1349 1
a1349 1
	 FALSE),		/* pcrel_offset */
d1355 1
a1355 1
	 FALSE,			/* pc_relative */
d1360 1
a1360 1
	 FALSE,			/* partial_inplace */
d1363 1
a1363 1
	 FALSE),		/* pcrel_offset */
d1369 1
a1369 1
	 FALSE,			/* pc_relative */
d1374 1
a1374 1
	 FALSE,			/* partial_inplace */
d1377 1
a1377 1
	 FALSE),		/* pcrel_offset */
d1383 1
a1383 1
	 FALSE,			/* pc_relative */
d1388 1
a1388 1
	 FALSE,			/* partial_inplace */
d1391 1
a1391 1
	 FALSE),		/* pcrel_offset */
d1452 1
a1452 1
	 FALSE,			/* pc_relative */
d1457 1
a1457 1
	 FALSE,			/* partial_inplace */
d1460 1
a1460 1
	 FALSE),		/* pcrel_offset */
d1469 1
a1469 1
	 TRUE,			/* pc_relative */
d1474 1
a1474 1
	 FALSE,			/* partial_inplace */
d1477 1
a1477 1
	 TRUE),			/* pcrel_offset */
d1484 1
a1484 1
	 FALSE,			/* pc_relative */
d1489 1
a1489 1
	 FALSE,			/* partial_inplace */
d1492 1
a1492 1
	 FALSE),		/* pcrel_offset */
d1499 1
a1499 1
	 FALSE,			/* pc_relative */
d1504 1
a1504 1
	 FALSE,			/* partial_inplace */
d1507 1
a1507 1
	 FALSE),		/* pcrel_offset */
d1514 1
a1514 1
	 FALSE,			/* pc_relative */
d1519 1
a1519 1
	 FALSE,			/* partial_inplace */
d1522 1
a1522 1
	 FALSE),		/* pcrel_offset */
d1529 1
a1529 1
	 TRUE,			/* pc_relative */
d1534 1
a1534 1
	 FALSE,			/* partial_inplace */
d1537 1
a1537 1
	 TRUE),			/* pcrel_offset */
d1544 1
a1544 1
	 FALSE,			/* pc_relative */
d1549 1
a1549 1
	 FALSE,			/* partial_inplace */
d1552 1
a1552 1
	 FALSE),		/* pcrel_offset */
d1559 1
a1559 1
	 TRUE,			/* pc_relative */
d1564 1
a1564 1
	 FALSE,			/* partial_inplace */
d1567 1
a1567 1
	 TRUE),			/* pcrel_offset */
d1574 1
a1574 1
	 FALSE,			/* pc_relative */
d1579 1
a1579 1
	 FALSE,			/* partial_inplace */
d1582 1
a1582 1
	 FALSE),		/* pcrel_offset */
d1589 1
a1589 1
	 TRUE,			/* pc_relative */
d1594 1
a1594 1
	 FALSE,			/* partial_inplace */
d1597 1
a1597 1
	 TRUE),			/* pcrel_offset */
d1604 1
a1604 1
	 FALSE,			/* pc_relative */
d1609 1
a1609 1
	 FALSE,			/* partial_inplace */
d1612 1
a1612 1
	 FALSE),		/* pcrel_offset */
d1619 1
a1619 1
	 TRUE,			/* pc_relative */
d1624 1
a1624 1
	 FALSE,			/* partial_inplace */
d1627 1
a1627 1
	 TRUE),			/* pcrel_offset */
d1634 1
a1634 1
	 FALSE,			/* pc_relative */
d1639 1
a1639 1
	 FALSE,			/* partial_inplace */
d1642 1
a1642 1
	 FALSE),		/* pcrel_offset */
d1649 1
a1649 1
	 TRUE,			/* pc_relative */
d1654 1
a1654 1
	 FALSE,			/* partial_inplace */
d1657 1
a1657 1
	 TRUE),			/* pcrel_offset */
d1663 9
a1671 4
sh_elf_reloc_loop (int r_type ATTRIBUTE_UNUSED, bfd *input_bfd,
		   asection *input_section, bfd_byte *contents,
		   bfd_vma addr, asection *symbol_section,
		   bfd_vma start, bfd_vma end)
d1773 9
a1781 3
sh_elf_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol_in,
	      void *data, asection *input_section, bfd *output_bfd,
	      char **error_message ATTRIBUTE_UNUSED)
d1848 9
a1856 5
sh_elf_ignore_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		     asymbol *symbol ATTRIBUTE_UNUSED,
		     void *data ATTRIBUTE_UNUSED, asection *input_section,
		     bfd *output_bfd,
		     char **error_message ATTRIBUTE_UNUSED)
a1876 2
  { BFD_RELOC_16, R_SH_DIR16 },
  { BFD_RELOC_8, R_SH_DIR8 },
d1970 3
a1972 2
sh_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			  bfd_reloc_code_real_type code)
d1988 4
a1991 2
sh_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
		      Elf_Internal_Rela *dst)
d2017 6
a2022 3
static bfd_boolean
sh_elf_relax_section (bfd *abfd, asection *sec,
		      struct bfd_link_info *link_info, bfd_boolean *again)
d2026 1
a2026 1
  bfd_boolean have_code;
d2031 1
a2031 1
  *again = FALSE;
d2033 1
a2033 1
  if (link_info->relocatable
d2036 1
a2036 1
    return TRUE;
d2042 1
a2042 1
      return TRUE;
d2053 2
a2054 2
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
d2059 1
a2059 1
  have_code = FALSE;
d2070 1
a2070 1
	have_code = TRUE;
a2234 6
      /* We used to test (ELF32_R_SYM (irelfn->r_info) < symtab_hdr->sh_info)
	 here, but that only checks if the symbol is an external symbol,
	 not if the symbol is in a different section.  Besides, we need
	 a consistent meaning for the relocation, so we just assume here that
	 the value of the symbol is not available.  */
#if 0
a2244 1
#endif
a2250 1
      irel->r_addend = -4;
d2282 1
a2282 1
      *again = TRUE;
d2319 1
a2319 2
  if ((elf_elfheader (abfd)->e_flags & EF_SH_MACH_MASK) != EF_SH4
      && have_code)
d2321 1
a2321 1
      bfd_boolean swapped;
d2380 1
a2380 1
  return TRUE;
d2393 1
a2393 1
  return FALSE;
d2400 6
a2405 3
static bfd_boolean
sh_elf_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr,
			   int count)
d2470 1
a2470 1
      bfd_boolean overflow;
d2545 2
a2546 8
	  off = insn & 0xfff;
	  if (! off)
	    {
	      /* This has been made by previous relaxation.  Since the
		 relocation will be against an external symbol, the
		 final relocation will just do the right thing.  */
	      start = stop = addr;
	    }
d2549 1
a2552 9

	      /* The addend will be against the section symbol, thus
		 for adjusting the addend, the relevant start is the
		 start of the section.
		 N.B. If we want to abandon in-place changes here and
		 test directly using symbol + addend, we have to take into
		 account that the addend has already been adjusted by -4.  */
	      if (stop > addr && stop < toaddr)
		irel->r_addend -= count;
d2622 1
a2622 1
	  overflow = FALSE;
d2633 1
a2633 1
		overflow = TRUE;
d2640 1
a2640 1
		overflow = TRUE;
d2654 1
a2654 1
		overflow = TRUE;
d2661 1
a2661 1
		overflow = TRUE;
d2668 1
a2668 1
		overflow = TRUE;
d2688 1
a2688 1
	      return FALSE;
d2710 1
a2710 1
	 FALSE, we should free them, if we are permitted to, when we
d2712 3
a2714 2
      internal_relocs = (_bfd_elf_link_read_relocs
			 (abfd, o, NULL, (Elf_Internal_Rela *) NULL, TRUE));
d2716 1
a2716 1
	return FALSE;
d2735 1
a2735 1
			 Perhaps, if info->keep_memory is FALSE, we
d2740 1
a2740 1
			return FALSE;
d2744 1
a2744 1
			return FALSE;
d2793 1
a2793 1
			 Perhaps, if info->keep_memory is FALSE, we
d2798 1
a2798 1
			return FALSE;
d2802 1
a2802 1
			return FALSE;
d2861 1
a2861 1
  return TRUE;
d2867 7
a2873 5
static bfd_boolean
sh_elf_align_loads (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
		    Elf_Internal_Rela *internal_relocs,
		    bfd_byte *contents ATTRIBUTE_UNUSED,
		    bfd_boolean *pswapped)
d2880 1
a2880 1
  *pswapped = FALSE;
d2924 1
a2924 1
				     internal_relocs, &label,
d2931 1
a2931 1
  return TRUE;
d2936 1
a2936 1
  return FALSE;
d2941 7
a2947 3
static bfd_boolean
sh_elf_swap_insns (bfd *abfd, asection *sec, void *relocs,
		   bfd_byte *contents, bfd_vma addr)
d3010 1
a3010 1
	  bfd_boolean overflow;
d3013 1
a3013 1
	  overflow = FALSE;
d3025 1
a3025 1
		overflow = TRUE;
d3034 1
a3034 1
		overflow = TRUE;
d3051 1
a3051 1
		    overflow = TRUE;
d3064 1
a3064 1
	      return FALSE;
d3069 1
a3069 1
  return TRUE;
d3228 4
a3231 1
movi_shori_putval (bfd *output_bfd, unsigned long value, char *addr)
d3252 1
a3252 1
   GCC to return the address of large structures, so it should not be
d3475 1
a3475 1
/* Return offset of the temporary in PLT entry */
d3527 3
d3551 3
a3553 2
static bfd_boolean
sh_elf_mkobject (bfd *abfd)
d3558 2
a3559 2
    return FALSE;
  return TRUE;
d3561 1
a3561 1

d3593 1
a3593 1
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func), \
d3604 4
a3607 3
sh_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			  struct bfd_hash_table *table,
			  const char *string)
d3633 1
d3642 2
a3643 1
sh_elf_link_hash_table_create (bfd *abfd)
d3675 4
a3678 2
static bfd_boolean
create_got_section (bfd *dynobj, struct bfd_link_info *info)
d3683 1
a3683 1
    return FALSE;
d3701 2
a3702 2
    return FALSE;
  return TRUE;
d3707 4
a3710 2
static bfd_boolean
sh_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d3715 1
a3715 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d3730 1
a3730 1
      return FALSE;
a3733 2
  if (htab->root.dynamic_sections_created)
    return TRUE;
d3753 1
a3753 1
    return FALSE;
d3764 1
a3764 1
	      (bfd_vma) 0, (const char *) NULL, FALSE,
d3766 1
a3766 1
	return FALSE;
d3774 1
a3774 1
	return FALSE;
d3783 1
a3783 1
    return FALSE;
d3785 2
a3786 3
  if (htab->sgot == NULL
      && !create_got_section (abfd, info))
    return FALSE;
a3803 2
	if (bfd_get_section_by_name (abfd, secname))
	  continue;
d3808 1
a3808 1
	  return FALSE;
d3824 1
a3824 1
	return FALSE;
d3846 1
a3846 1
	    return FALSE;
d3850 1
a3850 1
  return TRUE;
d3859 4
a3862 3
static bfd_boolean
sh_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
			      struct elf_link_hash_entry *h)
d3867 1
d3871 1
a3871 1
  htab = sh_elf_hash_table (info);
d3874 1
a3874 1
  BFD_ASSERT (htab->root.dynobj != NULL
d3891 5
a3895 3
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d3906 1
a3906 1
      return TRUE;
d3920 1
a3920 5
      if (info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
      return TRUE;
d3931 1
a3931 1
    return TRUE;
d3936 1
a3936 1
    return TRUE;
d3942 1
a3942 1
      return TRUE;
d3959 1
a3959 1
      return TRUE;
d3972 1
d3998 1
a3998 1
  if (power_of_two > bfd_get_section_alignment (htab->root.dynobj, s))
d4000 2
a4001 2
      if (! bfd_set_section_alignment (htab->root.dynobj, s, power_of_two))
	return FALSE;
d4011 1
a4011 1
  return TRUE;
d4018 1
a4018 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d4020 1
a4020 1
   && ((SHARED)								\
d4028 4
a4031 2
static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d4039 1
a4039 1
    return TRUE;
d4056 1
a4056 1
	 so treat all the gotplt refs as got refs. */
d4063 1
a4063 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d4071 1
a4071 1
	    return FALSE;
d4074 1
a4074 2
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d4122 1
a4122 1
      bfd_boolean dyn;
d4131 1
a4131 1
	    return FALSE;
d4141 1
a4141 1
      /* R_SH_TLS_IE_32 needs one dynamic relocation if dynamic,
d4144 1
a4144 1
	  || (tls_type == GOT_TLS_IE && dyn))
d4148 1
a4148 4
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
d4158 1
a4158 1
      bfd_boolean dyn;
d4166 1
a4166 1
	    return FALSE;
d4173 1
a4173 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h))
d4181 1
a4181 1
    return TRUE;
d4191 3
a4193 1
      if (SYMBOL_CALLS_LOCAL (info, h))
a4206 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d4210 3
d4230 1
a4230 1
		return FALSE;
d4251 1
a4251 1
  return TRUE;
d4256 4
a4259 2
static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d4279 1
a4279 1
	  return FALSE;
d4282 1
a4282 1
  return TRUE;
d4287 4
a4290 3
static bfd_boolean
sh_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
			      struct bfd_link_info *info)
d4295 1
a4295 1
  bfd_boolean relocs;
d4305 1
a4305 1
      if (info->executable)
d4399 1
a4399 1
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, info);
d4403 1
a4403 1
  relocs = FALSE;
d4419 1
a4419 1
	    relocs = TRUE;
d4454 1
a4454 1
	return FALSE;
d4467 1
a4467 1
      if (info->executable)
d4470 1
a4470 1
	    return FALSE;
d4479 1
a4479 1
	    return FALSE;
d4488 1
a4488 1
	    return FALSE;
d4493 2
a4494 1
	    elf_link_hash_traverse (&htab->root, readonly_dynrelocs, info);
d4499 1
a4499 1
		return FALSE;
d4505 1
a4505 1
  return TRUE;
d4510 11
a4520 6
static bfd_boolean
sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
			 bfd *input_bfd, asection *input_section,
			 bfd_byte *contents, Elf_Internal_Rela *relocs,
			 Elf_Internal_Sym *local_syms,
			 asection **local_sections)
d4569 2
a4570 2
      if (r_type >= (int) R_SH_GNU_VTINHERIT
	  && r_type <= (int) R_SH_LABEL)
d4589 1
a4589 1
	  return FALSE;
d4617 1
a4617 1
	  if (info->relocatable)
d4619 1
a4619 1
	      /* This is a relocatable link.  We don't have to change
d4656 1
a4656 1
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d4671 1
a4671 1
		  return FALSE;
a4685 2
	  /* FIXME: Ought to make use of the RELOC_FOR_GLOBAL_SYMBOL macro.  */

d4688 2
a4689 2
	     relocatable object file.  */
	  if (info->relocatable)
d4707 1
a4707 1
	      bfd_boolean dyn;
d4730 1
a4730 1
		      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
a4755 7
		  /* Dynamic relocs are not propagated for SEC_DEBUGGING
		     sections because such sections are not SEC_ALLOC and
		     thus ld.so will not process them.  */
		  || (sec->output_section == NULL
		      && ((input_section->flags & SEC_DEBUGGING) != 0
			  && (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d4766 1
a4766 1
		  return FALSE;
d4780 3
a4782 2
	  else if (! info->executable
		   && info->unresolved_syms_in_objects == RM_IGNORE
d4787 6
a4792 7
	      if (! info->callbacks->undefined_symbol
		  (info, h->root.root.string, input_bfd,
		   input_section, rel->r_offset,
		   ((info->shared && info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)
		    || (!info->shared && info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
		    || ELF_ST_VISIBILITY (h->other))))
		return FALSE;
d4808 1
d4841 1
a4841 1
		  return FALSE;
d4856 1
a4856 65
	  return FALSE;

	case R_SH_DIR16:
	case R_SH_DIR8:
	case R_SH_DIR8U:
	case R_SH_DIR8S:
	case R_SH_DIR4U:
	  goto final_link_relocate;

	case R_SH_DIR8UL:
	case R_SH_DIR4UL:
	  if (relocation & 3)
	    {
	      ((*_bfd_error_handler)
	       (_("%s: 0x%lx: fatal: unaligned %s relocation 0x%lx"),
		bfd_archive_filename (input_section->owner),
		(unsigned long) rel->r_offset, howto->name, 
		(unsigned long)relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;

	case R_SH_DIR8UW:
	case R_SH_DIR8SW:
	case R_SH_DIR4UW:
	  if (relocation & 1)
	    {
	      ((*_bfd_error_handler)
	       (_("%s: 0x%lx: fatal: unaligned %s relocation 0x%lx"),
		bfd_archive_filename (input_section->owner),
		(unsigned long) rel->r_offset, howto->name, 
		(unsigned long)relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;

	case R_SH_PSHA:
	  if ((signed int)relocation < -32
	      || (signed int)relocation > 32)
	    {
	      ((*_bfd_error_handler)
	       (_("%s: 0x%lx: fatal: R_SH_PSHA relocation %d not in range -32..32"),
		bfd_archive_filename (input_section->owner),
		(unsigned long) rel->r_offset,
		(unsigned long)relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;

	case R_SH_PSHL:
	  if ((signed int)relocation < -16
	      || (signed int)relocation > 16)
	    {
	      ((*_bfd_error_handler)
	       (_("%s: 0x%lx: fatal: R_SH_PSHL relocation %d not in range -32..32"),
		bfd_archive_filename (input_section->owner),
		(unsigned long) rel->r_offset,
		(unsigned long)relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;
a4859 6
#ifdef INCLUDE_SHMEDIA
	case R_SH_IMM_LOW16_PCREL:
	case R_SH_IMM_MEDLOW16_PCREL:
	case R_SH_IMM_MEDHI16_PCREL:
	case R_SH_IMM_HI16_PCREL:
#endif
a4860 3
	      && (h == NULL
		  || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		  || h->root.type != bfd_link_hash_undefweak)
d4863 6
a4868 2
	      && (r_type == R_SH_DIR32
		  || !SYMBOL_CALLS_LOCAL (info, h)))
d4871 1
a4871 2
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;
d4886 1
a4886 1
		    return FALSE;
d4897 2
a4898 2
	      skip = FALSE;
	      relocate = FALSE;
d4904 1
a4904 1
		skip = TRUE;
d4906 1
a4906 1
		skip = TRUE, relocate = TRUE;
a4918 11
#ifdef INCLUDE_SHMEDIA
	      else if (r_type == R_SH_IMM_LOW16_PCREL
		       || r_type == R_SH_IMM_MEDLOW16_PCREL
		       || r_type == R_SH_IMM_MEDHI16_PCREL
		       || r_type == R_SH_IMM_HI16_PCREL)
		{
		  BFD_ASSERT (h != NULL && h->dynindx != -1);
		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
		  outrel.r_addend = addend;
		}
#endif
d4928 1
a4928 1
		      relocate = TRUE;
d4944 5
a4948 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d5011 1
a5011 1
	      bfd_boolean dyn;
d5026 1
a5026 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d5028 3
a5030 3
		      && SYMBOL_REFERENCES_LOCAL (info, h))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
a5101 1
		      bfd_byte *loc;
d5115 5
a5119 3
		      loc = srelgot->contents;
		      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d5254 3
a5256 1
		      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d5267 2
d5274 1
a5274 1
		       jsr @@r1; add r12,r4; bra 3f; nop; .align 2;
d5345 35
a5379 2
	      bfd_put_32 (output_bfd, tpoff (info, relocation),
			  contents + rel->r_offset);
a5396 12
	  /* Relocate R_SH_TLS_IE_32 directly when statically linking.  */
	  if (r_type == R_SH_TLS_IE_32
	      && ! htab->root.dynamic_sections_created)
	    {
	      off &= ~1;
	      bfd_put_32 (output_bfd, tpoff (info, relocation),
			  sgot->contents + off);
	      bfd_put_32 (output_bfd, sgot->output_offset + off,
			  contents + rel->r_offset);
	      continue;
	    }

d5399 1
a5399 1
	  else
d5402 1
a5402 1
	      bfd_byte *loc;
d5414 1
a5414 5
	      if (h == NULL || h->dynindx == -1)
		indx = 0;
	      else
		indx = h->dynindx;

d5422 2
a5423 2
	      loc = srelgot->contents;
	      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
d5441 3
a5443 2
		      loc += sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d5574 1
a5574 1
	      bfd_byte *loc;
d5584 2
a5585 2
	      loc = srelgot->contents;
	      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
d5597 41
a5637 1
	    relocation = tpoff (info, relocation);
a5647 8
	    bfd_byte *loc;

	    if (! info->shared)
	      {
		relocation = tpoff (info, relocation);
		addend = rel->r_addend;
		goto final_link_relocate;
	      }
d5658 1
a5658 1
		  return FALSE;
d5669 1
a5669 5
	    if (h == NULL || h->dynindx == -1)
	      indx = 0;
	    else
	      indx = h->dynindx;

d5678 5
a5683 3
	    loc = sreloc->contents;
	    loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	    bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d5707 1
a5707 1
		      return FALSE;
d5714 1
a5714 1
		  return FALSE;
d5721 1
a5721 1
  return TRUE;
d5728 8
a5735 6
sh_elf_get_relocated_section_contents (bfd *output_bfd,
				       struct bfd_link_info *link_info,
				       struct bfd_link_order *link_order,
				       bfd_byte *data,
				       bfd_boolean relocatable,
				       asymbol **symbols)
d5746 1
a5746 1
  if (relocatable
d5750 1
a5750 1
						       relocatable,
d5765 3
a5767 3
      internal_relocs = (_bfd_elf_link_read_relocs
			 (input_bfd, input_section, NULL,
			  (Elf_Internal_Rela *) NULL, FALSE));
d5838 2
a5839 12
dtpoff_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for R_SH_TLS_TPOFF32..  */

static bfd_vma
tpoff (struct bfd_link_info *info, bfd_vma address)
d5841 4
a5844 6
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  /* SH TLS ABI is variant I and static TLS block start just after tcbhead
     structure which has 2 pointer fields.  */
  return address - elf_hash_table (info)->tls_sec->vma + 8;
d5848 6
a5853 4
sh_elf_gc_mark_hook (asection *sec,
		     struct bfd_link_info *info ATTRIBUTE_UNUSED,
		     Elf_Internal_Rela *rel, struct elf_link_hash_entry *h,
		     Elf_Internal_Sym *sym)
d5891 6
a5896 3
static bfd_boolean
sh_elf_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
		      asection *sec, const Elf_Internal_Rela *relocs)
d5902 3
a5914 3
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;
d5920 3
a5922 1
      if (r_symndx >= symtab_hdr->sh_info)
a5923 4
	  struct elf_sh_link_hash_entry *eh;
	  struct elf_sh_dyn_relocs **pp;
	  struct elf_sh_dyn_relocs *p;

a5932 8
	  eh = (struct elf_sh_link_hash_entry *) h;
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
d5934 1
d5936 3
a5938 2
      r_type = ELF32_R_TYPE (rel->r_info);
      switch (sh_elf_optimized_tls_reloc (info, r_type, h != NULL))
a5970 2
		  struct elf_sh_link_hash_entry *eh;
		  eh = (struct elf_sh_link_hash_entry *) h;
d5996 21
a6016 3
	  if (info->shared)
	    break;
	  /* Fall thru */
a6042 2
	      struct elf_sh_link_hash_entry *eh;
	      eh = (struct elf_sh_link_hash_entry *) h;
d6079 1
a6079 1
  return TRUE;
d6085 3
a6087 3
sh_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
			     struct elf_link_hash_entry *dir,
			     struct elf_link_hash_entry *ind)
d6149 1
a6149 12
  if (ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d6153 4
a6156 2
sh_elf_optimized_tls_reloc (struct bfd_link_info *info, int r_type,
			    int is_local)
d6179 6
a6184 3
static bfd_boolean
sh_elf_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
		     const Elf_Internal_Rela *relocs)
d6191 1
d6203 2
a6204 2
  if (info->relocatable)
    return TRUE;
d6213 1
d6287 4
a6290 7
	      if (htab->sgot == NULL)
		{
		  if (htab->root.dynobj == NULL)
		    htab->root.dynobj = abfd;
		  if (!create_got_section (htab->root.dynobj, info))
		    return FALSE;
		}
d6304 1
a6304 1
	    return FALSE;
d6311 1
a6311 1
	    return FALSE;
d6314 1
a6319 1
	force_got:
d6348 2
a6349 2
		  struct elf_sh_link_hash_entry *eh
		    = (struct elf_sh_link_hash_entry *) h;
d6380 1
a6380 1
		    return FALSE;
d6413 1
a6413 1
		  return FALSE;
a6483 6
#ifdef INCLUDE_SHMEDIA
	case R_SH_IMM_LOW16_PCREL:
	case R_SH_IMM_MEDLOW16_PCREL:
	case R_SH_IMM_MEDHI16_PCREL:
	case R_SH_IMM_HI16_PCREL:
#endif
d6527 2
a6528 2
	      if (htab->root.dynobj == NULL)
		htab->root.dynobj = abfd;
d6542 1
a6542 1
		    return FALSE;
d6548 1
a6548 1
		  sreloc = bfd_get_section_by_name (htab->root.dynobj, name);
d6553 1
a6553 1
		      sreloc = bfd_make_section (htab->root.dynobj, name);
d6559 3
a6561 5
			  || ! bfd_set_section_flags (htab->root.dynobj,
						      sreloc, flags)
			  || ! bfd_set_section_alignment (htab->root.dynobj,
							  sreloc, 2))
			return FALSE;
d6563 2
d6580 1
a6580 1
		    return FALSE;
d6590 1
a6590 1
		  p = bfd_alloc (htab->root.dynobj, amt);
d6592 1
a6592 1
		    return FALSE;
d6601 1
a6601 8
	      if (r_type == R_SH_REL32
#ifdef INCLUDE_SHMEDIA
		  || r_type == R_SH_IMM_LOW16_PCREL
		  || r_type == R_SH_IMM_MEDLOW16_PCREL
		  || r_type == R_SH_IMM_MEDHI16_PCREL
		  || r_type == R_SH_IMM_HI16_PCREL
#endif
		  )
d6612 1
a6612 1
	      return FALSE;
d6615 2
a6616 1
	  break;
d6618 1
d6620 81
a6700 1
	  /* Nothing to do.  */
d6708 1
a6708 1
  return TRUE;
d6712 3
a6714 2
static bfd_boolean
sh_elf_set_mach_from_flags (bfd *abfd)
a6725 3
    case EF_SH2E:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh2e);
      break;
a6741 12
    case EF_SH4_NOFPU:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4_nofpu);
      break;
    case EF_SH4A:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4a);
      break;
    case EF_SH4A_NOFPU:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4a_nofpu);
      break;
    case EF_SH4AL_DSP:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4al_dsp);
      break;
d6743 1
a6743 1
      return FALSE;
d6745 1
a6745 1
  return TRUE;
d6752 4
a6755 2
static bfd_boolean
sh_elf_set_private_flags (bfd *abfd, flagword flags)
d6761 1
a6761 1
  elf_flags_init (abfd) = TRUE;
d6769 4
a6772 2
static bfd_boolean
sh_elf_copy_private_data (bfd * ibfd, bfd * obfd)
d6776 1
a6776 1
    return TRUE;
d6786 4
a6789 2
static bfd_boolean
sh_elf_merge_private_data (bfd *ibfd, bfd *obfd)
d6794 1
a6794 1
    return FALSE;
d6798 1
a6798 1
    return TRUE;
d6803 1
a6803 1
      elf_flags_init (obfd) = TRUE;
d6817 1
a6817 1
      return FALSE;
d6829 3
a6831 2
static bfd_boolean
sh_elf_object_p (bfd *abfd)
d6833 13
a6845 1
  return sh_elf_set_mach_from_flags (abfd);
d6851 6
a6856 4
static bfd_boolean
sh_elf_finish_dynamic_symbol (bfd *output_bfd, struct bfd_link_info *info,
			      struct elf_link_hash_entry *h,
			      Elf_Internal_Sym *sym)
d6859 1
d6862 1
a6872 1
      bfd_byte *loc;
d6992 3
a6994 2
      loc = srel->contents + plt_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
a7010 1
      bfd_byte *loc;
d7029 4
a7032 1
	  && SYMBOL_REFERENCES_LOCAL (info, h))
d7046 4
a7049 3
      loc = srel->contents;
      loc += srel->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
a7061 1
	bfd_byte *loc;
d7080 4
a7083 1
	    && SYMBOL_REFERENCES_LOCAL (info, h))
d7098 4
a7101 3
	loc = srel->contents;
	loc += srel->reloc_count++ * sizeof (Elf32_External_Rela);
	bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
a7109 1
      bfd_byte *loc;
d7126 4
a7129 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
d7137 1
a7137 1
  return TRUE;
d7142 4
a7145 2
static bfd_boolean
sh_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
d7148 1
d7153 2
d7156 1
a7156 1
  sdyn = bfd_get_section_by_name (htab->root.dynobj, ".dynamic");
d7175 1
a7175 1
	  bfd_elf32_swap_dyn_in (htab->root.dynobj, dyncon, &dyn);
d7195 1
a7195 1
					    FALSE, FALSE, TRUE);
d7311 1
a7311 1
  return TRUE;
d7315 2
a7316 1
sh_elf_reloc_type_class (const Elf_Internal_Rela *rela)
d7331 5
a7335 3
/* Support for Linux core dump NOTE sections.  */
static bfd_boolean
elf32_shlin_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d7343 1
a7343 1
	return FALSE;
d7364 4
a7367 2
static bfd_boolean
elf32_shlin_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d7372 1
a7372 1
	return FALSE;
d7393 1
a7393 1
  return TRUE;
d7402 1
a7402 5
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE		0x1000
#else
#define ELF_MAXPAGESIZE		0x80
#endif
d7446 1
d7452 23
d7488 1
a7488 1
#undef	elf32_bed
d7493 1
d7509 1
a7509 1
#undef	elf32_bed
d7513 4
@


1.58
log
@	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.
@
text
@d3391 2
d3457 1
d3873 12
a3978 1
  eh = (struct elf_sh_link_hash_entry *) h;
d5217 1
d5320 8
a5327 1
	    if (h->got.refcount > 0)
a5328 2
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
d5388 2
d5564 1
@


1.58.8.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a61 6
static int sh_elf_optimized_tls_reloc
  PARAMS ((struct bfd_link_info *, int, int));
static boolean sh_elf_mkobject
  PARAMS((bfd *));
static boolean sh_elf_object_p
  PARAMS((bfd *));
a84 2
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
d716 8
a723 113

  HOWTO (R_SH_TLS_GD_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_GD_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LD_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LD_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LDO_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LDO_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_IE_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_IE_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LE_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LE_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_DTPMOD32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_DTPMOD32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_DTPOFF32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_DTPOFF32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_TPOFF32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_TPOFF32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

a1778 8
  { BFD_RELOC_SH_TLS_GD_32, R_SH_TLS_GD_32 },
  { BFD_RELOC_SH_TLS_LD_32, R_SH_TLS_LD_32 },
  { BFD_RELOC_SH_TLS_LDO_32, R_SH_TLS_LDO_32 },
  { BFD_RELOC_SH_TLS_IE_32, R_SH_TLS_IE_32 },
  { BFD_RELOC_SH_TLS_LE_32, R_SH_TLS_LE_32 },
  { BFD_RELOC_SH_TLS_DTPMOD32, R_SH_TLS_DTPMOD32 },
  { BFD_RELOC_SH_TLS_DTPOFF32, R_SH_TLS_DTPOFF32 },
  { BFD_RELOC_SH_TLS_TPOFF32, R_SH_TLS_TPOFF32 },
a1876 1
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC_5 || r > R_SH_LAST_INVALID_RELOC_5);
d3050 1
a3050 1
  0x00, 0xc8, 0x45, 0x10, /* add.l r12, r17, r17 */
d3070 1
a3070 1
  0x10, 0x45, 0xc8, 0x00, /* add.l r12, r17, r17 */
a3390 9

  bfd_signed_vma gotplt_refcount;

  enum {
    GOT_UNKNOWN = 0, GOT_NORMAL, GOT_TLS_GD, GOT_TLS_IE
  } tls_type;

  /* If true, R_SH_TLS_TPOFF32 relocation is generated.  */
  boolean tls_tpoff32;
a3392 30
#define sh_elf_hash_entry(ent) ((struct elf_sh_link_hash_entry *)(ent))

struct sh_elf_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
};

#define sh_elf_tdata(abfd) \
  ((struct sh_elf_obj_tdata *) (abfd)->tdata.any)

#define sh_elf_local_got_tls_type(abfd) \
  (sh_elf_tdata (abfd)->local_got_tls_type)

/* Override the generic function because we need to store sh_elf_obj_tdata
   as the specific tdata.  */

static boolean
sh_elf_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (struct sh_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return false;
  return true;
}
                 
a3409 7

  /* A counter or offset to track a TLS got entry.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } tls_ldm_got;
a3454 1
      eh->gotplt_refcount = 0;
a3457 2
      ret->tls_type = GOT_UNKNOWN;
      ret->tls_tpoff32 = false;
a3490 1
  ret->tls_ldm_got.refcount = 0;
d3582 1
a3582 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d3586 2
a3587 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a3588 2

      h = (struct elf_link_hash_entry *) bh;
a3869 12
  eh = (struct elf_sh_link_hash_entry *) h;
  if ((h->got.refcount > 0
      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
      && eh->gotplt_refcount > 0)
    {
      /* The symbol has been forced local, or we have some direct got refs,
         so treat all the gotplt refs as got refs. */
      h->got.refcount += eh->gotplt_refcount;
      if (h->plt.refcount >= eh->gotplt_refcount)
	h->plt.refcount -= eh->gotplt_refcount;
    }

a3930 1
      int tls_type = sh_elf_hash_entry (h)->tls_type;
a3956 3
      /* R_SH_TLS_GD needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->_raw_size += 4;
d3958 1
a3958 8
      /* R_SH_TLS_IE_32 needs one dynamic relocation,
	 R_SH_TLS_GD needs one if local symbol and two if global.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type == GOT_TLS_IE)
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->srelgot->_raw_size += 2 * sizeof (Elf32_External_Rela);
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d3964 1
a3994 3
      if (sh_elf_hash_entry (h)->tls_tpoff32)
	goto keep;

a4101 1
      char *local_tls_type;
a4146 1
      local_tls_type = sh_elf_local_got_tls_type (ibfd);
a4154 2
	      if (*local_tls_type == GOT_TLS_GD)
		s->_raw_size += 4;
a4159 1
	  ++local_tls_type;
a4162 11
  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_SH_TLS_LD_32
	 relocs.  */
      htab->tls_ldm_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 8;
      htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

a4297 1
  asection *srelgot;
a4308 1
  srelgot = NULL;
a4323 2
      bfd_vma off;
      int tls_type;
a4344 2
	  || (   r_type >= (int) R_SH_FIRST_INVALID_RELOC_5
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC_5)
d4515 1
a4515 4
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0)))
		  || (sec->output_section == NULL
		      && (sh_elf_hash_entry (h)->tls_type == GOT_TLS_IE
			  || sh_elf_hash_entry (h)->tls_type == GOT_TLS_GD)))
d4520 1
a4520 1
		    (_("%s: unresolvable relocation against symbol `%s' from %s section"),
d4523 1
a4523 1
		  return false;
d4768 1
d4826 2
d4861 1
d4864 2
a4865 6
		      if (srelgot == NULL)
			{
			  srelgot = bfd_get_section_by_name (dynobj,
							     ".rela.got");
			  BFD_ASSERT (srelgot != NULL);
			}
a4998 444

	case R_SH_TLS_GD_32:
	case R_SH_TLS_IE_32:
	  r_type = sh_elf_optimized_tls_reloc (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = sh_elf_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = sh_elf_hash_entry (h)->tls_type;
	      if (! info->shared
		  && (h->dynindx == -1
		      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  && (tls_type == GOT_TLS_IE
		      || sh_elf_hash_entry (h)->tls_tpoff32))
		r_type = R_SH_TLS_LE_32;
	    }

	  if (r_type == R_SH_TLS_GD_32 && tls_type == GOT_TLS_IE)
	    r_type = R_SH_TLS_IE_32;

	  if (r_type == R_SH_TLS_LE_32)
	    {
	      bfd_vma offset;
	      unsigned short insn;
	      int indx;
	      Elf_Internal_Rela outrel;

	      if (ELF32_R_TYPE (rel->r_info) == R_SH_TLS_GD_32)
		{
		  /* GD->LE transition:
		       mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		       jsr @@r1; add r12,r4; bra 3f; nop; .align 2; 
		       1: .long x$TLSGD; 2: .long __tls_get_addr@@PLT; 3:
		     We change it into:
		       mov.l 1f,r4; stc gbr,r0; add r4,r0; nop;
		       nop; nop; ...
		       1: .long x@@TPOFF; 2: .long __tls_get_addr@@PLT; 3:.  */

		  offset = rel->r_offset;
		  BFD_ASSERT (offset >= 16);
		  /* Size of GD instructions is 16 or 18.  */
		  offset -= 16;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		  if ((insn & 0xff00) == 0xc700)
		    {
		      BFD_ASSERT (offset >= 2);
		      offset -= 2;
		      insn = bfd_get_16 (input_bfd, contents + offset + 0);
		    }

		  BFD_ASSERT ((insn & 0xff00) == 0xd400);
		  insn = bfd_get_16 (input_bfd, contents + offset + 2);
		  BFD_ASSERT ((insn & 0xff00) == 0xc700);
		  insn = bfd_get_16 (input_bfd, contents + offset + 4);
		  BFD_ASSERT ((insn & 0xff00) == 0xd100);
		  insn = bfd_get_16 (input_bfd, contents + offset + 6);
		  BFD_ASSERT (insn == 0x310c);
		  insn = bfd_get_16 (input_bfd, contents + offset + 8);
		  BFD_ASSERT (insn == 0x410b);
		  insn = bfd_get_16 (input_bfd, contents + offset + 10);
		  BFD_ASSERT (insn == 0x34cc);

		  bfd_put_16 (output_bfd, 0x0012, contents + offset + 2);
		  bfd_put_16 (output_bfd, 0x304c, contents + offset + 4);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 6);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);
		}
	      else
		{
		  int index;

		  /* IE->LE transition:
		     mov.l 1f,r0; stc gbr,rN; mov.l @@(r0,r12),rM;
		     bra 2f; add ...; .align 2; 1: x@@GOTTPOFF; 2:
		     We change it into:
		     mov.l .Ln,rM; stc gbr,rN; nop; ...;
		     1: x@@TPOFF; 2:.  */

		  offset = rel->r_offset;
		  BFD_ASSERT (offset >= 16);
		  /* Size of IE instructions is 10 or 12.  */
		  offset -= 10;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		  if ((insn & 0xf0ff) == 0x0012)
		    {
		      BFD_ASSERT (offset >= 2);
		      offset -= 2;
		      insn = bfd_get_16 (input_bfd, contents + offset + 0);
		    }

		  BFD_ASSERT ((insn & 0xff00) == 0xd000);
		  index = insn & 0x00ff;
		  insn = bfd_get_16 (input_bfd, contents + offset + 2);
		  BFD_ASSERT ((insn & 0xf0ff) == 0x0012);
		  insn = bfd_get_16 (input_bfd, contents + offset + 4);
		  BFD_ASSERT ((insn & 0xf0ff) == 0x00ce);
		  insn = 0xd000 | (insn & 0x0f00) | index;
		  bfd_put_16 (output_bfd, insn, contents + offset + 0);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 4);
		}

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
		}

	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	      outrel.r_offset = (input_section->output_section->vma
				 + input_section->output_offset
				 + rel->r_offset);
	      outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;

	      continue;
	    }

	  sgot = htab->sgot;
	  if (sgot == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	  if ((off & 1) != 0)
	    off &= ~1;
          else
	    {
	      Elf_Internal_Rela outrel;
	      Elf32_External_Rela *loc;
	      int dr_type, indx;

	      if (srelgot == NULL)
		{
		  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
		  BFD_ASSERT (srelgot != NULL);
		}

	      outrel.r_offset = (sgot->output_section->vma
				 + sgot->output_offset + off);

	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	      dr_type = (r_type == R_SH_TLS_GD_32 ? R_SH_TLS_DTPMOD32 :
			 R_SH_TLS_TPOFF32);
	      if (dr_type == R_SH_TLS_TPOFF32 && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      outrel.r_info = ELF32_R_INFO (indx, dr_type);
	      loc = (Elf32_External_Rela *) srelgot->contents;
	      loc += srelgot->reloc_count++;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      if (r_type == R_SH_TLS_GD_32)
		{
		  if (indx == 0)
		    {
		      bfd_put_32 (output_bfd,
				  relocation - dtpoff_base (info),
				  sgot->contents + off + 4);
		    }
		  else
		    {
		      outrel.r_info = ELF32_R_INFO (indx,
						    R_SH_TLS_DTPOFF32);
		      outrel.r_offset += 4;
		      outrel.r_addend = 0;
		      srelgot->reloc_count++;
		      loc++;
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						loc);
		    }
		}

	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();

	  if (r_type == (int) ELF32_R_TYPE (rel->r_info))
	    relocation = sgot->output_offset + off;
	  else
	    {
	      bfd_vma offset;
	      unsigned short insn;

	      /* GD->IE transition:
		   mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		   jsr @@r1; add r12,r4; bra 3f; nop; .align 2;
		   1: .long x$TLSGD; 2: .long __tls_get_addr@@PLT; 3:
		 We change it into:
		   mov.l 1f,r0; stc gbr,r4; mov.l @@(r0,r12),r0; add r4,r0;
		   nop; nop; bra 3f; nop; .align 2;
		   1: .long x@@TPOFF; 2:...; 3:.  */

	      offset = rel->r_offset;
	      BFD_ASSERT (offset >= 16);
	      /* Size of GD instructions is 16 or 18.  */
	      offset -= 16;
	      insn = bfd_get_16 (input_bfd, contents + offset + 0);
	      if ((insn & 0xff00) == 0xc700)
		{
		  BFD_ASSERT (offset >= 2);
		  offset -= 2;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		}

	      BFD_ASSERT ((insn & 0xff00) == 0xd400);

	      /* Replace mov.l 1f,R4 with mov.l 1f,r0.  */
	      bfd_put_16 (output_bfd, insn & 0xf0ff, contents + offset);

	      insn = bfd_get_16 (input_bfd, contents + offset + 2);
	      BFD_ASSERT ((insn & 0xff00) == 0xc700);
	      insn = bfd_get_16 (input_bfd, contents + offset + 4);
	      BFD_ASSERT ((insn & 0xff00) == 0xd100);
	      insn = bfd_get_16 (input_bfd, contents + offset + 6);
	      BFD_ASSERT (insn == 0x310c);
	      insn = bfd_get_16 (input_bfd, contents + offset + 8);
	      BFD_ASSERT (insn == 0x410b);
	      insn = bfd_get_16 (input_bfd, contents + offset + 10);
	      BFD_ASSERT (insn == 0x34cc);

	      bfd_put_16 (output_bfd, 0x0412, contents + offset + 2);
	      bfd_put_16 (output_bfd, 0x00ce, contents + offset + 4);
	      bfd_put_16 (output_bfd, 0x304c, contents + offset + 6);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);

	      bfd_put_32 (output_bfd, sgot->output_offset + off,
			  contents + rel->r_offset);

	      continue;
	  }

	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_TLS_LD_32:
	  if (! info->shared)
	    {
	      bfd_vma offset;
	      unsigned short insn;

	      /* LD->LE transition:
		   mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		   jsr @@r1; add r12,r4; bra 3f; nop; .align 2;
		   1: .long x$TLSLD; 2: .long __tls_get_addr@@PLT; 3:
		 We change it into:
		   stc gbr,r0; nop; nop; nop;
		   nop; nop; bra 3f; ...; 3:.  */

	      offset = rel->r_offset;
	      BFD_ASSERT (offset >= 16);
	      /* Size of LD instructions is 16 or 18.  */
	      offset -= 16;
	      insn = bfd_get_16 (input_bfd, contents + offset + 0);
	      if ((insn & 0xff00) == 0xc700)
		{
		  BFD_ASSERT (offset >= 2);
		  offset -= 2;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		}

	      BFD_ASSERT ((insn & 0xff00) == 0xd400);
	      insn = bfd_get_16 (input_bfd, contents + offset + 2);
	      BFD_ASSERT ((insn & 0xff00) == 0xc700);
	      insn = bfd_get_16 (input_bfd, contents + offset + 4);
	      BFD_ASSERT ((insn & 0xff00) == 0xd100);
	      insn = bfd_get_16 (input_bfd, contents + offset + 6);
	      BFD_ASSERT (insn == 0x310c);
	      insn = bfd_get_16 (input_bfd, contents + offset + 8);
	      BFD_ASSERT (insn == 0x410b);
	      insn = bfd_get_16 (input_bfd, contents + offset + 10);
	      BFD_ASSERT (insn == 0x34cc);

	      bfd_put_16 (output_bfd, 0x0012, contents + offset + 0);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 2);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 4);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 6);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);

	      continue;
	    }

	  sgot = htab->sgot;
	  if (sgot == NULL)
	    abort ();

	  off = htab->tls_ldm_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      Elf32_External_Rela *loc;

	      srelgot = htab->srelgot;
	      if (srelgot == NULL)
		abort ();

	      outrel.r_offset = (sgot->output_section->vma
				 + sgot->output_offset + off);
	      outrel.r_addend = 0;
	      outrel.r_info = ELF32_R_INFO (0, R_SH_TLS_DTPMOD32);
	      loc = (Elf32_External_Rela *) srelgot->contents;
	      loc += srelgot->reloc_count++;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ldm_got.offset |= 1;
	    }

	  relocation = sgot->output_offset + off;
	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_TLS_LDO_32:
	  if (! info->shared)
	    {
	      int indx;
	      Elf_Internal_Rela outrel;

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
		}

	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	      outrel.r_offset = (input_section->output_section->vma
				 + input_section->output_offset
				 + rel->r_offset);
	      outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;

	      continue;
	    }
	  else
	    relocation -= dtpoff_base (info);

	  addend = rel->r_addend;
	  goto final_link_relocate;

	case R_SH_TLS_LE_32:
	  {
	    int indx;
	    Elf_Internal_Rela outrel;

	    if (sreloc == NULL)
	      {
		const char *name;

		name = (bfd_elf_string_from_elf_section
			(input_bfd,
			 elf_elfheader (input_bfd)->e_shstrndx,
			 elf_section_data (input_section)->rel_hdr.sh_name));
		if (name == NULL)
		  return false;

		BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			    && strcmp (bfd_get_section_name (input_bfd,
							     input_section),
				       name + 5) == 0);

		sreloc = bfd_get_section_by_name (dynobj, name);
		BFD_ASSERT (sreloc != NULL);
	      }

	    indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	    outrel.r_offset = (input_section->output_section->vma
			       + input_section->output_offset
			       + rel->r_offset);
	    outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	    if (indx == 0)
	      outrel.r_addend = relocation - dtpoff_base (info);
	    else
	      outrel.r_addend = 0;
	    bfd_elf32_swap_reloca_out (output_bfd, &outrel,
				       (((Elf32_External_Rela *)
					 sreloc->contents)
					+ sreloc->reloc_count));
	    ++sreloc->reloc_count;

	    continue;
	  }
a5145 14
/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (info)
     struct bfd_link_info *info;
{
 /* If tls_segment is NULL, we should have signalled an error already.  */
 if (elf_hash_table (info)->tls_segment == NULL)
   return 0;
  return elf_hash_table (info)->tls_segment->start;
}

a5202 1
  struct elf_sh_link_hash_entry *eh;
d5212 1
a5212 3
    switch (sh_elf_optimized_tls_reloc (info, ELF32_R_TYPE (rel->r_info),
				   ELF32_R_SYM (rel->r_info)
				   >= symtab_hdr->sh_info))
a5213 5
      case R_SH_TLS_LD_32:
	if (sh_elf_hash_table (info)->tls_ldm_got.refcount > 0)
	  sh_elf_hash_table (info)->tls_ldm_got.refcount -= 1;
	break;

a5232 2
      case R_SH_TLS_GD_32:
      case R_SH_TLS_IE_32:
d5305 1
a5305 8
	    eh = (struct elf_sh_link_hash_entry *) h;
	    if (eh->gotplt_refcount > 0)
	      {
		eh->gotplt_refcount -= 1;
		if (h->plt.refcount > 0)
		  h->plt.refcount -= 1;
	      }
	    else if (h->got.refcount > 0)
d5307 2
a5367 9
  edir->gotplt_refcount = eind->gotplt_refcount;
  eind->gotplt_refcount = 0;

  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }
a5371 23
static int
sh_elf_optimized_tls_reloc (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_SH_TLS_GD_32:
    case R_SH_TLS_IE_32:
      if (is_local)
	return R_SH_TLS_LE_32;
      return R_SH_TLS_IE_32;
    case R_SH_TLS_LD_32:
      return R_SH_TLS_LE_32;
    }

  return r_type;
}

a5392 2
  unsigned int r_type;
  int tls_type, old_tls_type;
a5417 2
      r_type = ELF32_R_TYPE (rel->r_info);

a5422 10
      r_type = sh_elf_optimized_tls_reloc (info, r_type, h == NULL);
      if (! info->shared
	  && r_type == R_SH_TLS_IE_32
	  && h != NULL
	  && h->root.type != bfd_link_hash_undefined
	  && h->root.type != bfd_link_hash_undefweak
	  && (h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	r_type = R_SH_TLS_LE_32;

d5426 1
a5426 1
	  switch (r_type)
a5453 3
	    case R_SH_TLS_GD_32:
	    case R_SH_TLS_LD_32:
	    case R_SH_TLS_IE_32:
d5465 1
a5465 1
      switch (r_type)
a5481 6
	case R_SH_TLS_IE_32:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;

	  /* FALLTHROUGH */
	case R_SH_TLS_GD_32:
a5490 13
	  switch (r_type)
	    {
	    default:
	      tls_type = GOT_NORMAL;
	      break;
	    case R_SH_TLS_GD_32:
	      tls_type = GOT_TLS_GD;
	      break;
	    case R_SH_TLS_IE_32:
	      tls_type = GOT_TLS_IE;
	      break;
	    }

d5492 1
a5492 4
	    {
	      h->got.refcount += 1;
	      old_tls_type = sh_elf_hash_entry (h)->tls_type;
	    }
a5510 1
		  size += symtab_hdr->sh_info;
a5515 9
#ifdef 	INCLUDE_SHMEDIA
		  /* Take care of both the datalabel and codelabel local
		     GOT offsets.  */
		  sh_elf_local_got_tls_type (abfd)
		    = (char *) (local_got_refcounts + 2 * symtab_hdr->sh_info);
#else
		  sh_elf_local_got_tls_type (abfd)
		    = (char *) (local_got_refcounts + symtab_hdr->sh_info);
#endif
a5517 25
	      old_tls_type = sh_elf_local_got_tls_type (abfd) [r_symndx];
	    }

	  /* If a TLS symbol is accessed using IE at least once,
	     there is no point to use dynamic model for it.  */
	  if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN
	      && (old_tls_type != GOT_TLS_GD || tls_type != GOT_TLS_IE))
	    {
	      if (old_tls_type == GOT_TLS_IE && tls_type == GOT_TLS_GD)
		tls_type = GOT_TLS_IE;
	      else
		{
		  (*_bfd_error_handler)
		    (_("%s: `%s' accessed both as normal and thread local symbol"),
		     bfd_archive_filename (abfd), h->root.root.string);
		  return false;
		}
	    }

	  if (old_tls_type != tls_type)
	    {
	      if (h != NULL)
		sh_elf_hash_entry (h)->tls_type = tls_type;
	      else
		sh_elf_local_got_tls_type (abfd) [r_symndx] = tls_type;
a5518 5

	  break;

	case R_SH_TLS_LD_32:
	  sh_elf_hash_table(info)->tls_ldm_got.refcount += 1;
a5541 1
	  ((struct elf_sh_link_hash_entry *) h)->gotplt_refcount += 1;
d5600 1
a5600 1
	       && (r_type != R_SH_REL32
d5690 1
a5690 1
	      if (r_type == R_SH_REL32)
a5694 99

	case R_SH_TLS_LE_32:
	  if (info->shared)
	    {
	      (*_bfd_error_handler) (_("%s: TLS local exec code cannot be linked into shared objects"),
				     bfd_archive_filename (abfd));
	      return false;
	    }

	  if (ELF32_R_TYPE (rel->r_info) == R_SH_TLS_LD_32)
	    break;

	  /* FALLTHROUGH */
	case R_SH_TLS_LDO_32:
	  /* We make a R_SH_TLS_TPOFF32 relocation. Count it as a
	     copy relocation.  */
	  if (! info->shared)
	    {
	      struct elf_sh_dyn_relocs *p;
	      struct elf_sh_dyn_relocs **head;

	      if (dynobj == NULL)
		htab->root.dynobj = dynobj = abfd;

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      sreloc = bfd_make_section (dynobj, name);
		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
			return false;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		head = &((struct elf_sh_link_hash_entry *) h)->dyn_relocs;
	      else
		{
		  asection *s;

		  /* Track dynamic relocs needed for local syms too.  */
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return false;

		  head = ((struct elf_sh_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof (*p);
		  p = ((struct elf_sh_dyn_relocs *) bfd_alloc (dynobj, amt));
		  if (p == NULL)
		    return false;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		}

	      p->count += 1;
	      if (h)
		sh_elf_hash_entry (h)->tls_tpoff32 = true;
	    }
	  break;

	default:
	  break;
a5814 23
/* Override the generic function because we need to store sh_elf_obj_tdata
   as the specific tdata.  We set also the machine architecture from flags
   here.  */

static boolean
sh_elf_object_p (abfd)
  bfd *abfd;
{
  struct sh_elf_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct sh_elf_obj_tdata);

  if (sh_elf_set_mach_from_flags (abfd) == false)
    return false;

  /* Allocate our special target data.  */
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return false;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;
  return true;
}

d5971 1
a5971 3
  if (h->got.offset != (bfd_vma) -1
      && sh_elf_hash_entry (h)->tls_type != GOT_TLS_GD
      && sh_elf_hash_entry (h)->tls_type != GOT_TLS_IE)
d6260 1
a6260 2
#define bfd_elf32_mkobject		sh_elf_mkobject
#define elf_backend_object_p		sh_elf_object_p
@


1.58.8.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a107 4
static boolean elf32_shlin_grok_prstatus
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));
static boolean elf32_shlin_grok_psinfo
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));
d3508 1
a3508 5
  union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } datalabel_got;
d3619 5
a3623 2
      ret->dyn_relocs = NULL;
      ret->gotplt_refcount = 0;
d3625 1
a3625 1
      ret->datalabel_got.refcount = ret->root.got.refcount;
d4130 12
d4143 1
a4161 26
#ifdef INCLUDE_SHMEDIA
  if (eh->datalabel_got.refcount > 0)
    {
      asection *s;
      boolean dyn;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      s = htab->sgot;
      eh->datalabel_got.offset = s->_raw_size;
      s->_raw_size += 4;
      dyn = htab->root.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    eh->datalabel_got.offset = (bfd_vma) -1;
#endif

d5002 1
a5002 1
		  off = hsh->datalabel_got.offset;
d5038 1
a5038 1
			  hsh->datalabel_got.offset |= 1;
d5896 8
a5903 4
    {
#ifdef INCLUDE_SHMEDIA
      int seen_stt_datalabel = 0;
#endif
d5905 34
a5938 16
      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
#ifdef INCLUDE_SHMEDIA
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    {
	      seen_stt_datalabel |= h->type == STT_DATALABEL;
	      h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
#endif
	}
      eh = (struct elf_sh_link_hash_entry *) h;
d5940 8
a5947 57
      switch (sh_elf_optimized_tls_reloc (info, ELF32_R_TYPE (rel->r_info),
					  ELF32_R_SYM (rel->r_info)
					  >= symtab_hdr->sh_info))
	{
	case R_SH_TLS_LD_32:
	  if (sh_elf_hash_table (info)->tls_ldm_got.refcount > 0)
	    sh_elf_hash_table (info)->tls_ldm_got.refcount -= 1;
	  break;

	case R_SH_GOT32:
	case R_SH_GOTOFF:
	case R_SH_GOTPC:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOT_LOW16:
	case R_SH_GOT_MEDLOW16:
	case R_SH_GOT_MEDHI16:
	case R_SH_GOT_HI16:
	case R_SH_GOT10BY4:
	case R_SH_GOT10BY8:
	case R_SH_GOTOFF_LOW16:
	case R_SH_GOTOFF_MEDLOW16:
	case R_SH_GOTOFF_MEDHI16:
	case R_SH_GOTOFF_HI16:
	case R_SH_GOTPC_LOW16:
	case R_SH_GOTPC_MEDLOW16:
	case R_SH_GOTPC_MEDHI16:
	case R_SH_GOTPC_HI16:
#endif
	case R_SH_TLS_GD_32:
	case R_SH_TLS_IE_32:
	  if (h != NULL)
	    {
#ifdef INCLUDE_SHMEDIA
	      if (seen_stt_datalabel)
		{
		  if (eh->datalabel_got.refcount > 0)
		    eh->datalabel_got.refcount -= 1;
		}
	      else
#endif
		if (h->got.refcount > 0)
		  h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
#ifdef INCLUDE_SHMEDIA
	      if (rel->r_addend & 1)
		{
		  if (local_got_refcounts[symtab_hdr->sh_info + r_symndx] > 0)
		    local_got_refcounts[symtab_hdr->sh_info + r_symndx] -= 1;
		}
	      else
#endif
		if (local_got_refcounts[r_symndx] > 0)
		  local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d5949 1
a5949 6
	case R_SH_DIR32:
	case R_SH_REL32:
	  if (h != NULL)
	    {
	      struct elf_sh_dyn_relocs **pp;
	      struct elf_sh_dyn_relocs *p;
d5951 2
d5954 1
a5954 2
	      if (!info->shared && h->plt.refcount > 0)
		h->plt.refcount -= 1;
d5956 12
a5967 12
	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    if (ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
		      p->pc_count -= 1;
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	    }
	  break;
d5969 1
a5969 1
	case R_SH_PLT32:
d5971 4
a5974 4
	case R_SH_PLT_LOW16:
	case R_SH_PLT_MEDLOW16:
	case R_SH_PLT_MEDHI16:
	case R_SH_PLT_HI16:
d5976 8
a5983 6
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;
d5985 1
a5985 1
	case R_SH_GOTPLT32:
d5987 6
a5992 6
	case R_SH_GOTPLT_LOW16:
	case R_SH_GOTPLT_MEDLOW16:
	case R_SH_GOTPLT_MEDHI16:
	case R_SH_GOTPLT_HI16:
	case R_SH_GOTPLT10BY4:
	case R_SH_GOTPLT10BY8:
d5994 20
a6013 32
	  if (h != NULL)
	    {
	      if (eh->gotplt_refcount > 0)
		{
		  eh->gotplt_refcount -= 1;
		  if (h->plt.refcount > 0)
		    h->plt.refcount -= 1;
		}
#ifdef INCLUDE_SHMEDIA
	      else if (seen_stt_datalabel)
		{
		  if (eh->datalabel_got.refcount > 0)
		    eh->datalabel_got.refcount -= 1;
		}
#endif
	      else if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
#ifdef INCLUDE_SHMEDIA
	      if (rel->r_addend & 1)
		{
		  if (local_got_refcounts[symtab_hdr->sh_info + r_symndx] > 0)
		    local_got_refcounts[symtab_hdr->sh_info + r_symndx] -= 1;
		}
	      else
#endif
		if (local_got_refcounts[r_symndx] > 0)
		  local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d6015 3
a6017 4
	default:
	  break;
	}
    }
a6029 3
#ifdef INCLUDE_SHMEDIA
  bfd_signed_vma tmp;
#endif
a6067 10
#ifdef INCLUDE_SHMEDIA
  tmp = edir->datalabel_got.refcount;
  if (tmp < 1)
    {
      edir->datalabel_got.refcount = eind->datalabel_got.refcount;
      eind->datalabel_got.refcount = tmp;
    }
  else
    BFD_ASSERT (eind->datalabel_got.refcount < 1);
#endif
a6147 3
#ifdef INCLUDE_SHMEDIA
      int seen_stt_datalabel = 0;
#endif
d6155 1
a6155 11
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
#ifdef INCLUDE_SHMEDIA
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    {
	      seen_stt_datalabel |= h->type == STT_DATALABEL;
	      h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
#endif
	}
d6259 1
a6259 11
#ifdef INCLUDE_SHMEDIA
	      if (seen_stt_datalabel)
		{
		  struct elf_sh_link_hash_entry *eh = 
		    (struct elf_sh_link_hash_entry *)h;

		  eh->datalabel_got.refcount += 1;
		}
	      else
#endif
		h->got.refcount += 1;
d6296 1
a6296 6
#ifdef INCLUDE_SHMEDIA
	      if (rel->r_addend & 1)
		local_got_refcounts[symtab_hdr->sh_info + r_symndx] += 1;
	      else
#endif
		local_got_refcounts[r_symndx] += 1;
a6950 54
#ifdef INCLUDE_SHMEDIA
  {
    struct elf_sh_link_hash_entry *eh;

    eh = (struct elf_sh_link_hash_entry *) h;
    if (eh->datalabel_got.offset != (bfd_vma) -1)
      {
	asection *sgot;
	asection *srel;
	Elf_Internal_Rela rel;

	/* This symbol has a datalabel entry in the global offset table.
	   Set it up.  */

	sgot = htab->sgot;
	srel = htab->srelgot;
	BFD_ASSERT (sgot != NULL && srel != NULL);

	rel.r_offset = (sgot->output_section->vma
			+ sgot->output_offset
			+ (eh->datalabel_got.offset &~ (bfd_vma) 1));

	/* If this is a static link, or it is a -Bsymbolic link and the
	   symbol is defined locally or was forced to be local because
	   of a version file, we just want to emit a RELATIVE reloc.
	   The entry in the global offset table will already have been
	   initialized in the relocate_section function.  */
	if (info->shared
	    && (info->symbolic
		|| h->dynindx == -1
		|| (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
	    && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	  {
	    rel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
	    rel.r_addend = (h->root.u.def.value
			    + h->root.u.def.section->output_section->vma
			    + h->root.u.def.section->output_offset);
	  }
	else
	  {
	    bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents
			+ eh->datalabel_got.offset);
	    rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_GLOB_DAT);
	    rel.r_addend = 0;
	  }

	bfd_elf32_swap_reloca_out (output_bfd, &rel,
				   ((Elf32_External_Rela *) srel->contents
				    + srel->reloc_count));
	++srel->reloc_count;
      }
  }
#endif

d7176 1
a7176 65
/* Support for Linux core dump NOTE sections */
static boolean
elf32_shlin_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  int offset;
  unsigned int raw_size;

  switch (note->descsz)
    {
      default:
	return false;

      case 168:		/* Linux/SH */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	raw_size = 92;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}

static boolean
elf32_shlin_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  switch (note->descsz)
    {
      default:
	return false;

      case 124:		/* Linux/SH elf_prpsinfo */
	elf_tdata (abfd)->core_program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
	elf_tdata (abfd)->core_command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return true;
}

d7186 1
d7230 1
a7230 2
#ifndef INCLUDE_SHMEDIA

d7232 1
a7233 67
/* QNX support.  */
#include "elf32-qnx.h"

#undef	TARGET_LITTLE_SYM 
#define	TARGET_LITTLE_SYM		bfd_elf32_shlqnx_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-shl-nto"
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shqnx_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-sh-nto"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x1000

#define	elf32_bed			elf32_sh_qnx_bed

#include "elf32-target.h"

#undef	elf_backend_set_nonloadable_filepos
#undef	elf_backend_is_contained_by_filepos
#undef	elf_backend_copy_private_bfd_data_p
#undef	elf32_bed

/* NetBSD support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shnbsd_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-sh-nbsd"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf32_shlnbsd_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-shl-nbsd"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x10000
#undef	elf_symbol_leading_char
#define	elf_symbol_leading_char		0

#define	elf32_bed			elf32_sh_nbsd_bed

#include "elf32-target.h"

#undef	elf32_bed

/* Linux support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shblin_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-shbig-linux"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf32_shlin_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-sh-linux"

#undef	elf_backend_grok_prstatus
#define	elf_backend_grok_prstatus	elf32_shlin_grok_prstatus
#undef	elf_backend_grok_psinfo
#define	elf_backend_grok_psinfo		elf32_shlin_grok_psinfo

#define	elf32_bed			elf32_sh_lin_bed

#include "elf32-target.h"

#undef	elf_backend_grok_prstatus
#undef	elf_backend_grok_psinfo
#undef	elf32_bed

#endif /* INCLUDE_SHMEDIA */
@


1.58.8.3
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d7452 23
@


1.58.8.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d37 1
a37 1
static bfd_boolean sh_elf_set_private_flags
d39 1
a39 1
static bfd_boolean sh_elf_copy_private_data
d41 1
a41 1
static bfd_boolean sh_elf_merge_private_data
d43 1
a43 1
static bfd_boolean sh_elf_set_mach_from_flags
d45 3
a47 3
static bfd_boolean sh_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean sh_elf_relax_delete_bytes
d49 3
a51 3
static bfd_boolean sh_elf_align_loads
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_byte *, bfd_boolean *));
static bfd_boolean sh_elf_swap_insns
d53 1
a53 1
static bfd_boolean sh_elf_relocate_section
d58 1
a58 1
	   bfd_byte *, bfd_boolean, asymbol **));
d64 1
a64 1
static bfd_boolean sh_elf_mkobject
d66 1
a66 1
static bfd_boolean sh_elf_object_p
d68 1
a68 1
static bfd_boolean sh_elf_check_relocs
d75 1
a75 1
static bfd_boolean sh_elf_adjust_dynamic_symbol
d77 1
a77 1
static bfd_boolean sh_elf_size_dynamic_sections
d79 1
a79 1
static bfd_boolean sh_elf_finish_dynamic_symbol
d82 1
a82 1
static bfd_boolean sh_elf_finish_dynamic_sections
d87 1
a87 1
static bfd_boolean create_got_section
d89 1
a89 1
static bfd_boolean sh_elf_create_dynamic_sections
d96 1
a96 1
static bfd_boolean sh_elf_gc_sweep_hook
d99 1
a99 1
static bfd_boolean allocate_dynrelocs
d101 1
a101 1
static bfd_boolean readonly_dynrelocs
d108 1
a108 1
static bfd_boolean elf32_shlin_grok_prstatus
d110 1
a110 1
static bfd_boolean elf32_shlin_grok_psinfo
d125 1
a125 1
	 FALSE,			/* pc_relative */
d130 1
a130 1
	 FALSE,			/* partial_inplace */
d133 1
a133 1
	 FALSE),		/* pcrel_offset */
d135 1
a135 1
  /* 32 bit absolute relocation.  Setting partial_inplace to TRUE and
d141 1
a141 1
	 FALSE,			/* pc_relative */
d146 1
a146 1
	 TRUE,			/* partial_inplace */
d149 1
a149 1
	 FALSE),		/* pcrel_offset */
d156 1
a156 1
	 TRUE,			/* pc_relative */
d161 1
a161 1
	 TRUE,			/* partial_inplace */
d164 1
a164 1
	 TRUE),			/* pcrel_offset */
d171 1
a171 1
	 TRUE,			/* pc_relative */
d176 1
a176 1
	 TRUE,			/* partial_inplace */
d179 1
a179 1
	 TRUE),			/* pcrel_offset */
d186 1
a186 1
	 TRUE,			/* pc_relative */
d191 1
a191 1
	 TRUE,			/* partial_inplace */
d194 1
a194 1
	 TRUE),			/* pcrel_offset */
d201 1
a201 1
	 TRUE,			/* pc_relative */
d206 1
a206 1
	 TRUE,			/* partial_inplace */
d209 1
a209 1
	 TRUE),			/* pcrel_offset */
d216 1
a216 1
	 TRUE,			/* pc_relative */
d221 1
a221 1
	 TRUE,			/* partial_inplace */
d224 1
a224 1
	 TRUE),			/* pcrel_offset */
d233 1
a233 1
	 FALSE,			/* pc_relative */
d238 1
a238 1
	 FALSE,			/* partial_inplace */
d241 1
a241 1
	 TRUE),			/* pcrel_offset */
d250 1
a250 1
	 FALSE,			/* pc_relative */
d255 1
a255 1
	 FALSE,			/* partial_inplace */
d258 1
a258 1
	 TRUE),			/* pcrel_offset */
d267 1
a267 1
	 FALSE,			/* pc_relative */
d272 1
a272 1
	 FALSE,			/* partial_inplace */
d275 1
a275 1
	 TRUE),			/* pcrel_offset */
d305 1
a305 1
	 FALSE,			/* pc_relative */
d310 1
a310 1
	 FALSE,			/* partial_inplace */
d313 1
a313 1
	 TRUE),			/* pcrel_offset */
d322 1
a322 1
	 FALSE,			/* pc_relative */
d327 1
a327 1
	 FALSE,			/* partial_inplace */
d330 1
a330 1
	 TRUE),			/* pcrel_offset */
d340 1
a340 1
	 FALSE,			/* pc_relative */
d345 1
a345 1
	 FALSE,			/* partial_inplace */
d348 1
a348 1
	 TRUE),			/* pcrel_offset */
d358 1
a358 1
	 FALSE,			/* pc_relative */
d363 1
a363 1
	 FALSE,			/* partial_inplace */
d366 1
a366 1
	 TRUE),			/* pcrel_offset */
d375 1
a375 1
	 FALSE,			/* pc_relative */
d380 1
a380 1
	 FALSE,			/* partial_inplace */
d383 1
a383 1
	 TRUE),			/* pcrel_offset */
d392 1
a392 1
	 FALSE,			/* pc_relative */
d397 1
a397 1
	 FALSE,			/* partial_inplace */
d400 1
a400 1
	 TRUE),			/* pcrel_offset */
d408 1
a408 1
	 FALSE,			/* pc_relative */
d413 1
a413 1
	 FALSE,			/* partial_inplace */
d416 1
a416 1
	 TRUE),			/* pcrel_offset */
d425 1
a425 1
	 FALSE,			/* pc_relative */
d430 1
a430 1
	 FALSE,			/* partial_inplace */
d433 1
a433 1
	 TRUE),			/* pcrel_offset */
d442 1
a442 1
	 FALSE,			/* pc_relative */
d447 1
a447 1
	 FALSE,			/* partial_inplace */
d450 1
a450 1
	 TRUE),			/* pcrel_offset */
d457 1
a457 1
	 FALSE,			/* pc_relative */
d462 1
a462 1
	 FALSE,			/* partial_inplace */
d465 1
a465 1
	 FALSE),		/* pcrel_offset */
d472 1
a472 1
	 FALSE,			/* pc_relative */
d477 1
a477 1
	 FALSE,			/* partial_inplace */
d480 1
a480 1
	 FALSE),		/* pcrel_offset */
d487 1
a487 1
	 FALSE,			/* pc_relative */
d492 1
a492 1
	 TRUE,			/* partial_inplace */
d495 1
a495 1
	 TRUE),			/* pcrel_offset */
d502 1
a502 1
	 FALSE,			/* pc_relative */
d507 1
a507 1
	 TRUE,			/* partial_inplace */
d510 1
a510 1
	 TRUE),			/* pcrel_offset */
d526 1
a526 1
	 FALSE,			/* pc_relative */
d531 1
a531 1
	 FALSE,			/* partial_inplace */
d534 1
a534 1
	 FALSE),		/* pcrel_offset */
d541 1
a541 1
	 FALSE,			/* pc_relative */
d546 1
a546 1
	 FALSE,			/* partial_inplace */
d549 1
a549 1
	 FALSE),		/* pcrel_offset */
d556 1
a556 1
	 FALSE,			/* pc_relative */
d561 1
a561 1
	 FALSE,			/* partial_inplace */
d564 1
a564 1
	 FALSE),		/* pcrel_offset */
d571 1
a571 1
	 FALSE,			/* pc_relative */
d576 1
a576 1
	 FALSE,			/* partial_inplace */
d579 1
a579 1
	 FALSE),		/* pcrel_offset */
d586 1
a586 1
	 FALSE,			/* pc_relative */
d591 1
a591 1
	 FALSE,			/* partial_inplace */
d594 1
a594 1
	 FALSE),		/* pcrel_offset */
d601 1
a601 1
	 FALSE,			/* pc_relative */
d606 1
a606 1
	 FALSE,			/* partial_inplace */
d609 1
a609 1
	 FALSE),		/* pcrel_offset */
d616 1
a616 1
	 FALSE,			/* pc_relative */
d621 1
a621 1
	 FALSE,			/* partial_inplace */
d624 1
a624 1
	 FALSE),		/* pcrel_offset */
d733 1
a733 1
	 FALSE,			/* pc_relative */
d738 1
a738 1
	 TRUE,			/* partial_inplace */
d741 1
a741 1
	 FALSE),		/* pcrel_offset */
d747 1
a747 1
	 FALSE,			/* pc_relative */
d752 1
a752 1
	 TRUE,			/* partial_inplace */
d755 1
a755 1
	 FALSE),		/* pcrel_offset */
d761 1
a761 1
	 FALSE,			/* pc_relative */
d766 1
a766 1
	 TRUE,			/* partial_inplace */
d769 1
a769 1
	 FALSE),		/* pcrel_offset */
d775 1
a775 1
	 FALSE,			/* pc_relative */
d780 1
a780 1
	 TRUE,			/* partial_inplace */
d783 1
a783 1
	 FALSE),		/* pcrel_offset */
d789 1
a789 1
	 FALSE,			/* pc_relative */
d794 1
a794 1
	 TRUE,			/* partial_inplace */
d797 1
a797 1
	 FALSE),		/* pcrel_offset */
d803 1
a803 1
	 FALSE,			/* pc_relative */
d808 1
a808 1
	 TRUE,			/* partial_inplace */
d811 1
a811 1
	 FALSE),		/* pcrel_offset */
d817 1
a817 1
	 FALSE,			/* pc_relative */
d822 1
a822 1
	 TRUE,			/* partial_inplace */
d825 1
a825 1
	 FALSE),		/* pcrel_offset */
d831 1
a831 1
	 FALSE,			/* pc_relative */
d836 1
a836 1
	 TRUE,			/* partial_inplace */
d839 1
a839 1
	 FALSE),		/* pcrel_offset */
d854 1
a854 1
	 FALSE,			/* pc_relative */
d859 1
a859 1
	 TRUE,			/* partial_inplace */
d862 1
a862 1
	 FALSE),		/* pcrel_offset */
d868 1
a868 1
	 TRUE,			/* pc_relative */
d873 1
a873 1
	 TRUE,			/* partial_inplace */
d876 1
a876 1
	 TRUE),			/* pcrel_offset */
d882 1
a882 1
	 FALSE,			/* pc_relative */
d887 1
a887 1
	 TRUE,			/* partial_inplace */
d890 1
a890 1
	 FALSE),		/* pcrel_offset */
d896 1
a896 1
	 FALSE,			/* pc_relative */
d901 1
a901 1
	 TRUE,			/* partial_inplace */
d904 1
a904 1
	 FALSE),		/* pcrel_offset */
d910 1
a910 1
	 FALSE,			/* pc_relative */
d915 1
a915 1
	 TRUE,			/* partial_inplace */
d918 1
a918 1
	 FALSE),		/* pcrel_offset */
d924 1
a924 1
	 FALSE,			/* pc_relative */
d929 1
a929 1
	 TRUE,			/* partial_inplace */
d932 1
a932 1
	 FALSE),		/* pcrel_offset */
d938 1
a938 1
	 FALSE,			/* pc_relative */
d943 1
a943 1
	 TRUE,			/* partial_inplace */
d946 1
a946 1
	 FALSE),		/* pcrel_offset */
d952 1
a952 1
	 TRUE,			/* pc_relative */
d957 1
a957 1
	 TRUE,			/* partial_inplace */
d960 1
a960 1
	 TRUE),			/* pcrel_offset */
d966 1
a966 1
	 FALSE,			/* pc_relative */
d971 1
a971 1
	 FALSE,			/* partial_inplace */
d974 1
a974 1
	 FALSE),		/* pcrel_offset */
d982 1
a982 1
	 FALSE,			/* pc_relative */
d987 1
a987 1
	 FALSE,			/* partial_inplace */
d990 1
a990 1
	 FALSE),		/* pcrel_offset */
d997 1
a997 1
	 FALSE,			/* pc_relative */
d1002 1
a1002 1
	 FALSE,			/* partial_inplace */
d1005 1
a1005 1
	 FALSE),		/* pcrel_offset */
d1012 1
a1012 1
	 FALSE,			/* pc_relative */
d1017 1
a1017 1
	 FALSE,			/* partial_inplace */
d1020 1
a1020 1
	 FALSE),		/* pcrel_offset */
d1027 1
a1027 1
	 FALSE,			/* pc_relative */
d1032 1
a1032 1
	 FALSE,			/* partial_inplace */
d1035 1
a1035 1
	 FALSE),		/* pcrel_offset */
d1042 1
a1042 1
	 FALSE,			/* pc_relative */
d1047 1
a1047 1
	 FALSE,			/* partial_inplace */
d1050 1
a1050 1
	 FALSE),		/* pcrel_offset */
d1057 1
a1057 1
	 FALSE,			/* pc_relative */
d1062 1
a1062 1
	 FALSE,			/* partial_inplace */
d1065 1
a1065 1
	 FALSE),		/* pcrel_offset */
d1072 1
a1072 1
	 FALSE,			/* pc_relative */
d1077 1
a1077 1
	 FALSE,			/* partial_inplace */
d1080 1
a1080 1
	 FALSE),		/* pcrel_offset */
d1087 1
a1087 1
	 FALSE,			/* pc_relative */
d1092 1
a1092 1
	 FALSE,			/* partial_inplace */
d1095 1
a1095 1
	 FALSE),		/* pcrel_offset */
d1102 1
a1102 1
	 TRUE,			/* pc_relative */
d1107 1
a1107 1
	 FALSE,			/* partial_inplace */
d1110 1
a1110 1
	 TRUE),			/* pcrel_offset */
d1117 1
a1117 1
	 TRUE,			/* pc_relative */
d1122 1
a1122 1
	 FALSE,			/* partial_inplace */
d1125 1
a1125 1
	 TRUE),			/* pcrel_offset */
d1132 1
a1132 1
	 TRUE,			/* pc_relative */
d1137 1
a1137 1
	 FALSE,			/* partial_inplace */
d1140 1
a1140 1
	 TRUE),			/* pcrel_offset */
d1147 1
a1147 1
	 TRUE,			/* pc_relative */
d1152 1
a1152 1
	 FALSE,			/* partial_inplace */
d1155 1
a1155 1
	 TRUE),			/* pcrel_offset */
d1162 1
a1162 1
	 FALSE,			/* pc_relative */
d1167 1
a1167 1
	 FALSE,			/* partial_inplace */
d1170 1
a1170 1
	 FALSE),		/* pcrel_offset */
d1177 1
a1177 1
	 FALSE,			/* pc_relative */
d1182 1
a1182 1
	 FALSE,			/* partial_inplace */
d1185 1
a1185 1
	 FALSE),		/* pcrel_offset */
d1192 1
a1192 1
	 FALSE,			/* pc_relative */
d1197 1
a1197 1
	 FALSE,			/* partial_inplace */
d1200 1
a1200 1
	 FALSE),		/* pcrel_offset */
d1207 1
a1207 1
	 FALSE,			/* pc_relative */
d1212 1
a1212 1
	 FALSE,			/* partial_inplace */
d1215 1
a1215 1
	 FALSE),		/* pcrel_offset */
d1222 1
a1222 1
	 TRUE,			/* pc_relative */
d1227 1
a1227 1
	 FALSE,			/* partial_inplace */
d1230 1
a1230 1
	 TRUE),			/* pcrel_offset */
d1237 1
a1237 1
	 TRUE,			/* pc_relative */
d1242 1
a1242 1
	 FALSE,			/* partial_inplace */
d1245 1
a1245 1
	 TRUE),			/* pcrel_offset */
d1252 1
a1252 1
	 TRUE,			/* pc_relative */
d1257 1
a1257 1
	 FALSE,			/* partial_inplace */
d1260 1
a1260 1
	 TRUE),			/* pcrel_offset */
d1267 1
a1267 1
	 TRUE,			/* pc_relative */
d1272 1
a1272 1
	 FALSE,			/* partial_inplace */
d1275 1
a1275 1
	 TRUE),			/* pcrel_offset */
d1282 1
a1282 1
	 FALSE,			/* pc_relative */
d1287 1
a1287 1
	 FALSE,			/* partial_inplace */
d1290 1
a1290 1
	 FALSE),		/* pcrel_offset */
d1297 1
a1297 1
	 FALSE,			/* pc_relative */
d1302 1
a1302 1
	 FALSE,			/* partial_inplace */
d1305 1
a1305 1
	 FALSE),		/* pcrel_offset */
d1312 1
a1312 1
	 FALSE,			/* pc_relative */
d1317 1
a1317 1
	 FALSE,			/* partial_inplace */
d1320 1
a1320 1
	 FALSE),		/* pcrel_offset */
d1327 1
a1327 1
	 FALSE,			/* pc_relative */
d1332 1
a1332 1
	 FALSE,			/* partial_inplace */
d1335 1
a1335 1
	 FALSE),		/* pcrel_offset */
d1341 1
a1341 1
	 FALSE,			/* pc_relative */
d1346 1
a1346 1
	 FALSE,			/* partial_inplace */
d1349 1
a1349 1
	 FALSE),		/* pcrel_offset */
d1355 1
a1355 1
	 FALSE,			/* pc_relative */
d1360 1
a1360 1
	 FALSE,			/* partial_inplace */
d1363 1
a1363 1
	 FALSE),		/* pcrel_offset */
d1369 1
a1369 1
	 FALSE,			/* pc_relative */
d1374 1
a1374 1
	 FALSE,			/* partial_inplace */
d1377 1
a1377 1
	 FALSE),		/* pcrel_offset */
d1383 1
a1383 1
	 FALSE,			/* pc_relative */
d1388 1
a1388 1
	 FALSE,			/* partial_inplace */
d1391 1
a1391 1
	 FALSE),		/* pcrel_offset */
d1452 1
a1452 1
	 FALSE,			/* pc_relative */
d1457 1
a1457 1
	 FALSE,			/* partial_inplace */
d1460 1
a1460 1
	 FALSE),		/* pcrel_offset */
d1469 1
a1469 1
	 TRUE,			/* pc_relative */
d1474 1
a1474 1
	 FALSE,			/* partial_inplace */
d1477 1
a1477 1
	 TRUE),			/* pcrel_offset */
d1484 1
a1484 1
	 FALSE,			/* pc_relative */
d1489 1
a1489 1
	 FALSE,			/* partial_inplace */
d1492 1
a1492 1
	 FALSE),		/* pcrel_offset */
d1499 1
a1499 1
	 FALSE,			/* pc_relative */
d1504 1
a1504 1
	 FALSE,			/* partial_inplace */
d1507 1
a1507 1
	 FALSE),		/* pcrel_offset */
d1514 1
a1514 1
	 FALSE,			/* pc_relative */
d1519 1
a1519 1
	 FALSE,			/* partial_inplace */
d1522 1
a1522 1
	 FALSE),		/* pcrel_offset */
d1529 1
a1529 1
	 TRUE,			/* pc_relative */
d1534 1
a1534 1
	 FALSE,			/* partial_inplace */
d1537 1
a1537 1
	 TRUE),			/* pcrel_offset */
d1544 1
a1544 1
	 FALSE,			/* pc_relative */
d1549 1
a1549 1
	 FALSE,			/* partial_inplace */
d1552 1
a1552 1
	 FALSE),		/* pcrel_offset */
d1559 1
a1559 1
	 TRUE,			/* pc_relative */
d1564 1
a1564 1
	 FALSE,			/* partial_inplace */
d1567 1
a1567 1
	 TRUE),			/* pcrel_offset */
d1574 1
a1574 1
	 FALSE,			/* pc_relative */
d1579 1
a1579 1
	 FALSE,			/* partial_inplace */
d1582 1
a1582 1
	 FALSE),		/* pcrel_offset */
d1589 1
a1589 1
	 TRUE,			/* pc_relative */
d1594 1
a1594 1
	 FALSE,			/* partial_inplace */
d1597 1
a1597 1
	 TRUE),			/* pcrel_offset */
d1604 1
a1604 1
	 FALSE,			/* pc_relative */
d1609 1
a1609 1
	 FALSE,			/* partial_inplace */
d1612 1
a1612 1
	 FALSE),		/* pcrel_offset */
d1619 1
a1619 1
	 TRUE,			/* pc_relative */
d1624 1
a1624 1
	 FALSE,			/* partial_inplace */
d1627 1
a1627 1
	 TRUE),			/* pcrel_offset */
d1634 1
a1634 1
	 FALSE,			/* pc_relative */
d1639 1
a1639 1
	 FALSE,			/* partial_inplace */
d1642 1
a1642 1
	 FALSE),		/* pcrel_offset */
d1649 1
a1649 1
	 TRUE,			/* pc_relative */
d1654 1
a1654 1
	 FALSE,			/* partial_inplace */
d1657 1
a1657 1
	 TRUE),			/* pcrel_offset */
d2017 1
a2017 1
static bfd_boolean
d2022 1
a2022 1
     bfd_boolean *again;
d2026 1
a2026 1
  bfd_boolean have_code;
d2031 1
a2031 1
  *again = FALSE;
d2036 1
a2036 1
    return TRUE;
d2042 1
a2042 1
      return TRUE;
d2059 1
a2059 1
  have_code = FALSE;
d2070 1
a2070 1
	have_code = TRUE;
d2282 1
a2282 1
      *again = TRUE;
d2321 1
a2321 1
      bfd_boolean swapped;
d2380 1
a2380 1
  return TRUE;
d2393 1
a2393 1
  return FALSE;
d2400 1
a2400 1
static bfd_boolean
d2470 1
a2470 1
      bfd_boolean overflow;
d2622 1
a2622 1
	  overflow = FALSE;
d2633 1
a2633 1
		overflow = TRUE;
d2640 1
a2640 1
		overflow = TRUE;
d2654 1
a2654 1
		overflow = TRUE;
d2661 1
a2661 1
		overflow = TRUE;
d2668 1
a2668 1
		overflow = TRUE;
d2688 1
a2688 1
	      return FALSE;
d2710 1
a2710 1
	 FALSE, we should free them, if we are permitted to, when we
d2714 1
a2714 1
			  TRUE));
d2716 1
a2716 1
	return FALSE;
d2735 1
a2735 1
			 Perhaps, if info->keep_memory is FALSE, we
d2740 1
a2740 1
			return FALSE;
d2744 1
a2744 1
			return FALSE;
d2793 1
a2793 1
			 Perhaps, if info->keep_memory is FALSE, we
d2798 1
a2798 1
			return FALSE;
d2802 1
a2802 1
			return FALSE;
d2861 1
a2861 1
  return TRUE;
d2867 1
a2867 1
static bfd_boolean
d2873 1
a2873 1
     bfd_boolean *pswapped;
d2880 1
a2880 1
  *pswapped = FALSE;
d2931 1
a2931 1
  return TRUE;
d2936 1
a2936 1
  return FALSE;
d2941 1
a2941 1
static bfd_boolean
d3010 1
a3010 1
	  bfd_boolean overflow;
d3013 1
a3013 1
	  overflow = FALSE;
d3025 1
a3025 1
		overflow = TRUE;
d3034 1
a3034 1
		overflow = TRUE;
d3051 1
a3051 1
		    overflow = TRUE;
d3064 1
a3064 1
	      return FALSE;
d3069 1
a3069 1
  return TRUE;
d3528 2
a3529 2
  /* If TRUE, R_SH_TLS_TPOFF32 relocation is generated.  */
  bfd_boolean tls_tpoff32;
d3551 1
a3551 1
static bfd_boolean
d3558 2
a3559 2
    return FALSE;
  return TRUE;
d3561 1
a3561 1

d3593 1
a3593 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d3633 1
a3633 1
      ret->tls_tpoff32 = FALSE;
d3675 1
a3675 1
static bfd_boolean
d3683 1
a3683 1
    return FALSE;
d3701 2
a3702 2
    return FALSE;
  return TRUE;
d3707 1
a3707 1
static bfd_boolean
d3730 1
a3730 1
      return FALSE;
d3753 1
a3753 1
    return FALSE;
d3764 1
a3764 1
	      (bfd_vma) 0, (const char *) NULL, FALSE,
d3766 1
a3766 1
	return FALSE;
d3774 1
a3774 1
	return FALSE;
d3783 1
a3783 1
    return FALSE;
d3786 1
a3786 1
    return FALSE;
d3808 1
a3808 1
	  return FALSE;
d3824 1
a3824 1
	return FALSE;
d3846 1
a3846 1
	    return FALSE;
d3850 1
a3850 1
  return TRUE;
d3859 1
a3859 1
static bfd_boolean
d3906 1
a3906 1
      return TRUE;
d3920 1
a3920 1
      return TRUE;
d3931 1
a3931 1
    return TRUE;
d3936 1
a3936 1
    return TRUE;
d3942 1
a3942 1
      return TRUE;
d3959 1
a3959 1
      return TRUE;
d4001 1
a4001 1
	return FALSE;
d4011 1
a4011 1
  return TRUE;
d4028 1
a4028 1
static bfd_boolean
d4039 1
a4039 1
    return TRUE;
d4071 1
a4071 1
	    return FALSE;
d4122 1
a4122 1
      bfd_boolean dyn;
d4131 1
a4131 1
	    return FALSE;
d4158 1
a4158 1
      bfd_boolean dyn;
d4166 1
a4166 1
	    return FALSE;
d4181 1
a4181 1
    return TRUE;
d4230 1
a4230 1
		return FALSE;
d4251 1
a4251 1
  return TRUE;
d4256 1
a4256 1
static bfd_boolean
d4279 1
a4279 1
	  return FALSE;
d4282 1
a4282 1
  return TRUE;
d4287 1
a4287 1
static bfd_boolean
d4295 1
a4295 1
  bfd_boolean relocs;
d4403 1
a4403 1
  relocs = FALSE;
d4419 1
a4419 1
	    relocs = TRUE;
d4454 1
a4454 1
	return FALSE;
d4470 1
a4470 1
	    return FALSE;
d4479 1
a4479 1
	    return FALSE;
d4488 1
a4488 1
	    return FALSE;
d4499 1
a4499 1
		return FALSE;
d4505 1
a4505 1
  return TRUE;
d4510 1
a4510 1
static bfd_boolean
d4589 1
a4589 1
	  return FALSE;
d4671 1
a4671 1
		  return FALSE;
d4707 1
a4707 1
	      bfd_boolean dyn;
a4755 7
		  /* Dynamic relocs are not propagated for SEC_DEBUGGING
		     sections because such sections are not SEC_ALLOC and
		     thus ld.so will not process them.  */
		  || (sec->output_section == NULL
		      && ((input_section->flags & SEC_DEBUGGING) != 0
			  && (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d4766 1
a4766 1
		  return FALSE;
d4792 1
a4792 1
		return FALSE;
d4841 1
a4841 1
		  return FALSE;
d4856 1
a4856 1
	  return FALSE;
d4871 1
a4871 2
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;
d4886 1
a4886 1
		    return FALSE;
d4897 2
a4898 2
	      skip = FALSE;
	      relocate = FALSE;
d4904 1
a4904 1
		skip = TRUE;
d4906 1
a4906 1
		skip = TRUE, relocate = TRUE;
d4928 1
a4928 1
		      relocate = TRUE;
d4944 5
a4948 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d5011 1
a5011 1
	      bfd_boolean dyn;
a5101 1
		      bfd_byte *loc;
d5115 5
a5119 3
		      loc = srelgot->contents;
		      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
a5268 1
	      bfd_byte *loc;
d5274 1
a5274 1
		       jsr @@r1; add r12,r4; bra 3f; nop; .align 2;
d5354 1
a5354 1
		    return FALSE;
d5374 5
a5379 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d5402 1
a5402 1
	      bfd_byte *loc;
d5422 2
a5423 2
	      loc = srelgot->contents;
	      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
d5441 3
a5443 2
		      loc += sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d5574 1
a5574 1
	      bfd_byte *loc;
d5584 2
a5585 2
	      loc = srelgot->contents;
	      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
a5599 1
	      bfd_byte *loc;
d5610 1
a5610 1
		    return FALSE;
d5630 5
a5635 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
a5647 1
	    bfd_byte *loc;
d5658 1
a5658 1
		  return FALSE;
d5678 5
a5683 3
	    loc = sreloc->contents;
	    loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	    bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d5707 1
a5707 1
		      return FALSE;
d5714 1
a5714 1
		  return FALSE;
d5721 1
a5721 1
  return TRUE;
d5734 1
a5734 1
     bfd_boolean relocateable;
d5767 1
a5767 1
			  (Elf_Internal_Rela *) NULL, FALSE));
d5891 1
a5891 1
static bfd_boolean
d6079 1
a6079 1
  return TRUE;
d6179 1
a6179 1
static bfd_boolean
d6204 1
a6204 1
    return TRUE;
d6290 1
a6290 1
		return FALSE;
d6304 1
a6304 1
	    return FALSE;
d6311 1
a6311 1
	    return FALSE;
d6348 2
a6349 2
		  struct elf_sh_link_hash_entry *eh
		    = (struct elf_sh_link_hash_entry *) h;
d6380 1
a6380 1
		    return FALSE;
d6413 1
a6413 1
		  return FALSE;
d6542 1
a6542 1
		    return FALSE;
d6561 1
a6561 1
			return FALSE;
d6580 1
a6580 1
		    return FALSE;
d6592 1
a6592 1
		    return FALSE;
d6612 1
a6612 1
	      return FALSE;
d6639 1
a6639 1
		    return FALSE;
d6658 1
a6658 1
			return FALSE;
d6677 1
a6677 1
		    return FALSE;
d6689 1
a6689 1
		    return FALSE;
d6699 1
a6699 1
		sh_elf_hash_entry (h)->tls_tpoff32 = TRUE;
d6708 1
a6708 1
  return TRUE;
d6712 1
a6712 1
static bfd_boolean
d6743 1
a6743 1
      return FALSE;
d6745 1
a6745 1
  return TRUE;
d6752 1
a6752 1
static bfd_boolean
d6761 1
a6761 1
  elf_flags_init (abfd) = TRUE;
d6769 1
a6769 1
static bfd_boolean
d6776 1
a6776 1
    return TRUE;
d6786 1
a6786 1
static bfd_boolean
d6794 1
a6794 1
    return FALSE;
d6798 1
a6798 1
    return TRUE;
d6803 1
a6803 1
      elf_flags_init (obfd) = TRUE;
d6817 1
a6817 1
      return FALSE;
d6829 1
a6829 1
static bfd_boolean
d6836 2
a6837 2
  if (!sh_elf_set_mach_from_flags (abfd))
    return FALSE;
d6842 1
a6842 1
    return FALSE;
d6845 1
a6845 1
  return TRUE;
d6851 1
a6851 1
static bfd_boolean
a6872 1
      bfd_byte *loc;
d6992 3
a6994 2
      loc = srel->contents + plt_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
a7010 1
      bfd_byte *loc;
d7046 4
a7049 3
      loc = srel->contents;
      loc += srel->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
a7061 1
	bfd_byte *loc;
d7098 4
a7101 3
	loc = srel->contents;
	loc += srel->reloc_count++ * sizeof (Elf32_External_Rela);
	bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
a7109 1
      bfd_byte *loc;
d7126 4
a7129 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
d7137 1
a7137 1
  return TRUE;
d7142 1
a7142 1
static bfd_boolean
d7195 1
a7195 1
					    FALSE, FALSE, TRUE);
d7311 1
a7311 1
  return TRUE;
d7332 1
a7332 1
static bfd_boolean
d7343 1
a7343 1
	return FALSE;
d7364 1
a7364 1
static bfd_boolean
d7372 1
a7372 1
	return FALSE;
d7393 1
a7393 1
  return TRUE;
@


1.58.8.5
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d65 1
a65 1
  PARAMS ((bfd *));
d67 1
a67 1
  PARAMS ((bfd *));
d88 1
a88 1
  PARAMS ((bfd *, struct bfd_link_info *));
a6726 3
    case EF_SH2E:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh2e);
      break;
d7331 1
a7331 1
/* Support for Linux core dump NOTE sections.  */
d7465 1
a7465 1
#undef	elf32_bed
d7470 1
d7486 1
a7486 1
#undef	elf32_bed
d7490 4
@


1.58.8.6
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@a181 2
  /* This cannot be partial_inplace because relaxation can't know the
     eventual value of a symbol.  */
d189 1
a189 1
	 NULL,			/* special_function */
d191 2
a192 2
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
a2234 6
      /* We used to test (ELF32_R_SYM (irelfn->r_info) < symtab_hdr->sh_info)
	 here, but that only checks if the symbol is an external symbol,
	 not if the symbol is in a different section.  Besides, we need
	 a consistent meaning for the relocation, so we just assume here that
	 the value of the symbol is not available.  */
#if 0
a2244 1
#endif
a2250 1
      irel->r_addend = -4;
d2319 1
a2319 2
  if ((elf_elfheader (abfd)->e_flags & EF_SH_MACH_MASK) != EF_SH4
      && have_code)
d2545 2
a2546 8
	  off = insn & 0xfff;
	  if (! off)
	    {
	      /* This has been made by previous relaxation.  Since the
		 relocation will be against an external symbol, the
		 final relocation will just do the right thing.  */
	      start = stop = addr;
	    }
d2549 1
a2552 9

	      /* The addend will be against the section symbol, thus
		 for adjusting the addend, the relevant start is the
		 start of the section.
		 N.B. If we want to abandom in-place changes here and
		 test directly using symbol + addend, we have to take into
		 account that the addend has already been adjusted by -4.  */
	      if (stop > addr && stop < toaddr)
		irel->r_addend -= count;
a3502 3

  /* If TRUE, R_SH_TLS_TPOFF32 relocation is generated.  */
  bfd_boolean tls_tpoff32;
d3527 3
d3633 1
d4056 1
a4056 1
	 so treat all the gotplt refs as got refs. */
d4210 2
a4211 3
      for (p = eh->dyn_relocs; p; p = p->next)
	if (p->tls_tpoff32)
	  goto keep;
d4788 1
d4815 1
d5259 4
a5262 12
		      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
		{
		  struct elf_sh_dyn_relocs *p;

		  /* If TPOFF32 relocation can be created, convert it.  */
		  for (p = sh_elf_hash_entry (h)->dyn_relocs; p; p = p->next)
		    if (p->sec == input_section && p->tls_tpoff32)
		      {
			r_type = R_SH_TLS_LE_32;
			break;
		      }
		}
d5371 1
a5371 7
	      if (h == NULL
		  || h->dynindx == -1
		  || (! info->shared
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
		indx = 0;
	      else
		indx = h->dynindx;
d5403 1
a5403 1
	  else
d5418 1
a5418 7
	      if (h == NULL
		  || h->dynindx == -1
		  || (! info->shared
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
		indx = 0;
	      else
		indx = h->dynindx;
d5903 3
a5915 3
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;
d5921 3
a5923 1
      if (r_symndx >= symtab_hdr->sh_info)
a5924 4
	  struct elf_sh_link_hash_entry *eh;
	  struct elf_sh_dyn_relocs **pp;
	  struct elf_sh_dyn_relocs *p;

a5933 8
	  eh = (struct elf_sh_link_hash_entry *) h;
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
d5935 1
d5937 3
a5939 2
      r_type = ELF32_R_TYPE (rel->r_info);
      switch (sh_elf_optimized_tls_reloc (info, r_type, h != NULL))
a5971 2
		  struct elf_sh_link_hash_entry *eh;
		  eh = (struct elf_sh_link_hash_entry *) h;
d5997 21
a6017 3
	  if (info->shared)
	    break;
	  /* Fall thru */
a6043 2
	      struct elf_sh_link_hash_entry *eh;
	      eh = (struct elf_sh_link_hash_entry *) h;
a6598 1
		  p->tls_tpoff32 = FALSE;
a6695 1
		  p->tls_tpoff32 = FALSE;
d6699 2
a6700 1
	      p->tls_tpoff32 = TRUE;
@


1.58.8.7
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1 1
a1 1
/* Renesas SH specific support for 32-bit ELF
@


1.58.8.8
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d1 1
a1 1
/* Renesas / SuperH SH specific support for 32-bit ELF
a92 2
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
d3528 3
d4042 1
a4042 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d4044 1
a4044 1
   && ((SHARED)								\
d4098 1
a4098 2
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d4165 1
a4165 1
      /* R_SH_TLS_IE_32 needs one dynamic relocation if dynamic,
d4168 1
a4168 1
	  || (tls_type == GOT_TLS_IE && dyn))
d4172 1
a4172 2
      else if (info->shared ||
	       WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
d4197 1
a4197 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h))
d4234 4
d4755 1
a4755 1
		      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d5055 1
a5055 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d5283 11
a5293 1
		r_type = R_SH_TLS_LE_32;
d5303 3
d5382 39
a5420 2
	      bfd_put_32 (output_bfd, tpoff (info, relocation),
			  contents + rel->r_offset);
a5437 12
	  /* Relocate R_SH_TLS_IE_32 directly when statically linking.  */
	  if (r_type == R_SH_TLS_IE_32
	      && ! htab->root.dynamic_sections_created)
	    {
	      off &= ~1;
	      bfd_put_32 (output_bfd, tpoff (info, relocation),
			  sgot->contents + off);
	      bfd_put_32 (output_bfd, sgot->output_offset + off,
			  contents + rel->r_offset);
	      continue;
	    }

d5455 4
a5458 1
	      if (h == NULL || h->dynindx == -1)
a5461 1

d5643 40
a5682 1
	    relocation = tpoff (info, relocation);
a5694 7
	    if (! info->shared)
	      {
		relocation = tpoff (info, relocation);
		addend = rel->r_addend;
		goto final_link_relocate;
	      }

d5715 1
a5715 5
	    if (h == NULL || h->dynindx == -1)
	      indx = 0;
	    else
	      indx = h->dynindx;

d5885 3
a5887 3
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
    return 0;
a5890 15
/* Return the relocation value for R_SH_TLS_TPOFF32..  */

static bfd_vma
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
{
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
    return 0;
  /* SH TLS ABI is variant I and static TLS block start just after tcbhead
     structure which has 2 pointer fields.  */
  return (address - dtpoff_base (info) + 8);
}

d6352 1
a6357 1
	force_got:
d6636 1
d6654 2
a6655 1
	  break;
d6657 1
d6659 81
a6739 1
	  /* Nothing to do.  */
@


1.58.8.9
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d2057 1
a2057 1
  internal_relocs = (_bfd_elf_link_read_relocs
d2739 1
a2739 1
      internal_relocs = (_bfd_elf_link_read_relocs
a3942 4
      if (info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d4086 1
a4086 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d4172 2
a4173 4
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
a4231 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
a4887 3
	      && (h == NULL
		  || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		  || h->root.type != bfd_link_hash_undefweak)
d5056 1
a5056 3
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
d5738 1
a5738 1
      internal_relocs = (_bfd_elf_link_read_relocs
d6131 1
a6131 11
  if (ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.58.8.10
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2037 1
a2037 1
  if (link_info->relocatable
d4341 1
a4341 1
      if (info->executable)
d4503 1
a4503 1
      if (info->executable)
d4653 1
a4653 1
	  if (info->relocatable)
d4655 1
a4655 1
	      /* This is a relocatable link.  We don't have to change
d4724 2
a4725 2
	     relocatable object file.  */
	  if (info->relocatable)
d5721 1
a5721 1
				       data, relocatable, symbols)
d5726 1
a5726 1
     bfd_boolean relocatable;
d5738 1
a5738 1
  if (relocatable
d5742 1
a5742 1
						       relocatable,
d6214 1
a6214 1
  if (info->relocatable)
@


1.58.8.11
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d30 1
a30 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d32 1
a32 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d34 1
a34 1
  (bfd *, bfd_reloc_code_real_type);
d36 1
a36 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d38 1
a38 1
  (bfd *, flagword);
d40 1
a40 1
  (bfd *, bfd *);
d42 1
a42 1
  (bfd *, bfd *);
d44 1
a44 1
  (bfd *);
d46 1
a46 1
  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
d48 1
a48 1
  (bfd *, asection *, bfd_vma, int);
d50 1
a50 1
  (bfd *, asection *, Elf_Internal_Rela *, bfd_byte *, bfd_boolean *);
d52 1
a52 1
  (bfd *, asection *, void *, bfd_byte *, bfd_vma);
d54 2
a55 2
  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
d57 2
a58 2
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);
d60 2
a61 2
  (struct elf_backend_data *, struct elf_link_hash_entry *,
   struct elf_link_hash_entry *);
d63 1
a63 1
  (struct bfd_link_info *, int, int);
d65 1
a65 1
  (bfd *);
d67 1
a67 1
  (bfd *);
d69 2
a70 1
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
d72 1
a72 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d74 1
a74 1
  (bfd *);
d76 1
a76 1
  (struct bfd_link_info *, struct elf_link_hash_entry *);
d78 1
a78 1
  (bfd *, struct bfd_link_info *);
d80 2
a81 2
  (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
   Elf_Internal_Sym *);
d83 1
a83 1
  (bfd *, struct bfd_link_info *);
d85 2
a86 2
  (int, bfd *, asection *, bfd_byte *, bfd_vma, asection *, bfd_vma,
   bfd_vma);
d88 1
a88 1
  (bfd *, struct bfd_link_info *);
d90 1
a90 1
  (bfd *, struct bfd_link_info *);
d92 1
a92 1
  (struct bfd_link_info *);
d94 1
a94 1
  (struct bfd_link_info *, bfd_vma);
d96 2
a97 2
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);
d99 2
a100 1
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
d102 1
a102 1
  (struct elf_link_hash_entry *, void *);
d104 1
a104 1
  (struct elf_link_hash_entry *, void *);
d106 1
a106 1
  (const Elf_Internal_Rela *);
d108 1
a108 1
inline static void movi_shori_putval (bfd *, unsigned long, char *);
d111 1
a111 1
  (bfd *abfd, Elf_Internal_Note *note);
d113 1
a113 1
  (bfd *abfd, Elf_Internal_Note *note);
d1667 9
a1675 4
sh_elf_reloc_loop (int r_type ATTRIBUTE_UNUSED, bfd *input_bfd,
		   asection *input_section, bfd_byte *contents,
		   bfd_vma addr, asection *symbol_section,
		   bfd_vma start, bfd_vma end)
d1777 9
a1785 3
sh_elf_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol_in,
	      void *data, asection *input_section, bfd *output_bfd,
	      char **error_message ATTRIBUTE_UNUSED)
d1852 9
a1860 5
sh_elf_ignore_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		     asymbol *symbol ATTRIBUTE_UNUSED,
		     void *data ATTRIBUTE_UNUSED, asection *input_section,
		     bfd *output_bfd,
		     char **error_message ATTRIBUTE_UNUSED)
d1974 3
a1976 2
sh_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			  bfd_reloc_code_real_type code)
d1992 4
a1995 2
sh_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
		      Elf_Internal_Rela *dst)
d2022 5
a2026 2
sh_elf_relax_section (bfd *abfd, asection *sec,
		      struct bfd_link_info *link_info, bfd_boolean *again)
d2058 1
a2058 1
		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
d2414 5
a2418 2
sh_elf_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr,
			   int count)
d2740 2
a2741 1
			 (abfd, o, NULL, (Elf_Internal_Rela *) NULL, TRUE));
d2895 6
a2900 4
sh_elf_align_loads (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
		    Elf_Internal_Rela *internal_relocs,
		    bfd_byte *contents ATTRIBUTE_UNUSED,
		    bfd_boolean *pswapped)
d2951 1
a2951 1
				     internal_relocs, &label,
d2969 6
a2974 2
sh_elf_swap_insns (bfd *abfd, asection *sec, void *relocs,
		   bfd_byte *contents, bfd_vma addr)
d3255 4
a3258 1
movi_shori_putval (bfd *output_bfd, unsigned long value, char *addr)
d3576 2
a3577 1
sh_elf_mkobject (bfd *abfd)
d3617 1
a3617 1
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func), \
d3628 4
a3631 3
sh_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			  struct bfd_hash_table *table,
			  const char *string)
d3665 2
a3666 1
sh_elf_link_hash_table_create (bfd *abfd)
d3699 3
a3701 1
create_got_section (bfd *dynobj, struct bfd_link_info *info)
d3731 3
a3733 1
sh_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
a3756 2
  if (htab->root.dynamic_sections_created)
    return TRUE;
d3808 1
a3808 2
  if (htab->sgot == NULL
      && !create_got_section (abfd, info))
a3826 2
	if (bfd_get_section_by_name (abfd, secname))
	  continue;
d3883 3
a3885 2
sh_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
			      struct elf_link_hash_entry *h)
d3890 1
d3894 1
a3894 1
  htab = sh_elf_hash_table (info);
d3897 1
a3897 1
  BFD_ASSERT (htab->root.dynobj != NULL
d3914 5
a3918 3
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d3999 1
d4025 1
a4025 1
  if (power_of_two > bfd_get_section_alignment (htab->root.dynobj, s))
d4027 1
a4027 1
      if (! bfd_set_section_alignment (htab->root.dynobj, s, power_of_two))
d4056 3
a4058 1
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d4224 3
a4226 1
      if (SYMBOL_CALLS_LOCAL (info, h))
d4293 3
a4295 1
readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d4324 3
a4326 2
sh_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
			      struct bfd_link_info *info)
d4435 1
a4435 1
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, info);
d4529 2
a4530 1
	    elf_link_hash_traverse (&htab->root, readonly_dynrelocs, info);
d4547 10
a4556 5
sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
			 bfd *input_bfd, asection *input_section,
			 bfd_byte *contents, Elf_Internal_Rela *relocs,
			 Elf_Internal_Sym *local_syms,
			 asection **local_sections)
d4908 5
a4912 1
		  || !SYMBOL_CALLS_LOCAL (info, h)))
d5071 3
a5073 1
		      && SYMBOL_REFERENCES_LOCAL (info, h))
d5720 8
a5727 6
sh_elf_get_relocated_section_contents (bfd *output_bfd,
				       struct bfd_link_info *link_info,
				       struct bfd_link_order *link_order,
				       bfd_byte *data,
				       bfd_boolean relocatable,
				       asymbol **symbols)
d5758 1
a5758 1
			 (input_bfd, input_section, NULL,
d5830 2
a5831 1
dtpoff_base (struct bfd_link_info *info)
d5842 3
a5844 1
tpoff (struct bfd_link_info *info, bfd_vma address)
d5855 6
a5860 4
sh_elf_gc_mark_hook (asection *sec,
		     struct bfd_link_info *info ATTRIBUTE_UNUSED,
		     Elf_Internal_Rela *rel, struct elf_link_hash_entry *h,
		     Elf_Internal_Sym *sym)
d5899 5
a5903 2
sh_elf_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
		      asection *sec, const Elf_Internal_Rela *relocs)
d6086 3
a6088 3
sh_elf_copy_indirect_symbol (struct elf_backend_data *bed,
			     struct elf_link_hash_entry *dir,
			     struct elf_link_hash_entry *ind)
d6164 4
a6167 2
sh_elf_optimized_tls_reloc (struct bfd_link_info *info, int r_type,
			    int is_local)
d6191 5
a6195 2
sh_elf_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
		     const Elf_Internal_Rela *relocs)
d6202 1
d6224 1
d6298 4
a6301 7
	      if (htab->sgot == NULL)
		{
		  if (htab->root.dynobj == NULL)
		    htab->root.dynobj = abfd;
		  if (!create_got_section (htab->root.dynobj, info))
		    return FALSE;
		}
d6538 2
a6539 2
	      if (htab->root.dynobj == NULL)
		htab->root.dynobj = abfd;
d6559 1
a6559 1
		  sreloc = bfd_get_section_by_name (htab->root.dynobj, name);
d6564 1
a6564 1
		      sreloc = bfd_make_section (htab->root.dynobj, name);
d6570 2
a6571 4
			  || ! bfd_set_section_flags (htab->root.dynobj,
						      sreloc, flags)
			  || ! bfd_set_section_alignment (htab->root.dynobj,
							  sreloc, 2))
d6574 2
d6601 1
a6601 1
		  p = bfd_alloc (htab->root.dynobj, amt);
d6642 2
a6643 1
sh_elf_set_mach_from_flags (bfd *abfd)
d6685 3
a6687 1
sh_elf_set_private_flags (bfd *abfd, flagword flags)
d6702 3
a6704 1
sh_elf_copy_private_data (bfd * ibfd, bfd * obfd)
d6719 3
a6721 1
sh_elf_merge_private_data (bfd *ibfd, bfd *obfd)
d6762 2
a6763 1
sh_elf_object_p (bfd *abfd)
d6784 5
a6788 3
sh_elf_finish_dynamic_symbol (bfd *output_bfd, struct bfd_link_info *info,
			      struct elf_link_hash_entry *h,
			      Elf_Internal_Sym *sym)
d6791 1
d6794 1
d6962 4
a6965 1
	  && SYMBOL_REFERENCES_LOCAL (info, h))
d7013 4
a7016 1
	    && SYMBOL_REFERENCES_LOCAL (info, h))
d7074 3
a7076 1
sh_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
d7079 1
d7084 2
d7087 1
a7087 1
  sdyn = bfd_get_section_by_name (htab->root.dynobj, ".dynamic");
d7106 1
a7106 1
	  bfd_elf32_swap_dyn_in (htab->root.dynobj, dyncon, &dyn);
d7246 2
a7247 1
sh_elf_reloc_type_class (const Elf_Internal_Rela *rela)
d7264 3
a7266 1
elf32_shlin_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d7296 3
a7298 1
elf32_shlin_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d7333 1
a7333 5
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE		0x1000
#else
#define ELF_MAXPAGESIZE		0x80
#endif
@


1.58.8.12
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d60 1
a60 1
  (const struct elf_backend_data *, struct elf_link_hash_entry *,
d3695 1
a3695 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
a4665 2
	  /* FIXME: Ought to make use of the RELOC_FOR_GLOBAL_SYMBOL macro.  */

d4767 2
a4768 2
	  else if (! info->executable
		   && info->unresolved_syms_in_objects == RM_IGNORE
d4773 5
a4777 6
	      if (! info->callbacks->undefined_symbol
		  (info, h->root.root.string, input_bfd,
		   input_section, rel->r_offset,
		   ((info->shared && info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)
		    || (!info->shared && info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
		    || ELF_ST_VISIBILITY (h->other))))
d6014 1
a6014 1
sh_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
@


1.58.8.13
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d279 2
a280 30
  /* 8 bit PC relative divided by 2 - but specified in a very odd way.  */
  HOWTO (R_SH_LOOP_START,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_LOOP_START",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 8 bit PC relative divided by 2 - but specified in a very odd way.  */
  HOWTO (R_SH_LOOP_END,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_LOOP_END",	/* name */
	 TRUE,			/* partial_inplace */
	 0xff,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

d291 3
a299 47
  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_SH_GNU_VTINHERIT, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_SH_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_SH_GNU_VTENTRY,     /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn,	/* special_function */
	 "R_SH_GNU_VTENTRY",   /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An 8 bit switch table entry.  This is generated for an expression
     such as ``.word L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_SH_SWITCH8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf_ignore_reloc,	/* special_function */
	 "R_SH_SWITCH8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

d437 4
a440 16
  /* The next 12 are only supported via linking in SHC-generated objects.  */
  HOWTO (R_SH_DIR16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR8,		/* type */
a445 14
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR8UL,		/* type */
	 2,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
d447 2
a448 2
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8UL",		/* name */
d451 2
a452 2
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d454 5
a458 4
  HOWTO (R_SH_DIR8UW,		/* type */
	 1,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
d461 3
a463 3
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8UW",		/* name */
d466 1
a466 1
	 0xff,			/* dst_mask */
d469 2
a470 1
  HOWTO (R_SH_DIR8U,		/* type */
d472 2
a473 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
d476 3
a478 3
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8U",		/* name */
d481 1
a481 1
	 0xff,			/* dst_mask */
d484 2
a485 1
  HOWTO (R_SH_DIR8SW,		/* type */
d487 1
a487 1
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
d492 4
a495 4
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8SW",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
d497 1
a497 1
	 FALSE),		/* pcrel_offset */
d499 4
a502 3
  HOWTO (R_SH_DIR8S,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
d507 4
a510 4
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR8S",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
d512 1
a512 29
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR4UL,		/* type */
	 2,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 4,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR4UL",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_DIR4UW,		/* type */
	 1,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 4,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR4UW",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d514 7
a520 41
  HOWTO (R_SH_DIR4U,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 4,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR4U",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_PSHA,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 FALSE,			/* pc_relative */
	 4,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PSHA",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_SH_PSHL,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 FALSE,			/* pc_relative */
	 4,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PSHL",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0f,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d639 1
a639 15

  HOWTO (R_SH_DIR16S,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR16S",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

a1863 2
  { BFD_RELOC_16, R_SH_DIR16 },
  { BFD_RELOC_8, R_SH_DIR8 },
d4549 2
a4550 2
      if (r_type >= (int) R_SH_GNU_VTINHERIT
	  && r_type <= (int) R_SH_LABEL)
d4636 1
a4636 1
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
a4845 64
	case R_SH_DIR16:
	case R_SH_DIR8:
	case R_SH_DIR8U:
	case R_SH_DIR8S:
	case R_SH_DIR4U:
	  goto final_link_relocate;

	case R_SH_DIR8UL:
	case R_SH_DIR4UL:
	  if (relocation & 3)
	    {
	      ((*_bfd_error_handler)
	       (_("%s: 0x%lx: fatal: unaligned %s relocation 0x%lx"),
		bfd_archive_filename (input_section->owner),
		(unsigned long) rel->r_offset, howto->name, 
		(unsigned long)relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;

	case R_SH_DIR8UW:
	case R_SH_DIR8SW:
	case R_SH_DIR4UW:
	  if (relocation & 1)
	    {
	      ((*_bfd_error_handler)
	       (_("%s: 0x%lx: fatal: unaligned %s relocation 0x%lx"),
		bfd_archive_filename (input_section->owner),
		(unsigned long) rel->r_offset, howto->name, 
		(unsigned long)relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;

	case R_SH_PSHA:
	  if ((signed int)relocation < -32
	      || (signed int)relocation > 32)
	    {
	      ((*_bfd_error_handler)
	       (_("%s: 0x%lx: fatal: R_SH_PSHA relocation %d not in range -32..32"),
		bfd_archive_filename (input_section->owner),
		(unsigned long) rel->r_offset,
		(unsigned long)relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;

	case R_SH_PSHL:
	  if ((signed int)relocation < -16
	      || (signed int)relocation > 16)
	    {
	      ((*_bfd_error_handler)
	       (_("%s: 0x%lx: fatal: R_SH_PSHL relocation %d not in range -32..32"),
		bfd_archive_filename (input_section->owner),
		(unsigned long) rel->r_offset,
		(unsigned long)relocation));
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  goto final_link_relocate;

a4847 6
#ifdef INCLUDE_SHMEDIA
	case R_SH_IMM_LOW16_PCREL:
	case R_SH_IMM_MEDLOW16_PCREL:
	case R_SH_IMM_MEDHI16_PCREL:
	case R_SH_IMM_HI16_PCREL:
#endif
d4854 1
a4854 1
	      && (r_type == R_SH_DIR32
a4906 11
#ifdef INCLUDE_SHMEDIA
	      else if (r_type == R_SH_IMM_LOW16_PCREL
		       || r_type == R_SH_IMM_MEDLOW16_PCREL
		       || r_type == R_SH_IMM_MEDHI16_PCREL
		       || r_type == R_SH_IMM_HI16_PCREL)
		{
		  BFD_ASSERT (h != NULL && h->dynindx != -1);
		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
		  outrel.r_addend = addend;
		}
#endif
d5771 2
a5772 2
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
d5774 1
a5774 1
  return elf_hash_table (info)->tls_sec->vma;
d5782 2
a5783 2
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
d5787 1
a5787 1
  return address - elf_hash_table (info)->tls_sec->vma + 8;
a6421 6
#ifdef INCLUDE_SHMEDIA
	case R_SH_IMM_LOW16_PCREL:
	case R_SH_IMM_MEDLOW16_PCREL:
	case R_SH_IMM_MEDHI16_PCREL:
	case R_SH_IMM_HI16_PCREL:
#endif
d6539 1
a6539 8
	      if (r_type == R_SH_REL32
#ifdef INCLUDE_SHMEDIA
		  || r_type == R_SH_IMM_LOW16_PCREL
		  || r_type == R_SH_IMM_MEDLOW16_PCREL
		  || r_type == R_SH_IMM_MEDHI16_PCREL
		  || r_type == R_SH_IMM_HI16_PCREL
#endif
		  )
a6599 12
    case EF_SH4_NOFPU:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4_nofpu);
      break;
    case EF_SH4A:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4a);
      break;
    case EF_SH4A_NOFPU:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4a_nofpu);
      break;
    case EF_SH4AL_DSP:
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh4al_dsp);
      break;
d7280 1
@


1.58.8.14
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d460 1
a460 1
     instructions.  A section should be processed as assuming it
d2721 1
a2721 1
		 N.B. If we want to abandon in-place changes here and
d3415 1
a3415 1
   GCC to return the address of large structures, so it should not be
d3638 1
a3638 1
/* Return offset of the temporary in PLT entry */
d6342 1
a6342 2
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
d6962 13
a6974 1
  return sh_elf_set_mach_from_flags (abfd);
@


1.57
log
@	* elf32-sh.c (elf_sh_plt0_entry_be, elf_sh_plt0_entry_le): Copy
	contents of .got.plt[2] to tr0, not address of .got.plt.
	(sh_elf_finish_dynamic_symbol): Do not apply GOT_BIAS when
	patching absolute plt entry. For shmedia plt entry, set bottom bit
	of branch to plt0 as this is a branch to an shmedia instruction.
	* elf64-sh64.c (elf_sh64_plt0_entry_be, elf_sh64_plt0_entry_le):
	Copy contents of .got.plt[2] to tr0, not address of .got.plt.
	(elf_sh64_plt_entry_be, elf_sh64_plt_entry_le): Use ptrel to
	branch to plt0.
	(sh64_elf64_finish_dynamic_symbol): Do not apply GOT_BIAS when
	patching absolute plt entry. For shmedia plt entry, branch to
	plt0 is now ptrel, so use relative offset.  Set bottom bit of
	branch target as it is a branch to an shmedia instruction.
@
text
@d59 3
d81 2
d91 4
d442 12
a453 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         false,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_SH_GNU_VTINHERIT", /* name */
         false,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         false),                /* pcrel_offset */
d457 12
a468 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         false,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_SH_GNU_VTENTRY",   /* name */
         false,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         false),                /* pcrel_offset */
d522 1
a522 1
	 false),	       	/* pcrel_offset */
d537 1
a537 1
	 false),	       	/* pcrel_offset */
d552 1
a552 1
	 false),	       	/* pcrel_offset */
d567 1
a567 1
	 false),	       	/* pcrel_offset */
d569 1
a569 1
  /* Used in LD.UW, ST.W et al.  */
d582 1
a582 1
	 false),	       	/* pcrel_offset */
d584 1
a584 1
  /* Used in LD.L, FLD.S et al.  */
d597 1
a597 1
	 false),	       	/* pcrel_offset */
d612 1
a612 1
	 false),	       	/* pcrel_offset */
d869 1
a869 1
	 "R_SH_GOT_LOW16",    	/* name */
d873 1
a873 1
	 false),	       	/* pcrel_offset */
d888 1
a888 1
	 false),	       	/* pcrel_offset */
d903 1
a903 1
	 false),	       	/* pcrel_offset */
d918 1
a918 1
	 false),	       	/* pcrel_offset */
d929 1
a929 1
	 "R_SH_GOTPLT_LOW16",   /* name */
d933 1
a933 1
	 false),	       	/* pcrel_offset */
d948 1
a948 1
	 false),	       	/* pcrel_offset */
d963 1
a963 1
	 false),	       	/* pcrel_offset */
d978 1
a978 1
	 false),	       	/* pcrel_offset */
d989 1
a989 1
	 "R_SH_PLT_LOW16",    	/* name */
d993 1
a993 1
	 true),		       	/* pcrel_offset */
d1008 1
a1008 1
	 true),		       	/* pcrel_offset */
d1023 1
a1023 1
	 true),		       	/* pcrel_offset */
d1038 1
a1038 1
	 true),		       	/* pcrel_offset */
d1049 1
a1049 1
	 "R_SH_GOTOFF_LOW16",   /* name */
d1053 1
a1053 1
	 false),	       	/* pcrel_offset */
d1068 1
a1068 1
	 false),	       	/* pcrel_offset */
d1083 1
a1083 1
	 false),	       	/* pcrel_offset */
d1098 1
a1098 1
	 false),	       	/* pcrel_offset */
d1109 1
a1109 1
	 "R_SH_GOTPC_LOW16",    /* name */
d1113 1
a1113 1
	 true),		       	/* pcrel_offset */
d1128 1
a1128 1
	 true),		       	/* pcrel_offset */
d1143 1
a1143 1
	 true),		       	/* pcrel_offset */
d1158 1
a1158 1
	 true),		       	/* pcrel_offset */
d1160 1
a1160 1
  /* Used in LD.L, FLD.S et al.  */
d1173 1
a1173 1
	 false),	       	/* pcrel_offset */
d1175 1
a1175 1
  /* Used in LD.L, FLD.S et al.  */
d1188 1
a1188 1
	 false),	       	/* pcrel_offset */
d1203 1
a1203 1
	 false),	       	/* pcrel_offset */
d1218 1
a1218 1
	 false),	       	/* pcrel_offset */
d1228 1
a1228 1
	 "R_SH_COPY64", 	/* name */
d1232 1
a1232 1
	 false),	       	/* pcrel_offset */
d1242 1
a1242 1
	 "R_SH_GLOB_DAT64", 	/* name */
d1246 1
a1246 1
	 false),	       	/* pcrel_offset */
d1256 1
a1256 1
	 "R_SH_JMP_SLOT64", 	/* name */
d1260 1
a1260 1
	 false),	       	/* pcrel_offset */
d1270 1
a1270 1
	 "R_SH_RELATIVE64", 	/* name */
d1274 1
a1274 1
	 false),	       	/* pcrel_offset */
d1375 1
a1375 1
	 false),	       	/* pcrel_offset */
d1390 1
a1390 1
	 false),	       	/* pcrel_offset */
d1401 1
a1401 1
	 "R_SH_IMM_LOW16",    	/* name */
d1405 1
a1405 1
	 false),	       	/* pcrel_offset */
d1435 1
a1435 1
	 false),	       	/* pcrel_offset */
d1465 1
a1465 1
	 false),	       	/* pcrel_offset */
d1495 1
a1495 1
	 false),	       	/* pcrel_offset */
d1521 1
a1521 1
	 "R_SH_64", 		/* name */
d1525 1
a1525 1
	 false),	       	/* pcrel_offset */
d1967 3
a1969 3
         the register load.  The 4 is because the r_addend field is
         computed as though it were a jump offset, which are based
         from 4 bytes after the jump instruction.  */
d1981 1
a1981 1
         do.  */
d2008 2
a2009 2
         being loaded.  This reloc will tell us which function is
         actually being called.  */
d2066 2
a2067 2
                 symbol.  Just ignore it--it will be caught by the
                 regular reloc processing.  */
d2107 1
a2107 1
         replace the jsr with a bsr.  */
d2112 2
a2113 2
             it will be handled here like other internal IND12W
             relocs.  */
d2121 2
a2122 2
             symbol value may be changed by future relaxing.  We let
             the final link phase handle it.  */
d2127 1
a2127 1
         register load.  */
d2142 2
a2143 2
         function address is stored.  Do this before deleting any
         bytes, to avoid confusion about the address.  */
d2154 2
a2155 2
         other function call to come within range, we should relax
         again.  Note that this is not required, and it may be slow.  */
d2168 1
a2168 1
         just deleted one.  */
d2180 2
a2181 2
         the address from irelfn, in case it was changed by the
         previous call to sh_elf_relax_delete_bytes.  */
d2367 1
a2367 1
         includes the bytes we have deleted.  */
d2390 3
a2392 3
             section, and the symbol will not be adjusted below, we
             must check the addend to see it will put the value in
             range to be adjusted, and hence must be changed.  */
d2584 2
a2585 2
         false, we should free them, if we are permitted to, when we
         leave sh_coff_relax_section.  */
d2609 3
a2611 3
                         Perhaps, if info->keep_memory is false, we
                         should free them, if we are permitted to,
                         when we leave sh_coff_relax_section.  */
d2667 3
a2669 3
                         Perhaps, if info->keep_memory is false, we
                         should free them, if we are permitted to,
                         when we leave sh_coff_relax_section.  */
d2841 2
a2842 2
         adjust.  These relocs do not apply to the instruction itself,
         but are only associated with the address.  */
d2851 5
a2855 5
         swapped, we must adjust it.  It would be incorrect to do this
         for a jump, though, since we want to execute both
         instructions after the jump.  (We have avoided swapping
         around a label, so the jump will not wind up executing an
         instruction it shouldn't).  */
d2914 5
a2918 5
                 the program counter before adding in the offset.
                 This means that if ADDR is at an even address, the
                 swap will not affect the offset.  If ADDR is an at an
                 odd address, then the instruction will be crossing a
                 four byte boundary, and must be adjusted.  */
d3360 13
a3372 15
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */

struct elf_sh_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf_sh_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
d3374 3
d3389 2
a3390 2
  /* Number of PC relative relocs copied for this symbol.  */
  struct elf_sh_pcrel_relocs_copied *pcrel_relocs_copied;
a3397 1
};
d3399 8
a3406 1
/* Declare this now that the above structures are defined.  */
d3408 3
a3410 2
static boolean sh_elf_discard_copies
  PARAMS ((struct elf_sh_link_hash_entry *, PTR));
d3451 4
a3454 1
      ret->pcrel_relocs_copied = NULL;
d3483 9
d3495 33
d3535 1
d3556 2
d3572 1
d3599 1
d3605 1
a3605 1
  if (! _bfd_elf_create_got_section (abfd, info))
d3641 1
d3662 1
d3684 3
d3710 6
a3715 3
      if (! info->shared
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
d3722 2
a3723 9
	  BFD_ASSERT ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0);
	  return true;
	}

      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
a3725 38
      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (s->_raw_size == 0)
	s->_raw_size += PLT_ENTRY_SIZE;

      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.  This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (! info->shared
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = s->_raw_size;
	}

      h->plt.offset = s->_raw_size;

      /* Make room for this entry.  */
      s->_raw_size += elf_sh_sizeof_plt (info);

      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */

      s = bfd_get_section_by_name (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += 4;

      /* We also need to make an entry in the .rela.plt section.  */

      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += sizeof (Elf32_External_Rela);

d3728 2
d3758 24
d3792 2
a3793 1
  s = bfd_get_section_by_name (dynobj, ".dynbss");
d3804 1
a3804 1
      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
d3817 1
a3817 2
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
d3834 233
d4074 1
a4076 1
  boolean plt;
d4078 1
d4080 2
a4081 1
  dynobj = elf_hash_table (info)->dynobj;
d4084 1
a4084 1
  if (elf_hash_table (info)->dynamic_sections_created)
a4094 30
  else
    {
      /* We may have created entries in the .rela.got section.
	 However, if we are not creating the dynamic sections, we will
	 not actually use these entries.  Reset the size of .rela.got,
	 which will cause it to get stripped from the output file
	 below.  */
      s = bfd_get_section_by_name (dynobj, ".rela.got");
      if (s != NULL)
	s->_raw_size = 0;
    }

  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared && info->symbolic)
    sh_elf_link_hash_traverse (sh_elf_hash_table (info),
			       sh_elf_discard_copies,
			       (PTR) NULL);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = false;
  relocs = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      boolean strip;
d4096 11
a4106 1
      if ((s->flags & SEC_LINKER_CREATED) == 0)
d4109 26
a4134 3
      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);
d4136 3
a4138 1
      strip = false;
d4140 10
a4149 1
      if (strcmp (name, ".plt") == 0)
d4151 1
a4151 1
	  if (s->_raw_size == 0)
d4153 4
a4156 3
	      /* Strip this section if we don't need it; see the
		 comment below.  */
	      strip = true;
d4159 22
a4180 4
	    {
	      /* Remember whether there is a PLT.  */
	      plt = true;
	    }
d4182 1
a4182 1
      else if (strncmp (name, ".rela", 5) == 0)
d4184 2
a4185 19
	  if (s->_raw_size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rela.bss and
		 .rela.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = true;
	    }
	  else
	    {
	      /* Remember whether there are any reloc sections other
		 than .rela.plt.  */
	      if (strcmp (name, ".rela.plt") != 0)
		relocs = true;
d4187 3
a4189 4
	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
d4191 1
a4191 1
      else if (strncmp (name, ".got", 4) != 0)
d4197 1
a4197 1
      if (strip)
d4199 10
d4213 5
a4217 1
      /* Allocate memory for the section contents.  */
d4219 1
a4219 1
      if (s->contents == NULL && s->_raw_size != 0)
d4223 1
a4223 1
  if (elf_hash_table (info)->dynamic_sections_created)
d4235 1
a4235 1
	  if (!add_dynamic_entry (DT_DEBUG, 0))
d4239 1
a4239 1
      if (plt)
d4241 4
a4244 4
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
d4250 4
a4253 3
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
a4254 1
	}
d4256 11
a4266 4
      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return false;
a4272 27

/* This function is called via sh_elf_link_hash_traverse if we are
   creating a shared object with -Bsymbolic.  It discards the space
   allocated to copy PC relative relocs against symbols which are
   defined in regular objects.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.  */

static boolean
sh_elf_discard_copies (h, ignore)
     struct elf_sh_link_hash_entry *h;
     PTR ignore ATTRIBUTE_UNUSED;
{
  struct elf_sh_pcrel_relocs_copied *s;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct elf_sh_link_hash_entry *) h->root.root.u.i.link;

  /* We only discard relocs for symbols defined in a regular object.  */
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return true;

  for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
    s->section->_raw_size -= s->count * sizeof (Elf32_External_Rela);

  return true;
}
d4288 1
d4299 1
d4302 1
a4302 1
  dynobj = elf_hash_table (info)->dynobj;
d4305 3
a4307 3
  sgot = NULL;
  sgotplt = NULL;
  splt = NULL;
d4330 1
a4330 1
         handled entirely by the relaxation code.  */
d4355 1
a4355 1
         the relocation.  */
d4434 3
a4436 3
              addend = bfd_get_32 (input_bfd, contents + rel->r_offset);
              msec = sec;
              addend =
d4467 3
d4490 1
a4490 1
		      && elf_hash_table (info)->dynamic_sections_created
d4505 2
a4506 2
			   && !(ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
				|| ELF_ST_VISIBILITY (h->other) == STV_HIDDEN))
d4513 3
a4515 1
			  || (input_section->flags & SEC_DEBUGGING) != 0)))
d4538 3
a4540 2
	       && (!info->symbolic || info->allow_shlib_undefined)
	       && !info->no_undefined)
d4546 3
a4548 1
		      input_section, rel->r_offset, true)))
d4729 1
a4729 2
	      || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	      || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
a4738 5
	  if (sgotplt == NULL)
	    {
	      sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
	      BFD_ASSERT (sgotplt != NULL);
	    }
d4740 1
d4763 2
a4764 5
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }
d4769 1
d4783 2
a4784 1
	      if (! elf_hash_table (info)->dynamic_sections_created
d4787 1
a4787 2
			  || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
			  || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
d4891 1
a4891 1
 	  relocation -= GOT_BIAS;
d4906 1
a4906 5
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }
d4932 1
a4932 6
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

d4958 1
a4958 2
	  if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	      || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
d4969 1
a4969 6
	  if (splt == NULL)
	    {
	      splt = bfd_get_section_by_name (dynobj, ".plt");
	      BFD_ASSERT (splt != NULL);
	    }

d5192 4
a5195 4
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d5197 124
a5320 4
  /* We use got and plt entries for sh, but it would seem that the
     existing SH code does no sort of reference counting or whatnot on
     its GOT and PLT entries, so it is not possible to garbage collect
     them at this time.  */
d5324 48
d5385 1
d5407 2
a5408 1
  dynobj = elf_hash_table (info)->dynobj;
d5424 1
a5424 1
      if (dynobj == NULL)
d5454 3
a5456 2
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfd_elf_create_got_section (dynobj, info))
d5466 3
a5468 3
        {
        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
d5474 2
a5475 2
        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
a5490 28
	  /* This symbol requires a global offset table entry.  */

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (srelgot == NULL
	      && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot = bfd_make_section (dynobj, ".rela.got");
		  if (srelgot == NULL
		      || ! bfd_set_section_flags (dynobj, srelgot,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY))
		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		    return false;
		}
	    }

d5492 2
d5495 1
a5495 24
#ifdef INCLUDE_SHMEDIA
	      if (h->type == STT_DATALABEL)
		{
		  struct elf_sh_link_hash_entry *hsh;

		  h = (struct elf_link_hash_entry *) h->root.u.i.link;
		  hsh = (struct elf_sh_link_hash_entry *)h;
		  if (hsh->datalabel_got_offset != (bfd_vma) -1)
		    break;

		  hsh->datalabel_got_offset = sgot->_raw_size;
		}
	      else
		{
#endif
	      if (h->got.offset != (bfd_vma) -1)
		{
		  /* We have already allocated space in the .got.  */
		  break;
		}
	      h->got.offset = sgot->_raw_size;
#ifdef INCLUDE_SHMEDIA
		}
#endif
a5496 11
	      /* Make sure this symbol is output as a dynamic symbol.  */
	      if (h->dynindx == -1)
		{
		  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		    return false;
		}

	      srelgot->_raw_size += sizeof (Elf32_External_Rela);
	    }
	  else
	    {
d5498 3
a5500 2
	         symbol.  */
	      if (local_got_offsets == NULL)
a5502 1
		  register unsigned int i;
d5505 1
a5505 1
		  size *= sizeof (bfd_vma);
d5511 3
a5513 2
		  local_got_offsets = (bfd_vma *) bfd_alloc (abfd, size);
		  if (local_got_offsets == NULL)
d5515 1
a5515 39
		  elf_local_got_offsets (abfd) = local_got_offsets;
		  for (i = 0; i < symtab_hdr->sh_info; i++)
		    local_got_offsets[i] = (bfd_vma) -1;
#ifdef INCLUDE_SHMEDIA
		  for (; i < 2 * symtab_hdr->sh_info; i++)
		    local_got_offsets[i] = (bfd_vma) -1;
#endif
		}
#ifdef INCLUDE_SHMEDIA
	      if ((rel->r_addend & 1) != 0)
		{
		  if (local_got_offsets[symtab_hdr->sh_info
					+ r_symndx] != (bfd_vma) -1)
		    {
		      /* We have already allocated space in the .got.  */
		      break;
		    }
		  local_got_offsets[symtab_hdr->sh_info
				    + r_symndx] = sgot->_raw_size;
		}
	      else
		{
#endif
	      if (local_got_offsets[r_symndx] != (bfd_vma) -1)
		{
		  /* We have already allocated space in the .got.  */
		  break;
		}
	      local_got_offsets[r_symndx] = sgot->_raw_size;
#ifdef INCLUDE_SHMEDIA
		}
#endif

	      if (info->shared)
		{
		  /* If we are generating a shared object, we need to
		     output a R_SH_RELATIVE reloc so that the dynamic
		     linker can adjust this GOT entry.  */
		  srelgot->_raw_size += sizeof (Elf32_External_Rela);
d5517 1
a5518 3

	  sgot->_raw_size += 4;

d5534 1
a5534 2
	      || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	      || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
d5537 1
a5537 2
	      || h->dynindx == -1
	      || h->got.offset != (bfd_vma) -1)
a5539 7
	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return false;
	    }

d5541 1
d5564 1
a5564 2
	  if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	      || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
d5568 1
a5568 1

d5573 5
a5577 2
	  if (h != NULL)
	    h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d5590 22
a5611 8
	     pcrel_relocs_copied field of the hash table entry.  */
	  if (info->shared
	      && (sec->flags & SEC_ALLOC) != 0
	      && (ELF32_R_TYPE (rel->r_info) != R_SH_REL32
		  || (h != NULL
		      && (! info->symbolic
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d5613 6
d5654 1
d5657 5
a5661 12
	      sreloc->_raw_size += sizeof (Elf32_External_Rela);

	      /* If we are linking with -Bsymbolic, and this is a
		 global symbol, we count the number of PC relative
		 relocations we have entered for this symbol, so that
		 we can discard them again if the symbol is later
		 defined by a regular object.  Note that this function
		 is only called if we are using an elf_sh linker
		 hash table, which means that h is really a pointer to
		 an elf_sh_link_hash_entry.  */
	      if (h != NULL && info->symbolic
		  && ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
d5663 1
a5663 2
		  struct elf_sh_link_hash_entry *eh;
		  struct elf_sh_pcrel_relocs_copied *p;
d5665 5
a5669 1
		  eh = (struct elf_sh_link_hash_entry *) h;
d5671 3
a5673 3
		  for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
		    if (p->section == sreloc)
		      break;
d5675 5
d5681 7
a5687 10
		    {
		      p = ((struct elf_sh_pcrel_relocs_copied *)
			   bfd_alloc (dynobj, (bfd_size_type) sizeof *p));
		      if (p == NULL)
			return false;
		      p->next = eh->pcrel_relocs_copied;
		      eh->pcrel_relocs_copied = p;
		      p->section = sreloc;
		      p->count = 0;
		    }
d5689 3
a5691 2
		  ++p->count;
		}
d5825 1
d5828 2
a5829 1
  dynobj = elf_hash_table (info)->dynobj;
d5846 3
a5848 3
      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
      srel = bfd_get_section_by_name (dynobj, ".rela.plt");
d5980 2
a5981 2
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srel = bfd_get_section_by_name (dynobj, ".rela.got");
d5988 3
a5990 3
      /* If this is a -Bsymbolic link, and the symbol is defined
	 locally, we just want to emit a RELATIVE reloc.  Likewise if
	 the symbol was forced to be local because of a version file.
d5994 3
a5996 1
	  && (info->symbolic || h->dynindx == -1)
d6058 1
d6063 2
a6064 1
  dynobj = elf_hash_table (info)->dynobj;
d6066 1
a6066 2
  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
d6069 1
a6069 1
  if (elf_hash_table (info)->dynamic_sections_created)
d6074 1
a6074 1
      BFD_ASSERT (sdyn != NULL);
d6081 2
d6084 1
a6084 2
	  asection *s;
	  struct elf_link_hash_entry *h;
d6103 3
a6105 1
		  h = elf_link_hash_lookup (elf_hash_table (info), name,
d6117 1
a6117 1
	      name = ".got";
d6121 1
a6121 1
	      name = ".rela.plt";
a6122 1
	      s = bfd_get_section_by_name (output_bfd, name);
d6129 1
a6129 1
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
d6148 1
a6148 2
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      if (s != NULL)
d6150 1
d6162 1
a6162 1
      splt = bfd_get_section_by_name (dynobj, ".plt");
d6208 1
a6208 1
  if (sgot->_raw_size > 0)
d6218 2
a6221 2
  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;

d6268 5
a6272 5
#define elf_backend_gc_mark_hook        sh_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook       sh_elf_gc_sweep_hook
#define elf_backend_check_relocs        sh_elf_check_relocs

#define elf_backend_can_gc_sections	1
d6287 2
@


1.56
log
@	* elf32-sh.c (sh_elf_finish_dynamic_sections): Set LSB of DT_INIT
	value if .init is an SHmedia function.  Similarly for DT_FINI.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_sections): Likewise.
@
text
@d2950 1
a2950 1
  0x6b, 0xf1, 0x46, 0x00, /* ptabs r17, tr0 */
d2970 1
a2970 1
  0x00, 0x46, 0xf1, 0x6b, /* ptabs r17, tr0 */
d5487 2
a5488 1
      got_offset -= GOT_BIAS;
d5509 1
d5511 2
a5512 1
			     (splt->output_section->vma + splt->output_offset),
d5551 2
a5552 1
      got_offset += GOT_BIAS;
@


1.55
log
@	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero initialize
	dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
@
text
@d5700 1
d5708 21
@


1.54
log
@Add sh-nto support
@
text
@d3898 1
a3898 1
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
@


1.53
log
@	* bfd/elf32-sh.c (sh_elf_gc_mark_hook): For sh64, skip indirect
	symbols when looking for section referred to by a relocation.
	* bfd/elf64-sh.c (sh_elf64_gc_mark_hook): Likewise.
@
text
@d5885 2
d5888 2
@


1.52
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@d4875 5
@


1.52.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@a58 3
static void sh_elf_copy_indirect_symbol
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
a77 2
static boolean create_got_section
  PARAMS((bfd *, struct bfd_link_info *));
a85 4
static boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
d433 12
a444 12
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_SH_GNU_VTINHERIT", /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d448 12
a459 12
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn,	/* special_function */
	 "R_SH_GNU_VTENTRY",   /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d513 1
a513 1
	 false),		/* pcrel_offset */
d528 1
a528 1
	 false),		/* pcrel_offset */
d543 1
a543 1
	 false),		/* pcrel_offset */
d558 1
a558 1
	 false),		/* pcrel_offset */
d560 1
a560 1
  /* Used in LD.UW, ST.W et al.	 */
d573 1
a573 1
	 false),		/* pcrel_offset */
d575 1
a575 1
  /* Used in LD.L, FLD.S et al.	 */
d588 1
a588 1
	 false),		/* pcrel_offset */
d603 1
a603 1
	 false),		/* pcrel_offset */
d860 1
a860 1
	 "R_SH_GOT_LOW16",	/* name */
d864 1
a864 1
	 false),		/* pcrel_offset */
d879 1
a879 1
	 false),		/* pcrel_offset */
d894 1
a894 1
	 false),		/* pcrel_offset */
d909 1
a909 1
	 false),		/* pcrel_offset */
d920 1
a920 1
	 "R_SH_GOTPLT_LOW16",	/* name */
d924 1
a924 1
	 false),		/* pcrel_offset */
d939 1
a939 1
	 false),		/* pcrel_offset */
d954 1
a954 1
	 false),		/* pcrel_offset */
d969 1
a969 1
	 false),		/* pcrel_offset */
d980 1
a980 1
	 "R_SH_PLT_LOW16",	/* name */
d984 1
a984 1
	 true),			/* pcrel_offset */
d999 1
a999 1
	 true),			/* pcrel_offset */
d1014 1
a1014 1
	 true),			/* pcrel_offset */
d1029 1
a1029 1
	 true),			/* pcrel_offset */
d1040 1
a1040 1
	 "R_SH_GOTOFF_LOW16",	/* name */
d1044 1
a1044 1
	 false),		/* pcrel_offset */
d1059 1
a1059 1
	 false),		/* pcrel_offset */
d1074 1
a1074 1
	 false),		/* pcrel_offset */
d1089 1
a1089 1
	 false),		/* pcrel_offset */
d1100 1
a1100 1
	 "R_SH_GOTPC_LOW16",	/* name */
d1104 1
a1104 1
	 true),			/* pcrel_offset */
d1119 1
a1119 1
	 true),			/* pcrel_offset */
d1134 1
a1134 1
	 true),			/* pcrel_offset */
d1149 1
a1149 1
	 true),			/* pcrel_offset */
d1151 1
a1151 1
  /* Used in LD.L, FLD.S et al.	 */
d1164 1
a1164 1
	 false),		/* pcrel_offset */
d1166 1
a1166 1
  /* Used in LD.L, FLD.S et al.	 */
d1179 1
a1179 1
	 false),		/* pcrel_offset */
d1194 1
a1194 1
	 false),		/* pcrel_offset */
d1209 1
a1209 1
	 false),		/* pcrel_offset */
d1219 1
a1219 1
	 "R_SH_COPY64",		/* name */
d1223 1
a1223 1
	 false),		/* pcrel_offset */
d1233 1
a1233 1
	 "R_SH_GLOB_DAT64",	/* name */
d1237 1
a1237 1
	 false),		/* pcrel_offset */
d1247 1
a1247 1
	 "R_SH_JMP_SLOT64",	/* name */
d1251 1
a1251 1
	 false),		/* pcrel_offset */
d1261 1
a1261 1
	 "R_SH_RELATIVE64",	/* name */
d1265 1
a1265 1
	 false),		/* pcrel_offset */
d1366 1
a1366 1
	 false),		/* pcrel_offset */
d1381 1
a1381 1
	 false),		/* pcrel_offset */
d1392 1
a1392 1
	 "R_SH_IMM_LOW16",	/* name */
d1396 1
a1396 1
	 false),		/* pcrel_offset */
d1426 1
a1426 1
	 false),		/* pcrel_offset */
d1456 1
a1456 1
	 false),		/* pcrel_offset */
d1486 1
a1486 1
	 false),		/* pcrel_offset */
d1512 1
a1512 1
	 "R_SH_64",		/* name */
d1516 1
a1516 1
	 false),		/* pcrel_offset */
d1958 3
a1960 3
	 the register load.  The 4 is because the r_addend field is
	 computed as though it were a jump offset, which are based
	 from 4 bytes after the jump instruction.  */
d1972 1
a1972 1
	 do.  */
d1999 2
a2000 2
	 being loaded.  This reloc will tell us which function is
	 actually being called.  */
d2057 2
a2058 2
		 symbol.  Just ignore it--it will be caught by the
		 regular reloc processing.  */
d2098 1
a2098 1
	 replace the jsr with a bsr.  */
d2103 2
a2104 2
	     it will be handled here like other internal IND12W
	     relocs.  */
d2112 2
a2113 2
	     symbol value may be changed by future relaxing.  We let
	     the final link phase handle it.  */
d2118 1
a2118 1
	 register load.  */
d2133 2
a2134 2
	 function address is stored.  Do this before deleting any
	 bytes, to avoid confusion about the address.  */
d2145 2
a2146 2
	 other function call to come within range, we should relax
	 again.  Note that this is not required, and it may be slow.  */
d2159 1
a2159 1
	 just deleted one.  */
d2171 2
a2172 2
	 the address from irelfn, in case it was changed by the
	 previous call to sh_elf_relax_delete_bytes.  */
d2358 1
a2358 1
	 includes the bytes we have deleted.  */
d2381 3
a2383 3
	     section, and the symbol will not be adjusted below, we
	     must check the addend to see it will put the value in
	     range to be adjusted, and hence must be changed.  */
d2575 2
a2576 2
	 false, we should free them, if we are permitted to, when we
	 leave sh_coff_relax_section.  */
d2600 3
a2602 3
			 Perhaps, if info->keep_memory is false, we
			 should free them, if we are permitted to,
			 when we leave sh_coff_relax_section.  */
d2658 3
a2660 3
			 Perhaps, if info->keep_memory is false, we
			 should free them, if we are permitted to,
			 when we leave sh_coff_relax_section.  */
d2832 2
a2833 2
	 adjust.  These relocs do not apply to the instruction itself,
	 but are only associated with the address.  */
d2842 5
a2846 5
	 swapped, we must adjust it.  It would be incorrect to do this
	 for a jump, though, since we want to execute both
	 instructions after the jump.  (We have avoided swapping
	 around a label, so the jump will not wind up executing an
	 instruction it shouldn't).  */
d2905 5
a2909 5
		 the program counter before adding in the offset.
		 This means that if ADDR is at an even address, the
		 swap will not affect the offset.  If ADDR is an at an
		 odd address, then the instruction will be crossing a
		 four byte boundary, and must be adjusted.  */
d3351 15
a3365 13
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct elf_sh_dyn_relocs
{
  struct elf_sh_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
a3366 3

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
d3379 2
a3380 2
  /* Track dynamic relocs copied for this symbol.  */
  struct elf_sh_dyn_relocs *dyn_relocs;
d3388 1
d3390 1
a3390 8
  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;
d3392 2
a3393 3
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
};
d3434 1
a3434 4
      struct elf_sh_link_hash_entry *eh;

      eh = (struct elf_sh_link_hash_entry *) ret;
      eh->dyn_relocs = NULL;
a3462 9
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->sym_sec.abfd = NULL;

a3465 33
/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static boolean
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf_sh_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return false;

  htab = sh_elf_hash_table (info);
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (! htab->sgot || ! htab->sgotplt)
    abort ();

  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC
				   | SEC_LOAD
				   | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY
				   | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return false;
  return true;
}

a3472 1
  struct elf_sh_link_hash_table *htab;
a3492 2
  htab = sh_elf_hash_table (info);

a3506 1
  htab->splt = s;
a3532 1
  htab->srelplt = s;
d3538 1
a3538 1
  if (! create_got_section (abfd, info))
a3573 1
      htab->sdynbss = s;
a3593 1
	  htab->srelbss = s;
a3614 3
  struct elf_sh_link_hash_table *htab;
  struct elf_sh_link_hash_entry *eh;
  struct elf_sh_dyn_relocs *p;
d3638 3
a3640 6
      if (h->plt.refcount <= 0
	  || (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
	      && h->root.type != bfd_link_hash_undefweak
	      && h->root.type != bfd_link_hash_undefined))
d3647 29
a3675 2
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d3678 18
a3697 2
  else
    h->plt.offset = (bfd_vma) -1;
a3725 24
  /* If -z nocopyreloc was given, we won't generate them either.  */
  if (info->nocopyreloc)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return true;
    }

  eh = (struct elf_sh_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      s = p->sec->output_section;
      if (s != NULL && (s->flags & (SEC_READONLY | SEC_HAS_CONTENTS)) != 0)
	break;
    }

  /* If we didn't find any dynamic relocs in sections which needs the
     copy reloc, then we'll be keeping the dynamic relocs and avoiding
     the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return true;
    }

d3736 1
a3736 2
  htab = sh_elf_hash_table (info);
  s = htab->sdynbss;
d3747 1
a3747 1
      srel = htab->srelbss;
d3760 2
a3761 1
  s->_raw_size = BFD_ALIGN (s->_raw_size, (bfd_size_type) (1 << power_of_two));
a3777 233
/* This is the condition under which sh_elf_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in sh_elf_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static boolean
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf_sh_link_hash_table *htab;
  struct elf_sh_link_hash_entry *eh;
  struct elf_sh_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return true;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = (struct bfd_link_info *) inf;
  htab = sh_elf_hash_table (info);

  if (htab->root.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
	{
	  asection *s = htab->splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_ENTRY_SIZE;

	  h->plt.offset = s->_raw_size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->_raw_size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  htab->sgotplt->_raw_size += 4;

	  /* We also need to make an entry in the .rel.plt section.  */
	  htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  if (h->got.refcount > 0)
    {
      asection *s;
      boolean dyn;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      s = htab->sgot;
#ifdef INCLUDE_SHMEDIA
      if (h->type == STT_DATALABEL)
	{
	  struct elf_sh_link_hash_entry *hsh;

	  h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  hsh = (struct elf_sh_link_hash_entry *)h;
	  hsh->datalabel_got_offset = s->_raw_size;
	}
      else
	h->got.offset = s->_raw_size;
#else
      h->got.offset = s->_raw_size;
#endif
      s->_raw_size += 4;
      dyn = htab->root.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;

  eh = (struct elf_sh_link_hash_entry *) h;
  if (eh->dyn_relocs == NULL)
    return true;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
	{
	  struct elf_sh_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	      || (htab->root.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return false;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
    }

  return true;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static boolean
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct elf_sh_link_hash_entry *eh;
  struct elf_sh_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  eh = (struct elf_sh_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return false;
	}
    }
  return true;
}

a3784 1
  struct elf_sh_link_hash_table *htab;
d3787 1
a3788 1
  bfd *ibfd;
d3790 1
a3790 2
  htab = sh_elf_hash_table (info);
  dynobj = htab->root.dynobj;
d3793 1
a3793 1
  if (htab->root.dynamic_sections_created)
d3804 30
d3835 6
a3840 9
  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;
d3842 1
a3842 2
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;
d3844 1
a3844 1
      for (s = ibfd->sections; s != NULL; s = s->next)
d3846 7
a3852 6
	  struct elf_sh_dyn_relocs *p;

	  for (p = ((struct elf_sh_dyn_relocs *)
		    elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
d3854 2
a3855 15
	      if (! bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->sec)->sreloc;
		  srel->_raw_size += p->count * sizeof (Elf32_External_Rela);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
d3858 1
a3858 15

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
#ifdef INCLUDE_SHMEDIA
      /* Count datalabel local GOT.  */
      locsymcount *= 2;
#endif
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got)
d3860 1
a3860 1
	  if (*local_got > 0)
d3862 10
a3871 4
	      *local_got = s->_raw_size;
	      s->_raw_size += 4;
	      if (info->shared)
		srel->_raw_size += sizeof (Elf32_External_Rela);
d3874 5
a3878 3
	    *local_got = (bfd_vma) -1;
	}
    }
d3880 4
a3883 27
  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);

  /* We now have determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (s == htab->splt
	  || s == htab->sgot
	  || s == htab->sgotplt)
	{
	  /* Strip this section if we don't need it; see the
	     comment below.  */
	}
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
	{
	  if (s->_raw_size != 0 && s != htab->srelplt)
	    relocs = true;

	  /* We use the reloc_count field as a counter if we need
	     to copy relocs into the output file.  */
	  s->reloc_count = 0;
d3885 1
a3885 1
      else
d3891 1
a3891 1
      if (s->_raw_size == 0)
a3892 10
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */

d3897 3
a3899 7
      /* Allocate memory for the section contents.  We use bfd_zalloc
	 here in case unused entries are not reclaimed before the
	 section's contents are written out.  This should not happen,
	 but this way if it does, we get a R_SH_NONE reloc instead
	 of garbage.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL)
d3903 1
a3903 1
  if (htab->root.dynamic_sections_created)
d3915 1
a3915 1
	  if (! add_dynamic_entry (DT_DEBUG, 0))
d3919 1
a3919 1
      if (htab->splt->_raw_size != 0)
d3921 4
a3924 4
	  if (! add_dynamic_entry (DT_PLTGOT, 0)
	      || ! add_dynamic_entry (DT_PLTRELSZ, 0)
	      || ! add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || ! add_dynamic_entry (DT_JMPREL, 0))
d3930 3
a3932 4
	  if (! add_dynamic_entry (DT_RELA, 0)
	      || ! add_dynamic_entry (DT_RELASZ, 0)
	      || ! add_dynamic_entry (DT_RELAENT,
				      sizeof (Elf32_External_Rela)))
d3934 1
d3936 4
a3939 11
	  /* If any dynamic relocs apply to a read-only section,
	     then we need a DT_TEXTREL entry.  */
	  if ((info->flags & DF_TEXTREL) == 0)
	    elf_link_hash_traverse (&htab->root, readonly_dynrelocs,
				    (PTR) info);

	  if ((info->flags & DF_TEXTREL) != 0)
	    {
	      if (! add_dynamic_entry (DT_TEXTREL, 0))
		return false;
	    }
d3946 27
a3987 1
  struct elf_sh_link_hash_table *htab;
a3997 1
  htab = sh_elf_hash_table (info);
d4000 1
a4000 1
  dynobj = htab->root.dynobj;
d4003 3
a4005 3
  sgot = htab->sgot;
  sgotplt = htab->sgotplt;
  splt = htab->splt;
d4028 1
a4028 1
	 handled entirely by the relaxation code.  */
d4053 1
a4053 1
	 the relocation.  */
d4132 3
a4134 3
	      addend = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      msec = sec;
	      addend =
a4164 3
	      boolean dyn;

	      dyn = htab->root.dynamic_sections_created;
d4185 1
a4185 1
		      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d4200 2
a4201 2
			   && (h->elf_link_hash_flags
			       & ELF_LINK_FORCED_LOCAL) == 0)
d4208 1
a4208 3
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))))
d4231 2
a4232 3
		   && (! info->symbolic || info->allow_shlib_undefined)
		   && ! info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d4238 1
a4238 3
		      input_section, rel->r_offset,
		      (!info->shared || info->no_undefined
		       || ELF_ST_VISIBILITY (h->other)))))
d4419 2
a4420 1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d4430 5
a4435 1
	  BFD_ASSERT (sgotplt != NULL);
d4458 5
a4462 2

	  BFD_ASSERT (sgot != NULL);
a4466 1
	      boolean dyn;
d4480 1
a4480 2
	      dyn = htab->root.dynamic_sections_created;
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d4483 2
a4484 1
			  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
d4588 1
a4588 1
	  relocation -= GOT_BIAS;
d4603 5
a4607 1
	  BFD_ASSERT (sgot != NULL);
d4633 6
a4638 1
	  BFD_ASSERT (sgot != NULL);
d4664 2
a4665 1
	  if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d4676 6
a4681 1
	  BFD_ASSERT (splt != NULL);
d4899 4
a4902 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d4904 4
a4907 124
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_SH_GOT32:
      case R_SH_GOTOFF:
      case R_SH_GOTPC:
#ifdef INCLUDE_SHMEDIA
      case R_SH_GOT_LOW16:
      case R_SH_GOT_MEDLOW16:
      case R_SH_GOT_MEDHI16:
      case R_SH_GOT_HI16:
      case R_SH_GOT10BY4:
      case R_SH_GOT10BY8:
      case R_SH_GOTOFF_LOW16:
      case R_SH_GOTOFF_MEDLOW16:
      case R_SH_GOTOFF_MEDHI16:
      case R_SH_GOTOFF_HI16:
      case R_SH_GOTPC_LOW16:
      case R_SH_GOTPC_MEDLOW16:
      case R_SH_GOTPC_MEDHI16:
      case R_SH_GOTPC_HI16:
#endif
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;

      case R_SH_DIR32:
      case R_SH_REL32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf_sh_link_hash_entry *eh;
	    struct elf_sh_dyn_relocs **pp;
	    struct elf_sh_dyn_relocs *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	    if (!info->shared && h->plt.refcount > 0)
	      h->plt.refcount -= 1;

	    eh = (struct elf_sh_link_hash_entry *) h;

	    for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	      if (p->sec == sec)
		{
		  if (ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
		    p->pc_count -= 1;
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
		}
	  }
	break;

      case R_SH_PLT32:
#ifdef INCLUDE_SHMEDIA
      case R_SH_PLT_LOW16:
      case R_SH_PLT_MEDLOW16:
      case R_SH_PLT_MEDHI16:
      case R_SH_PLT_HI16:
#endif
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	break;

      case R_SH_GOTPLT32:
#ifdef INCLUDE_SHMEDIA
      case R_SH_GOTPLT_LOW16:
      case R_SH_GOTPLT_MEDLOW16:
      case R_SH_GOTPLT_MEDHI16:
      case R_SH_GOTPLT_HI16:
      case R_SH_GOTPLT10BY4:
      case R_SH_GOTPLT10BY8:
#endif
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;

      default:
	break;
      }

a4910 48
/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
sh_elf_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
{
  struct elf_sh_link_hash_entry *edir, *eind;

  edir = (struct elf_sh_link_hash_entry *) dir;
  eind = (struct elf_sh_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf_sh_dyn_relocs **pp;
	  struct elf_sh_dyn_relocs *p;

	  BFD_ASSERT (ind->root.type != bfd_link_hash_indirect);

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf_sh_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

a4923 1
  struct elf_sh_link_hash_table *htab;
d4945 1
a4945 2
  htab = sh_elf_hash_table (info);
  dynobj = htab->root.dynobj;
d4961 1
a4961 1
      if (htab->sgot == NULL)
d4991 2
a4992 3
	      if (dynobj == NULL)
		htab->root.dynobj = dynobj = abfd;
	      if (! create_got_section (dynobj, info))
d5002 3
a5004 3
	{
	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
d5010 2
a5011 2
	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
d5027 28
d5056 35
a5090 1
	    h->got.refcount += 1;
a5092 2
	      bfd_signed_vma *local_got_refcounts;

d5094 2
a5095 3
		 symbol.  */
	      local_got_refcounts = elf_local_got_refcounts (abfd);
	      if (local_got_refcounts == NULL)
d5098 1
d5101 1
a5101 1
		  size *= sizeof (bfd_signed_vma);
d5107 2
a5108 3
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
		  if (local_got_refcounts == NULL)
d5110 39
a5148 1
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
a5149 1
	      local_got_refcounts[r_symndx] += 1;
d5151 3
d5169 2
a5170 1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d5173 2
a5174 1
	      || h->dynindx == -1)
d5177 7
a5184 1
	  h->plt.refcount += 1;
d5207 2
a5208 1
	  if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d5212 1
a5212 1
	  h->plt.refcount += 1;
d5217 2
a5218 5
	  if (h != NULL && ! info->shared)
	    {
	      h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
	      h->plt.refcount += 1;
	    }
d5231 8
a5238 22
	     dyn_relocs field of the hash table entry. A similar
	     situation occurs when creating shared libraries and symbol
	     visibility changes render the symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (sec->flags & SEC_ALLOC) != 0
	       && (ELF32_R_TYPE (rel->r_info) != R_SH_REL32
		   || (h != NULL
		       && (! info->symbolic
			   || h->root.type == bfd_link_hash_defweak
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
	      || (! info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
a5239 6
	      struct elf_sh_dyn_relocs *p;
	      struct elf_sh_dyn_relocs **head;

	      if (dynobj == NULL)
		htab->root.dynobj = dynobj = abfd;

a5274 1
		  elf_section_data (sec)->sreloc = sreloc;
d5277 12
a5288 5
	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		head = &((struct elf_sh_link_hash_entry *) h)->dyn_relocs;
	      else
d5290 2
a5291 1
		  asection *s;
d5293 1
a5293 5
		  /* Track dynamic relocs needed for local syms too.  */
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return false;
d5295 3
a5297 3
		  head = ((struct elf_sh_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
		}
a5298 5
	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof (*p);
		  p = ((struct elf_sh_dyn_relocs *) bfd_alloc (dynobj, amt));
d5300 12
a5311 6
		    return false;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
a5312 4

	      p->count += 1;
	      if (ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
		p->pc_count += 1;
a5445 1
  struct elf_sh_link_hash_table *htab;
d5448 1
a5448 2
  htab = sh_elf_hash_table (info);
  dynobj = htab->root.dynobj;
d5465 3
a5467 3
      splt = htab->splt;
      sgot = htab->sgotplt;
      srel = htab->srelplt;
d5595 2
a5596 2
      sgot = htab->sgot;
      srel = htab->srelgot;
d5603 3
a5605 3
      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
d5609 1
a5609 3
	  && (info->symbolic
	      || h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
a5670 1
  struct elf_sh_link_hash_table *htab;
d5675 1
a5675 2
  htab = sh_elf_hash_table (info);
  dynobj = htab->root.dynobj;
d5677 2
a5678 1
  sgot = htab->sgotplt;
d5681 1
a5681 1
  if (htab->root.dynamic_sections_created)
d5686 1
a5686 1
      BFD_ASSERT (sgot != NULL && sdyn != NULL);
d5693 1
d5704 1
a5704 1
	      s = htab->sgot->output_section;
d5708 1
a5708 1
	      s = htab->srelplt->output_section;
d5710 1
d5717 1
a5717 1
	      s = htab->srelplt->output_section;
d5736 2
a5737 1
	      if (htab->srelplt != NULL)
a5738 1
		  s = htab->srelplt->output_section;
d5750 1
a5750 1
      splt = htab->splt;
d5796 1
a5796 1
  if (sgot && sgot->_raw_size > 0)
d5806 1
d5808 1
a5808 2
      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
    }
d5856 5
a5860 5
#define elf_backend_gc_mark_hook	sh_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	sh_elf_gc_sweep_hook
#define elf_backend_check_relocs	sh_elf_check_relocs
#define elf_backend_copy_indirect_symbol \
					sh_elf_copy_indirect_symbol
a5874 2
#define elf_backend_can_gc_sections	1
#define elf_backend_can_refcount	1
@


1.52.2.2
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d3582 1
a3582 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d3586 2
a3587 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a3588 2

      h = (struct elf_link_hash_entry *) bh;
@


1.52.2.3
log
@Merge from mainline.
@
text
@a3390 2

  bfd_signed_vma gotplt_refcount;
a3454 1
      eh->gotplt_refcount = 0;
a3872 12
  eh = (struct elf_sh_link_hash_entry *) h;
  if ((h->got.refcount > 0
      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
      && eh->gotplt_refcount > 0)
    {
      /* The symbol has been forced local, or we have some direct got refs,
         so treat all the gotplt refs as got refs. */
      h->got.refcount += eh->gotplt_refcount;
      if (h->plt.refcount >= eh->gotplt_refcount)
	h->plt.refcount -= eh->gotplt_refcount;
    }

d3967 1
a5200 1
  struct elf_sh_link_hash_entry *eh;
d5303 1
a5303 8
	    eh = (struct elf_sh_link_hash_entry *) h;
	    if (eh->gotplt_refcount > 0)
	      {
		eh->gotplt_refcount -= 1;
		if (h->plt.refcount > 0)
		  h->plt.refcount -= 1;
	      }
	    else if (h->got.refcount > 0)
d5305 2
a5365 2
  edir->gotplt_refcount = eind->gotplt_refcount;
  eind->gotplt_refcount = 0;
a5539 1
	  ((struct elf_sh_link_hash_entry *) h)->gotplt_refcount += 1;
@


1.52.2.4
log
@Merge fixes from trunk.
@
text
@d4532 1
a4532 8
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0)))
		  /* Dynamic relocs are not propagated for SEC_DEBUGGING
		     sections because such sections are not SEC_ALLOC and
		     thus ld.so will not process them.  */
		  || (sec->output_section == NULL
		      && ((input_section->flags & SEC_DEBUGGING) != 0
			  && (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_DYNAMIC) != 0)))
@


1.51
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@a1548 1
  bfd_byte *free_contents = NULL;
a1582 1
	  free_contents = contents;
d1622 3
a1624 2
  if (free_contents)
    free (free_contents);
a1889 1
  Elf_Internal_Shdr *shndx_hdr;
a1890 1
  Elf_Internal_Rela *free_relocs = NULL;
d1894 1
a1894 4
  bfd_byte *free_contents = NULL;
  Elf32_External_Sym *extsyms = NULL;
  Elf32_External_Sym *free_extsyms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
a1916 1
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
a1922 2
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;
a1949 1
	      free_contents = contents;
d2014 1
a2014 1
      if (extsyms == NULL)
d2016 7
a2022 32
	  if (symtab_hdr->contents != NULL)
	    extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
	  else
	    {
	      bfd_size_type amt;

	      amt = symtab_hdr->sh_info;
	      amt *= sizeof (Elf32_External_Sym);
	      extsyms = (Elf32_External_Sym *) bfd_malloc (amt);
	      if (extsyms == NULL)
		goto error_return;
	      free_extsyms = extsyms;
	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) extsyms, amt, abfd) != amt)
		goto error_return;
	      symtab_hdr->contents = (bfd_byte *) extsyms;
	    }

	  if (shndx_hdr->sh_size != 0)
	    {
	      bfd_size_type amt;

	      amt = symtab_hdr->sh_info;
	      amt *= sizeof (Elf_External_Sym_Shndx);
	      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	      if (shndx_buf == NULL)
		goto error_return;
	      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
		goto error_return;
	      shndx_hdr->contents = (bfd_byte *) shndx_buf;
	    }
d2029 1
a2029 8
	  Elf32_External_Sym *esym;
	  Elf_External_Sym_Shndx *shndx;
	  Elf_Internal_Sym isym;

	  esym = extsyms + ELF32_R_SYM (irelfn->r_info);
	  shndx = shndx_buf + (shndx_buf ? ELF32_R_SYM (irelfn->r_info) : 0);
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d2031 2
a2032 1
	  if (isym.st_shndx
d2041 1
a2041 1
	  symval = (isym.st_value
a2091 2
      free_relocs = NULL;

d2093 1
a2093 3
      free_contents = NULL;

      free_extsyms = NULL;
a2197 1
	      free_contents = contents;
a2211 2
	  free_relocs = NULL;

d2213 1
a2213 3
	  free_contents = NULL;

	  free_extsyms = NULL;
d2217 2
a2218 4
  if (free_relocs != NULL)
    free (free_relocs);

  if (free_contents != NULL)
d2221 1
a2221 1
	free (free_contents);
d2224 2
a2225 2
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
d2229 2
a2230 7
  if (shndx_buf != NULL)
    {
      shndx_hdr->contents = NULL;
      free (shndx_buf);
    }

  if (free_extsyms != NULL)
d2233 2
d2236 2
a2237 2
	  symtab_hdr->contents = NULL;
	  free (free_extsyms);
d2241 4
d2248 9
a2256 14
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (shndx_buf != NULL)
    {
      shndx_hdr->contents = NULL;
      free (shndx_buf);
    }
  if (free_extsyms != NULL)
    {
      symtab_hdr->contents = NULL;
      free (free_extsyms);
    }
a2272 2
  Elf_Internal_Shdr *shndx_hdr;
  Elf32_External_Sym *extsyms;
d2278 1
a2278 2
  Elf32_External_Sym *esym, *esymend;
  Elf_External_Sym_Shndx *shndx_buf, *shndx;
d2285 1
a2285 4
  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;

  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  shndx_buf = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
a2332 1
      Elf_Internal_Sym sym;
d2386 4
a2389 8
	      esym = extsyms + ELF32_R_SYM (irel->r_info);
	      shndx = shndx_buf + (shndx_buf ? ELF32_R_SYM (irel->r_info) : 0);
	      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym,
					(const PTR) shndx, &sym);

	      if (sym.st_shndx == sec_shndx
		  && (sym.st_value <= addr
		      || sym.st_value >= toaddr))
d2394 1
a2394 1
		  val += sym.st_value;
a2586 2
	  Elf_Internal_Sym sym;

d2644 4
a2647 8
	  esym = extsyms + ELF32_R_SYM (irelscan->r_info);
	  shndx = shndx_buf + (shndx_buf ? ELF32_R_SYM (irelscan->r_info) : 0);
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &sym);

	  if (sym.st_shndx == sec_shndx
	      && (sym.st_value <= addr
		  || sym.st_value >= toaddr))
d2673 1
a2673 1
	      val += sym.st_value;
d2682 7
a2688 18
  shndx = shndx_buf;
  esym = extsyms;
  esymend = esym + symtab_hdr->sh_info;
  for (; esym < esymend; esym++, shndx = (shndx ? shndx + 1 : NULL))
    {
      Elf_Internal_Sym isym;
      Elf_External_Sym_Shndx dummy;

      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				&isym);

      if (isym.st_shndx == sec_shndx
	  && isym.st_value > addr
	  && isym.st_value < toaddr)
	{
	  isym.st_value -= count;
	  bfd_elf32_swap_symbol_out (abfd, &isym, (PTR) esym, (PTR) &dummy);
	}
a4762 1
  Elf_Internal_Shdr *shndx_hdr;
d4767 1
a4767 4
  Elf32_External_Sym *external_syms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
  Elf_External_Sym_Shndx *shndx;
  Elf_Internal_Sym *internal_syms = NULL;
a4778 1
  shndx_hdr = &elf_tdata (input_bfd)->symtab_shndx_hdr;
a4785 1
      Elf_Internal_Sym *isymp;
d4787 1
a4787 1
      Elf32_External_Sym *esym, *esymend;
a4789 26
      if (symtab_hdr->contents != NULL)
	external_syms = (Elf32_External_Sym *) symtab_hdr->contents;
      else if (symtab_hdr->sh_info != 0)
	{
	  amt = symtab_hdr->sh_info;
	  amt *= sizeof (Elf32_External_Sym);
	  external_syms = (Elf32_External_Sym *) bfd_malloc (amt);
	  if (external_syms == NULL)
	    goto error_return;
	  if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread ((PTR) external_syms, amt, input_bfd) != amt)
	    goto error_return;
	}

      if (symtab_hdr->sh_info != 0 && shndx_hdr->sh_size != 0)
	{
	  amt = symtab_hdr->sh_info;
	  amt *= sizeof (Elf_External_Sym_Shndx);
	  shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	  if (shndx_buf == NULL)
	    goto error_return;
	  if (bfd_seek (input_bfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread ((PTR) shndx_buf, amt, input_bfd) != amt)
	    goto error_return;
	}

d4796 10
a4805 5
      amt = symtab_hdr->sh_info;
      amt *= sizeof (Elf_Internal_Sym);
      internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
      if (internal_syms == NULL && amt != 0)
	goto error_return;
d4813 2
a4814 4
      for (isymp = internal_syms, secpp = sections, shndx = shndx_buf,
	     esym = external_syms, esymend = esym + symtab_hdr->sh_info;
	   esym < esymend;
	   ++esym, ++isymp, ++secpp, shndx = (shndx ? shndx + 1 : NULL))
d4818 1
a4818 4
	  bfd_elf32_swap_symbol_in (input_bfd, (const PTR) esym,
				    (const PTR) shndx, isymp);

	  if (isymp->st_shndx == SHN_UNDEF)
d4820 1
a4820 1
	  else if (isymp->st_shndx == SHN_ABS)
d4822 1
a4822 1
	  else if (isymp->st_shndx == SHN_COMMON)
d4825 1
a4825 1
	    isec = bfd_section_from_elf_index (input_bfd, isymp->st_shndx);
d4832 1
a4832 1
				     internal_syms, sections))
d4837 4
a4840 7
      if (internal_syms != NULL)
	free (internal_syms);
      if (shndx_buf != NULL)
	free (shndx_buf);
      if (external_syms != NULL && symtab_hdr->contents == NULL)
	free (external_syms);
      if (internal_relocs != elf_section_data (input_section)->relocs)
d4847 5
d4853 1
a4853 1
      && internal_relocs != elf_section_data (input_section)->relocs)
a4854 8
  if (shndx_buf != NULL)
    free (shndx_buf);
  if (external_syms != NULL && symtab_hdr->contents == NULL)
    free (external_syms);
  if (internal_syms != NULL)
    free (internal_syms);
  if (sections != NULL)
    free (sections);
@


1.50
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d81 1
a81 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d4981 2
a4982 2
sh_elf_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d5012 1
a5012 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.49
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d5528 1
a5528 1
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
@


1.48
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d2070 2
a2071 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR *) esym,
				    (const PTR *) shndx, &isym);
d2451 2
a2452 2
	      bfd_elf32_swap_symbol_in (abfd, (const PTR *) esym,
					(const PTR *) shndx, &sym);
d2715 2
a2716 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR *) esym,
				    (const PTR *) shndx, &sym);
d2763 1
a2763 1
      bfd_elf32_swap_symbol_in (abfd, (const PTR *) esym, (const PTR *) shndx,
d4931 2
a4932 2
	  bfd_elf32_swap_symbol_in (input_bfd, (const PTR *) esym,
				    (const PTR *) shndx, isymp);
@


1.47
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d2070 2
a2071 1
	  bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);
d2451 2
a2452 1
	      bfd_elf32_swap_symbol_in (abfd, esym, shndx, &sym);
d2715 2
a2716 1
	  bfd_elf32_swap_symbol_in (abfd, esym, shndx, &sym);
d2763 2
a2764 1
      bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);
d4931 2
a4932 1
	  bfd_elf32_swap_symbol_in (input_bfd, esym, shndx, isymp);
@


1.47.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2070 1
a2070 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d2450 1
a2450 2
	      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym,
					(const PTR) shndx, &sym);
d2713 1
a2713 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &sym);
d2760 1
a2760 2
      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				&isym);
d4927 1
a4927 2
	  bfd_elf32_swap_symbol_in (input_bfd, (const PTR) esym,
				    (const PTR) shndx, isymp);
@


1.47.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d81 1
a81 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d1549 1
d1584 1
d1624 2
a1625 3
  if (contents != NULL
      && elf_section_data (symbol_section)->this_hdr.contents != contents)
    free (contents);
d1891 1
d1893 1
d1897 4
a1900 1
  Elf_Internal_Sym *isymbuf = NULL;
d1923 1
d1930 2
d1959 1
d2024 1
a2024 1
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
d2026 32
a2057 7
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
d2064 8
a2071 1
	  Elf_Internal_Sym *isym;
d2073 1
a2073 2
	  isym = isymbuf + ELF32_R_SYM (irelfn->r_info);
	  if (isym->st_shndx
d2082 1
a2082 1
	  symval = (isym->st_value
d2133 2
d2136 3
a2138 1
      symtab_hdr->contents = (unsigned char *) isymbuf;
d2243 1
d2258 2
d2261 3
a2263 1
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d2267 4
a2270 2
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
d2273 1
a2273 1
	free (isymbuf);
d2276 2
a2277 2
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d2281 7
a2287 2
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
a2289 2
	free (contents);
      else
d2291 2
a2292 2
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
a2295 4
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

d2299 14
a2312 9
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
d2329 2
d2336 2
a2337 1
  Elf_Internal_Sym *isymbuf, *isym, *isymend;
d2344 4
a2347 1
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
d2395 1
d2449 8
a2456 4
	      isym = isymbuf + ELF32_R_SYM (irel->r_info);
	      if (isym->st_shndx == sec_shndx
		  && (isym->st_value <= addr
		      || isym->st_value >= toaddr))
d2461 1
a2461 1
		  val += isym->st_value;
d2654 2
d2713 8
a2720 4
	  isym = isymbuf + ELF32_R_SYM (irelscan->r_info);
	  if (isym->st_shndx == sec_shndx
	      && (isym->st_value <= addr
		  || isym->st_value >= toaddr))
d2746 1
a2746 1
	      val += isym->st_value;
d2755 18
a2772 7
  isymend = isymbuf + symtab_hdr->sh_info;
  for (isym = isymbuf; isym < isymend; isym++)
    {
      if (isym->st_shndx == sec_shndx
	  && isym->st_value > addr
	  && isym->st_value < toaddr)
	isym->st_value -= count;
d4847 1
d4852 4
a4855 1
  Elf_Internal_Sym *isymbuf = NULL;
d4867 1
d4875 1
d4877 1
a4877 1
      Elf_Internal_Sym *isym, *isymend;
d4880 26
d4912 5
a4916 10
      if (symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}
d4924 4
a4927 2
      isymend = isymbuf + symtab_hdr->sh_info;
      for (isym = isymbuf, secpp = sections; isym < isymend; ++isym, ++secpp)
d4931 4
a4934 1
	  if (isym->st_shndx == SHN_UNDEF)
d4936 1
a4936 1
	  else if (isym->st_shndx == SHN_ABS)
d4938 1
a4938 1
	  else if (isym->st_shndx == SHN_COMMON)
d4941 1
a4941 1
	    isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);
d4948 1
a4948 1
				     isymbuf, sections))
d4953 7
a4959 4
      if (isymbuf != NULL
	  && symtab_hdr->contents != (unsigned char *) isymbuf)
	free (isymbuf);
      if (elf_section_data (input_section)->relocs != internal_relocs)
d4966 9
a4976 6
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (input_section)->relocs != internal_relocs)
    free (internal_relocs);
d4981 2
a4982 2
sh_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d5012 3
a5014 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d5528 1
a5528 1
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
@


1.47.6.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a58 3
static void sh_elf_copy_indirect_symbol
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
a77 2
static boolean create_got_section
  PARAMS((bfd *, struct bfd_link_info *));
a85 4
static boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
d433 12
a444 12
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_SH_GNU_VTINHERIT", /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d448 12
a459 12
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn,	/* special_function */
	 "R_SH_GNU_VTENTRY",   /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d513 1
a513 1
	 false),		/* pcrel_offset */
d528 1
a528 1
	 false),		/* pcrel_offset */
d543 1
a543 1
	 false),		/* pcrel_offset */
d558 1
a558 1
	 false),		/* pcrel_offset */
d560 1
a560 1
  /* Used in LD.UW, ST.W et al.	 */
d573 1
a573 1
	 false),		/* pcrel_offset */
d575 1
a575 1
  /* Used in LD.L, FLD.S et al.	 */
d588 1
a588 1
	 false),		/* pcrel_offset */
d603 1
a603 1
	 false),		/* pcrel_offset */
d860 1
a860 1
	 "R_SH_GOT_LOW16",	/* name */
d864 1
a864 1
	 false),		/* pcrel_offset */
d879 1
a879 1
	 false),		/* pcrel_offset */
d894 1
a894 1
	 false),		/* pcrel_offset */
d909 1
a909 1
	 false),		/* pcrel_offset */
d920 1
a920 1
	 "R_SH_GOTPLT_LOW16",	/* name */
d924 1
a924 1
	 false),		/* pcrel_offset */
d939 1
a939 1
	 false),		/* pcrel_offset */
d954 1
a954 1
	 false),		/* pcrel_offset */
d969 1
a969 1
	 false),		/* pcrel_offset */
d980 1
a980 1
	 "R_SH_PLT_LOW16",	/* name */
d984 1
a984 1
	 true),			/* pcrel_offset */
d999 1
a999 1
	 true),			/* pcrel_offset */
d1014 1
a1014 1
	 true),			/* pcrel_offset */
d1029 1
a1029 1
	 true),			/* pcrel_offset */
d1040 1
a1040 1
	 "R_SH_GOTOFF_LOW16",	/* name */
d1044 1
a1044 1
	 false),		/* pcrel_offset */
d1059 1
a1059 1
	 false),		/* pcrel_offset */
d1074 1
a1074 1
	 false),		/* pcrel_offset */
d1089 1
a1089 1
	 false),		/* pcrel_offset */
d1100 1
a1100 1
	 "R_SH_GOTPC_LOW16",	/* name */
d1104 1
a1104 1
	 true),			/* pcrel_offset */
d1119 1
a1119 1
	 true),			/* pcrel_offset */
d1134 1
a1134 1
	 true),			/* pcrel_offset */
d1149 1
a1149 1
	 true),			/* pcrel_offset */
d1151 1
a1151 1
  /* Used in LD.L, FLD.S et al.	 */
d1164 1
a1164 1
	 false),		/* pcrel_offset */
d1166 1
a1166 1
  /* Used in LD.L, FLD.S et al.	 */
d1179 1
a1179 1
	 false),		/* pcrel_offset */
d1194 1
a1194 1
	 false),		/* pcrel_offset */
d1209 1
a1209 1
	 false),		/* pcrel_offset */
d1219 1
a1219 1
	 "R_SH_COPY64",		/* name */
d1223 1
a1223 1
	 false),		/* pcrel_offset */
d1233 1
a1233 1
	 "R_SH_GLOB_DAT64",	/* name */
d1237 1
a1237 1
	 false),		/* pcrel_offset */
d1247 1
a1247 1
	 "R_SH_JMP_SLOT64",	/* name */
d1251 1
a1251 1
	 false),		/* pcrel_offset */
d1261 1
a1261 1
	 "R_SH_RELATIVE64",	/* name */
d1265 1
a1265 1
	 false),		/* pcrel_offset */
d1366 1
a1366 1
	 false),		/* pcrel_offset */
d1381 1
a1381 1
	 false),		/* pcrel_offset */
d1392 1
a1392 1
	 "R_SH_IMM_LOW16",	/* name */
d1396 1
a1396 1
	 false),		/* pcrel_offset */
d1426 1
a1426 1
	 false),		/* pcrel_offset */
d1456 1
a1456 1
	 false),		/* pcrel_offset */
d1486 1
a1486 1
	 false),		/* pcrel_offset */
d1512 1
a1512 1
	 "R_SH_64",		/* name */
d1516 1
a1516 1
	 false),		/* pcrel_offset */
d1958 3
a1960 3
	 the register load.  The 4 is because the r_addend field is
	 computed as though it were a jump offset, which are based
	 from 4 bytes after the jump instruction.  */
d1972 1
a1972 1
	 do.  */
d1999 2
a2000 2
	 being loaded.  This reloc will tell us which function is
	 actually being called.  */
d2057 2
a2058 2
		 symbol.  Just ignore it--it will be caught by the
		 regular reloc processing.  */
d2098 1
a2098 1
	 replace the jsr with a bsr.  */
d2103 2
a2104 2
	     it will be handled here like other internal IND12W
	     relocs.  */
d2112 2
a2113 2
	     symbol value may be changed by future relaxing.  We let
	     the final link phase handle it.  */
d2118 1
a2118 1
	 register load.  */
d2133 2
a2134 2
	 function address is stored.  Do this before deleting any
	 bytes, to avoid confusion about the address.  */
d2145 2
a2146 2
	 other function call to come within range, we should relax
	 again.  Note that this is not required, and it may be slow.  */
d2159 1
a2159 1
	 just deleted one.  */
d2171 2
a2172 2
	 the address from irelfn, in case it was changed by the
	 previous call to sh_elf_relax_delete_bytes.  */
d2358 1
a2358 1
	 includes the bytes we have deleted.  */
d2381 3
a2383 3
	     section, and the symbol will not be adjusted below, we
	     must check the addend to see it will put the value in
	     range to be adjusted, and hence must be changed.  */
d2575 2
a2576 2
	 false, we should free them, if we are permitted to, when we
	 leave sh_coff_relax_section.  */
d2600 3
a2602 3
			 Perhaps, if info->keep_memory is false, we
			 should free them, if we are permitted to,
			 when we leave sh_coff_relax_section.  */
d2658 3
a2660 3
			 Perhaps, if info->keep_memory is false, we
			 should free them, if we are permitted to,
			 when we leave sh_coff_relax_section.  */
d2832 2
a2833 2
	 adjust.  These relocs do not apply to the instruction itself,
	 but are only associated with the address.  */
d2842 5
a2846 5
	 swapped, we must adjust it.  It would be incorrect to do this
	 for a jump, though, since we want to execute both
	 instructions after the jump.  (We have avoided swapping
	 around a label, so the jump will not wind up executing an
	 instruction it shouldn't).  */
d2905 5
a2909 5
		 the program counter before adding in the offset.
		 This means that if ADDR is at an even address, the
		 swap will not affect the offset.  If ADDR is an at an
		 odd address, then the instruction will be crossing a
		 four byte boundary, and must be adjusted.  */
d2950 1
a2950 1
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
d2970 1
a2970 1
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
d3351 15
a3365 13
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct elf_sh_dyn_relocs
{
  struct elf_sh_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
a3366 3

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
d3379 2
a3380 2
  /* Track dynamic relocs copied for this symbol.  */
  struct elf_sh_dyn_relocs *dyn_relocs;
d3388 1
d3390 1
a3390 8
  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;
d3392 2
a3393 3
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
};
d3434 1
a3434 4
      struct elf_sh_link_hash_entry *eh;

      eh = (struct elf_sh_link_hash_entry *) ret;
      eh->dyn_relocs = NULL;
a3462 9
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->sym_sec.abfd = NULL;

a3465 33
/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static boolean
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf_sh_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return false;

  htab = sh_elf_hash_table (info);
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (! htab->sgot || ! htab->sgotplt)
    abort ();

  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC
				   | SEC_LOAD
				   | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY
				   | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return false;
  return true;
}

a3472 1
  struct elf_sh_link_hash_table *htab;
a3492 2
  htab = sh_elf_hash_table (info);

a3506 1
  htab->splt = s;
a3532 1
  htab->srelplt = s;
d3538 1
a3538 1
  if (! create_got_section (abfd, info))
a3573 1
      htab->sdynbss = s;
a3593 1
	  htab->srelbss = s;
a3614 3
  struct elf_sh_link_hash_table *htab;
  struct elf_sh_link_hash_entry *eh;
  struct elf_sh_dyn_relocs *p;
d3638 3
a3640 6
      if (h->plt.refcount <= 0
	  || (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
	      && h->root.type != bfd_link_hash_undefweak
	      && h->root.type != bfd_link_hash_undefined))
d3647 2
a3648 2
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d3651 45
a3697 2
  else
    h->plt.offset = (bfd_vma) -1;
a3725 24
  /* If -z nocopyreloc was given, we won't generate them either.  */
  if (info->nocopyreloc)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return true;
    }

  eh = (struct elf_sh_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      s = p->sec->output_section;
      if (s != NULL && (s->flags & (SEC_READONLY | SEC_HAS_CONTENTS)) != 0)
	break;
    }

  /* If we didn't find any dynamic relocs in sections which needs the
     copy reloc, then we'll be keeping the dynamic relocs and avoiding
     the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return true;
    }

d3736 1
a3736 2
  htab = sh_elf_hash_table (info);
  s = htab->sdynbss;
d3747 1
a3747 1
      srel = htab->srelbss;
d3760 2
a3761 1
  s->_raw_size = BFD_ALIGN (s->_raw_size, (bfd_size_type) (1 << power_of_two));
a3777 233
/* This is the condition under which sh_elf_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in sh_elf_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static boolean
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf_sh_link_hash_table *htab;
  struct elf_sh_link_hash_entry *eh;
  struct elf_sh_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return true;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = (struct bfd_link_info *) inf;
  htab = sh_elf_hash_table (info);

  if (htab->root.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
	{
	  asection *s = htab->splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_ENTRY_SIZE;

	  h->plt.offset = s->_raw_size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->_raw_size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  htab->sgotplt->_raw_size += 4;

	  /* We also need to make an entry in the .rel.plt section.  */
	  htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  if (h->got.refcount > 0)
    {
      asection *s;
      boolean dyn;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      s = htab->sgot;
#ifdef INCLUDE_SHMEDIA
      if (h->type == STT_DATALABEL)
	{
	  struct elf_sh_link_hash_entry *hsh;

	  h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  hsh = (struct elf_sh_link_hash_entry *)h;
	  hsh->datalabel_got_offset = s->_raw_size;
	}
      else
	h->got.offset = s->_raw_size;
#else
      h->got.offset = s->_raw_size;
#endif
      s->_raw_size += 4;
      dyn = htab->root.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;

  eh = (struct elf_sh_link_hash_entry *) h;
  if (eh->dyn_relocs == NULL)
    return true;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
	{
	  struct elf_sh_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	      || (htab->root.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return false;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
    }

  return true;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static boolean
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct elf_sh_link_hash_entry *eh;
  struct elf_sh_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  eh = (struct elf_sh_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return false;
	}
    }
  return true;
}

a3784 1
  struct elf_sh_link_hash_table *htab;
d3787 1
a3788 1
  bfd *ibfd;
d3790 1
a3790 2
  htab = sh_elf_hash_table (info);
  dynobj = htab->root.dynobj;
d3793 1
a3793 1
  if (htab->root.dynamic_sections_created)
d3804 33
d3838 3
a3840 9
  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;
d3842 1
a3842 2
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;
d3844 1
a3844 1
      for (s = ibfd->sections; s != NULL; s = s->next)
d3846 7
a3852 6
	  struct elf_sh_dyn_relocs *p;

	  for (p = ((struct elf_sh_dyn_relocs *)
		    elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
d3854 2
a3855 15
	      if (! bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->sec)->sreloc;
		  srel->_raw_size += p->count * sizeof (Elf32_External_Rela);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
d3858 1
a3858 15

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
#ifdef INCLUDE_SHMEDIA
      /* Count datalabel local GOT.  */
      locsymcount *= 2;
#endif
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got)
d3860 1
a3860 1
	  if (*local_got > 0)
d3862 10
a3871 4
	      *local_got = s->_raw_size;
	      s->_raw_size += 4;
	      if (info->shared)
		srel->_raw_size += sizeof (Elf32_External_Rela);
d3874 5
a3878 3
	    *local_got = (bfd_vma) -1;
	}
    }
d3880 4
a3883 27
  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);

  /* We now have determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (s == htab->splt
	  || s == htab->sgot
	  || s == htab->sgotplt)
	{
	  /* Strip this section if we don't need it; see the
	     comment below.  */
	}
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
	{
	  if (s->_raw_size != 0 && s != htab->srelplt)
	    relocs = true;

	  /* We use the reloc_count field as a counter if we need
	     to copy relocs into the output file.  */
	  s->reloc_count = 0;
d3885 1
a3885 1
      else
d3891 1
a3891 1
      if (s->_raw_size == 0)
a3892 10
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */

d3897 3
a3899 7
      /* Allocate memory for the section contents.  We use bfd_zalloc
	 here in case unused entries are not reclaimed before the
	 section's contents are written out.  This should not happen,
	 but this way if it does, we get a R_SH_NONE reloc instead
	 of garbage.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL)
d3903 1
a3903 1
  if (htab->root.dynamic_sections_created)
d3915 1
a3915 1
	  if (! add_dynamic_entry (DT_DEBUG, 0))
d3919 1
a3919 1
      if (htab->splt->_raw_size != 0)
d3921 4
a3924 4
	  if (! add_dynamic_entry (DT_PLTGOT, 0)
	      || ! add_dynamic_entry (DT_PLTRELSZ, 0)
	      || ! add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || ! add_dynamic_entry (DT_JMPREL, 0))
d3930 3
a3932 4
	  if (! add_dynamic_entry (DT_RELA, 0)
	      || ! add_dynamic_entry (DT_RELASZ, 0)
	      || ! add_dynamic_entry (DT_RELAENT,
				      sizeof (Elf32_External_Rela)))
d3934 1
d3936 4
a3939 11
	  /* If any dynamic relocs apply to a read-only section,
	     then we need a DT_TEXTREL entry.  */
	  if ((info->flags & DF_TEXTREL) == 0)
	    elf_link_hash_traverse (&htab->root, readonly_dynrelocs,
				    (PTR) info);

	  if ((info->flags & DF_TEXTREL) != 0)
	    {
	      if (! add_dynamic_entry (DT_TEXTREL, 0))
		return false;
	    }
d3946 27
a3987 1
  struct elf_sh_link_hash_table *htab;
a3997 1
  htab = sh_elf_hash_table (info);
d4000 1
a4000 1
  dynobj = htab->root.dynobj;
d4003 3
a4005 3
  sgot = htab->sgot;
  sgotplt = htab->sgotplt;
  splt = htab->splt;
d4028 1
a4028 1
	 handled entirely by the relaxation code.  */
d4053 1
a4053 1
	 the relocation.  */
d4132 3
a4134 3
	      addend = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      msec = sec;
	      addend =
a4164 3
	      boolean dyn;

	      dyn = htab->root.dynamic_sections_created;
d4185 1
a4185 1
		      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d4200 2
a4201 2
			   && (h->elf_link_hash_flags
			       & ELF_LINK_FORCED_LOCAL) == 0)
d4208 1
a4208 3
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))))
d4231 2
a4232 3
		   && (! info->symbolic || info->allow_shlib_undefined)
		   && ! info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d4238 1
a4238 3
		      input_section, rel->r_offset,
		      (!info->shared || info->no_undefined
		       || ELF_ST_VISIBILITY (h->other)))))
d4419 2
a4420 1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d4430 5
a4435 1
	  BFD_ASSERT (sgotplt != NULL);
d4458 5
a4462 2

	  BFD_ASSERT (sgot != NULL);
a4466 1
	      boolean dyn;
d4480 1
a4480 2
	      dyn = htab->root.dynamic_sections_created;
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d4483 2
a4484 1
			  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
d4588 1
a4588 1
	  relocation -= GOT_BIAS;
d4603 5
a4607 1
	  BFD_ASSERT (sgot != NULL);
d4633 6
a4638 1
	  BFD_ASSERT (sgot != NULL);
d4664 2
a4665 1
	  if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d4676 6
a4681 1
	  BFD_ASSERT (splt != NULL);
a4874 5
#ifdef INCLUDE_SHMEDIA
	  while (h->root.type == bfd_link_hash_indirect
		 && h->root.u.i.link)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
#endif
d4899 4
a4902 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d4904 4
a4907 124
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_SH_GOT32:
      case R_SH_GOTOFF:
      case R_SH_GOTPC:
#ifdef INCLUDE_SHMEDIA
      case R_SH_GOT_LOW16:
      case R_SH_GOT_MEDLOW16:
      case R_SH_GOT_MEDHI16:
      case R_SH_GOT_HI16:
      case R_SH_GOT10BY4:
      case R_SH_GOT10BY8:
      case R_SH_GOTOFF_LOW16:
      case R_SH_GOTOFF_MEDLOW16:
      case R_SH_GOTOFF_MEDHI16:
      case R_SH_GOTOFF_HI16:
      case R_SH_GOTPC_LOW16:
      case R_SH_GOTPC_MEDLOW16:
      case R_SH_GOTPC_MEDHI16:
      case R_SH_GOTPC_HI16:
#endif
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;

      case R_SH_DIR32:
      case R_SH_REL32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf_sh_link_hash_entry *eh;
	    struct elf_sh_dyn_relocs **pp;
	    struct elf_sh_dyn_relocs *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	    if (!info->shared && h->plt.refcount > 0)
	      h->plt.refcount -= 1;

	    eh = (struct elf_sh_link_hash_entry *) h;

	    for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	      if (p->sec == sec)
		{
		  if (ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
		    p->pc_count -= 1;
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
		}
	  }
	break;

      case R_SH_PLT32:
#ifdef INCLUDE_SHMEDIA
      case R_SH_PLT_LOW16:
      case R_SH_PLT_MEDLOW16:
      case R_SH_PLT_MEDHI16:
      case R_SH_PLT_HI16:
#endif
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	break;

      case R_SH_GOTPLT32:
#ifdef INCLUDE_SHMEDIA
      case R_SH_GOTPLT_LOW16:
      case R_SH_GOTPLT_MEDLOW16:
      case R_SH_GOTPLT_MEDHI16:
      case R_SH_GOTPLT_HI16:
      case R_SH_GOTPLT10BY4:
      case R_SH_GOTPLT10BY8:
#endif
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;

      default:
	break;
      }

a4910 48
/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
sh_elf_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
{
  struct elf_sh_link_hash_entry *edir, *eind;

  edir = (struct elf_sh_link_hash_entry *) dir;
  eind = (struct elf_sh_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf_sh_dyn_relocs **pp;
	  struct elf_sh_dyn_relocs *p;

	  BFD_ASSERT (ind->root.type != bfd_link_hash_indirect);

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf_sh_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

a4923 1
  struct elf_sh_link_hash_table *htab;
d4945 1
a4945 2
  htab = sh_elf_hash_table (info);
  dynobj = htab->root.dynobj;
d4961 1
a4961 1
      if (htab->sgot == NULL)
d4991 2
a4992 3
	      if (dynobj == NULL)
		htab->root.dynobj = dynobj = abfd;
	      if (! create_got_section (dynobj, info))
d5002 3
a5004 3
	{
	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
d5010 2
a5011 2
	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
d5027 28
d5056 35
a5090 1
	    h->got.refcount += 1;
a5092 2
	      bfd_signed_vma *local_got_refcounts;

d5094 2
a5095 3
		 symbol.  */
	      local_got_refcounts = elf_local_got_refcounts (abfd);
	      if (local_got_refcounts == NULL)
d5098 1
d5101 1
a5101 1
		  size *= sizeof (bfd_signed_vma);
d5107 2
a5108 3
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
		  if (local_got_refcounts == NULL)
d5110 39
a5148 1
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
a5149 1
	      local_got_refcounts[r_symndx] += 1;
d5151 3
d5169 2
a5170 1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d5173 2
a5174 1
	      || h->dynindx == -1)
d5177 7
a5184 1
	  h->plt.refcount += 1;
d5207 2
a5208 1
	  if (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)
d5212 1
a5212 1
	  h->plt.refcount += 1;
d5217 2
a5218 5
	  if (h != NULL && ! info->shared)
	    {
	      h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
	      h->plt.refcount += 1;
	    }
d5231 8
a5238 22
	     dyn_relocs field of the hash table entry. A similar
	     situation occurs when creating shared libraries and symbol
	     visibility changes render the symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (sec->flags & SEC_ALLOC) != 0
	       && (ELF32_R_TYPE (rel->r_info) != R_SH_REL32
		   || (h != NULL
		       && (! info->symbolic
			   || h->root.type == bfd_link_hash_defweak
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
	      || (! info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
a5239 6
	      struct elf_sh_dyn_relocs *p;
	      struct elf_sh_dyn_relocs **head;

	      if (dynobj == NULL)
		htab->root.dynobj = dynobj = abfd;

a5274 1
		  elf_section_data (sec)->sreloc = sreloc;
d5277 12
a5288 5
	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		head = &((struct elf_sh_link_hash_entry *) h)->dyn_relocs;
	      else
d5290 2
a5291 1
		  asection *s;
d5293 1
a5293 5
		  /* Track dynamic relocs needed for local syms too.  */
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return false;
d5295 3
a5297 3
		  head = ((struct elf_sh_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
		}
a5298 5
	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof (*p);
		  p = ((struct elf_sh_dyn_relocs *) bfd_alloc (dynobj, amt));
d5300 12
a5311 6
		    return false;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
a5312 4

	      p->count += 1;
	      if (ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
		p->pc_count += 1;
a5445 1
  struct elf_sh_link_hash_table *htab;
d5448 1
a5448 2
  htab = sh_elf_hash_table (info);
  dynobj = htab->root.dynobj;
d5465 3
a5467 3
      splt = htab->splt;
      sgot = htab->sgotplt;
      srel = htab->srelplt;
d5482 1
a5482 2
      if (info->shared)
	got_offset -= GOT_BIAS;
a5502 1
	  /* Set bottom bit because its for a branch to SHmedia */
d5504 1
a5504 2
			     (splt->output_section->vma + splt->output_offset)
			     | 1,
d5543 1
a5543 2
      if (info->shared)
	got_offset += GOT_BIAS;
d5595 2
a5596 2
      sgot = htab->sgot;
      srel = htab->srelgot;
d5603 3
a5605 3
      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
d5609 1
a5609 3
	  && (info->symbolic
	      || h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
a5670 1
  struct elf_sh_link_hash_table *htab;
d5675 1
a5675 2
  htab = sh_elf_hash_table (info);
  dynobj = htab->root.dynobj;
d5677 2
a5678 1
  sgot = htab->sgotplt;
d5681 1
a5681 1
  if (htab->root.dynamic_sections_created)
d5686 1
a5686 1
      BFD_ASSERT (sgot != NULL && sdyn != NULL);
d5693 1
a5694 3
#ifdef INCLUDE_SHMEDIA
	  const char *name;
#endif
a5702 23
#ifdef INCLUDE_SHMEDIA
	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;

	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      if (dyn.d_un.d_val != 0)
		{
		  struct elf_link_hash_entry *h;

		  h = elf_link_hash_lookup (&htab->root, name,
					    false, false, true);
		  if (h != NULL && (h->other & STO_SH5_ISA32))
		    {
		      dyn.d_un.d_val |= 1;
		      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		    }
		}
	      break;
#endif

d5704 1
a5704 1
	      s = htab->sgot->output_section;
d5708 1
a5708 1
	      s = htab->srelplt->output_section;
d5710 1
d5717 1
a5717 1
	      s = htab->srelplt->output_section;
d5736 2
a5737 1
	      if (htab->srelplt != NULL)
a5738 1
		  s = htab->srelplt->output_section;
d5750 1
a5750 1
      splt = htab->splt;
d5796 1
a5796 1
  if (sgot && sgot->_raw_size > 0)
d5806 1
d5808 1
a5808 2
      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
    }
d5856 5
a5860 5
#define elf_backend_gc_mark_hook	sh_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	sh_elf_gc_sweep_hook
#define elf_backend_check_relocs	sh_elf_check_relocs
#define elf_backend_copy_indirect_symbol \
					sh_elf_copy_indirect_symbol
a5874 2
#define elf_backend_can_gc_sections	1
#define elf_backend_can_refcount	1
a5879 2

#ifndef ELF32_SH_C_INCLUDED
a5880 2
#endif

@


1.47.6.4
log
@merge from mainline
@
text
@a61 6
static int sh_elf_optimized_tls_reloc
  PARAMS ((struct bfd_link_info *, int, int));
static boolean sh_elf_mkobject
  PARAMS((bfd *));
static boolean sh_elf_object_p
  PARAMS((bfd *));
a84 2
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
a99 4
static boolean elf32_shlin_grok_prstatus
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));
static boolean elf32_shlin_grok_psinfo
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));
d716 8
a723 113

  HOWTO (R_SH_TLS_GD_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_GD_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LD_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LD_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LDO_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LDO_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_IE_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_IE_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_LE_32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_LE_32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_DTPMOD32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_DTPMOD32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_DTPOFF32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_DTPOFF32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_TLS_TPOFF32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* */
	 "R_SH_TLS_TPOFF32",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

a1778 8
  { BFD_RELOC_SH_TLS_GD_32, R_SH_TLS_GD_32 },
  { BFD_RELOC_SH_TLS_LD_32, R_SH_TLS_LD_32 },
  { BFD_RELOC_SH_TLS_LDO_32, R_SH_TLS_LDO_32 },
  { BFD_RELOC_SH_TLS_IE_32, R_SH_TLS_IE_32 },
  { BFD_RELOC_SH_TLS_LE_32, R_SH_TLS_LE_32 },
  { BFD_RELOC_SH_TLS_DTPMOD32, R_SH_TLS_DTPMOD32 },
  { BFD_RELOC_SH_TLS_DTPOFF32, R_SH_TLS_DTPOFF32 },
  { BFD_RELOC_SH_TLS_TPOFF32, R_SH_TLS_TPOFF32 },
a1876 1
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC_5 || r > R_SH_LAST_INVALID_RELOC_5);
d3050 1
a3050 1
  0x00, 0xc8, 0x45, 0x10, /* add.l r12, r17, r17 */
d3070 1
a3070 1
  0x10, 0x45, 0xc8, 0x00, /* add.l r12, r17, r17 */
d3386 1
a3386 5
  union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } datalabel_got;
a3390 19

  bfd_signed_vma gotplt_refcount;

  enum {
    GOT_UNKNOWN = 0, GOT_NORMAL, GOT_TLS_GD, GOT_TLS_IE
  } tls_type;

  /* If true, R_SH_TLS_TPOFF32 relocation is generated.  */
  boolean tls_tpoff32;
};

#define sh_elf_hash_entry(ent) ((struct elf_sh_link_hash_entry *)(ent))

struct sh_elf_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
a3392 20
#define sh_elf_tdata(abfd) \
  ((struct sh_elf_obj_tdata *) (abfd)->tdata.any)

#define sh_elf_local_got_tls_type(abfd) \
  (sh_elf_tdata (abfd)->local_got_tls_type)

/* Override the generic function because we need to store sh_elf_obj_tdata
   as the specific tdata.  */

static boolean
sh_elf_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (struct sh_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return false;
  return true;
}
                 
a3409 7

  /* A counter or offset to track a TLS got entry.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } tls_ldm_got;
d3451 4
a3454 2
      ret->dyn_relocs = NULL;
      ret->gotplt_refcount = 0;
d3456 1
a3456 1
      ret->datalabel_got.refcount = ret->root.got.refcount;
a3457 2
      ret->tls_type = GOT_UNKNOWN;
      ret->tls_tpoff32 = false;
a3490 1
  ret->tls_ldm_got.refcount = 0;
d3582 1
a3582 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d3586 2
a3587 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a3588 2

      h = (struct elf_link_hash_entry *) bh;
a3869 12
  eh = (struct elf_sh_link_hash_entry *) h;
  if ((h->got.refcount > 0
      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
      && eh->gotplt_refcount > 0)
    {
      /* The symbol has been forced local, or we have some direct got refs,
         so treat all the gotplt refs as got refs. */
      h->got.refcount += eh->gotplt_refcount;
      if (h->plt.refcount >= eh->gotplt_refcount)
	h->plt.refcount -= eh->gotplt_refcount;
    }

a3930 1
      int tls_type = sh_elf_hash_entry (h)->tls_type;
a3941 19
      h->got.offset = s->_raw_size;
      s->_raw_size += 4;
      /* R_SH_TLS_GD needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->_raw_size += 4;
      dyn = htab->root.dynamic_sections_created;
      /* R_SH_TLS_IE_32 needs one dynamic relocation,
	 R_SH_TLS_GD needs one if local symbol and two if global.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type == GOT_TLS_IE)
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->srelgot->_raw_size += 2 * sizeof (Elf32_External_Rela);
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;

d3943 3
a3945 4
  if (eh->datalabel_got.refcount > 0)
    {
      asection *s;
      boolean dyn;
d3947 3
a3949 7
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
d3951 5
a3955 3

      s = htab->sgot;
      eh->datalabel_got.offset = s->_raw_size;
d3962 1
a3962 2
    eh->datalabel_got.offset = (bfd_vma) -1;
#endif
d3964 1
a3994 3
      if (sh_elf_hash_entry (h)->tls_tpoff32)
	goto keep;

a4101 1
      char *local_tls_type;
a4146 1
      local_tls_type = sh_elf_local_got_tls_type (ibfd);
a4154 2
	      if (*local_tls_type == GOT_TLS_GD)
		s->_raw_size += 4;
a4159 1
	  ++local_tls_type;
a4162 11
  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_SH_TLS_LD_32
	 relocs.  */
      htab->tls_ldm_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 8;
      htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

a4297 1
  asection *srelgot;
a4308 1
  srelgot = NULL;
a4323 2
      bfd_vma off;
      int tls_type;
a4344 2
	  || (   r_type >= (int) R_SH_FIRST_INVALID_RELOC_5
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC_5)
d4515 1
a4515 4
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0)))
		  || (sec->output_section == NULL
		      && (sh_elf_hash_entry (h)->tls_type == GOT_TLS_IE
			  || sh_elf_hash_entry (h)->tls_type == GOT_TLS_GD)))
d4520 1
a4520 1
		    (_("%s: unresolvable relocation against symbol `%s' from %s section"),
d4523 1
a4523 1
		  return false;
d4768 1
d4778 1
a4778 1
		  off = hsh->datalabel_got.offset;
d4814 1
a4814 1
			  hsh->datalabel_got.offset |= 1;
d4826 2
d4861 1
d4864 2
a4865 6
		      if (srelgot == NULL)
			{
			  srelgot = bfd_get_section_by_name (dynobj,
							     ".rela.got");
			  BFD_ASSERT (srelgot != NULL);
			}
d4999 1
d5001 11
a5011 26
	case R_SH_TLS_GD_32:
	case R_SH_TLS_IE_32:
	  r_type = sh_elf_optimized_tls_reloc (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = sh_elf_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = sh_elf_hash_entry (h)->tls_type;
	      if (! info->shared
		  && (h->dynindx == -1
		      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  && (tls_type == GOT_TLS_IE
		      || sh_elf_hash_entry (h)->tls_tpoff32))
		r_type = R_SH_TLS_LE_32;
	    }

	  if (r_type == R_SH_TLS_GD_32 && tls_type == GOT_TLS_IE)
	    r_type = R_SH_TLS_IE_32;

	  if (r_type == R_SH_TLS_LE_32)
	    {
	      bfd_vma offset;
	      unsigned short insn;
	      int indx;
	      Elf_Internal_Rela outrel;
d5013 20
a5032 22
	      if (ELF32_R_TYPE (rel->r_info) == R_SH_TLS_GD_32)
		{
		  /* GD->LE transition:
		       mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		       jsr @@r1; add r12,r4; bra 3f; nop; .align 2; 
		       1: .long x$TLSGD; 2: .long __tls_get_addr@@PLT; 3:
		     We change it into:
		       mov.l 1f,r4; stc gbr,r0; add r4,r0; nop;
		       nop; nop; ...
		       1: .long x@@TPOFF; 2: .long __tls_get_addr@@PLT; 3:.  */

		  offset = rel->r_offset;
		  BFD_ASSERT (offset >= 16);
		  /* Size of GD instructions is 16 or 18.  */
		  offset -= 16;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		  if ((insn & 0xff00) == 0xc700)
		    {
		      BFD_ASSERT (offset >= 2);
		      offset -= 2;
		      insn = bfd_get_16 (input_bfd, contents + offset + 0);
		    }
d5034 2
a5035 21
		  BFD_ASSERT ((insn & 0xff00) == 0xd400);
		  insn = bfd_get_16 (input_bfd, contents + offset + 2);
		  BFD_ASSERT ((insn & 0xff00) == 0xc700);
		  insn = bfd_get_16 (input_bfd, contents + offset + 4);
		  BFD_ASSERT ((insn & 0xff00) == 0xd100);
		  insn = bfd_get_16 (input_bfd, contents + offset + 6);
		  BFD_ASSERT (insn == 0x310c);
		  insn = bfd_get_16 (input_bfd, contents + offset + 8);
		  BFD_ASSERT (insn == 0x410b);
		  insn = bfd_get_16 (input_bfd, contents + offset + 10);
		  BFD_ASSERT (insn == 0x34cc);

		  bfd_put_16 (output_bfd, 0x0012, contents + offset + 2);
		  bfd_put_16 (output_bfd, 0x304c, contents + offset + 4);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 6);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);
		}
	      else
		{
		  int index;
d5037 2
a5038 18
		  /* IE->LE transition:
		     mov.l 1f,r0; stc gbr,rN; mov.l @@(r0,r12),rM;
		     bra 2f; add ...; .align 2; 1: x@@GOTTPOFF; 2:
		     We change it into:
		     mov.l .Ln,rM; stc gbr,rN; nop; ...;
		     1: x@@TPOFF; 2:.  */

		  offset = rel->r_offset;
		  BFD_ASSERT (offset >= 16);
		  /* Size of IE instructions is 10 or 12.  */
		  offset -= 10;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		  if ((insn & 0xf0ff) == 0x0012)
		    {
		      BFD_ASSERT (offset >= 2);
		      offset -= 2;
		      insn = bfd_get_16 (input_bfd, contents + offset + 0);
		    }
d5040 16
a5055 10
		  BFD_ASSERT ((insn & 0xff00) == 0xd000);
		  index = insn & 0x00ff;
		  insn = bfd_get_16 (input_bfd, contents + offset + 2);
		  BFD_ASSERT ((insn & 0xf0ff) == 0x0012);
		  insn = bfd_get_16 (input_bfd, contents + offset + 4);
		  BFD_ASSERT ((insn & 0xf0ff) == 0x00ce);
		  insn = 0xd000 | (insn & 0x0f00) | index;
		  bfd_put_16 (output_bfd, insn, contents + offset + 0);
		  bfd_put_16 (output_bfd, 0x0009, contents + offset + 4);
		}
d5057 8
a5064 3
	      if (sreloc == NULL)
		{
		  const char *name;
d5066 1
a5066 6
		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;
d5068 2
a5069 4
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);
d5071 6
a5076 3
		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
		}
d5078 4
a5081 404
	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	      outrel.r_offset = (input_section->output_section->vma
				 + input_section->output_offset
				 + rel->r_offset);
	      outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;

	      continue;
	    }

	  sgot = htab->sgot;
	  if (sgot == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	  if ((off & 1) != 0)
	    off &= ~1;
          else
	    {
	      Elf_Internal_Rela outrel;
	      Elf32_External_Rela *loc;
	      int dr_type, indx;

	      if (srelgot == NULL)
		{
		  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
		  BFD_ASSERT (srelgot != NULL);
		}

	      outrel.r_offset = (sgot->output_section->vma
				 + sgot->output_offset + off);

	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	      dr_type = (r_type == R_SH_TLS_GD_32 ? R_SH_TLS_DTPMOD32 :
			 R_SH_TLS_TPOFF32);
	      if (dr_type == R_SH_TLS_TPOFF32 && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      outrel.r_info = ELF32_R_INFO (indx, dr_type);
	      loc = (Elf32_External_Rela *) srelgot->contents;
	      loc += srelgot->reloc_count++;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      if (r_type == R_SH_TLS_GD_32)
		{
		  if (indx == 0)
		    {
		      bfd_put_32 (output_bfd,
				  relocation - dtpoff_base (info),
				  sgot->contents + off + 4);
		    }
		  else
		    {
		      outrel.r_info = ELF32_R_INFO (indx,
						    R_SH_TLS_DTPOFF32);
		      outrel.r_offset += 4;
		      outrel.r_addend = 0;
		      srelgot->reloc_count++;
		      loc++;
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						loc);
		    }
		}

	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();

	  if (r_type == (int) ELF32_R_TYPE (rel->r_info))
	    relocation = sgot->output_offset + off;
	  else
	    {
	      bfd_vma offset;
	      unsigned short insn;

	      /* GD->IE transition:
		   mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		   jsr @@r1; add r12,r4; bra 3f; nop; .align 2;
		   1: .long x$TLSGD; 2: .long __tls_get_addr@@PLT; 3:
		 We change it into:
		   mov.l 1f,r0; stc gbr,r4; mov.l @@(r0,r12),r0; add r4,r0;
		   nop; nop; bra 3f; nop; .align 2;
		   1: .long x@@TPOFF; 2:...; 3:.  */

	      offset = rel->r_offset;
	      BFD_ASSERT (offset >= 16);
	      /* Size of GD instructions is 16 or 18.  */
	      offset -= 16;
	      insn = bfd_get_16 (input_bfd, contents + offset + 0);
	      if ((insn & 0xff00) == 0xc700)
		{
		  BFD_ASSERT (offset >= 2);
		  offset -= 2;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		}

	      BFD_ASSERT ((insn & 0xff00) == 0xd400);

	      /* Replace mov.l 1f,R4 with mov.l 1f,r0.  */
	      bfd_put_16 (output_bfd, insn & 0xf0ff, contents + offset);

	      insn = bfd_get_16 (input_bfd, contents + offset + 2);
	      BFD_ASSERT ((insn & 0xff00) == 0xc700);
	      insn = bfd_get_16 (input_bfd, contents + offset + 4);
	      BFD_ASSERT ((insn & 0xff00) == 0xd100);
	      insn = bfd_get_16 (input_bfd, contents + offset + 6);
	      BFD_ASSERT (insn == 0x310c);
	      insn = bfd_get_16 (input_bfd, contents + offset + 8);
	      BFD_ASSERT (insn == 0x410b);
	      insn = bfd_get_16 (input_bfd, contents + offset + 10);
	      BFD_ASSERT (insn == 0x34cc);

	      bfd_put_16 (output_bfd, 0x0412, contents + offset + 2);
	      bfd_put_16 (output_bfd, 0x00ce, contents + offset + 4);
	      bfd_put_16 (output_bfd, 0x304c, contents + offset + 6);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);

	      bfd_put_32 (output_bfd, sgot->output_offset + off,
			  contents + rel->r_offset);

	      continue;
	  }

	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_TLS_LD_32:
	  if (! info->shared)
	    {
	      bfd_vma offset;
	      unsigned short insn;

	      /* LD->LE transition:
		   mov.l 1f,r4; mova 2f,r0; mov.l 2f,r1; add r0,r1;
		   jsr @@r1; add r12,r4; bra 3f; nop; .align 2;
		   1: .long x$TLSLD; 2: .long __tls_get_addr@@PLT; 3:
		 We change it into:
		   stc gbr,r0; nop; nop; nop;
		   nop; nop; bra 3f; ...; 3:.  */

	      offset = rel->r_offset;
	      BFD_ASSERT (offset >= 16);
	      /* Size of LD instructions is 16 or 18.  */
	      offset -= 16;
	      insn = bfd_get_16 (input_bfd, contents + offset + 0);
	      if ((insn & 0xff00) == 0xc700)
		{
		  BFD_ASSERT (offset >= 2);
		  offset -= 2;
		  insn = bfd_get_16 (input_bfd, contents + offset + 0);
		}

	      BFD_ASSERT ((insn & 0xff00) == 0xd400);
	      insn = bfd_get_16 (input_bfd, contents + offset + 2);
	      BFD_ASSERT ((insn & 0xff00) == 0xc700);
	      insn = bfd_get_16 (input_bfd, contents + offset + 4);
	      BFD_ASSERT ((insn & 0xff00) == 0xd100);
	      insn = bfd_get_16 (input_bfd, contents + offset + 6);
	      BFD_ASSERT (insn == 0x310c);
	      insn = bfd_get_16 (input_bfd, contents + offset + 8);
	      BFD_ASSERT (insn == 0x410b);
	      insn = bfd_get_16 (input_bfd, contents + offset + 10);
	      BFD_ASSERT (insn == 0x34cc);

	      bfd_put_16 (output_bfd, 0x0012, contents + offset + 0);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 2);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 4);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 6);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 8);
	      bfd_put_16 (output_bfd, 0x0009, contents + offset + 10);

	      continue;
	    }

	  sgot = htab->sgot;
	  if (sgot == NULL)
	    abort ();

	  off = htab->tls_ldm_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      Elf32_External_Rela *loc;

	      srelgot = htab->srelgot;
	      if (srelgot == NULL)
		abort ();

	      outrel.r_offset = (sgot->output_section->vma
				 + sgot->output_offset + off);
	      outrel.r_addend = 0;
	      outrel.r_info = ELF32_R_INFO (0, R_SH_TLS_DTPMOD32);
	      loc = (Elf32_External_Rela *) srelgot->contents;
	      loc += srelgot->reloc_count++;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ldm_got.offset |= 1;
	    }

	  relocation = sgot->output_offset + off;
	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_TLS_LDO_32:
	  if (! info->shared)
	    {
	      int indx;
	      Elf_Internal_Rela outrel;

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
		}

	      indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	      outrel.r_offset = (input_section->output_section->vma
				 + input_section->output_offset
				 + rel->r_offset);
	      outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;

	      continue;
	    }
	  else
	    relocation -= dtpoff_base (info);

	  addend = rel->r_addend;
	  goto final_link_relocate;

	case R_SH_TLS_LE_32:
	  {
	    int indx;
	    Elf_Internal_Rela outrel;

	    if (sreloc == NULL)
	      {
		const char *name;

		name = (bfd_elf_string_from_elf_section
			(input_bfd,
			 elf_elfheader (input_bfd)->e_shstrndx,
			 elf_section_data (input_section)->rel_hdr.sh_name));
		if (name == NULL)
		  return false;

		BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			    && strcmp (bfd_get_section_name (input_bfd,
							     input_section),
				       name + 5) == 0);

		sreloc = bfd_get_section_by_name (dynobj, name);
		BFD_ASSERT (sreloc != NULL);
	      }

	    indx = (h && h->dynindx != -1) ? h->dynindx : 0;
	    outrel.r_offset = (input_section->output_section->vma
			       + input_section->output_offset
			       + rel->r_offset);
	    outrel.r_info = ELF32_R_INFO (indx, R_SH_TLS_TPOFF32);
	    if (indx == 0)
	      outrel.r_addend = relocation - dtpoff_base (info);
	    else
	      outrel.r_addend = 0;
	    bfd_elf32_swap_reloca_out (output_bfd, &outrel,
				       (((Elf32_External_Rela *)
					 sreloc->contents)
					+ sreloc->reloc_count));
	    ++sreloc->reloc_count;

	    continue;
	  }
	}

    relocation_done:
      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = h->root.root.string;
		else
		  {
		    name = (bfd_elf_string_from_elf_section
			    (input_bfd, symtab_hdr->sh_link, sym->st_name));
		    if (name == NULL)
		      return false;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rel->r_offset)))
		  return false;
	      }
	      break;
	    }
	}
    }

  return true;
}

/* This is a version of bfd_generic_get_relocated_section_contents
   which uses sh_elf_relocate_section.  */

static bfd_byte *
sh_elf_get_relocated_section_contents (output_bfd, link_info, link_order,
				       data, relocateable, symbols)
     bfd *output_bfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     boolean relocateable;
     asymbol **symbols;
{
  Elf_Internal_Shdr *symtab_hdr;
  asection *input_section = link_order->u.indirect.section;
  bfd *input_bfd = input_section->owner;
  asection **sections = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Sym *isymbuf = NULL;

  /* We only need to handle the case of relaxing, or of having a
     particular set of section contents, specially.  */
  if (relocateable
      || elf_section_data (input_section)->this_hdr.contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
						       link_order, data,
						       relocateable,
						       symbols);

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  memcpy (data, elf_section_data (input_section)->this_hdr.contents,
	  (size_t) input_section->_raw_size);

  if ((input_section->flags & SEC_RELOC) != 0
      && input_section->reloc_count > 0)
    {
      asection **secpp;
      Elf_Internal_Sym *isym, *isymend;
      bfd_size_type amt;

      internal_relocs = (_bfd_elf32_link_read_relocs
			 (input_bfd, input_section, (PTR) NULL,
			  (Elf_Internal_Rela *) NULL, false));
      if (internal_relocs == NULL)
a5145 14
/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (info)
     struct bfd_link_info *info;
{
 /* If tls_segment is NULL, we should have signalled an error already.  */
 if (elf_hash_table (info)->tls_segment == NULL)
   return 0;
  return elf_hash_table (info)->tls_segment->start;
}

a5202 1
  struct elf_sh_link_hash_entry *eh;
d5212 20
a5231 3
    {
#ifdef INCLUDE_SHMEDIA
      int seen_stt_datalabel = 0;
d5233 24
d5258 2
a5259 16
      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
#ifdef INCLUDE_SHMEDIA
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    {
	      seen_stt_datalabel |= h->type == STT_DATALABEL;
	      h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
#endif
	}
      eh = (struct elf_sh_link_hash_entry *) h;
d5261 1
a5261 8
      switch (sh_elf_optimized_tls_reloc (info, ELF32_R_TYPE (rel->r_info),
					  ELF32_R_SYM (rel->r_info)
					  >= symtab_hdr->sh_info))
	{
	case R_SH_TLS_LD_32:
	  if (sh_elf_hash_table (info)->tls_ldm_got.refcount > 0)
	    sh_elf_hash_table (info)->tls_ldm_got.refcount -= 1;
	  break;
d5263 2
a5264 25
	case R_SH_GOT32:
	case R_SH_GOTOFF:
	case R_SH_GOTPC:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOT_LOW16:
	case R_SH_GOT_MEDLOW16:
	case R_SH_GOT_MEDHI16:
	case R_SH_GOT_HI16:
	case R_SH_GOT10BY4:
	case R_SH_GOT10BY8:
	case R_SH_GOTOFF_LOW16:
	case R_SH_GOTOFF_MEDLOW16:
	case R_SH_GOTOFF_MEDHI16:
	case R_SH_GOTOFF_HI16:
	case R_SH_GOTPC_LOW16:
	case R_SH_GOTPC_MEDLOW16:
	case R_SH_GOTPC_MEDHI16:
	case R_SH_GOTPC_HI16:
#endif
	case R_SH_TLS_GD_32:
	case R_SH_TLS_IE_32:
	  if (h != NULL)
	    {
#ifdef INCLUDE_SHMEDIA
	      if (seen_stt_datalabel)
d5266 6
a5271 2
		  if (eh->datalabel_got.refcount > 0)
		    eh->datalabel_got.refcount -= 1;
d5273 2
a5274 43
	      else
#endif
		if (h->got.refcount > 0)
		  h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
#ifdef INCLUDE_SHMEDIA
	      if (rel->r_addend & 1)
		{
		  if (local_got_refcounts[symtab_hdr->sh_info + r_symndx] > 0)
		    local_got_refcounts[symtab_hdr->sh_info + r_symndx] -= 1;
		}
	      else
#endif
		if (local_got_refcounts[r_symndx] > 0)
		  local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	case R_SH_DIR32:
	case R_SH_REL32:
	  if (h != NULL)
	    {
	      struct elf_sh_dyn_relocs **pp;
	      struct elf_sh_dyn_relocs *p;


	      if (!info->shared && h->plt.refcount > 0)
		h->plt.refcount -= 1;

	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    if (ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
		      p->pc_count -= 1;
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	    }
	  break;
d5276 1
a5276 1
	case R_SH_PLT32:
d5278 4
a5281 4
	case R_SH_PLT_LOW16:
	case R_SH_PLT_MEDLOW16:
	case R_SH_PLT_MEDHI16:
	case R_SH_PLT_HI16:
d5283 8
a5290 6
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;
d5292 1
a5292 29
	case R_SH_GOTPLT32:
#ifdef INCLUDE_SHMEDIA
	case R_SH_GOTPLT_LOW16:
	case R_SH_GOTPLT_MEDLOW16:
	case R_SH_GOTPLT_MEDHI16:
	case R_SH_GOTPLT_HI16:
	case R_SH_GOTPLT10BY4:
	case R_SH_GOTPLT10BY8:
#endif
	  if (h != NULL)
	    {
	      if (eh->gotplt_refcount > 0)
		{
		  eh->gotplt_refcount -= 1;
		  if (h->plt.refcount > 0)
		    h->plt.refcount -= 1;
		}
#ifdef INCLUDE_SHMEDIA
	      else if (seen_stt_datalabel)
		{
		  if (eh->datalabel_got.refcount > 0)
		    eh->datalabel_got.refcount -= 1;
		}
#endif
	      else if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
d5294 6
a5299 6
	      if (rel->r_addend & 1)
		{
		  if (local_got_refcounts[symtab_hdr->sh_info + r_symndx] > 0)
		    local_got_refcounts[symtab_hdr->sh_info + r_symndx] -= 1;
		}
	      else
d5301 15
a5315 4
		if (local_got_refcounts[r_symndx] > 0)
		  local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d5317 3
a5319 4
	default:
	  break;
	}
    }
a5331 3
#ifdef INCLUDE_SHMEDIA
  bfd_signed_vma tmp;
#endif
a5367 19
  edir->gotplt_refcount = eind->gotplt_refcount;
  eind->gotplt_refcount = 0;
#ifdef INCLUDE_SHMEDIA
  tmp = edir->datalabel_got.refcount;
  if (tmp < 1)
    {
      edir->datalabel_got.refcount = eind->datalabel_got.refcount;
      eind->datalabel_got.refcount = tmp;
    }
  else
    BFD_ASSERT (eind->datalabel_got.refcount < 1);
#endif

  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }
a5371 23
static int
sh_elf_optimized_tls_reloc (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_SH_TLS_GD_32:
    case R_SH_TLS_IE_32:
      if (is_local)
	return R_SH_TLS_LE_32;
      return R_SH_TLS_IE_32;
    case R_SH_TLS_LD_32:
      return R_SH_TLS_LE_32;
    }

  return r_type;
}

a5392 2
  unsigned int r_type;
  int tls_type, old_tls_type;
a5415 3
#ifdef INCLUDE_SHMEDIA
      int seen_stt_datalabel = 0;
#endif
a5417 2
      r_type = ELF32_R_TYPE (rel->r_info);

d5421 1
a5421 21
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
#ifdef INCLUDE_SHMEDIA
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    {
	      seen_stt_datalabel |= h->type == STT_DATALABEL;
	      h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
#endif
	}

      r_type = sh_elf_optimized_tls_reloc (info, r_type, h == NULL);
      if (! info->shared
	  && r_type == R_SH_TLS_IE_32
	  && h != NULL
	  && h->root.type != bfd_link_hash_undefined
	  && h->root.type != bfd_link_hash_undefweak
	  && (h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	r_type = R_SH_TLS_LE_32;
d5426 1
a5426 1
	  switch (r_type)
a5453 3
	    case R_SH_TLS_GD_32:
	    case R_SH_TLS_LD_32:
	    case R_SH_TLS_IE_32:
d5465 1
a5465 1
      switch (r_type)
a5481 6
	case R_SH_TLS_IE_32:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;

	  /* FALLTHROUGH */
	case R_SH_TLS_GD_32:
a5490 13
	  switch (r_type)
	    {
	    default:
	      tls_type = GOT_NORMAL;
	      break;
	    case R_SH_TLS_GD_32:
	      tls_type = GOT_TLS_GD;
	      break;
	    case R_SH_TLS_IE_32:
	      tls_type = GOT_TLS_IE;
	      break;
	    }

d5492 1
a5492 14
	    {
#ifdef INCLUDE_SHMEDIA
	      if (seen_stt_datalabel)
		{
		  struct elf_sh_link_hash_entry *eh = 
		    (struct elf_sh_link_hash_entry *)h;

		  eh->datalabel_got.refcount += 1;
		}
	      else
#endif
		h->got.refcount += 1;
	      old_tls_type = sh_elf_hash_entry (h)->tls_type;
	    }
a5510 1
		  size += symtab_hdr->sh_info;
a5515 32
#ifdef 	INCLUDE_SHMEDIA
		  /* Take care of both the datalabel and codelabel local
		     GOT offsets.  */
		  sh_elf_local_got_tls_type (abfd)
		    = (char *) (local_got_refcounts + 2 * symtab_hdr->sh_info);
#else
		  sh_elf_local_got_tls_type (abfd)
		    = (char *) (local_got_refcounts + symtab_hdr->sh_info);
#endif
		}
#ifdef INCLUDE_SHMEDIA
	      if (rel->r_addend & 1)
		local_got_refcounts[symtab_hdr->sh_info + r_symndx] += 1;
	      else
#endif
		local_got_refcounts[r_symndx] += 1;
	      old_tls_type = sh_elf_local_got_tls_type (abfd) [r_symndx];
	    }

	  /* If a TLS symbol is accessed using IE at least once,
	     there is no point to use dynamic model for it.  */
	  if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN
	      && (old_tls_type != GOT_TLS_GD || tls_type != GOT_TLS_IE))
	    {
	      if (old_tls_type == GOT_TLS_IE && tls_type == GOT_TLS_GD)
		tls_type = GOT_TLS_IE;
	      else
		{
		  (*_bfd_error_handler)
		    (_("%s: `%s' accessed both as normal and thread local symbol"),
		     bfd_archive_filename (abfd), h->root.root.string);
		  return false;
d5517 1
a5518 13

	  if (old_tls_type != tls_type)
	    {
	      if (h != NULL)
		sh_elf_hash_entry (h)->tls_type = tls_type;
	      else
		sh_elf_local_got_tls_type (abfd) [r_symndx] = tls_type;
	    }

	  break;

	case R_SH_TLS_LD_32:
	  sh_elf_hash_table(info)->tls_ldm_got.refcount += 1;
a5541 1
	  ((struct elf_sh_link_hash_entry *) h)->gotplt_refcount += 1;
d5600 1
a5600 1
	       && (r_type != R_SH_REL32
d5690 1
a5690 1
	      if (r_type == R_SH_REL32)
a5694 99

	case R_SH_TLS_LE_32:
	  if (info->shared)
	    {
	      (*_bfd_error_handler) (_("%s: TLS local exec code cannot be linked into shared objects"),
				     bfd_archive_filename (abfd));
	      return false;
	    }

	  if (ELF32_R_TYPE (rel->r_info) == R_SH_TLS_LD_32)
	    break;

	  /* FALLTHROUGH */
	case R_SH_TLS_LDO_32:
	  /* We make a R_SH_TLS_TPOFF32 relocation. Count it as a
	     copy relocation.  */
	  if (! info->shared)
	    {
	      struct elf_sh_dyn_relocs *p;
	      struct elf_sh_dyn_relocs **head;

	      if (dynobj == NULL)
		htab->root.dynobj = dynobj = abfd;

	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      sreloc = bfd_make_section (dynobj, name);
		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
			return false;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		head = &((struct elf_sh_link_hash_entry *) h)->dyn_relocs;
	      else
		{
		  asection *s;

		  /* Track dynamic relocs needed for local syms too.  */
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return false;

		  head = ((struct elf_sh_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof (*p);
		  p = ((struct elf_sh_dyn_relocs *) bfd_alloc (dynobj, amt));
		  if (p == NULL)
		    return false;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		}

	      p->count += 1;
	      if (h)
		sh_elf_hash_entry (h)->tls_tpoff32 = true;
	    }
	  break;

	default:
	  break;
a5814 23
/* Override the generic function because we need to store sh_elf_obj_tdata
   as the specific tdata.  We set also the machine architecture from flags
   here.  */

static boolean
sh_elf_object_p (abfd)
  bfd *abfd;
{
  struct sh_elf_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct sh_elf_obj_tdata);

  if (sh_elf_set_mach_from_flags (abfd) == false)
    return false;

  /* Allocate our special target data.  */
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return false;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;
  return true;
}

d5971 1
a5971 3
  if (h->got.offset != (bfd_vma) -1
      && sh_elf_hash_entry (h)->tls_type != GOT_TLS_GD
      && sh_elf_hash_entry (h)->tls_type != GOT_TLS_IE)
a6016 54
#ifdef INCLUDE_SHMEDIA
  {
    struct elf_sh_link_hash_entry *eh;

    eh = (struct elf_sh_link_hash_entry *) h;
    if (eh->datalabel_got.offset != (bfd_vma) -1)
      {
	asection *sgot;
	asection *srel;
	Elf_Internal_Rela rel;

	/* This symbol has a datalabel entry in the global offset table.
	   Set it up.  */

	sgot = htab->sgot;
	srel = htab->srelgot;
	BFD_ASSERT (sgot != NULL && srel != NULL);

	rel.r_offset = (sgot->output_section->vma
			+ sgot->output_offset
			+ (eh->datalabel_got.offset &~ (bfd_vma) 1));

	/* If this is a static link, or it is a -Bsymbolic link and the
	   symbol is defined locally or was forced to be local because
	   of a version file, we just want to emit a RELATIVE reloc.
	   The entry in the global offset table will already have been
	   initialized in the relocate_section function.  */
	if (info->shared
	    && (info->symbolic
		|| h->dynindx == -1
		|| (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
	    && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	  {
	    rel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
	    rel.r_addend = (h->root.u.def.value
			    + h->root.u.def.section->output_section->vma
			    + h->root.u.def.section->output_offset);
	  }
	else
	  {
	    bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents
			+ eh->datalabel_got.offset);
	    rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_GLOB_DAT);
	    rel.r_addend = 0;
	  }

	bfd_elf32_swap_reloca_out (output_bfd, &rel,
				   ((Elf32_External_Rela *) srel->contents
				    + srel->reloc_count));
	++srel->reloc_count;
      }
  }
#endif

d6242 1
a6242 65
/* Support for Linux core dump NOTE sections */
static boolean
elf32_shlin_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  int offset;
  unsigned int raw_size;

  switch (note->descsz)
    {
      default:
	return false;

      case 168:		/* Linux/SH */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	raw_size = 92;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}

static boolean
elf32_shlin_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  switch (note->descsz)
    {
      default:
	return false;

      case 124:		/* Linux/SH elf_prpsinfo */
	elf_tdata (abfd)->core_program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
	elf_tdata (abfd)->core_command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return true;
}

d6252 1
d6260 1
a6260 2
#define bfd_elf32_mkobject		sh_elf_mkobject
#define elf_backend_object_p		sh_elf_object_p
d6295 1
a6295 2
#ifndef INCLUDE_SHMEDIA

d6297 1
a6298 67
/* QNX support.  */
#include "elf32-qnx.h"

#undef	TARGET_LITTLE_SYM 
#define	TARGET_LITTLE_SYM		bfd_elf32_shlqnx_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-shl-nto"
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shqnx_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-sh-nto"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x1000

#define	elf32_bed			elf32_sh_qnx_bed

#include "elf32-target.h"

#undef	elf_backend_set_nonloadable_filepos
#undef	elf_backend_is_contained_by_filepos
#undef	elf_backend_copy_private_bfd_data_p
#undef	elf32_bed

/* NetBSD support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shnbsd_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-sh-nbsd"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf32_shlnbsd_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-shl-nbsd"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x10000
#undef	elf_symbol_leading_char
#define	elf_symbol_leading_char		0

#define	elf32_bed			elf32_sh_nbsd_bed

#include "elf32-target.h"

#undef	elf32_bed

/* Linux support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_shblin_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-shbig-linux"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf32_shlin_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-sh-linux"

#undef	elf_backend_grok_prstatus
#define	elf_backend_grok_prstatus	elf32_shlin_grok_prstatus
#undef	elf_backend_grok_psinfo
#define	elf_backend_grok_psinfo		elf32_shlin_grok_psinfo

#define	elf32_bed			elf32_sh_lin_bed

#include "elf32-target.h"

#undef	elf_backend_grok_prstatus
#undef	elf_backend_grok_psinfo
#undef	elf32_bed

#endif /* INCLUDE_SHMEDIA */
@


1.47.4.1
log
@merge from trunk
@
text
@d2070 1
a2070 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d2450 1
a2450 2
	      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym,
					(const PTR) shndx, &sym);
d2713 1
a2713 2
	  bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &sym);
d2760 1
a2760 2
      bfd_elf32_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				&isym);
d4927 1
a4927 2
	  bfd_elf32_swap_symbol_in (input_bfd, (const PTR) esym,
				    (const PTR) shndx, isymp);
@


1.46
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d3532 1
a3532 1
  ret = (struct elf_sh_link_hash_table *) bfd_alloc (abfd, amt);
d3539 1
a3539 1
      bfd_release (abfd, ret);
@


1.45
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d3902 2
a3903 2
				 sh_elf_discard_copies,
				 (PTR) NULL);
d4040 3
@


1.44
log
@* elf32-sh.c: Added missing prototypes.
* elf32-sh64.c: Likewise.
(sh_elf_align_loads): Mark unused args as such.
* elf64-sh64.c: Added missing prototypes.
(struct elf_sh64_link_hash_entry): Fix typo.
(sh_elf64_relocate_section): Fix info argument passed to
_bfd_elf_section_offset.
@
text
@d4422 1
d4429 2
d4435 1
a4435 4
		{
		  memset (&outrel, 0, sizeof outrel);
		  relocate = false;
		}
a4438 1
		  relocate = false;
a4460 1
		      relocate = false;
@


1.43
log
@2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * coff-rs6000.c (xcoff_generate_rtinit): Silence uninitialized
        variable warnings.
        * elf32-sh.c (sh_elf_relax_section): Silence signed/unsigned
        comparison warning.
        * trad-core.c (trad_unix_core_file_p): Silence pointer/integer
        cast warnings for the common case.
@
text
@d88 3
d2814 1
a2814 1
     bfd *abfd;
d2817 1
a2817 1
     bfd_byte *contents;
@


1.42
log
@Contribute sh64-elf.
2002-01-23  Alexandre Oliva  <aoliva@@redhat.com>
* reloc.c (R_SH_GOTPLT32, R_SH_GOT_LOW16, R_SH_GOT_MEDLOW16,
R_SH_GOT_MEDHI16, R_SH_GOT_HI16, R_SH_GOTPLT_LOW16,
R_SH_GOTPLT_MEDLOW16, R_SH_GOTPLT_MEDHI16, R_SH_GOTPLT_HI16,
R_SH_PLT_LOW16, R_SH_PLT_MEDLOW16, R_SH_PLT_MEDHI16,
R_SH_PLT_HI16, R_SH_GOTOFF_LOW16, R_SH_GOTOFF_MEDLOW16,
R_SH_GOTOFF_MEDHI16, R_SH_GOTOFF_HI16, R_SH_GOTPC_LOW16,
R_SH_GOTPC_MEDLOW16, R_SH_GOTPC_MEDHI16, R_SH_GOTPC_HI16,
R_SH_GOT10BY4, R_SH_GOTPLT10BY4, R_SH_GOT10BY8, R_SH_GOTPLT10BY8,
R_SH_COPY64, R_SH_GLOB_DAT64, R_SH_JMP_SLOT64, R_SH_RELATIVE64):
New relocs.
* libbfd.h, bfd-in2.h: Rebuilt.
* elf32-sh.c (sh_elf_howto_table): Define new relocs.
(sh_reloc_map): Map them.
(PLT_ENTRY_SIZE, elf_sh_plt0_entry_be, elf_sh_plt0_entry_le,
elf_sh_plt_entry_be, elf_sh_plt_entry_le, elf_sh_pic_plt_entry_be,
elf_sh_pic_plt_entry_le, elf_sh_plt0_entry, elf_sh_plt_entry,
elf_sh_pic_plt_entry, elf_sh_sizeof_plt, elf_sh_plt_plt0_offset,
elf_sh_plt0_gotplt_offset, elf_sh_plt_temp_offset,
elf_sh_plt_symbol_offset, elf_sh_plt_reloc_offset,
movi_shori_putval) [INCLUDE_SHMEDIA]: New.
(elf_sh_link_hash_entry) [INCLUDE_SHMEDIA]: Add
datalabel_got_offset.
(sh_elf_link_hash_newfunc): Initialize it.
(sh_elf_relocate_section): Augment the scope of
seen_stt_datalabel.  Introduce GOTPLT support.	Extend GOTPC, PLT,
GOT and GOTOFF handling to new SHmedia relocation types.  Support
GOT_BIAS.
(sh_elf_check_relocs): Likewise.
(sh_elf_finish_dynamic_symbol) [TARGET_SHMEDIA]: Set up values in
PLT entries using movi_shori_putval.  Support GOT_BIAS.
(sh_elf_finish_dynamic_sections): Likewise.
* elf32-sh64.c (shmedia_prepare_reloc): Do not add addend to
relocation, it's now done by the caller.
(GOT_BIAS): New.
* elf64-sh64.c (GOT_BIAS, PLT_ENTRY_SIZE, elf_sh64_sizeof_plt,
elf_sh64_plt_plt0_offset, elf_sh64_plt0_gotplt_offset,
elf_sh64_plt_temp_offset, elf_sh64_plt_symbol_offset,
elf_sh64_plt_reloc_offset, ELF_DYNAMIC_INTERPRETER,
elf_sh64_pcrel_relocs_copied, elf_sh64_link_hash_entry,
elf_sh64_link_hash_table, sh64_elf64_link_hash_traverse,
sh64_elf64_hash_table): New.
(sh_elf64_howto_table): Introduce new relocs.
(sh_elf64_info_to_howto): Accept new PIC relocs.
(sh_elf64_relocate_section): Augment the scope of
seen_stt_datalabel.  Support new PIC relocs.
(sh_elf64_check_relocs): Support new PIC relocs.
(elf_sh64_plt0_entry_be, elf_sh64_plt0_entry_le,
elf_sh64_plt_entry_be, elf_sh64_plt_entry_le,
elf_sh64_pic_plt_entry_be, elf_sh64_pic_plt_entry_le,
elf_sh64_plt0_entry, elf_sh64_plt_entry, elf_sh64_pic_plt_entry,
sh64_elf64_link_hash_newfunc, sh64_elf64_link_hash_table_create,
movi_shori_putval, movi_3shori_putval,
sh64_elf64_create_dynamic_sections,
sh64_elf64_adjust_dynamic_symbol, sh64_elf64_discard_copies,
sh64_elf64_size_dynamic_sections,
sh64_elf64_finish_dynamic_symbol,
sh64_elf64_finish_dynamic_sections): New.
(elf_backend_create_dynamic-sections,
bfd_elf64_bfd_link_hash_table_create,
elf_backend_adjust_dynamic_symbol,
elf_backend_size_dynamic_sections,
elf_backend_finish_dynamic_symbol,
elf_backend_finish_dynamic_sections, elf_backend_want_got_plt,
elf_backend_plt_readonly, elf_backend_want_plt_sym,
elf_backend_got_header_size, elf_backend_plt_header_size):
Define.
2001-05-16  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-sh.c: Renumbered and renamed some SH5 relocations to
match official numbers and names; moved unmaching ones to the
range 0xf2-0xff.
* elf32-sh64.c, elf64-sh64.c: Likewise.
2001-03-12  DJ Delorie	<dj@@redhat.com>
* elf32-sh.c (sh_elf_relax_section): Don't relax SHmedia
sections.
2001-03-12  DJ Delorie	<dj@@redhat.com>
* elf32-sh64.c (shmedia_prepare_reloc): Validate relocs that must
be aligned.
* elf64-sh64.c (sh_elf64_relocate_section): Ditto.
2001-01-14  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh64.c (bfd_elf32_bfd_copy_private_section_data): Define.
(sh64_elf_fake_sections): Set type to SHT_SH5_CR_SORTED for a
.cranges section with SEC_SORT_ENTRIES set.
(sh64_backend_section_from_shdr): Set SEC_SORT_ENTRIES on an
incoming sorted .cranges section.
(sh64_bfd_elf_copy_private_section_data): New.
(sh64_elf_final_write_processing): Only sort .cranges and modify
start address if called by linker.
2001-01-08  Ben Elliston  <bje@@redhat.com>
* elf32-sh64.c (sh64_elf_final_write_processing): Activate
Hans-Peter Nilsson's set bit 0 patch from	2001-01-06.
* elf64-sh64.c (sh64_elf64_final_write_processing): Ditto.
2001-01-06  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf64-sh64.c (sh_elf64_howto_table): No open brace at start of
line.  Add comments before all entries.
<R_SH_PT_16, R_SH_SHMEDIA_CODE>: Correct and clarify describing
comment.
(sh_elf64_reloc): Correct head comment.
(sh_elf64_relocate_section): Correct spacing.
<relocating for a local symbol>: Do not honour STO_SH5_ISA32;
instead call reloc_dangerous callback.
<case R_SH_SHMEDIA_CODE>: New case.
(sh_elf64_gc_mark_hook): Correct spacing.
(sh_elf64_check_relocs): Ditto.
* elf32-sh64.c (shmedia_prepare_reloc) <case R_SH_SHMEDIA_CODE>:
New case.
* elf32-sh.c: Correct #endif comments for #ifndef-wrapped
functions.
(sh_elf_howto_table) <R_SH_PT_16, R_SH_SHMEDIA_CODE>: Correct,
clarify describing comment.  Add comments before all entries.
(sh_elf_relocate_section) <relocating for a local symbol>: Do not
honour STO_SH5_ISA32; instead call reloc_dangerous callback.
2001-01-06  Hans-Peter Nilsson	<hpn@@cygnus.com>
Sort .cranges section in final link.  Prepare to set bit 0 on
entry address.
* elf32-sh64.c (struct sh64_find_section_vma_data): New.
(sh64_elf_link_output_symbol_hook): Fix typo in prototype.
(sh64_elf_set_mach_from_flags): Set SEC_DEBUGGING on incoming
.cranges section.
(sh64_backend_section_from_shdr): New, to recognize
SHT_SH5_CR_SORTED on incoming .cranges section.
(elf_backend_section_from_shdr): Define.
(sh64_elf_final_write_processing): Sort outgoing .cranges
section.  (New, temporarily disabled:) Set bit 0 on entry address
according to ISA type.
(sh64_find_section_for_address): New.
(crange_qsort_cmpb, crange_qsort_cmpl, crange_bsearch_cmpb,
crange_bsearch_cmpl): Move here from opcodes/sh64-dis.c.
(sh64_address_in_cranges): Move here from opcodes/sh64-dis.c.  Use
bfd_malloc, not xmalloc.
(sh64_get_contents_type): Move here from opcodes/sh64-dis.c.  Make
global.
* elf32-sh64.c (sh64_elf64_final_write_processing): New, (but
temporarily disabled) setting bit 0 on entry address.
(elf_backend_final_write_processing): Define.
2001-01-05  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh.c (sh_elf_howto_table) <R_SH_PT_16>: Adjust fields to
be a proper relocation for PTA and PTB rather than a marker.
<R_SH_IMMU5, R_SH_IMMS6, R_SH_IMMU6, R_SH_IMMS10, R_SH_IMMS10BY2,
R_SH_IMMS10BY4, R_SH_IMMS10BY8, R_SH_IMMS16, R_SH_IMMU16,
R_SH_IMM_LOW16, R_SH_IMM_LOW16_PCREL, R_SH_IMM_MEDLOW16,
R_SH_IMM_MEDLOW16_PCREL, R_SH_IMM_MEDHI16, R_SH_IMM_MEDHI16_PCREL,
R_SH_IMM_HI16, R_SH_IMM_HI16_PCREL, R_SH_64, R_SH_64_PCREL>:
Zero src_mask.
* elf64-sh64.c: Ditto.
(sh_elf64_relocate_section) <case R_SH_PT_16>: New case.
* elf32-sh64.c: Include opcodes/sh64-opc.h
(shmedia_prepare_reloc): Take a bfd_link_info pointer as first
argument.  Drop const qualifiers from "bfd *" and "bfd_byte *"
parameters.  No unused parameters.  Caller changed.
<case R_SH_PT_16>: New case.
* Makefile.am (elf32-sh64.lo): Add dependency on sh64-opc.h.
* Makefile.in: Regenerate.
2000-12-30  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf64-sh64.c (sh64_elf64_fake_sections): Set SHF_SH5_ISA32 for
all code sections.
(sh_elf64_set_mach_from_flags): Change from EF_SH64 to EF_SH5.
(sh64_elf_merge_private_data): Ditto.
* elf32-sh64.c (sh64_elf_fake_sections): Use sh64_elf_section_data
to access stored section flags.
(sh64_elf_final_write_processing): Return immediately unless
called by linker.  Use sh64_elf_section_data (cranges) to get size
of linker-generated cranges entries.
(sh64_elf_copy_private_data): Add missing "return true".
(sh64_elf_set_mach_from_flags): Change from EF_SH64 to EF_SH5.
(sh_elf64_merge_private_data): Ditto.
2000-12-19  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf64-sh64.c (sh64_elf64_fake_sections): New, copy of
elf64-sh64.c:sh64_elf_fake_sections.
(elf_backend_fake_sections): Define as sh64_elf64_fake_sections.
2000-12-18  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh64.c (sh64_elf_copy_private_data_internal): Delete.
(sh64_elf_final_write_processing): New.
(elf_backend_final_write_processing): Define.
(sh64_elf_fake_sections): Get header flags from tdata field.
(sh64_elf_copy_private_data): Do not call
sh64_elf_copy_private_data_internal, just copy e_flags field.
(sh64_elf_merge_private_data): Do not call
sh64_elf_copy_private_data_internal.
2000-12-12  Hans-Peter Nilsson	<hpn@@cygnus.com>
Remove EF_SH64_ABI64, let ELF size make difference.
Remove SH64-specific BFD section flag.
* elf32-sh64.c (sh64_elf_fake_sections): Recognize section as
containing SHmedia through elf_section_data (asect)->tdata
non-zero, not using a BFD section flag.
(sh64_elf_set_mach_from_flags): Don't recognize EF_SH64_ABI64.
(sh64_elf_merge_private_data): Similar.
(elf_backend_section_flags): Don't define.
(sh64_elf_backend_section_flags): Delete.
* elf64-sh64.c (sh_elf64_set_mach_from_flags): Recognize EF_SH64,
not EF_SH64_ABI64.
(sh_elf64_merge_private_data): Similar.
* section.c (Section flags definitions): Don't define
SEC_SH_ISA_SHMEDIA.
(bfd-in2.h): Regenerate.
2000-12-09  Hans-Peter Nilsson	<hpn@@cygnus.com>
Make DataLabel references work with partial linking.
* elf32-sh64.c: Fix formatting.
(sh64_elf_link_output_symbol_hook): New.
(elf_backend_link_output_symbol_hook): Define to
sh64_elf_link_output_symbol_hook.
(sh64_elf_add_symbol_hook): Make DataLabel symbol just global
undefined if partial linking.  Adjust sanity check.
* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): New.
(elf_backend_link_output_symbol_hook): Define to
sh64_elf64_link_output_symbol_hook.
(sh64_elf64_add_symbol_hook): Make DataLabel symbol just global
undefined if partial linking.  Adjust sanity check.
2000-12-07  Hans-Peter Nilsson	<hpn@@cygnus.com>
Implement semantics for inter-file DataLabel references.
* elf64-sh64.c (DATALABEL_SUFFIX): Define.
(sh64_elf64_add_symbol_hook): New.
(sh_elf64_relocate_section): If passing an indirect symbol with
st_type STT_DATALABEL on the way to a symbol with st_other
STO_SH5_ISA32, do not bitor 1 to the relocation.
(elf_backend_add_symbol_hook): Define to
sh64_elf64_add_symbol_hook.
* elf64-sh32.c: Tweak comments.
(DATALABEL_SUFFIX): Define.
(sh64_elf_add_symbol_hook): New.
(elf_backend_add_symbol_hook): Define to sh64_elf_add_symbol_hook.
* elf32-sh.c (sh_elf_relocate_section): If passing an indirect
symbol with st_type STT_DATALABEL on the way to a symbol with
st_other STO_SH5_ISA32, do not bitor 1 to the relocation.
2000-12-05  Hans-Peter Nilsson	<hpn@@cygnus.com>
Pass through STT_DATALABEL.
* elf32-sh64.c (sh64_elf_get_symbol_type): New.
(elf_backend_get_symbol_type): Define.
* elf64-sh64.c (sh64_elf64_get_symbol_type): New.
(elf_backend_get_symbol_type): Define.
2000-11-30  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh64.c: Tweak comments.
(sh64_elf_copy_private_data_internal): Add prototype.
(bfd_elf32_bfd_set_private_flags): Define.
(sh64_elf_copy_private_data_internal): Compare machine name, not
textual BFD target name, to check whether to copy section flag
SHF_SH5_ISA32.
(sh64_elf_merge_private_data): Validize bfd_get_arch_size.
Tweak section-contents-type-mismatch message.
(shmedia_prepare_reloc): Add ATTRIBUTE_UNUSED markers.
Validize reloc-types.
* elf64-sh64.c: New file.
* targets.c (bfd_elf64_sh64_vec, bfd_elf64_sh64l_vec): Declare.
* Makefile.am (BFD64_BACKENDS): Add elf64-sh64.lo.
(BFD64_BACKENDS_CFILES): Add elf64-sh64.c.
Regenerate dependencies.
* Makefile.in: Regenerate.
* config.bfd (sh64-*-elf*): Add bfd_elf64_sh64_vec and
bfd_elf64_sh64l_vec.
* configure.in: Handle bfd_elf64_sh64_vec and
bfd_elf64_sh64l_vec.
* configure: Regenerate.
* po/POTFILES.in: Regenerate.
* po/bfd.pot: Regenerate.
2000-11-29  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh64.c (sh64_elf_set_mach_from_flags): Do not recognize
anything else but EF_SH64 and EF_SH64_ABI64.
(sh64_elf_merge_private_data): Emit error for anything else but
EF_SH64 and EF_SH64_ABI64.
* config.bfd: Remove bfd_elf32_shblin_vec and bfd_elf32_shlin_vec
from targ_selvecs.
* configure.in: Add cofflink.lo to bfd_elf32_sh64_vec and
bfd_elf32_sh64l_vec as a temporary measure.
* configure: Regenerate.
2000-11-27  Hans-Peter Nilsson	<hpn@@cygnus.com>
* cpu-sh.c (arch_info_struct): Include sh5 item
unconditionalized.
* config.bfd (sh64-*-elf*): Do not set targ_cflags.
Add targ_selvecs bfd_elf32_sh_vec, bfd_elf32_shl_vec,
bfd_elf32_shblin_vec and bfd_elf32_shlin_vec.
* elf32-sh64.c: Tweak comments.
(sh64_elf_set_mach_from_flags): Recognize all machine flags that
are proper subsets of SH64 as bfd_mach_sh5.  Add EF_SH64_ABI64.
(sh64_elf_copy_private_data_internal): Wrap long line.
(sh64_elf_merge_private_data): Rewrite to allow objects from
SH64 subsets to be linked together.
(INCLUDE_SHMEDIA): Define.
* elf32-sh.c (sh_elf_relocate_section) <local symbol>:
Parenthesize plus-expression inside or-expression.
<global symbol>: Ditto.
(sh_elf_set_mach_from_flags): Remove code refusing
deleted EF_SH64_32BIT_ABI flag.
2000-11-26  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh.c (sh_elf_howto_table) <R_SH_IMM_LOW16_PCREL,
R_SH_IMM_MEDLOW16_PCREL, R_SH_IMM_MEDHI16_PCREL,
R_SH_IMM_HI16_PCREL, R_SH_64_PCREL>: Set pcrel_offset to true.
(sh_elf_relocate_section) <local symbol>: Or 1 in
calculation of relocation if sym->st_other & STO_SH5_ISA32.
<global symbol>: Ditto if h->other & STO_SH5_ISA32.
* elf32-sh64.c (shmedia_prepare_reloc): Add rel->r_addend to
relocation.
2000-11-24  Hans-Peter Nilsson	<hpn@@cygnus.com>
* Makefile.am (BFD32_BACKENDS): Add elf32-sh64.lo.
(BFD32_BACKENDS_CFILES): Add elf32-sh64.c.
Regenerate dependencies.
* Makefile.in: Regenerate.
* archures.c: Add bfd_mach_sh5.
* config.bfd: Map targ_cpu sh* to bfd_sh_arch.
Handle sh64-*-elf*.  Set targ_cflags to -DINCLUDE_SHMEDIA.
* configure.in: Handle bfd_elf32_sh64_vec and bfd_elf32_sh64l_vec.
* configure: Regenerate.
* reloc.c (BFD_RELOC_SH_SHMEDIA_CODE, BFD_RELOC_SH_IMMU5,
BFD_RELOC_SH_IMMS6, BFD_RELOC_SH_IMMS6BY32, BFD_RELOC_SH_IMMU6,
BFD_RELOC_SH_IMMS10, BFD_RELOC_SH_IMMS10BY2,
BFD_RELOC_SH_IMMS10BY4, BFD_RELOC_SH_IMMS10BY8,
BFD_RELOC_SH_IMMS16, BFD_RELOC_SH_IMMU16, BFD_RELOC_SH_IMM_LOW16,
BFD_RELOC_SH_IMM_LOW16_PCREL, BFD_RELOC_SH_IMM_MEDLOW16,
BFD_RELOC_SH_IMM_MEDLOW16_PCREL, BFD_RELOC_SH_IMM_MEDHI16,
BFD_RELOC_SH_IMM_MEDHI16_PCREL, BFD_RELOC_SH_IMM_HI16,
BFD_RELOC_SH_IMM_HI16_PCREL, BFD_RELOC_SH_PT_16): New relocations.
* cpu-sh.c [INCLUDE_SHMEDIA] (arch_info_struct): Define and link
in item for SH5.
* elf32-sh.c [INCLUDE_SHMEDIA] (sh_elf_howto_table): Add howto items
for SHmedia relocs.
[INCLUDE_SHMEDIA] (sh_rel): Add mappings for SHmedia relocs.
[INCLUDE_SHMEDIA] (sh_elf_relocate_section) [default]: Call
shmedia_prepare_reloc, goto final_link_relocate if it returns
non-zero, else fail as before.
(sh_elf_set_mach_from_flags): Provide function only if not defined
as macro.  Do not recognize objects with EF_SH64_32BIT_ABI set.
(sh_elf_set_private_flags): Provide function only if not defined
as a macro.
(sh_elf_copy_private_data): Similar.
(sh_elf_merge_private_data): Similar.
* section.c (SEC_SH_ISA_SHMEDIA): New.
* targets.c (bfd_elf32_sh64_vec, bfd_elf32_sh64l_vec): Declare.
* elf32-sh64.c: New file.
* libbfd.h: Regenerate.
* bfd-in2.h: Regenerate.
* po/POTFILES.in: Regenerate.
* po/bfd.pot: Regenerate.
* bfd-in2.h: Regenerate.
* libbfd.h: Regenerate.
@
text
@d2069 2
a2070 1
	  if (isym.st_shndx != _bfd_elf_section_from_bfd_section (abfd, sec))
@


1.42.2.1
log
@2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * coff-rs6000.c (xcoff_generate_rtinit): Silence uninitialized
        variable warnings.
        * elf32-sh.c (sh_elf_relax_section): Silence signed/unsigned
        comparison warning.
        * trad-core.c (trad_unix_core_file_p): Silence pointer/integer
        cast warnings for the common case.
@
text
@d2069 1
a2069 2
	  if (isym.st_shndx
	      != (unsigned int) _bfd_elf_section_from_bfd_section (abfd, sec))
@


1.42.2.2
log
@* elf32-sh.c: Added missing prototypes.
* elf32-sh64.c: Likewise.
(sh_elf_align_loads): Mark unused args as such.
* elf64-sh64.c: Added missing prototypes.
(struct elf_sh64_link_hash_entry): Fix typo.
(sh_elf64_relocate_section): Fix info argument passed to
_bfd_elf_section_offset.
@
text
@a87 3
#ifdef INCLUDE_SHMEDIA
inline static void movi_shori_putval PARAMS ((bfd *, unsigned long, char *));
#endif
d2811 1
a2811 1
     bfd *abfd ATTRIBUTE_UNUSED;
d2814 1
a2814 1
     bfd_byte *contents ATTRIBUTE_UNUSED;
@


1.42.2.3
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a4421 1
	      relocate = false;
a4427 2
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = true, relocate = true;
d4432 4
a4435 1
		memset (&outrel, 0, sizeof outrel);
d4439 1
d4462 1
@


1.42.2.4
log
@Merge from mainline.
@
text
@d3902 2
a3903 2
			       sh_elf_discard_copies,
			       (PTR) NULL);
a4039 3

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct elf_sh_link_hash_entry *) h->root.root.u.i.link;
@


1.41
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d495 108
d610 2
d833 698
d1776 52
d1864 2
d1906 8
d3013 172
d3424 1
d3451 4
d3511 3
d4067 1
d4077 1
d4094 1
d4112 4
d4140 8
d4226 9
a4234 1
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d4243 9
a4251 1
		  || (r_type == R_SH_PLT32
d4253 5
a4257 1
		  || (r_type == R_SH_GOT32
d4292 1
a4292 1
		relocation = (h->root.u.def.value
d4294 6
a4299 1
			      + sec->output_offset);
d4370 5
d4481 41
d4523 8
d4544 9
d4580 11
a4590 1
		      h->got.offset |= 1;
d4600 14
d4618 3
d4651 6
a4656 1
		  local_got_offsets[r_symndx] |= 1;
d4662 4
d4669 6
d4691 6
d4700 6
d4716 6
d4725 6
d4761 6
d5079 1
d5083 22
d5131 1
d5133 8
d5171 15
d5192 3
d5216 5
d5227 4
d5232 15
d5253 3
d5270 32
d5303 6
d5436 1
d5472 1
d5474 1
d5489 1
d5491 1
d5505 1
d5507 1
d5548 1
d5595 4
d5609 13
d5633 1
d5645 5
d5653 1
d5656 10
d5669 1
d5685 3
d5887 7
d5900 1
@


1.40
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d1026 1
d1035 1
d1050 1
d1157 5
a1161 1
	      extsyms = (Elf32_External_Sym *) bfd_malloc (symtab_hdr->sh_size);
d1166 1
a1166 2
		  || (bfd_bread (extsyms, symtab_hdr->sh_size, abfd)
		      != symtab_hdr->sh_size))
d1168 16
d1190 3
d1195 3
a1197 4
	  /* A local symbol.  */
	  bfd_elf32_swap_symbol_in (abfd,
				    extsyms + ELF32_R_SYM (irelfn->r_info),
				    &isym);
a1262 1
      symtab_hdr->contents = (bfd_byte *) extsyms;
a1387 1
	  symtab_hdr->contents = (bfd_byte *) extsyms;
d1393 1
a1393 4
    {
      free (free_relocs);
      free_relocs = NULL;
    }
d1404 6
a1409 1
      free_contents = NULL;
a1414 2
	free (free_extsyms);
      else
d1416 2
a1417 2
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) extsyms;
a1418 1
      free_extsyms = NULL;
d1428 5
d1434 5
a1438 1
    free (free_extsyms);
d1454 1
d1456 1
a1456 1
  int shndx, index;
d1462 4
a1465 1
  struct elf_link_hash_entry *sym_hash;
d1471 4
a1474 1
  shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
d1574 5
a1578 4
	      bfd_elf32_swap_symbol_in (abfd,
					extsyms + ELF32_R_SYM (irel->r_info),
					&sym);
	      if (sym.st_shndx == shndx
a1835 3
	  bfd_elf32_swap_symbol_in (abfd,
				    extsyms + ELF32_R_SYM (irelscan->r_info),
				    &sym);
d1837 5
a1841 1
	  if (sym.st_shndx == shndx
d1878 1
d1881 1
a1881 1
  for (; esym < esymend; esym++)
d1884 1
d1886 1
a1886 1
      bfd_elf32_swap_symbol_in (abfd, esym, &isym);
d1888 1
a1888 1
      if (isym.st_shndx == shndx
d1893 1
a1893 1
	  bfd_elf32_swap_symbol_out (abfd, &isym, esym);
d1898 12
a1909 14
  esym = extsyms + symtab_hdr->sh_info;
  esymend = extsyms + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));
  for (index = 0; esym < esymend; esym++, index++)
    {
      Elf_Internal_Sym isym;

      bfd_elf32_swap_symbol_in (abfd, esym, &isym);
      sym_hash = elf_sym_hashes (abfd)[index];
      if (isym.st_shndx == shndx
	  && ((sym_hash)->root.type == bfd_link_hash_defined
	      || (sym_hash)->root.type == bfd_link_hash_defweak)
	  && (sym_hash)->root.u.def.section == sec
	  && (sym_hash)->root.u.def.value > addr
	  && (sym_hash)->root.u.def.value < toaddr)
d1911 1
a1911 1
	  (sym_hash)->root.u.def.value -= count;
d3613 1
d3619 2
d3633 1
d3644 1
a3644 1
      bfd_size_type size;
d3648 1
a3648 1
      else
d3650 4
a3653 4
	  size = symtab_hdr->sh_info;
	  size *= sizeof (Elf32_External_Sym);
	  external_syms = (Elf32_External_Sym *) bfd_malloc (size);
	  if (external_syms == NULL && size != 0)
d3656 13
a3668 1
	      || bfd_bread (external_syms, size, input_bfd) != size)
d3678 4
a3681 4
      size = symtab_hdr->sh_info;
      size *= sizeof (Elf_Internal_Sym);
      internal_syms = (Elf_Internal_Sym *) bfd_malloc (size);
      if (internal_syms == NULL && symtab_hdr->sh_info > 0)
d3684 4
a3687 4
      size = symtab_hdr->sh_info;
      size *= sizeof (asection *);
      sections = (asection **) bfd_malloc (size);
      if (sections == NULL && symtab_hdr->sh_info > 0)
d3690 4
a3693 5
      isymp = internal_syms;
      secpp = sections;
      esym = external_syms;
      esymend = esym + symtab_hdr->sh_info;
      for (; esym < esymend; ++esym, ++isymp, ++secpp)
d3697 1
a3697 1
	  bfd_elf32_swap_symbol_in (input_bfd, esym, isymp);
a3700 2
	  else if (isymp->st_shndx > 0 && isymp->st_shndx < SHN_LORESERVE)
	    isec = bfd_section_from_elf_index (input_bfd, isymp->st_shndx);
d3706 1
a3706 4
	    {
	      /* Who knows?  */
	      isec = NULL;
	    }
a3717 1
      sections = NULL;
d3720 2
a3721 1
      internal_syms = NULL;
a3723 1
      external_syms = NULL;
a3725 1
      internal_relocs = NULL;
d3734 2
d3778 1
a3778 5
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
                && sym->st_shndx != SHN_COMMON))
	return bfd_section_from_elf_index (abfd, sym->st_shndx);
d3780 1
@


1.39
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d3104 1
a3104 3
		_bfd_merged_section_offset (output_bfd, &msec,
					    elf_section_data (sec)->merge_info,
					    sym->st_value + addend, (bfd_vma) 0)
d3285 5
a3289 16
	      if (elf_section_data (input_section)->stab_info == NULL)
		outrel.r_offset = rel->r_offset;
	      else
		{
		  bfd_vma off;

		  off = (_bfd_stab_section_offset
			 (output_bfd, &elf_hash_table (info)->stab_info,
			  input_section,
			  &elf_section_data (input_section)->stab_info,
			  rel->r_offset));
		  if (off == (bfd_vma) -1)
		    skip = true;
		  outrel.r_offset = off;
		}

@


1.38
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d2963 1
a2963 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
a3043 1

d3080 31
@


1.37
log
@	* elf-m10200.c (mn10200_elf_relax_section): Cast assignment to
	Elf_Internal_Shdr.contents now that it's no longer a PTR.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elf.c (setup_group): Warning fixes.
	* elflink.h (elf_link_sort_relocs): Likewise.
	* pdp11.c (slurp_reloc_table): Likewise.
@
text
@d3219 1
@


1.36
log
@	* elf32-sh.c (sh_elf_howto_table, R_SH_REL32): Make
	partial_inplace, matching assembler output.  Set src_mask to
	all ones.
	(sh_elf_relocate_section): Delete misplaced comment.
	For relocatable linking against section symbol, call
	_bfd_relocate_contents for partial_inplace relocs and adjust
	rel->r_addend for others.
	<case R_SH_DIR32, R_SH_REL32>: Fetch partial_inplace addend with
	bfd_get_32, not at rel->r_addend.
@
text
@d1395 1
a1395 1
	  symtab_hdr->contents = extsyms;
@


1.35
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@d137 2
a138 2
	 false,			/* partial_inplace */
	 0,			/* src_mask */
d3029 5
a3033 1
      /* This is a final link.  */
d3053 26
a3078 1
		goto final_link_relocate;
d3285 2
a3286 1
		  outrel.r_addend = rel->r_addend;
d3299 3
a3301 1
		      outrel.r_addend = relocation + rel->r_addend;
d3308 3
a3310 1
		      outrel.r_addend = relocation + rel->r_addend;
a3326 2
	  else if (r_type == R_SH_DIR32)
	    addend = rel->r_addend;
d3506 1
@


1.34
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d87 1
a87 1
  PARAMS ((int));
d4437 2
a4438 2
sh_elf_reloc_type_class (type)
     int type;
d4440 1
a4440 1
  switch (type)
@


1.33
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d1099 1
a1099 1
				 bfd_get_filename (abfd),
d1111 1
a1111 1
	    bfd_get_filename (abfd), (unsigned long) irel->r_offset, insn));
d1128 1
a1128 1
	    bfd_get_filename (abfd), (unsigned long) irel->r_offset));
d1143 1
a1143 1
	    bfd_get_filename (abfd), (unsigned long) paddr));
d1179 1
a1179 1
		bfd_get_filename (abfd), (unsigned long) paddr));
d1301 1
a1301 1
	    bfd_get_filename (abfd), (unsigned long) paddr));
d1310 1
a1310 1
				  bfd_get_filename (abfd),
d1704 1
a1704 1
		bfd_get_filename (abfd), (unsigned long) irel->r_offset));
d2094 1
a2094 1
		bfd_get_filename (abfd), (unsigned long) irel->r_offset));
d3106 1
a3106 1
		     bfd_get_filename (input_bfd), h->root.root.string,
d3172 1
a3172 1
		    bfd_get_filename (input_section->owner),
d4094 1
a4094 1
	 bfd_get_filename (ibfd),
@


1.32
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d3117 3
a3119 1
	  else if (info->shared && !info->symbolic && !info->no_undefined)
@


1.31
log
@	* elf32-cris.c (cris_elf_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf_cris_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_cris_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.

	* elf32-sh.c (sh_elf_check_relocs): Set DF_TEXTREL if the reloc is
	against read-only section.
	(elf_backend_reloc_type_class): Define.
	(sh_elf_reloc_type_class): New.
	(sh_elf_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.

	* elf32-arm.h (elf32_arm_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf32_arm_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf32_arm_reloc_type_class): New.
@
text
@d770 1
a770 2
	  free_contents = contents
	    = (bfd_byte *) bfd_malloc (symbol_section->_raw_size);
d773 1
d828 1
a828 1
  bfd_put_16 (input_bfd, x, contents + addr);
d883 1
a883 1
      bfd_put_32 (abfd, insn, hit_data);
d896 1
a896 1
      bfd_put_16 (abfd, insn, hit_data);
d1123 1
a1123 1
      paddr += (laddr + 4) & ~3;
d1154 1
a1154 2
	      extsyms = ((Elf32_External_Sym *)
			 bfd_malloc (symtab_hdr->sh_size));
d1159 1
a1159 1
		  || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
d1253 1
a1253 1
		      0xb000 | ((foff >> 1) & 0xfff),
d1261 1
a1261 1
	  bfd_put_16 (abfd, 0xb000, contents + irel->r_offset);
d1462 2
a1463 1
  memmove (contents + addr, contents + addr + count, toaddr - addr - count);
d1474 1
a1474 1
	bfd_put_16 (abfd, NOP_OPCODE, contents + toaddr - count + i);
d1652 1
a1652 1
	      bfd_put_16 (abfd, insn, contents + nraddr);
d1659 1
a1659 1
	      bfd_put_16 (abfd, insn, contents + nraddr);
d1673 1
a1673 1
	      bfd_put_16 (abfd, insn, contents + nraddr);
d1687 1
a1687 1
	      bfd_put_signed_16 (abfd, voff, contents + nraddr);
d1692 1
a1692 1
	      bfd_put_signed_32 (abfd, voff, contents + nraddr);
d1783 1
a1783 1
		bfd_put_signed_32 (abfd, voff + count,
d1788 1
a1788 1
		bfd_put_signed_32 (abfd, voff - count,
d1889 1
a1889 1
					    alignto - alignaddr);
d1910 1
d1917 3
a1919 1
  labels = (bfd_vma *) bfd_malloc (sec->reloc_count * sizeof (bfd_vma));
d1988 2
a1989 2
  bfd_put_16 (abfd, i2, contents + addr);
  bfd_put_16 (abfd, i1, contents + addr + 2);
d2058 1
a2058 1
	      bfd_put_16 (abfd, insn, loc);
d2067 1
a2067 1
	      bfd_put_16 (abfd, insn, loc);
d2084 1
a2084 1
		  bfd_put_16 (abfd, insn, loc);
d2437 1
d2439 1
a2439 2
  ret = ((struct elf_sh_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf_sh_link_hash_table)));
d2541 1
a2541 1
	relname = (char *) bfd_malloc (strlen (secname) + 6);
d2897 3
d2902 1
a2902 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
d2908 4
a2911 4
	  if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
d2917 3
a2919 4
	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELA, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELASZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELAENT,
						sizeof (Elf32_External_Rela)))
d2925 1
a2925 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
d2929 1
d3540 1
a3540 1
	  input_section->_raw_size);
d3548 1
d3554 4
a3557 4
	  external_syms = ((Elf32_External_Sym *)
			   bfd_malloc (symtab_hdr->sh_info
				       * sizeof (Elf32_External_Sym)));
	  if (external_syms == NULL && symtab_hdr->sh_info > 0)
d3560 1
a3560 3
	      || (bfd_read (external_syms, sizeof (Elf32_External_Sym),
			    symtab_hdr->sh_info, input_bfd)
		  != (symtab_hdr->sh_info * sizeof (Elf32_External_Sym))))
d3570 3
a3572 3
      internal_syms = ((Elf_Internal_Sym *)
		       bfd_malloc (symtab_hdr->sh_info
				   * sizeof (Elf_Internal_Sym)));
d3576 3
a3578 2
      sections = (asection **) bfd_malloc (symtab_hdr->sh_info
					   * sizeof (asection *));
d3837 1
a3837 1
		  size_t size;
d3840 2
a3841 1
		  size = symtab_hdr->sh_info * sizeof (bfd_vma);
d3977 1
a3977 1
			   bfd_alloc (dynobj, sizeof *p));
d4230 1
a4230 1
		      + (h->got.offset &~ 1));
@


1.30
log
@Add missing prototypes
@
text
@d86 2
d1116 5
a1120 5
      	 displacement in the mov.l instruction is quadrupled.  It is a
      	 displacement from four bytes after the movl instruction, but,
      	 before adding in the PC address, two least significant bits
      	 of the PC are cleared.  We assume that the section is aligned
      	 on a four byte boundary.  */
d2766 1
a2766 1
     bfd *output_bfd;
a2772 1
  boolean reltext;
a2813 1
  reltext = false;
a2858 2
	      asection *target;

d2862 1
a2862 18
		{
		  const char *outname;

		  relocs = true;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  The entries in the .rela.plt section
		     really apply to the .got section, which we
		     created ourselves and so know is not readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 5);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = true;
		}
d2918 1
a2918 1
      if (reltext)
d3941 2
d4427 17
d4487 1
@


1.29
log
@Change PLT code to avoid using r2 - it used by GCC to return large startures
@
text
@d75 11
d3655 1
@


1.28
log
@* elf32-sh.c (sh_elf_relocate_section): Only relocation
R_SH_DIR8WP* relocs if they're against external symbols, else
they're just for relaxing.  Validate the reloc values.
@
text
@d2094 109
d2301 1
@


1.27
log
@Update copyright notices
@
text
@d3032 3
d3038 34
a3071 5
	  /* These should normally be handled by the assembler, but at
	     least IND12W is generated by ourselves, so we must deal
	     with it.  */
	  relocation -= 4;
	  goto final_link_relocate;
@


1.26
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1996, 97, 98, 1999, 2000 Free Software Foundation, Inc.
@


1.26.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.25
log
@Fix formatting.
@
text
@a2847 1

@


1.24
log
@2000-12-08  Kazu Hirata  <kazu@@hxi.com>

	* coffgen.c: Fix formatting.
	* elf32-i386.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf-m10300.c: Likewise.
@
text
@d80 2
a81 1
static reloc_howto_type sh_elf_howto_table[] = {
d915 2
a916 1
struct elf_reloc_map {
d923 2
a924 1
static const struct elf_reloc_map sh_reloc_map[] = {
d2093 2
a2094 1
static const bfd_byte elf_sh_plt0_entry_be[PLT_ENTRY_SIZE] = {
d2109 2
a2110 1
static const bfd_byte elf_sh_plt0_entry_le[PLT_ENTRY_SIZE] = {
d2128 2
a2129 1
static const bfd_byte elf_sh_plt_entry_be[PLT_ENTRY_SIZE] = {
d2143 2
a2144 1
static const bfd_byte elf_sh_plt_entry_le[PLT_ENTRY_SIZE] = {
d2160 2
a2161 1
static const bfd_byte elf_sh_pic_plt_entry_be[PLT_ENTRY_SIZE] = {
d2176 2
a2177 1
static const bfd_byte elf_sh_pic_plt_entry_le[PLT_ENTRY_SIZE] = {
d2226 2
a2227 1
struct elf_sh_pcrel_relocs_copied {
d2238 2
a2239 1
struct elf_sh_link_hash_entry {
d2248 2
a2249 1
struct elf_sh_link_hash_table {
d3539 1
a3539 3
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
d3908 2
a3909 2
     bfd *ibfd;
     bfd *obfd;
d3911 1
a3911 1
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
@


1.23
log
@Fix compile time warning, and remove possibility of infinite loop.
@
text
@d80 1
a80 2
static reloc_howto_type sh_elf_howto_table[] =
{
d712 1
a712 1
                   symbol_section, start, end)
d823 1
a823 1
	  error_message)
d857 2
a858 2
    sym_value = 0;                           
  else 
d914 1
a914 2
struct elf_reloc_map
{
d921 1
a921 2
static const struct elf_reloc_map sh_reloc_map[] =
{
d1001 1
a1001 1
static boolean 
d1106 1
a1106 1
      paddr += (laddr + 4) &~ 3;
d1564 1
a1564 1
	  stop = (start &~ (bfd_vma) 3) + 4 + off * 4;
d2090 1
a2090 2
static const bfd_byte elf_sh_plt0_entry_be[PLT_ENTRY_SIZE] =
{
d2105 1
a2105 2
static const bfd_byte elf_sh_plt0_entry_le[PLT_ENTRY_SIZE] =
{
d2123 1
a2123 2
static const bfd_byte elf_sh_plt_entry_be[PLT_ENTRY_SIZE] =
{
d2137 1
a2137 2
static const bfd_byte elf_sh_plt_entry_le[PLT_ENTRY_SIZE] =
{
d2153 1
a2153 2
static const bfd_byte elf_sh_pic_plt_entry_be[PLT_ENTRY_SIZE] =
{
d2168 1
a2168 2
static const bfd_byte elf_sh_pic_plt_entry_le[PLT_ENTRY_SIZE] =
{
d2217 1
a2217 2
struct elf_sh_pcrel_relocs_copied
{
d2228 1
a2228 2
struct elf_sh_link_hash_entry
{
d2237 1
a2237 2
struct elf_sh_link_hash_table
{
d2379 1
a2379 1
  s = bfd_make_section (abfd, 
d2439 3
a2441 3
	  s = bfd_make_section (abfd, 
				(bed->default_use_rela_p 
				 ? ".rela.bss" : ".rel.bss")); 
a2451 1

a2819 1
/*ARGSUSED*/
d2881 1
a2881 1
      bfd_vma addend = (bfd_vma)0;
d2952 1
a2952 1
		 sec->output_section will be NULL. */
d3009 1
a3009 1
      switch ((int)r_type)
d3013 1
a3013 1
	     R_SH_DIR32 to be compatible with other compilers. */
d3127 3
a3129 3
					(((Elf32_External_Rela *)
					  sreloc->contents)
					 + sreloc->reloc_count));
d3360 1
a3360 1
					data, relocateable, symbols)
d3492 5
a3496 5
       bfd *abfd;
       struct bfd_link_info *info ATTRIBUTE_UNUSED;
       Elf_Internal_Rela *rel;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
d3501 11
a3511 11
      {
      case R_SH_GNU_VTINHERIT:
      case R_SH_GNU_VTENTRY:
        break;

      default:
        switch (h->root.type)
          {
          case bfd_link_hash_defined:
          case bfd_link_hash_defweak:
            return h->root.u.def.section;
d3513 2
a3514 2
          case bfd_link_hash_common:
            return h->root.u.c.p->section;
d3516 10
a3525 10
	  default:
	    break;
          }
       }
     }
   else
     {
       if (!(elf_bad_symtab (abfd)
           && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
         && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
d3527 4
a3530 4
          {
            return bfd_section_from_elf_index (abfd, sym->st_shndx);
          }
      }
d3546 1
a3546 1
     them at this time. */
d3553 1
a3553 1
 
d3570 1
a3570 1
 
a3574 1
 
d3577 1
a3577 1
 
d3580 1
a3580 1
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
d3583 1
a3583 1
 
d3592 1
a3592 1
 
d3595 1
a3595 1
        h = NULL;
d3597 2
a3598 2
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];
 
d3621 5
a3625 5
        case R_SH_GNU_VTINHERIT:
          if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return false;
          break;
 
d3628 4
a3631 4
        case R_SH_GNU_VTENTRY:
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return false;
          break;
d3682 2
a3683 2
     	      /* This is a global offset table entry for a local
		 symbol.  */
d3837 1
a3837 1
        }
d3839 1
a3839 1
 
d3845 1
a3845 1
     bfd *    abfd;
d3879 2
a3880 1
/* Function to keep SH specific file flags. */
d3883 1
a3883 1
     bfd *    abfd;
d3895 1
d3898 2
a3899 2
     bfd * ibfd;
     bfd * obfd;
d3901 1
a3901 1
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
d3999 1
a3999 1
	      elf_sh_plt_entry = (bfd_big_endian (output_bfd)?
d4020 1
a4020 1
	      elf_sh_pic_plt_entry = (bfd_big_endian (output_bfd)?
d4100 2
a4101 2
				((Elf32_External_Rela *) srel->contents
				 + srel->reloc_count));
d4126 2
a4127 2
				((Elf32_External_Rela *) s->contents
				 + s->reloc_count));
d4232 1
a4232 1
		  elf_sh_pic_plt_entry = (bfd_big_endian (output_bfd)?
d4243 1
a4243 1
		  elf_sh_plt0_entry = (bfd_big_endian (output_bfd)?
@


1.22
log
@* elf32-sh.c (sh_elf_relocate_section): Ignore R_SH_NONE relocs.
@
text
@d792 1
a792 1
      while (start0 >= 0 && IS_PPI (contents + start0))
@


1.21
log
@* elf32-sh.c (sh_elf_relocate_section): Use
_bfd_final_link_relocate to apply the relocation against a section
symbol, when doing relocatable links.
@
text
@d2907 2
@


1.20
log
@* elf32-sh.c (ELF_MAXPAGESIZE): Define to 128, to match
ld/emulparams/shelf.sh.
@
text
@a2899 19
      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

d2932 13
d2948 6
@


1.19
log
@* elf32-sh.c (sh_elf_howto_table): Moved R_SH_GOT32, R_SH_PLT32,
R_SH_COPY, R_SH_GLOB_DAT, R_SH_JMP_SLOT, R_SH_RELATIVE,
R_SH_GOTOFF, R_SH_GOTPC) to the range from 160 to 167.  Replaced
the original entries with EMPTY_HOWTOs, and added new ones to fill
in the gap.
(sh_elf_info_to_howto): Make sure the new gap isn't used.
(sh_elf_relocate_section): Likewise.
@
text
@d4298 1
a4298 1
#define ELF_MAXPAGESIZE		0x1
@


1.18
log
@* config.bfd (sh-*-linux*): Added.
* configure.in (bfd_elf32_shlin_vec, bfd_elf32_shblin_vec): New.
* targets.c: Declare them.
* elf32-sh-lin.c: New file.
* Makefile.am: Compile it.
* elf32-sh.c: Don't override defines from elf32-sh-lin.c.
* configure, Makefile.in: Rebuilt.
@
text
@d239 8
a246 112
  HOWTO (R_SH_GOT32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_GOT32",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_PLT32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_PLT32",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 true),			/* pcrel_offset */

  HOWTO (R_SH_COPY,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_COPY",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_GLOB_DAT,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_GLOB_DAT",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_JMP_SLOT,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_JMP_SLOT",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_RELATIVE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_RELATIVE",	/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_GOTOFF,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_GOTOFF",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_SH_GOTPC,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* */
	 "R_SH_GOTPC",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 true),			/* pcrel_offset */

d474 235
d989 1
d2930 3
a2932 1
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC))
@


1.17
log
@* elf32-sh.c (R_SH_GOT32, R_SH_PLT32, R_SH_COPY, R_SH_GLOB_DAT,
R_SH_JMP_SLOT, R_SH_RELATIVE, R_SH_GOTOFF, R_SH_GOTPC): New.
(sh_reloc_map): Add new relocs.
(sh_elf_check_relocs, sh_elf_link_hash_newfunc,
sh_elf_link_hash_table_create, sh_elf_adjust_dynamic_symbol,
sh_elf_size_dynamic_sections, sh_elf_finish_dynamic_symbol,
sh_elf_finishe_dynamic_sections, sh_elf_discard_copies): New
functions.
(ELF_DYNAMIC_INTERPRETER, PLT_ENTRY_SIZE): Define.
(elf_sh_plt0_entry_be, elf_sh_plt0_entry_le,
elf_sh_plt_entry_be, elf_sh_plt_entry_le,
elf_sh_pic_plt_entry_be, elf_sh_pic_plt_entry_le):
New array constants.
(elf_sh_plt0_entry, elf_sh_plt_entry, elf_sh_pic_plt_entry):
New variables.
(elf_sh_sizeof_plt, elf_sh_plt_plt0_offset,
elf_sh_plt0_linker_offset, elf_sh_plt0_gotid_offset,
elf_sh_plt_temp_offset, elf_sh_plt_symbol_offset,
elf_sh_plt_reloc_offset): Define.
(elf_sh_pcrel_relocs_copied, elf_sh_link_hash_entry,
elf_sh_link_hash_table): New structs.
(sh_elf_link_hash_traverse, sh_elf_hash_table): New macros.
(sh_elf_relocate_section, sh_elf_check_relocs): Handle new
relocation types.
(elf_backend_create_dynamic_sections,
bfd_elf32_bfd_link_hash_table_create,
elf_backend_adjust_dynamic_symbol,
elf_backend_size_dynamic_sections,
elf_backend_finish_dynamic_symbol,
elf_backend_finish_dynamic_sections, elf_backend_want_got_plt,
elf_backend_plt_readonly, elf_backend_want_plt_sym,
elf_backend_got_header_size, elf_backend_plt_header_size):
Define.
* reloc.c (BFD_RELOC_SH_COPY, BFD_RELOC_SH_GLOB_DAT,
BFD_RELOC_SH_JMP_SLOT, BFD_RELOC_SH_RELATIVE, BFD_RELOC_SH_GOTPC):
New relocs.
* bfd-in2.h, libbfd.h: Rebuilt.
@
text
@d4157 1
d4167 1
@


1.16
log
@	* elf32-sh.c (sh_elf_merge_private_data): If ibfd's elf header flags
	not initialized, set them to indicate the SH1 instruction set.
@
text
@d58 21
d239 112
a350 8
  EMPTY_HOWTO (10),
  EMPTY_HOWTO (11),
  EMPTY_HOWTO (12),
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
d815 8
d1955 40
a1994 1
/* Relocate an SH ELF section.  */
d1996 1
a1996 11
static boolean
sh_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			 contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d1998 12
a2009 3
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel, *relend;
d2011 14
a2024 2
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
d2026 1
a2026 13
  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_vma addend = (bfd_vma)0;
      bfd_reloc_status_type r;
d2028 15
a2042 1
      r_symndx = ELF32_R_SYM (rel->r_info);
d2044 15
a2058 15
      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }
d2060 3
a2062 2
	  continue;
	}
d2064 2
a2065 1
      r_type = ELF32_R_TYPE (rel->r_info);
d2067 2
a2068 5
      /* Many of the relocs are only used for relaxing, and are
         handled entirely by the relaxation code.  */
      if (r_type > (int) R_SH_LAST_INVALID_RELOC
	  && r_type < (int) R_SH_LOOP_START)
	continue;
d2070 2
a2071 8
      if (r_type < 0
	  || r_type >= R_SH_max
	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC))
	{
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
d2073 2
a2074 1
      howto = sh_elf_howto_table + r_type;
d2076 2
a2077 37
      /* This is a final link.  */
      h = NULL;
      sym = NULL;
      sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
	}
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, true)))
		return false;
	      relocation = 0;
	    }
	}
d2079 2
a2080 9
      switch ((int)r_type)
	{
	final_link_relocate:
	  /* COFF relocs don't use the addend. The addend is used for
	     R_SH_DIR32 to be compatible with other compilers. */
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset,
					relocation, addend);
	  break;
d2082 2
a2083 9
	case R_SH_IND12W:
	case R_SH_DIR8WPN:
	case R_SH_DIR8WPZ:
	case R_SH_DIR8WPL:
	  /* These should normally be handled by the assembler, but at
	     least IND12W is generated by ourselves, so we must deal
	     with it.  */
	  relocation -= 4;
	  goto final_link_relocate;
d2085 5
a2089 3
	default:
	  bfd_set_error (bfd_error_bad_value);
	  return false;
d2091 2
a2092 3
	case R_SH_DIR32:
	  addend = rel->r_addend;
	  goto final_link_relocate;
d2094 9
a2102 3
	case R_SH_LOOP_START:
	  {
	    static bfd_vma start, end;
d2104 1
a2104 5
	    start = (relocation + rel->r_addend
		     - (sec->output_section->vma + sec->output_offset));
	    r = sh_elf_reloc_loop (r_type, input_bfd, input_section, contents,
				   rel->r_offset, sec, start, end);
	    break;
d2106 3
a2108 8
	case R_SH_LOOP_END:
	    end = (relocation + rel->r_addend
		   - (sec->output_section->vma + sec->output_offset));
	    r = sh_elf_reloc_loop (r_type, input_bfd, input_section, contents,
				   rel->r_offset, sec, start, end);
	    break;
	  }
	}
d2110 1098
a3207 10
      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;
d3412 2
d3421 4
a3424 1
  /* we don't use got and plt entries for sh. */
d3443 10
d3463 3
d3478 18
d3511 205
d3826 331
d4185 19
a4203 1
#define elf_backend_can_gc_sections 1
@


1.15
log
@* elf32-sh.c (sh_elf_relocate_section) [R_SH_IND12W,
R_SH_DIR8WPN, R_SH_DIR8WPZ, R_SH_DIR8WPL]: Handle them
explicitly.  Improve validation of r_type.
@
text
@d2347 1
d2349 1
a2349 1
      elf_elfheader (obfd)->e_flags = 0;
@


1.14
log
@* elf32-sh.c (sh_elf_set_mach_from_flags): Make it static.
@
text
@d1887 1
a1894 8
      /* FIXME: This is certainly incorrect.  However, it is how the
         COFF linker works.  */
      if (r_type != (int) R_SH_DIR32
	  && r_type != (int) R_SH_IND12W
	  && r_type != (int) R_SH_LOOP_START
	  && r_type != (int) R_SH_LOOP_END)
	continue;

a1902 5
	  /* There is nothing to be done for an internal IND12W
             relocation.  FIXME: This is probably wrong, but it's how
             the COFF relocations work.  */
	  if (r_type == (int) R_SH_IND12W)
	    continue;
a1934 4
      /* FIXME: This is how the COFF relocations work.  */
      if (r_type == (int) R_SH_IND12W)
	relocation -= 4;

d1937 1
a1937 4
	case (int)R_SH_DIR32:
	  addend = rel->r_addend;
	  /* Fall through.  */
	default:
d1944 19
d1972 1
@


1.13
log
@Fix bug in sh_elf_reloc_loop
@
text
@d42 1
a42 1
boolean sh_elf_set_mach_from_flags
d2264 1
a2264 1
boolean
@


1.12
log
@* elf32-sh.c (sh_elf_reloc_loop): Warning removal.
@
text
@d467 1
a467 1
  asection *last_symbol_section;
@


1.11
log
@	* elf32-sh.c (sh_elf_relax_delete_bytes): Handle R_SH_SWITCH8.
@
text
@d458 1
a458 1
     int r_type;
d520 1
a520 1
      diff = last_ptr - ptr >> 1;
d557 1
a557 1
  x = insn & ~0xff | x & 0xff;
@


1.10
log
@sh-dsp REPEAT support:
opcodes:

        * sh-opc.h (sh_nibble_type): Remove DISP_8 and DISP_4.
        Split IMM_[48]{,BY[24]} into IMM[01]_[48]{,BY[24]}.  Add REPEAT.
        (sh_arg_type): Add A_PC.
        (sh_table): Update entries using immediates.  Add repeat.
        * sh-dis.c (print_insn_shx): Remove DISP_8 and DISP_4.
        Split IMM_[48]{,BY[24]} into IMM[01]_[48]{,BY[24]}.  Add REPEAT.

gas:

        * config/tc-sh.c (immediate): Delete.
        (sh_operand_info): Add immediate member.
        (parse_reg): Use A_PC for pc.
        (parse_exp): Add second argument 'op'.  All callers changed.
        (parse_at): Expect pc to be coded as A_PC.
        Use immediate field in *op.
        (insert): Add fourth argument 'op'.  All callers changed.
        (build_relax): Add second argument 'op'.  All callers changed.
        (insert_loop_bounds): New function.
        (build_Mytes): Remove DISP_4.
        Split IMM_[48]{,BY[24]} into IMM[01]_[48]{,BY[24]}.  Add REPEAT.
        (assemble_ppi): Use immediate field in *operand.
        (sh_force_relocation): Handle BFD_RELOC_SH_LOOP_{START,END}.
        (md_apply_fix): Likewise.
        (tc_gen_reloc): Likewise.  Check for a pcrel BFD_RELOC_SH_LABEL.

include/coff:

        * sh.h (R_SH_LOOP_START, R_SH_LOOP_END): Define.

include/elf:

        * sh.h (R_SH_LOOP_START, R_SH_LOOP_END): New RELOC_NUMBERs.

bfd:

        * reloc.c (_bfd_relocate_contents): Add BFD_RELOC_SH_LOOP_START and
        BFD_RELOC_SH_LOOP_END.
        * elf32-sh.c (sh_elf_howto_tab): Change special_func to
        sh_elf_ignore_reloc for all entries that sh_elf_reloc used to ignore.
        Add entries for R_SH_LOOP_START and R_SH_LOOP_END.
        (sh_elf_reloc_loop): New function.
        (sh_elf_reloc): No need to test for always-to-be-ignored relocs
        any more.
        (sh_rel): Add entries for BFD_RELOC_SH_LOOP_{START,END}.
        (sh_elf_relocate_section): Handle BFD_RELOC_SH_LOOP_{START,END}.
        * bfd-in2.h, libbfd.h: Regenerate.
@
text
@d1397 7
@


1.9
log
@Fix building with --enable-targets=all
@
text
@d69 1
a69 1
	 sh_elf_reloc,		/* special_function */
d100 1
a100 1
	 sh_elf_reloc,		/* special_function */
d115 1
a115 1
	 sh_elf_reloc,		/* special_function */
d145 1
a145 1
	 sh_elf_reloc,		/* special_function */
d160 1
a160 1
	 sh_elf_reloc,		/* special_function */
d177 1
a177 1
	 sh_elf_reloc,		/* special_function */
d194 1
a194 1
	 sh_elf_reloc,		/* special_function */
d211 1
a211 1
	 sh_elf_reloc,		/* special_function */
d423 30
d455 109
a563 1
/* This function is used for normal relocs.  This is like the COFF
d594 1
a594 3
  if (r_type != R_SH_DIR32
      && (r_type != R_SH_IND12W
	  || (symbol_in->flags & BSF_LOCAL) != 0))
d688 2
d1875 2
a1876 1
      if (r_type > (int) R_SH_LAST_INVALID_RELOC)
d1880 2
a1881 1
	  || r_type >= (int) R_SH_FIRST_INVALID_RELOC)
d1890 3
a1892 1
	  && r_type != (int) R_SH_IND12W)
d1948 7
d1956 16
a1972 6

      /* COFF relocs don't use the addend. The addend is used for R_SH_DIR32 
	 to be compatible with other compilers. */
      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, addend);
@


1.8
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d2104 1
a2104 1
  switch (elf_elfheader (abfd)->e_flags & EF_SH_MACH_MASK)
@


1.7
log
@bfd:
Reinstate bits of sh4 support that got accidentally deleted.
Add sh-dsp support.

bfd:

	* archures.c (bfd_mach_sh2, bfd_mach_sh_dsp): New macros.
	(bfd_mach_sh3_dsp): Likewise.
	(bfd_mach_sh4): Reinstate.
	(bfd_default_scan): Recognize 7410, 7708, 7729 and 7750.
	* bfd-in2.h: Regenerate.
	* coff-sh.c (struct sh_opcode): flags is no longer short.
	(USESAS, USESAS_REG, USESR8, SETSAS, SETSAS_REG): New macros.
	(sh_opcode41, sh_opcode42): Integrate as sh_opcode41.
	(sh_opcode01, sh_opcode02, sh_opcode40): Add sh-dsp opcodes.
	(sh_opcode41, sh_opcode4, sh_opcode80): Likewise.
	(sh_opcodes): No longer const.
	(sh_dsp_opcodef0, sh_dsp_opcodef): New arrays.
	(sh_insn_uses_reg): Check for USESAS and USESR8.
	(sh_insn_sets_reg, sh_insns_conflict): Check for SETSAS.
	(_bfd_sh_align_load_span): Return early for SH4.
	Modify sh_opcodes lookup table for sh-dsp / sh3-dsp.
	Take into account that field b of a parallel processing insn
	could be mistaken for a separate insn.
	* cpu-sh.c (arch_info_struct): New array elements for
	sh2, sh-dsp and sh3-dsp.
	Reinstate element for sh4.
	(SH2_NEXT, SH_DSP_NEXT, SH3_DSP_NEXT): New macros.
	(SH4_NEXT): Reinstate.
	(SH3_NEXT, SH3E_NEXT): Adjust.
	* elf-bfd.h (_sh_elf_set_mach_from_flags): Declare.
	* elf32-sh.c (sh_elf_set_private_flags): New function.
	(sh_elf_copy_private_data, sh_elf_set_mach_from_flags): Likewise.
	(sh_elf_merge_private_data): New function.
	(elf_backend_object_p, bfd_elf32_bfd_set_private_bfd_flags): Define.
	(bfd_elf32_bfd_copy_private_bfd_data): Define.
	(bfd_elf32_bfd_merge_private_bfd_data): Change to
	sh_elf_merge_private_data.

gas:

	* config/tc-sh.c ("elf/sh.h"): Include.
	(sh_dsp, valid_arch, reg_x, reg_y, reg_efg): New static variables.
	(md.begin): Initialize target_arch.
	Only include opcodes in has table that match selected architecture.
	(parse_reg): Recognize register names for sh-dsp.
	(parse_at): Recognize post-modify addressing.
	(get_operands): The leading space is now optional.
	(get_specific): Remove FDREG_N support.  Add support for sh-dsp
	arguments.  Update valid_arch.
	(build_Mytes): Add support for SDT_REG_N.
	(find_cooked_opcode): New function, broken out of md_assemble.
	(assemble_ppi, sh_elf_final_processing): New functions.
	(md_assemble): Use find_cooked_opcode and assemble_ppi.
	(md_longopts, md_parse_option): New option: -dsp.
	* config/tc-sh.h (elf_tc_final_processing): Define.
	(sh_elf_final_processing): Declare.

include/elf:

	* sh.h: (EF_SH_MACH_MASK, EF_SH_UNKNOWN, EF_SH1, EF_SH2): New macros.
	(EF_SH3, EF_SH_HAS_DSP, EF_SH_DSP, EF_SH3_DSP): Likewise.
	(EF_SH_HAS_FP, EF_SH3E, EF_SH4, EF_SH_MERGE_MACH): Likewise.

opcodes:

	* sh-dis.c (print_movxy, print_insn_ddt, print_dsp_reg): New functions.
	(print_insn_ppi): Likewise.
	(print_insn_shx): Use info->mach to select appropriate insn set.
	Add support for sh-dsp.  Remove FD_REG_N support.
	* sh-opc.h (sh_nibble_type): Add new values for sh-dsp support.
	(sh_arg_type): Likewise.  Remove FD_REG_N.
	(sh_dsp_reg_nums): New enum.
	(arch_sh1, arch_sh2, arch_sh3, arch_sh3e, arch_sh4): New macros.
	(arch_sh_dsp, arch_sh3_dsp, arch_sh1_up, arch_sh2_up): Likewise.
	(arch_sh3_up, arch_sh3e_up, arch_sh4_up, arch_sh_dsp_up): Likewise.
	(arch_sh3_dsp_up): Likewise.
	(sh_opcode_info): New field: arch.
	(sh_table): Split up insn with FD_REG_N into ones with F_REG_N and
	D_REG_N.  Fill in arch field.  Add sh-dsp insns.
@
text
@d1792 1
a1792 1
		      input_section, rel->r_offset)))
@


1.6
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d36 8
d2098 103
d2217 5
d2223 1
a2223 1
					_bfd_generic_verify_endian_match
@


1.5
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d210 15
a224 15
  { 10 },
  { 11 },
  { 12 },
  { 13 },
  { 14 },
  { 15 },
  { 16 },
  { 17 },
  { 18 },
  { 19 },
  { 20 },
  { 21 },
  { 22 },
  { 23 },
  { 24 },
d429 1
a429 1
     char **error_message;
d500 1
a500 1
     bfd *abfd;
d502 2
a503 2
     asymbol *symbol;
     PTR data;
d506 1
a506 1
     char **error_message;
d551 1
a551 1
     bfd *abfd;
d569 1
a569 1
     bfd *abfd;
d1674 1
a1674 1
     bfd *output_bfd;
d1980 1
a1980 1
       struct bfd_link_info *info;
d2023 4
a2026 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
@


1.4
log
@	* elf32-sh.c (sh_elf_relax_delete_bytes): Fix setting of
	start / stop for recalculating of r_addend of R_SH_SWITCH*.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998 Free Software Foundation, Inc.
d2002 3
@


1.3
log
@	* elf32-sh.c (sh_elf_relax_delete_bytes): Handle R_SH_SWITCH32
	in other text sections.
@
text
@d1164 1
a1164 1
	     The r_offset field holds the difference between the reloc
d1167 3
a1169 1
	     both the r_offset field and the section contents.  */
d1171 2
a1172 2
	  start = irel->r_offset;
	  stop = (bfd_vma) ((bfd_signed_vma) start - (long) irel->r_addend);
a1181 2

	  start = stop;
@


1.2
log
@	* libbfd.c (_bfd_generic_verify_endian_match): New function.
	* libbfd-in.h (_bfd_generic_verify_endian_match): Declare.
	* libbfd.h: Regenerate.
	* coff-sh.c (sh_merge_private_data): Delete.
	(coff_bfd_merge_private_bfd_data): Change to
	_bfd_generic_verify_endian_match.
	(elf32-sh.c): bfd_elf32_bfd_merge_private_bfd_data: Define.
@
text
@d1310 50
@


1.1
log
@Initial revision
@
text
@d2053 2
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

