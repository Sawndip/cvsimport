head	1.131;
access;
symbols
	sid-snapshot-20180601:1.131
	sid-snapshot-20180501:1.131
	sid-snapshot-20180401:1.131
	sid-snapshot-20180301:1.131
	sid-snapshot-20180201:1.131
	sid-snapshot-20180101:1.131
	sid-snapshot-20171201:1.131
	sid-snapshot-20171101:1.131
	sid-snapshot-20171001:1.131
	sid-snapshot-20170901:1.131
	sid-snapshot-20170801:1.131
	sid-snapshot-20170701:1.131
	sid-snapshot-20170601:1.131
	sid-snapshot-20170501:1.131
	sid-snapshot-20170401:1.131
	sid-snapshot-20170301:1.131
	sid-snapshot-20170201:1.131
	sid-snapshot-20170101:1.131
	sid-snapshot-20161201:1.131
	sid-snapshot-20161101:1.131
	sid-snapshot-20160901:1.131
	sid-snapshot-20160801:1.131
	sid-snapshot-20160701:1.131
	sid-snapshot-20160601:1.131
	sid-snapshot-20160501:1.131
	sid-snapshot-20160401:1.131
	sid-snapshot-20160301:1.131
	sid-snapshot-20160201:1.131
	sid-snapshot-20160101:1.131
	sid-snapshot-20151201:1.131
	sid-snapshot-20151101:1.131
	sid-snapshot-20151001:1.131
	sid-snapshot-20150901:1.131
	sid-snapshot-20150801:1.131
	sid-snapshot-20150701:1.131
	sid-snapshot-20150601:1.131
	sid-snapshot-20150501:1.131
	sid-snapshot-20150401:1.131
	sid-snapshot-20150301:1.131
	sid-snapshot-20150201:1.131
	sid-snapshot-20150101:1.131
	sid-snapshot-20141201:1.131
	sid-snapshot-20141101:1.131
	sid-snapshot-20141001:1.131
	sid-snapshot-20140901:1.131
	sid-snapshot-20140801:1.131
	sid-snapshot-20140701:1.131
	sid-snapshot-20140601:1.131
	sid-snapshot-20140501:1.131
	sid-snapshot-20140401:1.131
	sid-snapshot-20140301:1.131
	sid-snapshot-20140201:1.131
	sid-snapshot-20140101:1.131
	sid-snapshot-20131201:1.131
	sid-snapshot-20131101:1.131
	sid-snapshot-20131001:1.131
	binutils-2_24-branch:1.131.0.2
	binutils-2_24-branchpoint:1.131
	binutils-2_21_1:1.107
	sid-snapshot-20130901:1.131
	gdb_7_6_1-2013-08-30-release:1.126
	sid-snapshot-20130801:1.130
	sid-snapshot-20130701:1.128
	sid-snapshot-20130601:1.128
	sid-snapshot-20130501:1.128
	gdb_7_6-2013-04-26-release:1.126
	sid-snapshot-20130401:1.128
	binutils-2_23_2:1.121.4.1
	gdb_7_6-branch:1.126.0.2
	gdb_7_6-2013-03-12-branchpoint:1.126
	sid-snapshot-20130301:1.126
	sid-snapshot-20130201:1.125
	sid-snapshot-20130101:1.124
	sid-snapshot-20121201:1.124
	gdb_7_5_1-2012-11-29-release:1.121
	binutils-2_23_1:1.121.4.1
	sid-snapshot-20121101:1.123
	binutils-2_23:1.121
	sid-snapshot-20121001:1.123
	sid-snapshot-20120901:1.121
	gdb_7_5-2012-08-17-release:1.121
	sid-snapshot-20120801:1.121
	binutils-2_23-branch:1.121.0.4
	binutils-2_23-branchpoint:1.121
	gdb_7_5-branch:1.121.0.2
	gdb_7_5-2012-07-18-branchpoint:1.121
	sid-snapshot-20120701:1.119
	sid-snapshot-20120601:1.118
	sid-snapshot-20120501:1.117
	binutils-2_22_branch:1.108.0.4
	gdb_7_4_1-2012-04-26-release:1.109
	sid-snapshot-20120401:1.115
	sid-snapshot-20120301:1.110
	sid-snapshot-20120201:1.110
	gdb_7_4-2012-01-24-release:1.109
	sid-snapshot-20120101:1.110
	gdb_7_4-branch:1.109.0.2
	gdb_7_4-2011-12-13-branchpoint:1.109
	sid-snapshot-20111201:1.109
	binutils-2_22:1.108
	sid-snapshot-20111101:1.109
	sid-snapshot-20111001:1.108
	binutils-2_22-branch:1.108.0.2
	binutils-2_22-branchpoint:1.108
	gdb_7_3_1-2011-09-04-release:1.107
	sid-snapshot-20110901:1.108
	sid-snapshot-20110801:1.108
	gdb_7_3-2011-07-26-release:1.107
	sid-snapshot-20110701:1.108
	sid-snapshot-20110601:1.107
	sid-snapshot-20110501:1.107
	gdb_7_3-branch:1.107.0.4
	gdb_7_3-2011-04-01-branchpoint:1.107
	sid-snapshot-20110401:1.107
	sid-snapshot-20110301:1.107
	sid-snapshot-20110201:1.107
	sid-snapshot-20110101:1.107
	binutils-2_21:1.107
	sid-snapshot-20101201:1.107
	binutils-2_21-branch:1.107.0.2
	binutils-2_21-branchpoint:1.107
	sid-snapshot-20101101:1.107
	sid-snapshot-20101001:1.106
	binutils-2_20_1:1.104
	gdb_7_2-2010-09-02-release:1.105
	sid-snapshot-20100901:1.106
	sid-snapshot-20100801:1.105
	gdb_7_2-branch:1.105.0.4
	gdb_7_2-2010-07-07-branchpoint:1.105
	sid-snapshot-20100701:1.105
	sid-snapshot-20100601:1.105
	sid-snapshot-20100501:1.105
	sid-snapshot-20100401:1.105
	gdb_7_1-2010-03-18-release:1.105
	sid-snapshot-20100301:1.105
	gdb_7_1-branch:1.105.0.2
	gdb_7_1-2010-02-18-branchpoint:1.105
	sid-snapshot-20100201:1.104
	sid-snapshot-20100101:1.104
	gdb_7_0_1-2009-12-22-release:1.104
	sid-snapshot-20091201:1.104
	sid-snapshot-20091101:1.104
	binutils-2_20:1.104
	gdb_7_0-2009-10-06-release:1.104
	sid-snapshot-20091001:1.104
	gdb_7_0-branch:1.104.0.4
	gdb_7_0-2009-09-16-branchpoint:1.104
	arc-sim-20090309:1.98
	binutils-arc-20081103-branch:1.98.0.20
	binutils-arc-20081103-branchpoint:1.98
	binutils-2_20-branch:1.104.0.2
	binutils-2_20-branchpoint:1.104
	sid-snapshot-20090901:1.103
	sid-snapshot-20090801:1.103
	msnyder-checkpoint-072509-branch:1.103.0.4
	msnyder-checkpoint-072509-branchpoint:1.103
	sid-snapshot-20090701:1.103
	dje-cgen-play1-branch:1.103.0.2
	dje-cgen-play1-branchpoint:1.103
	sid-snapshot-20090601:1.101
	sid-snapshot-20090501:1.101
	sid-snapshot-20090401:1.101
	arc-20081103-branch:1.98.0.18
	arc-20081103-branchpoint:1.98
	arc-insight_6_8-branch:1.98.0.16
	arc-insight_6_8-branchpoint:1.98
	insight_6_8-branch:1.98.0.14
	insight_6_8-branchpoint:1.98
	sid-snapshot-20090301:1.100
	binutils-2_19_1:1.98
	sid-snapshot-20090201:1.100
	sid-snapshot-20090101:1.100
	reverse-20081226-branch:1.100.0.2
	reverse-20081226-branchpoint:1.100
	sid-snapshot-20081201:1.99
	multiprocess-20081120-branch:1.98.0.12
	multiprocess-20081120-branchpoint:1.98
	sid-snapshot-20081101:1.98
	binutils-2_19:1.98
	sid-snapshot-20081001:1.98
	reverse-20080930-branch:1.98.0.10
	reverse-20080930-branchpoint:1.98
	binutils-2_19-branch:1.98.0.8
	binutils-2_19-branchpoint:1.98
	sid-snapshot-20080901:1.98
	sid-snapshot-20080801:1.98
	reverse-20080717-branch:1.98.0.6
	reverse-20080717-branchpoint:1.98
	sid-snapshot-20080701:1.98
	msnyder-reverse-20080609-branch:1.98.0.4
	msnyder-reverse-20080609-branchpoint:1.98
	drow-reverse-20070409-branch:1.91.0.2
	drow-reverse-20070409-branchpoint:1.91
	sid-snapshot-20080601:1.98
	sid-snapshot-20080501:1.98
	sid-snapshot-20080403:1.98
	sid-snapshot-20080401:1.98
	gdb_6_8-2008-03-27-release:1.98
	sid-snapshot-20080301:1.98
	gdb_6_8-branch:1.98.0.2
	gdb_6_8-2008-02-26-branchpoint:1.98
	sid-snapshot-20080201:1.97
	sid-snapshot-20080101:1.96
	sid-snapshot-20071201:1.96
	sid-snapshot-20071101:1.96
	gdb_6_7_1-2007-10-29-release:1.95
	gdb_6_7-2007-10-10-release:1.95
	sid-snapshot-20071001:1.96
	gdb_6_7-branch:1.95.0.4
	gdb_6_7-2007-09-07-branchpoint:1.95
	binutils-2_18:1.95
	binutils-2_18-branch:1.95.0.2
	binutils-2_18-branchpoint:1.95
	insight_6_6-20070208-release:1.89
	binutils-csl-coldfire-4_1-32:1.82
	binutils-csl-sourcerygxx-4_1-32:1.82
	gdb_6_6-2006-12-18-release:1.89
	binutils-csl-innovasic-fido-3_4_4-33:1.82
	binutils-csl-sourcerygxx-3_4_4-32:1.68
	binutils-csl-coldfire-4_1-30:1.82
	binutils-csl-sourcerygxx-4_1-30:1.82
	binutils-csl-coldfire-4_1-28:1.82
	binutils-csl-sourcerygxx-4_1-29:1.82
	binutils-csl-sourcerygxx-4_1-28:1.82
	gdb_6_6-branch:1.89.0.2
	gdb_6_6-2006-11-15-branchpoint:1.89
	binutils-csl-arm-2006q3-27:1.82
	binutils-csl-sourcerygxx-4_1-27:1.82
	binutils-csl-arm-2006q3-26:1.82
	binutils-csl-sourcerygxx-4_1-26:1.82
	binutils-csl-sourcerygxx-4_1-25:1.82
	binutils-csl-sourcerygxx-4_1-24:1.82
	binutils-csl-sourcerygxx-4_1-23:1.82
	insight_6_5-20061003-release:1.83
	gdb-csl-symbian-6_4_50_20060226-12:1.80
	binutils-csl-sourcerygxx-4_1-21:1.82
	binutils-csl-arm-2006q3-21:1.82
	binutils-csl-sourcerygxx-4_1-22:1.82
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.82
	binutils-csl-sourcerygxx-4_1-20:1.82
	binutils-csl-arm-2006q3-19:1.82
	binutils-csl-sourcerygxx-4_1-19:1.82
	binutils-csl-sourcerygxx-4_1-18:1.82
	binutils-csl-renesas-4_1-9:1.82
	gdb-csl-sourcerygxx-3_4_4-25:1.79
	binutils-csl-sourcerygxx-3_4_4-25:1.68
	nickrob-async-20060828-mergepoint:1.84
	gdb-csl-symbian-6_4_50_20060226-11:1.80
	binutils-csl-renesas-4_1-8:1.82
	binutils-csl-renesas-4_1-7:1.82
	binutils-csl-renesas-4_1-6:1.82
	gdb-csl-sourcerygxx-4_1-17:1.80
	binutils-csl-sourcerygxx-4_1-17:1.82
	gdb-csl-20060226-branch-local-2:1.80
	gdb-csl-sourcerygxx-4_1-14:1.80
	binutils-csl-sourcerygxx-4_1-14:1.82
	binutils-csl-sourcerygxx-4_1-15:1.82
	gdb-csl-sourcerygxx-4_1-13:1.80
	binutils-csl-sourcerygxx-4_1-13:1.82
	binutils-2_17:1.82
	gdb-csl-sourcerygxx-4_1-12:1.80
	binutils-csl-sourcerygxx-4_1-12:1.82
	gdb-csl-sourcerygxx-3_4_4-21:1.80
	binutils-csl-sourcerygxx-3_4_4-21:1.82
	gdb_6_5-20060621-release:1.83
	binutils-csl-wrs-linux-3_4_4-24:1.68
	binutils-csl-wrs-linux-3_4_4-23:1.68
	gdb-csl-sourcerygxx-4_1-9:1.80
	binutils-csl-sourcerygxx-4_1-9:1.82
	gdb-csl-sourcerygxx-4_1-8:1.80
	binutils-csl-sourcerygxx-4_1-8:1.82
	gdb-csl-sourcerygxx-4_1-7:1.80
	binutils-csl-sourcerygxx-4_1-7:1.82
	gdb-csl-arm-2006q1-6:1.80
	binutils-csl-arm-2006q1-6:1.82
	gdb-csl-sourcerygxx-4_1-6:1.80
	binutils-csl-sourcerygxx-4_1-6:1.82
	binutils-csl-wrs-linux-3_4_4-22:1.68
	gdb-csl-symbian-6_4_50_20060226-10:1.80
	gdb-csl-symbian-6_4_50_20060226-9:1.80
	gdb-csl-symbian-6_4_50_20060226-8:1.80
	gdb-csl-coldfire-4_1-11:1.80
	binutils-csl-coldfire-4_1-11:1.82
	gdb-csl-sourcerygxx-3_4_4-19:1.80
	binutils-csl-sourcerygxx-3_4_4-19:1.82
	gdb-csl-coldfire-4_1-10:1.80
	gdb_6_5-branch:1.83.0.4
	gdb_6_5-2006-05-14-branchpoint:1.83
	binutils-csl-coldfire-4_1-10:1.82
	gdb-csl-sourcerygxx-4_1-5:1.80
	binutils-csl-sourcerygxx-4_1-5:1.82
	nickrob-async-20060513-branch:1.83.0.2
	nickrob-async-20060513-branchpoint:1.83
	gdb-csl-sourcerygxx-4_1-4:1.80
	binutils-csl-sourcerygxx-4_1-4:1.82
	msnyder-reverse-20060502-branch:1.82.0.10
	msnyder-reverse-20060502-branchpoint:1.82
	binutils-csl-wrs-linux-3_4_4-21:1.68
	gdb-csl-morpho-4_1-4:1.80
	binutils-csl-morpho-4_1-4:1.82
	gdb-csl-sourcerygxx-3_4_4-17:1.80
	binutils-csl-sourcerygxx-3_4_4-17:1.82
	binutils-csl-wrs-linux-3_4_4-20:1.68
	readline_5_1-import-branch:1.82.0.8
	readline_5_1-import-branchpoint:1.82
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.80
	binutils-2_17-branch:1.82.0.6
	binutils-2_17-branchpoint:1.82
	gdb-csl-symbian-20060226-branch:1.80.0.4
	gdb-csl-symbian-20060226-branchpoint:1.80
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.80
	msnyder-reverse-20060331-branch:1.82.0.4
	msnyder-reverse-20060331-branchpoint:1.82
	binutils-csl-2_17-branch:1.82.0.2
	binutils-csl-2_17-branchpoint:1.82
	gdb-csl-available-20060303-branch:1.81.0.2
	gdb-csl-available-20060303-branchpoint:1.81
	gdb-csl-20060226-branch:1.80.0.2
	gdb-csl-20060226-branchpoint:1.80
	gdb_6_4-20051202-release:1.79
	msnyder-fork-checkpoint-branch:1.79.0.6
	msnyder-fork-checkpoint-branchpoint:1.79
	gdb-csl-gxxpro-6_3-branch:1.79.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.79
	gdb_6_4-branch:1.79.0.2
	gdb_6_4-2005-11-01-branchpoint:1.79
	gdb-csl-arm-20051020-branch:1.78.0.2
	gdb-csl-arm-20051020-branchpoint:1.78
	binutils-csl-gxxpro-3_4-branch:1.68.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.68
	binutils-2_16_1:1.68
	msnyder-tracepoint-checkpoint-branch:1.72.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.72
	gdb-csl-arm-20050325-2005-q1b:1.68
	binutils-csl-arm-2005q1b:1.68
	binutils-2_16:1.68
	gdb-csl-arm-20050325-2005-q1a:1.68
	binutils-csl-arm-2005q1a:1.68
	csl-arm-20050325-branch:1.68.0.6
	csl-arm-20050325-branchpoint:1.68
	binutils-csl-arm-2005q1-branch:1.68.0.4
	binutils-csl-arm-2005q1-branchpoint:1.68
	binutils-2_16-branch:1.68.0.2
	binutils-2_16-branchpoint:1.68
	csl-arm-2004-q3d:1.67
	gdb_6_3-20041109-release:1.66
	gdb_6_3-branch:1.66.0.2
	gdb_6_3-20041019-branchpoint:1.66
	csl-arm-2004-q3:1.66
	drow_intercu-merge-20040921:1.66
	drow_intercu-merge-20040915:1.64
	jimb-gdb_6_2-e500-branch:1.63.0.6
	jimb-gdb_6_2-e500-branchpoint:1.63
	gdb_6_2-20040730-release:1.63
	gdb_6_2-branch:1.63.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.63
	gdb_6_1_1-20040616-release:1.57
	binutils-2_15:1.56.6.2
	binutils-2_15-branchpoint:1.56
	csl-arm-2004-q1a:1.61
	csl-arm-2004-q1:1.60
	gdb_6_1-2004-04-05-release:1.57
	drow_intercu-merge-20040402:1.60
	drow_intercu-merge-20040327:1.59
	ezannoni_pie-20040323-branch:1.58.0.2
	ezannoni_pie-20040323-branchpoint:1.58
	cagney_tramp-20040321-mergepoint:1.57
	cagney_tramp-20040309-branch:1.57.0.4
	cagney_tramp-20040309-branchpoint:1.57
	gdb_6_1-branch:1.57.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.57
	drow_intercu-20040221-branch:1.56.0.8
	drow_intercu-20040221-branchpoint:1.56
	binutils-2_15-branch:1.56.0.6
	cagney_bfdfile-20040213-branch:1.56.0.4
	cagney_bfdfile-20040213-branchpoint:1.56
	drow-cplus-merge-20040208:1.56
	carlton_dictionary-20040126-merge:1.56
	cagney_bigcore-20040122-branch:1.56.0.2
	cagney_bigcore-20040122-branchpoint:1.56
	drow-cplus-merge-20040113:1.56
	csl-arm-2003-q4:1.56
	drow-cplus-merge-20031224:1.56
	drow-cplus-merge-20031220:1.56
	carlton_dictionary-20031215-merge:1.56
	drow-cplus-merge-20031214:1.56
	carlton-dictionary-20031111-merge:1.52
	gdb_6_0-2003-10-04-release:1.42
	kettenis_sparc-20030918-branch:1.49.0.6
	kettenis_sparc-20030918-branchpoint:1.49
	carlton_dictionary-20030917-merge:1.49
	ezannoni_pie-20030916-branchpoint:1.49
	ezannoni_pie-20030916-branch:1.49.0.4
	cagney_x86i386-20030821-branch:1.49.0.2
	cagney_x86i386-20030821-branchpoint:1.49
	carlton_dictionary-20030805-merge:1.46
	carlton_dictionary-20030627-merge:1.43
	gdb_6_0-branch:1.42.0.6
	gdb_6_0-2003-06-23-branchpoint:1.42
	jimb-ppc64-linux-20030613-branch:1.42.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.42
	binutils-2_14:1.37.18.1
	cagney_convert-20030606-branch:1.42.0.2
	cagney_convert-20030606-branchpoint:1.42
	cagney_writestrings-20030508-branch:1.38.0.2
	cagney_writestrings-20030508-branchpoint:1.38
	jimb-ppc64-linux-20030528-branch:1.41.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.41
	carlton_dictionary-20030523-merge:1.41
	cagney_fileio-20030521-branch:1.41.0.4
	cagney_fileio-20030521-branchpoint:1.41
	kettenis_i386newframe-20030517-mergepoint:1.41
	jimb-ppc64-linux-20030509-branch:1.41.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.41
	kettenis_i386newframe-20030504-mergepoint:1.37
	carlton_dictionary-20030430-merge:1.37
	binutils-2_14-branch:1.37.0.18
	binutils-2_14-branchpoint:1.37
	kettenis_i386newframe-20030419-branch:1.37.0.16
	kettenis_i386newframe-20030419-branchpoint:1.37
	carlton_dictionary-20030416-merge:1.37
	cagney_frameaddr-20030409-mergepoint:1.37
	kettenis_i386newframe-20030406-branch:1.37.0.14
	kettenis_i386newframe-20030406-branchpoint:1.37
	cagney_frameaddr-20030403-branchpoint:1.37
	cagney_frameaddr-20030403-branch:1.37.0.12
	cagney_framebase-20030330-mergepoint:1.37
	cagney_framebase-20030326-branch:1.37.0.10
	cagney_framebase-20030326-branchpoint:1.37
	cagney_lazyid-20030317-branch:1.37.0.8
	cagney_lazyid-20030317-branchpoint:1.37
	kettenis-i386newframe-20030316-mergepoint:1.37
	offbyone-20030313-branch:1.37.0.6
	offbyone-20030313-branchpoint:1.37
	kettenis-i386newframe-20030308-branch:1.37.0.4
	kettenis-i386newframe-20030308-branchpoint:1.37
	carlton_dictionary-20030305-merge:1.37
	cagney_offbyone-20030303-branch:1.37.0.2
	cagney_offbyone-20030303-branchpoint:1.37
	carlton_dictionary-20030207-merge:1.35
	interps-20030202-branch:1.35.0.2
	interps-20030202-branchpoint:1.35
	cagney-unwind-20030108-branch:1.33.0.2
	cagney-unwind-20030108-branchpoint:1.33
	binutils-2_13_2_1:1.29.2.1
	binutils-2_13_2:1.29.2.1
	carlton_dictionary-20021223-merge:1.33
	gdb_5_3-2002-12-12-release:1.31
	carlton_dictionary-20021115-merge:1.31
	binutils-2_13_1:1.29.2.1
	kseitz_interps-20021105-merge:1.31
	kseitz_interps-20021103-merge:1.31
	drow-cplus-merge-20021020:1.31
	drow-cplus-merge-20021025:1.31
	carlton_dictionary-20021025-merge:1.31
	carlton_dictionary-20021011-merge:1.31
	drow-cplus-branch:1.31.0.12
	drow-cplus-branchpoint:1.31
	kseitz_interps-20020930-merge:1.31
	carlton_dictionary-20020927-merge:1.31
	carlton_dictionary-branch:1.31.0.10
	carlton_dictionary-20020920-branchpoint:1.31
	sid-20020905-branchpoint:1.31
	sid-20020905-branch:1.31.0.8
	gdb_5_3-branch:1.31.0.6
	gdb_5_3-2002-09-04-branchpoint:1.31
	kseitz_interps-20020829-merge:1.31
	cagney_sysregs-20020825-branch:1.31.0.4
	cagney_sysregs-20020825-branchpoint:1.31
	readline_4_3-import-branch:1.31.0.2
	readline_4_3-import-branchpoint:1.31
	binutils-2_13:1.29
	gdb_5_2_1-2002-07-23-release:1.21
	binutils-2_13-branchpoint:1.29
	binutils-2_13-branch:1.29.0.2
	kseitz_interps-20020528-branch:1.24.0.4
	kseitz_interps-20020528-branchpoint:1.24
	cagney_regbuf-20020515-branch:1.24.0.2
	cagney_regbuf-20020515-branchpoint:1.24
	binutils-2_12_1:1.19.2.3
	jimb-macro-020506-branch:1.23.0.2
	jimb-macro-020506-branchpoint:1.23
	gdb_5_2-2002-04-29-release:1.21
	binutils-2_12:1.19.2.1
	gdb_5_2-branch:1.21.0.2
	gdb_5_2-2002-03-03-branchpoint:1.21
	binutils-2_12-branch:1.19.0.2
	binutils-2_12-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.17
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	x86_64versiong3:1.1
	binutils_latest_snapshot:1.131;
locks; strict;
comment	@ * @;


1.131
date	2013.08.24.22.16.41;	author macro;	state Exp;
branches;
next	1.130;

1.130
date	2013.07.05.09.51.00;	author krebbel;	state Exp;
branches;
next	1.129;

1.129
date	2013.07.05.09.45.43;	author krebbel;	state Exp;
branches;
next	1.128;

1.128
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.127;

1.127
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2013.02.10.04.36.32;	author amodra;	state Exp;
branches;
next	1.125;

1.125
date	2013.01.10.20.03.54;	author hjl;	state Exp;
branches;
next	1.124;

1.124
date	2012.11.05.12.31.08;	author krebbel;	state Exp;
branches;
next	1.123;

1.123
date	2012.09.03.12.03.48;	author krebbel;	state Exp;
branches;
next	1.122;

1.122
date	2012.09.02.12.17.26;	author hjl;	state Exp;
branches;
next	1.121;

1.121
date	2012.07.13.15.47.23;	author krebbel;	state Exp;
branches
	1.121.4.1;
next	1.120;

1.120
date	2012.07.13.14.22.48;	author nickc;	state Exp;
branches;
next	1.119;

1.119
date	2012.06.29.14.46.02;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2012.05.07.03.27.52;	author macro;	state Exp;
branches;
next	1.117;

1.117
date	2012.04.24.05.12.36;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2012.04.20.11.45.54;	author krebbel;	state Exp;
branches;
next	1.115;

1.115
date	2012.03.30.13.38.04;	author krebbel;	state Exp;
branches;
next	1.114;

1.114
date	2012.03.30.13.37.13;	author krebbel;	state Exp;
branches;
next	1.113;

1.113
date	2012.03.30.13.36.22;	author krebbel;	state Exp;
branches;
next	1.112;

1.112
date	2012.03.30.13.35.33;	author krebbel;	state Exp;
branches;
next	1.111;

1.111
date	2012.03.13.06.04.36;	author amodra;	state Exp;
branches;
next	1.110;

1.110
date	2011.12.22.15.00.44;	author sky;	state Exp;
branches;
next	1.109;

1.109
date	2011.10.19.07.17.18;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2011.06.13.00.59.12;	author amodra;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2010.10.25.15.54.15;	author drow;	state Exp;
branches;
next	1.106;

1.106
date	2010.08.25.14.53.45;	author hjl;	state Exp;
branches;
next	1.105;

1.105
date	2010.02.04.09.16.41;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2009.06.18.14.18.29;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2009.06.17.18.08.35;	author hjl;	state Exp;
branches;
next	1.101;

1.101
date	2009.03.20.12.57.15;	author krebbel;	state Exp;
branches;
next	1.100;

1.100
date	2008.12.04.08.43.26;	author krebbel;	state Exp;
branches;
next	1.99;

1.99
date	2008.11.25.13.03.56;	author nickc;	state Exp;
branches;
next	1.98;

1.98
date	2008.02.12.11.32.31;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2008.01.11.09.07.04;	author gingold;	state Exp;
branches;
next	1.96;

1.96
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.95;

1.95
date	2007.07.10.04.08.11;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.15.13.55.54;	author hjl;	state Exp;
branches;
next	1.92;

1.92
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2007.03.07.08.54.35;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2006.11.03.00.58.09;	author drow;	state Exp;
branches;
next	1.88;

1.88
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2006.09.20.14.38.17;	author sky;	state Exp;
branches;
next	1.85;

1.85
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2006.06.23.02.58.01;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2006.05.05.13.21.34;	author sky;	state Exp;
branches;
next	1.82;

1.82
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.80;

1.80
date	2006.02.21.01.51.58;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2005.10.25.16.19.07;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2005.10.06.19.21.14;	author drow;	state Exp;
branches;
next	1.77;

1.77
date	2005.08.25.02.32.10;	author hjl;	state Exp;
branches;
next	1.76;

1.76
date	2005.08.18.01.28.25;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2005.07.08.06.20.04;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2005.07.05.09.44.18;	author jakub;	state Exp;
branches;
next	1.73;

1.73
date	2005.06.20.18.12.10;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2005.05.05.14.33.58;	author hjl;	state Exp;
branches;
next	1.71;

1.71
date	2005.05.04.15.53.26;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2005.05.04.11.00.18;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.04.07.19.25;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2005.01.11.09.32.52;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2004.10.21.15.28.26;	author hjl;	state Exp;
branches;
next	1.66;

1.66
date	2004.09.17.07.14.29;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2004.09.16.14.52.07;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2004.08.13.03.15.58;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2004.06.29.13.46.33;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2004.06.24.04.46.22;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2004.04.22.14.45.32;	author jakub;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.25.12.48.40;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.22.02.28.17;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.27.10.03.05;	author sky;	state Exp;
branches;
next	1.56;

1.56
date	2003.12.04.03.03.27;	author amodra;	state Exp;
branches
	1.56.6.1
	1.56.8.1;
next	1.55;

1.55
date	2003.11.20.09.54.07;	author sky;	state Exp;
branches;
next	1.54;

1.54
date	2003.11.17.21.31.11;	author drow;	state Exp;
branches;
next	1.53;

1.53
date	2003.11.13.15.56.50;	author sky;	state Exp;
branches;
next	1.52;

1.52
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2003.11.04.06.16.35;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2003.11.03.15.17.39;	author drow;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.20.08.37.18;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.11.14.26.10;	author jakub;	state Exp;
branches;
next	1.47;

1.47
date	2003.08.07.08.38.08;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2003.07.07.11.14.40;	author jakub;	state Exp;
branches;
next	1.45;

1.45
date	2003.07.04.13.53.37;	author jakub;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.01.14.44.59;	author sky;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.25.06.40.23;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.30.15.50.10;	author jakub;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.09.16.41.42;	author sky;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.09.15.29.46;	author sky;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.09.15.17.54;	author sky;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.09.02.27.10;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.19.14.14.16;	author amodra;	state Exp;
branches
	1.37.16.1
	1.37.18.1;
next	1.36;

1.36
date	2003.02.17.18.24.40;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2003.01.24.17.12.42;	author sky;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.20.11.44.48;	author sky;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.28.11.55.42;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.22.01.27.20;	author amodra;	state Exp;
branches
	1.31.10.1
	1.31.12.1;
next	1.30;

1.30
date	2002.07.23.12.29.33;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.11.05.33.28;	author amodra;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2002.07.02.09.05.51;	author sky;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.01.08.06.45;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.05.13.32.01;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.03.01.57.09;	author kazu;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.07.00.16.52;	author amodra;	state Exp;
branches
	1.24.2.1
	1.24.4.1;
next	1.23;

1.23
date	2002.04.04.19.53.37;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.28.03.27.45;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.19.18.22.16;	author sky;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.19.12.40.28;	author jakub;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.05.00.00.23;	author amodra;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2002.01.29.11.14.35;	author sky;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.18.16.21.38;	author sky;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.07.11.12.18;	author jakub;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.23.12.17.17;	author jakub;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.14.18.48.26;	author sky;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.10.00.23.34;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.08.18.45.46;	author sky;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.15.07.28.45;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.29.06.21.59;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.20.23.30.36;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.27.08.59.07;	author aj;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.11.07.59.54;	author aj;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.08.21.04.00;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.10.00.55.54;	author nickc;	state Exp;
branches;
next	;

1.121.4.1
date	2012.11.12.09.04.13;	author gingold;	state Exp;
branches;
next	;

1.108.2.1
date	2012.05.11.12.24.30;	author nickc;	state Exp;
branches;
next	;

1.56.6.1
date	2004.04.08.12.41.45;	author amodra;	state Exp;
branches;
next	1.56.6.2;

1.56.6.2
date	2004.04.09.18.28.01;	author drow;	state Exp;
branches;
next	;

1.56.8.1
date	2004.03.27.17.37.35;	author drow;	state Exp;
branches;
next	1.56.8.2;

1.56.8.2
date	2004.04.02.16.47.36;	author drow;	state Exp;
branches;
next	1.56.8.3;

1.56.8.3
date	2004.09.16.17.00.31;	author drow;	state Exp;
branches;
next	1.56.8.4;

1.56.8.4
date	2004.09.21.20.44.03;	author drow;	state Exp;
branches;
next	;

1.37.16.1
date	2003.05.18.09.43.46;	author kettenis;	state Exp;
branches;
next	;

1.37.18.1
date	2003.05.15.19.20.22;	author drow;	state Exp;
branches;
next	;

1.31.10.1
date	2002.12.23.19.37.48;	author carlton;	state Exp;
branches;
next	1.31.10.2;

1.31.10.2
date	2003.02.07.19.17.39;	author carlton;	state Exp;
branches;
next	1.31.10.3;

1.31.10.3
date	2003.03.06.00.56.16;	author carlton;	state Exp;
branches;
next	1.31.10.4;

1.31.10.4
date	2003.05.23.18.40.27;	author carlton;	state Exp;
branches;
next	1.31.10.5;

1.31.10.5
date	2003.06.27.21.49.22;	author carlton;	state Exp;
branches;
next	1.31.10.6;

1.31.10.6
date	2003.08.05.17.12.51;	author carlton;	state Exp;
branches;
next	1.31.10.7;

1.31.10.7
date	2003.09.17.21.27.55;	author carlton;	state Exp;
branches;
next	1.31.10.8;

1.31.10.8
date	2003.11.11.23.50.23;	author carlton;	state Exp;
branches;
next	1.31.10.9;

1.31.10.9
date	2003.12.15.23.59.39;	author carlton;	state Exp;
branches;
next	;

1.31.12.1
date	2003.12.14.20.26.44;	author drow;	state Exp;
branches;
next	;

1.29.2.1
date	2002.08.22.01.34.15;	author amodra;	state Exp;
branches;
next	;

1.24.2.1
date	2002.06.15.16.42.38;	author cagney;	state Exp;
branches;
next	;

1.24.4.1
date	2002.06.20.01.30.38;	author kseitz;	state Exp;
branches;
next	1.24.4.2;

1.24.4.2
date	2002.07.22.21.46.46;	author kseitz;	state Exp;
branches;
next	1.24.4.3;

1.24.4.3
date	2002.08.09.18.34.16;	author kseitz;	state Exp;
branches;
next	1.24.4.4;

1.24.4.4
date	2002.08.30.22.52.37;	author kseitz;	state Exp;
branches;
next	;

1.19.2.1
date	2002.02.19.13.10.26;	author jakub;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.04.04.14.52.59;	author amodra;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2002.05.09.11.50.27;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.131
log
@	* elf32-tilepro.c (tilepro_elf_finish_dynamic_sections): Don't
	set GOT's entry size if there is no ELF section data.
	* elf64-s390.c (elf_s390_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_sections):
	Likewise.
@
text
@/* IBM S/390-specific support for 64-bit ELF
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2012 Free Software Foundation, Inc.
   Contributed Martin Schwidefsky (schwidefsky@@de.ibm.com).

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/s390.h"

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE      (((bfd_vma)0) - 1)

static bfd_reloc_status_type
s390_tls_reloc (bfd *, arelent *, asymbol *, void *,
		asection *, bfd *, char **);
static bfd_reloc_status_type
s390_elf_ldisp_reloc (bfd *, arelent *, asymbol *, void *,
		      asection *, bfd *, char **);

/* The relocation "howto" table.  */
static reloc_howto_type elf_howto_table[] =
{
  HOWTO (R_390_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = 2 byte, 2 = 4 byte) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_390_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO(R_390_8,         0, 0,  8, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_8",        FALSE, 0,0x000000ff, FALSE),
  HOWTO(R_390_12,        0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_12",       FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_16,        0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_16",       FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_32,        0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_32",       FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PC32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32",     FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT12",    FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT32",    FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLT32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32",    FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_COPY,      0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_COPY",     FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GLOB_DAT,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GLOB_DAT", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_JMP_SLOT,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_JMP_SLOT", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_RELATIVE,  0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_RELATIVE", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF32", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTPC,     0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPC",    FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOT16,     0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT16",    FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PC16,      0, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16",     FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16DBL",  FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT16DBL", FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32DBL",  FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32DBL", FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPCDBL", FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_64,        0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_64",       FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_PC64,	 0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC64",     FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOT64,	 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT64",    FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_PLT64,	 0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT64",    FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOTENT,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTENT",   FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_GOTOFF64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF64", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTPLT12,	 0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_GOTPLT12", FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOTPLT16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_GOTPLT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT32", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTPLT64,	 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT64", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTPLTENT, 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLTENT",FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_PLTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PLTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF32", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLTOFF64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF64", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_TLS_LOAD, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LOAD", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_GDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_GDCALL", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_LDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LDCALL", FALSE, 0, 0, FALSE),
  EMPTY_HOWTO (R_390_TLS_GD32),	/* Empty entry for R_390_TLS_GD32.  */
  HOWTO(R_390_TLS_GD64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GD64", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_GOTIE12, 0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE12", FALSE, 0, 0x00000fff, FALSE),
  EMPTY_HOWTO (R_390_TLS_GOTIE32),	/* Empty entry for R_390_TLS_GOTIE32.  */
  HOWTO(R_390_TLS_GOTIE64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE64", FALSE, 0, MINUS_ONE, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDM32),	/* Empty entry for R_390_TLS_LDM32.  */
  HOWTO(R_390_TLS_LDM64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDM64", FALSE, 0, MINUS_ONE, FALSE),
  EMPTY_HOWTO (R_390_TLS_IE32),	/* Empty entry for R_390_TLS_IE32.  */
  HOWTO(R_390_TLS_IE64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IE64", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_IEENT, 1, 2, 32, TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IEENT", FALSE, 0, MINUS_ONE, TRUE),
  EMPTY_HOWTO (R_390_TLS_LE32),	/* Empty entry for R_390_TLS_LE32.  */
  HOWTO(R_390_TLS_LE64,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LE64", FALSE, 0, MINUS_ONE, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDO32),	/* Empty entry for R_390_TLS_LDO32.  */
  HOWTO(R_390_TLS_LDO64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDO64", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_DTPMOD, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPMOD", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_DTPOFF, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPOFF", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_TPOFF, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_TPOFF", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_20,        0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_20",      FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOT20,	 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOT20",   FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOTPLT20,  0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOTPLT20", FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_TLS_GOTIE20, 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_TLS_GOTIE20", FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_IRELATIVE, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_IRELATIVE", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_PC12DBL,   1, 1, 12,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC12DBL",  FALSE, 0,0x00000fff, TRUE),
  HOWTO(R_390_PLT12DBL,  1, 1, 12,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT12DBL", FALSE, 0,0x00000fff, TRUE),
  HOWTO(R_390_PC24DBL,   1, 2, 24,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC24DBL",  FALSE, 0,0x00ffffff, TRUE),
  HOWTO(R_390_PLT24DBL,  1, 2, 24,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT24DBL", FALSE, 0,0x00ffffff, TRUE),
};

/* GNU extension to record C++ vtable hierarchy.  */
static reloc_howto_type elf64_s390_vtinherit_howto =
  HOWTO (R_390_GNU_VTINHERIT, 0,4,0,FALSE,0,complain_overflow_dont, NULL, "R_390_GNU_VTINHERIT", FALSE,0, 0, FALSE);
static reloc_howto_type elf64_s390_vtentry_howto =
  HOWTO (R_390_GNU_VTENTRY, 0,4,0,FALSE,0,complain_overflow_dont, _bfd_elf_rel_vtable_reloc_fn,"R_390_GNU_VTENTRY", FALSE,0,0, FALSE);

static reloc_howto_type *
elf_s390_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
{
  switch (code)
    {
    case BFD_RELOC_NONE:
      return &elf_howto_table[(int) R_390_NONE];
    case BFD_RELOC_8:
      return &elf_howto_table[(int) R_390_8];
    case BFD_RELOC_390_12:
      return &elf_howto_table[(int) R_390_12];
    case BFD_RELOC_16:
      return &elf_howto_table[(int) R_390_16];
    case BFD_RELOC_32:
      return &elf_howto_table[(int) R_390_32];
    case BFD_RELOC_CTOR:
      return &elf_howto_table[(int) R_390_32];
    case BFD_RELOC_32_PCREL:
      return &elf_howto_table[(int) R_390_PC32];
    case BFD_RELOC_390_GOT12:
      return &elf_howto_table[(int) R_390_GOT12];
    case BFD_RELOC_32_GOT_PCREL:
      return &elf_howto_table[(int) R_390_GOT32];
    case BFD_RELOC_390_PLT32:
      return &elf_howto_table[(int) R_390_PLT32];
    case BFD_RELOC_390_COPY:
      return &elf_howto_table[(int) R_390_COPY];
    case BFD_RELOC_390_GLOB_DAT:
      return &elf_howto_table[(int) R_390_GLOB_DAT];
    case BFD_RELOC_390_JMP_SLOT:
      return &elf_howto_table[(int) R_390_JMP_SLOT];
    case BFD_RELOC_390_RELATIVE:
      return &elf_howto_table[(int) R_390_RELATIVE];
    case BFD_RELOC_32_GOTOFF:
      return &elf_howto_table[(int) R_390_GOTOFF32];
    case BFD_RELOC_390_GOTPC:
      return &elf_howto_table[(int) R_390_GOTPC];
    case BFD_RELOC_390_GOT16:
      return &elf_howto_table[(int) R_390_GOT16];
    case BFD_RELOC_16_PCREL:
      return &elf_howto_table[(int) R_390_PC16];
    case BFD_RELOC_390_PC12DBL:
      return &elf_howto_table[(int) R_390_PC12DBL];
    case BFD_RELOC_390_PLT12DBL:
      return &elf_howto_table[(int) R_390_PLT12DBL];
    case BFD_RELOC_390_PC16DBL:
      return &elf_howto_table[(int) R_390_PC16DBL];
    case BFD_RELOC_390_PLT16DBL:
      return &elf_howto_table[(int) R_390_PLT16DBL];
    case BFD_RELOC_390_PC24DBL:
      return &elf_howto_table[(int) R_390_PC24DBL];
    case BFD_RELOC_390_PLT24DBL:
      return &elf_howto_table[(int) R_390_PLT24DBL];
    case BFD_RELOC_390_PC32DBL:
      return &elf_howto_table[(int) R_390_PC32DBL];
    case BFD_RELOC_390_PLT32DBL:
      return &elf_howto_table[(int) R_390_PLT32DBL];
    case BFD_RELOC_390_GOTPCDBL:
      return &elf_howto_table[(int) R_390_GOTPCDBL];
    case BFD_RELOC_64:
      return &elf_howto_table[(int) R_390_64];
    case BFD_RELOC_64_PCREL:
      return &elf_howto_table[(int) R_390_PC64];
    case BFD_RELOC_390_GOT64:
      return &elf_howto_table[(int) R_390_GOT64];
    case BFD_RELOC_390_PLT64:
      return &elf_howto_table[(int) R_390_PLT64];
    case BFD_RELOC_390_GOTENT:
      return &elf_howto_table[(int) R_390_GOTENT];
    case BFD_RELOC_16_GOTOFF:
      return &elf_howto_table[(int) R_390_GOTOFF16];
    case BFD_RELOC_390_GOTOFF64:
      return &elf_howto_table[(int) R_390_GOTOFF64];
    case BFD_RELOC_390_GOTPLT12:
      return &elf_howto_table[(int) R_390_GOTPLT12];
    case BFD_RELOC_390_GOTPLT16:
      return &elf_howto_table[(int) R_390_GOTPLT16];
    case BFD_RELOC_390_GOTPLT32:
      return &elf_howto_table[(int) R_390_GOTPLT32];
    case BFD_RELOC_390_GOTPLT64:
      return &elf_howto_table[(int) R_390_GOTPLT64];
    case BFD_RELOC_390_GOTPLTENT:
      return &elf_howto_table[(int) R_390_GOTPLTENT];
    case BFD_RELOC_390_PLTOFF16:
      return &elf_howto_table[(int) R_390_PLTOFF16];
    case BFD_RELOC_390_PLTOFF32:
      return &elf_howto_table[(int) R_390_PLTOFF32];
    case BFD_RELOC_390_PLTOFF64:
      return &elf_howto_table[(int) R_390_PLTOFF64];
    case BFD_RELOC_390_TLS_LOAD:
      return &elf_howto_table[(int) R_390_TLS_LOAD];
    case BFD_RELOC_390_TLS_GDCALL:
      return &elf_howto_table[(int) R_390_TLS_GDCALL];
    case BFD_RELOC_390_TLS_LDCALL:
      return &elf_howto_table[(int) R_390_TLS_LDCALL];
    case BFD_RELOC_390_TLS_GD64:
      return &elf_howto_table[(int) R_390_TLS_GD64];
    case BFD_RELOC_390_TLS_GOTIE12:
      return &elf_howto_table[(int) R_390_TLS_GOTIE12];
    case BFD_RELOC_390_TLS_GOTIE64:
      return &elf_howto_table[(int) R_390_TLS_GOTIE64];
    case BFD_RELOC_390_TLS_LDM64:
      return &elf_howto_table[(int) R_390_TLS_LDM64];
    case BFD_RELOC_390_TLS_IE64:
      return &elf_howto_table[(int) R_390_TLS_IE64];
    case BFD_RELOC_390_TLS_IEENT:
      return &elf_howto_table[(int) R_390_TLS_IEENT];
    case BFD_RELOC_390_TLS_LE64:
      return &elf_howto_table[(int) R_390_TLS_LE64];
    case BFD_RELOC_390_TLS_LDO64:
      return &elf_howto_table[(int) R_390_TLS_LDO64];
    case BFD_RELOC_390_TLS_DTPMOD:
      return &elf_howto_table[(int) R_390_TLS_DTPMOD];
    case BFD_RELOC_390_TLS_DTPOFF:
      return &elf_howto_table[(int) R_390_TLS_DTPOFF];
    case BFD_RELOC_390_TLS_TPOFF:
      return &elf_howto_table[(int) R_390_TLS_TPOFF];
    case BFD_RELOC_390_20:
      return &elf_howto_table[(int) R_390_20];
    case BFD_RELOC_390_GOT20:
      return &elf_howto_table[(int) R_390_GOT20];
    case BFD_RELOC_390_GOTPLT20:
      return &elf_howto_table[(int) R_390_GOTPLT20];
    case BFD_RELOC_390_TLS_GOTIE20:
      return &elf_howto_table[(int) R_390_TLS_GOTIE20];
    case BFD_RELOC_390_IRELATIVE:
      return &elf_howto_table[(int) R_390_IRELATIVE];
    case BFD_RELOC_VTABLE_INHERIT:
      return &elf64_s390_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf64_s390_vtentry_howto;
    default:
      break;
    }
  return 0;
}

static reloc_howto_type *
elf_s390_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (elf_howto_table) / sizeof (elf_howto_table[0]);
       i++)
    if (elf_howto_table[i].name != NULL
	&& strcasecmp (elf_howto_table[i].name, r_name) == 0)
      return &elf_howto_table[i];

    if (strcasecmp (elf64_s390_vtinherit_howto.name, r_name) == 0)
      return &elf64_s390_vtinherit_howto;
    if (strcasecmp (elf64_s390_vtentry_howto.name, r_name) == 0)
      return &elf64_s390_vtentry_howto;

  return NULL;
}

/* We need to use ELF64_R_TYPE so we have our own copy of this function,
   and elf64-s390.c has its own copy.  */

static void
elf_s390_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
			arelent *cache_ptr,
			Elf_Internal_Rela *dst)
{
  unsigned int r_type = ELF64_R_TYPE(dst->r_info);
  switch (r_type)
    {
    case R_390_GNU_VTINHERIT:
      cache_ptr->howto = &elf64_s390_vtinherit_howto;
      break;

    case R_390_GNU_VTENTRY:
      cache_ptr->howto = &elf64_s390_vtentry_howto;
      break;

    default:
      if (r_type >= sizeof (elf_howto_table) / sizeof (elf_howto_table[0]))
	{
	  (*_bfd_error_handler) (_("%B: invalid relocation type %d"),
				 abfd, (int) r_type);
	  r_type = R_390_NONE;
	}
      cache_ptr->howto = &elf_howto_table[r_type];
    }
}

/* A relocation function which doesn't do anything.  */
static bfd_reloc_status_type
s390_tls_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		arelent *reloc_entry,
		asymbol *symbol ATTRIBUTE_UNUSED,
		void * data ATTRIBUTE_UNUSED,
		asection *input_section,
		bfd *output_bfd,
		char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

/* Handle the large displacement relocs.  */
static bfd_reloc_status_type
s390_elf_ldisp_reloc (bfd *abfd,
		      arelent *reloc_entry,
		      asymbol *symbol,
		      void * data,
		      asection *input_section,
		      bfd *output_bfd,
		      char **error_message ATTRIBUTE_UNUSED)
{
  reloc_howto_type *howto = reloc_entry->howto;
  bfd_vma relocation;
  bfd_vma insn;

  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
  if (output_bfd != NULL)
    return bfd_reloc_continue;

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  relocation = (symbol->value
		+ symbol->section->output_section->vma
		+ symbol->section->output_offset);
  relocation += reloc_entry->addend;
  if (howto->pc_relative)
    {
      relocation -= (input_section->output_section->vma
		     + input_section->output_offset);
      relocation -= reloc_entry->address;
    }

  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn |= (relocation & 0xfff) << 16 | (relocation & 0xff000) >> 4;
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);

  if ((bfd_signed_vma) relocation < - 0x80000
      || (bfd_signed_vma) relocation > 0x7ffff)
    return bfd_reloc_overflow;
  else
    return bfd_reloc_ok;
}

static bfd_boolean
elf_s390_is_local_label_name (bfd *abfd, const char *name)
{
  if (name[0] == '.' && (name[1] == 'X' || name[1] == 'L'))
    return TRUE;

  return _bfd_elf_is_local_label_name (abfd, name);
}

/* Functions for the 390 ELF linker.  */

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/lib/ld64.so.1"

/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

/* The size in bytes of the first entry in the procedure linkage table.  */
#define PLT_FIRST_ENTRY_SIZE 32
/* The size in bytes of an entry in the procedure linkage table.  */
#define PLT_ENTRY_SIZE 32

#define GOT_ENTRY_SIZE 8

#define RELA_ENTRY_SIZE sizeof (Elf64_External_Rela)

/* The first three entries in a procedure linkage table are reserved,
   and the initial contents are unimportant (we zero them out).
   Subsequent entries look like this.  See the SVR4 ABI 386
   supplement to see how this works.  */

/* For the s390, simple addr offset can only be 0 - 4096.
   To use the full 16777216 TB address space, several instructions
   are needed to load an address in a register and execute
   a branch( or just saving the address)

   Furthermore, only r 0 and 1 are free to use!!!  */

/* The first 3 words in the GOT are then reserved.
   Word 0 is the address of the dynamic table.
   Word 1 is a pointer to a structure describing the object
   Word 2 is used to point to the loader entry address.

   The code for PLT entries looks like this:

   The GOT holds the address in the PLT to be executed.
   The loader then gets:
   24(15) =  Pointer to the structure describing the object.
   28(15) =  Offset in symbol table
   The loader  must  then find the module where the function is
   and insert the address in the GOT.

   PLT1: LARL 1,<fn>@@GOTENT # 6 bytes  Load address of GOT entry in r1
         LG   1,0(1)      # 6 bytes  Load address from GOT in r1
         BCR  15,1        # 2 bytes  Jump to address
   RET1: BASR 1,0         # 2 bytes  Return from GOT 1st time
         LGF  1,12(1)     # 6 bytes  Load offset in symbl table in r1
         BRCL 15,-x       # 6 bytes  Jump to start of PLT
         .long ?          # 4 bytes  offset into .rela.plt

   Total = 32 bytes per PLT entry
   Fixup at offset 2: relative address to GOT entry
   Fixup at offset 22: relative branch to PLT0
   Fixup at offset 28: 32 bit offset into .rela.plt

   A 32 bit offset into the symbol table is enough. It allows for
   .rela.plt sections up to a size of 2 gigabyte.  A single dynamic
   object (the main program, any shared library) is limited to 4GB in
   size.  Having a .rela.plt of 2GB would already make the .plt
   section bigger than 8GB.  */

static const bfd_byte elf_s390x_plt_entry[PLT_ENTRY_SIZE] =
  {
    0xc0, 0x10, 0x00, 0x00, 0x00, 0x00,     /* larl    %r1,.       */
    0xe3, 0x10, 0x10, 0x00, 0x00, 0x04,     /* lg      %r1,0(%r1)  */
    0x07, 0xf1,                             /* br      %r1         */
    0x0d, 0x10,                             /* basr    %r1,%r0     */
    0xe3, 0x10, 0x10, 0x0c, 0x00, 0x14,     /* lgf     %r1,12(%r1) */
    0xc0, 0xf4, 0x00, 0x00, 0x00, 0x00,     /* jg      first plt   */
    0x00, 0x00, 0x00, 0x00                  /* .long   0x00000000  */
  };

/* The first PLT entry pushes the offset into the symbol table
   from R1 onto the stack at 56(15) and the loader object info
   at 48(15), loads the loader address in R1 and jumps to it.  */

/* The first entry in the PLT:

  PLT0:
     STG  1,56(15)  # r1 contains the offset into the symbol table
     LARL 1,_GLOBAL_OFFSET_TABLE # load address of global offset table
     MVC  48(8,15),8(1) # move loader ino (object struct address) to stack
     LG   1,16(1)   # get entry address of loader
     BCR  15,1      # jump to loader

     Fixup at offset 8: relative address to start of GOT.  */

static const bfd_byte elf_s390x_first_plt_entry[PLT_FIRST_ENTRY_SIZE] =
  {
    0xe3, 0x10, 0xf0, 0x38, 0x00, 0x24,     /* stg     %r1,56(%r15)      */
    0xc0, 0x10, 0x00, 0x00, 0x00, 0x00,     /* larl    %r1,.             */
    0xd2, 0x07, 0xf0, 0x30, 0x10, 0x08,     /* mvc     48(8,%r15),8(%r1) */
    0xe3, 0x10, 0x10, 0x10, 0x00, 0x04,     /* lg      %r1,16(%r1)       */
    0x07, 0xf1,                             /* br      %r1               */
    0x07, 0x00,                             /* nopr    %r0               */
    0x07, 0x00,                             /* nopr    %r0               */
    0x07, 0x00                              /* nopr    %r0               */
  };


/* s390 ELF linker hash entry.  */

struct elf_s390_link_hash_entry
{
  struct elf_link_hash_entry elf;

  /* Track dynamic relocs copied for this symbol.  */
  struct elf_dyn_relocs *dyn_relocs;

  /* Number of GOTPLT references for a function.  */
  bfd_signed_vma gotplt_refcount;

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2
#define GOT_TLS_IE	3
#define GOT_TLS_IE_NLT	3
  unsigned char tls_type;

  /* For pointer equality reasons we might need to change the symbol
     type from STT_GNU_IFUNC to STT_FUNC together with its value and
     section entry.  So after alloc_dynrelocs only these values should
     be used.  In order to check whether a symbol is IFUNC use
     s390_is_ifunc_symbol_p.  */
  bfd_vma ifunc_resolver_address;
  asection *ifunc_resolver_section;
};

#define elf_s390_hash_entry(ent) \
  ((struct elf_s390_link_hash_entry *)(ent))

/* This structure represents an entry in the local PLT list needed for
   local IFUNC symbols.  */
struct plt_entry
{
  /* The section of the local symbol.
     Set in relocate_section and used in finish_dynamic_sections.  */
  asection *sec;

  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } plt;
};

/* NOTE: Keep this structure in sync with
   the one declared in elf32-s390.c.  */
struct elf_s390_obj_tdata
{
  struct elf_obj_tdata root;

  /* A local PLT is needed for ifunc symbols.  */
  struct plt_entry *local_plt;

  /* TLS type for each local got entry.  */
  char *local_got_tls_type;
};

#define elf_s390_tdata(abfd) \
  ((struct elf_s390_obj_tdata *) (abfd)->tdata.any)

#define elf_s390_local_plt(abfd) \
  (elf_s390_tdata (abfd)->local_plt)

#define elf_s390_local_got_tls_type(abfd) \
  (elf_s390_tdata (abfd)->local_got_tls_type)

#define is_s390_elf(bfd)				\
  (bfd_get_flavour (bfd) == bfd_target_elf_flavour	\
   && elf_tdata (bfd) != NULL				\
   && elf_object_id (bfd) == S390_ELF_DATA)

static bfd_boolean
elf_s390_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct elf_s390_obj_tdata),
				  S390_ELF_DATA);
}

static bfd_boolean
elf_s390_object_p (bfd *abfd)
{
  /* Set the right machine number for an s390 elf32 file.  */
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_64);
}

/* s390 ELF linker hash table.  */

struct elf_s390_link_hash_table
{
  struct elf_link_hash_table elf;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sdynbss;
  asection *srelbss;
  asection *irelifunc;

  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ldm_got;

  /* Small local sym cache.  */
  struct sym_cache sym_cache;
};

/* Get the s390 ELF linker hash table from a link_info structure.  */

#define elf_s390_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == S390_ELF_DATA ? ((struct elf_s390_link_hash_table *) ((p)->hash)) : NULL)

#define ELF64 1
#include "elf-s390-common.c"

/* Create an entry in an s390 ELF linker hash table.  */

static struct bfd_hash_entry *
link_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf_s390_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf_s390_link_hash_entry *eh;

      eh = (struct elf_s390_link_hash_entry *) entry;
      eh->dyn_relocs = NULL;
      eh->gotplt_refcount = 0;
      eh->tls_type = GOT_UNKNOWN;
      eh->ifunc_resolver_address = 0;
      eh->ifunc_resolver_section = NULL;
    }

  return entry;
}

/* Create an s390 ELF linker hash table.  */

static struct bfd_link_hash_table *
elf_s390_link_hash_table_create (bfd *abfd)
{
  struct elf_s390_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_s390_link_hash_table);

  ret = (struct elf_s390_link_hash_table *) bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc,
				      sizeof (struct elf_s390_link_hash_entry),
				      S390_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  return &ret->elf.root;
}

/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static bfd_boolean
create_got_section (bfd *dynobj,
		    struct bfd_link_info *info)
{
  struct elf_s390_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = elf_s390_hash_table (info);
  if (htab == NULL)
    return FALSE;

  htab->elf.sgot = bfd_get_linker_section (dynobj, ".got");
  htab->elf.sgotplt = bfd_get_linker_section (dynobj, ".got.plt");
  htab->elf.srelgot = bfd_get_linker_section (dynobj, ".rela.got");
  if (!htab->elf.sgot || !htab->elf.sgotplt || !htab->elf.srelgot)
    abort ();
  return TRUE;
}

/* Create .plt, .rela.plt, .got, .got.plt, .rela.got, .dynbss, and
   .rela.bss sections in DYNOBJ, and set up shortcuts to them in our
   hash table.  */

static bfd_boolean
elf_s390_create_dynamic_sections (bfd *dynobj,
				  struct bfd_link_info *info)
{
  struct elf_s390_link_hash_table *htab;

  htab = elf_s390_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (!htab->elf.sgot && !create_got_section (dynobj, info))
    return FALSE;

  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;

  htab->elf.splt = bfd_get_linker_section (dynobj, ".plt");
  htab->elf.srelplt = bfd_get_linker_section (dynobj, ".rela.plt");
  htab->sdynbss = bfd_get_linker_section (dynobj, ".dynbss");
  if (!info->shared)
    htab->srelbss = bfd_get_linker_section (dynobj, ".rela.bss");

  if (!htab->elf.splt || !htab->elf.srelplt || !htab->sdynbss
      || (!info->shared && !htab->srelbss))
    abort ();

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf_s390_copy_indirect_symbol (struct bfd_link_info *info,
			       struct elf_link_hash_entry *dir,
			       struct elf_link_hash_entry *ind)
{
  struct elf_s390_link_hash_entry *edir, *eind;

  edir = (struct elf_s390_link_hash_entry *) dir;
  eind = (struct elf_s390_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  /* Add reloc counts against the indirect sym to the direct sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }

  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
    }
  else
    _bfd_elf_link_hash_copy_indirect (info, dir, ind);
}

static int
elf_s390_tls_transition (struct bfd_link_info *info,
			 int r_type,
			 int is_local)
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_390_TLS_GD64:
    case R_390_TLS_IE64:
      if (is_local)
	return R_390_TLS_LE64;
      return R_390_TLS_IE64;
    case R_390_TLS_GOTIE64:
      if (is_local)
	return R_390_TLS_LE64;
      return R_390_TLS_GOTIE64;
    case R_390_TLS_LDM64:
      return R_390_TLS_LE64;
    }

  return r_type;
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  */

static bfd_boolean
elf_s390_check_relocs (bfd *abfd,
		       struct bfd_link_info *info,
		       asection *sec,
		       const Elf_Internal_Rela *relocs)
{
  struct elf_s390_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sreloc;
  bfd_signed_vma *local_got_refcounts;
  int tls_type, old_tls_type;

  if (info->relocatable)
    return TRUE;

  BFD_ASSERT (is_s390_elf (abfd));

  htab = elf_s390_hash_table (info);
  if (htab == NULL)
    return FALSE;

  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  sreloc = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned int r_type;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *isym;

      r_symndx = ELF64_R_SYM (rel->r_info);

      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
				 abfd,
				 r_symndx);
	  return FALSE;
	}

      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					abfd, r_symndx);
	  if (isym == NULL)
	    return FALSE;

	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
	    {
	      struct plt_entry *plt;

	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;

	      if (!s390_elf_create_ifunc_sections (htab->elf.dynobj, info))
		return FALSE;

	      if (local_got_refcounts == NULL)
		{
		  if (!elf_s390_allocate_local_syminfo (abfd, symtab_hdr))
		    return FALSE;
		  local_got_refcounts = elf_local_got_refcounts (abfd);
		}
	      plt = elf_s390_local_plt (abfd);
	      plt[r_symndx].plt.refcount++;
	    }
	  h = NULL;
	}
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      /* Create got section and local_got_refcounts array if they
	 are needed.  */
      r_type = elf_s390_tls_transition (info,
					ELF64_R_TYPE (rel->r_info),
					h == NULL);
      switch (r_type)
	{
	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOT64:
	case R_390_GOTENT:
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	case R_390_TLS_GD64:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE64:
	case R_390_TLS_IEENT:
	case R_390_TLS_IE64:
	case R_390_TLS_LDM64:
	  if (h == NULL
	      && local_got_refcounts == NULL)
	    {
	      if (!elf_s390_allocate_local_syminfo (abfd, symtab_hdr))
		return FALSE;
	      local_got_refcounts = elf_local_got_refcounts (abfd);
	    }

	  /* Fall through.  */
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	  if (htab->elf.sgot == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!create_got_section (htab->elf.dynobj, info))
		return FALSE;
	    }
	}

      if (h != NULL)
	{
	  if (htab->elf.dynobj == NULL)
	    htab->elf.dynobj = abfd;
	  if (!s390_elf_create_ifunc_sections (htab->elf.dynobj, info))
	    return FALSE;

	  /* Make sure an IFUNC symbol defined in a non-shared object
	     always gets a PLT slot.  */
	  if (s390_is_ifunc_symbol_p (h) && h->def_regular)
	    {
	      /* The symbol is called by the dynamic loader in order
		 to resolve the relocation.  So it is in fact also
		 referenced.  */
	      h->ref_regular = 1;
	      h->needs_plt = 1;
	    }
	}

      switch (r_type)
	{
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	  /* These relocs do not need a GOT slot.  They just load the
	     GOT pointer itself or address something else relative to
	     the GOT.  Since the GOT pointer has been set up above we
	     are done.  */
	  break;

	case R_390_PLT12DBL:
	case R_390_PLT16DBL:
	case R_390_PLT24DBL:
	case R_390_PLT32:
	case R_390_PLT32DBL:
	case R_390_PLT64:
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	case R_390_PLTOFF64:
	  /* This symbol requires a procedure linkage table entry.  We
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code which is
	     never referenced by a dynamic object, in which case we
	     don't need to generate a procedure linkage table entry
	     after all.  */

	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.  */
	  if (h != NULL)
	    {
	      h->needs_plt = 1;
	      h->plt.refcount += 1;
	    }
	  break;

	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	  /* This symbol requires either a procedure linkage table entry
	     or an entry in the local got. We actually build the entry
	     in adjust_dynamic_symbol because whether this is really a
	     global reference can change and with it the fact if we have
	     to create a plt entry or a local got entry. To be able to
	     make a once global symbol a local one we have to keep track
	     of the number of gotplt references that exist for this
	     symbol.  */
	  if (h != NULL)
	    {
	      ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount++;
	      h->needs_plt = 1;
	      h->plt.refcount += 1;
	    }
	  else
	    local_got_refcounts[r_symndx] += 1;
	  break;

	case R_390_TLS_LDM64:
	  htab->tls_ldm_got.refcount += 1;
	  break;

	case R_390_TLS_IE64:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE64:
	case R_390_TLS_IEENT:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  /* Fall through */

	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOT64:
	case R_390_GOTENT:
	case R_390_TLS_GD64:
	  /* This symbol requires a global offset table entry.  */
	  switch (r_type)
	    {
	    default:
	    case R_390_GOT12:
	    case R_390_GOT16:
	    case R_390_GOT20:
	    case R_390_GOT32:
	    case R_390_GOTENT:
	      tls_type = GOT_NORMAL;
	      break;
	    case R_390_TLS_GD64:
	      tls_type = GOT_TLS_GD;
	      break;
	    case R_390_TLS_IE64:
	    case R_390_TLS_GOTIE64:
	      tls_type = GOT_TLS_IE;
	      break;
	    case R_390_TLS_GOTIE12:
	    case R_390_TLS_GOTIE20:
	    case R_390_TLS_IEENT:
	      tls_type = GOT_TLS_IE_NLT;
	      break;
	    }

	  if (h != NULL)
	    {
	      h->got.refcount += 1;
	      old_tls_type = elf_s390_hash_entry(h)->tls_type;
	    }
	  else
	    {
	      local_got_refcounts[r_symndx] += 1;
	      old_tls_type = elf_s390_local_got_tls_type (abfd) [r_symndx];
	    }
	  /* If a TLS symbol is accessed using IE at least once,
	     there is no point to use dynamic model for it.  */
	  if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN)
	    {
	      if (old_tls_type == GOT_NORMAL || tls_type == GOT_NORMAL)
		{
		  (*_bfd_error_handler)
		    (_("%B: `%s' accessed both as normal and thread local symbol"),
		     abfd, h->root.root.string);
		  return FALSE;
		}
	      if (old_tls_type > tls_type)
		tls_type = old_tls_type;
	    }

	  if (old_tls_type != tls_type)
	    {
	      if (h != NULL)
		elf_s390_hash_entry (h)->tls_type = tls_type;
	      else
		elf_s390_local_got_tls_type (abfd) [r_symndx] = tls_type;
	    }

	  if (r_type != R_390_TLS_IE64)
	    break;
	  /* Fall through */

	case R_390_TLS_LE64:
	  if (!info->shared)
	    break;
	  info->flags |= DF_STATIC_TLS;
	  /* Fall through */

	case R_390_8:
	case R_390_16:
	case R_390_32:
	case R_390_64:
	case R_390_PC12DBL:
	case R_390_PC16:
	case R_390_PC16DBL:
	case R_390_PC24DBL:
	case R_390_PC32:
	case R_390_PC32DBL:
	case R_390_PC64:
	  if (h != NULL)
	    {
	      /* If this reloc is in a read-only section, we might
		 need a copy reloc.  We can't check reliably at this
		 stage whether the section is read-only, as input
		 sections have not yet been mapped to output sections.
		 Tentatively set the flag for now, and correct in
		 adjust_dynamic_symbol.  */
	      h->non_got_ref = 1;

	      if (!info->shared)
		{
		  /* We may need a .plt entry if the function this reloc
		     refers to is in a shared lib.  */
		  h->plt.refcount += 1;
		}
	    }

	  /* If we are creating a shared library, and this is a reloc
	     against a global symbol, or a non PC relative reloc
	     against a local symbol, then we need to copy the reloc
	     into the shared library.  However, if we are linking with
	     -Bsymbolic, we do not need to copy a reloc against a
	     global symbol which is defined in an object we are
	     including in the link (i.e., DEF_REGULAR is set).  At
	     this point we have not seen all the input files, so it is
	     possible that DEF_REGULAR is not set now but will be set
	     later (it is never cleared).  In case of a weak definition,
	     DEF_REGULAR may be cleared later by a strong definition in
	     a shared library. We account for that possibility below by
	     storing information in the relocs_copied field of the hash
	     table entry.  A similar situation occurs when creating
	     shared libraries and symbol visibility changes render the
	     symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (sec->flags & SEC_ALLOC) != 0
	       && ((ELF64_R_TYPE (rel->r_info) != R_390_PC16
		    && ELF64_R_TYPE (rel->r_info) != R_390_PC12DBL
		    && ELF64_R_TYPE (rel->r_info) != R_390_PC16DBL
		    && ELF64_R_TYPE (rel->r_info) != R_390_PC24DBL
		    && ELF64_R_TYPE (rel->r_info) != R_390_PC32
		    && ELF64_R_TYPE (rel->r_info) != R_390_PC32DBL
		    && ELF64_R_TYPE (rel->r_info) != R_390_PC64)
		   || (h != NULL
		       && (! SYMBOLIC_BIND (info, h)
			   || h->root.type == bfd_link_hash_defweak
			   || !h->def_regular))))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || !h->def_regular)))
	    {
	      struct elf_dyn_relocs *p;
	      struct elf_dyn_relocs **head;

	      /* We must copy these reloc types into the output file.
		 Create a reloc section in dynobj and make room for
		 this reloc.  */
	      if (sreloc == NULL)
		{
		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;

		  sreloc = _bfd_elf_make_dynamic_reloc_section
		    (sec, htab->elf.dynobj, 3, abfd, /*rela?*/ TRUE);

		  if (sreloc == NULL)
		    return FALSE;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		{
		  head = &((struct elf_s390_link_hash_entry *) h)->dyn_relocs;
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */
		  asection *s;
		  void *vpp;

		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
						abfd, r_symndx);
		  if (isym == NULL)
		    return FALSE;

		  s = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  if (s == NULL)
		    s = sec;

		  vpp = &elf_section_data (s)->local_dynrel;
		  head = (struct elf_dyn_relocs **) vpp;
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof *p;
		  p = ((struct elf_dyn_relocs *)
		       bfd_alloc (htab->elf.dynobj, amt));
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		}

	      p->count += 1;
	      if (ELF64_R_TYPE (rel->r_info) == R_390_PC16
		  || ELF64_R_TYPE (rel->r_info) == R_390_PC12DBL
		  || ELF64_R_TYPE (rel->r_info) == R_390_PC16DBL
		  || ELF64_R_TYPE (rel->r_info) == R_390_PC16DBL
		  || ELF64_R_TYPE (rel->r_info) == R_390_PC32
		  || ELF64_R_TYPE (rel->r_info) == R_390_PC32DBL
		  || ELF64_R_TYPE (rel->r_info) == R_390_PC64)
		p->pc_count += 1;
	    }
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_390_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_390_GNU_VTENTRY:
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
elf_s390_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info,
		       Elf_Internal_Rela *rel,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF64_R_TYPE (rel->r_info))
      {
      case R_390_GNU_VTINHERIT:
      case R_390_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf_s390_gc_sweep_hook (bfd *abfd,
			struct bfd_link_info *info,
			asection *sec,
			const Elf_Internal_Rela *relocs)
{
  struct elf_s390_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;

  if (info->relocatable)
    return TRUE;

  htab = elf_s390_hash_table (info);
  if (htab == NULL)
    return FALSE;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf_s390_link_hash_entry *eh;
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  eh = (struct elf_s390_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}
      else
	{
	  Elf_Internal_Sym *isym;

	  /* A local symbol.  */
	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					abfd, r_symndx);
	  if (isym == NULL)
	    return FALSE;

	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
	    {
	      struct plt_entry *plt = elf_s390_local_plt (abfd);
	      if (plt[r_symndx].plt.refcount > 0)
		plt[r_symndx].plt.refcount--;
	    }
	}

      r_type = ELF64_R_TYPE (rel->r_info);
      r_type = elf_s390_tls_transition (info, r_type, h != NULL);
      switch (r_type)
	{
	case R_390_TLS_LDM64:
	  if (htab->tls_ldm_got.refcount > 0)
	    htab->tls_ldm_got.refcount -= 1;
	  break;

	case R_390_TLS_GD64:
	case R_390_TLS_IE64:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE64:
	case R_390_TLS_IEENT:
	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOT64:
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	case R_390_GOTENT:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	case R_390_8:
	case R_390_12:
	case R_390_16:
	case R_390_20:
	case R_390_32:
	case R_390_64:
	case R_390_PC16:
	case R_390_PC12DBL:
	case R_390_PC16DBL:
	case R_390_PC24DBL:
	case R_390_PC32:
	case R_390_PC32DBL:
	case R_390_PC64:
	  if (info->shared)
	    break;
	  /* Fall through */

	case R_390_PLT12DBL:
	case R_390_PLT16DBL:
	case R_390_PLT24DBL:
	case R_390_PLT32:
	case R_390_PLT32DBL:
	case R_390_PLT64:
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	case R_390_PLTOFF64:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;

	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		{
		  ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount--;
		  h->plt.refcount -= 1;
		}
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Make sure we emit a GOT entry if the symbol was supposed to have a PLT
   entry but we found we will not create any.  Called when we find we will
   not have any PLT for this symbol, by for example
   elf_s390_adjust_dynamic_symbol when we're doing a proper dynamic link,
   or elf_s390_size_dynamic_sections if no dynamic sections will be
   created (we're only linking static objects).  */

static void
elf_s390_adjust_gotplt (struct elf_s390_link_hash_entry *h)
{
  if (h->elf.root.type == bfd_link_hash_warning)
    h = (struct elf_s390_link_hash_entry *) h->elf.root.u.i.link;

  if (h->gotplt_refcount <= 0)
    return;

  /* We simply add the number of gotplt references to the number
   * of got references for this symbol.  */
  h->elf.got.refcount += h->gotplt_refcount;
  h->gotplt_refcount = -1;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf_s390_adjust_dynamic_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *h)
{
  struct elf_s390_link_hash_table *htab;
  asection *s;

  /* STT_GNU_IFUNC symbol must go through PLT. */
  if (s390_is_ifunc_symbol_p (h))
    return TRUE;

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later
     (although we could actually do it here).  */
  if (h->type == STT_FUNC
      || h->needs_plt)
    {
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
	{
	  /* This case can occur if we saw a PLT32 reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PC32 reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
	}

      return TRUE;
    }
  else
    /* It's possible that we incorrectly decided a .plt reloc was
       needed for an R_390_PC32 reloc to a non-function sym in
       check_relocs.  We can't decide accurately between function and
       non-function syms in check-relocs;  Objects loaded later in
       the link may change h->type.  So fix it now.  */
    h->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->non_got_ref = h->u.weakdef->non_got_ref;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!h->non_got_ref)
    return TRUE;

  /* If -z nocopyreloc was given, we won't generate them either.  */
  if (info->nocopyreloc)
    {
      h->non_got_ref = 0;
      return TRUE;
    }

  if (ELIMINATE_COPY_RELOCS)
    {
      struct elf_s390_link_hash_entry * eh;
      struct elf_dyn_relocs *p;

      eh = (struct elf_s390_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->non_got_ref = 0;
	  return TRUE;
	}
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  htab = elf_s390_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* We must generate a R_390_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
    {
      htab->srelbss->size += sizeof (Elf64_External_Rela);
      h->needs_copy = 1;
    }

  s = htab->sdynbss;

  return _bfd_elf_adjust_dynamic_copy (h, s);
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h,
		    void * inf)
{
  struct bfd_link_info *info;
  struct elf_s390_link_hash_table *htab;
  struct elf_s390_link_hash_entry *eh = (struct elf_s390_link_hash_entry *)h;
  struct elf_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  info = (struct bfd_link_info *) inf;
  htab = elf_s390_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Since STT_GNU_IFUNC symbol must go through PLT, we handle it
     here if it is defined and referenced in a non-shared object.  */
  if (s390_is_ifunc_symbol_p (h) && h->def_regular)
    return s390_elf_allocate_ifunc_dyn_relocs (info, h,
					       &eh->dyn_relocs);
  else if (htab->elf.dynamic_sections_created
	   && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  asection *s = htab->elf.splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->size == 0)
	    s->size += PLT_FIRST_ENTRY_SIZE;

	  h->plt.offset = s->size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && !h->def_regular)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  htab->elf.sgotplt->size += GOT_ENTRY_SIZE;

	  /* We also need to make an entry in the .rela.plt section.  */
	  htab->elf.srelplt->size += sizeof (Elf64_External_Rela);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->needs_plt = 0;
      elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
    }

  /* If R_390_TLS_{IE64,GOTIE64,GOTIE12,IEENT} symbol is now local to
     the binary, we can optimize a bit. IE64 and GOTIE64 get converted
     to R_390_TLS_LE64 requiring no TLS entry. For GOTIE12 and IEENT
     we can save the dynamic TLS relocation.  */
  if (h->got.refcount > 0
      && !info->shared
      && h->dynindx == -1
      && elf_s390_hash_entry(h)->tls_type >= GOT_TLS_IE)
    {
      if (elf_s390_hash_entry(h)->tls_type == GOT_TLS_IE_NLT)
	/* For the GOTIE access without a literal pool entry the offset has
	   to be stored somewhere. The immediate value in the instruction
	   is not bit enough so the value is stored in the got.  */
	{
	  h->got.offset = htab->elf.sgot->size;
	  htab->elf.sgot->size += GOT_ENTRY_SIZE;
	}
      else
	h->got.offset = (bfd_vma) -1;
    }
  else if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;
      int tls_type = elf_s390_hash_entry(h)->tls_type;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = htab->elf.sgot;
      h->got.offset = s->size;
      s->size += GOT_ENTRY_SIZE;
      /* R_390_TLS_GD64 needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->size += GOT_ENTRY_SIZE;
      dyn = htab->elf.dynamic_sections_created;
      /* R_390_TLS_IE64 needs one dynamic relocation,
	 R_390_TLS_GD64 needs one if local symbol and two if global.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type >= GOT_TLS_IE)
	htab->elf.srelgot->size += sizeof (Elf64_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->elf.srelgot->size += 2 * sizeof (Elf64_External_Rela);
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	htab->elf.srelgot->size += sizeof (Elf64_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;

  if (eh->dyn_relocs == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (eh->dyn_relocs != NULL
	  && h->root.type == bfd_link_hash_undefweak)
	{
	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	    eh->dyn_relocs = NULL;

	  /* Make sure undefined weak symbols are output as a dynamic
	     symbol in PIEs.  */
	  else if (h->dynindx == -1
		   && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
	}
    }
  else if (ELIMINATE_COPY_RELOCS)
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
	      || (htab->elf.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->size += p->count * sizeof (Elf64_External_Rela);
    }

  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void * inf)
{
  struct elf_s390_link_hash_entry *eh;
  struct elf_dyn_relocs *p;

  eh = (struct elf_s390_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf_s390_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				struct bfd_link_info *info)
{
  struct elf_s390_link_hash_table *htab;
  bfd *dynobj;
  asection *s;
  bfd_boolean relocs;
  bfd *ibfd;

  htab = elf_s390_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = htab->elf.dynobj;
  if (dynobj == NULL)
    abort ();

  if (htab->elf.dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  if (s == NULL)
	    abort ();
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *local_tls_type;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srela;
      struct plt_entry *local_plt;
      unsigned int i;

      if (! is_s390_elf (ibfd))
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf_dyn_relocs *p;

	  for (p = elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
	    {
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srela = elf_section_data (p->sec)->sreloc;
		  srela->size += p->count * sizeof (Elf64_External_Rela);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_symtab_hdr (ibfd);
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      local_tls_type = elf_s390_local_got_tls_type (ibfd);
      s = htab->elf.sgot;
      srela = htab->elf.srelgot;
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
	{
	  if (*local_got > 0)
	    {
	      *local_got = s->size;
	      s->size += GOT_ENTRY_SIZE;
	      if (*local_tls_type == GOT_TLS_GD)
		s->size += GOT_ENTRY_SIZE;
	      if (info->shared)
		srela->size += sizeof (Elf64_External_Rela);
	    }
	  else
	    *local_got = (bfd_vma) -1;
	}

      local_plt = elf_s390_local_plt (ibfd);
      for (i = 0; i < symtab_hdr->sh_info; i++)
	{
	  if (local_plt[i].plt.refcount > 0)
	    {
	      local_plt[i].plt.offset = htab->elf.iplt->size;
	      htab->elf.iplt->size += PLT_ENTRY_SIZE;
	      htab->elf.igotplt->size += GOT_ENTRY_SIZE;
	      htab->elf.irelplt->size += sizeof (Elf64_External_Rela);
	    }
	  else
	    local_plt[i].plt.offset = (bfd_vma) -1;
	}
    }

  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_390_TLS_LDM64
	 relocs.  */
      htab->tls_ldm_got.offset = htab->elf.sgot->size;
      htab->elf.sgot->size += 2 * GOT_ENTRY_SIZE;
      htab->elf.srelgot->size += sizeof (Elf64_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);

  /* We now have determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (s == htab->elf.splt
	  || s == htab->elf.sgot
	  || s == htab->elf.sgotplt
	  || s == htab->sdynbss
	  || s == htab->elf.iplt
	  || s == htab->elf.igotplt
	  || s == htab->irelifunc)
	{
	  /* Strip this section if we don't need it; see the
	     comment below.  */
	}
      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rela"))
	{
	  if (s->size != 0 && s != htab->elf.srelplt)
	    relocs = TRUE;

	  /* We use the reloc_count field as a counter if we need
	     to copy relocs into the output file.  */
	  s->reloc_count = 0;
	}
      else
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is to handle .rela.bss and
	     .rela.plt.  We must create it in
	     create_dynamic_sections, because it must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */

	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  We use bfd_zalloc
	 here in case unused entries are not reclaimed before the
	 section's contents are written out.  This should not happen,
	 but this way if it does, we get a R_390_NONE reloc instead
	 of garbage.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }

  if (htab->elf.dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_s390_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (htab->elf.splt->size != 0)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
	    return FALSE;

	  /* If any dynamic relocs apply to a read-only section,
	     then we need a DT_TEXTREL entry.  */
	  if ((info->flags & DF_TEXTREL) == 0)
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs,
				    info);

	  if ((info->flags & DF_TEXTREL) != 0)
	    {
	      if (!add_dynamic_entry (DT_TEXTREL, 0))
		return FALSE;
	    }
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (struct bfd_link_info *info, bfd_vma address)
{
  struct elf_link_hash_table *htab = elf_hash_table (info);

  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
    return 0;
  return htab->tls_size + htab->tls_sec->vma - address;
}

/* Complain if TLS instruction relocation is against an invalid
   instruction.  */

static void
invalid_tls_insn (bfd *input_bfd,
		  asection *input_section,
		  Elf_Internal_Rela *rel)
{
  reloc_howto_type *howto;

  howto = elf_howto_table + ELF64_R_TYPE (rel->r_info);
  (*_bfd_error_handler)
    (_("%B(%A+0x%lx): invalid instruction for TLS relocation %s"),
     input_bfd,
     input_section,
     (long) rel->r_offset,
     howto->name);
  bfd_set_error (bfd_error_bad_value);
}

/* Relocate a 390 ELF section.  */

static bfd_boolean
elf_s390_relocate_section (bfd *output_bfd,
			   struct bfd_link_info *info,
			   bfd *input_bfd,
			   asection *input_section,
			   bfd_byte *contents,
			   Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
{
  struct elf_s390_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  BFD_ASSERT (is_s390_elf (input_bfd));

  htab = elf_s390_hash_table (info);
  if (htab == NULL)
    return FALSE;

  symtab_hdr = &elf_symtab_hdr (input_bfd);
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      unsigned int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sec;
      bfd_vma off;
      bfd_vma relocation;
      bfd_boolean unresolved_reloc;
      bfd_reloc_status_type r;
      int tls_type;
      asection *base_got = htab->elf.sgot;

      r_type = ELF64_R_TYPE (rel->r_info);
      if (r_type == (int) R_390_GNU_VTINHERIT
	  || r_type == (int) R_390_GNU_VTENTRY)
	continue;
      if (r_type >= (int) R_390_max)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      howto = elf_howto_table + r_type;
      r_symndx = ELF64_R_SYM (rel->r_info);

      h = NULL;
      sym = NULL;
      sec = NULL;
      unresolved_reloc = FALSE;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];

	  if (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
	    {
	      struct plt_entry *local_plt = elf_s390_local_plt (input_bfd);
	      if (local_plt == NULL)
		return FALSE;

	      /* Address of the PLT slot.  */
	      relocation = (htab->elf.iplt->output_section->vma
			    + htab->elf.iplt->output_offset
			    + local_plt[r_symndx].plt.offset);

	      switch (r_type)
		{
		case R_390_PLTOFF16:
		case R_390_PLTOFF32:
		case R_390_PLTOFF64:
		  relocation -= htab->elf.sgot->output_section->vma;
		  break;
		case R_390_GOTPLT12:
		case R_390_GOTPLT16:
		case R_390_GOTPLT20:
		case R_390_GOTPLT32:
		case R_390_GOTPLT64:
		case R_390_GOTPLTENT:
		case R_390_GOT12:
		case R_390_GOT16:
		case R_390_GOT20:
		case R_390_GOT32:
		case R_390_GOT64:
		case R_390_GOTENT:
		  {
		    /* Write the PLT slot address into the GOT slot.  */
		    bfd_put_64 (output_bfd, relocation,
				htab->elf.sgot->contents +
				local_got_offsets[r_symndx]);
		    relocation = (local_got_offsets[r_symndx] +
				  htab->elf.sgot->output_offset);

		    if (r_type == R_390_GOTENT || r_type == R_390_GOTPLTENT)
		      relocation += htab->elf.sgot->output_section->vma;
		    break;
		  }
		default:
		  break;
		}
	      /* The output section is needed later in
		 finish_dynamic_section when creating the dynamic
		 relocation.  */
	      local_plt[r_symndx].sec = sec;
	      goto do_relocation;
	    }
	  else
	    relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean warned ATTRIBUTE_UNUSED;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      switch (r_type)
	{
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	  /* There are three cases for a GOTPLT relocation. 1) The
	     relocation is against the jump slot entry of a plt that
	     will get emitted to the output file. 2) The relocation
	     is against the jump slot of a plt entry that has been
	     removed. elf_s390_adjust_gotplt has created a GOT entry
	     as replacement. 3) The relocation is against a local symbol.
	     Cases 2) and 3) are the same as the GOT relocation code
	     so we just have to test for case 1 and fall through for
	     the other two.  */
	  if (h != NULL && h->plt.offset != (bfd_vma) -1)
	    {
	      bfd_vma plt_index;

	      if (s390_is_ifunc_symbol_p (h))
		{
		  plt_index = h->plt.offset / PLT_ENTRY_SIZE;
		  relocation = (plt_index * GOT_ENTRY_SIZE +
				htab->elf.igotplt->output_offset);
		  if (r_type == R_390_GOTPLTENT)
		    relocation += htab->elf.igotplt->output_section->vma;
		}
	      else
		{
		  /* Calc. index no.
		     Current offset - size first entry / entry size.  */
		  plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) /
		    PLT_ENTRY_SIZE;

		  /* Offset in GOT is PLT index plus GOT headers(3)
		     times 4, addr & GOT addr.  */
		  relocation = (plt_index + 3) * GOT_ENTRY_SIZE;
		  if (r_type == R_390_GOTPLTENT)
		    relocation += htab->elf.sgot->output_section->vma;
		}
	      unresolved_reloc = FALSE;
	      break;
	    }
	  /* Fall through.  */

	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOT64:
	case R_390_GOTENT:
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
	  if (base_got == NULL)
	    abort ();

	  if (h != NULL)
	    {
	      bfd_boolean dyn;

	      off = h->got.offset;
	      dyn = htab->elf.dynamic_sections_created;

	      if (s390_is_ifunc_symbol_p (h))
		{
		  BFD_ASSERT (h->plt.offset != (bfd_vma) -1);
		  if (off == (bfd_vma)-1)
		    {
		      /* No explicit GOT usage so redirect to the
			 got.iplt slot.  */
		      base_got = htab->elf.igotplt;
		      off = h->plt.offset / PLT_ENTRY_SIZE * GOT_ENTRY_SIZE;
		    }
		  else
		    {
		      /* Explicit GOT slots must contain the address
			 of the PLT slot. This will be handled in
			 finish_dynamic_symbol.  */
		    }
		}
	      else if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		       || (info->shared
			   && SYMBOL_REFERENCES_LOCAL (info, h))
		       || (ELF_ST_VISIBILITY (h->other)
			   && h->root.type == bfd_link_hash_undefweak))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 2, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rel.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_64 (output_bfd, relocation,
				  base_got->contents + off);
		      h->got.offset |= 1;
		    }

		  if ((h->def_regular
		       && info->shared
		       && SYMBOL_REFERENCES_LOCAL (info, h))
		      /* lgrl rx,sym@@GOTENT -> larl rx, sym */
		      && ((r_type == R_390_GOTENT
			   && (bfd_get_16 (input_bfd,
					   contents + rel->r_offset - 2)
			       & 0xff0f) == 0xc408)
			  /* lg rx, sym@@GOT(r12) -> larl rx, sym */
			  || (r_type == R_390_GOT20
			      && (bfd_get_32 (input_bfd,
					      contents + rel->r_offset - 2)
				  & 0xff00f000) == 0xe300c000
			      && bfd_get_8 (input_bfd,
					    contents + rel->r_offset + 3) == 0x04)))

		    {
		      unsigned short new_insn =
			(0xc000 | (bfd_get_8 (input_bfd,
					      contents + rel->r_offset - 1) & 0xf0));
		      bfd_put_16 (output_bfd, new_insn,
				  contents + rel->r_offset - 2);
		      r_type = R_390_PC32DBL;
		      rel->r_addend = 2;
		      howto = elf_howto_table + r_type;
		      relocation = h->root.u.def.value
			+ h->root.u.def.section->output_section->vma
			+ h->root.u.def.section->output_offset;
		      goto do_relocation;
		    }
		}
	      else
		unresolved_reloc = FALSE;
	    }
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];

	      /* The offset must always be a multiple of 8.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_64 (output_bfd, relocation,
			      htab->elf.sgot->contents + off);

		  if (info->shared)
		    {
		      asection *s;
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;

		      s = htab->elf.srelgot;
		      if (s == NULL)
			abort ();

		      outrel.r_offset = (htab->elf.sgot->output_section->vma
					 + htab->elf.sgot->output_offset
					 + off);
		      outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
		      outrel.r_addend = relocation;
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		    }

		  local_got_offsets[r_symndx] |= 1;
		}
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();

	  relocation = base_got->output_offset + off;

	  /* For @@GOTENT the relocation is against the offset between
	     the instruction and the symbols entry in the GOT and not
	     between the start of the GOT and the symbols entry. We
	     add the vma of the GOT to get the correct value.  */
	  if (   r_type == R_390_GOTENT
	      || r_type == R_390_GOTPLTENT)
	    relocation += base_got->output_section->vma;

	  break;

	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
	  /* Relocation is relative to the start of the global offset
	     table.  */

	  /* Note that sgot->output_offset is not involved in this
	     calculation.  We always want the start of .got.  If we
	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
	     permitted by the ABI, we might have to change this
	     calculation.  */
	  relocation -= htab->elf.sgot->output_section->vma;
	  break;

	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	  /* Use global offset table as symbol value.  */
	  relocation = htab->elf.sgot->output_section->vma;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_PLT12DBL:
	case R_390_PLT16DBL:
	case R_390_PLT24DBL:
	case R_390_PLT32:
	case R_390_PLT32DBL:
	case R_390_PLT64:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLT32 reloc against a local symbol directly,
	     without using the procedure linkage table.  */
	  if (h == NULL)
	    break;

	  if (h->plt.offset == (bfd_vma) -1
	      || (htab->elf.splt == NULL && !s390_is_ifunc_symbol_p (h)))
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
	    }
	  if (s390_is_ifunc_symbol_p (h))
	    relocation = (htab->elf.iplt->output_section->vma
			  + htab->elf.iplt->output_offset
			  + h->plt.offset);
	  else
	    relocation = (htab->elf.splt->output_section->vma
			  + htab->elf.splt->output_offset
			  + h->plt.offset);
	  unresolved_reloc = FALSE;
	  break;

	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	case R_390_PLTOFF64:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table relative to the start of the GOT.  */

	  /* For local symbols or if we didn't make a PLT entry for
	     this symbol resolve the symbol directly.  */
	  if (h == NULL
	      || h->plt.offset == (bfd_vma) -1
	      || (htab->elf.splt == NULL && !s390_is_ifunc_symbol_p (h)))
	    {
	      relocation -= htab->elf.sgot->output_section->vma;
	      break;
	    }

	  if (s390_is_ifunc_symbol_p (h))
	    relocation = (htab->elf.iplt->output_section->vma
			  + htab->elf.iplt->output_offset
			  + h->plt.offset
			  - htab->elf.sgot->output_section->vma);
	  else
	    relocation = (htab->elf.splt->output_section->vma
			  + htab->elf.splt->output_offset
			  + h->plt.offset
			  - htab->elf.sgot->output_section->vma);
	  unresolved_reloc = FALSE;
	  break;

	case R_390_8:
	case R_390_16:
	case R_390_32:
	case R_390_64:
	case R_390_PC16:
	case R_390_PC12DBL:
	case R_390_PC16DBL:
	case R_390_PC24DBL:
	case R_390_PC32:
	case R_390_PC32DBL:
	case R_390_PC64:

	  if (h != NULL
	      && s390_is_ifunc_symbol_p (h)
	      && h->def_regular)
	    {
	      if (!info->shared || !h->non_got_ref)
		{
		  /* For a non-shared object STT_GNU_IFUNC symbol must
		     go through PLT.  */
		  relocation = (htab->elf.iplt->output_section->vma
				+ htab->elf.iplt->output_offset
				+ h ->plt.offset);
		  goto do_relocation;
		}
	      else
		{
		  /* For shared objects a runtime relocation is needed.  */

		  Elf_Internal_Rela outrel;
		  asection *sreloc;

		  /* Need a dynamic relocation to get the real function
		     address.  */
		  outrel.r_offset = _bfd_elf_section_offset (output_bfd,
							     info,
							     input_section,
							     rel->r_offset);
		  if (outrel.r_offset == (bfd_vma) -1
		      || outrel.r_offset == (bfd_vma) -2)
		    abort ();

		  outrel.r_offset += (input_section->output_section->vma
				      + input_section->output_offset);

		  if (h->dynindx == -1
		      || h->forced_local
		      || info->executable)
		    {
		      /* This symbol is resolved locally.  */
		      outrel.r_info = ELF64_R_INFO (0, R_390_IRELATIVE);
		      outrel.r_addend = (h->root.u.def.value
					 + h->root.u.def.section->output_section->vma
					 + h->root.u.def.section->output_offset);
		    }
		  else
		    {
		      outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
		      outrel.r_addend = 0;
		    }

		  sreloc = htab->elf.irelifunc;
		  elf_append_rela (output_bfd, sreloc, &outrel);

		  /* If this reloc is against an external symbol, we
		     do not want to fiddle with the addend.  Otherwise,
		     we need to include the symbol value so that it
		     becomes an addend for the dynamic reloc.  For an
		     internal symbol, we have updated addend.  */
		  continue;
		}
	    }

	  if ((input_section->flags & SEC_ALLOC) == 0)
	    break;

	  if ((info->shared
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
	       && ((r_type != R_390_PC16
		    && r_type != R_390_PC12DBL
		    && r_type != R_390_PC16DBL
		    && r_type != R_390_PC24DBL
		    && r_type != R_390_PC32
		    && r_type != R_390_PC32DBL
		    && r_type != R_390_PC64)
		   || !SYMBOL_CALLS_LOCAL (info, h)))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && h != NULL
		  && h->dynindx != -1
		  && !h->non_got_ref
		  && ((h->def_dynamic
		       && !h->def_regular)
		      || h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined)))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip, relocate;
	      asection *sreloc;
	      bfd_byte *loc;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */
	      skip = FALSE;
	      relocate = FALSE;

	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1)
		skip = TRUE;
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = TRUE, relocate = TRUE;

	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);

	      if (skip)
		memset (&outrel, 0, sizeof outrel);
	      else if (h != NULL
		       && h->dynindx != -1
		       && (r_type == R_390_PC16
			   || r_type == R_390_PC12DBL
			   || r_type == R_390_PC16DBL
			   || r_type == R_390_PC24DBL
			   || r_type == R_390_PC32
			   || r_type == R_390_PC32DBL
			   || r_type == R_390_PC64
			   || !info->shared
			   || !SYMBOLIC_BIND (info, h)
			   || !h->def_regular))
		{
		  outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
		  outrel.r_addend = rel->r_addend;
		}
	      else
		{
		  /* This symbol is local, or marked to become local.  */
		  outrel.r_addend = relocation + rel->r_addend;
		  if (r_type == R_390_64)
		    {
		      relocate = TRUE;
		      outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
		    }
		  else
		    {
		      long sindx;

		      if (bfd_is_abs_section (sec))
			sindx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error(bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  sindx = elf_section_data (osec)->dynindx;

			  if (sindx == 0)
			    {
			      osec = htab->elf.text_index_section;
			      sindx = elf_section_data (osec)->dynindx;
			    }
			  BFD_ASSERT (sindx != 0);

			  /* We are turning this relocation into one
			     against a section symbol, so subtract out
			     the output section's address but not the
			     offset of the input section in the output
			     section.  */
			  outrel.r_addend -= osec->vma;
			}
		      outrel.r_info = ELF64_R_INFO (sindx, r_type);
		    }
		}

	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	      /* If this reloc is against an external symbol, we do
		 not want to fiddle with the addend.  Otherwise, we
		 need to include the symbol value so that it becomes
		 an addend for the dynamic reloc.  */
	      if (! relocate)
		continue;
	    }

	  break;

	  /* Relocations for tls literal pool entries.  */
	case R_390_TLS_IE64:
	  if (info->shared)
	    {
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloc_out (output_bfd, &outrel, loc);
	    }
	  /* Fall through.  */

	case R_390_TLS_GD64:
	case R_390_TLS_GOTIE64:
	  r_type = elf_s390_tls_transition (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (!info->shared && h->dynindx == -1 && tls_type >= GOT_TLS_IE)
		r_type = R_390_TLS_LE64;
	    }
	  if (r_type == R_390_TLS_GD64 && tls_type >= GOT_TLS_IE)
	    r_type = R_390_TLS_IE64;

	  if (r_type == R_390_TLS_LE64)
	    {
	      /* This relocation gets optimized away by the local exec
		 access optimization.  */
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_64 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	      continue;
	    }

	  if (htab->elf.sgot == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	emit_tls_relocs:

	  if ((off & 1) != 0)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      int dr_type, indx;

	      if (htab->elf.srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->elf.sgot->output_section->vma
				 + htab->elf.sgot->output_offset + off);

	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
	      if (r_type == R_390_TLS_GD64)
		dr_type = R_390_TLS_DTPMOD;
	      else
		dr_type = R_390_TLS_TPOFF;
	      if (dr_type == R_390_TLS_TPOFF && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      outrel.r_info = ELF64_R_INFO (indx, dr_type);
	      loc = htab->elf.srelgot->contents;
	      loc += htab->elf.srelgot->reloc_count++
		* sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	      if (r_type == R_390_TLS_GD64)
		{
		  if (indx == 0)
		    {
	    	      BFD_ASSERT (! unresolved_reloc);
		      bfd_put_64 (output_bfd,
				  relocation - dtpoff_base (info),
				  htab->elf.sgot->contents + off + GOT_ENTRY_SIZE);
		    }
		  else
		    {
		      outrel.r_info = ELF64_R_INFO (indx, R_390_TLS_DTPOFF);
		      outrel.r_offset += GOT_ENTRY_SIZE;
		      outrel.r_addend = 0;
		      htab->elf.srelgot->reloc_count++;
		      loc += sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		    }
		}

	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();
	  if (r_type == ELF64_R_TYPE (rel->r_info))
	    {
	      relocation = htab->elf.sgot->output_offset + off;
	      if (r_type == R_390_TLS_IE64 || r_type == R_390_TLS_IEENT)
		relocation += htab->elf.sgot->output_section->vma;
	      unresolved_reloc = FALSE;
	    }
	  else
	    {
	      bfd_put_64 (output_bfd, htab->elf.sgot->output_offset + off,
			  contents + rel->r_offset);
	      continue;
	    }
	  break;

	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_IEENT:
	  if (h == NULL)
	    {
	      if (local_got_offsets == NULL)
		abort();
	      off = local_got_offsets[r_symndx];
	      if (info->shared)
		goto emit_tls_relocs;
	    }
	  else
	    {
	      off = h->got.offset;
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (info->shared || h->dynindx != -1 || tls_type < GOT_TLS_IE)
		goto emit_tls_relocs;
	    }

	  if (htab->elf.sgot == NULL)
	    abort ();

	  BFD_ASSERT (! unresolved_reloc);
	  bfd_put_64 (output_bfd, -tpoff (info, relocation),
		      htab->elf.sgot->contents + off);
	  relocation = htab->elf.sgot->output_offset + off;
	  if (r_type == R_390_TLS_IEENT)
	    relocation += htab->elf.sgot->output_section->vma;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_TLS_LDM64:
	  if (! info->shared)
	    /* The literal pool entry this relocation refers to gets ignored
	       by the optimized code of the local exec model. Do nothing
	       and the value will turn out zero.  */
	    continue;

	  if (htab->elf.sgot == NULL)
	    abort ();

	  off = htab->tls_ldm_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;

	      if (htab->elf.srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->elf.sgot->output_section->vma
				 + htab->elf.sgot->output_offset + off);

	      bfd_put_64 (output_bfd, 0,
			  htab->elf.sgot->contents + off + GOT_ENTRY_SIZE);
	      outrel.r_info = ELF64_R_INFO (0, R_390_TLS_DTPMOD);
	      outrel.r_addend = 0;
	      loc = htab->elf.srelgot->contents;
	      loc += htab->elf.srelgot->reloc_count++
		* sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ldm_got.offset |= 1;
	    }
	  relocation = htab->elf.sgot->output_offset + off;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_TLS_LE64:
	  if (info->shared)
	    {
	      /* Linking a shared library with non-fpic code requires
		 a R_390_TLS_TPOFF relocation.  */
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;
	      int indx;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      if (h != NULL && h->dynindx != -1)
		indx = h->dynindx;
	      else
		indx = 0;
	      outrel.r_info = ELF64_R_INFO (indx, R_390_TLS_TPOFF);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
	    }
	  else
	    {
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_64 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	    }
	  continue;

	case R_390_TLS_LDO64:
	  if (info->shared || (input_section->flags & SEC_DEBUGGING))
	    relocation -= dtpoff_base (info);
	  else
	    /* When converting LDO to LE, we must negate.  */
	    relocation = -tpoff (info, relocation);
	  break;

	  /* Relocations for tls instructions.  */
	case R_390_TLS_LOAD:
	case R_390_TLS_GDCALL:
	case R_390_TLS_LDCALL:
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    tls_type = elf_s390_hash_entry(h)->tls_type;

	  if (tls_type == GOT_TLS_GD)
	    continue;

	  if (r_type == R_390_TLS_LOAD)
	    {
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		{
		  /* IE->LE transition. Four valid cases:
		     lg %rx,(0,%ry)    -> sllg %rx,%ry,0
		     lg %rx,(%ry,0)    -> sllg %rx,%ry,0
		     lg %rx,(%ry,%r12) -> sllg %rx,%ry,0
		     lg %rx,(%r12,%ry) -> sllg %rx,%ry,0  */
		  unsigned int insn0, insn1, ry;

		  insn0 = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  insn1 = bfd_get_16 (input_bfd, contents + rel->r_offset + 4);
		  if (insn1 != 0x0004)
		    invalid_tls_insn (input_bfd, input_section, rel);
		  ry = 0;
		  if ((insn0 & 0xff00f000) == 0xe3000000)
		    /* lg %rx,0(%ry,0) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x000f0000);
		  else if ((insn0 & 0xff0f0000) == 0xe3000000)
		    /* lg %rx,0(0,%ry) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x0000f000) << 4;
		  else if ((insn0 & 0xff00f000) == 0xe300c000)
		    /* lg %rx,0(%ry,%r12) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x000f0000);
		  else if ((insn0 & 0xff0f0000) == 0xe30c0000)
		    /* lg %rx,0(%r12,%ry) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x0000f000) << 4;
		  else
		    invalid_tls_insn (input_bfd, input_section, rel);
		  insn0 = 0xeb000000 | (insn0 & 0x00f00000) | ry;
		  insn1 = 0x000d;
		  bfd_put_32 (output_bfd, insn0, contents + rel->r_offset);
		  bfd_put_16 (output_bfd, insn1, contents + rel->r_offset + 4);
		}
	    }
	  else if (r_type == R_390_TLS_GDCALL)
	    {
	      unsigned int insn0, insn1;

	      insn0 = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      insn1 = bfd_get_16 (input_bfd, contents + rel->r_offset + 4);
	      if ((insn0 & 0xffff0000) != 0xc0e50000)
		invalid_tls_insn (input_bfd, input_section, rel);
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		{
		  /* GD->LE transition.
		     brasl %r14,__tls_get_addr@@plt -> brcl 0,. */
		  insn0 = 0xc0040000;
		  insn1 = 0x0000;
		}
	      else
		{
		  /* GD->IE transition.
		     brasl %r14,__tls_get_addr@@plt -> lg %r2,0(%r2,%r12)  */
		  insn0 = 0xe322c000;
		  insn1 = 0x0004;
		}
	      bfd_put_32 (output_bfd, insn0, contents + rel->r_offset);
	      bfd_put_16 (output_bfd, insn1, contents + rel->r_offset + 4);
	    }
	  else if (r_type == R_390_TLS_LDCALL)
	    {
	      if (!info->shared)
		{
		  unsigned int insn0, insn1;

		  insn0 = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  insn1 = bfd_get_16 (input_bfd, contents + rel->r_offset + 4);
		  if ((insn0 & 0xffff0000) != 0xc0e50000)
		    invalid_tls_insn (input_bfd, input_section, rel);
		  /* LD->LE transition.
		     brasl %r14,__tls_get_addr@@plt -> brcl 0,. */
		  insn0 = 0xc0040000;
		  insn1 = 0x0000;
		  bfd_put_32 (output_bfd, insn0, contents + rel->r_offset);
		  bfd_put_16 (output_bfd, insn1, contents + rel->r_offset + 4);
		}
	    }
	  continue;

	default:
	  break;
	}

      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && h->def_dynamic)
	  && _bfd_elf_section_offset (output_bfd, info, input_section,
				      rel->r_offset) != (bfd_vma) -1)
	(*_bfd_error_handler)
	  (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	   input_bfd,
	   input_section,
	   (long) rel->r_offset,
	   howto->name,
	   h->root.root.string);

    do_relocation:

      /* When applying a 24 bit reloc we need to start one byte
	 earlier.  Otherwise the 32 bit get/put bfd operations might
	 access a byte after the actual section.  */
      if (r_type == R_390_PC24DBL
	  || r_type == R_390_PLT24DBL)
	rel->r_offset--;

      if (r_type == R_390_20
	  || r_type == R_390_GOT20
	  || r_type == R_390_GOTPLT20
	  || r_type == R_390_TLS_GOTIE20)
	{
	  relocation += rel->r_addend;
	  relocation = (relocation&0xfff) << 8 | (relocation&0xff000) >> 12;
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset,
					relocation, 0);
	}
      else
	r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				      contents, rel->r_offset,
				      relocation, rel->r_addend);

      if (r != bfd_reloc_ok)
	{
	  const char *name;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    {
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return FALSE;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  if (r == bfd_reloc_overflow)
	    {

	      if (! ((*info->callbacks->reloc_overflow)
		     (info, (h ? &h->root : NULL), name, howto->name,
		      (bfd_vma) 0, input_bfd, input_section,
		      rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
		 (long) rel->r_offset, name, (int) r);
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Generate the PLT slots together with the dynamic relocations needed
   for IFUNC symbols.  */

static void
elf_s390_finish_ifunc_symbol (bfd *output_bfd,
			      struct bfd_link_info *info,
			      struct elf_link_hash_entry *h,
			      struct elf_s390_link_hash_table *htab,
			      bfd_vma plt_offset,
			      bfd_vma resolver_address)
{
  bfd_vma plt_index;
  bfd_vma got_offset;
  Elf_Internal_Rela rela;
  bfd_byte *loc;
  asection *plt, *gotplt, *relplt;

  if (htab->elf.iplt == NULL
      || htab->elf.igotplt == NULL
      || htab->elf.irelplt == NULL)
    abort ();

  /* Index of the PLT slot within iplt section.  */
  plt_index = plt_offset / PLT_ENTRY_SIZE;
  plt = htab->elf.iplt;
  /* Offset into the igot.plt section.  */
  got_offset = plt_index * GOT_ENTRY_SIZE;
  gotplt = htab->elf.igotplt;
  relplt = htab->elf.irelplt;

  /* Fill in the blueprint of a PLT.  */
  memcpy (plt->contents + plt_offset, elf_s390x_plt_entry,
	  PLT_ENTRY_SIZE);

  /* Fixup the relative address to the GOT entry */
  bfd_put_32 (output_bfd,
	      (gotplt->output_section->vma +
	       gotplt->output_offset + got_offset
	       - (plt->output_section->vma +
		  plt->output_offset +
		  plt_offset))/2,
	      plt->contents + plt_offset + 2);
  /* Fixup the relative branch to PLT 0 */
  bfd_put_32 (output_bfd, - (plt->output_offset +
			     (PLT_ENTRY_SIZE * plt_index) + 22)/2,
	      plt->contents + plt_offset + 24);
  /* Fixup offset into .rela.plt section.  */
  bfd_put_32 (output_bfd, relplt->output_offset +
	      plt_index * sizeof (Elf64_External_Rela),
	      plt->contents + plt_offset + 28);

  /* Fill in the entry in the global offset table.
     Points to instruction after GOT offset.  */
  bfd_put_64 (output_bfd,
	      (plt->output_section->vma
	       + plt->output_offset
	       + plt_offset
	       + 14),
	      gotplt->contents + got_offset);

  /* Fill in the entry in the .rela.plt section.  */
  rela.r_offset = (gotplt->output_section->vma
		   + gotplt->output_offset
		   + got_offset);

  if (!h
      || h->dynindx == -1
      || ((info->executable
	   || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	  && h->def_regular))
    {
      /* The symbol can be locally resolved.  */
      rela.r_info = ELF64_R_INFO (0, R_390_IRELATIVE);
      rela.r_addend = resolver_address;
    }
  else
    {
      rela.r_info = ELF64_R_INFO (h->dynindx, R_390_JMP_SLOT);
      rela.r_addend = 0;
    }

  loc = relplt->contents + plt_index * sizeof (Elf64_External_Rela);
  bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
}


/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf_s390_finish_dynamic_symbol (bfd *output_bfd,
				struct bfd_link_info *info,
				struct elf_link_hash_entry *h,
				Elf_Internal_Sym *sym)
{
  struct elf_s390_link_hash_table *htab;
  struct elf_s390_link_hash_entry *eh = (struct elf_s390_link_hash_entry*)h;

  htab = elf_s390_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (h->plt.offset != (bfd_vma) -1)
    {
      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */
      if (s390_is_ifunc_symbol_p (h))
	{
	  /* If we can resolve the IFUNC symbol locally we generate an
	     IRELATIVE reloc.  */
	  elf_s390_finish_ifunc_symbol (output_bfd, info, h, htab, h->plt.offset,
					eh->ifunc_resolver_address +
					eh->ifunc_resolver_section->output_offset +
					eh->ifunc_resolver_section->output_section->vma);
				 ;
	  /* Fallthrough.  Handling of explicit GOT slots of IFUNC
	     symbols is below.  */
	}
      else
	{
	  if (h->dynindx == -1
	      || htab->elf.splt == NULL
	      || htab->elf.sgotplt == NULL
	      || htab->elf.srelplt == NULL)
	    abort ();

	  /* Calc. index no.
	     Current offset - size first entry / entry size.  */
	  plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) / PLT_ENTRY_SIZE;

	  /* Offset in GOT is PLT index plus GOT headers(3) times 8,
	     addr & GOT addr.  */
	  got_offset = (plt_index + 3) * GOT_ENTRY_SIZE;

	  /* Fill in the blueprint of a PLT.  */
	  memcpy (htab->elf.splt->contents + h->plt.offset, elf_s390x_plt_entry,
		  PLT_ENTRY_SIZE);

	  /* Fixup the relative address to the GOT entry */
	  bfd_put_32 (output_bfd,
		      (htab->elf.sgotplt->output_section->vma +
		       htab->elf.sgotplt->output_offset + got_offset
		       - (htab->elf.splt->output_section->vma +
			  htab->elf.splt->output_offset +
			  h->plt.offset))/2,
		      htab->elf.splt->contents + h->plt.offset + 2);
	  /* Fixup the relative branch to PLT 0 */
	  bfd_put_32 (output_bfd, - (PLT_FIRST_ENTRY_SIZE +
				     (PLT_ENTRY_SIZE * plt_index) + 22)/2,
		      htab->elf.splt->contents + h->plt.offset + 24);
	  /* Fixup offset into .rela.plt section.  */
	  bfd_put_32 (output_bfd, plt_index * sizeof (Elf64_External_Rela),
		      htab->elf.splt->contents + h->plt.offset + 28);

	  /* Fill in the entry in the global offset table.
	     Points to instruction after GOT offset.  */
	  bfd_put_64 (output_bfd,
		      (htab->elf.splt->output_section->vma
		       + htab->elf.splt->output_offset
		       + h->plt.offset
		       + 14),
		      htab->elf.sgotplt->contents + got_offset);

	  /* Fill in the entry in the .rela.plt section.  */
	  rela.r_offset = (htab->elf.sgotplt->output_section->vma
			   + htab->elf.sgotplt->output_offset
			   + got_offset);
	  rela.r_info = ELF64_R_INFO (h->dynindx, R_390_JMP_SLOT);
	  rela.r_addend = 0;
	  loc = htab->elf.srelplt->contents + plt_index *
	    sizeof (Elf64_External_Rela);
	  bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);

	  if (!h->def_regular)
	    {
	      /* Mark the symbol as undefined, rather than as defined in
		 the .plt section.  Leave the value alone.  This is a clue
		 for the dynamic linker, to make function pointer
		 comparisons work between an application and shared
		 library.  */
	      sym->st_shndx = SHN_UNDEF;
	    }
	}
    }

  if (h->got.offset != (bfd_vma) -1
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_GD
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE_NLT)
    {
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */
      if (htab->elf.sgot == NULL || htab->elf.srelgot == NULL)
	abort ();

      rela.r_offset = (htab->elf.sgot->output_section->vma
		       + htab->elf.sgot->output_offset
		       + (h->got.offset &~ (bfd_vma) 1));

      if (h->def_regular && s390_is_ifunc_symbol_p (h))
	{
	  if (info->shared)
	    {
	      /* An explicit GOT slot usage needs GLOB_DAT.  If the
		 symbol references local the implicit got.iplt slot
		 will be used and the IRELATIVE reloc has been created
		 above.  */
	      goto do_glob_dat;
	    }
	  else
	    {
	      /* For non-shared objects explicit GOT slots must be
		 filled with the PLT slot address for pointer
		 equality reasons.  */
	      bfd_put_64 (output_bfd, (htab->elf.iplt->output_section->vma
				       + htab->elf.iplt->output_offset
				       + h->plt.offset),
			  htab->elf.sgot->contents + h->got.offset);
	      return TRUE;
	    }
	}
      else if (info->shared
	  && SYMBOL_REFERENCES_LOCAL (info, h))
	{
	  /* If this is a static link, or it is a -Bsymbolic link and
	     the symbol is defined locally or was forced to be local
	     because of a version file, we just want to emit a
	     RELATIVE reloc.  The entry in the global offset table
	     will already have been initialized in the
	     relocate_section function.  */
	  if (!h->def_regular)
	    return FALSE;
	  BFD_ASSERT((h->got.offset & 1) != 0);
	  rela.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
	  rela.r_addend = (h->root.u.def.value
			   + h->root.u.def.section->output_section->vma
			   + h->root.u.def.section->output_offset);
	}
      else
	{
	  BFD_ASSERT((h->got.offset & 1) == 0);
do_glob_dat:
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->elf.sgot->contents + h->got.offset);
	  rela.r_info = ELF64_R_INFO (h->dynindx, R_390_GLOB_DAT);
	  rela.r_addend = 0;
	}

      loc = htab->elf.srelgot->contents;
      loc += htab->elf.srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
    }

  if (h->needs_copy)
    {
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbols needs a copy reloc.  Set it up.  */

      if (h->dynindx == -1
	  || (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	  || htab->srelbss == NULL)
	abort ();

      rela.r_offset = (h->root.u.def.value
		       + h->root.u.def.section->output_section->vma
		       + h->root.u.def.section->output_offset);
      rela.r_info = ELF64_R_INFO (h->dynindx, R_390_COPY);
      rela.r_addend = 0;
      loc = htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
    }

  /* Mark some specially defined symbols as absolute.  */
  if (h == htab->elf.hdynamic
      || h == htab->elf.hgot
      || h == htab->elf.hplt)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

/* Used to decide how to sort relocs in an optimal manner for the
   dynamic linker, before writing them out.  */

static enum elf_reloc_type_class
elf_s390_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   const asection *rel_sec ATTRIBUTE_UNUSED,
			   const Elf_Internal_Rela *rela)
{
  switch ((int) ELF64_R_TYPE (rela->r_info))
    {
    case R_390_RELATIVE:
      return reloc_class_relative;
    case R_390_JMP_SLOT:
      return reloc_class_plt;
    case R_390_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf_s390_finish_dynamic_sections (bfd *output_bfd,
				  struct bfd_link_info *info)
{
  struct elf_s390_link_hash_table *htab;
  bfd *dynobj;
  asection *sdyn;
  bfd *ibfd;
  unsigned int i;

  htab = elf_s390_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = htab->elf.dynobj;
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (htab->elf.dynamic_sections_created)
    {
      Elf64_External_Dyn *dyncon, *dynconend;

      if (sdyn == NULL || htab->elf.sgot == NULL)
	abort ();

      dyncon = (Elf64_External_Dyn *) sdyn->contents;
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;

	  bfd_elf64_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      continue;

	    case DT_PLTGOT:
	      dyn.d_un.d_ptr = htab->elf.sgot->output_section->vma;
	      break;

	    case DT_JMPREL:
	      dyn.d_un.d_ptr = htab->elf.srelplt->output_section->vma;
	      break;

	    case DT_PLTRELSZ:
	      s = htab->elf.srelplt->output_section;
	      dyn.d_un.d_val = s->size;
	      break;

	    case DT_RELASZ:
	      /* The procedure linkage table relocs (DT_JMPREL) should
		 not be included in the overall relocs (DT_RELA).
		 Therefore, we override the DT_RELASZ entry here to
		 make it not include the JMPREL relocs.  Since the
		 linker script arranges for .rela.plt to follow all
		 other relocation sections, we don't have to worry
		 about changing the DT_RELA entry.  */
	      s = htab->elf.srelplt->output_section;
	      dyn.d_un.d_val -= s->size;
	      break;
	    }

	  bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	}

      /* Fill in the special first entry in the procedure linkage table.  */
      if (htab->elf.splt && htab->elf.splt->size > 0)
	{
	  /* fill in blueprint for plt 0 entry */
	  memcpy (htab->elf.splt->contents, elf_s390x_first_plt_entry,
		  PLT_FIRST_ENTRY_SIZE);
	  /* Fixup relative address to start of GOT */
	  bfd_put_32 (output_bfd,
		      (htab->elf.sgotplt->output_section->vma +
		       htab->elf.sgotplt->output_offset
		       - htab->elf.splt->output_section->vma - 6)/2,
		      htab->elf.splt->contents + 8);
	}
      if (elf_section_data (htab->elf.splt->output_section) != NULL)
	elf_section_data (htab->elf.splt->output_section)->this_hdr.sh_entsize
	  = PLT_ENTRY_SIZE;
    }

  if (htab->elf.sgotplt)
    {
      /* Fill in the first three entries in the global offset table.  */
      if (htab->elf.sgotplt->size > 0)
	{
	  bfd_put_64 (output_bfd,
		      (sdyn == NULL ? (bfd_vma) 0
		       : sdyn->output_section->vma + sdyn->output_offset),
		      htab->elf.sgotplt->contents);
	  /* One entry for shared object struct ptr.  */
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->elf.sgotplt->contents + 8);
	  /* One entry for _dl_runtime_resolve.  */
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->elf.sgotplt->contents + 12);
	}

      elf_section_data (htab->elf.sgot->output_section)
	->this_hdr.sh_entsize = 8;
    }

  /* Finish dynamic symbol for local IFUNC symbols.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      struct plt_entry *local_plt;
      Elf_Internal_Sym *isym;
      Elf_Internal_Shdr *symtab_hdr;

      symtab_hdr = &elf_symtab_hdr (ibfd);

      local_plt = elf_s390_local_plt (ibfd);
      if (local_plt != NULL)
	for (i = 0; i < symtab_hdr->sh_info; i++)
	  {
	    if (local_plt[i].plt.offset != (bfd_vma) -1)
	      {
		asection *sec = local_plt[i].sec;
		isym = bfd_sym_from_r_symndx (&htab->sym_cache, ibfd, i);
		if (isym == NULL)
		  return FALSE;

		if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
		  elf_s390_finish_ifunc_symbol (output_bfd, info, NULL, htab,
						local_plt[i].plt.offset,
						isym->st_value
						+ sec->output_section->vma
						+ sec->output_offset);

	      }
	  }
    }

  return TRUE;
}

/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
elf_s390_plt_sym_val (bfd_vma i, const asection *plt,
		      const arelent *rel ATTRIBUTE_UNUSED)
{
  return plt->vma + PLT_FIRST_ENTRY_SIZE + i * PLT_ENTRY_SIZE;
}

/* Why was the hash table entry size definition changed from
   ARCH_SIZE/8 to 4? This breaks the 64 bit dynamic linker and
   this is the only reason for the s390_elf64_size_info structure.  */

const struct elf_size_info s390_elf64_size_info =
{
  sizeof (Elf64_External_Ehdr),
  sizeof (Elf64_External_Phdr),
  sizeof (Elf64_External_Shdr),
  sizeof (Elf64_External_Rel),
  sizeof (Elf64_External_Rela),
  sizeof (Elf64_External_Sym),
  sizeof (Elf64_External_Dyn),
  sizeof (Elf_External_Note),
  8,		/* hash-table entry size.  */
  1,		/* internal relocations per external relocations.  */
  64,		/* arch_size.  */
  3,		/* log_file_align.  */
  ELFCLASS64, EV_CURRENT,
  bfd_elf64_write_out_phdrs,
  bfd_elf64_write_shdrs_and_ehdr,
  bfd_elf64_checksum_contents,
  bfd_elf64_write_relocs,
  bfd_elf64_swap_symbol_in,
  bfd_elf64_swap_symbol_out,
  bfd_elf64_slurp_reloc_table,
  bfd_elf64_slurp_symbol_table,
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
};

#define TARGET_BIG_SYM	bfd_elf64_s390_vec
#define TARGET_BIG_NAME	"elf64-s390"
#define ELF_ARCH	bfd_arch_s390
#define ELF_TARGET_ID	S390_ELF_DATA
#define ELF_MACHINE_CODE EM_S390
#define ELF_MACHINE_ALT1 EM_S390_OLD
#define ELF_MAXPAGESIZE 0x1000

#define elf_backend_size_info		s390_elf64_size_info

#define elf_backend_can_gc_sections	1
#define elf_backend_can_refcount	1
#define elf_backend_want_got_plt	1
#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_got_header_size	24
#define elf_backend_rela_normal		1

#define elf_info_to_howto		elf_s390_info_to_howto

#define bfd_elf64_bfd_is_local_label_name     elf_s390_is_local_label_name
#define bfd_elf64_bfd_link_hash_table_create  elf_s390_link_hash_table_create
#define bfd_elf64_bfd_reloc_type_lookup	      elf_s390_reloc_type_lookup
#define bfd_elf64_bfd_reloc_name_lookup elf_s390_reloc_name_lookup

#define elf_backend_adjust_dynamic_symbol     elf_s390_adjust_dynamic_symbol
#define elf_backend_check_relocs	      elf_s390_check_relocs
#define elf_backend_copy_indirect_symbol      elf_s390_copy_indirect_symbol
#define elf_backend_create_dynamic_sections   elf_s390_create_dynamic_sections
#define elf_backend_finish_dynamic_sections   elf_s390_finish_dynamic_sections
#define elf_backend_finish_dynamic_symbol     elf_s390_finish_dynamic_symbol
#define elf_backend_gc_mark_hook	      elf_s390_gc_mark_hook
#define elf_backend_gc_sweep_hook	      elf_s390_gc_sweep_hook
#define elf_backend_reloc_type_class	      elf_s390_reloc_type_class
#define elf_backend_relocate_section	      elf_s390_relocate_section
#define elf_backend_size_dynamic_sections     elf_s390_size_dynamic_sections
#define elf_backend_init_index_section	      _bfd_elf_init_1_index_section
#define elf_backend_plt_sym_val		      elf_s390_plt_sym_val
#define elf_backend_add_symbol_hook           elf_s390_add_symbol_hook

#define bfd_elf64_mkobject		elf_s390_mkobject
#define elf_backend_object_p		elf_s390_object_p

/* Enable ELF64 archive functions.  */
#define bfd_elf64_archive_functions
extern bfd_boolean bfd_elf64_archive_slurp_armap (bfd *);
extern bfd_boolean bfd_elf64_archive_write_armap (bfd *, unsigned int, struct orl *, unsigned int, int);

#define bfd_elf64_archive_slurp_extended_name_table 	_bfd_archive_coff_slurp_extended_name_table
#define bfd_elf64_archive_construct_extended_name_table _bfd_archive_coff_construct_extended_name_table
#define bfd_elf64_archive_truncate_arname 		_bfd_archive_coff_truncate_arname
#define bfd_elf64_archive_read_ar_hdr			_bfd_archive_coff_read_ar_hdr
#define bfd_elf64_archive_write_ar_hdr			_bfd_archive_coff_write_ar_hdr
#define bfd_elf64_archive_openr_next_archived_file 	_bfd_archive_coff_openr_next_archived_file
#define bfd_elf64_archive_get_elt_at_index 		_bfd_archive_coff_get_elt_at_index
#define bfd_elf64_archive_generic_stat_arch_elt 	_bfd_archive_coff_generic_stat_arch_elt
#define bfd_elf64_archive_update_armap_timestamp 	_bfd_archive_coff_update_armap_timestamp

#include "elf64-target.h"
@


1.130
log
@2013-07-05  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

bfd/
	* elf32-s390.c: Rewrite GOT accesses using larl if possible.
	* elf64-s390.c: Likewise.

ld/testsuite/
	* ld-s390/gotreloc-1.s: New file.
	* ld-s390/gotreloc-1.ver: New file.
	* ld-s390/gotreloc_31-1.dd: New file.
	* ld-s390/gotreloc_64-1.dd: New file.
	* ld-s390/s390.exp: Run the new tests. Run 31 bit tests also on 64
	bit.
@
text
@d3695 3
a3697 2
      elf_section_data (htab->elf.splt->output_section)
	->this_hdr.sh_entsize = PLT_ENTRY_SIZE;
@


1.129
log
@2013-07-05  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>
opcodes/
	    * s390-opc.c (J12_12, J24_24): New macros.
	    (INSTR_MII_UPI): Rename to INSTR_MII_UPP.
	    (MASK_MII_UPI): Rename to MASK_MII_UPP.
	    * s390-opc.txt: Rename MII_UPI to MII_UPP for bprp instruction.

include/elf/
	    * s390.h: Add new relocs R_390_PC12DBL, R_390_PLT12DBL,
	    R_390_PC24DBL, and R_390_PLT24DBL.

gas/testsuite/
	    * gas/s390/zarch-zEC12.s: Change bprp second operand and add
	    variants requiring relocations.
	    * gas/s390/zarch-zEC12.d: Likewise.

gas/
	    * config/tc-s390.c (md_gather_operands, md_apply_fix): Support new
	    relocs.
bfd/
	    * elf32-s390.c: Add new relocation definitions R_390_PC12DBL,
	    R_390_PLT12DBL, R_390_PC24DBL, and R_390_PLT24DBL.
	    (elf_s390_reloc_type_lookup, elf_s390_check_relocs)
	    (elf_s390_gc_sweep_hook, elf_s390_relocate_section): Support new
	    relocations.
	    * elf64-s390.c: See elf32-s390.c
	    * bfd-in2.h: Add new relocs to enum bfd_reloc_code_real.
	    * libbfd.h: Add new reloc strings.
@
text
@d2499 31
@


1.128
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d46 1
a46 1
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
d174 8
a181 1

d232 4
d240 4
d1055 1
d1057 1
d1196 1
d1199 1
d1245 1
d1247 1
d1324 2
d1497 1
d1499 1
d1507 1
d1509 1
d2580 1
d2582 1
d2647 1
d2649 1
d2723 1
d2725 1
d2767 1
d2769 1
d3206 7
@


1.127
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d953 4
@


1.126
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d3519 3
a3521 1
elf_s390_reloc_type_class (const Elf_Internal_Rela *rela)
a3756 1
#define elf_backend_reloc_type_class	      elf_s390_reloc_type_class
@


1.125
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d702 1
a702 1
  ret = (struct elf_s390_link_hash_table *) bfd_malloc (amt);
a713 10
  ret->elf.sgot = NULL;
  ret->elf.sgotplt = NULL;
  ret->elf.srelgot = NULL;
  ret->elf.splt = NULL;
  ret->elf.srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->tls_ldm_got.refcount = 0;
  ret->sym_cache.abfd = NULL;

@


1.124
log
@2012-11-05  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	PR target/14788
	* elf32-s390.c (elf_s390_relocate_section): Set elf.dynobj for
	local ifunc symbols.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
@
text
@d418 1
a418 1
  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address); 
@


1.123
log
@2012-09-03  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (elf_s390_relocate_section): Handle PLTOFF for
	local and global ifunc symbols.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
@
text
@d940 3
@


1.122
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d2309 5
d2569 1
a2569 1
	      || (htab->elf.splt == NULL && htab->elf.iplt == NULL))
d2595 1
a2595 1
	  if (   h == NULL
d2597 1
a2597 1
	      || htab->elf.splt == NULL)
@


1.121
log
@2012-07-13  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf64-s390.c: Include elf-s390-common.c.
	(R_390_IRELATIVE): New reloc.
	(elf_s390_reloc_type_lookup): Support R_390_IRELATIVE.
	(RELA_ENTRY_SIZE): New macro.
	(elf_s390_link_hash_entry): New fields ifunc_resolver_address and
	*ifunc_resolver_section.
	(struct plt_entry): New struct.
	(struct elf_s390_obj_tdata): New field local_plt.
	(elf_s390_local_plt): New macro.
	(struct elf_s390_link_hash_table): New field irelifunc.
	(ELF64): New macro.
	(link_hash_newfunc): Initialize new fields.
	(elf_s390_check_relocs): Handle IFUNC symbols.
	(elf_s390_adjust_dynamic_symbol): Don't do anything for IFUNC
	symbols.
	(allocate_dynrelocs): Call s390_elf_allocate_ifunc_dyn_relocs for
	IFUNC symbols.
	(elf_s390_size_dynamic_sections): Handle IFUNC symbols.
	(elf_s390_relocate_section): Likewise.
	(elf_s390_finish_dynamic_symbol): Likewise.
	(elf_s390_finish_dynamic_sections): Handle local IFUNC symbols.
	(elf_s390_finish_ifunc_symbol): New function.
	(elf_s390_gc_sweep_hook): Handle local plt entries.
	(elf_backend_add_symbol_hook): Define.
	* elf32-s390.c: See elf64-s390.c changes.
	* elf-s390-common.c: New file.
	* bfd-in2.h (BFD_RELOC_390_IRELATIVE): New enum field.
	* libbfd.h (BFD_RELOC_390_IRELATIVE): New entry for
	BFD_RELOC_390_IRELATIVE.
	* reloc.c (BFD_RELOC_390_IRELATIVE): Document new relocation.

2012-07-13  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf/s390.h (START_RELOC_NUMBERS): Define R_390_IRELATIVE reloc.

2012-07-13  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* emulparams/elf_s390.sh (IREL_IN_PLT): Define.
	* emulparams/elf64_s390.sh (IREL_IN_PLT): Define.
@
text
@d3509 1
a3509 1
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
@


1.121.4.1
log
@bfd/
2012-11-05  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	PR target/14788
	* elf32-s390.c (elf_s390_relocate_section): Set elf.dynobj for
	local ifunc symbols.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
@
text
@a939 3
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;

@


1.120
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d172 3
d301 2
d458 2
d562 8
d575 15
d596 3
d606 3
d640 1
d657 3
d687 2
d916 1
d929 25
a953 1
	h = NULL;
d991 1
a991 7
	      bfd_size_type size;

	      size = symtab_hdr->sh_info;
	      size *= (sizeof (bfd_signed_vma) + sizeof(char));
	      local_got_refcounts = ((bfd_signed_vma *)
				     bfd_zalloc (abfd, size));
	      if (local_got_refcounts == NULL)
d993 1
a993 3
	      elf_local_got_refcounts (abfd) = local_got_refcounts;
	      elf_s390_local_got_tls_type (abfd)
		= (char *) (local_got_refcounts + symtab_hdr->sh_info);
d995 1
d1011 19
d1037 4
a1040 1
	  /* Got is created, nothing to be done.  */
d1187 1
a1187 1
	  if (h != NULL && !info->shared)
d1197 6
a1202 3
	      /* We may need a .plt entry if the function this reloc
		 refers to is in a shared lib.  */
	      h->plt.refcount += 1;
a1274 1
		  Elf_Internal_Sym *isym;
d1414 17
d1563 4
d1693 1
a1693 1
  struct elf_s390_link_hash_entry *eh;
d1704 7
a1710 2
  if (htab->elf.dynamic_sections_created
      && h->plt.refcount > 0)
a1826 1
  eh = (struct elf_s390_link_hash_entry *) h;
d1983 2
d2037 14
d2079 4
a2082 1
	  || s == htab->sdynbss)
d2272 1
d2295 49
a2343 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d2383 21
a2403 8
	      /* Calc. index no.
		 Current offset - size first entry / entry size.  */
	      plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) /
		PLT_ENTRY_SIZE;

	      /* Offset in GOT is PLT index plus GOT headers(3) times 4,
		 addr & GOT addr.  */
	      relocation = (plt_index + 3) * GOT_ENTRY_SIZE;
a2404 3

	      if (r_type == R_390_GOTPLTENT)
		relocation += htab->elf.sgot->output_section->vma;
d2417 1
a2417 1
	  if (htab->elf.sgot == NULL)
d2426 23
a2448 5
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		  || (info->shared
		      && SYMBOL_REFERENCES_LOCAL (info, h))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
d2467 1
a2467 1
				  htab->elf.sgot->contents + off);
d2518 1
a2518 1
	  relocation = htab->elf.sgot->output_offset + off;
d2526 1
a2526 1
	    relocation += htab->elf.sgot->output_section->vma;
d2564 1
a2564 1
	      || htab->elf.splt == NULL)
d2571 8
a2578 4

	  relocation = (htab->elf.splt->output_section->vma
			+ htab->elf.splt->output_offset
			+ h->plt.offset);
d2598 10
a2607 4
	  relocation = (htab->elf.splt->output_section->vma
			+ htab->elf.splt->output_offset
			+ h->plt.offset
			- htab->elf.sgot->output_section->vma);
d2620 62
d3167 2
d3225 86
d3321 1
d3336 31
d3368 15
a3382 5
      if (h->dynindx == -1
	  || htab->elf.splt == NULL
	  || htab->elf.sgotplt == NULL
	  || htab->elf.srelplt == NULL)
	abort ();
d3384 18
a3401 43
      /* Calc. index no.
	 Current offset - size first entry / entry size.  */
      plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) / PLT_ENTRY_SIZE;

      /* Offset in GOT is PLT index plus GOT headers(3) times 8,
	 addr & GOT addr.  */
      got_offset = (plt_index + 3) * GOT_ENTRY_SIZE;

      /* Fill in the blueprint of a PLT.  */
      memcpy (htab->elf.splt->contents + h->plt.offset, elf_s390x_plt_entry,
	      PLT_ENTRY_SIZE);

      /* Fixup the relative address to the GOT entry */
      bfd_put_32 (output_bfd,
		  (htab->elf.sgotplt->output_section->vma +
		   htab->elf.sgotplt->output_offset + got_offset
		   - (htab->elf.splt->output_section->vma + h->plt.offset))/2,
		  htab->elf.splt->contents + h->plt.offset + 2);
      /* Fixup the relative branch to PLT 0 */
      bfd_put_32 (output_bfd, - (PLT_FIRST_ENTRY_SIZE +
				 (PLT_ENTRY_SIZE * plt_index) + 22)/2,
		  htab->elf.splt->contents + h->plt.offset + 24);
      /* Fixup offset into .rela.plt section.  */
      bfd_put_32 (output_bfd, plt_index * sizeof (Elf64_External_Rela),
		  htab->elf.splt->contents + h->plt.offset + 28);

      /* Fill in the entry in the global offset table.
	 Points to instruction after GOT offset.  */
      bfd_put_64 (output_bfd,
		  (htab->elf.splt->output_section->vma
		   + htab->elf.splt->output_offset
		   + h->plt.offset
		   + 14),
		  htab->elf.sgotplt->contents + got_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (htab->elf.sgotplt->output_section->vma
		       + htab->elf.sgotplt->output_offset
		       + got_offset);
      rela.r_info = ELF64_R_INFO (h->dynindx, R_390_JMP_SLOT);
      rela.r_addend = 0;
      loc = htab->elf.srelplt->contents + plt_index * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
d3403 9
a3411 8
      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  This is a clue
	     for the dynamic linker, to make function pointer
	     comparisons work between an application and shared
	     library.  */
	  sym->st_shndx = SHN_UNDEF;
d3432 23
a3454 6
      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (info->shared
d3457 6
d3474 1
d3545 2
d3640 32
a3684 1

d3759 1
@


1.119
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@a27 57

static reloc_howto_type *elf_s390_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void elf_s390_info_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean elf_s390_is_local_label_name
  PARAMS ((bfd *, const char *));
static struct bfd_hash_entry *link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *elf_s390_link_hash_table_create
  PARAMS ((bfd *));
static bfd_boolean create_got_section
  PARAMS((bfd *, struct bfd_link_info *));
static bfd_boolean elf_s390_create_dynamic_sections
  PARAMS((bfd *, struct bfd_link_info *));
static void elf_s390_copy_indirect_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
static bfd_boolean elf_s390_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
struct elf_s390_link_hash_entry;
static void elf_s390_adjust_gotplt
  PARAMS ((struct elf_s390_link_hash_entry *));
static bfd_boolean elf_s390_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean elf_s390_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_s390_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf_s390_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static enum elf_reloc_type_class elf_s390_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean elf_s390_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_s390_object_p
  PARAMS ((bfd *));
static int elf_s390_tls_transition
  PARAMS ((struct bfd_link_info *, int, int));
static bfd_reloc_status_type s390_tls_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
static void invalid_tls_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *));
static bfd_reloc_status_type s390_elf_ldisp_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

d34 7
d181 2
a182 3
elf_s390_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d333 3
a335 4
elf_s390_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d361 7
a367 9
s390_tls_reloc (abfd, reloc_entry, symbol, data, input_section,
		output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d376 7
a382 9
s390_elf_ldisp_reloc (abfd, reloc_entry, symbol, data, input_section,
                      output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d425 1
a425 3
elf_s390_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
d589 1
a589 2
elf_s390_object_p (abfd)
     bfd *abfd;
d623 3
a625 4
link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d655 1
a655 2
elf_s390_link_hash_table_create (abfd)
     bfd *abfd;
d745 3
a747 3
elf_s390_copy_indirect_symbol (info, dir, ind)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *dir, *ind;
d809 3
a811 4
elf_s390_tls_transition (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
d1435 1
a1435 2
elf_s390_adjust_gotplt (h)
     struct elf_s390_link_hash_entry *h;
d1808 1
a1808 3
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d1941 1
a1941 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, (PTR) info);
d2039 1
a2039 1
				    (PTR) info);
d2058 1
a2058 2
dtpoff_base (info)
     struct bfd_link_info *info;
d2070 1
a2070 3
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
d2084 3
a2086 4
invalid_tls_insn (input_bfd, input_section, rel)
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *rel;
d3114 1
a3114 2
elf_s390_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d3323 15
@


1.118
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d762 3
a764 3
  htab->elf.sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->elf.sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  htab->elf.srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d790 3
a792 3
  htab->elf.splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->elf.srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
d794 1
a794 1
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rela.bss");
d1921 1
a1921 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d3214 1
a3214 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
@


1.117
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2249 1
a2249 1
					 rel, relend, howto, contents);
@


1.116
log
@2012-04-20  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (ELF_DYNAMIC_INTERPRETER): Set to the GCC default.
	* elf64-s390.c (ELF_DYNAMIC_INTERPRETER): Set to the GCC default.
@
text
@d2247 1
a2247 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.115
log
@2012-03-30  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf64-s390.c: Fix several comments regarding PLT entry
	description.
	* elf32-s390.c: Likewise.
@
text
@d496 1
a496 1
#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so.1"
@


1.114
log
@2012-03-30  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf64-s390.c: Use the section pointer shortcuts in
	elf_link_hash_table and remove them from the target specific
	variant.
	* elf32-s390.c: Likewise.
@
text
@d543 1
a543 1
         .long ?          # 4 bytes  offset into symbol table
d548 1
a548 1
   Fixup at offset 28: 32 bit offset into symbol table
d550 5
a554 5
   A 32 bit offset into the symbol table is enough. It allows for symbol
   tables up to a size of 2 gigabyte. A single dynamic object (the main
   program, any shared library) is limited to 4GB in size and I want to see
   the program that manages to have a symbol table of more than 2 GB with a
   total size of at max 4 GB.  */
d568 2
a569 2
   from R1 onto the stack at 8(15) and the loader object info
   at 12(15), loads the loader address in R1 and jumps to it.  */
d3068 1
a3068 1
      /* Fixup offset into symbol table */
@


1.113
log
@2012-03-30  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf64-s390.c (elf_s390x_plt_entry, elf_s390x_first_plt_entry):
	New definitions.
	(PLT_PIC_ENTRY_WORD*, PLT_PIC12_ENTRY_WORD*): Remove.
	(elf_s390_finish_dynamic_symbol): Use memcpy instead of bfd_put_32.
	(elf_s390_finish_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_plt_entry, elf_s390_plt_pic_entry)
	(elf_s390_plt_pic12_entry, elf_s390_plt_pic16_entry)
	(elf_s390_plt_first_entry, elf_s390_plt_pic_first_entry): New definitions.
	(PLT_PIC16_ENTRY_WORD*, PLT_ENTRY_WORD*)
	(PLT_PIC_FIRST_ENTRY_WORD*, PLT_FIRST_ENTRY_WORD*): Remove.
@
text
@a660 5
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
d733 5
a737 5
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
d762 4
a765 4
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  htab->srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
  if (!htab->sgot || !htab->sgotplt || !htab->srelgot)
d784 1
a784 1
  if (!htab->sgot && !create_got_section (dynobj, info))
d790 2
a791 2
  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
d796 1
a796 1
  if (!htab->splt || !htab->srelplt || !htab->sdynbss
d1004 1
a1004 1
	  if (htab->sgot == NULL)
d1677 1
a1677 1
	  asection *s = htab->splt;
d1703 1
a1703 1
	  htab->sgotplt->size += GOT_ENTRY_SIZE;
d1706 1
a1706 1
	  htab->srelplt->size += sizeof (Elf64_External_Rela);
d1736 2
a1737 2
	  h->got.offset = htab->sgot->size;
	  htab->sgot->size += GOT_ENTRY_SIZE;
d1757 1
a1757 1
      s = htab->sgot;
d1768 1
a1768 1
	htab->srelgot->size += sizeof (Elf64_External_Rela);
d1770 1
a1770 1
	htab->srelgot->size += 2 * sizeof (Elf64_External_Rela);
d1775 1
a1775 1
	htab->srelgot->size += sizeof (Elf64_External_Rela);
d1975 2
a1976 2
      s = htab->sgot;
      srela = htab->srelgot;
d1997 3
a1999 3
      htab->tls_ldm_got.offset = htab->sgot->size;
      htab->sgot->size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->size += sizeof (Elf64_External_Rela);
d2016 3
a2018 3
      if (s == htab->splt
	  || s == htab->sgot
	  || s == htab->sgotplt
d2026 1
a2026 1
	  if (s->size != 0 && s != htab->srelplt)
d2084 1
a2084 1
      if (htab->splt->size != 0)
d2286 1
a2286 1
		relocation += htab->sgot->output_section->vma;
d2299 1
a2299 1
	  if (htab->sgot == NULL)
d2331 1
a2331 1
				  htab->sgot->contents + off);
d2353 1
a2353 1
			      htab->sgot->contents + off);
d2361 1
a2361 1
		      s = htab->srelgot;
d2365 2
a2366 2
		      outrel.r_offset = (htab->sgot->output_section->vma
					 + htab->sgot->output_offset
d2382 1
a2382 1
	  relocation = htab->sgot->output_offset + off;
d2390 1
a2390 1
	    relocation += htab->sgot->output_section->vma;
d2405 1
a2405 1
	  relocation -= htab->sgot->output_section->vma;
d2411 1
a2411 1
	  relocation = htab->sgot->output_section->vma;
d2428 1
a2428 1
	      || htab->splt == NULL)
d2436 2
a2437 2
	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
d2452 1
a2452 1
	      || htab->splt == NULL)
d2454 1
a2454 1
	      relocation -= htab->sgot->output_section->vma;
d2458 2
a2459 2
	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
d2461 1
a2461 1
			- htab->sgot->output_section->vma);
d2644 1
a2644 1
	  if (htab->sgot == NULL)
d2667 1
a2667 1
	      if (htab->srelgot == NULL)
d2670 2
a2671 2
	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);
d2683 2
a2684 2
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
d2695 1
a2695 1
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
d2702 1
a2702 1
		      htab->srelgot->reloc_count++;
d2718 1
a2718 1
	      relocation = htab->sgot->output_offset + off;
d2720 1
a2720 1
		relocation += htab->sgot->output_section->vma;
d2725 1
a2725 1
	      bfd_put_64 (output_bfd, htab->sgot->output_offset + off,
d2750 1
a2750 1
	  if (htab->sgot == NULL)
d2755 2
a2756 2
		      htab->sgot->contents + off);
	  relocation = htab->sgot->output_offset + off;
d2758 1
a2758 1
	    relocation += htab->sgot->output_section->vma;
d2769 1
a2769 1
	  if (htab->sgot == NULL)
d2780 1
a2780 1
	      if (htab->srelgot == NULL)
d2783 2
a2784 2
	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);
d2787 1
a2787 1
			  htab->sgot->contents + off + GOT_ENTRY_SIZE);
d2790 2
a2791 2
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
d2796 1
a2796 1
	  relocation = htab->sgot->output_offset + off;
d3041 3
a3043 3
	  || htab->splt == NULL
	  || htab->sgotplt == NULL
	  || htab->srelplt == NULL)
d3055 1
a3055 1
      memcpy (htab->splt->contents + h->plt.offset, elf_s390x_plt_entry,
d3060 4
a3063 4
		  (htab->sgotplt->output_section->vma +
		   htab->sgotplt->output_offset + got_offset
		   - (htab->splt->output_section->vma + h->plt.offset))/2,
		  htab->splt->contents + h->plt.offset + 2);
d3067 1
a3067 1
		  htab->splt->contents + h->plt.offset + 24);
d3070 1
a3070 1
		  htab->splt->contents + h->plt.offset + 28);
d3075 2
a3076 2
		  (htab->splt->output_section->vma
		   + htab->splt->output_offset
d3079 1
a3079 1
		  htab->sgotplt->contents + got_offset);
d3082 2
a3083 2
      rela.r_offset = (htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset
d3087 1
a3087 1
      loc = htab->srelplt->contents + plt_index * sizeof (Elf64_External_Rela);
d3111 1
a3111 1
      if (htab->sgot == NULL || htab->srelgot == NULL)
d3114 2
a3115 2
      rela.r_offset = (htab->sgot->output_section->vma
		       + htab->sgot->output_offset
d3137 1
a3137 1
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->sgot->contents + h->got.offset);
d3142 2
a3143 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d3220 1
a3220 1
      if (sdyn == NULL || htab->sgot == NULL)
d3238 1
a3238 1
	      dyn.d_un.d_ptr = htab->sgot->output_section->vma;
d3242 1
a3242 1
	      dyn.d_un.d_ptr = htab->srelplt->output_section->vma;
d3246 1
a3246 1
	      s = htab->srelplt->output_section;
d3258 1
a3258 1
	      s = htab->srelplt->output_section;
d3267 1
a3267 1
      if (htab->splt && htab->splt->size > 0)
d3270 1
a3270 1
	  memcpy (htab->splt->contents, elf_s390x_first_plt_entry,
d3274 4
a3277 4
		      (htab->sgotplt->output_section->vma +
		       htab->sgotplt->output_offset
		       - htab->splt->output_section->vma - 6)/2,
		      htab->splt->contents + 8);
d3279 1
a3279 1
      elf_section_data (htab->splt->output_section)
d3283 1
a3283 1
  if (htab->sgotplt)
d3286 1
a3286 1
      if (htab->sgotplt->size > 0)
d3291 1
a3291 1
		      htab->sgotplt->contents);
d3293 1
a3293 1
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->sgotplt->contents + 8);
d3295 1
a3295 1
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->sgotplt->contents + 12);
d3298 1
a3298 1
      elf_section_data (htab->sgot->output_section)
@


1.112
log
@2012-03-30  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (struct elf_s390_dyn_relocs): Remove.
	Rename all occurrences in the file to elf_dyn_relocs.
	* elf64-s390.c: Likewise.
@
text
@d556 10
a565 8
#define PLT_ENTRY_WORD0     (bfd_vma) 0xc0100000
#define PLT_ENTRY_WORD1     (bfd_vma) 0x0000e310
#define PLT_ENTRY_WORD2     (bfd_vma) 0x10000004
#define PLT_ENTRY_WORD3     (bfd_vma) 0x07f10d10
#define PLT_ENTRY_WORD4     (bfd_vma) 0xe310100c
#define PLT_ENTRY_WORD5     (bfd_vma) 0x0014c0f4
#define PLT_ENTRY_WORD6     (bfd_vma) 0x00000000
#define PLT_ENTRY_WORD7     (bfd_vma) 0x00000000
d582 11
a592 8
#define PLT_FIRST_ENTRY_WORD0     (bfd_vma) 0xe310f038
#define PLT_FIRST_ENTRY_WORD1     (bfd_vma) 0x0024c010
#define PLT_FIRST_ENTRY_WORD2     (bfd_vma) 0x00000000
#define PLT_FIRST_ENTRY_WORD3     (bfd_vma) 0xd207f030
#define PLT_FIRST_ENTRY_WORD4     (bfd_vma) 0x1008e310
#define PLT_FIRST_ENTRY_WORD5     (bfd_vma) 0x10100004
#define PLT_FIRST_ENTRY_WORD6     (bfd_vma) 0x07f10700
#define PLT_FIRST_ENTRY_WORD7     (bfd_vma) 0x07000700
d3060 3
a3062 16
      bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD0,
		  htab->splt->contents + h->plt.offset);
      bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD1,
		  htab->splt->contents + h->plt.offset + 4);
      bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD2,
		  htab->splt->contents + h->plt.offset + 8);
      bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD3,
		  htab->splt->contents + h->plt.offset + 12);
      bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD4,
		  htab->splt->contents + h->plt.offset + 16);
      bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD5,
		  htab->splt->contents + h->plt.offset + 20);
      bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD6,
		  htab->splt->contents + h->plt.offset + 24);
      bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD7,
		  htab->splt->contents + h->plt.offset + 28);
d3275 2
a3276 14
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD0,
		      htab->splt->contents );
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD1,
		      htab->splt->contents +4 );
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD3,
		      htab->splt->contents +12 );
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD4,
		      htab->splt->contents +16 );
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD5,
		      htab->splt->contents +20 );
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD6,
		      htab->splt->contents + 24);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD7,
		      htab->splt->contents + 28 );
@


1.111
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@a588 19
/* The s390 linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct elf_s390_dyn_relocs
{
  struct elf_s390_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};
d597 1
a597 1
  struct elf_s390_dyn_relocs *dyn_relocs;
d819 2
a820 2
	  struct elf_s390_dyn_relocs **pp;
	  struct elf_s390_dyn_relocs *p;
d826 1
a826 1
	      struct elf_s390_dyn_relocs *q;
d1221 2
a1222 2
	      struct elf_s390_dyn_relocs *p;
	      struct elf_s390_dyn_relocs **head;
d1264 1
a1264 1
		  head = (struct elf_s390_dyn_relocs **) vpp;
d1271 1
a1271 1
		  p = ((struct elf_s390_dyn_relocs *)
d1375 2
a1376 2
	  struct elf_s390_dyn_relocs **pp;
	  struct elf_s390_dyn_relocs *p;
d1595 1
a1595 1
      struct elf_s390_dyn_relocs *p;
d1652 1
a1652 1
  struct elf_s390_dyn_relocs *p;
d1794 1
a1794 1
	  struct elf_s390_dyn_relocs **pp;
d1876 1
a1876 1
  struct elf_s390_dyn_relocs *p;
d1945 1
a1945 1
	  struct elf_s390_dyn_relocs *p;
@


1.110
log
@2011-12-22  Martin Schwidefsky  <schwidefsky@@de.ibm.com>

	* elf32-s390.c (elf_s390_relocate_section): Add check for debugging
	section in LD to LE linker relaxation for R_390_TLS_LDO32.
	* elf64-s390.c (elf_s390_relocate_section): Likewise for
	R_390_TLS_LDO64.
@
text
@d3 1
a3 1
   2010, 2011 Free Software Foundation, Inc.
a1632 7
  if (h->size == 0)
    {
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     h->root.root.string);
      return TRUE;
    }

d1650 1
a1650 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.109
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d2864 1
a2864 1
	  if (info->shared)
@


1.108
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d2974 3
a2976 1
	       && h->def_dynamic))
@


1.108.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2273 1
a2273 1
      if (sec != NULL && discarded_section (sec))
@


1.107
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d3 1
a3 1
   2010  Free Software Foundation, Inc.
a1682 6
  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a1903 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.106
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d2283 2
a2284 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.105
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d3418 1
@


1.104
log
@update copyright dates
@
text
@d2 2
a3 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
d651 1
a651 1
   && elf_object_id (bfd) == S390_ELF_TDATA)
d657 1
a657 1
				  S390_ELF_TDATA);
d695 2
a696 1
  ((struct elf_s390_link_hash_table *) ((p)->hash))
d745 2
a746 1
				      sizeof (struct elf_s390_link_hash_entry)))
d769 2
a770 3
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d778 3
d794 2
a795 3
elf_s390_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d800 3
d920 4
a923 5
elf_s390_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d940 3
d1364 1
d1373 4
d1417 2
a1418 2
	  if (elf_s390_hash_table (info)->tls_ldm_got.refcount > 0)
	    elf_s390_hash_table (info)->tls_ldm_got.refcount -= 1;
d1538 2
a1539 3
elf_s390_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d1651 2
d1672 2
a1673 3
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d1691 2
d1934 2
a1935 3
elf_s390_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d1944 3
d2207 8
a2214 10
elf_s390_relocate_section (output_bfd, info, input_bfd, input_section,
			      contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d2226 3
d3059 4
a3062 5
elf_s390_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d3067 2
d3255 2
a3256 3
elf_s390_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d3263 3
@


1.103
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.102
log
@2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-arm.c (create_got_section): Get existing .rela.got
	section.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	* elf32-lm32.c (create_got_section): Likewise.
	* elf32-m32r.c (create_got_section): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.

	* elflink.c (_bfd_elf_create_got_section): Properly initialize
	the GOT size.
@
text
@d688 2
a689 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d758 1
a758 1
  ret->sym_sec.abfd = NULL;
a1260 1

d1263 6
d1270 1
a1270 2
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
d1272 1
a1272 1
		    return FALSE;
@


1.101
log
@2009-03-20  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	    Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (elf_s390_check_relocs): Use the SYMBOL_*
        macros for visibilty and locality checks.
	(elf_s390_adjust_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_s390_relocate_section): Likewise.
	(elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_adjust_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_s390_relocate_section): Likewise.
	(elf_s390_finish_dynamic_symbol): Likewise.
@
text
@d779 2
a780 1
  if (!htab->sgot || !htab->sgotplt)
a781 10

  htab->srelgot = bfd_make_section_with_flags (dynobj, ".rela.got",
					       (SEC_ALLOC | SEC_LOAD
						| SEC_HAS_CONTENTS
						| SEC_IN_MEMORY
						| SEC_LINKER_CREATED
						| SEC_READONLY));
  if (htab->srelgot == NULL
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 3))
    return FALSE;
@


1.100
log
@2008-12-04  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf64-s390.c (elf_s390_check_relocs): Initialize
	htab->elf.dynobj if necessary.
@
text
@d1231 1
a1231 1
		       && (! info->symbolic
d1544 3
a1546 5
	  || (! info->shared
	      && !h->def_dynamic
	      && !h->ref_dynamic
	      && h->root.type != bfd_link_hash_undefweak
	      && h->root.type != bfd_link_hash_undefined))
d1685 1
a1685 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d1814 1
a1814 1
      if (SYMBOL_REFERENCES_LOCAL (info, h))
d2339 1
a2339 4
		      && (info->symbolic
			  || h->dynindx == -1
			  || h->forced_local)
		      && h->def_regular)
d2515 1
a2515 2
		   || (h != NULL
		       && !SYMBOL_REFERENCES_LOCAL (info, h))))
d2558 1
a2558 1
			   || !info->symbolic
d3163 1
a3163 4
	  && (info->symbolic
	      || h->dynindx == -1
	      || h->forced_local)
	  && h->def_regular)
d3165 2
@


1.99
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d1249 3
@


1.98
log
@PR ld/5692
   * elf-bfd.h (enum elf_object_id): New enum, used to identify
   target specific extensions to the elf_obj_tdata structure.
   (struct elf_obj_tdata): New field 'object_id'.
   (elf_object_id, elf_program_header_size, elf_symtab_hdr): New
   macros for accessing fields in the elf_obj_tdata structure.
   (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object.
   (bfd_elf_allocate_object): New function.
   * elf.c (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object
   and implement by calling bfd_elf_allocate_object.
   (bfd_elf_allocate_object): New function: Allocates an
   elf_obj_tdata structure, possibly with a target specific
   extension.
   * elfxx-target.h (bfd_elfNN_mkobject): Use
   bfd_elf_make_generic_object as the default value.
   * elf32-arm.c (elf32_arm_obj_tdata): Rename to elf_arm_obj_tdata
   for consistency with other, similar structures.
   (is_arm_elf): New macro.  Checks a BFD to make sure that is an ARM
   ELF bfd.
   (elf32_arm_mkobject): Call bfd_elf_allocate_object.
   (bfd_elf32_arm_vfp11_erratum_scan): Use is_arm_elf macro to check
   the bfd being processed.
   (bfd_elf32_arm_vfp11_fix_veneer_locations): Likewise.
   (bfd_elf32_arm_set_target_relocs): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_copy_private_bfd_data): Likewise.
   (bfd_elf32_arm_merge_eabi_attributes): Likewise.
   (bfd_elf32_arm_merge_private_bfd_data): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_gc_mark_extra_sections): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   (bfd_elf32_arm_process_before_allocation): Use elf_symtab_hdr.
   (bfd_elf32_arm_init_maps): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_relocate_section): Likewise.
   (bfd_elf32_arm_gc_sweep_hook): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   * elf32-i386.c (elf_i386_mkobject): Call bfd_elf_allocate_object.
   (is_i386_elf): New macro.  Checks a BFD to make sure that is an x86
   ELF bfd.
   (elf_i386_check_relocs): Use is_i386_elf macro to check    the bfd
   being processed.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   (elf_i386_check_relocs): Use elf_symtab_hdr.
   (elf_i386_gc_sweep_hook): Likewise.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   * elf32-ppc.c (ppc_elf_mkobject): Call bfd_elf_allocate_object.
   (elf_create_pointer_linker_section): Use is_ppc_elf_target to
   verify that the bfd before accessing target specific fields.
   (ppc_elf_check_relocs): Likewise.
   (elf_finish_pointer_linker_section): Likewise.
   (elf_create_pointer_linker_section): Use elf_symtab_hdr.
   (ppc_elf_check_relocs): Likewise.
   (ppc_elf_gc_sweep_hook): Likewise.
   (ppc_elf_tls_optimize): Likewise.
   (ppc_elf_size_dynamic_sections): Likewise.
   (ppc_elf_relax_section): Likewise.
   (ppc_elf_relocate_section): Likewise.
   * elf32-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf64-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf32-sh.c (sh_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sh_elf): New macro.  Checks a BFD to make sure that is an SH
   ELF bfd.
   (sh_elf_size_dynamic_sections): Use is_sh_elf macro to check the
   bfd being processed.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_check_relocs): Likewise.
   (sh_elf_copy_private_data): Likewise.
   (sh_elf_relax_section): Use elf_symtab_hdr.
   (sh_elf_size_dynamic_sections): Likewise.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_get_relocated_section_contents): Likewise.
   (sh_elf_gc_sweep_hook): Likewise.
   (sh_elf_check_relocs): Likewise.
   * elf64-alpha.c (elf64_alpha_mkobject): Call bfd_elf_allocate_object.
   (is_alpha_elf): New macro.  Checks a BFD to make sure that is an
   Alpha ELF bfd.
   (elf64_alpha_create_got_section): Use is_alpha_elf macro to check
   the bfd being processed.
   (elf64_alpha_create_dynamic_section): Likewise.
   (elf64_alpha_check_relocs): Likewise.
   (elf64_alpha_size_got_sections): Likewise.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   (elf64_alpha_final_link): Likewise.
   (elf64_alpha_check_relocs): Use elf_symtab_hdr.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section_r): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   * elf64-ppc.c (ppc64_elf_mkobject): Call bfd_elf_allocate_object.
   (ppc64_elf_check_relocs): Use is_ppc64_elf_target to check the bfd
   being processed.
   (opd_entry_value): Likewise.
   (allocate_dynrelocs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   (ppc64_elf_check_relocs): Use elf_symtab_hdr.
   (opd_entry_value): Likewise.
   (ppc64_elf_gc_sweep_hook): Likewise.
   (get_sym_h): Likewise.
   (ppc64_elf_edit_opd): Likewise.
   (ppc64_elf_tls_optimize): Likewise.
   (ppc64_elf_edit_toc): Likewise.
   (ppc64_elf_size_dynamic_sections): Likewise.
   (toc_adjusting_stub_needed): Likewise.
   (ppc64_elf_size_stubs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   * elf64-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf32-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf64-x86_64.c (elf64_x86_64_mkobject): Call bfd_elf_allocate_object.
   (is_x86_64_elf): New macro.  Checks a BFD to make sure that is an
   x86_64 ELF bfd.
   (elf64_x86_64_check_relocs): Use is_x86_64_elf macro to check the bfd
   being processed.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   (elf64_x86_64_check_relocs): Use elf_symtab_hdr.
   (elf64_x86_64_gc_sweep_hook): Likewise.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   * elfxx-sparc.c (_bfd_sparc_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sparc_elf): New macro.  Checks a BFD to make sure that is a Sparc
   ELF bfd.
   (_bfd_sparc_elf_check_relocs): Use is_sparc_elf macro to check the
   bfd being processed.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_check_relocs): Use elf_symtab_hdr.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d1249 2
a1250 2
		  const char *name;
		  bfd *dynobj;
d1252 1
a1252 5
		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
a1253 31

		  if (! CONST_STRNEQ (name, ".rela")
		      || strcmp (bfd_get_section_name (abfd, sec),
				 name + 5) != 0)
		    {
		      (*_bfd_error_handler)
			(_("%B: bad relocation section name `%s\'"),
			 abfd, name);
		    }

		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;

		  dynobj = htab->elf.dynobj;
		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      sreloc = bfd_make_section_with_flags (dynobj,
							    name,
							    flags);
		      if (sreloc == NULL
			  || ! bfd_set_section_alignment (dynobj, sreloc, 3))
			return FALSE;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
@


1.97
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d632 2
d638 1
a638 1
  /* tls_type for each local got entry.  */
d648 5
d656 2
a657 8
  if (abfd->tdata.any == NULL)
    {
      bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
      abfd->tdata.any = bfd_zalloc (abfd, amt);
      if (abfd->tdata.any == NULL)
	return FALSE;
    }
  return bfd_elf_mkobject (abfd);
d941 2
d944 1
a944 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d1403 1
a1403 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d1999 1
a1999 1
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
d2030 1
a2030 1
      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d2249 2
d2252 1
a2252 1
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
@


1.96
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d1395 3
@


1.95
log
@	* elf32-arm.c (elf32_arm_size_info): Init checksum_contents field.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (elf64_sparc_size_info): Likewise.
@
text
@d1347 3
a1349 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.94
log
@Switch sources over to use the GPL version 3
@
text
@d3416 1
@


1.93
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
@


1.92
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@a1559 1
  unsigned int power_of_two;
a1679 7
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
a1680 6
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
    {
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
	return FALSE;
    }
d1682 1
a1682 8
  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
@


1.91
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.90
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d359 21
d3472 1
@


1.89
log
@bfd/
	* libbfd-in.h (_bfd_clear_contents): New prototype.
	* reloc.c (_bfd_clear_contents): New.
	* libbfd.h: Regenerated.

	* elf32-arm.c (elf32_arm_final_link_relocate): Use
	_bfd_clear_contents.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set value to
	zero for discarded symbols.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
ld/testsuite/
	* ld-discard/zero-rel.d, ld-discard/zero-rel.s: New files.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006
a2240 3
  if (info->relocatable)
    return TRUE;

a2274 1
      /* This is a final link.  */
d2295 14
a2531 9
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	  if (r_symndx == 0)
	    {
	      _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	      break;
	    }

@


1.88
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d2525 7
a2531 2
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
@


1.87
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2614 7
a2620 1
			  BFD_ASSERT (sindx > 0);
a2626 1

d3457 1
@


1.86
log
@	* elf32-s390.c (elf_s390_relocate_section): Remove check for code
	section in LD to LE linker relaxation for R_390_TLS_LDO32.
	* elf64-s390.c (elf_s390_relocate_section): Likewise for
	R_390_TLS_LDO64.
@
text
@a48 6
static asection *elf_s390_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf_s390_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d1342 5
a1346 6
elf_s390_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d1349 6
a1354 13
    {
      switch (ELF64_R_TYPE (rel->r_info))
	{
	case R_390_GNU_VTINHERIT:
	case R_390_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;
d1356 1
a1356 12
	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
d1362 4
a1365 5
elf_s390_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
@


1.85
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d2912 1
a2912 1
	  if (info->shared || (input_section->flags & SEC_CODE) == 0)
@


1.84
log
@	PR ld/2754
	* elf.c (bfd_elf_mkobject): Don't alloc if already done.  Set
	program_header_size to -1.
	(_bfd_elf_map_sections_to_segments): Adjust program_header_size check.
	(assign_file_positions_for_load_sections ): Likewise.
	(_bfd_elf_sizeof_headers): Use saved program_header_size if
	available.
	* elf32-arm.c (elf32_arm_mkobject): Call bfd_elf_mkobject, don't
	alloc if already done.
	* elf32-i386.c (elf_i386_mkobject): Likewise.
	* elf32-ppc.c (ppc_elf_mkobject): Likewise.
	* elf32-s390.c (elf_s390_mkobject): Likewise.
	* elf32-sh.c (sh_elf_mkobject): Likewise.
	* elf64-alpha.c (elf64_alpha_mkobject): Likewise.
	* elf64-ppc.c (ppc64_elf_mkobject): Likewise.
	* elf64-s390.c (elf_s390_mkobject): Likewise.
	* elf64-x86-64.c (elf64_x86_64_mkobject): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_mkobject): Likewise.
@
text
@d1241 1
a1241 1
		  if (strncmp (name, ".rela", 5) != 0
d2101 1
a2101 1
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
@


1.83
log
@	* elf32-s390.c (invalid_tls_insn): Call bfd_set_error.
	(elf_s390_relocate_section): Add code to do the GD->LE and
	LD->LE TLS linker optimizations if a brasl instruction is used
	for the __tls_get_offset function call.
	* elf64-s390.c (invalid_tls_insn): Call bfd_set_error.
@
text
@a75 2
static bfd_boolean elf_s390_mkobject
  PARAMS ((bfd *));
d632 1
a632 2
elf_s390_mkobject (abfd)
     bfd *abfd;
a633 2
  bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
d635 7
a641 2
    return FALSE;
  return TRUE;
@


1.82
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d2243 1
@


1.81
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d727 2
a728 1
  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc))
@


1.80
log
@	PR ld/2218
	* elf32-arm.c (allocate_dynrelocs): Ensure undef weak sym in pie
	is dynamic.
	* elf32-hppa.c (allocate_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	* elf32-sh.c (allocate_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	* elf32-m32r.c (allocate_dynrelocs): Likewise.  Discard relocs
	on undef weak with non-default visibility too.
	* elfxx-sparc.c (allocate_dynrelocs): Ditto.
@
text
@d3255 2
a3256 2
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
      || strcmp (h->root.root.string, "_PROCEDURE_LINKAGE_TABLE_") == 0)
@


1.79
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005
d1884 1
a1884 1
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
d1886 13
a1898 1
	eh->dyn_relocs = NULL;
@


1.78
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d44 1
a44 1
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
d811 2
a812 2
elf_s390_copy_indirect_symbol (bed, dir, ind)
     const struct elf_backend_data *bed;
d827 1
a827 4
	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
d871 1
a871 1
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.77
log
@2005-08-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1208
	* elf-hppa.h (elf_hppa_relocate_section): Print out the name
	of unresolvable relocation.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d1288 2
d1295 2
a1296 2
		  head = ((struct elf_s390_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
d2014 1
a2014 4
	  for (p = *((struct elf_s390_dyn_relocs **)
		     &elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
@


1.76
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d3014 1
a3014 1
	  (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
d3018 1
@


1.75
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d1658 7
@


1.74
log
@	* libbfd-in.h (bfd_malloc2, bfd_realloc2, bfd_zmalloc2, bfd_alloc2,
	bfd_zalloc2): New prototypes.
	* bfd-in.h (HALF_BFD_SIZE_TYPE): Define.
	* libbfd.c (bfd_malloc2, bfd_realloc2, bfd_zmalloc2): New functions.
	* opncls.c (bfd_alloc2, bfd_zalloc2): New functions.
	* elf.c (bfd_elf_get_elf_syms, setup_group, assign_section_numbers,
	elf_map_symbols, map_sections_to_segments,
	assign_file_positions_for_segments, copy_private_bfd_data,
	swap_out_syms, _bfd_elf_slurp_version_tables): Use bfd_*alloc2
	where appropriate.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.

	* elf.c (_bfd_elf_print_private_bfd_data): Don't crash on bogus
	verdef or verneed section.
	(_bfd_elf_slurp_version_tables): Handle corrupt verdef and/or
	verneed sections gracefully.
	* elfxx-sparc.c (_bfd_sparc_elf_info_to_howto_ptr): Don't crash on
	bogus relocation values.
	* elf64-ppc.c (ppc64_elf_info_to_howto): Likewise.
	* elf64-s390.c (elf_s390_info_to_howto): Likewise.
	* elf32-s390.c (elf_s390_info_to_howto): Likewise.
	* elf64-x86-64.c (elf64_x86_64_info_to_howto): Likewise.
	* elfxx-ia64.c (lookup_howto): Likewise.
@
text
@d2079 2
a2080 1
	  || s == htab->sgotplt)
d2116 3
@


1.73
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d376 2
a377 1
  switch (ELF64_R_TYPE(dst->r_info))
d388 7
a394 2
      BFD_ASSERT (ELF64_R_TYPE(dst->r_info) < (unsigned int) R_390_max);
      cache_ptr->howto = &elf_howto_table[ELF64_R_TYPE(dst->r_info)];
@


1.72
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d948 6
a953 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.71
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d759 6
a764 1
  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
a765 4
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
a1249 1
		      sreloc = bfd_make_section (dynobj, name);
d1254 3
a1257 1
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
@


1.70
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
@


1.69
log
@Update the FSF address in the copyright/GPL notice
@
text
@d2098 1
a2098 1
	  _bfd_strip_section_from_output (info, s);
@


1.68
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@d21 1
a21 1
   02111-1307, USA.  */
@


1.67
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2 2
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1406 3
@


1.66
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d3029 3
a3031 2
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
@


1.65
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d1586 1
a1586 1
  if (h->weakdef != NULL)
d1588 4
a1591 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
d1593 1
a1593 1
	h->non_got_ref = h->weakdef->non_got_ref;
@


1.64
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d855 10
a864 9
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
d1032 1
a1032 1
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d1054 1
a1054 1
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d1166 1
a1166 1
	      h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d1204 1
a1204 2
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1210 1
a1210 2
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d1554 1
a1554 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d1558 2
a1559 2
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
d1569 1
a1569 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1593 1
a1593 3
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1609 1
a1609 1
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
d1615 1
a1615 1
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d1636 1
a1636 1
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d1659 1
a1659 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d1720 1
a1720 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d1744 1
a1744 1
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1763 1
a1763 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1770 1
a1770 1
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1803 1
a1803 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d1871 3
a1873 3
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1881 1
a1881 1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d2345 2
a2346 2
			  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d2532 3
a2534 5
		  && (h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
		  && (((h->elf_link_hash_flags
			& ELF_LINK_HASH_DEF_DYNAMIC) != 0
		       && (h->elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2571 1
a2571 2
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))
d2984 1
a2984 1
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d3134 1
a3134 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3170 2
a3171 2
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d3192 1
a3192 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
@


1.63
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d936 2
a937 2
	  (*_bfd_error_handler) (_("%s: bad symbol index: %d"),
				 bfd_archive_filename (abfd),
d1122 2
a1123 2
		    (_("%s: `%s' accessed both as normal and thread local symbol"),
		     bfd_archive_filename (abfd), h->root.root.string);
d1236 2
a1237 2
			(_("%s: bad relocation section name `%s\'"),
			 bfd_archive_filename (abfd), name);
d2204 3
a2206 3
    (_("%s(%s+0x%lx): invalid instruction for TLS relocation %s"),
     bfd_archive_filename (input_bfd),
     bfd_get_section_name (input_bfd, input_section),
d2992 3
a2994 3
	  (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	   bfd_archive_filename (input_bfd),
	   bfd_get_section_name (input_bfd, input_section),
d3042 2
a3043 3
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
@


1.62
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a422 1
  bfd_size_type sz;
d435 1
a435 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
@


1.61
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Define.
	* targets.c (BFD_JUMP_TABLE_DYNAMIC): Add
	NAME##_get_synthetic_symtab.
	(struct bfd_target): Add _bfd_get_synthetic_symtab.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Define.
	* elf-bfd.h (struct elf_backend_data): Add plt_sym_val and
	relplt_name fields.
	(_bfd_elf_get_synthetic_symtab): New prototype.
	* elfcode.h (elf_get_synthetic_symtab): Define.
	* elf.c (_bfd_elf_get_synthetic_symtab): New function.
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Define.
	(elf_backend_plt_sym_val, elf_backend_relplt_name): Define.
	(elfNN_bed): Add elf_backend_plt_sym_val and elf_backend_relplt_name.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-x86-64.c (elf64_x86_64_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-sparc (elf32_sparc_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-ppc.c (ppc_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* aout-target.h (MY_get_synthetic_symtab): Define.
	* aout-tic30.c (MY_get_synthetic_symtab): Define.
	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(aix5coff64_vec): Likewise.
	* sunos.c (MY_get_synthetic_symtab): Define.
	* vms.c (vms_get_synthetic_symtab): Define.
binutils/
	* objdump.c (synthsyms, synthcount): New variables.
	(disassemble_data): Use dynsyms for stripped binaries or libraries.
	Add synthetized symbols.
	(dump_bfd): For disassemble, initialize dynsyms always and
	also synthsyms.  Free synthsyms and clear {sym,dynsym,synth}count
	before returning.
@
text
@d423 1
d436 2
a437 1
  if (reloc_entry->address > input_section->_cooked_size)
d1663 1
a1663 1
      htab->srelbss->_raw_size += sizeof (Elf64_External_Rela);
d1675 1
a1675 1
  s->_raw_size = BFD_ALIGN (s->_raw_size, (bfd_size_type) (1 << power_of_two));
d1684 1
a1684 1
  h->root.u.def.value = s->_raw_size;
d1687 1
a1687 1
  s->_raw_size += h->size;
d1738 2
a1739 2
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_FIRST_ENTRY_SIZE;
d1741 1
a1741 1
	  h->plt.offset = s->_raw_size;
d1756 1
a1756 1
	  s->_raw_size += PLT_ENTRY_SIZE;
d1760 1
a1760 1
	  htab->sgotplt->_raw_size += GOT_ENTRY_SIZE;
d1763 1
a1763 1
	  htab->srelplt->_raw_size += sizeof (Elf64_External_Rela);
d1793 2
a1794 2
	  h->got.offset = htab->sgot->_raw_size;
	  htab->sgot->_raw_size += GOT_ENTRY_SIZE;
d1815 2
a1816 2
      h->got.offset = s->_raw_size;
      s->_raw_size += GOT_ENTRY_SIZE;
d1819 1
a1819 1
	s->_raw_size += GOT_ENTRY_SIZE;
d1825 1
a1825 1
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
d1827 1
a1827 1
	htab->srelgot->_raw_size += 2 * sizeof (Elf64_External_Rela);
d1832 1
a1832 1
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
d1907 1
a1907 1
      sreloc->_raw_size += p->count * sizeof (Elf64_External_Rela);
d1970 1
a1970 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d2009 1
a2009 1
		  srela->_raw_size += p->count * sizeof (Elf64_External_Rela);
d2030 2
a2031 2
	      *local_got = s->_raw_size;
	      s->_raw_size += GOT_ENTRY_SIZE;
d2033 1
a2033 1
		s->_raw_size += GOT_ENTRY_SIZE;
d2035 1
a2035 1
		srela->_raw_size += sizeof (Elf64_External_Rela);
d2046 3
a2048 3
      htab->tls_ldm_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
d2074 1
a2074 1
	  if (s->_raw_size != 0 && s != htab->srelplt)
d2087 1
a2087 1
      if (s->_raw_size == 0)
d2108 1
a2108 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d2129 1
a2129 1
      if (htab->splt->_raw_size != 0)
d3276 1
a3276 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d3299 1
a3299 4
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
d3311 1
a3311 4
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val -= s->_cooked_size;
	      else
		dyn.d_un.d_val -= s->_raw_size;
d3319 1
a3319 1
      if (htab->splt && htab->splt->_raw_size > 0)
d3350 1
a3350 1
      if (htab->sgotplt->_raw_size > 0)
@


1.60
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d3372 11
d3452 1
@


1.59
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d1312 1
a1312 1
	  if (!_bfd_elf64_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d1319 1
a1319 1
	  if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_addend))
a1689 11
/* This is the condition under which elf_s390_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf_s390_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d1725 1
a1725 1
	  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
d1808 1
a1808 1
	  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
d1886 1
a1886 1
	      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
@


1.58
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d2130 1
a2130 1
  bfd_elf64_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.57
log
@	* elf32-s390.c (allocate_dynrelocs): Use SYMBOL_REFERENCES_LOCAL
	for pc relative relocs.
	(elf_s390_relocate_section): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Use SYMBOL_REFERENCES_LOCAL
	for pc relative relocs.
	(elf_s390_relocate_section): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d2295 4
a2298 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
@


1.56
log
@	* elf32-i386.c (elf_i386_object_p): Delete.
	(elf_backend_object_p): Don't define.
	* elf32-s390.c (elf_s390_object_p): No need to alloc tdata here.
	* elf32-sh.c (sh_elf_object_p): Likewise.
	* elf32-sparc.c (elf32_sparc_object_p): Likewise.
	* elf64-alpha.c (elf64_alpha_object_p): Likewise.
	* elf64-s390.c (elf_s390_object_p): Likewise.
	* elf64-x86-64.c (elf64_x86_64_elf_object_p): Likewise.
@
text
@d1858 1
a1858 3
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
d2541 1
a2541 4
		       && h->dynindx != -1
		       && (! info->symbolic
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
@


1.56.6.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1312 1
a1312 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d1319 1
a1319 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d1690 11
d1736 1
a1736 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1819 1
a1819 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1899 1
a1899 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2132 1
a2132 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d2297 4
a2300 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.56.6.2
log
@Merge to 2.15 branch.
@
text
@d1847 3
a1849 1
      if (SYMBOL_REFERENCES_LOCAL (info, h))
d2532 4
a2535 1
		       && !SYMBOL_REFERENCES_LOCAL (info, h))))
@


1.56.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1858 3
a1860 1
      if (SYMBOL_REFERENCES_LOCAL (info, h))
d2132 1
a2132 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d2297 4
a2300 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d2543 4
a2546 1
		       && !SYMBOL_REFERENCES_LOCAL (info, h))))
@


1.56.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d1312 1
a1312 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d1319 1
a1319 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d1690 11
d1736 1
a1736 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1819 1
a1819 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1897 1
a1897 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
@


1.56.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d435 1
a435 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d936 2
a937 2
	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
				 abfd,
d1122 2
a1123 2
		    (_("%B: `%s' accessed both as normal and thread local symbol"),
		     abfd, h->root.root.string);
d1236 2
a1237 2
			(_("%B: bad relocation section name `%s\'"),
			 abfd, name);
d1661 1
a1661 1
      htab->srelbss->size += sizeof (Elf64_External_Rela);
d1673 1
a1673 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d1682 1
a1682 1
  h->root.u.def.value = s->size;
d1685 1
a1685 1
  s->size += h->size;
d1736 2
a1737 2
	  if (s->size == 0)
	    s->size += PLT_FIRST_ENTRY_SIZE;
d1739 1
a1739 1
	  h->plt.offset = s->size;
d1754 1
a1754 1
	  s->size += PLT_ENTRY_SIZE;
d1758 1
a1758 1
	  htab->sgotplt->size += GOT_ENTRY_SIZE;
d1761 1
a1761 1
	  htab->srelplt->size += sizeof (Elf64_External_Rela);
d1791 2
a1792 2
	  h->got.offset = htab->sgot->size;
	  htab->sgot->size += GOT_ENTRY_SIZE;
d1813 2
a1814 2
      h->got.offset = s->size;
      s->size += GOT_ENTRY_SIZE;
d1817 1
a1817 1
	s->size += GOT_ENTRY_SIZE;
d1823 1
a1823 1
	htab->srelgot->size += sizeof (Elf64_External_Rela);
d1825 1
a1825 1
	htab->srelgot->size += 2 * sizeof (Elf64_External_Rela);
d1830 1
a1830 1
	htab->srelgot->size += sizeof (Elf64_External_Rela);
d1905 1
a1905 1
      sreloc->size += p->count * sizeof (Elf64_External_Rela);
d1968 1
a1968 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d2007 1
a2007 1
		  srela->size += p->count * sizeof (Elf64_External_Rela);
d2028 2
a2029 2
	      *local_got = s->size;
	      s->size += GOT_ENTRY_SIZE;
d2031 1
a2031 1
		s->size += GOT_ENTRY_SIZE;
d2033 1
a2033 1
		srela->size += sizeof (Elf64_External_Rela);
d2044 3
a2046 3
      htab->tls_ldm_got.offset = htab->sgot->size;
      htab->sgot->size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->size += sizeof (Elf64_External_Rela);
d2072 1
a2072 1
	  if (s->size != 0 && s != htab->srelplt)
d2085 1
a2085 1
      if (s->size == 0)
d2106 1
a2106 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
d2127 1
a2127 1
      if (htab->splt->size != 0)
d2204 3
a2206 3
    (_("%B(%A+0x%lx): invalid instruction for TLS relocation %s"),
     input_bfd,
     input_section,
d2992 3
a2994 3
	  (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	   input_bfd,
	   input_section,
d3042 3
a3044 2
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
d3274 1
a3274 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
d3297 4
a3300 1
	      dyn.d_un.d_val = s->size;
d3312 4
a3315 1
	      dyn.d_un.d_val -= s->size;
d3323 1
a3323 1
      if (htab->splt && htab->splt->size > 0)
d3354 1
a3354 1
      if (htab->sgotplt->size > 0)
a3371 11
/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
elf_s390_plt_sym_val (bfd_vma i, const asection *plt,
		      const arelent *rel ATTRIBUTE_UNUSED)
{
  return plt->vma + PLT_FIRST_ENTRY_SIZE + i * PLT_ENTRY_SIZE;
}


a3440 1
#define elf_backend_plt_sym_val		      elf_s390_plt_sym_val
@


1.56.8.4
log
@Merge from mainline.
@
text
@d855 9
a863 10
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
    }
d1031 1
a1031 1
	      h->needs_plt = 1;
d1053 1
a1053 1
	      h->needs_plt = 1;
d1165 1
a1165 1
	      h->non_got_ref = 1;
d1203 2
a1204 1
			   || !h->def_regular))))
d1210 2
a1211 1
		      || !h->def_regular)))
d1555 1
a1555 1
      || h->needs_plt)
d1559 2
a1560 2
	      && !h->def_dynamic
	      && !h->ref_dynamic
d1570 1
a1570 1
	  h->needs_plt = 0;
d1587 1
a1587 1
  if (h->u.weakdef != NULL)
d1589 4
a1592 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d1594 3
a1596 1
	h->non_got_ref = h->u.weakdef->non_got_ref;
d1612 1
a1612 1
  if (!h->non_got_ref)
d1618 1
a1618 1
      h->non_got_ref = 0;
d1639 1
a1639 1
	  h->non_got_ref = 0;
d1662 1
a1662 1
      h->needs_copy = 1;
d1723 1
a1723 1
	  && !h->forced_local)
d1747 1
a1747 1
	      && !h->def_regular)
d1766 1
a1766 1
	  h->needs_plt = 0;
d1773 1
a1773 1
      h->needs_plt = 0;
d1806 1
a1806 1
	  && !h->forced_local)
d1874 3
a1876 3
      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
d1884 1
a1884 1
	      && !h->forced_local)
d2348 2
a2349 2
			  || h->forced_local)
		      && h->def_regular)
d2535 5
a2539 3
		  && !h->non_got_ref
		  && ((h->def_dynamic
		       && !h->def_regular)
d2576 2
a2577 1
			   || !h->def_regular))
d2990 1
a2990 1
	       && h->def_dynamic))
d3140 1
a3140 1
      if (!h->def_regular)
d3176 2
a3177 2
	      || h->forced_local)
	  && h->def_regular)
d3198 1
a3198 1
  if (h->needs_copy)
@


1.55
log
@	* elf32-s390.c (elf_s390_relocate_section): Don't recalculate symbol
	section for reloc output and subtract the output section's address
	from the addend when converting a relocation into one against a
	section symbol.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
@
text
@a640 8
  /* Allocate our special target data.  */
  struct elf_s390_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return FALSE;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;
@


1.54
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Copy
	ELF_LINK_HASH_NEEDS_PLT.  Fix formatting.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elf32-xtensa.c (elf_xtensa_copy_indirect_symbol): Remove.
	(elf_backend_copy_indirect_symbol): Don't define.
@
text
@d2609 1
a2613 1
		      outrel.r_addend = relocation + rel->r_addend;
d2619 1
a2619 10
		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
		      if (sec != NULL && bfd_is_abs_section (sec))
d2633 8
a2642 1
		      outrel.r_addend = relocation + rel->r_addend;
@


1.53
log
@	* elf32-s390.c (elf_s390_relocate_section): Only convert R_390_32
	to R_390_RELAVITE. Convert the other relocations against local
	symbols to relocations against the start of the section.
	* elf64-s390.c (elf_s390_relocate_section): Only convert R_390_64
	to R_390_RELAVITE. Convert the other relocations against local
	symbols to relocations against the start of the section.
@
text
@d870 2
a871 1
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
@


1.52
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d2608 37
a2644 3
		  relocate = TRUE;
		  outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
		  outrel.r_addend = relocation + rel->r_addend;
@


1.51
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d2298 1
a2298 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.50
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d2189 2
a2190 2
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
d2192 1
a2192 1
  return elf_hash_table (info)->tls_segment->start;
d2203 1
a2203 2
  struct elf_link_tls_segment *tls_segment
    = elf_hash_table (info)->tls_segment;
d2205 2
a2206 2
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (tls_segment == NULL)
d2208 1
a2208 2
  return (align_power (tls_segment->size, tls_segment->align)
	  + tls_segment->start - address);
@


1.49
log
@Better handking for unresolved symbols
@
text
@a3413 1
#define elf_backend_plt_header_size	PLT_ENTRY_SIZE
@


1.48
log
@	* elf32-i386.c (elf_i386_relocate_section): Make undefined symbols
	fatal if -pie.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(ppc_elf_relocate_section) <case R_PPC_RELAX32>: Issue fatal error
	on undefined symbols if -pie.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
@
text
@d2304 1
a2304 4
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d2306 4
a2309 34
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      if (sec->output_section == NULL)
		{
		  /* Set a flag that will be cleared later if we find a
		     relocation value for this symbol.  output_section
		     is typically NULL for symbols satisfied by a shared
		     library.  */
		  unresolved_reloc = TRUE;
		  relocation = 0;
		}
	      else
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else if (!info->executable
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset,
		      (info->executable || info->no_undefined
		       || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	      relocation = 0;
	    }
@


1.47
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d2338 1
a2338 1
		      (!info->shared || info->no_undefined
@


1.46
log
@	* elf32-s390.c (elf_howto_table): Change R_390_GOT12 to
	complain_overflow_bitfield.
	* elf64-s390.c (elf_howto_table): Change R_390_GOT12 to
	complain_overflow_bitfield.
@
text
@d43 1
a43 1
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
d812 1
a812 1
     struct elf_backend_data *bed;
@


1.45
log
@bfd/
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add rel_fptr_sec.
	(elfNN_ia64_dynamic_symbol_p): Change info->shared into
	!info->executable.
	(get_fptr): For -pie create .opd as writable section and create
	.rela.opd as well.
	(elfNN_ia64_check_relocs): Change info->shared into
	!info->executable.
	(allocate_fptr): Likewise.
	(allocate_dynrel_entries): Account for a relative reloc for -pie
	@@fptr().  Don't account for a relative reloc if -pie want_ltoff_fptr
	for undefweak symbol.  Account for an IPLT reloc in .rela.opd
	section if -pie.
	(set_got_entry): Don't create a relative reloc if -pie
	want_ltoff_fptr for undefweak symbol.
	(set_fptr_entry): Emit an IPLT reloc in .rela.opd for -pie.
	(elfNN_ia64_relocate_section): Emit a relative reloc for -pie
	@@fptr().

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Issue undefined_symbol
	even if -pie.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
ld/
	* emulparams/elf64_ia64.sh (OTHER_READONLY_SECTIONS): Don't include
	.opd if -pie.
	(OTHER_READWRITE_SECTIONS): Include .opd if -pie.
	* scripttempl/elf.sc: Use SHLIB_DATA_ADDR instead of DATA_ADDR
	if -pie.
@
text
@d125 1
a125 1
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_dont,
@


1.44
log
@        * elf32-s390.c (s390_elf_ldisp_reloc): New prototype.
        (s390_tls_reloc): New function.
        (elf_howto_table): Add long displacement relocations R_390_20,
        R_390_GOT20, R_390_GOTPLT20 and R_390_TLS_GOTIE20.
        (elf_s390_reloc_type_lookup): Likewise.
        (elf_s390_check_relocs): Likewise.
        (elf_s390_gc_sweep_hook): Likewise.
        (elf_s390_relocate_section): Likewise.
        * elf64-s390.c: Same changes as for elf32-s390.c.
        * reloc.c: Add long displacement relocations BFD_RELOC_390_20,
        BFD_RELOC_390_GOT20, BFD_RELOC_390_GOTPLT20 and
        BFD_RELOC_390_TLS_GOTIE20.
        * bfd-in2.h: Regenerate.
        * libbfd.h: Likewise.
@
text
@d2329 1
a2329 1
	  else if (info->shared
@


1.43
log
@Correct spelling of "relocatable".
@
text
@d89 2
d221 8
d348 8
d408 52
d963 1
d969 1
d975 1
d1045 1
d1073 1
d1082 1
d1093 1
d1106 1
d1436 1
d1441 1
d1465 1
d1493 1
d2349 1
d2384 1
d2800 1
d3024 13
a3036 1
      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
@


1.42
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Use !info->executable
	instead of info->shared where appropriate.
	(bfd_elfNN_size_dynamic_sections, elf_link_output_extsym): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-ppc.c (ppc64_elf_size_dynamic_sections: Likewise.
	* elf64-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections: Likewise.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections: Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections: Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections: Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections: Likewise.
include/
	* bfdlink.h (struct bfd_link_info): Add pie and executable
	bits.
ld/
	* lexsup.c (OPTION_PIE): Define.
	(ld_options): Add -pie and --pic-executable options.
	(parse_args): Handle OPTION_PIE.
	* ldmain.c (main): Initialize link_info.pie and
	link_info.executable.
	* genscripts.sh: Generate PIE scripts.
	* ld.texinfo: Document -pie and --pic-executable options.
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open):
	(gld${EMULATION_NAME}_place_orphan): Likewise.
	(gld${EMULATION_NAME}_get_script): Include PIE scripts.
	* scripttempl/elf.sc: In PIE scripts set . the same way as in
	shared scripts.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Set to yes.
	* emulparams/elf64_ia64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_x86_64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64alpha.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Likewise.
@
text
@d852 1
a852 1
  if (info->relocateable)
d2172 1
a2172 1
  if (info->relocateable)
@


1.41
log
@	* elf32-s390.c (allocate_dynrelocs, elf_s390_relocate_section):
	Fix WILL_CALL_FINISH_DYNAMIC_SYMBOL call.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Pass SHARED instead of INFO.
	* elf64-s390.c: Likewise.
@
text
@d1901 1
a1901 1
      if (! info->shared)
d2059 1
a2059 1
      if (! info->shared)
@


1.40
log
@	* elf32-s390.c (ELIMINATE_COPY_RELOCS): Define as one.
	(elf_s390_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
	(elf_s390_copy_indirect_symbol): Test whether the weakdef sym has
	already been adjusted before treating it specially.
	* el64-s390.c: Likwise.
@
text
@d1619 1
a1619 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
d1621 1
a1621 1
   && ((INFO)->shared							\
d1666 1
a1666 1
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d2315 1
a2315 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
@


1.39
log
@        * elf32-s390.c (allocate_dynrelocs): For undef weak syms with
	non-default visibility, a) don't make them dynamic, b) discard
	space for dynamic relocs.
	(elf_s390_relocate_section): Initialize the GOT entries and skip
	R_390_{8,16,32}/R_390_PC{16,16DBL,32DBL,32} for weak undefined
	symbols with non-default visibility.
	* elf64-s390.c: Likewise.
@
text
@d408 6
d791 12
a802 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1134 2
a1135 1
	      || (!info->shared
a1472 2
  struct elf_s390_link_hash_entry * eh;
  struct elf_s390_dyn_relocs *p;
d1518 4
d1547 1
a1547 2
  eh = (struct elf_s390_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
d1549 10
a1558 4
      s = p->sec->output_section;
      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	break;
    }
d1560 7
a1566 6
  /* If we didn't find any dynamic relocs in read-only sections, then
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return TRUE;
d1806 1
a1806 1
  else
d2505 2
a2506 1
	      || (!info->shared
@


1.38
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d1626 3
a1628 1
      && h->plt.refcount > 0)
d1639 2
a1640 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d1736 4
a1739 1
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d1773 6
d2294 3
a2296 1
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d2466 3
@


1.37
log
@	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Simplify dynamic reloc
	removal.  Localize vars.  Remove unnecessary dynobj test.
	* elf32-i386 (WILL_CALL_FINISH_DYNAMIC_SYMBOL): Pass SHARED instead
	of INFO.
	(allocate_dynrelocs): Adjust WILL_CALL_FINISH_DYNAMIC_SYMBOL uses,
	and optimize.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_gc_sweep_hook): Simplify dyn reloc removal.  Localize vars.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.  Remove
	local_dynrel for section too.  Don't touch HIPLT22, LOPLT10, PCPLT32
	or PCPLT10 relocs.  Don't subtract twice on PLT32 relocs.
	Formatting.
@
text
@d3274 1
a3274 1
  8,		/* file_align.  */
@


1.37.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@a407 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d785 1
a785 12
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1117 1
a1117 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1455 2
a1501 4
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1527 2
a1528 1
  if (ELIMINATE_COPY_RELOCS)
d1530 4
a1533 2
      struct elf_s390_link_hash_entry * eh;
      struct elf_s390_dyn_relocs *p;
d1535 6
a1540 15
      eh = (struct elf_s390_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1593 1
a1593 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d1595 1
a1595 1
   && ((SHARED)								\
d1626 1
a1626 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d1637 1
a1637 2
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d1733 1
a1733 4
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
a1766 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d1768 1
a1768 1
  else if (ELIMINATE_COPY_RELOCS)
d2277 1
a2277 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d2282 1
a2282 3
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
a2451 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d2462 1
a2462 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d3274 1
a3274 1
  3,		/* log_file_align.  */
@


1.37.18.1
log
@	Merge from mainline:

	2003-05-09  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* elf32-s390.c (ELIMINATE_COPY_RELOCS): Define as one.
	(elf_s390_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
	(elf_s390_copy_indirect_symbol): Test whether the weakdef sym has
	already been adjusted before treating it specially.
	* el64-s390.c: Likwise.

	2003-05-08  H.J. Lu <hongjiu.lu@@intel.com>
	* elflink.h (elf_add_default_symbol): After skipping the
	unversioned symbol, go to non-default one.

	2003-05-07  H.J. Lu <hongjiu.lu@@intel.com>
	* elflink.h (elf_link_check_versioned_symbol): Also handle the
	case that a DSO references a hidden symbol which may be
	satisfied by a versioned symbol in another DSO.
	(elf_link_output_extsym): Check versioned definition for hidden
	symbol referenced by a DSO.

	2003-05-06  Alexandre Oliva  <aoliva@@redhat.com>
	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Improve
	error message for mixing different-endian files.  Check for ABI
	compatibility of input files with the selected emulation.
@
text
@a407 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d785 1
a785 12
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1117 1
a1117 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1455 2
a1501 4
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1527 2
a1528 1
  if (ELIMINATE_COPY_RELOCS)
d1530 4
a1533 2
      struct elf_s390_link_hash_entry * eh;
      struct elf_s390_dyn_relocs *p;
d1535 6
a1540 15
      eh = (struct elf_s390_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1768 1
a1768 1
  else if (ELIMINATE_COPY_RELOCS)
d2462 1
a2462 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
@


1.36
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@d376 1
a376 1
                      output_bfd, error_message)
d989 1
a989 1
        case R_390_GOT16:
a1294 3
  unsigned long r_symndx;
  int r_type;
  struct elf_link_hash_entry *h;
d1305 4
d1310 8
d1319 8
a1326 4
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d1328 2
a1329 3
      r_type = elf_s390_tls_transition (info,
					ELF64_R_TYPE (rel->r_info),
					r_symndx >= symtab_hdr->sh_info);
d1362 1
a1362 8
	  if (r_type != R_390_TLS_IE64)
	    break;
	  /* Fall through */
	  
	case R_390_TLS_LE64:
	  if (!info->shared)
	    break;
	  /* Fall through */
d1374 3
a1376 27
	  if (h != NULL)
	    {
	      struct elf_s390_link_hash_entry *eh;
	      struct elf_s390_dyn_relocs **pp;
	      struct elf_s390_dyn_relocs *p;
	      
	      if (!info->shared && h->plt.refcount > 0)
		h->plt.refcount -= 1;
	      
	      eh = (struct elf_s390_link_hash_entry *) h;
	      
	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    if (ELF64_R_TYPE (rel->r_info) == R_390_PC16
			|| ELF64_R_TYPE (rel->r_info) == R_390_PC16DBL
			|| ELF64_R_TYPE (rel->r_info) == R_390_PC32
			|| ELF64_R_TYPE (rel->r_info) == R_390_PC32DBL
			|| ELF64_R_TYPE (rel->r_info) == R_390_PC64)
		      p->pc_count -= 1;
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	    }
	  break;
d2249 1
a2249 1
	      
d2256 1
a2256 1
		relocation += htab->sgot->output_section->vma;	    
d2410 1
a2410 1
          break;
d2415 2
a2416 2
          /* Relocation is to the entry for this symbol in the
             procedure linkage table relative to the start of the GOT.  */
d2420 1
a2420 1
          if (   h == NULL
d2428 3
a2430 3
          relocation = (htab->splt->output_section->vma
                        + htab->splt->output_offset
                        + h->plt.offset
d2601 1
a2601 1
          else
d2736 1
a2736 1
	  unresolved_reloc = FALSE;	  
@


1.35
log
@	* bfd-in2.h: Regenerate.
	* elf32-s390.c (elf_s390_mkobject, elf_s390_tls_transition,
	s390_tls_reloc, dtpoff_base, tpoff, invalid_tls_insn): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_s390_reloc_type_lookup): Likewise.
	(elf_s390_link_hash_entry): Add tls_type.
	(elf_s390_hash_entry, elf_s390_obj_tdata, elf_s390_local_got_tls_type):
	New macros.
	(elf_s390_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Initialize tls_type.
	(elf_s390_link_hash_table_create): Initialize refcount of tls_ldm_got.
	(elf_s390_copy_indirect_symbol): Copy tls_type information.
	(elf_s390_check_relocs): Support TLS relocs.
	(elf_s390_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	(elf_s390_relocate_section): Likewise.
	(elf_s390_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject): Define for TLS.
	* elf64-s390.c: Same changes as for elf32-s390.c.
	* libbfd.h: Regenerate.
	* reloc.c: Add s390 TLS relocations.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
a2228 1
		   && (!info->symbolic || info->allow_shlib_undefined)
d2373 4
a2376 6
	  /*
	   * For @@GOTENT the relocation is against the offset between
	   * the instruction and the symbols entry in the GOT and not
	   * between the start of the GOT and the symbols entry. We
	   * add the vma of the GOT to get the correct value.
	   */
a2499 1

d2576 1
a2576 1
	  /* Fall through */
a3065 1

d3276 3
a3278 5
/*
 * Why was the hash table entry size definition changed from
 * ARCH_SIZE/8 to 4? This breaks the 64 bit dynamic linker and
 * this is the only reason for the s390_elf64_size_info structure.
 */
d3290 4
a3293 4
  8,		/* hash-table entry size */
  1,		/* internal relocations per external relocations */
  64,		/* arch_size */
  8,		/* file_align */
@


1.34
log
@	* bfd-in2.h: Regenerate.
	* elf32-s390.c (elf_s390_adjust_gotplt): New prototype.
	(elf_howto_table): Rename R_390_GOTOFF to R_390_GOTOFF32. Add
	R_390_GOTOFF16, R_390_GOTOFF64, R_390_GOTPLT12, R_390_GOTPLT16,
	R_390_GOTPLT32, R_390_GOTPLT64, R_390_GOTPLTENT, R_390_PLTOFF16,
	R_390_PLTOFF32 and R_390_PLTOFF64.
	(elf_s390_reloc_type_lookup): Likewise.
	(struct elf_s390_link_hash_entry): Add gotplt_refcount to keep track
	of GOTPLT references to a function.
	(link_hash_newfunc): Initialize gotplt_refcount.
	(elf_s390_check_relocs): Move allocation of local_got_refcounts array
	and creation of the got section out of the main switch. Add support
	for the gotoff, gotplt and pltoff relocations.
	(elf_s390_gc_sweep_hook): Add reference counting for gotoff, gotplt
	and pltoff.
	(elf_s390_adjust_gotplt): New function.
	(elf_s390_adjust_dynamic_symbol): Adjust gotplt refcount for removed
	plt entries.
	(allocate_dynrelocs): Add comment.
	(elf_s390_relocate_section): Change r_type to unsigned. Add support
	for gotoff, gotplt and pltoff relocations.
	* elf64-s390.c: Same changes as for elf32-s390.c.
	* libbfd.h: Regenerate.
	* reloc.c: Add BFD_RELOC_390_GOTOFF64, BFD_RELOC_390_GOTPLT12,
	BFD_RELOC_390_GOTPLT16, BFD_RELOC_390_GOTPLT32, BFD_RELOC_390_GOTPLT64,
	BFD_RELOC_390_GOTPLTENT, BFD_RELOC_390_PLTOFF16, BFD_RELOC_390_PLTOFF32
	and BFD_RELOC_390_PLTOFF64.
@
text
@d75 2
d79 10
d185 34
d310 28
d373 17
d524 7
d533 44
d592 5
d633 1
d665 1
d778 7
d788 27
d833 1
d848 1
d869 4
a872 1
      switch (ELF64_R_TYPE (rel->r_info))
d884 6
d896 1
a896 1
	      size *= sizeof (bfd_signed_vma);
d902 2
d920 1
a920 1
      switch (ELF64_R_TYPE (rel->r_info))
a921 16
	case R_390_GOT12:
        case R_390_GOT16:
	case R_390_GOT32:
	case R_390_GOT64:
	case R_390_GOTENT:
	  /* This symbol requires a global offset table entry.  */
	  if (h != NULL)
	    {
	      h->got.refcount += 1;
	    }
	  else
	    {
	      local_got_refcounts[r_symndx] += 1;
	    }
	  /* Fall through */

d973 50
d1025 1
d1027 32
a1058 1
	  break;
d1296 1
d1315 4
a1318 1
      switch (ELF64_R_TYPE (rel->r_info))
d1320 10
d1350 3
a1352 1
	  break;
d1354 4
a1357 33
	case R_390_PLT16DBL:
	case R_390_PLT32:
	case R_390_PLT32DBL:
	case R_390_PLT64:
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	case R_390_PLTOFF64:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;

	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		{
		  ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount--;
		  h->plt.refcount -= 1;
		}
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d1397 34
d1703 21
a1723 1
  if (h->got.refcount > 0)
d1727 1
d1741 3
d1745 8
a1752 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d1898 1
d1940 1
d1943 1
a1943 1
      for (; local_got < end_local_got; ++local_got)
d1949 2
d1959 11
d2080 52
d2175 1
d2561 340
d3060 4
a3063 1
  if (h->got.offset != (bfd_vma) -1)
a3280 7
static bfd_boolean
elf_s390_object_p (abfd)
     bfd *abfd;
{
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_64);
}

d3354 2
a3355 1
#define elf_backend_object_p		      elf_s390_object_p
@


1.33
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d54 3
d75 2
a76 1
static bfd_boolean elf_s390_object_p PARAMS ((bfd *));
d101 72
a172 26
  HOWTO(R_390_8,         0, 0,  8, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_8",       FALSE, 0,0x000000ff, FALSE),
  HOWTO(R_390_12,        0, 1, 12, FALSE, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_12",      FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_16,        0, 1, 16, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_16",      FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_32,        0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_32",      FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PC32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32",    FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_GOT12",   FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT32",   FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLT32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32",   FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_COPY,      0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_COPY",    FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_GLOB_DAT,  0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GLOB_DAT",FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_JMP_SLOT,  0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_JMP_SLOT",FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_RELATIVE,  0, 4, 64,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_RELATIVE",FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_GOTOFF,    0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTOFF",  FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_GOTPC,     0, 4, 64,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPC",   FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOT16,     0, 1, 16, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT16",   FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PC16,      0, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16",    FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16DBL", FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT16DBL", FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32DBL", FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32DBL", FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPCDBL", FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_64,        0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_64",      FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_PC64,	 0, 4, 64,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC64",    FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOT64,	 0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT64",   FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_PLT64,	 0, 4, 64,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT64",   FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOTENT,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTENT",   FALSE, 0,MINUS_ONE,  TRUE),
d217 1
a217 1
      return &elf_howto_table[(int) R_390_GOTOFF];
a227 4
    case BFD_RELOC_VTABLE_INHERIT:
      return &elf64_s390_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf64_s390_vtentry_howto;
d244 24
d430 3
d485 1
d649 1
d657 1
d682 2
d691 40
a737 16
	      bfd_signed_vma *local_got_refcounts;

	      /* This is a global offset table entry for a local symbol.  */
	      local_got_refcounts = elf_local_got_refcounts (abfd);
	      if (local_got_refcounts == NULL)
		{
		  bfd_size_type size;

		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_signed_vma);
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		}
d742 3
a744 1
	case R_390_GOTOFF:
d747 1
a747 7
	  if (htab->sgot == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!create_got_section (htab->elf.dynobj, info))
		return FALSE;
	    }
d754 3
d766 6
a771 2
	  if (h == NULL)
	    continue;
d773 23
a795 2
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	  h->plt.refcount += 1;
d1044 2
a1045 23
    switch (ELF64_R_TYPE (rel->r_info))
      {
      case R_390_GOT12:
      case R_390_GOT16:
      case R_390_GOT32:
      case R_390_GOT64:
      case R_390_GOTOFF:
      case R_390_GOTPC:
      case R_390_GOTPCDBL:
      case R_390_GOTENT:
	r_symndx = ELF64_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;
d1047 4
a1050 18
      case R_390_8:
      case R_390_12:
      case R_390_16:
      case R_390_32:
      case R_390_64:
      case R_390_PC16:
      case R_390_PC16DBL:
      case R_390_PC32:
      case R_390_PC32DBL:
      case R_390_PC64:
	r_symndx = ELF64_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf_s390_link_hash_entry *eh;
	    struct elf_s390_dyn_relocs **pp;
	    struct elf_s390_dyn_relocs *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d1052 37
a1088 2
	    if (!info->shared && h->plt.refcount > 0)
	      h->plt.refcount -= 1;
d1090 8
a1097 4
	    eh = (struct elf_s390_link_hash_entry *) h;

	    for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	      if (p->sec == sec)
d1099 2
a1100 8
		  if (ELF64_R_TYPE (rel->r_info) == R_390_PC16
		      || ELF64_R_TYPE (rel->r_info) == R_390_PC16DBL
		      || ELF64_R_TYPE (rel->r_info) == R_390_PC32)
		    p->pc_count -= 1;
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
d1102 7
a1108 2
	  }
	break;
d1110 37
a1146 12
      case R_390_PLT16DBL:
      case R_390_PLT32:
      case R_390_PLT32DBL:
      case R_390_PLT64:
	r_symndx = ELF64_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	break;
d1148 4
a1151 3
      default:
	break;
      }
d1156 23
d1216 1
d1353 3
d1410 1
d1417 1
d1784 1
a1784 1
      int r_type;
d1799 1
a1799 1
      if (r_type < 0 || r_type >= (int) R_390_max)
d1807 2
d1865 34
d1998 2
a1999 1
	  if (r_type == R_390_GOTENT)
d2004 3
a2006 1
	case R_390_GOTOFF:
a2015 1

d2049 23
@


1.32
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d32 1
a32 1
static boolean elf_s390_is_local_label_name
d38 1
a38 1
static boolean create_got_section
d40 1
a40 1
static boolean elf_s390_create_dynamic_sections
d45 1
a45 1
static boolean elf_s390_check_relocs
d51 1
a51 1
static boolean elf_s390_gc_sweep_hook
d54 1
a54 1
static boolean elf_s390_adjust_dynamic_symbol
d56 1
a56 1
static boolean allocate_dynrelocs
d58 1
a58 1
static boolean readonly_dynrelocs
d60 1
a60 1
static boolean elf_s390_size_dynamic_sections
d62 1
a62 1
static boolean elf_s390_relocate_section
d65 1
a65 1
static boolean elf_s390_finish_dynamic_symbol
d70 1
a70 1
static boolean elf_s390_finish_dynamic_sections
d72 1
a72 1
static boolean elf_s390_object_p PARAMS ((bfd *));
d87 1
a87 1
	 false,			/* pc_relative */
d92 1
a92 1
	 false,			/* partial_inplace */
d95 1
a95 1
	 false),		/* pcrel_offset */
d97 26
a122 26
  HOWTO(R_390_8,         0, 0,  8, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_8",       false, 0,0x000000ff, false),
  HOWTO(R_390_12,        0, 1, 12, false, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_12",      false, 0,0x00000fff, false),
  HOWTO(R_390_16,        0, 1, 16, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_16",      false, 0,0x0000ffff, false),
  HOWTO(R_390_32,        0, 2, 32, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_32",      false, 0,0xffffffff, false),
  HOWTO(R_390_PC32,	 0, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32",    false, 0,0xffffffff,  true),
  HOWTO(R_390_GOT12,	 0, 1, 12, false, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_GOT12",   false, 0,0x00000fff, false),
  HOWTO(R_390_GOT32,	 0, 2, 32, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT32",   false, 0,0xffffffff, false),
  HOWTO(R_390_PLT32,	 0, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32",   false, 0,0xffffffff,  true),
  HOWTO(R_390_COPY,      0, 4, 64, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_COPY",    false, 0,MINUS_ONE, false),
  HOWTO(R_390_GLOB_DAT,  0, 4, 64, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GLOB_DAT",false, 0,MINUS_ONE, false),
  HOWTO(R_390_JMP_SLOT,  0, 4, 64, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_JMP_SLOT",false, 0,MINUS_ONE, false),
  HOWTO(R_390_RELATIVE,  0, 4, 64,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_RELATIVE",false, 0,MINUS_ONE, false),
  HOWTO(R_390_GOTOFF,    0, 4, 64, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTOFF",  false, 0,MINUS_ONE, false),
  HOWTO(R_390_GOTPC,     0, 4, 64,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPC",   false, 0,MINUS_ONE,  true),
  HOWTO(R_390_GOT16,     0, 1, 16, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT16",   false, 0,0x0000ffff, false),
  HOWTO(R_390_PC16,      0, 1, 16,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16",    false, 0,0x0000ffff,  true),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16DBL", false, 0,0x0000ffff,  true),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT16DBL", false, 0,0x0000ffff,  true),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32DBL", false, 0,0xffffffff,  true),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32DBL", false, 0,0xffffffff,  true),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPCDBL", false, 0,MINUS_ONE,  true),
  HOWTO(R_390_64,        0, 4, 64, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_64",      false, 0,MINUS_ONE, false),
  HOWTO(R_390_PC64,	 0, 4, 64,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC64",    false, 0,MINUS_ONE,  true),
  HOWTO(R_390_GOT64,	 0, 4, 64, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT64",   false, 0,MINUS_ONE, false),
  HOWTO(R_390_PLT64,	 0, 4, 64,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT64",   false, 0,MINUS_ONE,  true),
  HOWTO(R_390_GOTENT,	 1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTENT",   false, 0,MINUS_ONE,  true),
d127 1
a127 1
  HOWTO (R_390_GNU_VTINHERIT, 0,4,0,false,0,complain_overflow_dont, NULL, "R_390_GNU_VTINHERIT", false,0, 0, false);
d129 1
a129 1
  HOWTO (R_390_GNU_VTENTRY, 0,4,0,false,0,complain_overflow_dont, _bfd_elf_rel_vtable_reloc_fn,"R_390_GNU_VTENTRY", false,0,0, false);
d229 1
a229 1
static boolean
d235 1
a235 1
    return true;
d451 1
a451 1
static boolean
d459 1
a459 1
    return false;
d474 2
a475 2
    return false;
  return true;
d482 1
a482 1
static boolean
d491 1
a491 1
    return false;
d494 1
a494 1
    return false;
d506 1
a506 1
  return true;
d562 1
a562 1
static boolean
d577 1
a577 1
    return true;
d598 1
a598 1
	  return false;
d633 1
a633 1
		    return false;
d648 1
a648 1
		return false;
d752 1
a752 1
		    return false;
d780 1
a780 1
			return false;
d801 1
a801 1
		    return false;
d814 1
a814 1
		    return false;
d836 1
a836 1
	    return false;
d843 1
a843 1
	    return false;
d851 1
a851 1
  return true;
d896 1
a896 1
static boolean
d998 1
a998 1
  return true;
d1007 1
a1007 1
static boolean
d1040 1
a1040 1
      return true;
d1059 1
a1059 1
      return true;
d1070 1
a1070 1
    return true;
d1075 1
a1075 1
    return true;
d1081 1
a1081 1
      return true;
d1097 1
a1097 1
      return true;
d1133 1
a1133 1
	return false;
d1143 1
a1143 1
  return true;
d1160 1
a1160 1
static boolean
d1171 1
a1171 1
    return true;
d1188 1
a1188 1
	    return false;
d1239 1
a1239 1
      boolean dyn;
d1247 1
a1247 1
	    return false;
d1262 1
a1262 1
    return true;
d1308 1
a1308 1
		return false;
d1329 1
a1329 1
  return true;
d1334 1
a1334 1
static boolean
d1357 1
a1357 1
	  return false;
d1360 1
a1360 1
  return true;
d1365 1
a1365 1
static boolean
d1373 1
a1373 1
  boolean relocs;
d1463 1
a1463 1
  relocs = false;
d1479 1
a1479 1
	    relocs = true;
d1514 1
a1514 1
	return false;
d1530 1
a1530 1
	    return false;
d1539 1
a1539 1
	    return false;
d1547 1
a1547 1
	    return false;
d1558 1
a1558 1
		return false;
d1564 1
a1564 1
  return true;
d1569 1
a1569 1
static boolean
d1589 1
a1589 1
    return true;
d1608 1
a1608 1
      boolean unresolved_reloc;
d1618 1
a1618 1
	  return false;
d1626 1
a1626 1
      unresolved_reloc = false;
d1650 1
a1650 1
		  unresolved_reloc = true;
d1672 1
a1672 1
		return false;
d1691 1
a1691 1
	      boolean dyn;
d1724 1
a1724 1
		unresolved_reloc = false;
d1800 1
a1800 1
	  unresolved_reloc = false;
d1827 1
a1827 1
	  unresolved_reloc = false;
d1869 1
a1869 1
	      boolean skip, relocate;
d1877 2
a1878 2
	      skip = false;
	      relocate = false;
d1884 1
a1884 1
		skip = true;
d1886 1
a1886 1
		skip = true, relocate = true;
d1911 1
a1911 1
		  relocate = true;
d1967 1
a1967 1
		return false;
d1978 1
a1978 1
		return false;
d1987 1
a1987 1
	      return false;
d1992 1
a1992 1
  return true;
d1998 1
a1998 1
static boolean
d2167 1
a2167 1
  return true;
d2192 1
a2192 1
static boolean
d2308 1
a2308 1
  return true;
d2311 1
a2311 1
static boolean
@


1.31
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d609 1
a609 1
        case R_390_GOT16:
d652 1
a652 1
        case R_390_PLT16DBL:
d657 5
a661 5
             actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code which is
             never referenced by a dynamic object, in which case we
             don't need to generate a procedure linkage table entry
             after all.  */
d664 1
a664 1
             creating a procedure linkage table entry.  */
d672 2
a673 2
        case R_390_8:
        case R_390_16:
d676 2
a677 2
        case R_390_PC16:
        case R_390_PC16DBL:
d834 4
a837 4
        case R_390_GNU_VTINHERIT:
          if (!_bfd_elf64_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return false;
          break;
d841 4
a844 4
        case R_390_GNU_VTENTRY:
          if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return false;
          break;
d1032 2
a1033 2
             file, but the symbol was never referred to by a dynamic
             object, or if all references were garbage collected.  In
d1543 4
a1546 4
        {
          if (!add_dynamic_entry (DT_RELA, 0)
              || !add_dynamic_entry (DT_RELASZ, 0)
              || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
d1613 2
a1614 2
          || r_type == (int) R_390_GNU_VTENTRY)
        continue;
d1669 1
a1669 1
          	      input_section, rel->r_offset,
d1679 7
a1685 7
        case R_390_GOT12:
        case R_390_GOT16:
        case R_390_GOT32:
        case R_390_GOT64:
        case R_390_GOTENT:
          /* Relocation is to the entry for this symbol in the global
             offset table.  */
d1689 2
a1690 2
          if (h != NULL)
            {
d1693 1
a1693 1
              off = h->got.offset;
d1695 3
a1697 3
              if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
                  || (info->shared
                      && (info->symbolic
d1700 18
a1717 18
                      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
                {
                  /* This is actually a static link, or it is a
                     -Bsymbolic link and the symbol is defined
                     locally, or the symbol was forced to be local
                     because of a version file.  We must initialize
                     this entry in the global offset table.  Since the
                     offset must always be a multiple of 2, we use the
                     least significant bit to record whether we have
                     initialized it already.

                     When doing a dynamic link, we create a .rel.got
                     relocation entry to initialize the value.  This
                     is done in the finish_dynamic_symbol routine.  */
                  if ((off & 1) != 0)
                    off &= ~1;
                  else
                    {
d1720 3
a1722 3
                      h->got.offset |= 1;
                    }
                }
d1725 3
a1727 3
            }
          else
            {
d1731 1
a1731 1
              off = local_got_offsets[r_symndx];
d1733 8
a1740 8
              /* The offset must always be a multiple of 8.  We use
                 the least significant bit to record whether we have
                 already generated the necessary reloc.  */
              if ((off & 1) != 0)
                off &= ~1;
              else
                {
                  bfd_put_64 (output_bfd, relocation,
d1743 5
a1747 5
                  if (info->shared)
                    {
                      asection *srelgot;
                      Elf_Internal_Rela outrel;
		      Elf64_External_Rela *loc;
d1749 2
a1750 2
                      srelgot = htab->srelgot;
		      if (srelgot == NULL)
d1753 4
a1756 4
                      outrel.r_offset = (htab->sgot->output_section->vma
                                         + htab->sgot->output_offset
                                         + off);
                      outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
d1758 8
a1765 8
		      loc = (Elf64_External_Rela *) srelgot->contents;
		      loc += srelgot->reloc_count++;
                      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
                    }

                  local_got_offsets[r_symndx] |= 1;
                }
            }
d1781 5
a1785 1
          break;
d1787 6
a1792 10
        case R_390_GOTOFF:
          /* Relocation is relative to the start of the global offset
             table.  */

          /* Note that sgot->output_offset is not involved in this
             calculation.  We always want the start of .got.  If we
             defined _GLOBAL_OFFSET_TABLE in a different way, as is
             permitted by the ABI, we might have to change this
             calculation.  */
          relocation -= htab->sgot->output_section->vma;
d1794 1
a1794 1
          break;
d1796 1
a1796 1
        case R_390_GOTPC:
d1798 2
a1799 2
          /* Use global offset table as symbol value.  */
          relocation = htab->sgot->output_section->vma;
d1801 8
a1808 1
         break;
d1810 4
a1813 11
        case R_390_PLT16DBL:
        case R_390_PLT32:
        case R_390_PLT32DBL:
        case R_390_PLT64:
          /* Relocation is to the entry for this symbol in the
             procedure linkage table.  */

          /* Resolve a PLT32 reloc against a local symbol directly,
             without using the procedure linkage table.  */
          if (h == NULL)
            break;
d1815 1
a1815 1
          if (h->plt.offset == (bfd_vma) -1
d1817 10
a1826 10
            {
              /* We didn't make a PLT entry for this symbol.  This
                 happens when statically linking PIC code, or when
                 using -Bsymbolic.  */
              break;
            }

          relocation = (htab->splt->output_section->vma
                        + htab->splt->output_offset
                        + h->plt.offset);
d1828 1
a1828 1
          break;
d1830 7
a1836 7
        case R_390_8:
        case R_390_16:
        case R_390_32:
        case R_390_64:
        case R_390_PC16:
        case R_390_PC16DBL:
        case R_390_PC32:
d1838 1
a1838 1
        case R_390_PC64:
d1842 2
a1843 2
          if (r_symndx == 0
              || (input_section->flags & SEC_ALLOC) == 0)
d1846 1
a1846 1
          if ((info->shared
d1867 3
a1869 3
            {
              Elf_Internal_Rela outrel;
              boolean skip, relocate;
d1871 1
a1871 1
	      Elf64_External_Rela *loc;
d1873 3
a1875 3
              /* When generating a shared object, these relocations
                 are copied into the output file to be resolved at run
                 time.  */
d1877 2
a1878 2
              skip = false;
              relocate = false;
d1888 2
a1889 2
              outrel.r_offset += (input_section->output_section->vma
                                  + input_section->output_offset);
d1891 1
a1891 1
              if (skip)
d1893 1
a1893 1
              else if (h != NULL
d1904 2
a1905 2
                {
                  outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
d1907 3
a1909 3
                }
              else
                {
d1920 17
a1936 17
	      loc = (Elf64_External_Rela *) sreloc->contents;
	      loc += sreloc->reloc_count++;
              bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

              /* If this reloc is against an external symbol, we do
                 not want to fiddle with the addend.  Otherwise, we
                 need to include the symbol value so that it becomes
                 an addend for the dynamic reloc.  */
              if (! relocate)
                continue;
            }

          break;

        default:
          break;
        }
d2014 1
a2014 1
      Elf64_External_Rela *loc;
d2017 1
a2017 1
         it up.  */
d2026 1
a2026 1
         Current offset - size first entry / entry size.  */
d2030 1
a2030 1
         addr & GOT addr.  */
d2065 1
a2065 1
         Points to instruction after GOT offset.  */
d2079 1
a2079 1
      loc = (Elf64_External_Rela *) htab->srelplt->contents + plt_index;
d2096 1
a2096 1
      Elf64_External_Rela *loc;
d2099 1
a2099 1
         up.  */
d2118 1
a2118 1
        {
d2120 5
a2124 5
          rela.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
          rela.r_addend = (h->root.u.def.value
                           + h->root.u.def.section->output_section->vma
                           + h->root.u.def.section->output_offset);
        }
d2130 2
a2131 2
          rela.r_addend = 0;
        }
d2133 2
a2134 2
      loc = (Elf64_External_Rela *) htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++;
d2141 1
a2141 1
      Elf64_External_Rela *loc;
d2156 2
a2157 2
      loc = (Elf64_External_Rela *) htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++;
d2334 2
a2335 2
  8,            /* hash-table entry size */
  1,            /* internal relocations per external relocations */
d2348 4
a2351 4
  NULL,
  NULL,
  NULL,
  NULL
d2391 1
a2391 1
#define elf_backend_object_p                  elf_s390_object_p
@


1.31.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d32 1
a32 1
static bfd_boolean elf_s390_is_local_label_name
d38 1
a38 1
static bfd_boolean create_got_section
d40 1
a40 1
static bfd_boolean elf_s390_create_dynamic_sections
d43 1
a43 1
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
d45 1
a45 1
static bfd_boolean elf_s390_check_relocs
d51 1
a51 1
static bfd_boolean elf_s390_gc_sweep_hook
d54 1
a54 4
struct elf_s390_link_hash_entry;
static void elf_s390_adjust_gotplt
  PARAMS ((struct elf_s390_link_hash_entry *));
static bfd_boolean elf_s390_adjust_dynamic_symbol
d56 1
a56 1
static bfd_boolean allocate_dynrelocs
d58 1
a58 1
static bfd_boolean readonly_dynrelocs
d60 1
a60 1
static bfd_boolean elf_s390_size_dynamic_sections
d62 1
a62 1
static bfd_boolean elf_s390_relocate_section
d65 1
a65 1
static bfd_boolean elf_s390_finish_dynamic_symbol
d70 1
a70 1
static bfd_boolean elf_s390_finish_dynamic_sections
d72 1
a72 16
static bfd_boolean elf_s390_mkobject
  PARAMS ((bfd *));
static bfd_boolean elf_s390_object_p
  PARAMS ((bfd *));
static int elf_s390_tls_transition
  PARAMS ((struct bfd_link_info *, int, int));
static bfd_reloc_status_type s390_tls_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
static void invalid_tls_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *));
static bfd_reloc_status_type s390_elf_ldisp_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d87 1
a87 1
	 FALSE,			/* pc_relative */
d92 1
a92 1
	 FALSE,			/* partial_inplace */
d95 1
a95 1
	 FALSE),		/* pcrel_offset */
d97 26
a122 114
  HOWTO(R_390_8,         0, 0,  8, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_8",        FALSE, 0,0x000000ff, FALSE),
  HOWTO(R_390_12,        0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_12",       FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_16,        0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_16",       FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_32,        0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_32",       FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PC32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32",     FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT12",    FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT32",    FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLT32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32",    FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_COPY,      0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_COPY",     FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GLOB_DAT,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GLOB_DAT", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_JMP_SLOT,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_JMP_SLOT", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_RELATIVE,  0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_RELATIVE", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF32", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTPC,     0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPC",    FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOT16,     0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT16",    FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PC16,      0, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16",     FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16DBL",  FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT16DBL", FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32DBL",  FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32DBL", FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPCDBL", FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_64,        0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_64",       FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_PC64,	 0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC64",     FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOT64,	 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT64",    FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_PLT64,	 0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT64",    FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOTENT,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTENT",   FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_GOTOFF64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF64", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTPLT12,	 0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_GOTPLT12", FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOTPLT16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_GOTPLT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT32", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTPLT64,	 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT64", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTPLTENT, 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLTENT",FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_PLTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PLTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF32", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLTOFF64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF64", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_TLS_LOAD, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LOAD", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_GDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_GDCALL", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_LDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LDCALL", FALSE, 0, 0, FALSE),
  EMPTY_HOWTO (R_390_TLS_GD32),	/* Empty entry for R_390_TLS_GD32.  */
  HOWTO(R_390_TLS_GD64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GD64", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_GOTIE12, 0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE12", FALSE, 0, 0x00000fff, FALSE),
  EMPTY_HOWTO (R_390_TLS_GOTIE32),	/* Empty entry for R_390_TLS_GOTIE32.  */
  HOWTO(R_390_TLS_GOTIE64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE64", FALSE, 0, MINUS_ONE, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDM32),	/* Empty entry for R_390_TLS_LDM32.  */
  HOWTO(R_390_TLS_LDM64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDM64", FALSE, 0, MINUS_ONE, FALSE),
  EMPTY_HOWTO (R_390_TLS_IE32),	/* Empty entry for R_390_TLS_IE32.  */
  HOWTO(R_390_TLS_IE64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IE64", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_IEENT, 1, 2, 32, TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IEENT", FALSE, 0, MINUS_ONE, TRUE),
  EMPTY_HOWTO (R_390_TLS_LE32),	/* Empty entry for R_390_TLS_LE32.  */
  HOWTO(R_390_TLS_LE64,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LE64", FALSE, 0, MINUS_ONE, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDO32),	/* Empty entry for R_390_TLS_LDO32.  */
  HOWTO(R_390_TLS_LDO64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDO64", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_DTPMOD, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPMOD", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_DTPOFF, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPOFF", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_TPOFF, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_TPOFF", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_20,        0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_20",      FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOT20,	 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOT20",   FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOTPLT20,  0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOTPLT20", FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_TLS_GOTIE20, 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_TLS_GOTIE20", FALSE, 0,0x0fffff00, FALSE),
d127 1
a127 1
  HOWTO (R_390_GNU_VTINHERIT, 0,4,0,FALSE,0,complain_overflow_dont, NULL, "R_390_GNU_VTINHERIT", FALSE,0, 0, FALSE);
d129 1
a129 1
  HOWTO (R_390_GNU_VTENTRY, 0,4,0,FALSE,0,complain_overflow_dont, _bfd_elf_rel_vtable_reloc_fn,"R_390_GNU_VTENTRY", FALSE,0,0, FALSE);
d167 1
a167 1
      return &elf_howto_table[(int) R_390_GOTOFF32];
d178 4
a197 60
    case BFD_RELOC_16_GOTOFF:
      return &elf_howto_table[(int) R_390_GOTOFF16];
    case BFD_RELOC_390_GOTOFF64:
      return &elf_howto_table[(int) R_390_GOTOFF64];
    case BFD_RELOC_390_GOTPLT12:
      return &elf_howto_table[(int) R_390_GOTPLT12];
    case BFD_RELOC_390_GOTPLT16:
      return &elf_howto_table[(int) R_390_GOTPLT16];
    case BFD_RELOC_390_GOTPLT32:
      return &elf_howto_table[(int) R_390_GOTPLT32];
    case BFD_RELOC_390_GOTPLT64:
      return &elf_howto_table[(int) R_390_GOTPLT64];
    case BFD_RELOC_390_GOTPLTENT:
      return &elf_howto_table[(int) R_390_GOTPLTENT];
    case BFD_RELOC_390_PLTOFF16:
      return &elf_howto_table[(int) R_390_PLTOFF16];
    case BFD_RELOC_390_PLTOFF32:
      return &elf_howto_table[(int) R_390_PLTOFF32];
    case BFD_RELOC_390_PLTOFF64:
      return &elf_howto_table[(int) R_390_PLTOFF64];
    case BFD_RELOC_390_TLS_LOAD:
      return &elf_howto_table[(int) R_390_TLS_LOAD];
    case BFD_RELOC_390_TLS_GDCALL:
      return &elf_howto_table[(int) R_390_TLS_GDCALL];
    case BFD_RELOC_390_TLS_LDCALL:
      return &elf_howto_table[(int) R_390_TLS_LDCALL];
    case BFD_RELOC_390_TLS_GD64:
      return &elf_howto_table[(int) R_390_TLS_GD64];
    case BFD_RELOC_390_TLS_GOTIE12:
      return &elf_howto_table[(int) R_390_TLS_GOTIE12];
    case BFD_RELOC_390_TLS_GOTIE64:
      return &elf_howto_table[(int) R_390_TLS_GOTIE64];
    case BFD_RELOC_390_TLS_LDM64:
      return &elf_howto_table[(int) R_390_TLS_LDM64];
    case BFD_RELOC_390_TLS_IE64:
      return &elf_howto_table[(int) R_390_TLS_IE64];
    case BFD_RELOC_390_TLS_IEENT:
      return &elf_howto_table[(int) R_390_TLS_IEENT];
    case BFD_RELOC_390_TLS_LE64:
      return &elf_howto_table[(int) R_390_TLS_LE64];
    case BFD_RELOC_390_TLS_LDO64:
      return &elf_howto_table[(int) R_390_TLS_LDO64];
    case BFD_RELOC_390_TLS_DTPMOD:
      return &elf_howto_table[(int) R_390_TLS_DTPMOD];
    case BFD_RELOC_390_TLS_DTPOFF:
      return &elf_howto_table[(int) R_390_TLS_DTPOFF];
    case BFD_RELOC_390_TLS_TPOFF:
      return &elf_howto_table[(int) R_390_TLS_TPOFF];
    case BFD_RELOC_390_20:
      return &elf_howto_table[(int) R_390_20];
    case BFD_RELOC_390_GOT20:
      return &elf_howto_table[(int) R_390_GOT20];
    case BFD_RELOC_390_GOTPLT20:
      return &elf_howto_table[(int) R_390_GOTPLT20];
    case BFD_RELOC_390_TLS_GOTIE20:
      return &elf_howto_table[(int) R_390_TLS_GOTIE20];
    case BFD_RELOC_VTABLE_INHERIT:
      return &elf64_s390_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf64_s390_vtentry_howto;
d229 1
a229 70
/* A relocation function which doesn't do anything.  */
static bfd_reloc_status_type
s390_tls_reloc (abfd, reloc_entry, symbol, data, input_section,
		output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

/* Handle the large displacement relocs.  */
static bfd_reloc_status_type
s390_elf_ldisp_reloc (abfd, reloc_entry, symbol, data, input_section,
                      output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  reloc_howto_type *howto = reloc_entry->howto;
  bfd_vma relocation;
  bfd_vma insn;

  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
  if (output_bfd != NULL)
    return bfd_reloc_continue;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  relocation = (symbol->value
		+ symbol->section->output_section->vma
		+ symbol->section->output_offset);
  relocation += reloc_entry->addend;
  if (howto->pc_relative)
    {
      relocation -= (input_section->output_section->vma
		     + input_section->output_offset);
      relocation -= reloc_entry->address;
    }

  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address); 
  insn |= (relocation & 0xfff) << 16 | (relocation & 0xff000) >> 4;
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);

  if ((bfd_signed_vma) relocation < - 0x80000
      || (bfd_signed_vma) relocation > 0x7ffff)
    return bfd_reloc_overflow;
  else
    return bfd_reloc_ok;
}

static bfd_boolean
d235 1
a235 1
    return TRUE;
a246 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

a359 10

  /* Number of GOTPLT references for a function.  */
  bfd_signed_vma gotplt_refcount;

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2
#define GOT_TLS_IE	3
#define GOT_TLS_IE_NLT	3
  unsigned char tls_type;
a361 36
#define elf_s390_hash_entry(ent) \
  ((struct elf_s390_link_hash_entry *)(ent))

struct elf_s390_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
};

#define elf_s390_tdata(abfd) \
  ((struct elf_s390_obj_tdata *) (abfd)->tdata.any)

#define elf_s390_local_got_tls_type(abfd) \
  (elf_s390_tdata (abfd)->local_got_tls_type)

static bfd_boolean
elf_s390_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
  return TRUE;
}

static bfd_boolean
elf_s390_object_p (abfd)
     bfd *abfd;
{
  /* Set the right machine number for an s390 elf32 file.  */
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_64);
}

a376 5
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ldm_got;

a411 2
      eh->gotplt_refcount = 0;
      eh->tls_type = GOT_UNKNOWN;
a442 1
  ret->tls_ldm_got.refcount = 0;
d451 1
a451 1
static bfd_boolean
d459 1
a459 1
    return FALSE;
d474 2
a475 2
    return FALSE;
  return TRUE;
d482 1
a482 1
static bfd_boolean
d491 1
a491 1
    return FALSE;
d494 1
a494 1
    return FALSE;
d506 1
a506 1
  return TRUE;
d513 1
a513 1
     const struct elf_backend_data *bed;
d555 1
a555 47
  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }

  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

static int
elf_s390_tls_transition (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_390_TLS_GD64:
    case R_390_TLS_IE64:
      if (is_local)
	return R_390_TLS_LE64;
      return R_390_TLS_IE64;
    case R_390_TLS_GOTIE64:
      if (is_local)
	return R_390_TLS_LE64;
      return R_390_TLS_GOTIE64;
    case R_390_TLS_LDM64:
      return R_390_TLS_LE64;
    }

  return r_type;
d562 1
a562 1
static bfd_boolean
a574 2
  bfd_signed_vma *local_got_refcounts;
  int tls_type, old_tls_type;
d576 2
a577 2
  if (info->relocatable)
    return TRUE;
a581 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
a587 1
      unsigned int r_type;
d598 1
a598 1
	  return FALSE;
d606 1
a606 6
      /* Create got section and local_got_refcounts array if they
	 are needed.  */
      r_type = elf_s390_tls_transition (info,
					ELF64_R_TYPE (rel->r_info),
					h == NULL);
      switch (r_type)
d609 1
a609 2
	case R_390_GOT16:
	case R_390_GOT20:
d613 6
a618 15
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	case R_390_TLS_GD64:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE64:
	case R_390_TLS_IEENT:
	case R_390_TLS_IE64:
	case R_390_TLS_LDM64:
	  if (h == NULL
	      && local_got_refcounts == NULL)
d620 1
a620 1
	      bfd_size_type size;
d622 2
a623 4
	      size = symtab_hdr->sh_info;
	      size *= (sizeof (bfd_signed_vma) + sizeof(char));
	      local_got_refcounts = ((bfd_signed_vma *)
				     bfd_zalloc (abfd, size));
d625 12
a636 4
		return FALSE;
	      elf_local_got_refcounts (abfd) = local_got_refcounts;
	      elf_s390_local_got_tls_type (abfd)
		= (char *) (local_got_refcounts + symtab_hdr->sh_info);
d638 3
a640 4
	  /* Fall through.  */
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
d648 1
a648 1
		return FALSE;
a649 10
	}

      switch (r_type)
	{
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	  /* Got is created, nothing to be done.  */
d652 1
a652 1
	case R_390_PLT16DBL:
a655 3
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	case R_390_PLTOFF64:
d657 5
a661 5
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code which is
	     never referenced by a dynamic object, in which case we
	     don't need to generate a procedure linkage table entry
	     after all.  */
d664 3
a666 7
	     creating a procedure linkage table entry.  */
	  if (h != NULL)
	    {
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->plt.refcount += 1;
	    }
	  break;
d668 2
a669 22
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	  /* This symbol requires either a procedure linkage table entry
	     or an entry in the local got. We actually build the entry
	     in adjust_dynamic_symbol because whether this is really a
	     global reference can change and with it the fact if we have
	     to create a plt entry or a local got entry. To be able to
	     make a once global symbol a local one we have to keep track
	     of the number of gotplt references that exist for this
	     symbol.  */
	  if (h != NULL)
	    {
	      ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount++;
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->plt.refcount += 1;
	    }
	  else
	    local_got_refcounts[r_symndx] += 1;
d672 2
a673 90
	case R_390_TLS_LDM64:
	  htab->tls_ldm_got.refcount += 1;
	  break;

	case R_390_TLS_IE64:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE64:
	case R_390_TLS_IEENT:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  /* Fall through */

	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOT64:
	case R_390_GOTENT:
	case R_390_TLS_GD64:
	  /* This symbol requires a global offset table entry.  */
	  switch (r_type)
	    {
	    default:
	    case R_390_GOT12:
	    case R_390_GOT16:
	    case R_390_GOT20:
	    case R_390_GOT32:
	    case R_390_GOTENT:
	      tls_type = GOT_NORMAL;
	      break;
	    case R_390_TLS_GD64:
	      tls_type = GOT_TLS_GD;
	      break;
	    case R_390_TLS_IE64:
	    case R_390_TLS_GOTIE64:
	      tls_type = GOT_TLS_IE;
	      break;
	    case R_390_TLS_GOTIE12:
	    case R_390_TLS_GOTIE20:
	    case R_390_TLS_IEENT:
	      tls_type = GOT_TLS_IE_NLT;
	      break;
	    }

	  if (h != NULL)
	    {
	      h->got.refcount += 1;
	      old_tls_type = elf_s390_hash_entry(h)->tls_type;
	    }
	  else
	    {
	      local_got_refcounts[r_symndx] += 1;
	      old_tls_type = elf_s390_local_got_tls_type (abfd) [r_symndx];
	    }
	  /* If a TLS symbol is accessed using IE at least once,
	     there is no point to use dynamic model for it.  */
	  if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN)
	    {
	      if (old_tls_type == GOT_NORMAL || tls_type == GOT_NORMAL)
		{
		  (*_bfd_error_handler)
		    (_("%s: `%s' accessed both as normal and thread local symbol"),
		     bfd_archive_filename (abfd), h->root.root.string);
		  return FALSE;
		}
	      if (old_tls_type > tls_type)
		tls_type = old_tls_type;
	    }

	  if (old_tls_type != tls_type)
	    {
	      if (h != NULL)
		elf_s390_hash_entry (h)->tls_type = tls_type;
	      else
		elf_s390_local_got_tls_type (abfd) [r_symndx] = tls_type;
	    }

	  if (r_type != R_390_TLS_IE64)
	    break;
	  /* Fall through */

	case R_390_TLS_LE64:
	  if (!info->shared)
	    break;
	  info->flags |= DF_STATIC_TLS;
	  /* Fall through */

	case R_390_8:
	case R_390_16:
d676 2
a677 2
	case R_390_PC16:
	case R_390_PC16DBL:
d729 1
a729 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d752 1
a752 1
		    return FALSE;
d780 1
a780 1
			return FALSE;
d801 1
a801 1
		    return FALSE;
d814 1
a814 1
		    return FALSE;
d834 4
a837 4
	case R_390_GNU_VTINHERIT:
	  if (!_bfd_elf64_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;
d841 4
a844 4
	case R_390_GNU_VTENTRY:
	  if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;
d851 1
a851 1
  return TRUE;
d896 1
a896 1
static bfd_boolean
d907 2
d918 42
a959 14
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf_s390_link_hash_entry *eh;
	  struct elf_s390_dyn_relocs **pp;
	  struct elf_s390_dyn_relocs *p;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct elf_s390_link_hash_entry *) h;
d961 2
a962 8
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}
d964 1
a964 37
      r_type = ELF64_R_TYPE (rel->r_info);
      r_type = elf_s390_tls_transition (info, r_type, h != NULL);
      switch (r_type)
	{
	case R_390_TLS_LDM64:
	  if (elf_s390_hash_table (info)->tls_ldm_got.refcount > 0)
	    elf_s390_hash_table (info)->tls_ldm_got.refcount -= 1;
	  break;

	case R_390_TLS_GD64:
	case R_390_TLS_IE64:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE64:
	case R_390_TLS_IEENT:
	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOT64:
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	case R_390_GOTENT:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d966 2
a967 38
	case R_390_8:
	case R_390_12:
	case R_390_16:
	case R_390_20:
	case R_390_32:
	case R_390_64:
	case R_390_PC16:
	case R_390_PC16DBL:
	case R_390_PC32:
	case R_390_PC32DBL:
	case R_390_PC64:
	  if (info->shared)
	    break;
	  /* Fall through */

	case R_390_PLT16DBL:
	case R_390_PLT32:
	case R_390_PLT32DBL:
	case R_390_PLT64:
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	case R_390_PLTOFF64:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;

	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
d969 8
a976 2
		  ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount--;
		  h->plt.refcount -= 1;
d978 2
a979 7
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d981 16
a996 4
	default:
	  break;
	}
    }
d998 1
a998 24
  return TRUE;
}

/* Make sure we emit a GOT entry if the symbol was supposed to have a PLT
   entry but we found we will not create any.  Called when we find we will
   not have any PLT for this symbol, by for example
   elf_s390_adjust_dynamic_symbol when we're doing a proper dynamic link,
   or elf_s390_size_dynamic_sections if no dynamic sections will be
   created (we're only linking static objects).  */

static void
elf_s390_adjust_gotplt (h)
     struct elf_s390_link_hash_entry *h;
{
  if (h->elf.root.type == bfd_link_hash_warning)
    h = (struct elf_s390_link_hash_entry *) h->elf.root.u.i.link;

  if (h->gotplt_refcount <= 0)
    return;

  /* We simply add the number of gotplt references to the number
   * of got references for this symbol.  */
  h->elf.got.refcount += h->gotplt_refcount;
  h->gotplt_refcount = -1;
d1007 1
a1007 1
static bfd_boolean
d1013 2
d1032 2
a1033 2
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
a1037 1
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
d1040 1
a1040 1
      return TRUE;
d1059 1
a1059 5
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
      return TRUE;
d1070 1
a1070 1
    return TRUE;
d1075 1
a1075 1
    return TRUE;
d1081 1
a1081 1
      return TRUE;
d1084 2
a1085 1
  if (ELIMINATE_COPY_RELOCS)
d1087 4
a1090 2
      struct elf_s390_link_hash_entry * eh;
      struct elf_s390_dyn_relocs *p;
d1092 6
a1097 15
      eh = (struct elf_s390_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1133 1
a1133 1
	return FALSE;
d1143 1
a1143 1
  return TRUE;
d1150 1
a1150 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d1152 1
a1152 1
   && ((SHARED)								\
d1160 1
a1160 1
static bfd_boolean
d1171 1
a1171 1
    return TRUE;
a1173 3
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
d1180 1
a1180 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d1188 1
a1188 1
	    return FALSE;
d1191 1
a1191 2
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
a1227 1
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
a1233 1
      elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
d1236 1
a1236 21
  /* If R_390_TLS_{IE64,GOTIE64,GOTIE12,IEENT} symbol is now local to
     the binary, we can optimize a bit. IE64 and GOTIE64 get converted
     to R_390_TLS_LE64 requiring no TLS entry. For GOTIE12 and IEENT
     we can save the dynamic TLS relocation.  */
  if (h->got.refcount > 0
      && !info->shared
      && h->dynindx == -1
      && elf_s390_hash_entry(h)->tls_type >= GOT_TLS_IE)
    {
      if (elf_s390_hash_entry(h)->tls_type == GOT_TLS_IE_NLT)
	/* For the GOTIE access without a literal pool entry the offset has
	   to be stored somewhere. The immediate value in the instruction
	   is not bit enough so the value is stored in the got.  */
	{
	  h->got.offset = htab->sgot->_raw_size;
	  htab->sgot->_raw_size += GOT_ENTRY_SIZE;
	}
      else
	h->got.offset = (bfd_vma) -1;
    }
  else if (h->got.refcount > 0)
d1239 1
a1239 2
      bfd_boolean dyn;
      int tls_type = elf_s390_hash_entry(h)->tls_type;
d1247 1
a1247 1
	    return FALSE;
a1252 3
      /* R_390_TLS_GD64 needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->_raw_size += GOT_ENTRY_SIZE;
d1254 1
a1254 11
      /* R_390_TLS_IE64 needs one dynamic relocation,
	 R_390_TLS_GD64 needs one if local symbol and two if global.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type >= GOT_TLS_IE)
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->srelgot->_raw_size += 2 * sizeof (Elf64_External_Rela);
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
d1262 1
a1262 1
    return TRUE;
a1287 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d1289 1
a1289 1
  else if (ELIMINATE_COPY_RELOCS)
d1308 1
a1308 1
		return FALSE;
d1329 1
a1329 1
  return TRUE;
d1334 1
a1334 1
static bfd_boolean
d1357 1
a1357 1
	  return FALSE;
d1360 1
a1360 1
  return TRUE;
d1365 1
a1365 1
static bfd_boolean
d1373 1
a1373 1
  bfd_boolean relocs;
d1384 1
a1384 1
      if (info->executable)
a1399 1
      char *local_tls_type;
a1440 1
      local_tls_type = elf_s390_local_got_tls_type (ibfd);
d1443 1
a1443 1
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
a1448 2
	      if (*local_tls_type == GOT_TLS_GD)
		s->_raw_size += GOT_ENTRY_SIZE;
a1456 11
  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_390_TLS_LDM64
	 relocs.  */
      htab->tls_ldm_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

d1463 1
a1463 1
  relocs = FALSE;
d1479 1
a1479 1
	    relocs = TRUE;
d1514 1
a1514 1
	return FALSE;
d1527 1
a1527 1
      if (info->executable)
d1530 1
a1530 1
	    return FALSE;
d1539 1
a1539 1
	    return FALSE;
d1543 5
a1547 5
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
	    return FALSE;
d1558 1
a1558 1
		return FALSE;
d1564 1
a1564 51
  return TRUE;
}

/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (info)
     struct bfd_link_info *info;
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
{
  struct elf_link_hash_table *htab = elf_hash_table (info);

  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
    return 0;
  return htab->tls_size + htab->tls_sec->vma - address;
}

/* Complain if TLS instruction relocation is against an invalid
   instruction.  */

static void
invalid_tls_insn (input_bfd, input_section, rel)
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *rel;
{
  reloc_howto_type *howto;

  howto = elf_howto_table + ELF64_R_TYPE (rel->r_info);
  (*_bfd_error_handler)
    (_("%s(%s+0x%lx): invalid instruction for TLS relocation %s"),
     bfd_archive_filename (input_bfd),
     bfd_get_section_name (input_bfd, input_section),
     (long) rel->r_offset,
     howto->name);
d1569 1
a1569 1
static bfd_boolean
d1588 2
a1589 2
  if (info->relocatable)
    return TRUE;
d1600 1
a1600 1
      unsigned int r_type;
d1608 1
a1608 1
      bfd_boolean unresolved_reloc;
a1609 1
      int tls_type;
d1613 3
a1615 3
	  || r_type == (int) R_390_GNU_VTENTRY)
	continue;
      if (r_type >= (int) R_390_max)
d1618 1
a1618 1
	  return FALSE;
a1622 2

      /* This is a final link.  */
d1626 1
a1626 1
      unresolved_reloc = FALSE;
d1631 1
a1631 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1635 4
a1638 1
	  bfd_boolean warned ATTRIBUTE_UNUSED;
d1640 35
a1674 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
d1679 7
a1685 43
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	  /* There are three cases for a GOTPLT relocation. 1) The
	     relocation is against the jump slot entry of a plt that
	     will get emitted to the output file. 2) The relocation
	     is against the jump slot of a plt entry that has been
	     removed. elf_s390_adjust_gotplt has created a GOT entry
	     as replacement. 3) The relocation is against a local symbol.
	     Cases 2) and 3) are the same as the GOT relocation code
	     so we just have to test for case 1 and fall through for
	     the other two.  */
	  if (h != NULL && h->plt.offset != (bfd_vma) -1)
	    {
	      bfd_vma plt_index;

	      /* Calc. index no.
		 Current offset - size first entry / entry size.  */
	      plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) /
		PLT_ENTRY_SIZE;

	      /* Offset in GOT is PLT index plus GOT headers(3) times 4,
		 addr & GOT addr.  */
	      relocation = (plt_index + 3) * GOT_ENTRY_SIZE;
	      unresolved_reloc = FALSE;

	      if (r_type == R_390_GOTPLTENT)
		relocation += htab->sgot->output_section->vma;
	      break;
	    }
	  /* Fall through.  */

	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOT64:
	case R_390_GOTENT:
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
d1689 3
a1691 3
	  if (h != NULL)
	    {
	      bfd_boolean dyn;
d1693 1
a1693 1
	      off = h->got.offset;
d1695 3
a1697 3
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		  || (info->shared
		      && (info->symbolic
d1700 18
a1717 20
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 2, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rel.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
d1720 3
a1722 3
		      h->got.offset |= 1;
		    }
		}
d1724 4
a1727 4
		unresolved_reloc = FALSE;
	    }
	  else
	    {
d1731 1
a1731 1
	      off = local_got_offsets[r_symndx];
d1733 8
a1740 8
	      /* The offset must always be a multiple of 8.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_64 (output_bfd, relocation,
d1743 5
a1747 5
		  if (info->shared)
		    {
		      asection *s;
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;
d1749 2
a1750 2
		      s = htab->srelgot;
		      if (s == NULL)
d1753 4
a1756 4
		      outrel.r_offset = (htab->sgot->output_section->vma
					 + htab->sgot->output_offset
					 + off);
		      outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
d1758 8
a1765 8
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		    }

		  local_got_offsets[r_symndx] |= 1;
		}
	    }
d1772 7
a1778 6
	  /* For @@GOTENT the relocation is against the offset between
	     the instruction and the symbols entry in the GOT and not
	     between the start of the GOT and the symbols entry. We
	     add the vma of the GOT to get the correct value.  */
	  if (   r_type == R_390_GOTENT
	      || r_type == R_390_GOTPLTENT)
d1781 12
a1792 1
	  break;
d1794 1
a1794 13
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
	  /* Relocation is relative to the start of the global offset
	     table.  */

	  /* Note that sgot->output_offset is not involved in this
	     calculation.  We always want the start of .got.  If we
	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
	     permitted by the ABI, we might have to change this
	     calculation.  */
	  relocation -= htab->sgot->output_section->vma;
	  break;
d1796 1
a1796 1
	case R_390_GOTPC:
d1798 16
a1813 11
	  /* Use global offset table as symbol value.  */
	  relocation = htab->sgot->output_section->vma;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_PLT16DBL:
	case R_390_PLT32:
	case R_390_PLT32DBL:
	case R_390_PLT64:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */
d1815 1
a1815 6
	  /* Resolve a PLT32 reloc against a local symbol directly,
	     without using the procedure linkage table.  */
	  if (h == NULL)
	    break;

	  if (h->plt.offset == (bfd_vma) -1
d1817 20
a1836 43
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
	    }

	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
			+ h->plt.offset);
	  unresolved_reloc = FALSE;
	  break;

	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	case R_390_PLTOFF64:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table relative to the start of the GOT.  */

	  /* For local symbols or if we didn't make a PLT entry for
	     this symbol resolve the symbol directly.  */
	  if (   h == NULL
	      || h->plt.offset == (bfd_vma) -1
	      || htab->splt == NULL)
	    {
	      relocation -= htab->sgot->output_section->vma;
	      break;
	    }

	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
			+ h->plt.offset
			- htab->sgot->output_section->vma);
	  unresolved_reloc = FALSE;
	  break;

	case R_390_8:
	case R_390_16:
	case R_390_32:
	case R_390_64:
	case R_390_PC16:
	case R_390_PC16DBL:
	case R_390_PC32:
d1838 1
a1838 1
	case R_390_PC64:
d1842 2
a1843 2
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
d1846 1
a1846 4
	  if ((info->shared
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d1857 1
a1857 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1867 3
a1869 3
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip, relocate;
d1871 5
a1875 1
	      bfd_byte *loc;
d1877 2
a1878 5
	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */
	      skip = FALSE;
	      relocate = FALSE;
d1884 1
a1884 1
		skip = TRUE;
d1886 1
a1886 1
		skip = TRUE, relocate = TRUE;
d1888 2
a1889 2
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);
d1891 1
a1891 1
	      if (skip)
d1893 1
a1893 1
	      else if (h != NULL
d1904 2
a1905 2
		{
		  outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
d1907 3
a1909 3
		}
	      else
		{
d1911 2
a1913 162
		  if (r_type == R_390_64)
		    {
		      relocate = TRUE;
		      outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
		    }
		  else
		    {
		      long sindx;

		      if (bfd_is_abs_section (sec))
			sindx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error(bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  sindx = elf_section_data (osec)->dynindx;
			  BFD_ASSERT (sindx > 0);

			  /* We are turning this relocation into one
			     against a section symbol, so subtract out
			     the output section's address but not the
			     offset of the input section in the output
			     section.  */

			  outrel.r_addend -= osec->vma;
			}
		      outrel.r_info = ELF64_R_INFO (sindx, r_type);
		    }
		}

	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	      /* If this reloc is against an external symbol, we do
		 not want to fiddle with the addend.  Otherwise, we
		 need to include the symbol value so that it becomes
		 an addend for the dynamic reloc.  */
	      if (! relocate)
		continue;
	    }

	  break;

	  /* Relocations for tls literal pool entries.  */
	case R_390_TLS_IE64:
	  if (info->shared)
	    {
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloc_out (output_bfd, &outrel, loc);
	    }
	  /* Fall through.  */

	case R_390_TLS_GD64:
	case R_390_TLS_GOTIE64:
	  r_type = elf_s390_tls_transition (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (!info->shared && h->dynindx == -1 && tls_type >= GOT_TLS_IE)
		r_type = R_390_TLS_LE64;
	    }
	  if (r_type == R_390_TLS_GD64 && tls_type >= GOT_TLS_IE)
	    r_type = R_390_TLS_IE64;

	  if (r_type == R_390_TLS_LE64)
	    {
	      /* This relocation gets optimized away by the local exec
		 access optimization.  */
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_64 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	      continue;
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	emit_tls_relocs:

	  if ((off & 1) != 0)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      int dr_type, indx;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
	      if (r_type == R_390_TLS_GD64)
		dr_type = R_390_TLS_DTPMOD;
	      else
		dr_type = R_390_TLS_TPOFF;
	      if (dr_type == R_390_TLS_TPOFF && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      outrel.r_info = ELF64_R_INFO (indx, dr_type);
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
		* sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	      if (r_type == R_390_TLS_GD64)
		{
		  if (indx == 0)
		    {
	    	      BFD_ASSERT (! unresolved_reloc);
		      bfd_put_64 (output_bfd,
				  relocation - dtpoff_base (info),
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
		    }
		  else
		    {
		      outrel.r_info = ELF64_R_INFO (indx, R_390_TLS_DTPOFF);
		      outrel.r_offset += GOT_ENTRY_SIZE;
		      outrel.r_addend = 0;
		      htab->srelgot->reloc_count++;
		      loc += sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		    }
a1915 114
	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();
	  if (r_type == ELF64_R_TYPE (rel->r_info))
	    {
	      relocation = htab->sgot->output_offset + off;
	      if (r_type == R_390_TLS_IE64 || r_type == R_390_TLS_IEENT)
		relocation += htab->sgot->output_section->vma;
	      unresolved_reloc = FALSE;
	    }
	  else
	    {
	      bfd_put_64 (output_bfd, htab->sgot->output_offset + off,
			  contents + rel->r_offset);
	      continue;
	    }
	  break;

	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_IEENT:
	  if (h == NULL)
	    {
	      if (local_got_offsets == NULL)
		abort();
	      off = local_got_offsets[r_symndx];
	      if (info->shared)
		goto emit_tls_relocs;
	    }
	  else
	    {
	      off = h->got.offset;
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (info->shared || h->dynindx != -1 || tls_type < GOT_TLS_IE)
		goto emit_tls_relocs;
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  BFD_ASSERT (! unresolved_reloc);
	  bfd_put_64 (output_bfd, -tpoff (info, relocation),
		      htab->sgot->contents + off);
	  relocation = htab->sgot->output_offset + off;
	  if (r_type == R_390_TLS_IEENT)
	    relocation += htab->sgot->output_section->vma;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_TLS_LDM64:
	  if (! info->shared)
	    /* The literal pool entry this relocation refers to gets ignored
	       by the optimized code of the local exec model. Do nothing
	       and the value will turn out zero.  */
	    continue;

	  if (htab->sgot == NULL)
	    abort ();

	  off = htab->tls_ldm_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      bfd_put_64 (output_bfd, 0,
			  htab->sgot->contents + off + GOT_ENTRY_SIZE);
	      outrel.r_info = ELF64_R_INFO (0, R_390_TLS_DTPMOD);
	      outrel.r_addend = 0;
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
		* sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ldm_got.offset |= 1;
	    }
	  relocation = htab->sgot->output_offset + off;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_TLS_LE64:
	  if (info->shared)
	    {
	      /* Linking a shared library with non-fpic code requires
		 a R_390_TLS_TPOFF relocation.  */
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;
	      int indx;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      if (h != NULL && h->dynindx != -1)
		indx = h->dynindx;
	      else
		indx = 0;
	      outrel.r_info = ELF64_R_INFO (indx, R_390_TLS_TPOFF);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
a1918 29
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
	    }
	  else
	    {
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_64 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	    }
	  continue;

	case R_390_TLS_LDO64:
	  if (info->shared || (input_section->flags & SEC_CODE) == 0)
	    relocation -= dtpoff_base (info);
	  else
	    /* When converting LDO to LE, we must negate.  */
	    relocation = -tpoff (info, relocation);
	  break;

	  /* Relocations for tls instructions.  */
	case R_390_TLS_LOAD:
	case R_390_TLS_GDCALL:
	case R_390_TLS_LDCALL:
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    tls_type = elf_s390_hash_entry(h)->tls_type;
d1920 17
a1936 87
	  if (tls_type == GOT_TLS_GD)
	    continue;

	  if (r_type == R_390_TLS_LOAD)
	    {
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		{
		  /* IE->LE transition. Four valid cases:
		     lg %rx,(0,%ry)    -> sllg %rx,%ry,0
		     lg %rx,(%ry,0)    -> sllg %rx,%ry,0
		     lg %rx,(%ry,%r12) -> sllg %rx,%ry,0
		     lg %rx,(%r12,%ry) -> sllg %rx,%ry,0  */
		  unsigned int insn0, insn1, ry;

		  insn0 = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  insn1 = bfd_get_16 (input_bfd, contents + rel->r_offset + 4);
		  if (insn1 != 0x0004)
		    invalid_tls_insn (input_bfd, input_section, rel);
		  ry = 0;
		  if ((insn0 & 0xff00f000) == 0xe3000000)
		    /* lg %rx,0(%ry,0) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x000f0000);
		  else if ((insn0 & 0xff0f0000) == 0xe3000000)
		    /* lg %rx,0(0,%ry) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x0000f000) << 4;
		  else if ((insn0 & 0xff00f000) == 0xe300c000)
		    /* lg %rx,0(%ry,%r12) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x000f0000);
		  else if ((insn0 & 0xff0f0000) == 0xe30c0000)
		    /* lg %rx,0(%r12,%ry) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x0000f000) << 4;
		  else
		    invalid_tls_insn (input_bfd, input_section, rel);
		  insn0 = 0xeb000000 | (insn0 & 0x00f00000) | ry;
		  insn1 = 0x000d;
		  bfd_put_32 (output_bfd, insn0, contents + rel->r_offset);
		  bfd_put_16 (output_bfd, insn1, contents + rel->r_offset + 4);
		}
	    }
	  else if (r_type == R_390_TLS_GDCALL)
	    {
	      unsigned int insn0, insn1;

	      insn0 = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      insn1 = bfd_get_16 (input_bfd, contents + rel->r_offset + 4);
	      if ((insn0 & 0xffff0000) != 0xc0e50000)
		invalid_tls_insn (input_bfd, input_section, rel);
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		{
		  /* GD->LE transition.
		     brasl %r14,__tls_get_addr@@plt -> brcl 0,. */
		  insn0 = 0xc0040000;
		  insn1 = 0x0000;
		}
	      else
		{
		  /* GD->IE transition.
		     brasl %r14,__tls_get_addr@@plt -> lg %r2,0(%r2,%r12)  */
		  insn0 = 0xe322c000;
		  insn1 = 0x0004;
		}
	      bfd_put_32 (output_bfd, insn0, contents + rel->r_offset);
	      bfd_put_16 (output_bfd, insn1, contents + rel->r_offset + 4);
	    }
	  else if (r_type == R_390_TLS_LDCALL)
	    {
	      if (!info->shared)
		{
		  unsigned int insn0, insn1;

		  insn0 = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  insn1 = bfd_get_16 (input_bfd, contents + rel->r_offset + 4);
		  if ((insn0 & 0xffff0000) != 0xc0e50000)
		    invalid_tls_insn (input_bfd, input_section, rel);
		  /* LD->LE transition.
		     brasl %r14,__tls_get_addr@@plt -> brcl 0,. */
		  insn0 = 0xc0040000;
		  insn1 = 0x0000;
		  bfd_put_32 (output_bfd, insn0, contents + rel->r_offset);
		  bfd_put_16 (output_bfd, insn1, contents + rel->r_offset + 4);
		}
	    }
	  continue;

	default:
	  break;
	}
d1951 1
a1951 13
      if (r_type == R_390_20
	  || r_type == R_390_GOT20
	  || r_type == R_390_GOTPLT20
	  || r_type == R_390_TLS_GOTIE20)
	{
	  relocation += rel->r_addend;
	  relocation = (relocation&0xfff) << 8 | (relocation&0xff000) >> 12;
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset,
					relocation, 0);
	}
      else
	r = _bfd_final_link_relocate (howto, input_bfd, input_section,
d1967 1
a1967 1
		return FALSE;
d1978 1
a1978 1
		return FALSE;
d1987 1
a1987 1
	      return FALSE;
d1992 1
a1992 1
  return TRUE;
d1998 1
a1998 1
static bfd_boolean
d2014 1
a2014 1
      bfd_byte *loc;
d2017 1
a2017 1
	 it up.  */
d2026 1
a2026 1
	 Current offset - size first entry / entry size.  */
d2030 1
a2030 1
	 addr & GOT addr.  */
d2065 1
a2065 1
	 Points to instruction after GOT offset.  */
d2079 1
a2079 1
      loc = htab->srelplt->contents + plt_index * sizeof (Elf64_External_Rela);
d2093 1
a2093 4
  if (h->got.offset != (bfd_vma) -1
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_GD
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE_NLT)
d2096 1
a2096 1
      bfd_byte *loc;
d2099 2
a2100 1
	 up.  */
d2118 1
a2118 1
	{
d2120 5
a2124 5
	  rela.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
	  rela.r_addend = (h->root.u.def.value
			   + h->root.u.def.section->output_section->vma
			   + h->root.u.def.section->output_offset);
	}
d2130 2
a2131 2
	  rela.r_addend = 0;
	}
d2133 2
a2134 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d2141 1
a2141 1
      bfd_byte *loc;
d2156 2
a2157 2
      loc = htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++ * sizeof (Elf64_External_Rela);
d2167 1
a2167 1
  return TRUE;
d2192 1
a2192 1
static bfd_boolean
d2308 8
a2315 1
  return TRUE;
d2318 5
a2322 3
/* Why was the hash table entry size definition changed from
   ARCH_SIZE/8 to 4? This breaks the 64 bit dynamic linker and
   this is the only reason for the s390_elf64_size_info structure.  */
d2334 4
a2337 4
  8,		/* hash-table entry size.  */
  1,		/* internal relocations per external relocations.  */
  64,		/* arch_size.  */
  3,		/* log_file_align.  */
d2348 4
a2351 4
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
d2369 1
d2391 1
a2391 2
#define bfd_elf64_mkobject		elf_s390_mkobject
#define elf_backend_object_p		elf_s390_object_p
@


1.31.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d32 1
a32 1
static bfd_boolean elf_s390_is_local_label_name
d38 1
a38 1
static bfd_boolean create_got_section
d40 1
a40 1
static bfd_boolean elf_s390_create_dynamic_sections
d45 1
a45 1
static bfd_boolean elf_s390_check_relocs
d51 1
a51 1
static bfd_boolean elf_s390_gc_sweep_hook
d54 1
a54 1
static bfd_boolean elf_s390_adjust_dynamic_symbol
d56 1
a56 1
static bfd_boolean allocate_dynrelocs
d58 1
a58 1
static bfd_boolean readonly_dynrelocs
d60 1
a60 1
static bfd_boolean elf_s390_size_dynamic_sections
d62 1
a62 1
static bfd_boolean elf_s390_relocate_section
d65 1
a65 1
static bfd_boolean elf_s390_finish_dynamic_symbol
d70 1
a70 1
static bfd_boolean elf_s390_finish_dynamic_sections
d72 1
a72 1
static bfd_boolean elf_s390_object_p PARAMS ((bfd *));
d87 1
a87 1
	 FALSE,			/* pc_relative */
d92 1
a92 1
	 FALSE,			/* partial_inplace */
d95 1
a95 1
	 FALSE),		/* pcrel_offset */
d97 26
a122 26
  HOWTO(R_390_8,         0, 0,  8, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_8",       FALSE, 0,0x000000ff, FALSE),
  HOWTO(R_390_12,        0, 1, 12, FALSE, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_12",      FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_16,        0, 1, 16, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_16",      FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_32,        0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_32",      FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PC32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32",    FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_GOT12",   FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT32",   FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLT32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32",   FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_COPY,      0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_COPY",    FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_GLOB_DAT,  0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GLOB_DAT",FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_JMP_SLOT,  0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_JMP_SLOT",FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_RELATIVE,  0, 4, 64,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_RELATIVE",FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_GOTOFF,    0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTOFF",  FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_GOTPC,     0, 4, 64,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPC",   FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOT16,     0, 1, 16, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT16",   FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PC16,      0, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16",    FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16DBL", FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT16DBL", FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32DBL", FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32DBL", FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPCDBL", FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_64,        0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_64",      FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_PC64,	 0, 4, 64,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC64",    FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOT64,	 0, 4, 64, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT64",   FALSE, 0,MINUS_ONE, FALSE),
  HOWTO(R_390_PLT64,	 0, 4, 64,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT64",   FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOTENT,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTENT",   FALSE, 0,MINUS_ONE,  TRUE),
d127 1
a127 1
  HOWTO (R_390_GNU_VTINHERIT, 0,4,0,FALSE,0,complain_overflow_dont, NULL, "R_390_GNU_VTINHERIT", FALSE,0, 0, FALSE);
d129 1
a129 1
  HOWTO (R_390_GNU_VTENTRY, 0,4,0,FALSE,0,complain_overflow_dont, _bfd_elf_rel_vtable_reloc_fn,"R_390_GNU_VTENTRY", FALSE,0,0, FALSE);
d229 1
a229 1
static bfd_boolean
d235 1
a235 1
    return TRUE;
d451 1
a451 1
static bfd_boolean
d459 1
a459 1
    return FALSE;
d474 2
a475 2
    return FALSE;
  return TRUE;
d482 1
a482 1
static bfd_boolean
d491 1
a491 1
    return FALSE;
d494 1
a494 1
    return FALSE;
d506 1
a506 1
  return TRUE;
d562 1
a562 1
static bfd_boolean
d577 1
a577 1
    return TRUE;
d598 1
a598 1
	  return FALSE;
d609 1
a609 1
	case R_390_GOT16:
d633 1
a633 1
		    return FALSE;
d648 1
a648 1
		return FALSE;
d652 1
a652 1
	case R_390_PLT16DBL:
d657 5
a661 5
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code which is
	     never referenced by a dynamic object, in which case we
	     don't need to generate a procedure linkage table entry
	     after all.  */
d664 1
a664 1
	     creating a procedure linkage table entry.  */
d672 2
a673 2
	case R_390_8:
	case R_390_16:
d676 2
a677 2
	case R_390_PC16:
	case R_390_PC16DBL:
d752 1
a752 1
		    return FALSE;
d780 1
a780 1
			return FALSE;
d801 1
a801 1
		    return FALSE;
d814 1
a814 1
		    return FALSE;
d834 4
a837 4
	case R_390_GNU_VTINHERIT:
	  if (!_bfd_elf64_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;
d841 4
a844 4
	case R_390_GNU_VTENTRY:
	  if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;
d851 1
a851 1
  return TRUE;
d896 1
a896 1
static bfd_boolean
d998 1
a998 1
  return TRUE;
d1007 1
a1007 1
static bfd_boolean
d1032 2
a1033 2
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
d1040 1
a1040 1
      return TRUE;
d1059 1
a1059 1
      return TRUE;
d1070 1
a1070 1
    return TRUE;
d1075 1
a1075 1
    return TRUE;
d1081 1
a1081 1
      return TRUE;
d1097 1
a1097 1
      return TRUE;
d1133 1
a1133 1
	return FALSE;
d1143 1
a1143 1
  return TRUE;
d1160 1
a1160 1
static bfd_boolean
d1171 1
a1171 1
    return TRUE;
d1188 1
a1188 1
	    return FALSE;
d1239 1
a1239 1
      bfd_boolean dyn;
d1247 1
a1247 1
	    return FALSE;
d1262 1
a1262 1
    return TRUE;
d1308 1
a1308 1
		return FALSE;
d1329 1
a1329 1
  return TRUE;
d1334 1
a1334 1
static bfd_boolean
d1357 1
a1357 1
	  return FALSE;
d1360 1
a1360 1
  return TRUE;
d1365 1
a1365 1
static bfd_boolean
d1373 1
a1373 1
  bfd_boolean relocs;
d1463 1
a1463 1
  relocs = FALSE;
d1479 1
a1479 1
	    relocs = TRUE;
d1514 1
a1514 1
	return FALSE;
d1530 1
a1530 1
	    return FALSE;
d1539 1
a1539 1
	    return FALSE;
d1543 5
a1547 5
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
	    return FALSE;
d1558 1
a1558 1
		return FALSE;
d1564 1
a1564 1
  return TRUE;
d1569 1
a1569 1
static bfd_boolean
d1589 1
a1589 1
    return TRUE;
d1608 1
a1608 1
      bfd_boolean unresolved_reloc;
d1613 2
a1614 2
	  || r_type == (int) R_390_GNU_VTENTRY)
	continue;
d1618 1
a1618 1
	  return FALSE;
d1626 1
a1626 1
      unresolved_reloc = FALSE;
d1650 1
a1650 1
		  unresolved_reloc = TRUE;
d1669 1
a1669 1
		      input_section, rel->r_offset,
d1672 1
a1672 1
		return FALSE;
d1679 7
a1685 7
	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT32:
	case R_390_GOT64:
	case R_390_GOTENT:
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
d1689 3
a1691 3
	  if (h != NULL)
	    {
	      bfd_boolean dyn;
d1693 1
a1693 1
	      off = h->got.offset;
d1695 3
a1697 3
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
		  || (info->shared
		      && (info->symbolic
d1700 18
a1717 18
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 2, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rel.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
d1720 3
a1722 3
		      h->got.offset |= 1;
		    }
		}
d1724 4
a1727 4
		unresolved_reloc = FALSE;
	    }
	  else
	    {
d1731 1
a1731 1
	      off = local_got_offsets[r_symndx];
d1733 8
a1740 8
	      /* The offset must always be a multiple of 8.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_64 (output_bfd, relocation,
d1743 5
a1747 5
		  if (info->shared)
		    {
		      asection *s;
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;
d1749 2
a1750 2
		      s = htab->srelgot;
		      if (s == NULL)
d1753 4
a1756 4
		      outrel.r_offset = (htab->sgot->output_section->vma
					 + htab->sgot->output_offset
					 + off);
		      outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
d1758 8
a1765 8
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		    }

		  local_got_offsets[r_symndx] |= 1;
		}
	    }
d1781 1
a1781 5
	  break;

	case R_390_GOTOFF:
	  /* Relocation is relative to the start of the global offset
	     table.  */
d1783 10
a1792 6
	  /* Note that sgot->output_offset is not involved in this
	     calculation.  We always want the start of .got.  If we
	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
	     permitted by the ABI, we might have to change this
	     calculation.  */
	  relocation -= htab->sgot->output_section->vma;
d1794 1
a1794 1
	  break;
d1796 1
a1796 1
	case R_390_GOTPC:
d1798 16
a1813 4
	  /* Use global offset table as symbol value.  */
	  relocation = htab->sgot->output_section->vma;
	  unresolved_reloc = FALSE;
	  break;
d1815 1
a1815 13
	case R_390_PLT16DBL:
	case R_390_PLT32:
	case R_390_PLT32DBL:
	case R_390_PLT64:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLT32 reloc against a local symbol directly,
	     without using the procedure linkage table.  */
	  if (h == NULL)
	    break;

	  if (h->plt.offset == (bfd_vma) -1
d1817 20
a1836 20
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
	    }

	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
			+ h->plt.offset);
	  unresolved_reloc = FALSE;
	  break;

	case R_390_8:
	case R_390_16:
	case R_390_32:
	case R_390_64:
	case R_390_PC16:
	case R_390_PC16DBL:
	case R_390_PC32:
d1838 1
a1838 1
	case R_390_PC64:
d1842 2
a1843 2
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
d1846 1
a1846 1
	  if ((info->shared
d1867 3
a1869 3
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip, relocate;
d1871 1
a1871 1
	      bfd_byte *loc;
d1873 3
a1875 3
	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */
d1877 2
a1878 2
	      skip = FALSE;
	      relocate = FALSE;
d1884 1
a1884 1
		skip = TRUE;
d1886 1
a1886 1
		skip = TRUE, relocate = TRUE;
d1888 2
a1889 2
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);
d1891 1
a1891 1
	      if (skip)
d1893 1
a1893 1
	      else if (h != NULL
d1904 2
a1905 2
		{
		  outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
d1907 3
a1909 3
		}
	      else
		{
d1911 1
a1911 1
		  relocate = TRUE;
d1920 17
a1936 17
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	      /* If this reloc is against an external symbol, we do
		 not want to fiddle with the addend.  Otherwise, we
		 need to include the symbol value so that it becomes
		 an addend for the dynamic reloc.  */
	      if (! relocate)
		continue;
	    }

	  break;

	default:
	  break;
	}
d1967 1
a1967 1
		return FALSE;
d1978 1
a1978 1
		return FALSE;
d1987 1
a1987 1
	      return FALSE;
d1992 1
a1992 1
  return TRUE;
d1998 1
a1998 1
static bfd_boolean
d2014 1
a2014 1
      bfd_byte *loc;
d2017 1
a2017 1
	 it up.  */
d2026 1
a2026 1
	 Current offset - size first entry / entry size.  */
d2030 1
a2030 1
	 addr & GOT addr.  */
d2065 1
a2065 1
	 Points to instruction after GOT offset.  */
d2079 1
a2079 1
      loc = htab->srelplt->contents + plt_index * sizeof (Elf64_External_Rela);
d2096 1
a2096 1
      bfd_byte *loc;
d2099 1
a2099 1
	 up.  */
d2118 1
a2118 1
	{
d2120 5
a2124 5
	  rela.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
	  rela.r_addend = (h->root.u.def.value
			   + h->root.u.def.section->output_section->vma
			   + h->root.u.def.section->output_offset);
	}
d2130 2
a2131 2
	  rela.r_addend = 0;
	}
d2133 2
a2134 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d2141 1
a2141 1
      bfd_byte *loc;
d2156 2
a2157 2
      loc = htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++ * sizeof (Elf64_External_Rela);
d2167 1
a2167 1
  return TRUE;
d2192 1
a2192 1
static bfd_boolean
d2308 1
a2308 1
  return TRUE;
d2311 1
a2311 1
static bfd_boolean
d2334 2
a2335 2
  8,		/* hash-table entry size */
  1,		/* internal relocations per external relocations */
d2348 4
a2351 4
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
d2391 1
a2391 1
#define elf_backend_object_p		      elf_s390_object_p
@


1.31.10.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a53 3
struct elf_s390_link_hash_entry;
static void elf_s390_adjust_gotplt
  PARAMS ((struct elf_s390_link_hash_entry *));
d72 1
a72 14
static bfd_boolean elf_s390_mkobject
  PARAMS ((bfd *));
static bfd_boolean elf_s390_object_p
  PARAMS ((bfd *));
static int elf_s390_tls_transition
  PARAMS ((struct bfd_link_info *, int, int));
static bfd_reloc_status_type s390_tls_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
static void invalid_tls_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *));
d97 26
a122 106
  HOWTO(R_390_8,         0, 0,  8, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_8",        FALSE, 0,0x000000ff, FALSE),
  HOWTO(R_390_12,        0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_12",       FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_16,        0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_16",       FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_32,        0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_32",       FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PC32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32",     FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_GOT12",    FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT32",    FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLT32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32",    FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_COPY,      0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_COPY",     FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GLOB_DAT,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GLOB_DAT", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_JMP_SLOT,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_JMP_SLOT", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_RELATIVE,  0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_RELATIVE", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF32", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTPC,     0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPC",    FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOT16,     0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT16",    FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PC16,      0, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16",     FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16DBL",  FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT16DBL", FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32DBL",  FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32DBL", FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPCDBL", FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_64,        0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_64",       FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_PC64,	 0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC64",     FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOT64,	 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT64",    FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_PLT64,	 0, 4, 64,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT64",    FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOTENT,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTENT",   FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_GOTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_GOTOFF64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF64", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTPLT12,	 0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_GOTPLT12", FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOTPLT16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_GOTPLT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT32", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTPLT64,	 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT64", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_GOTPLTENT, 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLTENT",FALSE, 0,MINUS_ONE,  TRUE),
  HOWTO(R_390_PLTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PLTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF32", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLTOFF64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF64", FALSE, 0,MINUS_ONE,  FALSE),
  HOWTO(R_390_TLS_LOAD, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LOAD", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_GDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_GDCALL", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_LDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LDCALL", FALSE, 0, 0, FALSE),
  EMPTY_HOWTO (R_390_TLS_GD32),	/* Empty entry for R_390_TLS_GD32.  */
  HOWTO(R_390_TLS_GD64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GD64", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_GOTIE12, 0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE12", FALSE, 0, 0x00000fff, FALSE),
  EMPTY_HOWTO (R_390_TLS_GOTIE32),	/* Empty entry for R_390_TLS_GOTIE32.  */
  HOWTO(R_390_TLS_GOTIE64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE64", FALSE, 0, MINUS_ONE, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDM32),	/* Empty entry for R_390_TLS_LDM32.  */
  HOWTO(R_390_TLS_LDM64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDM64", FALSE, 0, MINUS_ONE, FALSE),
  EMPTY_HOWTO (R_390_TLS_IE32),	/* Empty entry for R_390_TLS_IE32.  */
  HOWTO(R_390_TLS_IE64,  0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IE64", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_IEENT, 1, 2, 32, TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IEENT", FALSE, 0, MINUS_ONE, TRUE),
  EMPTY_HOWTO (R_390_TLS_LE32),	/* Empty entry for R_390_TLS_LE32.  */
  HOWTO(R_390_TLS_LE64,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LE64", FALSE, 0, MINUS_ONE, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDO32),	/* Empty entry for R_390_TLS_LDO32.  */
  HOWTO(R_390_TLS_LDO64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDO64", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_DTPMOD, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPMOD", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_DTPOFF, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPOFF", FALSE, 0, MINUS_ONE, FALSE),
  HOWTO(R_390_TLS_TPOFF, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_TPOFF", FALSE, 0, MINUS_ONE, FALSE),
d167 1
a167 1
      return &elf_howto_table[(int) R_390_GOTOFF32];
d178 4
a197 52
    case BFD_RELOC_16_GOTOFF:
      return &elf_howto_table[(int) R_390_GOTOFF16];
    case BFD_RELOC_390_GOTOFF64:
      return &elf_howto_table[(int) R_390_GOTOFF64];
    case BFD_RELOC_390_GOTPLT12:
      return &elf_howto_table[(int) R_390_GOTPLT12];
    case BFD_RELOC_390_GOTPLT16:
      return &elf_howto_table[(int) R_390_GOTPLT16];
    case BFD_RELOC_390_GOTPLT32:
      return &elf_howto_table[(int) R_390_GOTPLT32];
    case BFD_RELOC_390_GOTPLT64:
      return &elf_howto_table[(int) R_390_GOTPLT64];
    case BFD_RELOC_390_GOTPLTENT:
      return &elf_howto_table[(int) R_390_GOTPLTENT];
    case BFD_RELOC_390_PLTOFF16:
      return &elf_howto_table[(int) R_390_PLTOFF16];
    case BFD_RELOC_390_PLTOFF32:
      return &elf_howto_table[(int) R_390_PLTOFF32];
    case BFD_RELOC_390_PLTOFF64:
      return &elf_howto_table[(int) R_390_PLTOFF64];
    case BFD_RELOC_390_TLS_LOAD:
      return &elf_howto_table[(int) R_390_TLS_LOAD];
    case BFD_RELOC_390_TLS_GDCALL:
      return &elf_howto_table[(int) R_390_TLS_GDCALL];
    case BFD_RELOC_390_TLS_LDCALL:
      return &elf_howto_table[(int) R_390_TLS_LDCALL];
    case BFD_RELOC_390_TLS_GD64:
      return &elf_howto_table[(int) R_390_TLS_GD64];
    case BFD_RELOC_390_TLS_GOTIE12:
      return &elf_howto_table[(int) R_390_TLS_GOTIE12];
    case BFD_RELOC_390_TLS_GOTIE64:
      return &elf_howto_table[(int) R_390_TLS_GOTIE64];
    case BFD_RELOC_390_TLS_LDM64:
      return &elf_howto_table[(int) R_390_TLS_LDM64];
    case BFD_RELOC_390_TLS_IE64:
      return &elf_howto_table[(int) R_390_TLS_IE64];
    case BFD_RELOC_390_TLS_IEENT:
      return &elf_howto_table[(int) R_390_TLS_IEENT];
    case BFD_RELOC_390_TLS_LE64:
      return &elf_howto_table[(int) R_390_TLS_LE64];
    case BFD_RELOC_390_TLS_LDO64:
      return &elf_howto_table[(int) R_390_TLS_LDO64];
    case BFD_RELOC_390_TLS_DTPMOD:
      return &elf_howto_table[(int) R_390_TLS_DTPMOD];
    case BFD_RELOC_390_TLS_DTPOFF:
      return &elf_howto_table[(int) R_390_TLS_DTPOFF];
    case BFD_RELOC_390_TLS_TPOFF:
      return &elf_howto_table[(int) R_390_TLS_TPOFF];
    case BFD_RELOC_VTABLE_INHERIT:
      return &elf64_s390_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf64_s390_vtentry_howto;
a228 17
/* A relocation function which doesn't do anything.  */
static bfd_reloc_status_type
s390_tls_reloc (abfd, reloc_entry, symbol, data, input_section,
                      output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

a359 10

  /* Number of GOTPLT references for a function.  */
  bfd_signed_vma gotplt_refcount;

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2
#define GOT_TLS_IE	3
#define GOT_TLS_IE_NLT	3
  unsigned char tls_type;
a361 44
#define elf_s390_hash_entry(ent) \
  ((struct elf_s390_link_hash_entry *)(ent))

struct elf_s390_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
};

#define elf_s390_tdata(abfd) \
  ((struct elf_s390_obj_tdata *) (abfd)->tdata.any)

#define elf_s390_local_got_tls_type(abfd) \
  (elf_s390_tdata (abfd)->local_got_tls_type)

static bfd_boolean
elf_s390_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
  return TRUE;
}

static bfd_boolean
elf_s390_object_p (abfd)
     bfd *abfd;
{
  /* Allocate our special target data.  */
  struct elf_s390_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return FALSE;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;
  /* Set the right machine number for an s390 elf32 file.  */
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_64);
}

a376 5
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ldm_got;

a411 2
      eh->gotplt_refcount = 0;
      eh->tls_type = GOT_UNKNOWN;
a442 1
  ret->tls_ldm_got.refcount = 0;
a554 7
  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }

a557 27
static int
elf_s390_tls_transition (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_390_TLS_GD64:
    case R_390_TLS_IE64:
      if (is_local)
	return R_390_TLS_LE64;
      return R_390_TLS_IE64;
    case R_390_TLS_GOTIE64:
      if (is_local)
	return R_390_TLS_LE64;
      return R_390_TLS_GOTIE64;
    case R_390_TLS_LDM64:
      return R_390_TLS_LE64;
    }

  return r_type;
}

a574 2
  bfd_signed_vma *local_got_refcounts;
  int tls_type, old_tls_type;
a581 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
a587 1
      unsigned int r_type;
d606 1
a606 6
      /* Create got section and local_got_refcounts array if they
	 are needed.  */
      r_type = elf_s390_tls_transition (info,
					ELF64_R_TYPE (rel->r_info),
					h == NULL);
      switch (r_type)
d613 11
a623 20
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	case R_390_TLS_GD64:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE64:
	case R_390_TLS_IEENT:
	case R_390_TLS_IE64:
	case R_390_TLS_LDM64:
	  if (h == NULL
	      && local_got_refcounts == NULL)
	    {
	      bfd_size_type size;

	      size = symtab_hdr->sh_info;
	      size *= (sizeof (bfd_signed_vma) + sizeof(char));
	      local_got_refcounts = ((bfd_signed_vma *)
				     bfd_zalloc (abfd, size));
d625 16
a640 9
		return FALSE;
	      elf_local_got_refcounts (abfd) = local_got_refcounts;
	      elf_s390_local_got_tls_type (abfd)
		= (char *) (local_got_refcounts + symtab_hdr->sh_info);
	    }
	  /* Fall through.  */
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
a649 10
	}

      switch (r_type)
	{
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	  /* Got is created, nothing to be done.  */
a655 3
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	case R_390_PLTOFF64:
d665 2
a666 6
	  if (h != NULL)
	    {
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->plt.refcount += 1;
	    }
	  break;
d668 2
a669 25
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	  /* This symbol requires either a procedure linkage table entry
	     or an entry in the local got. We actually build the entry
	     in adjust_dynamic_symbol because whether this is really a
	     global reference can change and with it the fact if we have
	     to create a plt entry or a local got entry. To be able to
	     make a once global symbol a local one we have to keep track
	     of the number of gotplt references that exist for this
	     symbol.  */
	  if (h != NULL)
	    {
	      ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount++;
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->plt.refcount += 1;
	    }
	  else
	    local_got_refcounts[r_symndx] += 1;
	  break;

	case R_390_TLS_LDM64:
	  htab->tls_ldm_got.refcount += 1;
a671 80
	case R_390_TLS_IE64:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE64:
	case R_390_TLS_IEENT:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  /* Fall through */

	case R_390_GOT12:
        case R_390_GOT16:
	case R_390_GOT32:
	case R_390_GOT64:
	case R_390_GOTENT:
	case R_390_TLS_GD64:
	  /* This symbol requires a global offset table entry.  */
	  switch (r_type)
	    {
	    default:
	    case R_390_GOT12:
	    case R_390_GOT16:
	    case R_390_GOT32:
	    case R_390_GOTENT:
	      tls_type = GOT_NORMAL;
	      break;
	    case R_390_TLS_GD64:
	      tls_type = GOT_TLS_GD;
	      break;
	    case R_390_TLS_IE64:
	    case R_390_TLS_GOTIE64:
	      tls_type = GOT_TLS_IE;
	      break;
	    case R_390_TLS_GOTIE12:
	    case R_390_TLS_IEENT:
	      tls_type = GOT_TLS_IE_NLT;
	      break;
	    }

	  if (h != NULL)
	    {
	      h->got.refcount += 1;
	      old_tls_type = elf_s390_hash_entry(h)->tls_type;
	    }
	  else
	    {
	      local_got_refcounts[r_symndx] += 1;
	      old_tls_type = elf_s390_local_got_tls_type (abfd) [r_symndx];
	    }
	  /* If a TLS symbol is accessed using IE at least once,
	     there is no point to use dynamic model for it.  */
	  if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN)
	    {
	      if (old_tls_type == GOT_NORMAL || tls_type == GOT_NORMAL)
		{
		  (*_bfd_error_handler)
		    (_("%s: `%s' accessed both as normal and thread local symbol"),
		     bfd_archive_filename (abfd), h->root.root.string);
		  return FALSE;
		}
	      if (old_tls_type > tls_type)
		tls_type = old_tls_type;
	    }

	  if (old_tls_type != tls_type)
	    {
	      if (h != NULL)
		elf_s390_hash_entry (h)->tls_type = tls_type;
	      else
		elf_s390_local_got_tls_type (abfd) [r_symndx] = tls_type;
	    }

	  if (r_type != R_390_TLS_IE64)
	    break;
	  /* Fall through */

	case R_390_TLS_LE64:
	  if (!info->shared)
	    break;
	  info->flags |= DF_STATIC_TLS;
	  /* Fall through */

a907 1
  int r_type;
d918 23
a940 2
    {
      r_symndx = ELF64_R_SYM (rel->r_info);
d942 18
a959 48
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];

      r_type = elf_s390_tls_transition (info,
					ELF64_R_TYPE (rel->r_info),
					r_symndx >= symtab_hdr->sh_info);
      switch (r_type)
	{
	case R_390_TLS_LDM64:
	  if (elf_s390_hash_table (info)->tls_ldm_got.refcount > 0)
	    elf_s390_hash_table (info)->tls_ldm_got.refcount -= 1;
	  break;

	case R_390_TLS_GD64:
	case R_390_TLS_IE64:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE64:
	case R_390_TLS_IEENT:
	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT32:
	case R_390_GOT64:
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	case R_390_GOTENT:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  if (r_type != R_390_TLS_IE64)
	    break;
	  /* Fall through */
	  
	case R_390_TLS_LE64:
	  if (!info->shared)
	    break;
	  /* Fall through */
d961 2
a962 37
	case R_390_8:
	case R_390_12:
	case R_390_16:
	case R_390_32:
	case R_390_64:
	case R_390_PC16:
	case R_390_PC16DBL:
	case R_390_PC32:
	case R_390_PC32DBL:
	case R_390_PC64:
	  if (h != NULL)
	    {
	      struct elf_s390_link_hash_entry *eh;
	      struct elf_s390_dyn_relocs **pp;
	      struct elf_s390_dyn_relocs *p;
	      
	      if (!info->shared && h->plt.refcount > 0)
		h->plt.refcount -= 1;
	      
	      eh = (struct elf_s390_link_hash_entry *) h;
	      
	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    if (ELF64_R_TYPE (rel->r_info) == R_390_PC16
			|| ELF64_R_TYPE (rel->r_info) == R_390_PC16DBL
			|| ELF64_R_TYPE (rel->r_info) == R_390_PC32
			|| ELF64_R_TYPE (rel->r_info) == R_390_PC32DBL
			|| ELF64_R_TYPE (rel->r_info) == R_390_PC64)
		      p->pc_count -= 1;
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	    }
	  break;
d964 1
a964 13
	case R_390_PLT16DBL:
	case R_390_PLT32:
	case R_390_PLT32DBL:
	case R_390_PLT64:
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	case R_390_PLTOFF64:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;
d966 2
a967 8
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
d969 8
a976 2
		  ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount--;
		  h->plt.refcount -= 1;
d978 15
a992 7
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d994 3
a996 4
	default:
	  break;
	}
    }
a1000 23
/* Make sure we emit a GOT entry if the symbol was supposed to have a PLT
   entry but we found we will not create any.  Called when we find we will
   not have any PLT for this symbol, by for example
   elf_s390_adjust_dynamic_symbol when we're doing a proper dynamic link,
   or elf_s390_size_dynamic_sections if no dynamic sections will be
   created (we're only linking static objects).  */

static void
elf_s390_adjust_gotplt (h)
     struct elf_s390_link_hash_entry *h;
{
  if (h->elf.root.type == bfd_link_hash_warning)
    h = (struct elf_s390_link_hash_entry *) h->elf.root.u.i.link;

  if (h->gotplt_refcount <= 0)
    return;

  /* We simply add the number of gotplt references to the number
   * of got references for this symbol.  */
  h->elf.got.refcount += h->gotplt_refcount;
  h->gotplt_refcount = -1;
}

a1037 1
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
a1173 3
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
a1227 1
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
a1233 1
      elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
d1236 1
a1236 21
  /* If R_390_TLS_{IE64,GOTIE64,GOTIE12,IEENT} symbol is now local to
     the binary, we can optimize a bit. IE64 and GOTIE64 get converted
     to R_390_TLS_LE64 requiring no TLS entry. For GOTIE12 and IEENT
     we can save the dynamic TLS relocation.  */
  if (h->got.refcount > 0
      && !info->shared
      && h->dynindx == -1
      && elf_s390_hash_entry(h)->tls_type >= GOT_TLS_IE)
    {
      if (elf_s390_hash_entry(h)->tls_type == GOT_TLS_IE_NLT)
	/* For the GOTIE access without a literal pool entry the offset has
	   to be stored somewhere. The immediate value in the instruction
	   is not bit enough so the value is stored in the got.  */
	{
	  h->got.offset = htab->sgot->_raw_size;
	  htab->sgot->_raw_size += GOT_ENTRY_SIZE;
	}
      else
	h->got.offset = (bfd_vma) -1;
    }
  else if (h->got.refcount > 0)
a1239 1
      int tls_type = elf_s390_hash_entry(h)->tls_type;
a1252 3
      /* R_390_TLS_GD64 needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->_raw_size += GOT_ENTRY_SIZE;
d1254 1
a1254 8
      /* R_390_TLS_IE64 needs one dynamic relocation,
	 R_390_TLS_GD64 needs one if local symbol and two if global.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type >= GOT_TLS_IE)
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->srelgot->_raw_size += 2 * sizeof (Elf64_External_Rela);
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
a1399 1
      char *local_tls_type;
a1440 1
      local_tls_type = elf_s390_local_got_tls_type (ibfd);
d1443 1
a1443 1
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
a1448 2
	      if (*local_tls_type == GOT_TLS_GD)
		s->_raw_size += GOT_ENTRY_SIZE;
a1456 11
  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_390_TLS_LDM64
	 relocs.  */
      htab->tls_ldm_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

a1566 52
/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (info)
     struct bfd_link_info *info;
{
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
    return 0;
  return elf_hash_table (info)->tls_segment->start;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
{
  struct elf_link_tls_segment *tls_segment
    = elf_hash_table (info)->tls_segment;

  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (tls_segment == NULL)
    return 0;
  return (align_power (tls_segment->size, tls_segment->align)
	  + tls_segment->start - address);
}

/* Complain if TLS instruction relocation is against an invalid
   instruction.  */

static void
invalid_tls_insn (input_bfd, input_section, rel)
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *rel;
{
  reloc_howto_type *howto;

  howto = elf_howto_table + ELF64_R_TYPE (rel->r_info);
  (*_bfd_error_handler)
    (_("%s(%s+0x%lx): invalid instruction for TLS relocation %s"),
     bfd_archive_filename (input_bfd),
     bfd_get_section_name (input_bfd, input_section),
     (long) rel->r_offset,
     howto->name);
}

d1600 1
a1600 1
      unsigned int r_type;
a1609 1
      int tls_type;
d1615 1
a1615 1
      if (r_type >= (int) R_390_max)
a1622 2

      /* This is a final link.  */
a1678 34
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT32:
	case R_390_GOTPLT64:
	case R_390_GOTPLTENT:
	  /* There are three cases for a GOTPLT relocation. 1) The
	     relocation is against the jump slot entry of a plt that
	     will get emitted to the output file. 2) The relocation
	     is against the jump slot of a plt entry that has been
	     removed. elf_s390_adjust_gotplt has created a GOT entry
	     as replacement. 3) The relocation is against a local symbol.
	     Cases 2) and 3) are the same as the GOT relocation code
	     so we just have to test for case 1 and fall through for
	     the other two.  */
	  if (h != NULL && h->plt.offset != (bfd_vma) -1)
	    {
	      bfd_vma plt_index;

	      /* Calc. index no.
		 Current offset - size first entry / entry size.  */
	      plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) /
		PLT_ENTRY_SIZE;
	      
	      /* Offset in GOT is PLT index plus GOT headers(3) times 4,
		 addr & GOT addr.  */
	      relocation = (plt_index + 3) * GOT_ENTRY_SIZE;
	      unresolved_reloc = FALSE;

	      if (r_type == R_390_GOTPLTENT)
		relocation += htab->sgot->output_section->vma;	    
	      break;
	    }
	  /* Fall through.  */

d1778 1
a1778 2
	  if (   r_type == R_390_GOTENT
	      || r_type == R_390_GOTPLTENT)
d1783 1
a1783 3
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTOFF64:
d1793 1
a1827 23
          break;

	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	case R_390_PLTOFF64:
          /* Relocation is to the entry for this symbol in the
             procedure linkage table relative to the start of the GOT.  */

	  /* For local symbols or if we didn't make a PLT entry for
	     this symbol resolve the symbol directly.  */
          if (   h == NULL
	      || h->plt.offset == (bfd_vma) -1
	      || htab->splt == NULL)
	    {
	      relocation -= htab->sgot->output_section->vma;
	      break;
	    }

          relocation = (htab->splt->output_section->vma
                        + htab->splt->output_offset
                        + h->plt.offset
			- htab->sgot->output_section->vma);
	  unresolved_reloc = FALSE;
a1933 340
	  /* Relocations for tls literal pool entries.  */
	case R_390_TLS_IE64:
	  if (info->shared)
	    {
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloc_out (output_bfd, &outrel, loc);
	    }
	  /* Fall through */

	case R_390_TLS_GD64:
	case R_390_TLS_GOTIE64:
	  r_type = elf_s390_tls_transition (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (!info->shared && h->dynindx == -1 && tls_type >= GOT_TLS_IE)
		r_type = R_390_TLS_LE64;
	    }
	  if (r_type == R_390_TLS_GD64 && tls_type >= GOT_TLS_IE)
	    r_type = R_390_TLS_IE64;

	  if (r_type == R_390_TLS_LE64)
	    {
	      /* This relocation gets optimized away by the local exec
		 access optimization.  */
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_64 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	      continue;
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	emit_tls_relocs:

	  if ((off & 1) != 0)
	    off &= ~1;
          else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      int dr_type, indx;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
	      if (r_type == R_390_TLS_GD64)
		dr_type = R_390_TLS_DTPMOD;
	      else
		dr_type = R_390_TLS_TPOFF;
	      if (dr_type == R_390_TLS_TPOFF && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      outrel.r_info = ELF64_R_INFO (indx, dr_type);
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
		* sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	      if (r_type == R_390_TLS_GD64)
		{
		  if (indx == 0)
		    {
	    	      BFD_ASSERT (! unresolved_reloc);
		      bfd_put_64 (output_bfd,
				  relocation - dtpoff_base (info),
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
		    }
		  else
		    {
		      outrel.r_info = ELF64_R_INFO (indx, R_390_TLS_DTPOFF);
		      outrel.r_offset += GOT_ENTRY_SIZE;
		      outrel.r_addend = 0;
		      htab->srelgot->reloc_count++;
		      loc += sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		    }
		}

	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();
	  if (r_type == ELF64_R_TYPE (rel->r_info))
	    {
	      relocation = htab->sgot->output_offset + off;
	      if (r_type == R_390_TLS_IE64 || r_type == R_390_TLS_IEENT)
		relocation += htab->sgot->output_section->vma;
	      unresolved_reloc = FALSE;
	    }
	  else
	    {
	      bfd_put_64 (output_bfd, htab->sgot->output_offset + off,
			  contents + rel->r_offset);
	      continue;
	    }
	  break;

	case R_390_TLS_GOTIE12:
	case R_390_TLS_IEENT:
	  if (h == NULL)
	    {
	      if (local_got_offsets == NULL)
		abort();
	      off = local_got_offsets[r_symndx];
	      if (info->shared)
		goto emit_tls_relocs;
	    }
	  else
	    {
	      off = h->got.offset;
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (info->shared || h->dynindx != -1 || tls_type < GOT_TLS_IE)
		goto emit_tls_relocs;
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  BFD_ASSERT (! unresolved_reloc);
	  bfd_put_64 (output_bfd, -tpoff (info, relocation),
		      htab->sgot->contents + off);
	  relocation = htab->sgot->output_offset + off;
	  if (r_type == R_390_TLS_IEENT)
	    relocation += htab->sgot->output_section->vma;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_TLS_LDM64:
	  if (! info->shared)
	    /* The literal pool entry this relocation refers to gets ignored
	       by the optimized code of the local exec model. Do nothing
	       and the value will turn out zero.  */
	    continue;

	  if (htab->sgot == NULL)
	    abort ();

	  off = htab->tls_ldm_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      bfd_put_64 (output_bfd, 0,
			  htab->sgot->contents + off + GOT_ENTRY_SIZE);
	      outrel.r_info = ELF64_R_INFO (0, R_390_TLS_DTPMOD);
	      outrel.r_addend = 0;
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
		* sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ldm_got.offset |= 1;
	    }
	  relocation = htab->sgot->output_offset + off;
	  unresolved_reloc = FALSE;	  
	  break;

	case R_390_TLS_LE64:
	  if (info->shared)
	    {
	      /* Linking a shared library with non-fpic code requires
		 a R_390_TLS_TPOFF relocation.  */
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;
	      int indx;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      if (h != NULL && h->dynindx != -1)
		indx = h->dynindx;
	      else
		indx = 0;
	      outrel.r_info = ELF64_R_INFO (indx, R_390_TLS_TPOFF);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
	    }
	  else
	    {
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_64 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	    }
	  continue;

	case R_390_TLS_LDO64:
	  if (info->shared || (input_section->flags & SEC_CODE) == 0)
	    relocation -= dtpoff_base (info);
	  else
	    /* When converting LDO to LE, we must negate.  */
	    relocation = -tpoff (info, relocation);
	  break;

	  /* Relocations for tls instructions.  */
	case R_390_TLS_LOAD:
	case R_390_TLS_GDCALL:
	case R_390_TLS_LDCALL:
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    tls_type = elf_s390_hash_entry(h)->tls_type;

	  if (tls_type == GOT_TLS_GD)
	    continue;

	  if (r_type == R_390_TLS_LOAD)
	    {
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		{
		  /* IE->LE transition. Four valid cases:
		     lg %rx,(0,%ry)    -> sllg %rx,%ry,0
		     lg %rx,(%ry,0)    -> sllg %rx,%ry,0
		     lg %rx,(%ry,%r12) -> sllg %rx,%ry,0
		     lg %rx,(%r12,%ry) -> sllg %rx,%ry,0  */
		  unsigned int insn0, insn1, ry;

		  insn0 = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  insn1 = bfd_get_16 (input_bfd, contents + rel->r_offset + 4);
		  if (insn1 != 0x0004)
		    invalid_tls_insn (input_bfd, input_section, rel);
		  ry = 0;
		  if ((insn0 & 0xff00f000) == 0xe3000000)
		    /* lg %rx,0(%ry,0) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x000f0000);
		  else if ((insn0 & 0xff0f0000) == 0xe3000000)
		    /* lg %rx,0(0,%ry) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x0000f000) << 4;
		  else if ((insn0 & 0xff00f000) == 0xe300c000)
		    /* lg %rx,0(%ry,%r12) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x000f0000);
		  else if ((insn0 & 0xff0f0000) == 0xe30c0000)
		    /* lg %rx,0(%r12,%ry) -> sllg %rx,%ry,0  */
		    ry = (insn0 & 0x0000f000) << 4;
		  else
		    invalid_tls_insn (input_bfd, input_section, rel);
		  insn0 = 0xeb000000 | (insn0 & 0x00f00000) | ry;
		  insn1 = 0x000d;
		  bfd_put_32 (output_bfd, insn0, contents + rel->r_offset);
		  bfd_put_16 (output_bfd, insn1, contents + rel->r_offset + 4);
		}
	    }
	  else if (r_type == R_390_TLS_GDCALL)
	    {
	      unsigned int insn0, insn1;

	      insn0 = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      insn1 = bfd_get_16 (input_bfd, contents + rel->r_offset + 4);
	      if ((insn0 & 0xffff0000) != 0xc0e50000)
		invalid_tls_insn (input_bfd, input_section, rel);
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		{
		  /* GD->LE transition.
		     brasl %r14,__tls_get_addr@@plt -> brcl 0,. */
		  insn0 = 0xc0040000;
		  insn1 = 0x0000;
		}
	      else
		{
		  /* GD->IE transition.
		     brasl %r14,__tls_get_addr@@plt -> lg %r2,0(%r2,%r12)  */
		  insn0 = 0xe322c000;
		  insn1 = 0x0004;
		}
	      bfd_put_32 (output_bfd, insn0, contents + rel->r_offset);
	      bfd_put_16 (output_bfd, insn1, contents + rel->r_offset + 4);
	    }
	  else if (r_type == R_390_TLS_LDCALL)
	    {
	      if (!info->shared)
		{
		  unsigned int insn0, insn1;

		  insn0 = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  insn1 = bfd_get_16 (input_bfd, contents + rel->r_offset + 4);
		  if ((insn0 & 0xffff0000) != 0xc0e50000)
		    invalid_tls_insn (input_bfd, input_section, rel);
		  /* LD->LE transition.
		     brasl %r14,__tls_get_addr@@plt -> brcl 0,. */
		  insn0 = 0xc0040000;
		  insn1 = 0x0000;
		  bfd_put_32 (output_bfd, insn0, contents + rel->r_offset);
		  bfd_put_16 (output_bfd, insn1, contents + rel->r_offset + 4);
		}
	    }
	  continue;

d2093 1
a2093 4
  if (h->got.offset != (bfd_vma) -1
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_GD
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE_NLT)
d2311 7
d2391 1
a2391 2
#define bfd_elf64_mkobject		elf_s390_mkobject
#define elf_backend_object_p		elf_s390_object_p
@


1.31.10.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d376 1
a376 1
		output_bfd, error_message)
d989 1
a989 1
	case R_390_GOT16:
d1295 3
a1307 4
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;

a1308 5
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf_s390_link_hash_entry *eh;
	  struct elf_s390_dyn_relocs **pp;
	  struct elf_s390_dyn_relocs *p;
d1310 4
a1313 2
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct elf_s390_link_hash_entry *) h;
d1315 3
a1317 11
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      r_type = ELF64_R_TYPE (rel->r_info);
      r_type = elf_s390_tls_transition (info, r_type, h != NULL);
d1350 8
a1357 1
	  break;
d1369 27
a1395 3
	  if (info->shared)
	    break;
	  /* Fall through */
d2229 1
d2269 1
a2269 1

d2276 1
a2276 1
		relocation += htab->sgot->output_section->vma;
d2374 6
a2379 4
	  /* For @@GOTENT the relocation is against the offset between
	     the instruction and the symbols entry in the GOT and not
	     between the start of the GOT and the symbols entry. We
	     add the vma of the GOT to get the correct value.  */
d2432 1
a2432 1
	  break;
d2437 2
a2438 2
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table relative to the start of the GOT.  */
d2442 1
a2442 1
	  if (   h == NULL
d2450 3
a2452 3
	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
			+ h->plt.offset
d2503 1
d2580 1
a2580 1
	  /* Fall through.  */
d2624 1
a2624 1
	  else
d2759 1
a2759 1
	  unresolved_reloc = FALSE;
d3070 1
d3281 5
a3285 3
/* Why was the hash table entry size definition changed from
   ARCH_SIZE/8 to 4? This breaks the 64 bit dynamic linker and
   this is the only reason for the s390_elf64_size_info structure.  */
d3297 4
a3300 4
  8,		/* hash-table entry size.  */
  1,		/* internal relocations per external relocations.  */
  64,		/* arch_size.  */
  8,		/* file_align.  */
@


1.31.10.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a407 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d785 1
a785 12
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1117 1
a1117 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1455 2
a1501 4
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1527 2
a1528 1
  if (ELIMINATE_COPY_RELOCS)
d1530 4
a1533 2
      struct elf_s390_link_hash_entry * eh;
      struct elf_s390_dyn_relocs *p;
d1535 6
a1540 15
      eh = (struct elf_s390_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1593 1
a1593 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d1595 1
a1595 1
   && ((SHARED)								\
d1626 1
a1626 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d1637 1
a1637 2
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d1733 1
a1733 4
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
a1766 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d1768 1
a1768 1
  else if (ELIMINATE_COPY_RELOCS)
d2277 1
a2277 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d2282 1
a2282 3
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
a2451 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d2462 1
a2462 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d3274 1
a3274 1
  3,		/* log_file_align.  */
@


1.31.10.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d852 1
a852 1
  if (info->relocatable)
d1901 1
a1901 1
      if (info->executable)
d2059 1
a2059 1
      if (info->executable)
d2172 1
a2172 1
  if (info->relocatable)
@


1.31.10.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a88 2
static bfd_reloc_status_type s390_elf_ldisp_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d123 1
a123 1
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_bitfield,
a218 8
  HOWTO(R_390_20,        0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_20",      FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOT20,	 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOT20",   FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOTPLT20,  0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOTPLT20", FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_TLS_GOTIE20, 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_TLS_GOTIE20", FALSE, 0,0x0fffff00, FALSE),
a337 8
    case BFD_RELOC_390_20:
      return &elf_howto_table[(int) R_390_20];
    case BFD_RELOC_390_GOT20:
      return &elf_howto_table[(int) R_390_GOT20];
    case BFD_RELOC_390_GOTPLT20:
      return &elf_howto_table[(int) R_390_GOTPLT20];
    case BFD_RELOC_390_TLS_GOTIE20:
      return &elf_howto_table[(int) R_390_TLS_GOTIE20];
a389 52
/* Handle the large displacement relocs.  */
static bfd_reloc_status_type
s390_elf_ldisp_reloc (abfd, reloc_entry, symbol, data, input_section,
                      output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  reloc_howto_type *howto = reloc_entry->howto;
  bfd_vma relocation;
  bfd_vma insn;

  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
  if (output_bfd != NULL)
    return bfd_reloc_continue;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  relocation = (symbol->value
		+ symbol->section->output_section->vma
		+ symbol->section->output_offset);
  relocation += reloc_entry->addend;
  if (howto->pc_relative)
    {
      relocation -= (input_section->output_section->vma
		     + input_section->output_offset);
      relocation -= reloc_entry->address;
    }

  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address); 
  insn |= (relocation & 0xfff) << 16 | (relocation & 0xff000) >> 4;
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);

  if ((bfd_signed_vma) relocation < - 0x80000
      || (bfd_signed_vma) relocation > 0x7ffff)
    return bfd_reloc_overflow;
  else
    return bfd_reloc_ok;
}

a892 1
	case R_390_GOT20:
a897 1
	case R_390_GOTPLT20:
a902 1
	case R_390_TLS_GOTIE20:
a971 1
	case R_390_GOTPLT20:
a998 1
	case R_390_TLS_GOTIE20:
a1006 1
	case R_390_GOT20:
a1016 1
	    case R_390_GOT20:
a1028 1
	    case R_390_TLS_GOTIE20:
a1357 1
	case R_390_TLS_GOTIE20:
a1361 1
	case R_390_GOT20:
a1384 1
	case R_390_20:
a1411 1
	case R_390_GOTPLT20:
d2247 1
a2247 1
	  else if (!info->executable
a2266 1
	case R_390_GOTPLT20:
a2300 1
	case R_390_GOT20:
a2715 1
	case R_390_TLS_GOTIE20:
d2939 1
a2939 13
      if (r_type == R_390_20
	  || r_type == R_390_GOT20
	  || r_type == R_390_GOTPLT20
	  || r_type == R_390_TLS_GOTIE20)
	{
	  relocation += rel->r_addend;
	  relocation = (relocation&0xfff) << 8 | (relocation&0xff000) >> 12;
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset,
					relocation, 0);
	}
      else
	r = _bfd_final_link_relocate (howto, input_bfd, input_section,
@


1.31.10.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d43 1
a43 1
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
d812 1
a812 1
     const struct elf_backend_data *bed;
d2304 4
a2307 1
	  bfd_boolean warned ATTRIBUTE_UNUSED;
d2309 34
a2342 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
@


1.31.10.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2189 2
a2190 2
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
d2192 1
a2192 1
  return elf_hash_table (info)->tls_sec->vma;
d2203 2
a2204 1
  struct elf_link_hash_table *htab = elf_hash_table (info);
d2206 2
a2207 2
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
d2209 2
a2210 1
  return htab->tls_size + htab->tls_sec->vma - address;
d2300 1
a2300 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d3414 1
@


1.31.10.9
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d641 8
d870 1
a870 2
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
d2608 2
a2610 34
		  if (r_type == R_390_64)
		    {
		      relocate = TRUE;
		      outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
		    }
		  else
		    {
		      long sindx;

		      if (bfd_is_abs_section (sec))
			sindx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error(bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  sindx = elf_section_data (osec)->dynindx;
			  BFD_ASSERT (sindx > 0);

			  /* We are turning this relocation into one
			     against a section symbol, so subtract out
			     the output section's address but not the
			     offset of the input section in the output
			     section.  */

			  outrel.r_addend -= osec->vma;
			}
		      outrel.r_info = ELF64_R_INFO (sindx, r_type);
		    }
@


1.30
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d43 2
a44 1
  PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));
d512 2
a513 1
elf_s390_copy_indirect_symbol (dir, ind)
d555 1
a555 1
  _bfd_elf_link_hash_copy_indirect (dir, ind);
@


1.29
log
@	* elf32-i386.c (elf_i386_relocate_section): Don't complain about
	unresolved debugging relocs in dynamic applications.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@a72 2
#define USE_RELA 1		/* We want RELA relocations, not REL.  */

@


1.29.2.1
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d43 1
a43 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d513 1
a513 2
elf_s390_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d555 1
a555 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.28
log
@2002-07-02  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* elf64-s390.c (create_got_section): Set .got section alignment to
	8 bytes.
	(elf_s390_check_relocs): Set .rela.dyn section alignment to 8 bytes.
@
text
@d1938 3
d1942 1
a1942 2
	  && !(info->shared
	       && (input_section->flags & SEC_DEBUGGING) != 0
@


1.27
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@d474 1
a474 1
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
d779 1
a779 1
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
@


1.26
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d48 1
a48 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d858 2
a859 2
elf_s390_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d889 1
a889 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.25
log
@	* elf32-arc.c: Fix formatting.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i386qnx.c: Likewise.
	* elf32-or32.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d2342 1
@


1.24
log
@	* elf-bfd.h (struct elf_backend_data): Add rela_normal.
	* elfxx-target.h (elf_backend_rela_normal): Define.
	(elfNN_bed): Init rela_normal.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Handle adjustment
	for section symbols here if rela_normal.  Simplify abs section test.
	* elf-m10200.c (mn10200_elf_relocate_section): If relocatable,
	return immediately.  Remove code handling relocatable linking.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise #ifndef USE_REL.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf-m10200.c (elf_backend_rela_normal): Define.
	* elf-m10300.c (elf_backend_rela_normal): Define.
	* elf32-fr30.c (elf_backend_rela_normal): Define.
	* elf32-i370.c (elf_backend_rela_normal): Define.
	* elf32-i860.c (elf_backend_rela_normal): Define.
	* elf32-m68k.c (elf_backend_rela_normal): Define.
	* elf32-mcore.c (elf_backend_rela_normal): Define.
	* elf32-openrisc.c (elf_backend_rela_normal): Define.
	* elf32-ppc.c (elf_backend_rela_normal): Define.
	* elf32-s390.c (elf_backend_rela_normal): Define.
	* elf32-xstormy16.c (elf_backend_rela_normal): Define.
	* elf64-ppc.c (elf_backend_rela_normal): Define.
	* elf64-s390.c (elf_backend_rela_normal): Define.
	* elf64-x86-64.c (elf_backend_rela_normal): Define.
	* elfxx-ia64.c (elf_backend_rela_normal): Define.
	* elf32-arm.h (elf_backend_rela_normal): Define #ifndef USE_REL.
	* elf32-m32r.c (elf_backend_rela_normal): Likewise.
@
text
@d1022 1
a1022 1
     (although we could actually do it here). */
@


1.24.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1022 1
a1022 1
     (although we could actually do it here).  */
a2341 1
  bfd_elf64_swap_symbol_in,
@


1.24.4.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d48 1
a48 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d474 1
a474 1
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 3))
d779 1
a779 1
			  || ! bfd_set_section_alignment (dynobj, sreloc, 3))
d858 2
a859 2
elf_s390_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d889 3
a891 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
a1939 3
      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
d1941 2
a1942 1
	  && !((input_section->flags & SEC_DEBUGGING) != 0
@


1.24.4.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d73 2
@


1.24.4.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d43 1
a43 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d511 1
a511 2
elf_s390_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d553 1
a553 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.24.2.1
log
@merge from trunk
@
text
@d1022 1
a1022 1
     (although we could actually do it here).  */
a2341 1
  bfd_elf64_swap_symbol_in,
@


1.23
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d1590 3
d1622 1
a1623 1

a1624 21

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d2369 1
@


1.22
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d427 1
a427 1
  ret = (struct elf_s390_link_hash_table *) bfd_alloc (abfd, amt);
d433 1
a433 1
      bfd_release (abfd, ret);
@


1.21
log
@2002-02-19  Martin Schwidefsky  <schwidefsky@@de.ibm.com>

	* archures.c (bfd_mach_s390_esa): Rename to bfd_mach_s390_31.
	(bfd_mach_s390_esame): Rename to bfd_mach_s390_64.
	* bfd-in2.h: Regenerate.
	* cpu-s390.c (arch_info_struct): Use renamed architecture defines.
	Replace architecture name "s390" with "s390:31-bit" and "s390:esame"
	with "s390:64-bit".
	* elf32-s390.c (elf_howto_table): Add 32 bit pc relative relocations.
	(elf_s390_reloc_type_lookup): Likewise.
	(elf_s390_check_relocs): Likewise.
	(elf_s390_gc_sweep_hook): Likewise.
	(elf_s390_relocate_section): Likewise.
	(elf_s390_object_p): Use renamed architecture define.
	* elf64-s390.c (elf_s390_object_p): Use renamed architecture define.
@
text
@d2 1
a2 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d1172 1
a1172 2
  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
d1175 3
d1343 3
@


1.20
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d2328 1
a2328 1
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_esame);
@


1.19
log
@	* elf64-ppc.c (ppc64_elf_size_dynamic_sections): Check for relocs
	against section syms in readonly sections.  Don't do the global
	sym check if we find one.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	(elf_s390_grok_prstatus): Add missing prototype.
@
text
@d1893 1
d1900 2
d1907 1
a1907 4
                {
                  memset (&outrel, 0, sizeof outrel);
                  relocate = false;
                }
a1919 1
		  relocate = false;
@


1.19.2.1
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a1892 1
              relocate = false;
a1898 2
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = true, relocate = true;
d1904 4
a1907 1
		memset (&outrel, 0, sizeof outrel);
d1920 1
@


1.19.2.2
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d1172 2
a1173 1
  if (h->root.type == bfd_link_hash_indirect)
a1175 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a1341 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

d2328 1
a2328 1
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_64);
@


1.19.2.3
log
@Merge from mainline
@
text
@a1589 3
  if (info->relocateable)
    return true;

d1619 1
a1620 1
      howto = elf_howto_table + r_type;
d1622 21
a2386 1
#define elf_backend_rela_normal		1
@


1.18
log
@	* elf32-i386 (elf_i386_adjust_dynamic_symbol): Do not replace PLT32
	relocations with PC32 relocations for undefined or weak symbols.
	* elf32-s390 (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf64-s390x (elf_i386_adjust_dynamic_symbol): Likewise.
@
text
@d1421 1
a1421 1
	      else
d1425 2
d1548 3
a1550 1
	  elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, (PTR) info);
@


1.17
log
@        * elf32-s390 (elf_s390_check_relocs): Pass addend to
        gc_record_vtentry.
        * elf64-s390 (elf_s390_check_relocs): Likewise.
        Fix by Andreas Jaeger <aj@@suse.de>.
@
text
@d1029 3
a1031 1
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0))
@


1.16
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d842 1
a842 1
          if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_offset))
@


1.15
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d890 1
a890 7
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
@


1.14
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d1894 5
a1898 12
              if (elf_section_data (input_section)->stab_info == NULL)
                outrel.r_offset = rel->r_offset;
              else
                {
                  off = (_bfd_stab_section_offset
                         (output_bfd, htab->elf.stab_info, input_section,
                          &elf_section_data (input_section)->stab_info,
                          rel->r_offset));
                  if (off == (bfd_vma) -1)
                    skip = true;
                  outrel.r_offset = off;
                }
@


1.13
log
@	* elf32-s390.c (elf_s390_relocate_section): Use the "unresolved_reloc"
	scheme to get rid of an ugly complicated test.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
@
text
@d1646 1
a1646 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.12
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d1661 1
a1661 46
	      if (r_type == R_390_GOTPC
		  || r_type == R_390_GOTPCDBL
		  || ((r_type == R_390_PLT16DBL
		       || r_type == R_390_PLT32
		       || r_type == R_390_PLT32DBL
		       || r_type == R_390_PLT64)
                      && htab->splt != NULL
		      && h->plt.offset != (bfd_vma) -1)
		  || ((r_type == R_390_GOT12
                       || r_type == R_390_GOT16
		       || r_type == R_390_GOT32
		       || r_type == R_390_GOT64
		       || r_type == R_390_GOTENT)
		      && elf_hash_table (info)->dynamic_sections_created
		      && (! info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0)
		      && (r_type == R_390_8
			  || r_type == R_390_16
			  || r_type == R_390_32
			  || r_type == R_390_64
			  || r_type == R_390_PC16
			  || r_type == R_390_PC16DBL
			  || r_type == R_390_PC32
			  || r_type == R_390_PC32DBL
			  || r_type == R_390_PC64)
                      && ((input_section->flags & SEC_ALLOC) != 0
                          /* DWARF will emit R_390_32 relocations in its
                             sections against symbols defined externally
                             in shared libraries.  We can't do anything
                             with them here.  */
                          || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))))
		{
		  /* In these cases, we don't need the relocation
                     value.  We check specially because in some
                     obscure cases sec->output_section will be NULL.  */
		  relocation = 0;
		}
	      else if (sec->output_section == NULL)
d1931 1
a1931 1
		  outrel.r_addend = relocation + rel->r_addend;
@


1.11
log
@* elf32-s390: Major rework that introduces all recent changes to
the s390 backends.  Get a closer match to elf32-i386.
(elf_s390_relocate_section): Make use of dynamic section short-cuts.
Localise vars, and delay setting.  Better error reporting, replace
BFD_ASSERT with abort.  Check ELF_LINK_HASH_DEF_DYNAMIC to see if a
symbol is not defined in the regular object file and tread the weak
definition as the normal one.  Don't discard relocs for undefweak or
undefined symbols and check !DEF_REGULAR as well as DEF_DYNAMIC in
test for avoided copy relocs.  Reinstate fudge for unresolved relocs
in debugging sections.
(elf32_s390_adjust_dynamic_symbol): Handle nocopyreloc.  Don't do copy
reloc processing for weakdefs.  Remove redundant casts and aborts.
Delay setting of vars until needed.  Move creation of dynamic symbols
and allocation of .plt and .rela.plt to allocate_dynrelocs.  Replace
BFD_ASSERT with abort.  Discard .plt entries for everything with
plt.refcount <= 0.
(elf_s390_check_relocs):  Don't allocate space for dynamic relocs,
.got or .relgot here but do it in allocate_dynrelocs.  Reference count
possible .plt and .got entries.  Don't test input section SEC_READONLY
here to try to avoid copy relocs, and keep dyn_relocs regardless of
ELF_LINK_NON_GOT_REF.  Don't set DF_TEXTREL here.  Delay setting of
variables until needed.  Remove separate switch stmt for creating .got
section.  Initialise local_got_refcounts to 0.  Cache pointer to
"sreloc" section in elf_section_data. Tweak condition under which .got
created.  Report files with bad relocation section names.
(elf_s390_finish_dynamic_symbol): Don't copy relocs for symbols that
have been forced local.  Use same test to decide if we can use a
relative reloc for got as elf_s390_relocate_section.  Expand SHN_UNDEF
comment.  Move expressions out of function calls.  Replace BFD_ASSERT
with abort.
(elf_s390_finish_dynamic_sections): Migrate common code out of switch
statement.  Replace BFD_ASSERT with abort.
(elf_s390_size_dynamic_sections): Call readonly_dynrelocs. Rename "i"
to "ibfd".  Allocate space for local dyn relocs.  Use DF_TEXTREL flag
instead of looking up section names for DT_TEXTREL.  Replace
BFD_ASSERT with abort.  Zero out the dynamic allocated content space.
Add a comment to remind us that one day this ought to be fixed.
(struct elf_s390_link_hash_entry): Rename "root" to "elf".
(struct elf_s390_link_hash_table): Likewise.
(elf_s390_link_hash_newfunc): Rename to link_hash_newfunc and get
rid of unnecessary casts.
(struct elf_s390_dyn_relocs): Add "sec", and "pc_count" fields.
Remove "section" field.
(elf_s390_gc_sweep_hook): Sweep dyn_relocs and local_dynrel.
Reference count possible .plt entries.  Don't deallocate .got and
.relgot space here.
(struct elf_s390_pcrel_relocs_copied): Rename to elf_s390_dyn_relocs.
Update comment.
(struct elf_s390_link_hash_entry): Rename pcrel_relocs_copied to
dyn_relocs.
(elf_s390_discard_copies):  Delete.
(elf_s390_link_hash_traverse): Delete.
(bfd_elf32_bfd_final_link): Delete.  (ie. use regular final link
rather than gc variety).
(struct elf_s390_link_hash_table): Add sgot, sgotplt, srelgot, splt,
srelplt, sdynbss, srelbss fields.
(elf_s390_link_hash_table_create): Init them.
(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
(allocate_dynrelocs): New function.
(create_got_section): New function.
(elf_backend_can_refcount): Define.
(elf_backend_copy_indirect_symbol): Define.
(elf_s390_copy_indirect_symbol): New function.
(elf_s390_create_dynamic_sections): New function.
(readonly_dynrelocs): New function.
* elf64-s390x: Likewise.
@
text
@d377 3
d444 1
d627 1
a627 1
		
d651 1
a651 1
	
d662 1
a662 1
	
d667 1
a667 1
	
d671 1
a671 1
	
d690 1
a690 1
	
d695 1
a695 1
	
d736 3
d746 1
a746 1
		
d753 1
a753 1
		
d762 1
a762 1
		
d771 1
a771 1
		
d784 1
a784 1
	
d789 13
a801 5
		  struct elf_s390_link_hash_entry *eh;
		  struct elf_s390_dyn_relocs *p;
		
		  eh = (struct elf_s390_link_hash_entry *) h;
		  p = eh->dyn_relocs;
d803 2
a804 21
		  if (p == NULL || p->sec != sec)
		    {
		      bfd_size_type amt = sizeof *p;
		      p = ((struct elf_s390_dyn_relocs *)
			   bfd_alloc (htab->elf.dynobj, amt));
		      if (p == NULL)
			return false;
		      p->next = eh->dyn_relocs;
		      eh->dyn_relocs = p;
		      p->sec = sec;
		      p->count = 0;
		      p->pc_count = 0;
		    }
		
		  p->count += 1;
		  if (ELF64_R_TYPE (rel->r_info) == R_390_PC16
		      || ELF64_R_TYPE (rel->r_info) == R_390_PC16DBL
		      || ELF64_R_TYPE (rel->r_info) == R_390_PC32
		      || ELF64_R_TYPE (rel->r_info) == R_390_PC32DBL
		      || ELF64_R_TYPE (rel->r_info) == R_390_PC64)
		    p->pc_count += 1;
d806 3
a808 1
	      else
d810 10
a819 2
		  /* Track dynamic relocs needed for local syms too.  */
		  elf_section_data (sec)->local_dynrel += 1;
d821 8
d831 1
a831 1
	
d838 1
a838 1
	
d845 1
a845 1
	
a916 1
  bfd *dynobj;
d918 1
a918 5
  elf_section_data (sec)->local_dynrel = 0;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return true;
d1217 1
a1217 1
	
d1220 1
a1220 1
	
d1323 1
a1323 1
    keep:
d1410 1
a1410 1
	  bfd_size_type count = elf_section_data (s)->local_dynrel;
d1412 4
a1415 1
	  if (count != 0)
d1417 13
a1429 2
	      srela = elf_section_data (s)->sreloc;
	      srela->_raw_size += count * sizeof (Elf64_External_Rela);
d1479 1
a1479 1
	
d1547 1
a1547 1
	
d1551 1
a1551 1
	
d1901 7
a1908 1
	       && (input_section->flags & SEC_ALLOC) != 0
a1919 1
		  && (input_section->flags & SEC_ALLOC) != 0
d2026 1
a2026 1
	
d2039 1
a2039 1
	
d2042 1
a2042 1
	
d2286 1
a2286 1
	
d2288 1
a2288 1
	
d2293 1
a2293 1
	
d2297 1
a2297 1
	
d2301 1
a2301 1
	
d2309 1
a2309 1
	
@


1.10
log
@	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Merge dyn_reloc
	counts for aliases instead of aborting.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.

	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Set plt.offset
	to -1 for non-function symbols.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Refer to
	plt.offset instead of plt.refcount when setting to -1.
@
text
@d32 3
a34 2
static boolean elf_s390_is_local_label_name PARAMS ((bfd *, const char *));
static struct bfd_hash_entry *elf_s390_link_hash_newfunc
d38 6
d55 4
d67 2
a71 2
static enum elf_reloc_type_class elf_s390_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
d137 65
a201 64
  switch (code) {
  case BFD_RELOC_NONE:
    return &elf_howto_table[(int) R_390_NONE];
  case BFD_RELOC_8:
    return &elf_howto_table[(int) R_390_8];
  case BFD_RELOC_390_12:
    return &elf_howto_table[(int) R_390_12];
  case BFD_RELOC_16:
    return &elf_howto_table[(int) R_390_16];
  case BFD_RELOC_32:
    return &elf_howto_table[(int) R_390_32];
  case BFD_RELOC_CTOR:
    return &elf_howto_table[(int) R_390_32];
  case BFD_RELOC_32_PCREL:
    return &elf_howto_table[(int) R_390_PC32];
  case BFD_RELOC_390_GOT12:
    return &elf_howto_table[(int) R_390_GOT12];
  case BFD_RELOC_32_GOT_PCREL:
    return &elf_howto_table[(int) R_390_GOT32];
  case BFD_RELOC_390_PLT32:
    return &elf_howto_table[(int) R_390_PLT32];
  case BFD_RELOC_390_COPY:
    return &elf_howto_table[(int) R_390_COPY];
  case BFD_RELOC_390_GLOB_DAT:
    return &elf_howto_table[(int) R_390_GLOB_DAT];
  case BFD_RELOC_390_JMP_SLOT:
    return &elf_howto_table[(int) R_390_JMP_SLOT];
  case BFD_RELOC_390_RELATIVE:
    return &elf_howto_table[(int) R_390_RELATIVE];
  case BFD_RELOC_32_GOTOFF:
    return &elf_howto_table[(int) R_390_GOTOFF];
  case BFD_RELOC_390_GOTPC:
    return &elf_howto_table[(int) R_390_GOTPC];
  case BFD_RELOC_390_GOT16:
    return &elf_howto_table[(int) R_390_GOT16];
  case BFD_RELOC_16_PCREL:
    return &elf_howto_table[(int) R_390_PC16];
  case BFD_RELOC_390_PC16DBL:
    return &elf_howto_table[(int) R_390_PC16DBL];
  case BFD_RELOC_390_PLT16DBL:
    return &elf_howto_table[(int) R_390_PLT16DBL];
  case BFD_RELOC_VTABLE_INHERIT:
    return &elf64_s390_vtinherit_howto;
  case BFD_RELOC_VTABLE_ENTRY:
    return &elf64_s390_vtentry_howto;
  case BFD_RELOC_390_PC32DBL:
    return &elf_howto_table[(int) R_390_PC32DBL];
  case BFD_RELOC_390_PLT32DBL:
    return &elf_howto_table[(int) R_390_PLT32DBL];
  case BFD_RELOC_390_GOTPCDBL:
    return &elf_howto_table[(int) R_390_GOTPCDBL];
  case BFD_RELOC_64:
    return &elf_howto_table[(int) R_390_64];
  case BFD_RELOC_64_PCREL:
    return &elf_howto_table[(int) R_390_PC64];
  case BFD_RELOC_390_GOT64:
    return &elf_howto_table[(int) R_390_GOT64];
  case BFD_RELOC_390_PLT64:
    return &elf_howto_table[(int) R_390_PLT64];
  case BFD_RELOC_390_GOTENT:
    return &elf_howto_table[(int) R_390_GOTENT];
  default:
    break;
  }
a247 5
/* The nop opcode we use.  */

#define s390_NOP 0x07070707


d334 13
a346 15
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */

struct elf_s390_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf_s390_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
d348 3
d357 1
a357 1
  struct elf_link_hash_entry root;
d359 2
a360 2
  /* Number of PC relative relocs copied for this symbol.  */
  struct elf_s390_pcrel_relocs_copied *pcrel_relocs_copied;
d367 10
a376 1
  struct elf_link_hash_table root;
a378 13
/* Declare this now that the above structures are defined.  */

static boolean elf_s390_discard_copies
  PARAMS ((struct elf_s390_link_hash_entry *, PTR));

/* Traverse an s390 ELF linker hash table.  */

#define elf_s390_link_hash_traverse(table, func, info)		\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
    (info)))

d387 1
a387 1
elf_s390_link_hash_newfunc (entry, table, string)
a391 3
  struct elf_s390_link_hash_entry *ret =
    (struct elf_s390_link_hash_entry *) entry;

d394 7
a400 6
  if (ret == (struct elf_s390_link_hash_entry *) NULL)
    ret = ((struct elf_s390_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf_s390_link_hash_entry)));
  if (ret == (struct elf_s390_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
d403 2
a404 4
  ret = ((struct elf_s390_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct elf_s390_link_hash_entry *) NULL)
d406 4
a409 1
      ret->pcrel_relocs_copied = NULL;
d412 1
a412 1
  return (struct bfd_hash_entry *) ret;
d424 2
a425 2
  ret = ((struct elf_s390_link_hash_table *) bfd_alloc (abfd, amt));
  if (ret == (struct elf_s390_link_hash_table *) NULL)
d428 1
a428 2
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       elf_s390_link_hash_newfunc))
d434 70
a503 1
  return &ret->root.root;
d506 47
d565 1
a565 1
  bfd *dynobj;
a567 1
  bfd_signed_vma *local_got_refcounts;
a569 2
  asection *sgot;
  asection *srelgot;
d575 1
a575 1
  dynobj = elf_hash_table (info)->dynobj;
a577 1
  local_got_refcounts = elf_local_got_offsets (abfd);
a578 2
  sgot = NULL;
  srelgot = NULL;
d589 8
a601 24
      /* Some relocs require a global offset table.  */
      if (dynobj == NULL)
	{
	  switch (ELF64_R_TYPE (rel->r_info))
	    {
	    case R_390_GOT12:
            case R_390_GOT16:
	    case R_390_GOT32:
	    case R_390_GOT64:
	    case R_390_GOTOFF:
	    case R_390_GOTPC:
	    case R_390_GOTPCDBL:
	    case R_390_GOTENT:
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfd_elf_create_got_section (dynobj, info))
		return false;
	      break;

	    default:
	      break;
	    }
	}


a609 28

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }


	  if (srelgot == NULL
	      && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot = bfd_make_section (dynobj, ".rela.got");
		  if (srelgot == NULL
		      || ! bfd_set_section_flags (dynobj, srelgot,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY))
		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		    return false;
		}
	    }

a611 12
	      if (h->got.refcount == 0)
		{
		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->dynindx == -1)
		    {
		      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
			return false;
		    }

		  sgot->_raw_size += 8;
		  srelgot->_raw_size += sizeof (Elf64_External_Rela);
		}
d616 2
d619 1
d623 3
a625 2

		  size = symtab_hdr->sh_info * sizeof (bfd_vma);
a631 11
	      if (local_got_refcounts[r_symndx] == 0)
		{
		  sgot->_raw_size += 8;
		  if (info->shared)
		    {
		      /* If we are generating a shared object, we need to
			 output a R_390_RELATIVE reloc so that the dynamic
			 linker can adjust this GOT entry.  */
		      srelgot->_raw_size += sizeof (Elf64_External_Rela);
		    }
		}
d634 12
d647 1
a647 1

d658 1
a658 1

d663 1
a663 1

d667 1
a667 1

d677 15
a691 3
	  if (h != NULL)
	    h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

d693 38
a730 22
             against a global symbol, or a non PC relative reloc
             against a local symbol, then we need to copy the reloc
             into the shared library.  However, if we are linking with
             -Bsymbolic, we do not need to copy a reloc against a
             global symbol which is defined in an object we are
             including in the link (i.e., DEF_REGULAR is set).  At
             this point we have not seen all the input files, so it is
             possible that DEF_REGULAR is not set now but will be set
             later (it is never cleared).  We account for that
             possibility below by storing information in the
             pcrel_relocs_copied field of the hash table entry.  */
	  if (info->shared
              && (sec->flags & SEC_ALLOC) != 0
	      && (ELF64_R_TYPE (rel->r_info) == R_390_8
		  || ELF64_R_TYPE (rel->r_info) == R_390_16
		  || ELF64_R_TYPE (rel->r_info) == R_390_32
		  || ELF64_R_TYPE (rel->r_info) == R_390_64
		  || (h != NULL
		      && h->dynindx != -1
		      && (! info->symbolic
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d732 3
a734 3
	      /* When creating a shared object, we must copy these
                 reloc types into the output file.  We create a reloc
                 section in dynobj and make room for this reloc.  */
d738 2
a739 1

d746 12
d759 1
a759 4
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

d764 1
a764 1

d775 1
a775 2
		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
d777 4
a780 17

	      sreloc->_raw_size += sizeof (Elf64_External_Rela);

	      /* If we are linking with -Bsymbolic, and this is a
                 global symbol, we count the number of PC relative
                 relocations we have entered for this symbol, so that
                 we can discard them again if the symbol is later
                 defined by a regular object.  Note that this function
                 is only called if we are using an elf64_s390 linker
                 hash table, which means that h is really a pointer to
                 an elf64_s390_link_hash_entry.  */
	      if (h != NULL
		  && (ELF64_R_TYPE (rel->r_info) == R_390_PC16 ||
		      ELF64_R_TYPE (rel->r_info) == R_390_PC16DBL ||
		      ELF64_R_TYPE (rel->r_info) == R_390_PC32 ||
		      ELF64_R_TYPE (rel->r_info) == R_390_PC32DBL ||
		      ELF64_R_TYPE (rel->r_info) == R_390_PC64))
d783 2
a784 2
		  struct elf_s390_pcrel_relocs_copied *p;

d786 1
d788 1
a788 5
		  for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
		    if (p->section == sreloc)
		      break;

		  if (p == NULL)
d790 3
a792 2
		      p = ((struct elf_s390_pcrel_relocs_copied *)
			   bfd_alloc (dynobj, (bfd_size_type) sizeof *p));
d795 3
a797 3
		      p->next = eh->pcrel_relocs_copied;
		      eh->pcrel_relocs_copied = p;
		      p->section = sreloc;
d799 1
d801 13
a813 2

		  ++p->count;
a815 1

d817 1
a817 1

d824 1
a824 1

d828 1
a828 1
          if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d831 1
a831 1

d892 4
a895 4
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
a903 2
  asection *sgot;
  asection *srelgot;
d905 1
a905 3
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);
d911 3
a913 2
  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d932 1
a932 8
	      {
		h->got.refcount -= 1;
		if (h->got.refcount == 0)
		  {
		    sgot->_raw_size -= 8;
		    srelgot->_raw_size -= sizeof (Elf64_External_Rela);
		  }
	      }
d937 40
a976 9
	      {
		local_got_refcounts[r_symndx] -= 1;
		if (local_got_refcounts[r_symndx] == 0)
		  {
		    sgot->_raw_size -= 8;
		    if (info->shared)
		      srelgot->_raw_size -= sizeof (Elf64_External_Rela);
		  }
	      }
d1011 3
a1013 1
  bfd *dynobj;
a1016 13
  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
		  || h->weakdef != NULL
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));

d1023 4
a1026 4
      if ((! info->shared
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	  || (info->shared && h->plt.refcount <= 0))
d1030 3
a1032 3
             object.  In such a case, we don't actually need to build
             a procedure linkage table, and we can just do a PC32
             reloc instead.  */
a1034 1
	  return true;
a1036 43
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
	    return false;
	}

      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);


      /* The first  entry in .plt is reserved.  */
      if (s->_raw_size == 0)
	s->_raw_size = PLT_FIRST_ENTRY_SIZE;

     /* If this symbol is not defined in a regular file, and we are
       not generating a shared library, then set the symbol to this
       location in the .plt.  This is required to make function
       pointers compare as equal between the normal executable and
       the shared library.  */
     if (! info->shared
	&& (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
      {
	h->root.u.def.section = s;
	h->root.u.def.value = s->_raw_size;
      }

      h->plt.offset = s->_raw_size;

      /* Make room for this entry.  */
      s->_raw_size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */
      s = bfd_get_section_by_name (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += GOT_ENTRY_SIZE;

      /* We also need to make an entry in the .rela.plt section.  */
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += sizeof (Elf64_External_Rela);

d1040 5
d1074 23
d1107 1
a1107 2
  s = bfd_get_section_by_name (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);
d1109 3
a1111 4
  /* We must generate a R_390_COPY reloc to tell the dynamic linker
     to copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rel.bss section we are going to use.  */
d1114 1
a1114 5
      asection *srel;

      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
      BFD_ASSERT (srel != NULL);
      srel->_raw_size += sizeof (Elf64_External_Rela);
d1125 3
a1127 3
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
d1129 1
a1129 1
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
d1143 212
d1362 1
d1366 1
a1366 1
  boolean plt;
d1368 4
a1371 2
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);
d1373 1
a1373 1
  if (elf_hash_table (info)->dynamic_sections_created)
d1379 2
a1380 1
	  BFD_ASSERT (s != NULL);
a1384 11
  else
    {
      /* We may have created entries in the .rela.got section.
         However, if we are not creating the dynamic sections, we will
         not actually use these entries.  Reset the size of .rela.got,
         which will cause it to get stripped from the output file
         below.  */
      s = bfd_get_section_by_name (dynobj, ".rela.got");
      if (s != NULL)
	s->_raw_size = 0;
    }
d1386 9
a1394 18
  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared)
    elf_s390_link_hash_traverse (elf_s390_hash_table (info),
			         elf_s390_discard_copies,
				 (PTR) info);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = false;
  relocs = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      boolean strip;
d1396 1
a1396 1
      if ((s->flags & SEC_LINKER_CREATED) == 0)
d1399 3
a1401 5
      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      strip = false;
d1403 1
a1403 3
      if (strcmp (name, ".plt") == 0)
	{
	  if (s->_raw_size == 0)
d1405 2
a1406 8
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = true;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = true;
d1409 11
a1419 1
      else if (strncmp (name, ".rela", 5) == 0)
d1421 1
a1421 1
	  if (s->_raw_size == 0)
d1423 4
a1426 10
	      /* If we don't need this section, strip it from the
		 output file.  This is to handle .rela.bss and
		 .rel.plt.  We must create it in
		 create_dynamic_sections, because it must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = true;
d1429 31
a1459 10
	    {
	      /* Remember whether there are any reloc sections other
                 than .rela.plt.  */
	      if (strcmp (name, ".rela.plt") != 0)
		relocs = true;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
d1461 1
a1461 1
      else if (strncmp (name, ".got", 4) != 0)
d1467 1
a1467 1
      if (strip)
d1469 10
d1483 7
a1489 3
      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d1493 1
a1493 1
  if (elf_hash_table (info)->dynamic_sections_created)
d1509 1
a1509 1
      if (plt)
d1524 10
a1533 7
         }

      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return false;
	  info->flags |= DF_TEXTREL;
a1540 29
/* This function is called via elf64_s390_link_hash_traverse if we are
   creating a shared object with -Bsymbolic.  It discards the space
   allocated to copy PC relative relocs against symbols which are
   defined in regular objects.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.  */

/*ARGSUSED*/
static boolean
elf_s390_discard_copies (h, inf)
     struct elf_s390_link_hash_entry *h;
     PTR inf;
{
  struct elf_s390_pcrel_relocs_copied *s;
  struct bfd_link_info *info = (struct bfd_link_info *) inf;

  /* If a symbol has been forced local or we have found a regular
     definition for the symbolic link case, then we won't be needing
     any relocs.  */
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
      && ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	  || info->symbolic))
    {
      for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
	s->section->_raw_size -= s->count * sizeof (Elf64_External_Rela);
    }

  return true;
}
d1555 1
a1555 1
  bfd *dynobj;
a1558 3
  asection *sgot;
  asection *splt;
  asection *sreloc;
d1562 1
a1562 1
  dynobj = elf_hash_table (info)->dynobj;
a1566 9
  sgot = NULL;
  splt = NULL;
  sreloc = NULL;
  if (dynobj != NULL)
    {
      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got");
    }

d1577 1
d1579 1
d1583 2
a1584 2
      if (r_type == R_390_GNU_VTINHERIT
          || r_type == R_390_GNU_VTENTRY)
d1618 1
d1633 1
d1638 7
a1644 7
	      if ((r_type == R_390_GOTPC
		   || r_type == R_390_GOTPCDBL)
		  || ((r_type == R_390_PLT16DBL ||
		       r_type == R_390_PLT32 ||
		       r_type == R_390_PLT32DBL ||
		       r_type == R_390_PLT64)
                      && splt != NULL
d1646 5
a1650 5
		  || ((r_type == R_390_GOT12 ||
                       r_type == R_390_GOT16 ||
		       r_type == R_390_GOT32 ||
		       r_type == R_390_GOT64 ||
		       r_type == R_390_GOTENT)
d1660 9
a1668 9
		      && ( r_type == R_390_8 ||
			   r_type == R_390_16 ||
                           r_type == R_390_32 ||
			   r_type == R_390_64 ||
                           r_type == R_390_PC16 ||
                           r_type == R_390_PC16DBL ||
			   r_type == R_390_PC32 ||
			   r_type == R_390_PC32DBL ||
			   r_type == R_390_PC64)
d1670 1
a1670 1
                          /* DWARF will emit R_386_32 relocations in its
d1685 5
a1689 4
		  (*_bfd_error_handler)
		    (_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
		     bfd_archive_filename (input_bfd), h->root.root.string,
		     bfd_get_section_name (input_bfd, input_section));
d1708 3
a1710 3
	      input_section, rel->r_offset,
		     (!info->shared || info->no_undefined
		      || ELF_ST_VISIBILITY (h->other)))))
d1725 2
a1726 1
	  BFD_ASSERT (sgot != NULL);
d1730 1
a1730 1
              bfd_vma off;
d1733 2
a1734 3
              BFD_ASSERT (off != (bfd_vma) -1);

              if (! elf_hash_table (info)->dynamic_sections_created
d1736 3
a1738 1
                      && (info->symbolic || h->dynindx == -1)
d1758 1
a1758 1
				  sgot->contents + off);
d1762 2
a1763 1
	      relocation = sgot->output_offset + off;
d1767 2
a1768 4
              bfd_vma off;

              BFD_ASSERT (local_got_offsets != NULL
                          && local_got_offsets[r_symndx] != (bfd_vma) -1);
d1779 2
a1780 1
                  bfd_put_64 (output_bfd, relocation, sgot->contents + off);
d1786 1
d1788 3
a1790 2
                      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
                      BFD_ASSERT (srelgot != NULL);
d1792 2
a1793 2
                      outrel.r_offset = (sgot->output_section->vma
                                         + sgot->output_offset
d1797 3
a1799 5
                      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
                                                (((Elf64_External_Rela *)
                                                  srelgot->contents)
                                                 + srelgot->reloc_count));
                      ++srelgot->reloc_count;
d1804 1
d1806 4
a1809 2
	      relocation = sgot->output_offset + off;
            }
d1818 1
a1818 1
	    relocation += sgot->output_section->vma;
a1825 6
          if (sgot == NULL)
            {
              sgot = bfd_get_section_by_name (dynobj, ".got");
              BFD_ASSERT (sgot != NULL);
            }

d1831 1
a1831 1
          relocation -= sgot->output_section->vma;
d1838 3
a1840 10

          if (sgot == NULL)
            {
              sgot = bfd_get_section_by_name (dynobj, ".got");
              BFD_ASSERT (sgot != NULL);
            }

          relocation = sgot->output_section->vma;

          break;
d1854 2
a1855 1
          if (h->plt.offset == (bfd_vma) -1 || splt == NULL)
d1863 2
a1864 2
          relocation = (splt->output_section->vma
                        + splt->output_offset
d1866 1
a1866 1

d1878 23
a1900 11
          if (info->shared
              && (input_section->flags & SEC_ALLOC) != 0
              && (r_type == R_390_8
                  || r_type == R_390_16
		  || r_type == R_390_32
		  || r_type == R_390_64
                  || (h != NULL
                      && h->dynindx != -1
                      && (! info->symbolic
                          || (h->elf_link_hash_flags
                              & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1904 2
a1910 20
              if (sreloc == NULL)
                {
                  const char *name;

                  name = (bfd_elf_string_from_elf_section
                          (input_bfd,
                           elf_elfheader (input_bfd)->e_shstrndx,
                           elf_section_data (input_section)->rel_hdr.sh_name));
                  if (name == NULL)
                    return false;

                  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
                              && strcmp (bfd_get_section_name (input_bfd,
                                                               input_section),
                                         name + 5) == 0);

                  sreloc = bfd_get_section_by_name (dynobj, name);
                  BFD_ASSERT (sreloc != NULL);
                }

a1916 2
                  bfd_vma off;

d1918 1
a1918 2
                         (output_bfd, &elf_hash_table (info)->stab_info,
                          input_section,
d1934 11
a1944 5
              else if (r_type == R_390_PC16 ||
                       r_type == R_390_PC16DBL ||
		       r_type == R_390_PC32 ||
		       r_type == R_390_PC32DBL ||
		       r_type == R_390_PC64)
a1945 1
                  BFD_ASSERT (h != NULL && h->dynindx != -1);
d1952 9
a1960 19
                  /* h->dynindx may be -1 if this symbol was marked to
                     become local.  */
                  if (h == NULL
                      || ((info->symbolic || h->dynindx == -1)
                          && (h->elf_link_hash_flags
                              & ELF_LINK_HASH_DEF_REGULAR) != 0))
                    {
                      relocate = true;
                      outrel.r_info = ELF64_R_INFO (0, R_390_RELATIVE);
		      outrel.r_addend = relocation + rel->r_addend;
                    }
		  else
		    {
		      BFD_ASSERT (h->dynindx != -1);
		      relocate = false;
		      outrel.r_info = ELF64_R_INFO (h->dynindx, R_390_64);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
                }
d1962 3
a1964 5
              bfd_elf64_swap_reloca_out (output_bfd, &outrel,
                                        (((Elf64_External_Rela *)
                                          sreloc->contents)
                                         + sreloc->reloc_count));
              ++sreloc->reloc_count;
d1980 11
d1997 24
a2020 1
	  switch (r)
d2022 6
a2027 25
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = h->root.root.string;
		else
		  {
		    name = bfd_elf_string_from_elf_section (input_bfd,
							    symtab_hdr->sh_link,
							    sym->st_name);
		    if (name == NULL)
		      return false;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rel->r_offset)))
		  return false;
	      }
	      break;
d2045 1
a2045 1
  bfd *dynobj;
d2047 1
a2047 1
  dynobj = elf_hash_table (info)->dynobj;
d2051 2
a2052 2
      asection *splt;
      asection *srela;
d2054 1
a2054 3
      bfd_vma got_offset;
      bfd_vma plt_index;
      asection *sgot;
d2059 5
a2063 6
      BFD_ASSERT (h->dynindx != -1);

      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
      srela = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);
d2074 16
a2089 16
      bfd_put_32 (output_bfd, PLT_ENTRY_WORD0,
		  splt->contents + h->plt.offset);
      bfd_put_32 (output_bfd, PLT_ENTRY_WORD1,
		  splt->contents + h->plt.offset + 4);
      bfd_put_32 (output_bfd, PLT_ENTRY_WORD2,
		  splt->contents + h->plt.offset + 8);
      bfd_put_32 (output_bfd, PLT_ENTRY_WORD3,
		  splt->contents + h->plt.offset + 12);
      bfd_put_32 (output_bfd, PLT_ENTRY_WORD4,
		  splt->contents + h->plt.offset + 16);
      bfd_put_32 (output_bfd, PLT_ENTRY_WORD5,
		  splt->contents + h->plt.offset + 20);
      bfd_put_32 (output_bfd, PLT_ENTRY_WORD6,
		  splt->contents + h->plt.offset + 24);
      bfd_put_32 (output_bfd, PLT_ENTRY_WORD7,
		  splt->contents + h->plt.offset + 28);
d2092 4
a2095 3
		  (sgot->output_section->vma + sgot->output_offset + got_offset
		   - (splt->output_section->vma + h->plt.offset))/2,
		  splt->contents + h->plt.offset + 2);
d2099 1
a2099 1
		  splt->contents + h->plt.offset + 24);
d2102 1
a2102 11
		  splt->contents + h->plt.offset + 28);

      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
		       + got_offset);
      rela.r_info = ELF64_R_INFO (h->dynindx, R_390_JMP_SLOT);
      rela.r_addend = 0;
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) srela->contents
				  + plt_index ));
d2107 2
a2108 2
		  (splt->output_section->vma
		   + splt->output_offset
d2111 1
a2111 1
		  sgot->contents + got_offset);
d2113 8
d2125 4
a2128 1
	     the .plt section.  Leave the value alone.  */
a2134 2
      asection *sgot;
      asection *srela;
d2136 1
d2141 2
a2142 3
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srela = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srela != NULL);
d2144 2
a2145 2
      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
d2153 5
a2157 4
      if (! elf_hash_table (info)->dynamic_sections_created
	  || (info->shared
	      && (info->symbolic || h->dynindx == -1)
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d2159 1
d2168 1
a2168 1
	  bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
d2173 3
a2175 4
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) srela->contents
				  + srela->reloc_count));
      ++srela->reloc_count;
a2179 1
      asection *s;
d2181 1
d2185 5
a2189 8
      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));


      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rela.bss");
      BFD_ASSERT (s != NULL);
d2196 3
a2198 4
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
d2210 20
d2237 1
a2239 3
  asection *sgot;

  dynobj = elf_hash_table (info)->dynobj;
d2241 2
a2242 2
  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
d2245 1
a2245 1
  if (elf_hash_table (info)->dynamic_sections_created)
a2246 1
      asection *splt;
d2249 2
a2250 1
      BFD_ASSERT (sdyn != NULL);
a2256 1
	  const char *name;
d2258 1
a2258 1

d2260 1
a2260 1

d2264 4
d2269 1
a2269 4

	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;
d2271 1
a2271 6
	      name = ".rela.plt";
	    get_vma:
	      s = bfd_get_section_by_name(output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
d2273 1
a2273 1

d2275 1
a2275 2
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      BFD_ASSERT (s != NULL);
a2279 1
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
d2281 1
a2281 1

d2290 5
a2294 9
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      if (s != NULL)
		{
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val -= s->_cooked_size;
		  else
		    dyn.d_un.d_val -= s->_raw_size;
		}
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
d2297 2
d2302 1
a2302 2
      splt = bfd_get_section_by_name (dynobj, ".plt");
      if (splt && splt->_raw_size > 0)
d2305 14
a2318 14
	  bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD0,
		      splt->contents );
	  bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD1,
		      splt->contents +4 );
	  bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD3,
		      splt->contents +12 );
	  bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD4,
		      splt->contents +16 );
	  bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD5,
		      splt->contents +20 );
	  bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD6,
		      splt->contents + 24);
	  bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD7,
		      splt->contents + 28 );
d2321 4
a2324 3
		      (sgot->output_section->vma + sgot->output_offset
		       - splt->output_section->vma - 6)/2,
		      splt->contents + 8);
d2326 2
a2327 3

      elf_section_data (splt->output_section)->this_hdr.sh_entsize =
	PLT_ENTRY_SIZE;
d2330 1
a2330 3
  /* Set the first entry in the global offset table to the address of
     the dynamic section.  */
  if (sgot->_raw_size > 0)
d2332 12
a2343 6
      if (sdyn == NULL)
	bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
	bfd_put_64 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);
d2345 2
a2346 4
      /* One entry for shared object struct ptr.  */
      bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
      /* One entry for _dl_runtime_resolve.  */
      bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + 12);
a2347 3

  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 8;

a2357 18

static enum elf_reloc_type_class
elf_s390_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  switch ((int) ELF64_R_TYPE (rela->r_info))
    {
    case R_390_RELATIVE:
      return reloc_class_relative;
    case R_390_JMP_SLOT:
      return reloc_class_plt;
    case R_390_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

a2411 1
#define bfd_elf64_bfd_final_link	      _bfd_elf64_gc_common_final_link
d2418 2
a2419 1
#define elf_backend_create_dynamic_sections   _bfd_elf_create_dynamic_sections
d2424 1
@


1.9
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): Add init_refcount.
	(struct elf_backend_data): Add can_refcount.
	* elf.c (_bfd_elf_link_hash_newfunc): Get rid of a few casts.  Set
	got.refcount and plt.refcount from init_refcount.
	(_bfd_elf_link_hash_table_init): Set up init_refcount.
	(_bfd_elf_link_hash_copy_indirect): Reference got/plt.refcount
	rather than got/plt.offset, and test for <= 0 rather than -1.
	* elflink.h (size_dynamic_sections): Set init_refcount to -1.
	* elfxx-target.h (elf_backend_can_refcount): Define.
	(elfNN_bed): Init can_refcount.
	* linker.c (_bfd_link_hash_newfunc): Get rid of a few casts.
	(_bfd_generic_link_hash_newfunc): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-hppa.c (elf32_hppa_check_relocs): Modify for refcounts
	starting from zero.
	(elf32_hppa_copy_indirect_symbol): Make static to agree with
	prototype.
	(elf_backend_can_refcount): Define.
	* elf32-i386.c (elf_i386_check_relocs): Modify for refcounts
	starting from zero.
	(allocate_dynrelocs): Set plt/got.offset rather than *.refcount.
	(elf_i386_finish_dynamic_symbol): Expand SHN_UNDEF comment.
	(elf_i386_finish_dynamic_sections): Use local var so line < 80 chars.
	(elf_backend_can_refcount): Define.
	(elf_i386_copy_indirect_symbol): Make static to agree with
	prototype.  Formatting fix.
	* elf32-m68k.c (elf_m68k_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-ppc.c (ppc_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
@
text
@d979 2
@


1.8
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@d544 1
a544 1
	      if (h->got.refcount == -1)
a545 2
		  h->got.refcount = 1;

d556 1
a556 2
	      else
		h->got.refcount += 1;
d567 1
a567 1
					 bfd_alloc (abfd, size));
a570 1
		  memset (local_got_refcounts, -1, (size_t) size);
d572 1
a572 1
	      if (local_got_refcounts[r_symndx] == -1)
a573 2
		  local_got_refcounts[r_symndx] = 1;

d583 1
a583 3
	      else
		local_got_refcounts[r_symndx] += 1;

d603 2
a604 7
	  if (h->plt.refcount == -1)
	    {
	      h->plt.refcount = 1;
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	    }
	  else
	    h->plt.refcount += 1;
d2152 1
@


1.7
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d59 2
a60 1
static enum elf_reloc_type_class elf_s390_reloc_type_class PARAMS ((int));
d2104 2
a2105 2
elf_s390_reloc_type_class (type)
     int type;
d2107 1
a2107 1
  switch (type)
@


1.6
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d1424 1
a1424 1
		     bfd_get_filename (input_bfd), h->root.root.string,
@


1.5
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1435 2
a1436 1
	  else if (info->shared && !info->symbolic
@


1.4
log
@	* elf64-s390.c (elf_s390_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf_s390_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_s390_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.

	* elf32-s390.c (elf_s390_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf_s390_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_s390_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.

	* elf32-ppc.c (ppc_elf_check_relocs): Set DF_TEXTREL if the reloc
	is against read-only section.
	(ppc_elf_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(ppc_elf_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
@
text
@d292 8
a299 8
#define PLT_ENTRY_WORD0     0xc0100000
#define PLT_ENTRY_WORD1     0x0000e310
#define PLT_ENTRY_WORD2     0x10000004
#define PLT_ENTRY_WORD3     0x07f10d10
#define PLT_ENTRY_WORD4     0xe310100c
#define PLT_ENTRY_WORD5     0x0014c0f4
#define PLT_ENTRY_WORD6     0x00000000
#define PLT_ENTRY_WORD7     0x00000000
d316 8
a323 8
#define PLT_FIRST_ENTRY_WORD0     0xe310f038
#define PLT_FIRST_ENTRY_WORD1     0x0024c010
#define PLT_FIRST_ENTRY_WORD2     0x00000000
#define PLT_FIRST_ENTRY_WORD3     0xd207f030
#define PLT_FIRST_ENTRY_WORD4     0x1008e310
#define PLT_FIRST_ENTRY_WORD5     0x10100004
#define PLT_FIRST_ENTRY_WORD6     0x07f10700
#define PLT_FIRST_ENTRY_WORD7     0x07000700
d418 1
d420 1
a420 2
  ret = ((struct elf_s390_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf_s390_link_hash_table)));
d565 1
a565 1
		  size_t size;
d568 2
a569 2
		  local_got_refcounts = (bfd_signed_vma *)
		                         bfd_alloc (abfd, size);
d573 1
a573 1
		  memset (local_got_refcounts, -1, size);
d721 1
a721 1
			   bfd_alloc (dynobj, sizeof *p));
d1203 3
d1208 1
a1208 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_DEBUG, 0))
d1214 4
a1217 4
	  if (! bfd_elf64_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_JMPREL, 0))
d1223 3
a1225 4
          if (! bfd_elf64_add_dynamic_entry (info, DT_RELA, 0)
              || ! bfd_elf64_add_dynamic_entry (info, DT_RELASZ, 0)
              || ! bfd_elf64_add_dynamic_entry (info, DT_RELAENT,
					    sizeof (Elf64_External_Rela)))
d1231 1
a1231 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_TEXTREL, 0))
d1236 1
d1892 1
a1892 1
		       + (h->got.offset &~ 1));
@


1.3
log
@2001-08-10  Andreas Jaeger  <aj@@suse.de>

	* elf64-sparc.c: Add missing prototypes.
	* elf32-cris.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d59 1
d688 2
d1075 1
a1075 1
     bfd *output_bfd;
a1079 1
  boolean reltext;
a1121 1
  reltext = false;
a1167 2
	      asection *target;

d1171 1
a1171 18
		{
		  const char *outname;

		  relocs = true;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  The entries in the .rela.plt section
		     really apply to the .got section, which we
		     created ourselves and so know is not readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 5);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = true;
		}
d1227 1
a1227 1
      if (reltext)
d2097 18
d2182 1
@


1.2
log
@Update copyright notices
@
text
@d40 6
d58 1
d117 1
a117 1
  HOWTO (R_390_GNU_VTENTRY, 0,4,0,false,0,complain_overflow_dont, _bfd_elf_rel_vtable_reloc_fn,"R_390_GNU_VTENTRY", false,0,0, false); 
d186 1
a186 1
    break;                                         
d213 1
a213 1
    }     
d242 1
a242 1
#define PLT_ENTRY_SIZE 32 
d256 1
a256 1
   Furthermore, only r 0 and 1 are free to use!!!  */ 
d268 1
a268 1
   28(15) =  Offset in symbol table                                             
d478 1
a478 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];      
d552 1
a552 1
		  
d561 1
a561 1
     	      /* This is a global offset table entry for a local symbol.  */
d645 1
a645 1
		  || ELF64_R_TYPE (rel->r_info) == R_390_16 
d746 1
a746 1
                   
d1458 2
a1459 2
          	      input_section, rel->r_offset,
	 	     (!info->shared || info->no_undefined
d1566 1
a1566 1
 
d1702 1
a1702 1
		       r_type == R_390_PC32 || 
d1826 1
a1826 1
      /* Calc. index no. 
d2082 1
a2082 1
      elf_section_data (splt->output_section)->this_hdr.sh_entsize = 
@


1.1
log
@Add s390 support
@
text
@d2 1
a2 1
   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
@

