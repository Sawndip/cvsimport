head	1.73;
access;
symbols
	sid-snapshot-20180601:1.73
	sid-snapshot-20180501:1.73
	sid-snapshot-20180401:1.73
	sid-snapshot-20180301:1.73
	sid-snapshot-20180201:1.73
	sid-snapshot-20180101:1.73
	sid-snapshot-20171201:1.73
	sid-snapshot-20171101:1.73
	sid-snapshot-20171001:1.73
	sid-snapshot-20170901:1.73
	sid-snapshot-20170801:1.73
	sid-snapshot-20170701:1.73
	sid-snapshot-20170601:1.73
	sid-snapshot-20170501:1.73
	sid-snapshot-20170401:1.73
	sid-snapshot-20170301:1.73
	sid-snapshot-20170201:1.73
	sid-snapshot-20170101:1.73
	sid-snapshot-20161201:1.73
	sid-snapshot-20161101:1.73
	sid-snapshot-20160901:1.73
	sid-snapshot-20160801:1.73
	sid-snapshot-20160701:1.73
	sid-snapshot-20160601:1.73
	sid-snapshot-20160501:1.73
	sid-snapshot-20160401:1.73
	sid-snapshot-20160301:1.73
	sid-snapshot-20160201:1.73
	sid-snapshot-20160101:1.73
	sid-snapshot-20151201:1.73
	sid-snapshot-20151101:1.73
	sid-snapshot-20151001:1.73
	sid-snapshot-20150901:1.73
	sid-snapshot-20150801:1.73
	sid-snapshot-20150701:1.73
	sid-snapshot-20150601:1.73
	sid-snapshot-20150501:1.73
	sid-snapshot-20150401:1.73
	sid-snapshot-20150301:1.73
	sid-snapshot-20150201:1.73
	sid-snapshot-20150101:1.73
	sid-snapshot-20141201:1.73
	sid-snapshot-20141101:1.73
	sid-snapshot-20141001:1.73
	sid-snapshot-20140901:1.73
	sid-snapshot-20140801:1.73
	sid-snapshot-20140701:1.73
	sid-snapshot-20140601:1.73
	sid-snapshot-20140501:1.73
	sid-snapshot-20140401:1.73
	sid-snapshot-20140301:1.73
	sid-snapshot-20140201:1.73
	sid-snapshot-20140101:1.73
	sid-snapshot-20131201:1.73
	sid-snapshot-20131101:1.73
	sid-snapshot-20131001:1.73
	binutils-2_24-branch:1.73.0.4
	binutils-2_24-branchpoint:1.73
	binutils-2_21_1:1.70
	sid-snapshot-20130901:1.73
	gdb_7_6_1-2013-08-30-release:1.73
	sid-snapshot-20130801:1.73
	sid-snapshot-20130701:1.73
	sid-snapshot-20130601:1.73
	sid-snapshot-20130501:1.73
	gdb_7_6-2013-04-26-release:1.73
	sid-snapshot-20130401:1.73
	binutils-2_23_2:1.72
	gdb_7_6-branch:1.73.0.2
	gdb_7_6-2013-03-12-branchpoint:1.73
	sid-snapshot-20130301:1.73
	sid-snapshot-20130201:1.73
	sid-snapshot-20130101:1.72
	sid-snapshot-20121201:1.72
	gdb_7_5_1-2012-11-29-release:1.72
	binutils-2_23_1:1.72
	sid-snapshot-20121101:1.72
	binutils-2_23:1.72
	sid-snapshot-20121001:1.72
	sid-snapshot-20120901:1.72
	gdb_7_5-2012-08-17-release:1.72
	sid-snapshot-20120801:1.72
	binutils-2_23-branch:1.72.0.10
	binutils-2_23-branchpoint:1.72
	gdb_7_5-branch:1.72.0.8
	gdb_7_5-2012-07-18-branchpoint:1.72
	sid-snapshot-20120701:1.72
	sid-snapshot-20120601:1.72
	sid-snapshot-20120501:1.72
	binutils-2_22_branch:1.72.0.6
	gdb_7_4_1-2012-04-26-release:1.72
	sid-snapshot-20120401:1.72
	sid-snapshot-20120301:1.72
	sid-snapshot-20120201:1.72
	gdb_7_4-2012-01-24-release:1.72
	sid-snapshot-20120101:1.72
	gdb_7_4-branch:1.72.0.4
	gdb_7_4-2011-12-13-branchpoint:1.72
	sid-snapshot-20111201:1.72
	binutils-2_22:1.72
	sid-snapshot-20111101:1.72
	sid-snapshot-20111001:1.72
	binutils-2_22-branch:1.72.0.2
	binutils-2_22-branchpoint:1.72
	gdb_7_3_1-2011-09-04-release:1.70
	sid-snapshot-20110901:1.72
	sid-snapshot-20110801:1.72
	gdb_7_3-2011-07-26-release:1.70
	sid-snapshot-20110701:1.71
	sid-snapshot-20110601:1.70
	sid-snapshot-20110501:1.70
	gdb_7_3-branch:1.70.0.6
	gdb_7_3-2011-04-01-branchpoint:1.70
	sid-snapshot-20110401:1.70
	sid-snapshot-20110301:1.70
	sid-snapshot-20110201:1.70
	sid-snapshot-20110101:1.70
	binutils-2_21:1.70
	sid-snapshot-20101201:1.70
	binutils-2_21-branch:1.70.0.4
	binutils-2_21-branchpoint:1.70
	sid-snapshot-20101101:1.70
	sid-snapshot-20101001:1.70
	binutils-2_20_1:1.65
	gdb_7_2-2010-09-02-release:1.70
	sid-snapshot-20100901:1.70
	sid-snapshot-20100801:1.70
	gdb_7_2-branch:1.70.0.2
	gdb_7_2-2010-07-07-branchpoint:1.70
	sid-snapshot-20100701:1.70
	sid-snapshot-20100601:1.69
	sid-snapshot-20100501:1.69
	sid-snapshot-20100401:1.69
	gdb_7_1-2010-03-18-release:1.68
	sid-snapshot-20100301:1.68
	gdb_7_1-branch:1.68.0.2
	gdb_7_1-2010-02-18-branchpoint:1.68
	sid-snapshot-20100201:1.68
	sid-snapshot-20100101:1.67
	gdb_7_0_1-2009-12-22-release:1.65
	sid-snapshot-20091201:1.66
	sid-snapshot-20091101:1.65
	binutils-2_20:1.65
	gdb_7_0-2009-10-06-release:1.65
	sid-snapshot-20091001:1.65
	gdb_7_0-branch:1.65.0.4
	gdb_7_0-2009-09-16-branchpoint:1.65
	arc-sim-20090309:1.62
	binutils-arc-20081103-branch:1.62.0.22
	binutils-arc-20081103-branchpoint:1.62
	binutils-2_20-branch:1.65.0.2
	binutils-2_20-branchpoint:1.65
	sid-snapshot-20090901:1.64
	sid-snapshot-20090801:1.63
	msnyder-checkpoint-072509-branch:1.63.0.4
	msnyder-checkpoint-072509-branchpoint:1.63
	sid-snapshot-20090701:1.63
	dje-cgen-play1-branch:1.63.0.2
	dje-cgen-play1-branchpoint:1.63
	sid-snapshot-20090601:1.63
	sid-snapshot-20090501:1.63
	sid-snapshot-20090401:1.62
	arc-20081103-branch:1.62.0.20
	arc-20081103-branchpoint:1.62
	arc-insight_6_8-branch:1.62.0.18
	arc-insight_6_8-branchpoint:1.62
	insight_6_8-branch:1.62.0.16
	insight_6_8-branchpoint:1.62
	sid-snapshot-20090301:1.62
	binutils-2_19_1:1.62
	sid-snapshot-20090201:1.62
	sid-snapshot-20090101:1.62
	reverse-20081226-branch:1.62.0.14
	reverse-20081226-branchpoint:1.62
	sid-snapshot-20081201:1.62
	multiprocess-20081120-branch:1.62.0.12
	multiprocess-20081120-branchpoint:1.62
	sid-snapshot-20081101:1.62
	binutils-2_19:1.62
	sid-snapshot-20081001:1.62
	reverse-20080930-branch:1.62.0.10
	reverse-20080930-branchpoint:1.62
	binutils-2_19-branch:1.62.0.8
	binutils-2_19-branchpoint:1.62
	sid-snapshot-20080901:1.62
	sid-snapshot-20080801:1.62
	reverse-20080717-branch:1.62.0.6
	reverse-20080717-branchpoint:1.62
	sid-snapshot-20080701:1.62
	msnyder-reverse-20080609-branch:1.62.0.4
	msnyder-reverse-20080609-branchpoint:1.62
	drow-reverse-20070409-branch:1.58.0.2
	drow-reverse-20070409-branchpoint:1.58
	sid-snapshot-20080601:1.62
	sid-snapshot-20080501:1.62
	sid-snapshot-20080403:1.62
	sid-snapshot-20080401:1.62
	gdb_6_8-2008-03-27-release:1.62
	sid-snapshot-20080301:1.62
	gdb_6_8-branch:1.62.0.2
	gdb_6_8-2008-02-26-branchpoint:1.62
	sid-snapshot-20080201:1.62
	sid-snapshot-20080101:1.62
	sid-snapshot-20071201:1.62
	sid-snapshot-20071101:1.62
	gdb_6_7_1-2007-10-29-release:1.61
	gdb_6_7-2007-10-10-release:1.61
	sid-snapshot-20071001:1.62
	gdb_6_7-branch:1.61.0.4
	gdb_6_7-2007-09-07-branchpoint:1.61
	binutils-2_18:1.61
	binutils-2_18-branch:1.61.0.2
	binutils-2_18-branchpoint:1.61
	insight_6_6-20070208-release:1.57
	binutils-csl-coldfire-4_1-32:1.53
	binutils-csl-sourcerygxx-4_1-32:1.53
	gdb_6_6-2006-12-18-release:1.57
	binutils-csl-innovasic-fido-3_4_4-33:1.53
	binutils-csl-sourcerygxx-3_4_4-32:1.43
	binutils-csl-coldfire-4_1-30:1.53
	binutils-csl-sourcerygxx-4_1-30:1.53
	binutils-csl-coldfire-4_1-28:1.53
	binutils-csl-sourcerygxx-4_1-29:1.53
	binutils-csl-sourcerygxx-4_1-28:1.53
	gdb_6_6-branch:1.57.0.2
	gdb_6_6-2006-11-15-branchpoint:1.57
	binutils-csl-arm-2006q3-27:1.53
	binutils-csl-sourcerygxx-4_1-27:1.53
	binutils-csl-arm-2006q3-26:1.53
	binutils-csl-sourcerygxx-4_1-26:1.53
	binutils-csl-sourcerygxx-4_1-25:1.53
	binutils-csl-sourcerygxx-4_1-24:1.53
	binutils-csl-sourcerygxx-4_1-23:1.53
	insight_6_5-20061003-release:1.54
	gdb-csl-symbian-6_4_50_20060226-12:1.52
	binutils-csl-sourcerygxx-4_1-21:1.53
	binutils-csl-arm-2006q3-21:1.53
	binutils-csl-sourcerygxx-4_1-22:1.53
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.53
	binutils-csl-sourcerygxx-4_1-20:1.53
	binutils-csl-arm-2006q3-19:1.53
	binutils-csl-sourcerygxx-4_1-19:1.53
	binutils-csl-sourcerygxx-4_1-18:1.53
	binutils-csl-renesas-4_1-9:1.53
	gdb-csl-sourcerygxx-3_4_4-25:1.51
	binutils-csl-sourcerygxx-3_4_4-25:1.43
	nickrob-async-20060828-mergepoint:1.56
	gdb-csl-symbian-6_4_50_20060226-11:1.52
	binutils-csl-renesas-4_1-8:1.53
	binutils-csl-renesas-4_1-7:1.53
	binutils-csl-renesas-4_1-6:1.53
	gdb-csl-sourcerygxx-4_1-17:1.52
	binutils-csl-sourcerygxx-4_1-17:1.53
	gdb-csl-20060226-branch-local-2:1.52
	gdb-csl-sourcerygxx-4_1-14:1.52
	binutils-csl-sourcerygxx-4_1-14:1.53
	binutils-csl-sourcerygxx-4_1-15:1.53
	gdb-csl-sourcerygxx-4_1-13:1.52
	binutils-csl-sourcerygxx-4_1-13:1.53
	binutils-2_17:1.53
	gdb-csl-sourcerygxx-4_1-12:1.52
	binutils-csl-sourcerygxx-4_1-12:1.53
	gdb-csl-sourcerygxx-3_4_4-21:1.52
	binutils-csl-sourcerygxx-3_4_4-21:1.53
	gdb_6_5-20060621-release:1.54
	binutils-csl-wrs-linux-3_4_4-24:1.43
	binutils-csl-wrs-linux-3_4_4-23:1.43
	gdb-csl-sourcerygxx-4_1-9:1.52
	binutils-csl-sourcerygxx-4_1-9:1.53
	gdb-csl-sourcerygxx-4_1-8:1.52
	binutils-csl-sourcerygxx-4_1-8:1.53
	gdb-csl-sourcerygxx-4_1-7:1.52
	binutils-csl-sourcerygxx-4_1-7:1.53
	gdb-csl-arm-2006q1-6:1.52
	binutils-csl-arm-2006q1-6:1.53
	gdb-csl-sourcerygxx-4_1-6:1.52
	binutils-csl-sourcerygxx-4_1-6:1.53
	binutils-csl-wrs-linux-3_4_4-22:1.43
	gdb-csl-symbian-6_4_50_20060226-10:1.52
	gdb-csl-symbian-6_4_50_20060226-9:1.52
	gdb-csl-symbian-6_4_50_20060226-8:1.52
	gdb-csl-coldfire-4_1-11:1.52
	binutils-csl-coldfire-4_1-11:1.53
	gdb-csl-sourcerygxx-3_4_4-19:1.52
	binutils-csl-sourcerygxx-3_4_4-19:1.53
	gdb-csl-coldfire-4_1-10:1.52
	gdb_6_5-branch:1.54.0.4
	gdb_6_5-2006-05-14-branchpoint:1.54
	binutils-csl-coldfire-4_1-10:1.53
	gdb-csl-sourcerygxx-4_1-5:1.52
	binutils-csl-sourcerygxx-4_1-5:1.53
	nickrob-async-20060513-branch:1.54.0.2
	nickrob-async-20060513-branchpoint:1.54
	gdb-csl-sourcerygxx-4_1-4:1.52
	binutils-csl-sourcerygxx-4_1-4:1.53
	msnyder-reverse-20060502-branch:1.53.0.10
	msnyder-reverse-20060502-branchpoint:1.53
	binutils-csl-wrs-linux-3_4_4-21:1.43
	gdb-csl-morpho-4_1-4:1.52
	binutils-csl-morpho-4_1-4:1.53
	gdb-csl-sourcerygxx-3_4_4-17:1.52
	binutils-csl-sourcerygxx-3_4_4-17:1.53
	binutils-csl-wrs-linux-3_4_4-20:1.43
	readline_5_1-import-branch:1.53.0.8
	readline_5_1-import-branchpoint:1.53
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.52
	binutils-2_17-branch:1.53.0.6
	binutils-2_17-branchpoint:1.53
	gdb-csl-symbian-20060226-branch:1.52.0.6
	gdb-csl-symbian-20060226-branchpoint:1.52
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.52
	msnyder-reverse-20060331-branch:1.53.0.4
	msnyder-reverse-20060331-branchpoint:1.53
	binutils-csl-2_17-branch:1.53.0.2
	binutils-csl-2_17-branchpoint:1.53
	gdb-csl-available-20060303-branch:1.52.0.4
	gdb-csl-available-20060303-branchpoint:1.52
	gdb-csl-20060226-branch:1.52.0.2
	gdb-csl-20060226-branchpoint:1.52
	gdb_6_4-20051202-release:1.51
	msnyder-fork-checkpoint-branch:1.51.0.8
	msnyder-fork-checkpoint-branchpoint:1.51
	gdb-csl-gxxpro-6_3-branch:1.51.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.51
	gdb_6_4-branch:1.51.0.4
	gdb_6_4-2005-11-01-branchpoint:1.51
	gdb-csl-arm-20051020-branch:1.51.0.2
	gdb-csl-arm-20051020-branchpoint:1.51
	binutils-csl-gxxpro-3_4-branch:1.43.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.43
	binutils-2_16_1:1.43
	msnyder-tracepoint-checkpoint-branch:1.49.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.49
	gdb-csl-arm-20050325-2005-q1b:1.45
	binutils-csl-arm-2005q1b:1.43
	binutils-2_16:1.43
	gdb-csl-arm-20050325-2005-q1a:1.45
	binutils-csl-arm-2005q1a:1.43
	csl-arm-20050325-branch:1.45.0.2
	csl-arm-20050325-branchpoint:1.45
	binutils-csl-arm-2005q1-branch:1.43.0.4
	binutils-csl-arm-2005q1-branchpoint:1.43
	binutils-2_16-branch:1.43.0.2
	binutils-2_16-branchpoint:1.43
	csl-arm-2004-q3d:1.41
	gdb_6_3-20041109-release:1.41
	gdb_6_3-branch:1.41.0.2
	gdb_6_3-20041019-branchpoint:1.41
	csl-arm-2004-q3:1.40
	drow_intercu-merge-20040921:1.40
	drow_intercu-merge-20040915:1.40
	jimb-gdb_6_2-e500-branch:1.38.0.6
	jimb-gdb_6_2-e500-branchpoint:1.38
	gdb_6_2-20040730-release:1.38
	gdb_6_2-branch:1.38.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.38
	gdb_6_1_1-20040616-release:1.36
	binutils-2_15:1.36
	binutils-2_15-branchpoint:1.36
	csl-arm-2004-q1a:1.37
	csl-arm-2004-q1:1.36
	gdb_6_1-2004-04-05-release:1.36
	drow_intercu-merge-20040402:1.36
	drow_intercu-merge-20040327:1.36
	ezannoni_pie-20040323-branch:1.36.0.14
	ezannoni_pie-20040323-branchpoint:1.36
	cagney_tramp-20040321-mergepoint:1.36
	cagney_tramp-20040309-branch:1.36.0.12
	cagney_tramp-20040309-branchpoint:1.36
	gdb_6_1-branch:1.36.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.36
	drow_intercu-20040221-branch:1.36.0.8
	drow_intercu-20040221-branchpoint:1.36
	binutils-2_15-branch:1.36.0.6
	cagney_bfdfile-20040213-branch:1.36.0.4
	cagney_bfdfile-20040213-branchpoint:1.36
	drow-cplus-merge-20040208:1.36
	carlton_dictionary-20040126-merge:1.36
	cagney_bigcore-20040122-branch:1.36.0.2
	cagney_bigcore-20040122-branchpoint:1.36
	drow-cplus-merge-20040113:1.36
	csl-arm-2003-q4:1.36
	drow-cplus-merge-20031224:1.36
	drow-cplus-merge-20031220:1.36
	carlton_dictionary-20031215-merge:1.36
	drow-cplus-merge-20031214:1.36
	carlton-dictionary-20031111-merge:1.35
	gdb_6_0-2003-10-04-release:1.31
	kettenis_sparc-20030918-branch:1.32.0.6
	kettenis_sparc-20030918-branchpoint:1.32
	carlton_dictionary-20030917-merge:1.32
	ezannoni_pie-20030916-branchpoint:1.32
	ezannoni_pie-20030916-branch:1.32.0.4
	cagney_x86i386-20030821-branch:1.32.0.2
	cagney_x86i386-20030821-branchpoint:1.32
	carlton_dictionary-20030805-merge:1.32
	carlton_dictionary-20030627-merge:1.32
	gdb_6_0-branch:1.31.0.26
	gdb_6_0-2003-06-23-branchpoint:1.31
	jimb-ppc64-linux-20030613-branch:1.31.0.24
	jimb-ppc64-linux-20030613-branchpoint:1.31
	binutils-2_14:1.31
	cagney_convert-20030606-branch:1.31.0.22
	cagney_convert-20030606-branchpoint:1.31
	cagney_writestrings-20030508-branch:1.31.0.20
	cagney_writestrings-20030508-branchpoint:1.31
	jimb-ppc64-linux-20030528-branch:1.31.0.18
	jimb-ppc64-linux-20030528-branchpoint:1.31
	carlton_dictionary-20030523-merge:1.31
	cagney_fileio-20030521-branch:1.31.0.16
	cagney_fileio-20030521-branchpoint:1.31
	kettenis_i386newframe-20030517-mergepoint:1.31
	jimb-ppc64-linux-20030509-branch:1.31.0.14
	jimb-ppc64-linux-20030509-branchpoint:1.31
	kettenis_i386newframe-20030504-mergepoint:1.31
	carlton_dictionary-20030430-merge:1.31
	binutils-2_14-branch:1.31.0.12
	binutils-2_14-branchpoint:1.31
	kettenis_i386newframe-20030419-branch:1.31.0.10
	kettenis_i386newframe-20030419-branchpoint:1.31
	carlton_dictionary-20030416-merge:1.31
	cagney_frameaddr-20030409-mergepoint:1.31
	kettenis_i386newframe-20030406-branch:1.31.0.8
	kettenis_i386newframe-20030406-branchpoint:1.31
	cagney_frameaddr-20030403-branchpoint:1.31
	cagney_frameaddr-20030403-branch:1.31.0.6
	cagney_framebase-20030330-mergepoint:1.31
	cagney_framebase-20030326-branch:1.31.0.4
	cagney_framebase-20030326-branchpoint:1.31
	cagney_lazyid-20030317-branch:1.31.0.2
	cagney_lazyid-20030317-branchpoint:1.31
	kettenis-i386newframe-20030316-mergepoint:1.31
	offbyone-20030313-branch:1.30.0.6
	offbyone-20030313-branchpoint:1.30
	kettenis-i386newframe-20030308-branch:1.30.0.4
	kettenis-i386newframe-20030308-branchpoint:1.30
	carlton_dictionary-20030305-merge:1.30
	cagney_offbyone-20030303-branch:1.30.0.2
	cagney_offbyone-20030303-branchpoint:1.30
	carlton_dictionary-20030207-merge:1.30
	interps-20030202-branch:1.29.0.4
	interps-20030202-branchpoint:1.29
	cagney-unwind-20030108-branch:1.29.0.2
	cagney-unwind-20030108-branchpoint:1.29
	binutils-2_13_2_1:1.27.2.1
	binutils-2_13_2:1.27.2.1
	carlton_dictionary-20021223-merge:1.29
	gdb_5_3-2002-12-12-release:1.28
	carlton_dictionary-20021115-merge:1.28
	binutils-2_13_1:1.27.2.1
	kseitz_interps-20021105-merge:1.28
	kseitz_interps-20021103-merge:1.28
	drow-cplus-merge-20021020:1.28
	drow-cplus-merge-20021025:1.28
	carlton_dictionary-20021025-merge:1.28
	carlton_dictionary-20021011-merge:1.28
	drow-cplus-branch:1.28.0.12
	drow-cplus-branchpoint:1.28
	kseitz_interps-20020930-merge:1.28
	carlton_dictionary-20020927-merge:1.28
	carlton_dictionary-branch:1.28.0.10
	carlton_dictionary-20020920-branchpoint:1.28
	sid-20020905-branchpoint:1.28
	sid-20020905-branch:1.28.0.8
	gdb_5_3-branch:1.28.0.6
	gdb_5_3-2002-09-04-branchpoint:1.28
	kseitz_interps-20020829-merge:1.28
	cagney_sysregs-20020825-branch:1.28.0.4
	cagney_sysregs-20020825-branchpoint:1.28
	readline_4_3-import-branch:1.28.0.2
	readline_4_3-import-branchpoint:1.28
	binutils-2_13:1.27
	gdb_5_2_1-2002-07-23-release:1.22
	binutils-2_13-branchpoint:1.27
	binutils-2_13-branch:1.27.0.2
	kseitz_interps-20020528-branch:1.24.0.2
	kseitz_interps-20020528-branchpoint:1.24
	cagney_regbuf-20020515-branch:1.23.0.4
	cagney_regbuf-20020515-branchpoint:1.23
	binutils-2_12_1:1.22
	jimb-macro-020506-branch:1.23.0.2
	jimb-macro-020506-branchpoint:1.23
	gdb_5_2-2002-04-29-release:1.22
	binutils-2_12:1.22
	gdb_5_2-branch:1.22.0.4
	gdb_5_2-2002-03-03-branchpoint:1.22
	binutils-2_12-branch:1.22.0.2
	binutils-2_12-branchpoint:1.22
	gdb_5_1_1-2002-01-24-release:1.16
	gdb_5_1_0_1-2002-01-03-release:1.16
	cygnus_cvs_20020108_pre:1.21
	gdb_5_1_0_1-2002-01-03-branch:1.16.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.16
	gdb_5_1-2001-11-21-release:1.16
	gdb_s390-2001-09-26-branch:1.16.0.4
	gdb_s390-2001-09-26-branchpoint:1.16
	gdb_5_1-2001-07-29-branch:1.16.0.2
	gdb_5_1-2001-07-29-branchpoint:1.16
	binutils-2_11_2:1.13.2.2
	binutils-2_11_1:1.13.2.2
	binutils-2_11:1.13
	x86_64versiong3:1.13
	binutils-2_11-branch:1.13.0.2
	insight-precleanup-2001-01-01:1.13
	binutils-2_10_1:1.7.2.1
	binutils-2_10:1.7.2.1
	gdb-premipsmulti-2000-06-06-branch:1.8.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.8
	gdb_5_0-2000-05-19-release:1.7
	gdb_4_18_2-2000-05-18-release:1.7
	gdb_4_95_1-2000-05-11-snapshot:1.7
	gdb_4_95_0-2000-04-27-snapshot:1.7
	gdb_5_0-2000-04-10-branch:1.7.0.4
	gdb_5_0-2000-04-10-branchpoint:1.7
	binutils-2_10-branch:1.7.0.2
	binutils-2_10-branchpoint:1.7
	binutils_latest_snapshot:1.73
	repo-unification-2000-02-06:1.6
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.73
date	2013.01.10.20.03.54;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2011.07.11.15.03.06;	author clm;	state Exp;
branches;
next	1.71;

1.71
date	2011.06.06.01.26.03;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2010.06.27.04.07.53;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2010.03.24.15.41.59;	author hjl;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.26.13.42.26;	author gingold;	state Exp;
branches;
next	1.67;

1.67
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2009.11.23.14.41.29;	author pbrook;	state Exp;
branches;
next	1.65;

1.65
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2009.04.16.23.06.58;	author rsandifo;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.11.16.07.50;	author kazu;	state Exp;
branches;
next	1.61;

1.61
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.21.07.49.29;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2007.03.26.12.23.03;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.06.13.42.03;	author nathan;	state Exp;
branches;
next	1.52;

1.52
date	2006.02.07.19.01.09;	author nathan;	state Exp;
branches;
next	1.51;

1.51
date	2005.10.06.19.21.14;	author drow;	state Exp;
branches;
next	1.50;

1.50
date	2005.08.18.03.48.26;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2005.05.23.17.44.54;	author fnf;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.04.15.53.32;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.04.07.19.27;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.11.08.23.01;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.22.18.03.26;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.22.16.14.43;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.03.11.41.00;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2005.01.31.23.13.27;	author bje;	state Exp;
branches;
next	1.41;

1.41
date	2004.10.08.14.54.00;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.13.03.16.00;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.24.04.46.23;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.30.14.23.39;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches
	1.36.8.1;
next	1.35;

1.35
date	2003.11.04.10.41.51;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.21.13.28.58;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.16.04.11.06;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.25.06.40.21;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.14.12.47.20;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches
	1.30.4.1;
next	1.29;

1.29
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.30.05.49.24;	author amodra;	state Exp;
branches
	1.28.10.1
	1.28.12.1;
next	1.27;

1.27
date	2002.06.25.06.21.54;	author amodra;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2002.06.07.15.04.48;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.05.03.43.10;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.15.00.18.57;	author amodra;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2002.04.04.19.53.37;	author drow;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2002.01.30.16.07.28;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.20.23.30.37;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.19.05.33.12;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.18.09.57.25;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.23.15.45.19;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.15.14.44.40;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.11.12.23.47;	author jakub;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.06.20.15.27;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.25.21.53.44;	author nickc;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.10.10.23.38.27;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.10.15.50.35;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.07.19.46.11;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.07.19.39.55;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.19.10.53.01;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.11.23.09.42;	author amodra;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.12.10.18.51.35;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.12.10.01.41.22;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	99.11.09.19.11.52;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.07.19.14.55.16;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.10.29.45;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.36.8.1
date	2004.09.16.17.00.34;	author drow;	state Exp;
branches;
next	;

1.30.4.1
date	2003.03.16.14.01.44;	author kettenis;	state Exp;
branches;
next	;

1.28.10.1
date	2002.12.23.19.37.53;	author carlton;	state Exp;
branches;
next	1.28.10.2;

1.28.10.2
date	2003.02.07.19.17.40;	author carlton;	state Exp;
branches;
next	1.28.10.3;

1.28.10.3
date	2003.04.16.19.56.46;	author carlton;	state Exp;
branches;
next	1.28.10.4;

1.28.10.4
date	2003.06.27.21.49.28;	author carlton;	state Exp;
branches;
next	1.28.10.5;

1.28.10.5
date	2003.11.11.23.50.27;	author carlton;	state Exp;
branches;
next	1.28.10.6;

1.28.10.6
date	2003.12.15.23.59.50;	author carlton;	state Exp;
branches;
next	;

1.28.12.1
date	2003.12.14.20.26.46;	author drow;	state Exp;
branches;
next	;

1.27.2.1
date	2002.09.23.22.12.41;	author drow;	state Exp;
branches;
next	;

1.24.2.1
date	2002.06.20.01.30.57;	author kseitz;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.07.22.21.46.48;	author kseitz;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2002.08.09.18.34.17;	author kseitz;	state Exp;
branches;
next	;

1.23.4.1
date	2002.06.15.16.42.39;	author cagney;	state Exp;
branches;
next	;

1.13.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.06.11.10.04.17;	author amodra;	state Exp;
branches;
next	;

1.7.2.1
date	2000.04.19.11.13.16;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches;
next	;


desc
@@


1.73
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* BFD back-end for ieee-695 objects.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011
   Free Software Foundation, Inc.

   Written by Steve Chamberlain of Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


#define KEEPMINUSPCININST 0

/* IEEE 695 format is a stream of records, which we parse using a simple one-
   token (which is one byte in this lexicon) lookahead recursive decent
   parser.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "ieee.h"
#include "libieee.h"
#include "safe-ctype.h"

struct output_buffer_struct
{
  unsigned char *ptrp;
  int buffer;
};

static unsigned char *output_ptr_start;
static unsigned char *output_ptr;
static unsigned char *output_ptr_end;
static unsigned char *input_ptr_start;
static unsigned char *input_ptr;
static unsigned char *input_ptr_end;
static bfd *input_bfd;
static bfd *output_bfd;
static int output_buffer;


static void block (void);

/* Functions for writing to ieee files in the strange way that the
   standard requires.  */

static bfd_boolean
ieee_write_byte (bfd *abfd, int barg)
{
  bfd_byte byte;

  byte = barg;
  if (bfd_bwrite ((void *) &byte, (bfd_size_type) 1, abfd) != 1)
    return FALSE;
  return TRUE;
}

static bfd_boolean
ieee_write_2bytes (bfd *abfd, int bytes)
{
  bfd_byte buffer[2];

  buffer[0] = bytes >> 8;
  buffer[1] = bytes & 0xff;
  if (bfd_bwrite ((void *) buffer, (bfd_size_type) 2, abfd) != 2)
    return FALSE;
  return TRUE;
}

static bfd_boolean
ieee_write_int (bfd *abfd, bfd_vma value)
{
  if (value <= 127)
    {
      if (! ieee_write_byte (abfd, (bfd_byte) value))
	return FALSE;
    }
  else
    {
      unsigned int length;

      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
      if (value & 0xff000000)
	length = 4;
      else if (value & 0x00ff0000)
	length = 3;
      else if (value & 0x0000ff00)
	length = 2;
      else
	length = 1;

      if (! ieee_write_byte (abfd,
			     (bfd_byte) ((int) ieee_number_repeat_start_enum
					 + length)))
	return FALSE;
      switch (length)
	{
	case 4:
	  if (! ieee_write_byte (abfd, (bfd_byte) (value >> 24)))
	    return FALSE;
	  /* Fall through.  */
	case 3:
	  if (! ieee_write_byte (abfd, (bfd_byte) (value >> 16)))
	    return FALSE;
	  /* Fall through.  */
	case 2:
	  if (! ieee_write_byte (abfd, (bfd_byte) (value >> 8)))
	    return FALSE;
	  /* Fall through.  */
	case 1:
	  if (! ieee_write_byte (abfd, (bfd_byte) (value)))
	    return FALSE;
	}
    }

  return TRUE;
}

static bfd_boolean
ieee_write_id (bfd *abfd, const char *id)
{
  size_t length = strlen (id);

  if (length <= 127)
    {
      if (! ieee_write_byte (abfd, (bfd_byte) length))
	return FALSE;
    }
  else if (length < 255)
    {
      if (! ieee_write_byte (abfd, ieee_extension_length_1_enum)
	  || ! ieee_write_byte (abfd, (bfd_byte) length))
	return FALSE;
    }
  else if (length < 65535)
    {
      if (! ieee_write_byte (abfd, ieee_extension_length_2_enum)
	  || ! ieee_write_2bytes (abfd, (int) length))
	return FALSE;
    }
  else
    {
      (*_bfd_error_handler)
	(_("%s: string too long (%d chars, max 65535)"),
	 bfd_get_filename (abfd), length);
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  if (bfd_bwrite ((void *) id, (bfd_size_type) length, abfd) != length)
    return FALSE;
  return TRUE;
}

/* Functions for reading from ieee files in the strange way that the
   standard requires.  */

#define this_byte(ieee)           *((ieee)->input_p)
#define next_byte(ieee)            ((ieee)->input_p++)
#define this_byte_and_next(ieee) (*((ieee)->input_p++))

static unsigned short
read_2bytes (common_header_type *ieee)
{
  unsigned char c1 = this_byte_and_next (ieee);
  unsigned char c2 = this_byte_and_next (ieee);

  return (c1 << 8) | c2;
}

static void
bfd_get_string (common_header_type *ieee, char *string, size_t length)
{
  size_t i;

  for (i = 0; i < length; i++)
    string[i] = this_byte_and_next (ieee);
}

static char *
read_id (common_header_type *ieee)
{
  size_t length;
  char *string;

  length = this_byte_and_next (ieee);
  if (length <= 0x7f)
    /* Simple string of length 0 to 127.  */
    ;

  else if (length == 0xde)
    /* Length is next byte, allowing 0..255.  */
    length = this_byte_and_next (ieee);

  else if (length == 0xdf)
    {
      /* Length is next two bytes, allowing 0..65535.  */
      length = this_byte_and_next (ieee);
      length = (length * 256) + this_byte_and_next (ieee);
    }

  /* Buy memory and read string.  */
  string = bfd_alloc (ieee->abfd, (bfd_size_type) length + 1);
  if (!string)
    return NULL;
  bfd_get_string (ieee, string, length);
  string[length] = 0;
  return string;
}

static bfd_boolean
ieee_write_expression (bfd *abfd,
		       bfd_vma value,
		       asymbol *symbol,
		       bfd_boolean pcrel,
		       unsigned int sindex)
{
  unsigned int term_count = 0;

  if (value != 0)
    {
      if (! ieee_write_int (abfd, value))
	return FALSE;
      term_count++;
    }

  /* Badly formatted binaries can have a missing symbol,
     so test here to prevent a seg fault.  */
  if (symbol != NULL)
    {
      if (bfd_is_com_section (symbol->section)
	  || bfd_is_und_section (symbol->section))
	{
	  /* Def of a common symbol.  */
	  if (! ieee_write_byte (abfd, ieee_variable_X_enum)
	      || ! ieee_write_int (abfd, symbol->value))
	    return FALSE;
	  term_count ++;
	}
      else if (! bfd_is_abs_section (symbol->section))
	{
	  /* Ref to defined symbol -  */
	  if (symbol->flags & BSF_GLOBAL)
	    {
	      if (! ieee_write_byte (abfd, ieee_variable_I_enum)
		  || ! ieee_write_int (abfd, symbol->value))
		return FALSE;
	      term_count++;
	    }
	  else if (symbol->flags & (BSF_LOCAL | BSF_SECTION_SYM))
	    {
	      /* This is a reference to a defined local symbol.  We can
		 easily do a local as a section+offset.  */
	      if (! ieee_write_byte (abfd, ieee_variable_R_enum)
		  || ! ieee_write_byte (abfd,
					(bfd_byte) (symbol->section->index
						    + IEEE_SECTION_NUMBER_BASE)))
		return FALSE;

	      term_count++;
	      if (symbol->value != 0)
		{
		  if (! ieee_write_int (abfd, symbol->value))
		    return FALSE;
		  term_count++;
		}
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: unrecognized symbol `%s' flags 0x%x"),
		 bfd_get_filename (abfd), bfd_asymbol_name (symbol),
		 symbol->flags);
	      bfd_set_error (bfd_error_invalid_operation);
	      return FALSE;
	    }
	}
    }

  if (pcrel)
    {
      /* Subtract the pc from here by asking for PC of this section.  */
      if (! ieee_write_byte (abfd, ieee_variable_P_enum)
	  || ! ieee_write_byte (abfd,
				(bfd_byte) (sindex + IEEE_SECTION_NUMBER_BASE))
	  || ! ieee_write_byte (abfd, ieee_function_minus_enum))
	return FALSE;
    }

  /* Handle the degenerate case of a 0 address.  */
  if (term_count == 0)
    if (! ieee_write_int (abfd, (bfd_vma) 0))
      return FALSE;

  while (term_count > 1)
    {
      if (! ieee_write_byte (abfd, ieee_function_plus_enum))
	return FALSE;
      term_count--;
    }

  return TRUE;
}

/* Writes any integer into the buffer supplied and always takes 5 bytes.  */

static void
ieee_write_int5 (bfd_byte *buffer, bfd_vma value)
{
  buffer[0] = (bfd_byte) ieee_number_repeat_4_enum;
  buffer[1] = (value >> 24) & 0xff;
  buffer[2] = (value >> 16) & 0xff;
  buffer[3] = (value >> 8) & 0xff;
  buffer[4] = (value >> 0) & 0xff;
}

static bfd_boolean
ieee_write_int5_out (bfd *abfd, bfd_vma value)
{
  bfd_byte b[5];

  ieee_write_int5 (b, value);
  if (bfd_bwrite ((void *) b, (bfd_size_type) 5, abfd) != 5)
    return FALSE;
  return TRUE;
}

static bfd_boolean
parse_int (common_header_type *ieee, bfd_vma *value_ptr)
{
  int value = this_byte (ieee);
  int result;

  if (value >= 0 && value <= 127)
    {
      *value_ptr = value;
      next_byte (ieee);
      return TRUE;
    }
  else if (value >= 0x80 && value <= 0x88)
    {
      unsigned int count = value & 0xf;

      result = 0;
      next_byte (ieee);
      while (count)
	{
	  result = (result << 8) | this_byte_and_next (ieee);
	  count--;
	}
      *value_ptr = result;
      return TRUE;
    }
  return FALSE;
}

static int
parse_i (common_header_type *ieee, bfd_boolean *ok)
{
  bfd_vma x = 0;
  *ok = parse_int (ieee, &x);
  return x;
}

static bfd_vma
must_parse_int (common_header_type *ieee)
{
  bfd_vma result = 0;
  BFD_ASSERT (parse_int (ieee, &result));
  return result;
}

typedef struct
{
  bfd_vma value;
  asection *section;
  ieee_symbol_index_type symbol;
} ieee_value_type;


#if KEEPMINUSPCININST

#define SRC_MASK(arg) arg
#define PCREL_OFFSET FALSE

#else

#define SRC_MASK(arg) 0
#define PCREL_OFFSET TRUE

#endif

static reloc_howto_type abs32_howto =
  HOWTO (1,
	 0,
	 2,
	 32,
	 FALSE,
	 0,
	 complain_overflow_bitfield,
	 0,
	 "abs32",
	 TRUE,
	 0xffffffff,
	 0xffffffff,
	 FALSE);

static reloc_howto_type abs16_howto =
  HOWTO (1,
	 0,
	 1,
	 16,
	 FALSE,
	 0,
	 complain_overflow_bitfield,
	 0,
	 "abs16",
	 TRUE,
	 0x0000ffff,
	 0x0000ffff,
	 FALSE);

static reloc_howto_type abs8_howto =
  HOWTO (1,
	 0,
	 0,
	 8,
	 FALSE,
	 0,
	 complain_overflow_bitfield,
	 0,
	 "abs8",
	 TRUE,
	 0x000000ff,
	 0x000000ff,
	 FALSE);

static reloc_howto_type rel32_howto =
  HOWTO (1,
	 0,
	 2,
	 32,
	 TRUE,
	 0,
	 complain_overflow_signed,
	 0,
	 "rel32",
	 TRUE,
	 SRC_MASK (0xffffffff),
	 0xffffffff,
	 PCREL_OFFSET);

static reloc_howto_type rel16_howto =
  HOWTO (1,
	 0,
	 1,
	 16,
	 TRUE,
	 0,
	 complain_overflow_signed,
	 0,
	 "rel16",
	 TRUE,
	 SRC_MASK (0x0000ffff),
	 0x0000ffff,
	 PCREL_OFFSET);

static reloc_howto_type rel8_howto =
  HOWTO (1,
	 0,
	 0,
	 8,
	 TRUE,
	 0,
	 complain_overflow_signed,
	 0,
	 "rel8",
	 TRUE,
	 SRC_MASK (0x000000ff),
	 0x000000ff,
	 PCREL_OFFSET);

static ieee_symbol_index_type NOSYMBOL = {0, 0};

static void
parse_expression (ieee_data_type *ieee,
		  bfd_vma *value,
		  ieee_symbol_index_type *symbol,
		  bfd_boolean *pcrel,
		  unsigned int *extra,
		  asection **section)

{
  bfd_boolean loop = TRUE;
  ieee_value_type stack[10];
  ieee_value_type *sp = stack;
  asection *dummy;

#define POS sp[1]
#define TOS sp[0]
#define NOS sp[-1]
#define INC sp++;
#define DEC sp--;

  /* The stack pointer always points to the next unused location.  */
#define PUSH(x,y,z) TOS.symbol = x; TOS.section = y; TOS.value = z; INC;
#define POP(x,y,z)  DEC; x = TOS.symbol; y = TOS.section; z = TOS.value;

  while (loop && ieee->h.input_p < ieee->h.last_byte)
    {
      switch (this_byte (&(ieee->h)))
	{
	case ieee_variable_P_enum:
	  /* P variable, current program counter for section n.  */
	  {
	    int section_n;

	    next_byte (&(ieee->h));
	    *pcrel = TRUE;
	    section_n = must_parse_int (&(ieee->h));
	    (void) section_n;
	    PUSH (NOSYMBOL, bfd_abs_section_ptr, 0);
	    break;
	  }
	case ieee_variable_L_enum:
	  /* L variable  address of section N.  */
	  next_byte (&(ieee->h));
	  PUSH (NOSYMBOL, ieee->section_table[must_parse_int (&(ieee->h))], 0);
	  break;
	case ieee_variable_R_enum:
	  /* R variable, logical address of section module.  */
	  /* FIXME, this should be different to L.  */
	  next_byte (&(ieee->h));
	  PUSH (NOSYMBOL, ieee->section_table[must_parse_int (&(ieee->h))], 0);
	  break;
	case ieee_variable_S_enum:
	  /* S variable, size in MAUS of section module.  */
	  next_byte (&(ieee->h));
	  PUSH (NOSYMBOL,
		0,
		ieee->section_table[must_parse_int (&(ieee->h))]->size);
	  break;
	case ieee_variable_I_enum:
	  /* Push the address of variable n.  */
	  {
	    ieee_symbol_index_type sy;

	    next_byte (&(ieee->h));
	    sy.index = (int) must_parse_int (&(ieee->h));
	    sy.letter = 'I';

	    PUSH (sy, bfd_abs_section_ptr, 0);
	  }
	  break;
	case ieee_variable_X_enum:
	  /* Push the address of external variable n.  */
	  {
	    ieee_symbol_index_type sy;

	    next_byte (&(ieee->h));
	    sy.index = (int) (must_parse_int (&(ieee->h)));
	    sy.letter = 'X';

	    PUSH (sy, bfd_und_section_ptr, 0);
	  }
	  break;
	case ieee_function_minus_enum:
	  {
	    bfd_vma value1, value2;
	    asection *section1, *section_dummy;
	    ieee_symbol_index_type sy;

	    next_byte (&(ieee->h));

	    POP (sy, section1, value1);
	    POP (sy, section_dummy, value2);
	    PUSH (sy, section1 ? section1 : section_dummy, value2 - value1);
	  }
	  break;
	case ieee_function_plus_enum:
	  {
	    bfd_vma value1, value2;
	    asection *section1;
	    asection *section2;
	    ieee_symbol_index_type sy1;
	    ieee_symbol_index_type sy2;

	    next_byte (&(ieee->h));

	    POP (sy1, section1, value1);
	    POP (sy2, section2, value2);
	    PUSH (sy1.letter ? sy1 : sy2,
		  bfd_is_abs_section (section1) ? section2 : section1,
		  value1 + value2);
	  }
	  break;
	default:
	  {
	    bfd_vma va;

	    BFD_ASSERT (this_byte (&(ieee->h)) < (int) ieee_variable_A_enum
		    || this_byte (&(ieee->h)) > (int) ieee_variable_Z_enum);
	    if (parse_int (&(ieee->h), &va))
	      {
		PUSH (NOSYMBOL, bfd_abs_section_ptr, va);
	      }
	    else
	      /* Thats all that we can understand.  */
	      loop = FALSE;
	  }
	}
    }

  /* As far as I can see there is a bug in the Microtec IEEE output
     which I'm using to scan, whereby the comma operator is omitted
     sometimes in an expression, giving expressions with too many
     terms.  We can tell if that's the case by ensuring that
     sp == stack here.  If not, then we've pushed something too far,
     so we keep adding.  */
  while (sp != stack + 1)
    {
      asection *section1;
      ieee_symbol_index_type sy1;

      POP (sy1, section1, *extra);
      (void) section1;
      (void) sy1;
    }

  POP (*symbol, dummy, *value);
  if (section)
    *section = dummy;
}


#define ieee_seek(ieee, offset) \
  do								\
    {								\
      ieee->h.input_p = ieee->h.first_byte + offset;		\
      ieee->h.last_byte = (ieee->h.first_byte			\
			   + ieee_part_after (ieee, offset));	\
    }								\
  while (0)

#define ieee_pos(ieee) \
  (ieee->h.input_p - ieee->h.first_byte)

/* Find the first part of the ieee file after HERE.  */

static file_ptr
ieee_part_after (ieee_data_type *ieee, file_ptr here)
{
  int part;
  file_ptr after = ieee->w.r.me_record;

  /* File parts can come in any order, except that module end is
     guaranteed to be last (and the header first).  */
  for (part = 0; part < N_W_VARIABLES; part++)
    if (ieee->w.offset[part] > here && after > ieee->w.offset[part])
      after = ieee->w.offset[part];

  return after;
}

static unsigned int last_index;
static char last_type;		/* Is the index for an X or a D.  */

static ieee_symbol_type *
get_symbol (bfd *abfd ATTRIBUTE_UNUSED,
	    ieee_data_type *ieee,
	    ieee_symbol_type *last_symbol,
	    unsigned int *symbol_count,
	    ieee_symbol_type ***pptr,
	    unsigned int *max_index,
	    int this_type)
{
  /* Need a new symbol.  */
  unsigned int new_index = must_parse_int (&(ieee->h));

  if (new_index != last_index || this_type != last_type)
    {
      ieee_symbol_type *new_symbol;
      bfd_size_type amt = sizeof (ieee_symbol_type);

      new_symbol = bfd_alloc (ieee->h.abfd, amt);
      if (!new_symbol)
	return NULL;

      new_symbol->index = new_index;
      last_index = new_index;
      (*symbol_count)++;
      **pptr = new_symbol;
      *pptr = &new_symbol->next;
      if (new_index > *max_index)
	*max_index = new_index;

      last_type = this_type;
      new_symbol->symbol.section = bfd_abs_section_ptr;
      return new_symbol;
    }
  return last_symbol;
}

static bfd_boolean
ieee_slurp_external_symbols (bfd *abfd)
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  file_ptr offset = ieee->w.r.external_part;

  ieee_symbol_type **prev_symbols_ptr = &ieee->external_symbols;
  ieee_symbol_type **prev_reference_ptr = &ieee->external_reference;
  ieee_symbol_type *symbol = NULL;
  unsigned int symbol_count = 0;
  bfd_boolean loop = TRUE;

  last_index = 0xffffff;
  ieee->symbol_table_full = TRUE;

  ieee_seek (ieee, offset);

  while (loop)
    {
      switch (this_byte (&(ieee->h)))
	{
	case ieee_nn_record:
	  next_byte (&(ieee->h));

	  symbol = get_symbol (abfd, ieee, symbol, &symbol_count,
			       & prev_symbols_ptr,
			       & ieee->external_symbol_max_index, 'I');
	  if (symbol == NULL)
	    return FALSE;

	  symbol->symbol.the_bfd = abfd;
	  symbol->symbol.name = read_id (&(ieee->h));
	  symbol->symbol.udata.p = NULL;
	  symbol->symbol.flags = BSF_NO_FLAGS;
	  break;
	case ieee_external_symbol_enum:
	  next_byte (&(ieee->h));

	  symbol = get_symbol (abfd, ieee, symbol, &symbol_count,
			       &prev_symbols_ptr,
			       &ieee->external_symbol_max_index, 'D');
	  if (symbol == NULL)
	    return FALSE;

	  BFD_ASSERT (symbol->index >= ieee->external_symbol_min_index);

	  symbol->symbol.the_bfd = abfd;
	  symbol->symbol.name = read_id (&(ieee->h));
	  symbol->symbol.udata.p = NULL;
	  symbol->symbol.flags = BSF_NO_FLAGS;
	  break;
	case ieee_attribute_record_enum >> 8:
	  {
	    unsigned int symbol_name_index;
	    unsigned int symbol_type_index;
	    unsigned int symbol_attribute_def;
	    bfd_vma value = 0;

	    switch (read_2bytes (&ieee->h))
	      {
	      case ieee_attribute_record_enum:
		symbol_name_index = must_parse_int (&(ieee->h));
		symbol_type_index = must_parse_int (&(ieee->h));
		(void) symbol_type_index;
		symbol_attribute_def = must_parse_int (&(ieee->h));
		switch (symbol_attribute_def)
		  {
		  case 8:
		  case 19:
		    parse_int (&ieee->h, &value);
		    break;
		  default:
		    (*_bfd_error_handler)
		      (_("%B: unimplemented ATI record %u for symbol %u"),
		       abfd, symbol_attribute_def, symbol_name_index);
		    bfd_set_error (bfd_error_bad_value);
		    return FALSE;
		    break;
		  }
		break;
	      case ieee_external_reference_info_record_enum:
		/* Skip over ATX record.  */
		parse_int (&(ieee->h), &value);
		parse_int (&(ieee->h), &value);
		parse_int (&(ieee->h), &value);
		parse_int (&(ieee->h), &value);
		break;
	      case ieee_atn_record_enum:
		/* We may get call optimization information here,
		   which we just ignore.  The format is
		   {$F1}${CE}{index}{$00}{$3F}{$3F}{#_of_ASNs}.  */
		parse_int (&ieee->h, &value);
		parse_int (&ieee->h, &value);
		parse_int (&ieee->h, &value);
		if (value != 0x3f)
		  {
		    (*_bfd_error_handler)
		      (_("%B: unexpected ATN type %d in external part"),
			 abfd, (int) value);
		    bfd_set_error (bfd_error_bad_value);
		    return FALSE;
		  }
		parse_int (&ieee->h, &value);
		parse_int (&ieee->h, &value);
		while (value > 0)
		  {
		    bfd_vma val1;

		    --value;

		    switch (read_2bytes (&ieee->h))
		      {
		      case ieee_asn_record_enum:
			parse_int (&ieee->h, &val1);
			parse_int (&ieee->h, &val1);
			break;

		      default:
			(*_bfd_error_handler)
			  (_("%B: unexpected type after ATN"), abfd);
			bfd_set_error (bfd_error_bad_value);
			return FALSE;
		      }
		  }
	      }
	  }
	  break;
	case ieee_value_record_enum >> 8:
	  {
	    unsigned int symbol_name_index;
	    ieee_symbol_index_type symbol_ignore;
	    bfd_boolean pcrel_ignore;
	    unsigned int extra;

	    next_byte (&(ieee->h));
	    next_byte (&(ieee->h));

	    symbol_name_index = must_parse_int (&(ieee->h));
	    (void) symbol_name_index;
	    parse_expression (ieee,
			      &symbol->symbol.value,
			      &symbol_ignore,
			      &pcrel_ignore,
			      &extra,
			      &symbol->symbol.section);

	    /* Fully linked IEEE-695 files tend to give every symbol
               an absolute value.  Try to convert that back into a
               section relative value.  FIXME: This won't always to
               the right thing.  */
	    if (bfd_is_abs_section (symbol->symbol.section)
		&& (abfd->flags & HAS_RELOC) == 0)
	      {
		bfd_vma val;
		asection *s;

		val = symbol->symbol.value;
		for (s = abfd->sections; s != NULL; s = s->next)
		  {
		    if (val >= s->vma && val < s->vma + s->size)
		      {
			symbol->symbol.section = s;
			symbol->symbol.value -= s->vma;
			break;
		      }
		  }
	      }

	    symbol->symbol.flags = BSF_GLOBAL | BSF_EXPORT;

	  }
	  break;
	case ieee_weak_external_reference_enum:
	  {
	    bfd_vma size;
	    bfd_vma value;

	    next_byte (&(ieee->h));
	    /* Throw away the external reference index.  */
	    (void) must_parse_int (&(ieee->h));
	    /* Fetch the default size if not resolved.  */
	    size = must_parse_int (&(ieee->h));
	    /* Fetch the default value if available.  */
	    if (! parse_int (&(ieee->h), &value))
	      value = 0;
	    /* This turns into a common.  */
	    symbol->symbol.section = bfd_com_section_ptr;
	    symbol->symbol.value = size;
	  }
	  break;

	case ieee_external_reference_enum:
	  next_byte (&(ieee->h));

	  symbol = get_symbol (abfd, ieee, symbol, &symbol_count,
			       &prev_reference_ptr,
			       &ieee->external_reference_max_index, 'X');
	  if (symbol == NULL)
	    return FALSE;

	  symbol->symbol.the_bfd = abfd;
	  symbol->symbol.name = read_id (&(ieee->h));
	  symbol->symbol.udata.p = NULL;
	  symbol->symbol.section = bfd_und_section_ptr;
	  symbol->symbol.value = (bfd_vma) 0;
	  symbol->symbol.flags = 0;

	  BFD_ASSERT (symbol->index >= ieee->external_reference_min_index);
	  break;

	default:
	  loop = FALSE;
	}
    }

  if (ieee->external_symbol_max_index != 0)
    {
      ieee->external_symbol_count =
	ieee->external_symbol_max_index -
	ieee->external_symbol_min_index + 1;
    }
  else
    ieee->external_symbol_count = 0;

  if (ieee->external_reference_max_index != 0)
    {
      ieee->external_reference_count =
	ieee->external_reference_max_index -
	ieee->external_reference_min_index + 1;
    }
  else
    ieee->external_reference_count = 0;

  abfd->symcount =
    ieee->external_reference_count + ieee->external_symbol_count;

  if (symbol_count != abfd->symcount)
    /* There are gaps in the table -- */
    ieee->symbol_table_full = FALSE;

  *prev_symbols_ptr   = NULL;
  *prev_reference_ptr = NULL;

  return TRUE;
}

static bfd_boolean
ieee_slurp_symbol_table (bfd *abfd)
{
  if (! IEEE_DATA (abfd)->read_symbols)
    {
      if (! ieee_slurp_external_symbols (abfd))
	return FALSE;
      IEEE_DATA (abfd)->read_symbols = TRUE;
    }
  return TRUE;
}

static long
ieee_get_symtab_upper_bound (bfd *abfd)
{
  if (! ieee_slurp_symbol_table (abfd))
    return -1;

  return (abfd->symcount != 0) ?
    (abfd->symcount + 1) * (sizeof (ieee_symbol_type *)) : 0;
}

/* Move from our internal lists to the canon table, and insert in
   symbol index order.  */

extern const bfd_target ieee_vec;

static long
ieee_canonicalize_symtab (bfd *abfd, asymbol **location)
{
  ieee_symbol_type *symp;
  static bfd dummy_bfd;
  static asymbol empty_symbol =
  {
    &dummy_bfd,
    " ieee empty",
    (symvalue) 0,
    BSF_DEBUGGING,
    bfd_abs_section_ptr
#ifdef __STDC__
    /* K&R compilers can't initialise unions.  */
    , { 0 }
#endif
  };

  if (abfd->symcount)
    {
      ieee_data_type *ieee = IEEE_DATA (abfd);

      dummy_bfd.xvec = &ieee_vec;
      if (! ieee_slurp_symbol_table (abfd))
	return -1;

      if (! ieee->symbol_table_full)
	{
	  /* Arrgh - there are gaps in the table, run through and fill them
	     up with pointers to a null place.  */
	  unsigned int i;

	  for (i = 0; i < abfd->symcount; i++)
	    location[i] = &empty_symbol;
	}

      ieee->external_symbol_base_offset = -ieee->external_symbol_min_index;
      for (symp = IEEE_DATA (abfd)->external_symbols;
	   symp != (ieee_symbol_type *) NULL;
	   symp = symp->next)
	/* Place into table at correct index locations.  */
	location[symp->index + ieee->external_symbol_base_offset] = &symp->symbol;

      /* The external refs are indexed in a bit.  */
      ieee->external_reference_base_offset =
	-ieee->external_reference_min_index + ieee->external_symbol_count;

      for (symp = IEEE_DATA (abfd)->external_reference;
	   symp != (ieee_symbol_type *) NULL;
	   symp = symp->next)
	location[symp->index + ieee->external_reference_base_offset] =
	  &symp->symbol;
    }

  if (abfd->symcount)
    location[abfd->symcount] = (asymbol *) NULL;

  return abfd->symcount;
}

static asection *
get_section_entry (bfd *abfd, ieee_data_type *ieee, unsigned int sindex)
{
  if (sindex >= ieee->section_table_size)
    {
      unsigned int c, i;
      asection **n;
      bfd_size_type amt;

      c = ieee->section_table_size;
      if (c == 0)
	c = 20;
      while (c <= sindex)
	c *= 2;

      amt = c;
      amt *= sizeof (asection *);
      n = bfd_realloc (ieee->section_table, amt);
      if (n == NULL)
	return NULL;

      for (i = ieee->section_table_size; i < c; i++)
	n[i] = NULL;

      ieee->section_table = n;
      ieee->section_table_size = c;
    }

  if (ieee->section_table[sindex] == (asection *) NULL)
    {
      char *tmp = bfd_alloc (abfd, (bfd_size_type) 11);
      asection *section;

      if (!tmp)
	return NULL;
      sprintf (tmp, " fsec%4d", sindex);
      section = bfd_make_section (abfd, tmp);
      ieee->section_table[sindex] = section;
      section->target_index = sindex;
      ieee->section_table[sindex] = section;
    }
  return ieee->section_table[sindex];
}

static void
ieee_slurp_sections (bfd *abfd)
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  file_ptr offset = ieee->w.r.section_part;
  char *name;

  if (offset != 0)
    {
      bfd_byte section_type[3];

      ieee_seek (ieee, offset);
      while (TRUE)
	{
	  switch (this_byte (&(ieee->h)))
	    {
	    case ieee_section_type_enum:
	      {
		asection *section;
		unsigned int section_index;

		next_byte (&(ieee->h));
		section_index = must_parse_int (&(ieee->h));

		section = get_section_entry (abfd, ieee, section_index);

		section_type[0] = this_byte_and_next (&(ieee->h));

		/* Set minimal section attributes. Attributes are
		   extended later, based on section contents.  */
		switch (section_type[0])
		  {
		  case 0xC1:
		    /* Normal attributes for absolute sections.  */
		    section_type[1] = this_byte (&(ieee->h));
		    section->flags = SEC_ALLOC;
		    switch (section_type[1])
		      {
			/* AS Absolute section attributes.  */
		      case 0xD3:
			next_byte (&(ieee->h));
			section_type[2] = this_byte (&(ieee->h));
			switch (section_type[2])
			  {
			  case 0xD0:
			    /* Normal code.  */
			    next_byte (&(ieee->h));
			    section->flags |= SEC_CODE;
			    break;
			  case 0xC4:
			    /* Normal data.  */
			    next_byte (&(ieee->h));
			    section->flags |= SEC_DATA;
			    break;
			  case 0xD2:
			    next_byte (&(ieee->h));
			    /* Normal rom data.  */
			    section->flags |= SEC_ROM | SEC_DATA;
			    break;
			  default:
			    break;
			  }
		      }
		    break;

		    /* Named relocatable sections (type C).  */
		  case 0xC3:
		    section_type[1] = this_byte (&(ieee->h));
		    section->flags = SEC_ALLOC;
		    switch (section_type[1])
		      {
		      case 0xD0:	/* Normal code (CP).  */
			next_byte (&(ieee->h));
			section->flags |= SEC_CODE;
			break;
		      case 0xC4:	/* Normal data (CD).  */
			next_byte (&(ieee->h));
			section->flags |= SEC_DATA;
			break;
		      case 0xD2:	/* Normal rom data (CR).  */
			next_byte (&(ieee->h));
			section->flags |= SEC_ROM | SEC_DATA;
			break;
		      default:
			break;
		      }
		  }

		/* Read section name, use it if non empty.  */
		name = read_id (&ieee->h);
		if (name[0])
		  section->name = name;

		/* Skip these fields, which we don't care about.  */
		{
		  bfd_vma parent, brother, context;

		  parse_int (&(ieee->h), &parent);
		  parse_int (&(ieee->h), &brother);
		  parse_int (&(ieee->h), &context);
		}
	      }
	      break;
	    case ieee_section_alignment_enum:
	      {
		unsigned int section_index;
		bfd_vma value;
		asection *section;

		next_byte (&(ieee->h));
		section_index = must_parse_int (&ieee->h);
		section = get_section_entry (abfd, ieee, section_index);
		if (section_index > ieee->section_count)
		  ieee->section_count = section_index;

		section->alignment_power =
		  bfd_log2 (must_parse_int (&ieee->h));
		(void) parse_int (&(ieee->h), &value);
	      }
	      break;
	    case ieee_e2_first_byte_enum:
	      {
		asection *section;
		ieee_record_enum_type t;

		t = (ieee_record_enum_type) (read_2bytes (&(ieee->h)));
		switch (t)
		  {
		  case ieee_section_size_enum:
		    section = ieee->section_table[must_parse_int (&(ieee->h))];
		    section->size = must_parse_int (&(ieee->h));
		    break;
		  case ieee_physical_region_size_enum:
		    section = ieee->section_table[must_parse_int (&(ieee->h))];
		    section->size = must_parse_int (&(ieee->h));
		    break;
		  case ieee_region_base_address_enum:
		    section = ieee->section_table[must_parse_int (&(ieee->h))];
		    section->vma = must_parse_int (&(ieee->h));
		    section->lma = section->vma;
		    break;
		  case ieee_mau_size_enum:
		    must_parse_int (&(ieee->h));
		    must_parse_int (&(ieee->h));
		    break;
		  case ieee_m_value_enum:
		    must_parse_int (&(ieee->h));
		    must_parse_int (&(ieee->h));
		    break;
		  case ieee_section_base_address_enum:
		    section = ieee->section_table[must_parse_int (&(ieee->h))];
		    section->vma = must_parse_int (&(ieee->h));
		    section->lma = section->vma;
		    break;
		  case ieee_section_offset_enum:
		    (void) must_parse_int (&(ieee->h));
		    (void) must_parse_int (&(ieee->h));
		    break;
		  default:
		    return;
		  }
	      }
	      break;
	    default:
	      return;
	    }
	}
    }
}

/* Make a section for the debugging information, if any.  We don't try
   to interpret the debugging information; we just point the section
   at the area in the file so that program which understand can dig it
   out.  */

static bfd_boolean
ieee_slurp_debug (bfd *abfd)
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  asection *sec;
  file_ptr debug_end;
  flagword flags;

  if (ieee->w.r.debug_information_part == 0)
    return TRUE;

  flags = SEC_DEBUGGING | SEC_HAS_CONTENTS;
  sec = bfd_make_section_with_flags (abfd, ".debug", flags);
  if (sec == NULL)
    return FALSE;
  sec->filepos = ieee->w.r.debug_information_part;

  debug_end = ieee_part_after (ieee, ieee->w.r.debug_information_part);
  sec->size = debug_end - ieee->w.r.debug_information_part;

  return TRUE;
}

/* Archive stuff.  */

static const bfd_target *
ieee_archive_p (bfd *abfd)
{
  char *library;
  unsigned int i;
  unsigned char buffer[512];
  file_ptr buffer_offset = 0;
  ieee_ar_data_type *save = abfd->tdata.ieee_ar_data;
  ieee_ar_data_type *ieee;
  bfd_size_type alc_elts;
  ieee_ar_obstack_type *elts = NULL;
  bfd_size_type amt = sizeof (ieee_ar_data_type);

  abfd->tdata.ieee_ar_data = bfd_alloc (abfd, amt);
  if (!abfd->tdata.ieee_ar_data)
    goto error_ret_restore;
  ieee = IEEE_AR_DATA (abfd);

  /* Ignore the return value here.  It doesn't matter if we don't read
     the entire buffer.  We might have a very small ieee file.  */
  bfd_bread ((void *) buffer, (bfd_size_type) sizeof (buffer), abfd);

  ieee->h.first_byte = buffer;
  ieee->h.input_p = buffer;

  ieee->h.abfd = abfd;

  if (this_byte (&(ieee->h)) != Module_Beginning)
    goto got_wrong_format_error;

  next_byte (&(ieee->h));
  library = read_id (&(ieee->h));
  if (strcmp (library, "LIBRARY") != 0)
    goto got_wrong_format_error;

  /* Throw away the filename.  */
  read_id (&(ieee->h));

  ieee->element_count = 0;
  ieee->element_index = 0;

  next_byte (&(ieee->h));	/* Drop the ad part.  */
  must_parse_int (&(ieee->h));	/* And the two dummy numbers.  */
  must_parse_int (&(ieee->h));

  alc_elts = 10;
  elts = bfd_malloc (alc_elts * sizeof *elts);
  if (elts == NULL)
    goto error_return;

  /* Read the index of the BB table.  */
  while (1)
    {
      int rec;
      ieee_ar_obstack_type *t;

      rec = read_2bytes (&(ieee->h));
      if (rec != (int) ieee_assign_value_to_variable_enum)
	break;

      if (ieee->element_count >= alc_elts)
	{
	  ieee_ar_obstack_type *n;

	  alc_elts *= 2;
	  n = bfd_realloc (elts, alc_elts * sizeof (* elts));
	  if (n == NULL)
	    goto error_return;
	  elts = n;
	}

      t = &elts[ieee->element_count];
      ieee->element_count++;

      must_parse_int (&(ieee->h));
      t->file_offset = must_parse_int (&(ieee->h));
      t->abfd = (bfd *) NULL;

      /* Make sure that we don't go over the end of the buffer.  */
      if ((size_t) ieee_pos (IEEE_DATA (abfd)) > sizeof (buffer) / 2)
	{
	  /* Past half way, reseek and reprime.  */
	  buffer_offset += ieee_pos (IEEE_DATA (abfd));
	  if (bfd_seek (abfd, buffer_offset, SEEK_SET) != 0)
	    goto error_return;

	  /* Again ignore return value of bfd_bread.  */
	  bfd_bread ((void *) buffer, (bfd_size_type) sizeof (buffer), abfd);
	  ieee->h.first_byte = buffer;
	  ieee->h.input_p = buffer;
	}
    }

  amt = ieee->element_count;
  amt *= sizeof *ieee->elements;
  ieee->elements = bfd_alloc (abfd, amt);
  if (ieee->elements == NULL)
    goto error_return;

  memcpy (ieee->elements, elts, (size_t) amt);
  free (elts);
  elts = NULL;

  /* Now scan the area again, and replace BB offsets with file offsets.  */
  for (i = 2; i < ieee->element_count; i++)
    {
      if (bfd_seek (abfd, ieee->elements[i].file_offset, SEEK_SET) != 0)
	goto error_return;

      /* Again ignore return value of bfd_bread.  */
      bfd_bread ((void *) buffer, (bfd_size_type) sizeof (buffer), abfd);
      ieee->h.first_byte = buffer;
      ieee->h.input_p = buffer;

      next_byte (&(ieee->h));		/* Drop F8.  */
      next_byte (&(ieee->h));		/* Drop 14.  */
      must_parse_int (&(ieee->h));	/* Drop size of block.  */

      if (must_parse_int (&(ieee->h)) != 0)
	/* This object has been deleted.  */
	ieee->elements[i].file_offset = 0;
      else
	ieee->elements[i].file_offset = must_parse_int (&(ieee->h));
    }

  /*  abfd->has_armap = ;*/

  return abfd->xvec;

 got_wrong_format_error:
  bfd_set_error (bfd_error_wrong_format);
 error_return:
  if (elts != NULL)
    free (elts);
  bfd_release (abfd, ieee);
 error_ret_restore:
  abfd->tdata.ieee_ar_data = save;

  return NULL;
}

static bfd_boolean
ieee_mkobject (bfd *abfd)
{
  bfd_size_type amt;

  output_ptr_start = NULL;
  output_ptr = NULL;
  output_ptr_end = NULL;
  input_ptr_start = NULL;
  input_ptr = NULL;
  input_ptr_end = NULL;
  input_bfd = NULL;
  output_bfd = NULL;
  output_buffer = 0;
  amt = sizeof (ieee_data_type);
  abfd->tdata.ieee_data = bfd_zalloc (abfd, amt);
  return abfd->tdata.ieee_data != NULL;
}

static bfd_boolean
do_one (ieee_data_type *ieee,
	ieee_per_section_type *current_map,
	unsigned char *location_ptr,
	asection *s,
	int iterations)
{
  switch (this_byte (&(ieee->h)))
    {
    case ieee_load_constant_bytes_enum:
      {
	unsigned int number_of_maus;
	unsigned int i;

	next_byte (&(ieee->h));
	number_of_maus = must_parse_int (&(ieee->h));

	for (i = 0; i < number_of_maus; i++)
	  {
	    location_ptr[current_map->pc++] = this_byte (&(ieee->h));
	    next_byte (&(ieee->h));
	  }
      }
      break;

    case ieee_load_with_relocation_enum:
      {
	bfd_boolean loop = TRUE;

	next_byte (&(ieee->h));
	while (loop)
	  {
	    switch (this_byte (&(ieee->h)))
	      {
	      case ieee_variable_R_enum:

	      case ieee_function_signed_open_b_enum:
	      case ieee_function_unsigned_open_b_enum:
	      case ieee_function_either_open_b_enum:
		{
		  unsigned int extra = 4;
		  bfd_boolean pcrel = FALSE;
		  asection *section;
		  ieee_reloc_type *r;

		  r = bfd_alloc (ieee->h.abfd, sizeof (* r));
		  if (!r)
		    return FALSE;

		  *(current_map->reloc_tail_ptr) = r;
		  current_map->reloc_tail_ptr = &r->next;
		  r->next = (ieee_reloc_type *) NULL;
		  next_byte (&(ieee->h));
/*			    abort();*/
		  r->relent.sym_ptr_ptr = 0;
		  parse_expression (ieee,
				    &r->relent.addend,
				    &r->symbol,
				    &pcrel, &extra, &section);
		  r->relent.address = current_map->pc;
		  s->flags |= SEC_RELOC;
		  s->owner->flags |= HAS_RELOC;
		  s->reloc_count++;
		  if (r->relent.sym_ptr_ptr == NULL && section != NULL)
		    r->relent.sym_ptr_ptr = section->symbol_ptr_ptr;

		  if (this_byte (&(ieee->h)) == (int) ieee_comma)
		    {
		      next_byte (&(ieee->h));
		      /* Fetch number of bytes to pad.  */
		      extra = must_parse_int (&(ieee->h));
		    };

		  switch (this_byte (&(ieee->h)))
		    {
		    case ieee_function_signed_close_b_enum:
		      next_byte (&(ieee->h));
		      break;
		    case ieee_function_unsigned_close_b_enum:
		      next_byte (&(ieee->h));
		      break;
		    case ieee_function_either_close_b_enum:
		      next_byte (&(ieee->h));
		      break;
		    default:
		      break;
		    }
		  /* Build a relocation entry for this type.  */
		  /* If pc rel then stick -ve pc into instruction
		     and take out of reloc ..

		     I've changed this. It's all too complicated. I
		     keep 0 in the instruction now.  */

		  switch (extra)
		    {
		    case 0:
		    case 4:

		      if (pcrel)
			{
#if KEEPMINUSPCININST
			  bfd_put_32 (ieee->h.abfd, -current_map->pc,
				      location_ptr + current_map->pc);
			  r->relent.howto = &rel32_howto;
			  r->relent.addend -= current_map->pc;
#else
			  bfd_put_32 (ieee->h.abfd, (bfd_vma) 0, location_ptr +
				      current_map->pc);
			  r->relent.howto = &rel32_howto;
#endif
			}
		      else
			{
			  bfd_put_32 (ieee->h.abfd, (bfd_vma) 0,
				      location_ptr + current_map->pc);
			  r->relent.howto = &abs32_howto;
			}
		      current_map->pc += 4;
		      break;
		    case 2:
		      if (pcrel)
			{
#if KEEPMINUSPCININST
			  bfd_put_16 (ieee->h.abfd, (bfd_vma) -current_map->pc,
				      location_ptr + current_map->pc);
			  r->relent.addend -= current_map->pc;
			  r->relent.howto = &rel16_howto;
#else

			  bfd_put_16 (ieee->h.abfd, (bfd_vma) 0,
				      location_ptr + current_map->pc);
			  r->relent.howto = &rel16_howto;
#endif
			}

		      else
			{
			  bfd_put_16 (ieee->h.abfd, (bfd_vma) 0,
				      location_ptr + current_map->pc);
			  r->relent.howto = &abs16_howto;
			}
		      current_map->pc += 2;
		      break;
		    case 1:
		      if (pcrel)
			{
#if KEEPMINUSPCININST
			  bfd_put_8 (ieee->h.abfd, (int) (-current_map->pc), location_ptr + current_map->pc);
			  r->relent.addend -= current_map->pc;
			  r->relent.howto = &rel8_howto;
#else
			  bfd_put_8 (ieee->h.abfd, 0, location_ptr + current_map->pc);
			  r->relent.howto = &rel8_howto;
#endif
			}
		      else
			{
			  bfd_put_8 (ieee->h.abfd, 0, location_ptr + current_map->pc);
			  r->relent.howto = &abs8_howto;
			}
		      current_map->pc += 1;
		      break;

		    default:
		      BFD_FAIL ();
		      return FALSE;
		    }
		}
		break;
	      default:
		{
		  bfd_vma this_size;

		  if (parse_int (&(ieee->h), &this_size))
		    {
		      unsigned int i;

		      for (i = 0; i < this_size; i++)
			{
			  location_ptr[current_map->pc++] = this_byte (&(ieee->h));
			  next_byte (&(ieee->h));
			}
		    }
		  else
		    loop = FALSE;
		}
	      }

	    /* Prevent more than the first load-item of an LR record
	       from being repeated (MRI convention).  */
	    if (iterations != 1)
	      loop = FALSE;
	  }
      }
    }
  return TRUE;
}

/* Read in all the section data and relocation stuff too.  */

static bfd_boolean
ieee_slurp_section_data (bfd *abfd)
{
  bfd_byte *location_ptr = (bfd_byte *) NULL;
  ieee_data_type *ieee = IEEE_DATA (abfd);
  unsigned int section_number;
  ieee_per_section_type *current_map = NULL;
  asection *s;

  /* Seek to the start of the data area.  */
  if (ieee->read_data)
    return TRUE;
  ieee->read_data = TRUE;
  ieee_seek (ieee, ieee->w.r.data_part);

  /* Allocate enough space for all the section contents.  */
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      ieee_per_section_type *per = ieee_per_section (s);
      arelent **relpp;

      if ((s->flags & SEC_DEBUGGING) != 0)
	continue;
      per->data = bfd_alloc (ieee->h.abfd, s->size);
      if (!per->data)
	return FALSE;
      relpp = &s->relocation;
      per->reloc_tail_ptr = (ieee_reloc_type **) relpp;
    }

  while (TRUE)
    {
      switch (this_byte (&(ieee->h)))
	{
	  /* IF we see anything strange then quit.  */
	default:
	  return TRUE;

	case ieee_set_current_section_enum:
	  next_byte (&(ieee->h));
	  section_number = must_parse_int (&(ieee->h));
	  s = ieee->section_table[section_number];
	  s->flags |= SEC_LOAD | SEC_HAS_CONTENTS;
	  current_map = ieee_per_section (s);
	  location_ptr = current_map->data - s->vma;
	  /* The document I have says that Microtec's compilers reset
	     this after a sec section, even though the standard says not
	     to, SO...  */
	  current_map->pc = s->vma;
	  break;

	case ieee_e2_first_byte_enum:
	  next_byte (&(ieee->h));
	  switch (this_byte (&(ieee->h)))
	    {
	    case ieee_set_current_pc_enum & 0xff:
	      {
		bfd_vma value;
		ieee_symbol_index_type symbol;
		unsigned int extra;
		bfd_boolean pcrel;

		next_byte (&(ieee->h));
		must_parse_int (&(ieee->h));	/* Throw away section #.  */
		parse_expression (ieee, &value,
				  &symbol,
				  &pcrel, &extra,
				  0);
		current_map->pc = value;
		BFD_ASSERT ((unsigned) (value - s->vma) <= s->size);
	      }
	      break;

	    case ieee_value_starting_address_enum & 0xff:
	      next_byte (&(ieee->h));
	      if (this_byte (&(ieee->h)) == ieee_function_either_open_b_enum)
		next_byte (&(ieee->h));
	      abfd->start_address = must_parse_int (&(ieee->h));
	      /* We've got to the end of the data now -  */
	      return TRUE;
	    default:
	      BFD_FAIL ();
	      return FALSE;
	    }
	  break;
	case ieee_repeat_data_enum:
	  {
	    /* Repeat the following LD or LR n times - we do this by
	       remembering the stream pointer before running it and
	       resetting it and running it n times. We special case
	       the repetition of a repeat_data/load_constant.  */
	    unsigned int iterations;
	    unsigned char *start;

	    next_byte (&(ieee->h));
	    iterations = must_parse_int (&(ieee->h));
	    start = ieee->h.input_p;
	    if (start[0] == (int) ieee_load_constant_bytes_enum
		&& start[1] == 1)
	      {
		while (iterations != 0)
		  {
		    location_ptr[current_map->pc++] = start[2];
		    iterations--;
		  }
		next_byte (&(ieee->h));
		next_byte (&(ieee->h));
		next_byte (&(ieee->h));
	      }
	    else
	      {
		while (iterations != 0)
		  {
		    ieee->h.input_p = start;
		    if (!do_one (ieee, current_map, location_ptr, s,
				 (int) iterations))
		      return FALSE;
		    iterations--;
		  }
	      }
	  }
	  break;
	case ieee_load_constant_bytes_enum:
	case ieee_load_with_relocation_enum:
	  if (!do_one (ieee, current_map, location_ptr, s, 1))
	    return FALSE;
	}
    }
}

static const bfd_target *
ieee_object_p (bfd *abfd)
{
  char *processor;
  unsigned int part;
  ieee_data_type *ieee;
  unsigned char buffer[300];
  ieee_data_type *save = IEEE_DATA (abfd);
  bfd_size_type amt;

  abfd->tdata.ieee_data = 0;
  ieee_mkobject (abfd);

  ieee = IEEE_DATA (abfd);
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto fail;
  /* Read the first few bytes in to see if it makes sense.  Ignore
     bfd_bread return value;  The file might be very small.  */
  bfd_bread ((void *) buffer, (bfd_size_type) sizeof (buffer), abfd);

  ieee->h.input_p = buffer;
  if (this_byte_and_next (&(ieee->h)) != Module_Beginning)
    goto got_wrong_format;

  ieee->read_symbols = FALSE;
  ieee->read_data = FALSE;
  ieee->section_count = 0;
  ieee->external_symbol_max_index = 0;
  ieee->external_symbol_min_index = IEEE_PUBLIC_BASE;
  ieee->external_reference_min_index = IEEE_REFERENCE_BASE;
  ieee->external_reference_max_index = 0;
  ieee->h.abfd = abfd;
  ieee->section_table = NULL;
  ieee->section_table_size = 0;

  processor = ieee->mb.processor = read_id (&(ieee->h));
  if (strcmp (processor, "LIBRARY") == 0)
    goto got_wrong_format;
  ieee->mb.module_name = read_id (&(ieee->h));
  if (abfd->filename == (const char *) NULL)
    abfd->filename = ieee->mb.module_name;

  /* Determine the architecture and machine type of the object file.  */
  {
    const bfd_arch_info_type *arch;
    char family[10];

    /* IEEE does not specify the format of the processor identification
       string, so the compiler is free to put in it whatever it wants.
       We try here to recognize different processors belonging to the
       m68k family.  Code for other processors can be added here.  */
    if ((processor[0] == '6') && (processor[1] == '8'))
      {
	if (processor[2] == '3')	    /* 683xx integrated processors.  */
	  {
	    switch (processor[3])
	      {
	      case '0':			    /* 68302, 68306, 68307 */
	      case '2':			    /* 68322, 68328 */
	      case '5':			    /* 68356 */
		strcpy (family, "68000");   /* MC68000-based controllers.  */
		break;

	      case '3':			    /* 68330, 68331, 68332, 68333,
					       68334, 68335, 68336, 68338 */
	      case '6':			    /* 68360 */
	      case '7':			    /* 68376 */
		strcpy (family, "68332");   /* CPU32 and CPU32+ */
		break;

	      case '4':
		if (processor[4] == '9')    /* 68349 */
		  strcpy (family, "68030"); /* CPU030 */
		else		            /* 68340, 68341 */
		  strcpy (family, "68332"); /* CPU32 and CPU32+ */
		break;

	      default:			    /* Does not exist yet.  */
		strcpy (family, "68332");   /* Guess it will be CPU32 */
	      }
	  }
	else if (TOUPPER (processor[3]) == 'F')  /* 68F333 */
	  strcpy (family, "68332");	           /* CPU32 */
	else if ((TOUPPER (processor[3]) == 'C') /* Embedded controllers.  */
		 && ((TOUPPER (processor[2]) == 'E')
		     || (TOUPPER (processor[2]) == 'H')
		     || (TOUPPER (processor[2]) == 'L')))
	  {
	    strcpy (family, "68");
	    strncat (family, processor + 4, 7);
	    family[9] = '\0';
	  }
	else				 /* "Regular" processors.  */
	  {
	    strncpy (family, processor, 9);
	    family[9] = '\0';
	  }
      }
    else if ((CONST_STRNEQ (processor, "cpu32")) /* CPU32 and CPU32+  */
	     || (CONST_STRNEQ (processor, "CPU32")))
      strcpy (family, "68332");
    else
      {
	strncpy (family, processor, 9);
	family[9] = '\0';
      }

    arch = bfd_scan_arch (family);
    if (arch == 0)
      goto got_wrong_format;
    abfd->arch_info = arch;
  }

  if (this_byte (&(ieee->h)) != (int) ieee_address_descriptor_enum)
    goto fail;

  next_byte (&(ieee->h));

  if (! parse_int (&(ieee->h), &ieee->ad.number_of_bits_mau))
    goto fail;

  if (! parse_int (&(ieee->h), &ieee->ad.number_of_maus_in_address))
    goto fail;

  /* If there is a byte order info, take it.  */
  if (this_byte (&(ieee->h)) == (int) ieee_variable_L_enum
      || this_byte (&(ieee->h)) == (int) ieee_variable_M_enum)
    next_byte (&(ieee->h));

  for (part = 0; part < N_W_VARIABLES; part++)
    {
      bfd_boolean ok;

      if (read_2bytes (&(ieee->h)) != (int) ieee_assign_value_to_variable_enum)
	goto fail;

      if (this_byte_and_next (&(ieee->h)) != part)
	goto fail;

      ieee->w.offset[part] = parse_i (&(ieee->h), &ok);
      if (! ok)
	goto fail;
    }

  if (ieee->w.r.external_part != 0)
    abfd->flags = HAS_SYMS;

  /* By now we know that this is a real IEEE file, we're going to read
     the whole thing into memory so that we can run up and down it
     quickly.  We can work out how big the file is from the trailer
     record.  */

  amt = ieee->w.r.me_record + 1;
  IEEE_DATA (abfd)->h.first_byte = bfd_alloc (ieee->h.abfd, amt);
  if (!IEEE_DATA (abfd)->h.first_byte)
    goto fail;
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto fail;
  /* FIXME: Check return value.  I'm not sure whether it needs to read
     the entire buffer or not.  */
  bfd_bread ((void *) (IEEE_DATA (abfd)->h.first_byte),
	    (bfd_size_type) ieee->w.r.me_record + 1, abfd);

  ieee_slurp_sections (abfd);

  if (! ieee_slurp_debug (abfd))
    goto fail;

  /* Parse section data to activate file and section flags implied by
     section contents.  */
  if (! ieee_slurp_section_data (abfd))
    goto fail;

  return abfd->xvec;
got_wrong_format:
  bfd_set_error (bfd_error_wrong_format);
fail:
  bfd_release (abfd, ieee);
  abfd->tdata.ieee_data = save;
  return (const bfd_target *) NULL;
}

static void
ieee_get_symbol_info (bfd *ignore_abfd ATTRIBUTE_UNUSED,
		      asymbol *symbol,
		      symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);
  if (symbol->name[0] == ' ')
    ret->name = "* empty table entry ";
  if (!symbol->section)
    ret->type = (symbol->flags & BSF_LOCAL) ? 'a' : 'A';
}

static void
ieee_print_symbol (bfd *abfd,
		   void * afile,
		   asymbol *symbol,
		   bfd_print_symbol_type how)
{
  FILE *file = (FILE *) afile;

  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_more:
      BFD_FAIL ();
      break;
    case bfd_print_symbol_all:
      {
	const char *section_name =
	  (symbol->section == (asection *) NULL
	   ? "*abs"
	   : symbol->section->name);

	if (symbol->name[0] == ' ')
	  fprintf (file, "* empty table entry ");
	else
	  {
	    bfd_print_symbol_vandf (abfd, (void *) file, symbol);

	    fprintf (file, " %-5s %04x %02x %s",
		     section_name,
		     (unsigned) ieee_symbol (symbol)->index,
		     (unsigned) 0,
		     symbol->name);
	  }
      }
      break;
    }
}

static bfd_boolean
ieee_new_section_hook (bfd *abfd, asection *newsect)
{
  if (!newsect->used_by_bfd)
    {
      newsect->used_by_bfd = bfd_alloc (abfd, sizeof (ieee_per_section_type));
      if (!newsect->used_by_bfd)
	return FALSE;
    }
  ieee_per_section (newsect)->data = NULL;
  ieee_per_section (newsect)->section = newsect;
  return _bfd_generic_new_section_hook (abfd, newsect);
}

static long
ieee_get_reloc_upper_bound (bfd *abfd, sec_ptr asect)
{
  if ((asect->flags & SEC_DEBUGGING) != 0)
    return 0;
  if (! ieee_slurp_section_data (abfd))
    return -1;
  return (asect->reloc_count + 1) * sizeof (arelent *);
}

static bfd_boolean
ieee_get_section_contents (bfd *abfd,
			   sec_ptr section,
			   void * location,
			   file_ptr offset,
			   bfd_size_type count)
{
  ieee_per_section_type *p = ieee_per_section (section);
  if ((section->flags & SEC_DEBUGGING) != 0)
    return _bfd_generic_get_section_contents (abfd, section, location,
					      offset, count);
  ieee_slurp_section_data (abfd);
  (void) memcpy ((void *) location, (void *) (p->data + offset), (unsigned) count);
  return TRUE;
}

static long
ieee_canonicalize_reloc (bfd *abfd,
			 sec_ptr section,
			 arelent **relptr,
			 asymbol **symbols)
{
  ieee_reloc_type *src = (ieee_reloc_type *) (section->relocation);
  ieee_data_type *ieee = IEEE_DATA (abfd);

  if ((section->flags & SEC_DEBUGGING) != 0)
    return 0;

  while (src != (ieee_reloc_type *) NULL)
    {
      /* Work out which symbol to attach it this reloc to.  */
      switch (src->symbol.letter)
	{
	case 'I':
	  src->relent.sym_ptr_ptr =
	    symbols + src->symbol.index + ieee->external_symbol_base_offset;
	  break;
	case 'X':
	  src->relent.sym_ptr_ptr =
	    symbols + src->symbol.index + ieee->external_reference_base_offset;
	  break;
	case 0:
	  if (src->relent.sym_ptr_ptr != NULL)
	    src->relent.sym_ptr_ptr =
	      src->relent.sym_ptr_ptr[0]->section->symbol_ptr_ptr;
	  break;
	default:

	  BFD_FAIL ();
	}
      *relptr++ = &src->relent;
      src = src->next;
    }
  *relptr = NULL;
  return section->reloc_count;
}

static int
comp (const void * ap, const void * bp)
{
  arelent *a = *((arelent **) ap);
  arelent *b = *((arelent **) bp);
  return a->address - b->address;
}

/* Write the section headers.  */

static bfd_boolean
ieee_write_section_part (bfd *abfd)
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  asection *s;

  ieee->w.r.section_part = bfd_tell (abfd);
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      if (! bfd_is_abs_section (s)
	  && (s->flags & SEC_DEBUGGING) == 0)
	{
	  if (! ieee_write_byte (abfd, ieee_section_type_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (s->index
						+ IEEE_SECTION_NUMBER_BASE)))
	    return FALSE;

	  if (abfd->flags & EXEC_P)
	    {
	      /* This image is executable, so output absolute sections.  */
	      if (! ieee_write_byte (abfd, ieee_variable_A_enum)
		  || ! ieee_write_byte (abfd, ieee_variable_S_enum))
		return FALSE;
	    }
	  else
	    {
	      if (! ieee_write_byte (abfd, ieee_variable_C_enum))
		return FALSE;
	    }

	  switch (s->flags & (SEC_CODE | SEC_DATA | SEC_ROM))
	    {
	    case SEC_CODE | SEC_LOAD:
	    case SEC_CODE:
	      if (! ieee_write_byte (abfd, ieee_variable_P_enum))
		return FALSE;
	      break;
	    case SEC_DATA:
	    default:
	      if (! ieee_write_byte (abfd, ieee_variable_D_enum))
		return FALSE;
	      break;
	    case SEC_ROM:
	    case SEC_ROM | SEC_DATA:
	    case SEC_ROM | SEC_LOAD:
	    case SEC_ROM | SEC_DATA | SEC_LOAD:
	      if (! ieee_write_byte (abfd, ieee_variable_R_enum))
		return FALSE;
	    }


	  if (! ieee_write_id (abfd, s->name))
	    return FALSE;
	  /* Alignment.  */
	  if (! ieee_write_byte (abfd, ieee_section_alignment_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (s->index
						+ IEEE_SECTION_NUMBER_BASE))
	      || ! ieee_write_int (abfd, (bfd_vma) 1 << s->alignment_power))
	    return FALSE;

	  /* Size.  */
	  if (! ieee_write_2bytes (abfd, ieee_section_size_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (s->index
						+ IEEE_SECTION_NUMBER_BASE))
	      || ! ieee_write_int (abfd, s->size))
	    return FALSE;
	  if (abfd->flags & EXEC_P)
	    {
	      /* Relocateable sections don't have asl records.  */
	      /* Vma.  */
	      if (! ieee_write_2bytes (abfd, ieee_section_base_address_enum)
		  || ! ieee_write_byte (abfd,
					((bfd_byte)
					 (s->index
					  + IEEE_SECTION_NUMBER_BASE)))
		  || ! ieee_write_int (abfd, s->lma))
		return FALSE;
	    }
	}
    }

  return TRUE;
}

static bfd_boolean
do_with_relocs (bfd *abfd, asection *s)
{
  unsigned int number_of_maus_in_address =
    bfd_arch_bits_per_address (abfd) / bfd_arch_bits_per_byte (abfd);
  unsigned int relocs_to_go = s->reloc_count;
  bfd_byte *stream = ieee_per_section (s)->data;
  arelent **p = s->orelocation;
  bfd_size_type current_byte_index = 0;

  qsort (s->orelocation,
	 relocs_to_go,
	 sizeof (arelent **),
	 comp);

  /* Output the section preheader.  */
  if (! ieee_write_byte (abfd, ieee_set_current_section_enum)
      || ! ieee_write_byte (abfd,
			    (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE))
      || ! ieee_write_2bytes (abfd, ieee_set_current_pc_enum)
      || ! ieee_write_byte (abfd,
			    (bfd_byte) (s->index + IEEE_SECTION_NUMBER_BASE)))
    return FALSE;

  if ((abfd->flags & EXEC_P) != 0 && relocs_to_go == 0)
    {
      if (! ieee_write_int (abfd, s->lma))
	return FALSE;
    }
  else
    {
      if (! ieee_write_expression (abfd, (bfd_vma) 0, s->symbol, 0, 0))
	return FALSE;
    }

  if (relocs_to_go == 0)
    {
      /* If there aren't any relocations then output the load constant
	 byte opcode rather than the load with relocation opcode.  */
      while (current_byte_index < s->size)
	{
	  bfd_size_type run;
	  unsigned int MAXRUN = 127;

	  run = MAXRUN;
	  if (run > s->size - current_byte_index)
	    run = s->size - current_byte_index;

	  if (run != 0)
	    {
	      if (! ieee_write_byte (abfd, ieee_load_constant_bytes_enum))
		return FALSE;
	      /* Output a stream of bytes.  */
	      if (! ieee_write_int (abfd, run))
		return FALSE;
	      if (bfd_bwrite ((void *) (stream + current_byte_index), run, abfd)
		  != run)
		return FALSE;
	      current_byte_index += run;
	    }
	}
    }
  else
    {
      if (! ieee_write_byte (abfd, ieee_load_with_relocation_enum))
	return FALSE;

      /* Output the data stream as the longest sequence of bytes
	 possible, allowing for the a reasonable packet size and
	 relocation stuffs.  */
      if (stream == NULL)
	{
	  /* Outputting a section without data, fill it up.  */
	  stream = bfd_zalloc (abfd, s->size);
	  if (!stream)
	    return FALSE;
	}
      while (current_byte_index < s->size)
	{
	  bfd_size_type run;
	  unsigned int MAXRUN = 127;

	  if (relocs_to_go)
	    {
	      run = (*p)->address - current_byte_index;
	      if (run > MAXRUN)
		run = MAXRUN;
	    }
	  else
	    run = MAXRUN;

	  if (run > s->size - current_byte_index)
	    run = s->size - current_byte_index;

	  if (run != 0)
	    {
	      /* Output a stream of bytes.  */
	      if (! ieee_write_int (abfd, run))
		return FALSE;
	      if (bfd_bwrite ((void *) (stream + current_byte_index), run, abfd)
		  != run)
		return FALSE;
	      current_byte_index += run;
	    }

	  /* Output any relocations here.  */
	  if (relocs_to_go && (*p) && (*p)->address == current_byte_index)
	    {
	      while (relocs_to_go
		     && (*p) && (*p)->address == current_byte_index)
		{
		  arelent *r = *p;
		  bfd_signed_vma ov;
		  switch (r->howto->size)
		    {
		    case 2:
		      ov = bfd_get_signed_32 (abfd,
					      stream + current_byte_index);
		      current_byte_index += 4;
		      break;
		    case 1:
		      ov = bfd_get_signed_16 (abfd,
					      stream + current_byte_index);
		      current_byte_index += 2;
		      break;
		    case 0:
		      ov = bfd_get_signed_8 (abfd,
					     stream + current_byte_index);
		      current_byte_index++;
		      break;
		    default:
		      ov = 0;
		      BFD_FAIL ();
		      return FALSE;
		    }

		  ov &= r->howto->src_mask;

		  if (r->howto->pc_relative
		      && ! r->howto->pcrel_offset)
		    ov += r->address;

		  if (! ieee_write_byte (abfd,
					 ieee_function_either_open_b_enum))
		    return FALSE;

		  if (r->sym_ptr_ptr != (asymbol **) NULL)
		    {
		      if (! ieee_write_expression (abfd, r->addend + ov,
						   *(r->sym_ptr_ptr),
						   r->howto->pc_relative,
						   (unsigned) s->index))
			return FALSE;
		    }
		  else
		    {
		      if (! ieee_write_expression (abfd, r->addend + ov,
						   (asymbol *) NULL,
						   r->howto->pc_relative,
						   (unsigned) s->index))
			return FALSE;
		    }

		  if (number_of_maus_in_address
		      != bfd_get_reloc_size (r->howto))
		    {
		      bfd_vma rsize = bfd_get_reloc_size (r->howto);
		      if (! ieee_write_int (abfd, rsize))
			return FALSE;
		    }
		  if (! ieee_write_byte (abfd,
					 ieee_function_either_close_b_enum))
		    return FALSE;

		  relocs_to_go--;
		  p++;
		}

	    }
	}
    }

  return TRUE;
}

/* If there are no relocations in the output section then we can be
   clever about how we write.  We block items up into a max of 127
   bytes.  */

static bfd_boolean
do_as_repeat (bfd *abfd, asection *s)
{
  if (s->size)
    {
      if (! ieee_write_byte (abfd, ieee_set_current_section_enum)
	  || ! ieee_write_byte (abfd,
				(bfd_byte) (s->index
					    + IEEE_SECTION_NUMBER_BASE))
	  || ! ieee_write_byte (abfd, ieee_set_current_pc_enum >> 8)
	  || ! ieee_write_byte (abfd, ieee_set_current_pc_enum & 0xff)
	  || ! ieee_write_byte (abfd,
				(bfd_byte) (s->index
					    + IEEE_SECTION_NUMBER_BASE)))
	return FALSE;

      if ((abfd->flags & EXEC_P) != 0)
	{
	  if (! ieee_write_int (abfd, s->lma))
	    return FALSE;
	}
      else
	{
	  if (! ieee_write_expression (abfd, (bfd_vma) 0, s->symbol, 0, 0))
	    return FALSE;
	}

      if (! ieee_write_byte (abfd, ieee_repeat_data_enum)
	  || ! ieee_write_int (abfd, s->size)
	  || ! ieee_write_byte (abfd, ieee_load_constant_bytes_enum)
	  || ! ieee_write_byte (abfd, 1)
	  || ! ieee_write_byte (abfd, 0))
	return FALSE;
    }

  return TRUE;
}

static bfd_boolean
do_without_relocs (bfd *abfd, asection *s)
{
  bfd_byte *stream = ieee_per_section (s)->data;

  if (stream == 0 || ((s->flags & SEC_LOAD) == 0))
    {
      if (! do_as_repeat (abfd, s))
	return FALSE;
    }
  else
    {
      unsigned int i;

      for (i = 0; i < s->size; i++)
	{
	  if (stream[i] != 0)
	    {
	      if (! do_with_relocs (abfd, s))
		return FALSE;
	      return TRUE;
	    }
	}
      if (! do_as_repeat (abfd, s))
	return FALSE;
    }

  return TRUE;
}

static void
fill (void)
{
  bfd_size_type amt = input_ptr_end - input_ptr_start;
  /* FIXME: Check return value.  I'm not sure whether it needs to read
     the entire buffer or not.  */
  bfd_bread ((void *) input_ptr_start, amt, input_bfd);
  input_ptr = input_ptr_start;
}

static void
flush (void)
{
  bfd_size_type amt = output_ptr - output_ptr_start;

  if (bfd_bwrite ((void *) (output_ptr_start), amt, output_bfd) != amt)
    abort ();
  output_ptr = output_ptr_start;
  output_buffer++;
}

#define THIS() ( *input_ptr )
#define NEXT() { input_ptr++; if (input_ptr == input_ptr_end) fill (); }
#define OUT(x) { *output_ptr++ = (x); if (output_ptr == output_ptr_end)  flush (); }

static void
write_int (int value)
{
  if (value >= 0 && value <= 127)
    {
      OUT (value);
    }
  else
    {
      unsigned int length;

      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
      if (value & 0xff000000)
	length = 4;
      else if (value & 0x00ff0000)
	length = 3;
      else if (value & 0x0000ff00)
	length = 2;
      else
	length = 1;

      OUT ((int) ieee_number_repeat_start_enum + length);
      switch (length)
	{
	case 4:
	  OUT (value >> 24);
	case 3:
	  OUT (value >> 16);
	case 2:
	  OUT (value >> 8);
	case 1:
	  OUT (value);
	}
    }
}

static void
copy_id (void)
{
  int length = THIS ();
  char ch;

  OUT (length);
  NEXT ();
  while (length--)
    {
      ch = THIS ();
      OUT (ch);
      NEXT ();
    }
}

#define VAR(x) ((x | 0x80))
static void
copy_expression (void)
{
  int stack[10];
  int *tos = stack;
  int value;

  while (1)
    {
      switch (THIS ())
	{
	case 0x84:
	  NEXT ();
	  value = THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  *tos++ = value;
	  break;
	case 0x83:
	  NEXT ();
	  value = THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  *tos++ = value;
	  break;
	case 0x82:
	  NEXT ();
	  value = THIS ();
	  NEXT ();
	  value = (value << 8) | THIS ();
	  NEXT ();
	  *tos++ = value;
	  break;
	case 0x81:
	  NEXT ();
	  value = THIS ();
	  NEXT ();
	  *tos++ = value;
	  break;
	case 0x80:
	  NEXT ();
	  *tos++ = 0;
	  break;
	default:
	  if (THIS () > 0x84)
	    {
	      /* Not a number, just bug out with the answer.  */
	      write_int (*(--tos));
	      return;
	    }
	  *tos++ = THIS ();
	  NEXT ();
	  break;
	case 0xa5:
	  /* PLUS anything.  */
	  value = *(--tos);
	  value += *(--tos);
	  *tos++ = value;
	  NEXT ();
	  break;
	case VAR ('R'):
	  {
	    int section_number;
	    ieee_data_type *ieee;
	    asection *s;

	    NEXT ();
	    section_number = THIS ();

	    NEXT ();
	    ieee = IEEE_DATA (input_bfd);
	    s = ieee->section_table[section_number];
	    value = 0;
	    if (s->output_section)
	      value = s->output_section->lma;
	    value += s->output_offset;
	    *tos++ = value;
	  }
	  break;
	case 0x90:
	  {
	    NEXT ();
	    write_int (*(--tos));
	    OUT (0x90);
	    return;
	  }
	}
    }
}

/* Drop the int in the buffer, and copy a null into the gap, which we
   will overwrite later.  */

static void
fill_int (struct output_buffer_struct *buf)
{
  if (buf->buffer == output_buffer)
    {
      /* Still a chance to output the size.  */
      int value = output_ptr - buf->ptrp + 3;
      buf->ptrp[0] = value >> 24;
      buf->ptrp[1] = value >> 16;
      buf->ptrp[2] = value >> 8;
      buf->ptrp[3] = value >> 0;
    }
}

static void
drop_int (struct output_buffer_struct *buf)
{
  int type = THIS ();
  int ch;

  if (type <= 0x84)
    {
      NEXT ();
      switch (type)
	{
	case 0x84:
	  ch = THIS ();
	  NEXT ();
	case 0x83:
	  ch = THIS ();
	  NEXT ();
	case 0x82:
	  ch = THIS ();
	  NEXT ();
	case 0x81:
	  ch = THIS ();
	  NEXT ();
	case 0x80:
	  break;
	}
    }
  (void) ch;
  OUT (0x84);
  buf->ptrp = output_ptr;
  buf->buffer = output_buffer;
  OUT (0);
  OUT (0);
  OUT (0);
  OUT (0);
}

static void
copy_int (void)
{
  int type = THIS ();
  int ch;
  if (type <= 0x84)
    {
      OUT (type);
      NEXT ();
      switch (type)
	{
	case 0x84:
	  ch = THIS ();
	  NEXT ();
	  OUT (ch);
	case 0x83:
	  ch = THIS ();
	  NEXT ();
	  OUT (ch);
	case 0x82:
	  ch = THIS ();
	  NEXT ();
	  OUT (ch);
	case 0x81:
	  ch = THIS ();
	  NEXT ();
	  OUT (ch);
	case 0x80:
	  break;
	}
    }
}

#define ID      copy_id ()
#define INT     copy_int ()
#define EXP     copy_expression ()
#define INTn(q) copy_int ()
#define EXPn(q) copy_expression ()

static void
copy_till_end (void)
{
  int ch = THIS ();

  while (1)
    {
      while (ch <= 0x80)
	{
	  OUT (ch);
	  NEXT ();
	  ch = THIS ();
	}
      switch (ch)
	{
	case 0x84:
	  OUT (THIS ());
	  NEXT ();
	case 0x83:
	  OUT (THIS ());
	  NEXT ();
	case 0x82:
	  OUT (THIS ());
	  NEXT ();
	case 0x81:
	  OUT (THIS ());
	  NEXT ();
	  OUT (THIS ());
	  NEXT ();

	  ch = THIS ();
	  break;
	default:
	  return;
	}
    }

}

static void
f1_record (void)
{
  int ch;

  /* ATN record.  */
  NEXT ();
  ch = THIS ();
  switch (ch)
    {
    default:
      OUT (0xf1);
      OUT (ch);
      break;
    case 0xc9:
      NEXT ();
      OUT (0xf1);
      OUT (0xc9);
      INT;
      INT;
      ch = THIS ();
      switch (ch)
	{
	case 0x16:
	  NEXT ();
	  break;
	case 0x01:
	  NEXT ();
	  break;
	case 0x00:
	  NEXT ();
	  INT;
	  break;
	case 0x03:
	  NEXT ();
	  INT;
	  break;
	case 0x13:
	  EXPn (instruction address);
	  break;
	default:
	  break;
	}
      break;
    case 0xd8:
      /* EXternal ref.  */
      NEXT ();
      OUT (0xf1);
      OUT (0xd8);
      EXP;
      EXP;
      EXP;
      EXP;
      break;
    case 0xce:
      NEXT ();
      OUT (0xf1);
      OUT (0xce);
      INT;
      INT;
      ch = THIS ();
      INT;
      switch (ch)
	{
	case 0x01:
	  INT;
	  INT;
	  break;
	case 0x02:
	  INT;
	  break;
	case 0x04:
	  EXPn (external function);
	  break;
	case 0x05:
	  break;
	case 0x07:
	  INTn (line number);
	  INT;
	case 0x08:
	  break;
	case 0x0a:
	  INTn (locked register);
	  INT;
	  break;
	case 0x3f:
	  copy_till_end ();
	  break;
	case 0x3e:
	  copy_till_end ();
	  break;
	case 0x40:
	  copy_till_end ();
	  break;
	case 0x41:
	  ID;
	  break;
	}
    }
}

static void
f0_record (void)
{
  /* Attribute record.  */
  NEXT ();
  OUT (0xf0);
  INTn (Symbol name);
  ID;
}

static void
f2_record (void)
{
  NEXT ();
  OUT (0xf2);
  INT;
  NEXT ();
  OUT (0xce);
  INT;
  copy_till_end ();
}

static void
f8_record (void)
{
  int ch;
  NEXT ();
  ch = THIS ();
  switch (ch)
    {
    case 0x01:
    case 0x02:
    case 0x03:
      /* Unique typedefs for module.  */
      /* GLobal typedefs.   */
      /* High level module scope beginning.  */
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (ch);
	drop_int (&ob);
	ID;

	block ();

	NEXT ();
	fill_int (&ob);
	OUT (0xf9);
      }
      break;
    case 0x04:
      /* Global function.  */
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (0x04);
	drop_int (&ob);
	ID;
	INTn (stack size);
	INTn (ret val);
	EXPn (offset);

	block ();

	NEXT ();
	OUT (0xf9);
	EXPn (size of block);
	fill_int (&ob);
      }
      break;

    case 0x05:
      /* File name for source line numbers.  */
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (0x05);
	drop_int (&ob);
	ID;
	INTn (year);
	INTn (month);
	INTn (day);
	INTn (hour);
	INTn (monute);
	INTn (second);
	block ();
	NEXT ();
	OUT (0xf9);
	fill_int (&ob);
      }
      break;

    case 0x06:
      /* Local function.  */
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (0x06);
	drop_int (&ob);
	ID;
	INTn (stack size);
	INTn (type return);
	EXPn (offset);
	block ();
	NEXT ();
	OUT (0xf9);
	EXPn (size);
	fill_int (&ob);
      }
      break;

    case 0x0a:
      /* Assembler module scope beginning -  */
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (0x0a);
	drop_int (&ob);
	ID;
	ID;
	INT;
	ID;
	INT;
	INT;
	INT;
	INT;
	INT;
	INT;

	block ();

	NEXT ();
	OUT (0xf9);
	fill_int (&ob);
      }
      break;
    case 0x0b:
      {
	struct output_buffer_struct ob;

	NEXT ();
	OUT (0xf8);
	OUT (0x0b);
	drop_int (&ob);
	ID;
	INT;
	INTn (section index);
	EXPn (offset);
	INTn (stuff);

	block ();

	OUT (0xf9);
	NEXT ();
	EXPn (Size in Maus);
	fill_int (&ob);
      }
      break;
    }
}

static void
e2_record (void)
{
  OUT (0xe2);
  NEXT ();
  OUT (0xce);
  NEXT ();
  INT;
  EXP;
}

static void
block (void)
{
  int ch;

  while (1)
    {
      ch = THIS ();
      switch (ch)
	{
	case 0xe1:
	case 0xe5:
	  return;
	case 0xf9:
	  return;
	case 0xf0:
	  f0_record ();
	  break;
	case 0xf1:
	  f1_record ();
	  break;
	case 0xf2:
	  f2_record ();
	  break;
	case 0xf8:
	  f8_record ();
	  break;
	case 0xe2:
	  e2_record ();
	  break;

	}
    }
}

/* Moves all the debug information from the source bfd to the output
   bfd, and relocates any expressions it finds.  */

static void
relocate_debug (bfd *output ATTRIBUTE_UNUSED,
		bfd *input)
{
#define IBS 400
#define OBS 400
  unsigned char input_buffer[IBS];

  input_ptr_start = input_ptr = input_buffer;
  input_ptr_end = input_buffer + IBS;
  input_bfd = input;
  /* FIXME: Check return value.  I'm not sure whether it needs to read
     the entire buffer or not.  */
  bfd_bread ((void *) input_ptr_start, (bfd_size_type) IBS, input);
  block ();
}

/* Gather together all the debug information from each input BFD into
   one place, relocating it and emitting it as we go.  */

static bfd_boolean
ieee_write_debug_part (bfd *abfd)
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  bfd_chain_type *chain = ieee->chain_root;
  unsigned char obuff[OBS];
  bfd_boolean some_debug = FALSE;
  file_ptr here = bfd_tell (abfd);

  output_ptr_start = output_ptr = obuff;
  output_ptr_end = obuff + OBS;
  output_ptr = obuff;
  output_bfd = abfd;

  if (chain == (bfd_chain_type *) NULL)
    {
      asection *s;

      for (s = abfd->sections; s != NULL; s = s->next)
	if ((s->flags & SEC_DEBUGGING) != 0)
	  break;
      if (s == NULL)
	{
	  ieee->w.r.debug_information_part = 0;
	  return TRUE;
	}

      ieee->w.r.debug_information_part = here;
      if (bfd_bwrite (s->contents, s->size, abfd) != s->size)
	return FALSE;
    }
  else
    {
      while (chain != (bfd_chain_type *) NULL)
	{
	  bfd *entry = chain->this;
	  ieee_data_type *entry_ieee = IEEE_DATA (entry);

	  if (entry_ieee->w.r.debug_information_part)
	    {
	      if (bfd_seek (entry, entry_ieee->w.r.debug_information_part,
			    SEEK_SET) != 0)
		return FALSE;
	      relocate_debug (abfd, entry);
	    }

	  chain = chain->next;
	}

      if (some_debug)
	ieee->w.r.debug_information_part = here;
      else
	ieee->w.r.debug_information_part = 0;

      flush ();
    }

  return TRUE;
}

/* Write the data in an ieee way.  */

static bfd_boolean
ieee_write_data_part (bfd *abfd)
{
  asection *s;

  ieee_data_type *ieee = IEEE_DATA (abfd);
  ieee->w.r.data_part = bfd_tell (abfd);

  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      /* Skip sections that have no loadable contents (.bss,
         debugging, etc.)  */
      if ((s->flags & SEC_LOAD) == 0)
	continue;

      /* Sort the reloc records so we can insert them in the correct
	 places.  */
      if (s->reloc_count != 0)
	{
	  if (! do_with_relocs (abfd, s))
	    return FALSE;
	}
      else
	{
	  if (! do_without_relocs (abfd, s))
	    return FALSE;
	}
    }

  return TRUE;
}

static bfd_boolean
init_for_output (bfd *abfd)
{
  asection *s;

  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    {
      if ((s->flags & SEC_DEBUGGING) != 0)
	continue;
      if (s->size != 0)
	{
	  bfd_size_type size = s->size;
	  ieee_per_section (s)->data = bfd_alloc (abfd, size);
	  if (!ieee_per_section (s)->data)
	    return FALSE;
	}
    }
  return TRUE;
}

/* Exec and core file sections.  */

/* Set section contents is complicated with IEEE since the format is
   not a byte image, but a record stream.  */

static bfd_boolean
ieee_set_section_contents (bfd *abfd,
			   sec_ptr section,
			   const void * location,
			   file_ptr offset,
			   bfd_size_type count)
{
  if ((section->flags & SEC_DEBUGGING) != 0)
    {
      if (section->contents == NULL)
	{
	  bfd_size_type size = section->size;
	  section->contents = bfd_alloc (abfd, size);
	  if (section->contents == NULL)
	    return FALSE;
	}
      /* bfd_set_section_contents has already checked that everything
         is within range.  */
      memcpy (section->contents + offset, location, (size_t) count);
      return TRUE;
    }

  if (ieee_per_section (section)->data == (bfd_byte *) NULL)
    {
      if (!init_for_output (abfd))
	return FALSE;
    }
  memcpy ((void *) (ieee_per_section (section)->data + offset),
	  (void *) location,
	  (unsigned int) count);
  return TRUE;
}

/* Write the external symbols of a file.  IEEE considers two sorts of
   external symbols, public, and referenced.  It uses to internal
   forms to index them as well.  When we write them out we turn their
   symbol values into indexes from the right base.  */

static bfd_boolean
ieee_write_external_part (bfd *abfd)
{
  asymbol **q;
  ieee_data_type *ieee = IEEE_DATA (abfd);
  unsigned int reference_index = IEEE_REFERENCE_BASE;
  unsigned int public_index = IEEE_PUBLIC_BASE + 2;
  file_ptr here = bfd_tell (abfd);
  bfd_boolean hadone = FALSE;

  if (abfd->outsymbols != (asymbol **) NULL)
    {

      for (q = abfd->outsymbols; *q != (asymbol *) NULL; q++)
	{
	  asymbol *p = *q;

	  if (bfd_is_und_section (p->section))
	    {
	      /* This must be a symbol reference.  */
	      if (! ieee_write_byte (abfd, ieee_external_reference_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) reference_index)
		  || ! ieee_write_id (abfd, p->name))
		return FALSE;
	      p->value = reference_index;
	      reference_index++;
	      hadone = TRUE;
	    }
	  else if (bfd_is_com_section (p->section))
	    {
	      /* This is a weak reference.  */
	      if (! ieee_write_byte (abfd, ieee_external_reference_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) reference_index)
		  || ! ieee_write_id (abfd, p->name)
		  || ! ieee_write_byte (abfd,
					ieee_weak_external_reference_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) reference_index)
		  || ! ieee_write_int (abfd, p->value))
		return FALSE;
	      p->value = reference_index;
	      reference_index++;
	      hadone = TRUE;
	    }
	  else if (p->flags & BSF_GLOBAL)
	    {
	      /* This must be a symbol definition.  */
	      if (! ieee_write_byte (abfd, ieee_external_symbol_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) public_index)
		  || ! ieee_write_id (abfd, p->name)
		  || ! ieee_write_2bytes (abfd, ieee_attribute_record_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) public_index)
		  || ! ieee_write_byte (abfd, 15) /* Instruction address.  */
		  || ! ieee_write_byte (abfd, 19) /* Static symbol.  */
		  || ! ieee_write_byte (abfd, 1)) /* One of them.  */
		return FALSE;

	      /* Write out the value.  */
	      if (! ieee_write_2bytes (abfd, ieee_value_record_enum)
		  || ! ieee_write_int (abfd, (bfd_vma) public_index))
		return FALSE;
	      if (! bfd_is_abs_section (p->section))
		{
		  if (abfd->flags & EXEC_P)
		    {
		      /* If fully linked, then output all symbols
			 relocated.  */
		      if (! (ieee_write_int
			     (abfd,
			      (p->value
			       + p->section->output_offset
			       + p->section->output_section->vma))))
			return FALSE;
		    }
		  else
		    {
		      if (! (ieee_write_expression
			     (abfd,
			      p->value + p->section->output_offset,
			      p->section->output_section->symbol,
			      FALSE, 0)))
			return FALSE;
		    }
		}
	      else
		{
		  if (! ieee_write_expression (abfd,
					       p->value,
					       bfd_abs_section_ptr->symbol,
					       FALSE, 0))
		    return FALSE;
		}
	      p->value = public_index;
	      public_index++;
	      hadone = TRUE;
	    }
	  else
	    {
	      /* This can happen - when there are gaps in the symbols read
	         from an input ieee file.  */
	    }
	}
    }
  if (hadone)
    ieee->w.r.external_part = here;

  return TRUE;
}


static const unsigned char exten[] =
{
  0xf0, 0x20, 0x00,
  0xf1, 0xce, 0x20, 0x00, 37, 3, 3,	/* Set version 3 rev 3.  */
  0xf1, 0xce, 0x20, 0x00, 39, 2,	/* Keep symbol in  original case.  */
  0xf1, 0xce, 0x20, 0x00, 38		/* Set object type relocatable to x.  */
};

static const unsigned char envi[] =
{
  0xf0, 0x21, 0x00,

/*    0xf1, 0xce, 0x21, 00, 50, 0x82, 0x07, 0xc7, 0x09, 0x11, 0x11,
    0x19, 0x2c,
*/
  0xf1, 0xce, 0x21, 00, 52, 0x00,	/* exec ok.  */

  0xf1, 0xce, 0x21, 0, 53, 0x03,/* host unix.  */
/*    0xf1, 0xce, 0x21, 0, 54, 2,1,1	tool & version # */
};

static bfd_boolean
ieee_write_me_part (bfd *abfd)
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  ieee->w.r.trailer_part = bfd_tell (abfd);
  if (abfd->start_address)
    {
      if (! ieee_write_2bytes (abfd, ieee_value_starting_address_enum)
	  || ! ieee_write_byte (abfd, ieee_function_either_open_b_enum)
	  || ! ieee_write_int (abfd, abfd->start_address)
	  || ! ieee_write_byte (abfd, ieee_function_either_close_b_enum))
	return FALSE;
    }
  ieee->w.r.me_record = bfd_tell (abfd);
  if (! ieee_write_byte (abfd, ieee_module_end_enum))
    return FALSE;
  return TRUE;
}

/* Write out the IEEE processor ID.  */

static bfd_boolean
ieee_write_processor (bfd *abfd)
{
  const bfd_arch_info_type *arch;

  arch = bfd_get_arch_info (abfd);
  switch (arch->arch)
    {
    default:
      if (! ieee_write_id (abfd, bfd_printable_name (abfd)))
	return FALSE;
      break;

    case bfd_arch_h8300:
      if (! ieee_write_id (abfd, "H8/300"))
	return FALSE;
      break;

    case bfd_arch_h8500:
      if (! ieee_write_id (abfd, "H8/500"))
	return FALSE;
      break;

    case bfd_arch_i960:
      switch (arch->mach)
	{
	default:
	case bfd_mach_i960_core:
	case bfd_mach_i960_ka_sa:
	  if (! ieee_write_id (abfd, "80960KA"))
	    return FALSE;
	  break;

	case bfd_mach_i960_kb_sb:
	  if (! ieee_write_id (abfd, "80960KB"))
	    return FALSE;
	  break;

	case bfd_mach_i960_ca:
	  if (! ieee_write_id (abfd, "80960CA"))
	    return FALSE;
	  break;

	case bfd_mach_i960_mc:
	case bfd_mach_i960_xa:
	  if (! ieee_write_id (abfd, "80960MC"))
	    return FALSE;
	  break;
	}
      break;

    case bfd_arch_m68k:
      {
	const char *id;

	switch (arch->mach)
	  {
	  default:		id = "68020"; break;
	  case bfd_mach_m68000: id = "68000"; break;
	  case bfd_mach_m68008: id = "68008"; break;
	  case bfd_mach_m68010: id = "68010"; break;
	  case bfd_mach_m68020: id = "68020"; break;
	  case bfd_mach_m68030: id = "68030"; break;
	  case bfd_mach_m68040: id = "68040"; break;
	  case bfd_mach_m68060: id = "68060"; break;
	  case bfd_mach_cpu32:  id = "cpu32"; break;
	  case bfd_mach_mcf_isa_a_nodiv: id = "isa-a:nodiv"; break;
	  case bfd_mach_mcf_isa_a: id = "isa-a"; break;
	  case bfd_mach_mcf_isa_a_mac: id = "isa-a:mac"; break;
	  case bfd_mach_mcf_isa_a_emac: id = "isa-a:emac"; break;
	  case bfd_mach_mcf_isa_aplus: id = "isa-aplus"; break;
	  case bfd_mach_mcf_isa_aplus_mac: id = "isa-aplus:mac"; break;
	  case bfd_mach_mcf_isa_aplus_emac: id = "isa-aplus:mac"; break;
	  case bfd_mach_mcf_isa_b_nousp: id = "isa-b:nousp"; break;
	  case bfd_mach_mcf_isa_b_nousp_mac: id = "isa-b:nousp:mac"; break;
	  case bfd_mach_mcf_isa_b_nousp_emac: id = "isa-b:nousp:emac"; break;
	  case bfd_mach_mcf_isa_b: id = "isa-b"; break;
	  case bfd_mach_mcf_isa_b_mac: id = "isa-b:mac"; break;
	  case bfd_mach_mcf_isa_b_emac: id = "isa-b:emac"; break;
	  case bfd_mach_mcf_isa_b_float: id = "isa-b:float"; break;
	  case bfd_mach_mcf_isa_b_float_mac: id = "isa-b:float:mac"; break;
	  case bfd_mach_mcf_isa_b_float_emac: id = "isa-b:float:emac"; break;
	  case bfd_mach_mcf_isa_c: id = "isa-c"; break;
	  case bfd_mach_mcf_isa_c_mac: id = "isa-c:mac"; break;
	  case bfd_mach_mcf_isa_c_emac: id = "isa-c:emac"; break;
	  case bfd_mach_mcf_isa_c_nodiv: id = "isa-c:nodiv"; break;
	  case bfd_mach_mcf_isa_c_nodiv_mac: id = "isa-c:nodiv:mac"; break;
	  case bfd_mach_mcf_isa_c_nodiv_emac: id = "isa-c:nodiv:emac"; break;
	  }

	if (! ieee_write_id (abfd, id))
	  return FALSE;
      }
      break;
    }

  return TRUE;
}

static bfd_boolean
ieee_write_object_contents (bfd *abfd)
{
  ieee_data_type *ieee = IEEE_DATA (abfd);
  unsigned int i;
  file_ptr old;

  /* Fast forward over the header area.  */
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;

  if (! ieee_write_byte (abfd, ieee_module_beginning_enum)
      || ! ieee_write_processor (abfd)
      || ! ieee_write_id (abfd, abfd->filename))
    return FALSE;

  /* Fast forward over the variable bits.  */
  if (! ieee_write_byte (abfd, ieee_address_descriptor_enum))
    return FALSE;

  /* Bits per MAU.  */
  if (! ieee_write_byte (abfd, (bfd_byte) (bfd_arch_bits_per_byte (abfd))))
    return FALSE;
  /* MAU's per address.  */
  if (! ieee_write_byte (abfd,
			 (bfd_byte) (bfd_arch_bits_per_address (abfd)
				     / bfd_arch_bits_per_byte (abfd))))
    return FALSE;

  old = bfd_tell (abfd);
  if (bfd_seek (abfd, (file_ptr) (8 * N_W_VARIABLES), SEEK_CUR) != 0)
    return FALSE;

  ieee->w.r.extension_record = bfd_tell (abfd);
  if (bfd_bwrite ((char *) exten, (bfd_size_type) sizeof (exten), abfd)
      != sizeof (exten))
    return FALSE;
  if (abfd->flags & EXEC_P)
    {
      if (! ieee_write_byte (abfd, 0x1)) /* Absolute.  */
	return FALSE;
    }
  else
    {
      if (! ieee_write_byte (abfd, 0x2)) /* Relocateable.  */
	return FALSE;
    }

  ieee->w.r.environmental_record = bfd_tell (abfd);
  if (bfd_bwrite ((char *) envi, (bfd_size_type) sizeof (envi), abfd)
      != sizeof (envi))
    return FALSE;

  /* The HP emulator database requires a timestamp in the file.  */
  {
    time_t now;
    const struct tm *t;

    time (&now);
    t = (struct tm *) localtime (&now);
    if (! ieee_write_2bytes (abfd, (int) ieee_atn_record_enum)
	|| ! ieee_write_byte (abfd, 0x21)
	|| ! ieee_write_byte (abfd, 0)
	|| ! ieee_write_byte (abfd, 50)
	|| ! ieee_write_int (abfd, (bfd_vma) (t->tm_year + 1900))
	|| ! ieee_write_int (abfd, (bfd_vma) (t->tm_mon + 1))
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_mday)
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_hour)
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_min)
	|| ! ieee_write_int (abfd, (bfd_vma) t->tm_sec))
      return FALSE;
  }

  output_bfd = abfd;

  flush ();

  if (! ieee_write_section_part (abfd))
    return FALSE;
  /* First write the symbols.  This changes their values into table
    indeces so we cant use it after this point.  */
  if (! ieee_write_external_part (abfd))
    return FALSE;

  /* Write any debugs we have been told about.  */
  if (! ieee_write_debug_part (abfd))
    return FALSE;

  /* Can only write the data once the symbols have been written, since
     the data contains relocation information which points to the
     symbols.  */
  if (! ieee_write_data_part (abfd))
    return FALSE;

  /* At the end we put the end!  */
  if (! ieee_write_me_part (abfd))
    return FALSE;

  /* Generate the header.  */
  if (bfd_seek (abfd, old, SEEK_SET) != 0)
    return FALSE;

  for (i = 0; i < N_W_VARIABLES; i++)
    {
      if (! ieee_write_2bytes (abfd, ieee_assign_value_to_variable_enum)
	  || ! ieee_write_byte (abfd, (bfd_byte) i)
	  || ! ieee_write_int5_out (abfd, (bfd_vma) ieee->w.offset[i]))
	return FALSE;
    }

  return TRUE;
}

/* Native-level interface to symbols.  */

/* We read the symbols into a buffer, which is discarded when this
   function exits.  We read the strings into a buffer large enough to
   hold them all plus all the cached symbol entries.  */

static asymbol *
ieee_make_empty_symbol (bfd *abfd)
{
  bfd_size_type amt = sizeof (ieee_symbol_type);
  ieee_symbol_type *new_symbol = (ieee_symbol_type *) bfd_zalloc (abfd, amt);

  if (!new_symbol)
    return NULL;
  new_symbol->symbol.the_bfd = abfd;
  return &new_symbol->symbol;
}

static bfd *
ieee_openr_next_archived_file (bfd *arch, bfd *prev)
{
  ieee_ar_data_type *ar = IEEE_AR_DATA (arch);

  /* Take the next one from the arch state, or reset.  */
  if (prev == (bfd *) NULL)
    /* Reset the index - the first two entries are bogus.  */
    ar->element_index = 2;

  while (TRUE)
    {
      ieee_ar_obstack_type *p = ar->elements + ar->element_index;

      ar->element_index++;
      if (ar->element_index <= ar->element_count)
	{
	  if (p->file_offset != (file_ptr) 0)
	    {
	      if (p->abfd == (bfd *) NULL)
		{
		  p->abfd = _bfd_create_empty_archive_element_shell (arch);
		  p->abfd->origin = p->file_offset;
		}
	      return p->abfd;
	    }
	}
      else
	{
	  bfd_set_error (bfd_error_no_more_archived_files);
	  return NULL;
	}
    }
}

static bfd_boolean
ieee_find_nearest_line (bfd *abfd ATTRIBUTE_UNUSED,
			asection *section ATTRIBUTE_UNUSED,
			asymbol **symbols ATTRIBUTE_UNUSED,
			bfd_vma offset ATTRIBUTE_UNUSED,
			const char **filename_ptr ATTRIBUTE_UNUSED,
			const char **functionname_ptr ATTRIBUTE_UNUSED,
			unsigned int *line_ptr ATTRIBUTE_UNUSED)
{
  return FALSE;
}

static bfd_boolean
ieee_find_inliner_info (bfd *abfd ATTRIBUTE_UNUSED,
			const char **filename_ptr ATTRIBUTE_UNUSED,
			const char **functionname_ptr ATTRIBUTE_UNUSED,
			unsigned int *line_ptr ATTRIBUTE_UNUSED)
{
  return FALSE;
}

static int
ieee_generic_stat_arch_elt (bfd *abfd, struct stat *buf)
{
  ieee_ar_data_type *ar = (ieee_ar_data_type *) NULL;
  ieee_data_type *ieee;

  if (abfd->my_archive != NULL)
    ar = abfd->my_archive->tdata.ieee_ar_data;
  if (ar == (ieee_ar_data_type *) NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  if (IEEE_DATA (abfd) == NULL)
    {
      if (ieee_object_p (abfd) == NULL)
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return -1;
	}
    }

  ieee = IEEE_DATA (abfd);

  buf->st_size = ieee->w.r.me_record + 1;
  buf->st_mode = 0644;
  return 0;
}

static int
ieee_sizeof_headers (bfd *abfd ATTRIBUTE_UNUSED,
		     struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  return 0;
}

#define	ieee_close_and_cleanup _bfd_generic_close_and_cleanup
#define ieee_bfd_free_cached_info _bfd_generic_bfd_free_cached_info

#define ieee_slurp_armap bfd_true
#define ieee_slurp_extended_name_table bfd_true
#define ieee_construct_extended_name_table \
  ((bfd_boolean (*) \
    (bfd *, char **, bfd_size_type *, const char **)) \
   bfd_true)
#define ieee_truncate_arname bfd_dont_truncate_arname
#define ieee_write_armap \
  ((bfd_boolean (*) \
    (bfd *, unsigned int, struct orl *, unsigned int, int)) \
   bfd_true)
#define ieee_read_ar_hdr bfd_nullvoidptr
#define ieee_write_ar_hdr ((bfd_boolean (*) (bfd *, bfd *)) bfd_false)
#define ieee_update_armap_timestamp bfd_true
#define ieee_get_elt_at_index _bfd_generic_get_elt_at_index

#define ieee_bfd_is_target_special_symbol  \
  ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
#define ieee_bfd_is_local_label_name bfd_generic_is_local_label_name
#define ieee_get_lineno _bfd_nosymbols_get_lineno
#define ieee_bfd_make_debug_symbol _bfd_nosymbols_bfd_make_debug_symbol
#define ieee_read_minisymbols _bfd_generic_read_minisymbols
#define ieee_minisymbol_to_symbol _bfd_generic_minisymbol_to_symbol

#define ieee_bfd_reloc_type_lookup _bfd_norelocs_bfd_reloc_type_lookup
#define ieee_bfd_reloc_name_lookup _bfd_norelocs_bfd_reloc_name_lookup

#define ieee_set_arch_mach _bfd_generic_set_arch_mach

#define ieee_get_section_contents_in_window \
  _bfd_generic_get_section_contents_in_window
#define ieee_bfd_get_relocated_section_contents \
  bfd_generic_get_relocated_section_contents
#define ieee_bfd_relax_section bfd_generic_relax_section
#define ieee_bfd_gc_sections bfd_generic_gc_sections
#define ieee_bfd_lookup_section_flags bfd_generic_lookup_section_flags
#define ieee_bfd_merge_sections bfd_generic_merge_sections
#define ieee_bfd_is_group_section bfd_generic_is_group_section
#define ieee_bfd_discard_group bfd_generic_discard_group
#define ieee_section_already_linked \
  _bfd_generic_section_already_linked
#define ieee_bfd_define_common_symbol bfd_generic_define_common_symbol
#define ieee_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#define ieee_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
#define ieee_bfd_link_add_symbols _bfd_generic_link_add_symbols
#define ieee_bfd_link_just_syms _bfd_generic_link_just_syms
#define ieee_bfd_copy_link_hash_symbol_type \
  _bfd_generic_copy_link_hash_symbol_type
#define ieee_bfd_final_link _bfd_generic_final_link
#define ieee_bfd_link_split_section  _bfd_generic_link_split_section

const bfd_target ieee_vec =
{
  "ieee",			/* Name.  */
  bfd_target_ieee_flavour,
  BFD_ENDIAN_UNKNOWN,		/* Target byte order.  */
  BFD_ENDIAN_UNKNOWN,		/* Target headers byte order.  */
  (HAS_RELOC | EXEC_P |		/* Object flags.  */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
  (SEC_CODE | SEC_DATA | SEC_ROM | SEC_HAS_CONTENTS
   | SEC_ALLOC | SEC_LOAD | SEC_RELOC),	/* Section flags.  */
  '_',				/* Leading underscore.  */
  ' ',				/* AR_pad_char.  */
  16,				/* AR_max_namelen.  */
  0,				/* match priority.  */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* Data.  */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* Headers.  */

  {_bfd_dummy_target,
   ieee_object_p,		/* bfd_check_format.  */
   ieee_archive_p,
   _bfd_dummy_target,
  },
  {
    bfd_false,
    ieee_mkobject,
    _bfd_generic_mkarchive,
    bfd_false
  },
  {
    bfd_false,
    ieee_write_object_contents,
    _bfd_write_archive_contents,
    bfd_false,
  },

  /* ieee_close_and_cleanup, ieee_bfd_free_cached_info, ieee_new_section_hook,
     ieee_get_section_contents, ieee_get_section_contents_in_window.  */
  BFD_JUMP_TABLE_GENERIC (ieee),

  BFD_JUMP_TABLE_COPY (_bfd_generic),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),

  /* ieee_slurp_armap, ieee_slurp_extended_name_table,
     ieee_construct_extended_name_table, ieee_truncate_arname,
     ieee_write_armap, ieee_read_ar_hdr, ieee_openr_next_archived_file,
     ieee_get_elt_at_index, ieee_generic_stat_arch_elt,
     ieee_update_armap_timestamp.  */
  BFD_JUMP_TABLE_ARCHIVE (ieee),

  /* ieee_get_symtab_upper_bound, ieee_canonicalize_symtab,
     ieee_make_empty_symbol, ieee_print_symbol, ieee_get_symbol_info,
     ieee_bfd_is_local_label_name, ieee_get_lineno,
     ieee_find_nearest_line, ieee_bfd_make_debug_symbol,
     ieee_read_minisymbols, ieee_minisymbol_to_symbol.  */
  BFD_JUMP_TABLE_SYMBOLS (ieee),

  /* ieee_get_reloc_upper_bound, ieee_canonicalize_reloc,
     ieee_bfd_reloc_type_lookup.   */
  BFD_JUMP_TABLE_RELOCS (ieee),

  /* ieee_set_arch_mach, ieee_set_section_contents.  */
  BFD_JUMP_TABLE_WRITE (ieee),

  /* ieee_sizeof_headers, ieee_bfd_get_relocated_section_contents,
     ieee_bfd_relax_section, ieee_bfd_link_hash_table_create,
     _bfd_generic_link_hash_table_free,
     ieee_bfd_link_add_symbols, ieee_bfd_final_link,
     ieee_bfd_link_split_section, ieee_bfd_gc_sections,
     ieee_bfd_merge_sections.  */
  BFD_JUMP_TABLE_LINK (ieee),

  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  NULL
};
@


1.72
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@d1665 1
a1665 1
  
@


1.71
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d3775 1
@


1.70
log
@fix set but unused variable warnings
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010
d3804 1
@


1.69
log
@Update copyright year.

2010-03-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-target.h: Update copyright year.
	* aout-tic30.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* elf64-mips.c: Likewise.
	* ieee.c: Likewise.
	* libecoff.h: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* oasys.c: Likewise.
	* targets.c: Likewise.
@
text
@d536 1
d641 2
d782 1
d857 1
d2677 1
@


1.68
log
@2010-01-26  Tristan Gingold  <gingold@@adacore.com>

	* targets.c (BFD_JUMP_TABLE_ARCHIVE): Add initializer for write_ar_hdr.
	(bfd_target): Add _bfd_write_ar_hdr_fn field.
	* archive.c (is_bsd44_extended_name): New macro.
	(_bfd_generic_read_ar_hdr_mag): Use it.  Add extra_size.
	(bfd_slurp_armap): Also check for "__.SYMDEF" as a BSD4.4 extended
	name.
	(_bfd_archive_bsd44_construct_extended_name_table): New function.
	(_bfd_generic_write_ar_hdr): Ditto.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_archive_contents): Call _bfd_write_ar_hdr.
	(bsd_write_armap): Adjust firstreal computation.
	* libbfd-in.h (struct areltdata): Add extra_size field.
	(_bfd_generic_write_ar_hdr): Add prototype.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_ar_hdr): Define.
	(_bfd_noarchive_write_ar_hdr): Ditto.
	(_bfd_archive_bsd_write_ar_hdr): Ditto.
	(_bfd_archive_coff_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_slurp_armap): Ditto.
	(_bfd_archive_bsd44_slurp_extended_name_table): Ditto.
	(_bfd_archive_bsd44_construct_extended_name_table): New prototype.
	(_bfd_archive_bsd44_truncate_arname): Ditto.
	(_bfd_archive_bsd44_write_armap): Ditto.
	(_bfd_archive_bsd44_read_ar_hdr): Ditto.
	(_bfd_archive_bsd44_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_openr_next_archived_file): Ditto.
	(_bfd_archive_bsd44_get_elt_at_index): Ditto.
	(_bfd_archive_bsd44_generic_stat_arch_elt): Ditto.
	(_bfd_archive_bsd44_update_armap_timestamp): Ditto.
	* libbfd.h: Regenerate.
	* oasys.c (oasys_write_ar_hdr): Define.
	* libecoff.h (_bfd_ecoff_write_ar_hdr): Define.
	* ieee.c (ieee_write_ar_hdr): Define.
	* elf64-mips.c (bfd_elf64_archive_write_ar_hdr): Define.
	* coff-rs6000.c (rs6000coff_vec): Adjust for write_ar_hdr field.
	(bfd_pmac_xcoff_backend_data): Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(bfd_xcoff_aix5_backend_data): Ditto.
	* coff-alpha.c (alpha_ecoff_write_ar_hdr): Define.
	* aout-target.h (MY_write_ar_hdr): Define it if not defined.
	* aout-tic30.c (MY_write_ar_hdr): Ditto.
	* mach-o-target.c (TARGET_NAME): Use _bfd_archive_bsd44 archive.
	(bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved to mach-o.c
	* mach-o.c (bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved from mach-o-target.c
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
@


1.67
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3746 1
@


1.66
log
@2009-11-23  Paul Brook  <paul@@codesourcery.com>

	ld/
	* ldexp.c: Copy symbol type for simple assignments.

	bfd/
	* libbfd-in.h (_bfd_generic_copy_link_hash_symbol_type): Add
	prototype.
	* elf-bfd.h (_bfd_elf_copy_link_hash_symbol_type): Add prototype.
	* linker.c (_bfd_generic_copy_link_hash_symbol_type): New function.
	* elflink.c (_bfd_elf_copy_link_hash_symbol_type): New function.
	* targets.c (BFD_JUMP_TABLE_LINK, struct bfd_target): Add
	_copy_link_hash_symbol_type.
	* bfd/coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* bfd/coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* aout-adobe.c (aout_32_bfd_copy_link_hash_symbol_type): Define.
	* aout-target.h (MY_bfd_copy_link_hash_symbol_type): Define.
	* aout-tic30.c (MY_bfd_copy_link_hash_symbol_type): Define.
	* binary.c (binary_bfd_copy_link_hash_symbol_type): Define.
	* bout.c (b_out_bfd_copy_link_hash_symbol_type): Define.
	* coffcode.h (coff_bfd_copy_link_hash_symbol_type): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_link_hash_symbol_type): Define.
	* i386msdos.c (msdos_bfd_copy_link_hash_symbol_type): Define.
	* i386os9k.c (os9k_bfd_copy_link_hash_symbol_type): Define.
	* ieee.c (ieee_bfd_copy_link_hash_symbol_type): Define.
	* ihex.c (ihex_bfd_copy_link_hash_symbol_type): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_link_hash_symbol_type): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_link_hash_symbol_type): Define.
	* mmo.c (mmo_bfd_copy_link_hash_symbol_type): Define.
	* nlm-target.h (nlm_bfd_copy_link_hash_symbol_type): Define.
	* oasys.c (oasys_bfd_copy_link_hash_symbol_type): Define.
	* pef.c (bfd_pef_bfd_copy_link_hash_symbol_type): Define.
	* ppcboot.c (ppcboot_bfd_copy_link_hash_symbol_type): Define.
	* som.c (som_bfd_copy_link_hash_symbol_type): Define.
	* srec.c (srec_bfd_copy_link_hash_symbol_type): Define.
	* tekhex.c (tekhex_bfd_copy_link_hash_symbol_type): Define.
	* versados.c (versados_bfd_copy_link_hash_symbol_type): Define.
	* vms.c (vms_bfd_copy_link_hash_symbol_type): Define.
	* xsym.c (bfd_sym_bfd_copy_link_hash_symbol_type): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	ld/testsuite
	* ld-arm/script-type.sym: New test.
	* ld-arm/script-type.s: New test.
	* ld-arm/script-type.s: New test.
@
text
@d231 1
a231 1
		       unsigned int index)
d300 1
a300 1
				(bfd_byte) (index + IEEE_SECTION_NUMBER_BASE))
d1048 1
a1048 1
get_section_entry (bfd *abfd, ieee_data_type *ieee, unsigned int index)
d1050 1
a1050 1
  if (index >= ieee->section_table_size)
d1059 1
a1059 1
      while (c <= index)
d1075 1
a1075 1
  if (ieee->section_table[index] == (asection *) NULL)
d1082 1
a1082 1
      sprintf (tmp, " fsec%4d", index);
d1084 3
a1086 3
      ieee->section_table[index] = section;
      section->target_index = index;
      ieee->section_table[index] = section;
d1088 1
a1088 1
  return ieee->section_table[index];
@


1.65
log
@update copyright dates
@
text
@d3778 2
@


1.64
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.63
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d3630 1
a3630 1
  ieee_symbol_type *new = bfd_zalloc (abfd, amt);
d3632 1
a3632 1
  if (!new)
d3634 2
a3635 2
  new->symbol.the_bfd = abfd;
  return &new->symbol;
@


1.62
log
@bfd/
	* archures.c: Add bfd_mach_mcf_isa_c_nodiv,
	bfd_mach_mcf_isa_c_nodiv_mac & bfd_mach_mcf_isa_c_nodiv_emac.
	* ieee.c (ieee_write_processor): Update coldfire architecture
	list.
	* bfd-in2.h: Rebuilt.
	* cpu-m68k.c (arch_info_struct): Add isa_c nodiv architectures.
	(m68k_arch_features): Likewise.
	* elf32-m68k.c (elf32_m68k_object_p): Add EF_M68K_CF_ISA_C_NODIV.
	(elf32_m68k_print_private_bfd_data): Likewise.

gas/
	* config/tc-m68k.c (m68k_ip): Add mcfisa_c case.
	(m68k_elf_final_processing): Add EF_M68K_CF_ISA_C_NODIV.

include/elf/
	* m68k.h (EF_M68K_CF_ISA_C_NODIV): New.
@
text
@d3773 1
@


1.61
log
@Switch sources over to use the GPL version 3
@
text
@d3490 6
@


1.60
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d22 3
a24 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.59
log
@* ecoff.c (_bfd_ecoff_write_armap): Initialise rehash.
  (ecoff_link_add_archive_symbols): Likewise.
* coff-m68k.c (m68kcoff_common_addend_rtype_to_howto): Initialise relent.howto.
* ieee.c (parse_int): Initialise x.
  (must_parse_int): Initialise result.
  (ieee_slurp_external_symbols): Initialise value.
@
text
@d30 1
a31 1
#include "sysdep.h"
@


1.58
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d373 1
a373 1
  bfd_vma x;
d381 1
a381 1
  bfd_vma result;
d770 1
a770 1
	    bfd_vma value;
@


1.57
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006
d3750 1
@


1.56
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d1878 2
a1879 2
    else if ((strncmp (processor, "cpu32", 5) == 0) /* CPU32 and CPU32+ */
	     || (strncmp (processor, "CPU32", 5) == 0))
@


1.55
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d3718 1
a3718 1
		     bfd_boolean x ATTRIBUTE_UNUSED)
@


1.54
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@a1082 1
      section->flags = SEC_NO_FLAGS;
d1270 1
d1275 2
a1276 1
  sec = bfd_make_section (abfd, ".debug");
a1278 1
  sec->flags |= SEC_DEBUGGING | SEC_HAS_CONTENTS;
@


1.53
log
@	bfd:
	* archures.c (bfd_mach_mcf_isa_a_nodiv, bfd_mach_mcf_isa_b_nousp):
	New.  Adjust other variants.
	(bfd_default_scan): Update.
	* bfd-in2.h: Rebuilt.
	* cpu-m68k.c: Adjust.
	(bfd_m68k_compatible): New. Use it for architectures.
	* elf32-m68k.c (elf32_m68k_object_p): Adjust.
	(elf32_m68k_merge_private_bfd_data): Adjust.  Correct isa-a/b
	mismatch.
	(elf32_m68k_print_private_bfd_data): Adjust.
	* ieee.c (ieee_write_processor): Adjust.

	binutils:
	* readelf.c (get_machine_flags): Adjust.

	gas:
	* config/tc-m68k.c (m68k_extensions): Allow 'float' on both m68k
	and cf.
	(m68k_ip): <case 'J'> Check we have some control regs.
	(md_parse_option): Allow raw arch switch.
	(m68k_init_arch): Better detection of arch/cpu mismatch.  Detect
	whether 68881 or cfloat was meant by -mfloat.
	(md_show_usage): Adjust extension display.
	(m68k_elf_final_processing): Adjust.

	gas/testsuite:
	* gas/m68k/arch-cpu-1.s: Tweak.
	* gas/m68k/arch-cpu-1.d: Tweak.

	include/elf:
	* m68k.h (EF_M68K_ISA_MASK, EF_M68K_ISA_A,
	EF_M68K_ISA_A_PLUS, EF_M68K_ISA_B, EF_M68K_ISA_C): Adjust.
	(EF_M68K_ISA_A_NODIV, EF_M68K_ISA_B_NOUSP): New.
	(EF_M68K_HW_DIV, EF_M68K_USP): Remove.
	(EF_M68K_MAC, EF_M68K_EMAC, EF_M68K_FLOAT): Adjust.
	(EF_M68K_EMAC_B): New.

	ld/testsuite:
	* ld-m68k: New tests.
@
text
@a2016 1
  newsect->used_by_bfd = bfd_alloc (abfd, (bfd_size_type) sizeof (ieee_per_section_type));
d2018 5
a2022 1
    return FALSE;
d2025 1
a2025 1
  return TRUE;
@


1.52
log
@	* bfd/archures.c (bfd_mach_mcf5200, bfd_mach_mcf5206e,
	bfd_mach_mcf5307, bfd_mach_mcf5407, bfd_mach_mcf528x,
	bfd_mach_mcfv4e, bfd_mach_mcf521x, bfd_mach_mcf5249,
	bfd_mach_mcf547x, bfd_mach_mcf548x): Remove.
	(bfd_mach_mcf_isa_a, bfd_mach_mcf_isa_a_div,
	bfd_mach_mcf_isa_a_div_mac, bfd_mach_mcf_isa_a_div_emac,
	bfd_mach_mcf_isa_aplus, bfd_mach_mcf_isa_aplus_mac,
	bfd_mach_mcf_isa_aplus_emac, bfd_mach_mcf_isa_aplus_usp,
	bfd_mach_mcf_isa_aplus_usp_mac, bfd_mach_mcf_isa_aplus_usp_emac,
	bfd_mach_mcf_isa_b, bfd_mach_mcf_isa_b_mac, bfd_mach_mcf_isa_b_emac,
	bfd_mach_mcf_isa_b_usp_float, bfd_mach_mcf_isa_b_usp_float_mac,
	bfd_mach_mcf_isa_b_usp_float_emac): New.
	(bfd_default_scan): Update coldfire mapping.
	* bfd/bfd-in.h (bfd_m68k_mach_to_features,
	bfd_m68k_features_to_mach): Declare.
	* bfd/bfd-in2.h: Rebuilt.
	* bfd/cpu-m68k.c (arch_info_struct): Add new coldfire machines,
	adjust legacy names.
	(m68k_arch_features): New.
	(bfd_m68k_mach_to_features,
	bfd_m68k_features_to_mach): Define.
	* bfd/elf32-m68k.c (elf32_m68k_object_p): New.
	(elf32_m68k_merge_private_bfd_data): Merge the CF EF flags.
	(elf32_m68k_print_private_bfd_data): Print the CF EF flags.
	(elf_backend_object_p): Define.
	* bfd/ieee.c (ieee_write_processor): Update coldfire machines.
	* bfd/libbfd.h: Rebuilt.

	* gas/config/tc-m68k.c (mcf5208_control_regs, mcf5213_control_regs,
	mcf5329_control_regs): New.
	(not_current_architecture, selected_arch, selected_cpu): New.
	(m68k_archs, m68k_extensions): New.
	(archs): Renamed to ...
	(m68k_cpus): ... here.  Adjust.
	(n_arches): Remove.
	(md_pseudo_table): Add arch and cpu directives.
	(find_cf_chip, m68k_ip): Adjust table scanning.
	(no_68851, no_68881): Remove.
	(md_assemble): Lazily initialize.
	(select_control_regs): Adjust cpu names. Add 5208, 5213, 5329.
	(md_init_after_args): Move functionality to m68k_init_arch.
	(mri_chip): Adjust table scanning.
	(md_parse_option): Reimplement 'm' processing to add -march & -mcpu
	options with saner parsing.
	(m68k_lookup_cpu, m68k_set_arch, m68k_set_cpu, m68k_set_extension,
	m68k_init_arch): New.
	(s_m68k_cpu, s_m68k_arch): New.
	(md_show_usage): Adjust.
	(m68k_elf_final_processing): Set CF EF flags.
	* gas/config/tc-m68k.h (m68k_init_after_args): Remove.
	(tc_init_after_args): Remove.
	* gas/doc/c-m68k.texi (M68K-Opts): Document -march, -mcpu options.
	(M68k-Directives): Document .arch and .cpu directives.

	* gas/testsuite/gas/m68k/all.exp: Add arch-cpu-1 test.
	* gas/testsuite/gas/m68k/arch-cpu-1.[sd]: New.

	* include/elf/m68k.h (EF_CPU32, EF_M68000, EF_CFV4E): Rename to ...
	(EF_M68K_CPU32, EF_M68K_M68000, EF_M68K_CFV4E): ... here.
	(EF_M68K_ISA_MASK, EF_M68K_ISA_A, EF_M68K_M68K_ISA_A_PLUS,
	EF_M68K_ISA_B, EF_M68K_HW_DIV, EF_M68K_MAC_MASK, EF_M68K_MAC,
	EF_M68K_EMAC, EF_M68K_USP, EF_M68K_FLOAT): New.

	* include/opcode/m68k.h (m68008, m68ec030, m68882): Remove.
	(m68k_mask): New.
	(cpu_m68k, cpu_cf): New.
	(mcf5200, mcf5206e, mcf521x, mcf5249, mcf528x, mcf5307, mcf5407,
	mcf5470, mcf5480): Rename to cpu_<foo>. Add m680x0 variants.

	* opcodes/m68k-dis.c (print_insn_m68k): Use
	bfd_m68k_mach_to_features.

	* binutils/readelf.c (get_machine_flags): Add logic for EF_M68K flags.
@
text
@d3469 1
d3471 8
a3478 9
	  case bfd_mach_mcf_isa_a_div: id = "isa-a:div"; break;
	  case bfd_mach_mcf_isa_a_div_mac: id = "isa-a:div:mac"; break;
	  case bfd_mach_mcf_isa_a_div_emac: id = "isa-a:div:emac"; break;
	  case bfd_mach_mcf_isa_aplus: id = "isa-a+"; break;
	  case bfd_mach_mcf_isa_aplus_mac: id = "isa-a+:mac"; break;
	  case bfd_mach_mcf_isa_aplus_emac: id = "isa-a+:mac"; break;
	  case bfd_mach_mcf_isa_aplus_usp: id = "isa-a+:usp"; break;
	  case bfd_mach_mcf_isa_aplus_usp_mac: id = "isa-a+:usp:mac"; break;
	  case bfd_mach_mcf_isa_aplus_usp_emac: id = "isa-a+:usp:emac"; break;
d3482 3
a3484 3
	  case bfd_mach_mcf_isa_b_usp_float: id = "isa-b:usp:float"; break;
	  case bfd_mach_mcf_isa_b_usp_float_mac: id = "isa-b:usp:float:mac"; break;
	  case bfd_mach_mcf_isa_b_usp_float_emac: id = "isa-b:usp:float:emac"; break;
@


1.51
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005
d3469 16
a3484 5
	  case bfd_mach_mcf5200:id = "5200";  break;
	  case bfd_mach_mcf5206e:id = "5206e"; break;
	  case bfd_mach_mcf5307:id = "5307";  break;
	  case bfd_mach_mcf5407:id = "5407";  break;
	  case bfd_mach_mcf528x:id = "5282";  break;
@


1.50
log
@Remove a29k support.
@
text
@d1669 1
d1676 2
a1677 2
      per->reloc_tail_ptr =
	(ieee_reloc_type **) & (s->relocation);
@


1.49
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@a3414 5
    case bfd_arch_a29k:
      if (! ieee_write_id (abfd, "29000"))
	return FALSE;
      break;

@


1.48
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3667 9
@


1.47
log
@Update the FSF address in the copyright/GPL notice
@
text
@d22 1
a22 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.46
log
@Convert to ISO C90 formatting
@
text
@d22 1
a22 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.45
log
@Oops - fix typos and finish of ISO-C90'fication of ieee.c
@
text
@a1492 1
		  bfd_size_type amt = sizeof (ieee_reloc_type);
d1494 1
a1494 1
		  r = bfd_alloc (ieee->h.abfd, amt);
d3711 1
a3711 1
    PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
d3716 1
a3716 1
    PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int))) \
d3754 1
a3754 1
  "ieee",			/* name */
d3756 3
a3758 3
  BFD_ENDIAN_UNKNOWN,		/* target byte order */
  BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
  (HAS_RELOC | EXEC_P |		/* object flags */
d3762 4
a3765 4
   | SEC_ALLOC | SEC_LOAD | SEC_RELOC),	/* section flags */
  '_',				/* leading underscore */
  ' ',				/* ar_pad_char */
  16,				/* ar_max_namelen */
d3768 1
a3768 1
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
d3771 1
a3771 1
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
d3774 1
a3774 1
   ieee_object_p,		/* bfd_check_format */
d3831 1
a3831 1
  (void *) 0
@


1.44
log
@Convert to ISO C90 formatting.
@
text
@d43 13
d379 1
a379 1
must_parse_int (common_header_type *ieee)a
d971 1
a971 2
ieee_get_symtab_upper_bound (abfd)
     bfd *abfd;
d1289 1
a1289 1
const bfd_target *
d1430 2
a1431 2
const bfd_target *
ieee_object_p (bfd *abfd)
a1432 5
  char *processor;
  unsigned int part;
  ieee_data_type *ieee;
  unsigned char buffer[300];
  ieee_data_type *save = IEEE_DATA (abfd);
d1435 12
a1446 222
  abfd->tdata.ieee_data = 0;
  ieee_mkobject (abfd);

  ieee = IEEE_DATA (abfd);
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto fail;
  /* Read the first few bytes in to see if it makes sense.  Ignore
     bfd_bread return value;  The file might be very small.  */
  bfd_bread ((void *) buffer, (bfd_size_type) sizeof (buffer), abfd);

  ieee->h.input_p = buffer;
  if (this_byte_and_next (&(ieee->h)) != Module_Beginning)
    goto got_wrong_format;

  ieee->read_symbols = FALSE;
  ieee->read_data = FALSE;
  ieee->section_count = 0;
  ieee->external_symbol_max_index = 0;
  ieee->external_symbol_min_index = IEEE_PUBLIC_BASE;
  ieee->external_reference_min_index = IEEE_REFERENCE_BASE;
  ieee->external_reference_max_index = 0;
  ieee->h.abfd = abfd;
  ieee->section_table = NULL;
  ieee->section_table_size = 0;

  processor = ieee->mb.processor = read_id (&(ieee->h));
  if (strcmp (processor, "LIBRARY") == 0)
    goto got_wrong_format;
  ieee->mb.module_name = read_id (&(ieee->h));
  if (abfd->filename == (const char *) NULL)
    abfd->filename = ieee->mb.module_name;

  /* Determine the architecture and machine type of the object file.  */
  {
    const bfd_arch_info_type *arch;
    char family[10];

    /* IEEE does not specify the format of the processor identification
       string, so the compiler is free to put in it whatever it wants.
       We try here to recognize different processors belonging to the
       m68k family.  Code for other processors can be added here.  */
    if ((processor[0] == '6') && (processor[1] == '8'))
      {
	if (processor[2] == '3')	    /* 683xx integrated processors.  */
	  {
	    switch (processor[3])
	      {
	      case '0':			    /* 68302, 68306, 68307 */
	      case '2':			    /* 68322, 68328 */
	      case '5':			    /* 68356 */
		strcpy (family, "68000");   /* MC68000-based controllers.  */
		break;

	      case '3':			    /* 68330, 68331, 68332, 68333,
					       68334, 68335, 68336, 68338 */
	      case '6':			    /* 68360 */
	      case '7':			    /* 68376 */
		strcpy (family, "68332");   /* CPU32 and CPU32+ */
		break;

	      case '4':
		if (processor[4] == '9')    /* 68349 */
		  strcpy (family, "68030"); /* CPU030 */
		else		            /* 68340, 68341 */
		  strcpy (family, "68332"); /* CPU32 and CPU32+ */
		break;

	      default:			    /* Does not exist yet.  */
		strcpy (family, "68332");   /* Guess it will be CPU32 */
	      }
	  }
	else if (TOUPPER (processor[3]) == 'F')  /* 68F333 */
	  strcpy (family, "68332");	           /* CPU32 */
	else if ((TOUPPER (processor[3]) == 'C') /* Embedded controllers.  */
		 && ((TOUPPER (processor[2]) == 'E')
		     || (TOUPPER (processor[2]) == 'H')
		     || (TOUPPER (processor[2]) == 'L')))
	  {
	    strcpy (family, "68");
	    strncat (family, processor + 4, 7);
	    family[9] = '\0';
	  }
	else				 /* "Regular" processors.  */
	  {
	    strncpy (family, processor, 9);
	    family[9] = '\0';
	  }
      }
    else if ((strncmp (processor, "cpu32", 5) == 0) /* CPU32 and CPU32+ */
	     || (strncmp (processor, "CPU32", 5) == 0))
      strcpy (family, "68332");
    else
      {
	strncpy (family, processor, 9);
	family[9] = '\0';
      }

    arch = bfd_scan_arch (family);
    if (arch == 0)
      goto got_wrong_format;
    abfd->arch_info = arch;
  }

  if (this_byte (&(ieee->h)) != (int) ieee_address_descriptor_enum)
    goto fail;

  next_byte (&(ieee->h));

  if (! parse_int (&(ieee->h), &ieee->ad.number_of_bits_mau))
    goto fail;

  if (! parse_int (&(ieee->h), &ieee->ad.number_of_maus_in_address))
    goto fail;

  /* If there is a byte order info, take it.  */
  if (this_byte (&(ieee->h)) == (int) ieee_variable_L_enum
      || this_byte (&(ieee->h)) == (int) ieee_variable_M_enum)
    next_byte (&(ieee->h));

  for (part = 0; part < N_W_VARIABLES; part++)
    {
      bfd_boolean ok;

      if (read_2bytes (&(ieee->h)) != (int) ieee_assign_value_to_variable_enum)
	goto fail;

      if (this_byte_and_next (&(ieee->h)) != part)
	goto fail;

      ieee->w.offset[part] = parse_i (&(ieee->h), &ok);
      if (! ok)
	goto fail;
    }

  if (ieee->w.r.external_part != 0)
    abfd->flags = HAS_SYMS;

  /* By now we know that this is a real IEEE file, we're going to read
     the whole thing into memory so that we can run up and down it
     quickly.  We can work out how big the file is from the trailer
     record.  */

  amt = ieee->w.r.me_record + 1;
  IEEE_DATA (abfd)->h.first_byte = bfd_alloc (ieee->h.abfd, amt);
  if (!IEEE_DATA (abfd)->h.first_byte)
    goto fail;
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto fail;
  /* FIXME: Check return value.  I'm not sure whether it needs to read
     the entire buffer or not.  */
  bfd_bread ((void *) (IEEE_DATA (abfd)->h.first_byte),
	    (bfd_size_type) ieee->w.r.me_record + 1, abfd);

  ieee_slurp_sections (abfd);

  if (! ieee_slurp_debug (abfd))
    goto fail;

  /* Parse section data to activate file and section flags implied by
     section contents.  */
  if (! ieee_slurp_section_data (abfd))
    goto fail;

  return abfd->xvec;
got_wrong_format:
  bfd_set_error (bfd_error_wrong_format);
fail:
  bfd_release (abfd, ieee);
  abfd->tdata.ieee_data = save;
  return (const bfd_target *) NULL;
}

static void
ieee_get_symbol_info (bfd *ignore_abfd ATTRIBUTE_UNUSED,
		      asymbol *symbol,
		      symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);
  if (symbol->name[0] == ' ')
    ret->name = "* empty table entry ";
  if (!symbol->section)
    ret->type = (symbol->flags & BSF_LOCAL) ? 'a' : 'A';
}

static void
ieee_print_symbol (bfd *abfd,
		   void * afile,
		   asymbol *symbol,
		   bfd_print_symbol_type how)
{
  FILE *file = (FILE *) afile;

  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_more:
      BFD_FAIL ();
      break;
    case bfd_print_symbol_all:
      {
	const char *section_name =
	  (symbol->section == (asection *) NULL
	   ? "*abs"
	   : symbol->section->name);

	if (symbol->name[0] == ' ')
	  fprintf (file, "* empty table entry ");
	else
	  {
	    bfd_print_symbol_vandf (abfd, (void *) file, symbol);

	    fprintf (file, " %-5s %04x %02x %s",
		     section_name,
		     (unsigned) ieee_symbol (symbol)->index,
		     (unsigned) 0,
		     symbol->name);
	  }
      }
      break;
    }
d1780 234
a2445 30

static unsigned char *output_ptr_start;
static unsigned char *output_ptr;
static unsigned char *output_ptr_end;
static unsigned char *input_ptr_start;
static unsigned char *input_ptr;
static unsigned char *input_ptr_end;
static bfd *input_bfd;
static bfd *output_bfd;
static int output_buffer;

static bfd_boolean
ieee_mkobject (bfd *abfd)
{
  bfd_size_type amt;

  output_ptr_start = NULL;
  output_ptr = NULL;
  output_ptr_end = NULL;
  input_ptr_start = NULL;
  input_ptr = NULL;
  input_ptr_end = NULL;
  input_bfd = NULL;
  output_bfd = NULL;
  output_buffer = 0;
  amt = sizeof (ieee_data_type);
  abfd->tdata.ieee_data = bfd_zalloc (abfd, amt);
  return abfd->tdata.ieee_data != NULL;
}

d2509 1
a2509 1
copy_id ()
d2526 1
a2526 1
copy_expression ()
d2627 1
a2627 2
fill_int (buf)
     struct output_buffer_struct *buf;
d2641 1
a2641 2
drop_int (buf)
     struct output_buffer_struct *buf;
d2677 1
a2677 1
copy_int ()
d2709 5
a2713 5
#define ID copy_id()
#define INT copy_int()
#define EXP copy_expression()
#define INTn(q) copy_int()
#define EXPn(q) copy_expression()
d2716 40
a2755 1
f1_record ()
d2856 1
a2856 1
f0_record ()
d2866 1
a2866 40
copy_till_end ()
{
  int ch = THIS ();

  while (1)
    {
      while (ch <= 0x80)
	{
	  OUT (ch);
	  NEXT ();
	  ch = THIS ();
	}
      switch (ch)
	{
	case 0x84:
	  OUT (THIS ());
	  NEXT ();
	case 0x83:
	  OUT (THIS ());
	  NEXT ();
	case 0x82:
	  OUT (THIS ());
	  NEXT ();
	case 0x81:
	  OUT (THIS ());
	  NEXT ();
	  OUT (THIS ());
	  NEXT ();

	  ch = THIS ();
	  break;
	default:
	  return;
	}
    }

}

static void
f2_record ()
a2876 1

d2878 1
a2878 1
f8_record ()
d3027 1
a3027 1
e2_record ()
d3038 1
a3038 1
block ()
a3071 1

d3076 2
a3077 3
relocate_debug (output, input)
     bfd *output ATTRIBUTE_UNUSED;
     bfd *input;
d3096 1
a3096 2
ieee_write_debug_part (abfd)
     bfd *abfd;
d3158 1
a3158 2
ieee_write_data_part (abfd)
     bfd *abfd;
a3188 1

d3190 1
a3190 2
init_for_output (abfd)
     bfd *abfd;
d3215 5
a3219 6
ieee_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     const void * location;
     file_ptr offset;
     bfd_size_type count;
d3253 1
a3253 2
ieee_write_external_part (abfd)
     bfd *abfd;
d3383 1
a3383 2
ieee_write_me_part (abfd)
     bfd *abfd;
d3404 1
a3404 2
ieee_write_processor (abfd)
     bfd *abfd;
d3491 1
a3491 2
ieee_write_object_contents (abfd)
     bfd *abfd;
d3610 1
a3610 2
ieee_make_empty_symbol (abfd)
     bfd *abfd;
d3622 1
a3622 3
ieee_openr_next_archived_file (arch, prev)
     bfd *arch;
     bfd *prev;
d3651 1
a3651 1
	  return (bfd *) NULL;
d3657 7
a3663 9
ieee_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
			functionname_ptr, line_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
     bfd_vma offset ATTRIBUTE_UNUSED;
     const char **filename_ptr ATTRIBUTE_UNUSED;
     const char **functionname_ptr ATTRIBUTE_UNUSED;
     unsigned int *line_ptr ATTRIBUTE_UNUSED;
d3669 1
a3669 3
ieee_generic_stat_arch_elt (abfd, buf)
     bfd *abfd;
     struct stat *buf;
d3699 2
a3700 3
ieee_sizeof_headers (abfd, x)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean x ATTRIBUTE_UNUSED;
@


1.43
log
@update copyright dates
@
text
@a42 141
static bfd_boolean ieee_write_byte
  PARAMS ((bfd *, int));
static bfd_boolean ieee_write_2bytes
  PARAMS ((bfd *, int));
static bfd_boolean ieee_write_int
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean ieee_write_id
  PARAMS ((bfd *, const char *));
static unsigned short read_2bytes
  PARAMS ((common_header_type *));
static void bfd_get_string
  PARAMS ((common_header_type *, char *, size_t));
static char *read_id
  PARAMS ((common_header_type *));
static bfd_boolean ieee_write_expression
  PARAMS ((bfd *, bfd_vma, asymbol *, bfd_boolean, unsigned int));
static void ieee_write_int5
  PARAMS ((bfd_byte *, bfd_vma));
static bfd_boolean ieee_write_int5_out
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean parse_int
  PARAMS ((common_header_type *, bfd_vma *));
static int parse_i
  PARAMS ((common_header_type *, bfd_boolean *));
static bfd_vma must_parse_int
  PARAMS ((common_header_type *));
static void parse_expression
  PARAMS ((ieee_data_type *, bfd_vma *, ieee_symbol_index_type *,
	   bfd_boolean *, unsigned int *, asection **));
static file_ptr ieee_part_after
  PARAMS ((ieee_data_type *, file_ptr));
static ieee_symbol_type *get_symbol
  PARAMS ((bfd *, ieee_data_type *, ieee_symbol_type *, unsigned int *,
	   ieee_symbol_type ***, unsigned int *, int));
static bfd_boolean ieee_slurp_external_symbols
  PARAMS ((bfd *));
static bfd_boolean ieee_slurp_symbol_table
  PARAMS ((bfd *));
static long ieee_get_symtab_upper_bound
  PARAMS ((bfd *));
static long ieee_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
static asection *get_section_entry
  PARAMS ((bfd *, ieee_data_type *i, unsigned int));
static void ieee_slurp_sections
  PARAMS ((bfd *));
static bfd_boolean ieee_slurp_debug
  PARAMS ((bfd *));
const bfd_target *ieee_archive_p
  PARAMS ((bfd *));
const bfd_target *ieee_object_p
  PARAMS ((bfd *));
static void ieee_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void ieee_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static bfd_boolean do_one
  PARAMS ((ieee_data_type *, ieee_per_section_type *, unsigned char *,
	   asection *, int));
static bfd_boolean ieee_slurp_section_data
  PARAMS ((bfd *));
static bfd_boolean ieee_new_section_hook
  PARAMS ((bfd *, asection *));
static long ieee_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static bfd_boolean ieee_get_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static long ieee_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
static int comp
  PARAMS ((const PTR, const PTR));
static bfd_boolean ieee_write_section_part
  PARAMS ((bfd *));
static bfd_boolean do_with_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean do_as_repeat
  PARAMS ((bfd *, asection *));
static bfd_boolean do_without_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean ieee_mkobject
  PARAMS ((bfd *));
static void fill
  PARAMS ((void));
static void flush
  PARAMS ((void));
static void write_int
  PARAMS ((int));
static void copy_id
  PARAMS ((void));
static void copy_expression
  PARAMS ((void));
static void fill_int
  PARAMS ((struct output_buffer_struct *));
static void drop_int
  PARAMS ((struct output_buffer_struct *));
static void copy_int
  PARAMS ((void));
static void f1_record
  PARAMS ((void));
static void f0_record
  PARAMS ((void));
static void copy_till_end
  PARAMS ((void));
static void f2_record
  PARAMS ((void));
static void f8_record
  PARAMS ((void));
static void e2_record
  PARAMS ((void));
static void block
  PARAMS ((void));
static void relocate_debug
  PARAMS ((bfd *, bfd *));
static bfd_boolean ieee_write_debug_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_data_part
  PARAMS ((bfd *));
static bfd_boolean init_for_output
  PARAMS ((bfd *));
static bfd_boolean ieee_set_section_contents
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
static bfd_boolean ieee_write_external_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_me_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_processor
  PARAMS ((bfd *));
static bfd_boolean ieee_write_object_contents
  PARAMS ((bfd *));
static asymbol *ieee_make_empty_symbol
  PARAMS ((bfd *));
static bfd *ieee_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd_boolean ieee_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
static int ieee_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static int ieee_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));

d44 1
a44 1
   standard requires. */
d47 1
a47 3
ieee_write_byte (abfd, barg)
     bfd *abfd;
     int barg;
d52 1
a52 1
  if (bfd_bwrite ((PTR) &byte, (bfd_size_type) 1, abfd) != 1)
d58 1
a58 3
ieee_write_2bytes (abfd, bytes)
     bfd *abfd;
     int bytes;
d64 1
a64 1
  if (bfd_bwrite ((PTR) buffer, (bfd_size_type) 2, abfd) != 2)
d70 1
a70 3
ieee_write_int (abfd, value)
     bfd *abfd;
     bfd_vma value;
d120 1
a120 3
ieee_write_id (abfd, id)
     bfd *abfd;
     const char *id;
d150 1
a150 1
  if (bfd_bwrite ((PTR) id, (bfd_size_type) length, abfd) != length)
d158 2
a159 2
#define this_byte(ieee) *((ieee)->input_p)
#define next_byte(ieee) ((ieee)->input_p++)
d163 1
a163 2
read_2bytes (ieee)
     common_header_type *ieee;
d172 1
a172 4
bfd_get_string (ieee, string, length)
     common_header_type *ieee;
     char *string;
     size_t length;
d181 1
a181 2
read_id (ieee)
     common_header_type *ieee;
d188 3
a190 3
    {
      /* Simple string of length 0 to 127.  */
    }
d192 3
a194 4
    {
      /* Length is next byte, allowing 0..255.  */
      length = this_byte_and_next (ieee);
    }
d212 5
a216 6
ieee_write_expression (abfd, value, symbol, pcrel, index)
     bfd *abfd;
     bfd_vma value;
     asymbol *symbol;
     bfd_boolean pcrel;
     unsigned int index;
a242 1

d308 1
a308 3
ieee_write_int5 (buffer, value)
     bfd_byte *buffer;
     bfd_vma value;
d318 1
a318 3
ieee_write_int5_out (abfd, value)
     bfd *abfd;
     bfd_vma value;
d323 1
a323 1
  if (bfd_bwrite ((PTR) b, (bfd_size_type) 5, abfd) != 5)
d329 1
a329 3
parse_int (ieee, value_ptr)
     common_header_type *ieee;
     bfd_vma *value_ptr;
d358 1
a358 3
parse_i (ieee, ok)
     common_header_type *ieee;
     bfd_boolean *ok;
d366 1
a366 2
must_parse_int (ieee)
     common_header_type *ieee;
d486 6
a491 7
parse_expression (ieee, value, symbol, pcrel, extra, section)
     ieee_data_type *ieee;
     bfd_vma *value;
     ieee_symbol_index_type *symbol;
     bfd_boolean *pcrel;
     unsigned int *extra;
     asection **section;
d494 5
a504 3
  bfd_boolean loop = TRUE;
  ieee_value_type stack[10];

d506 2
a507 4
#define PUSH(x,y,z) TOS.symbol=x;TOS.section=y;TOS.value=z;INC;
#define POP(x,y,z) DEC;x=TOS.symbol;y=TOS.section;z=TOS.value;
  ieee_value_type *sp = stack;
  asection *dummy;
d546 1
d558 1
d571 1
d586 1
d599 1
d607 2
a608 4
	      {
		/* Thats all that we can understand.  */
		loop = FALSE;
	      }
d623 1
d648 1
a648 3
ieee_part_after (ieee, here)
     ieee_data_type *ieee;
     file_ptr here;
d666 7
a672 8
get_symbol (abfd, ieee, last_symbol, symbol_count, pptr, max_index, this_type)
     bfd *abfd ATTRIBUTE_UNUSED;
     ieee_data_type *ieee;
     ieee_symbol_type *last_symbol;
     unsigned int *symbol_count;
     ieee_symbol_type ***pptr;
     unsigned int *max_index;
     int this_type;
d682 1
a682 1
      new_symbol = (ieee_symbol_type *) bfd_alloc (ieee->h.abfd, amt);
d702 1
a702 2
ieee_slurp_external_symbols (abfd)
     bfd *abfd;
d709 1
a709 1
  ieee_symbol_type *symbol = (ieee_symbol_type *) NULL;
d712 1
d726 2
a727 2
			       &prev_symbols_ptr,
			       &ieee->external_symbol_max_index, 'I');
d733 1
a733 1
	  symbol->symbol.udata.p = (PTR) NULL;
d749 1
a749 1
	  symbol->symbol.udata.p = (PTR) NULL;
d758 1
d833 1
d875 1
d883 1
a883 3
	      {
		value = 0;
	      }
d901 1
a901 1
	  symbol->symbol.udata.p = (PTR) NULL;
d921 1
a921 3
    {
      ieee->external_symbol_count = 0;
    }
d930 1
a930 3
    {
      ieee->external_reference_count = 0;
    }
d936 2
a937 4
    {
      /* There are gaps in the table -- */
      ieee->symbol_table_full = FALSE;
    }
d939 2
a940 2
  *prev_symbols_ptr = (ieee_symbol_type *) NULL;
  *prev_reference_ptr = (ieee_symbol_type *) NULL;
d946 1
a946 2
ieee_slurp_symbol_table (abfd)
     bfd *abfd;
d974 1
a974 3
ieee_canonicalize_symtab (abfd, location)
     bfd *abfd;
     asymbol **location;
d994 1
d1034 1
a1034 4
get_section_entry (abfd, ieee, index)
     bfd *abfd;
     ieee_data_type *ieee;
     unsigned int index;
d1050 1
a1050 1
      n = (asection **) bfd_realloc (ieee->section_table, amt);
d1079 1
a1079 2
ieee_slurp_sections (abfd)
     bfd *abfd;
d1088 1
d1098 1
d1116 2
a1117 1
		      case 0xD3:	/* AS Absolute section attributes.  */
d1142 3
a1144 1
		  case 0xC3:	/* Named relocatable sections (type C).  */
d1174 1
d1186 1
d1191 2
a1192 3
		  {
		    ieee->section_count = section_index;
		  }
d1254 1
a1254 2
ieee_slurp_debug (abfd)
     bfd *abfd;
d1278 1
a1278 2
ieee_archive_p (abfd)
     bfd *abfd;
d1290 1
a1290 1
  abfd->tdata.ieee_ar_data = (ieee_ar_data_type *) bfd_alloc (abfd, amt);
d1297 1
a1297 1
  bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);
d1323 1
a1323 1
  elts = (ieee_ar_obstack_type *) bfd_malloc (alc_elts * sizeof *elts);
d1342 1
a1342 2
	  n = ((ieee_ar_obstack_type *)
	       bfd_realloc (elts, alc_elts * sizeof *elts));
d1364 1
a1364 1
	  bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);
d1372 1
a1372 1
  ieee->elements = (ieee_ar_obstack_type *) bfd_alloc (abfd, amt);
d1387 1
a1387 1
      bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);
d1419 1
a1419 2
ieee_object_p (abfd)
     bfd *abfd;
d1436 1
a1436 1
  bfd_bread ((PTR) buffer, (bfd_size_type) sizeof (buffer), abfd);
d1471 1
a1471 1
	if (processor[2] == '3')	    /* 683xx integrated processors */
d1478 1
a1478 1
		strcpy (family, "68000");   /* MC68000-based controllers */
d1495 1
a1495 1
	      default:			    /* Does not exist yet */
d1571 1
a1571 2
  IEEE_DATA (abfd)->h.first_byte =
    (unsigned char *) bfd_alloc (ieee->h.abfd, amt);
d1578 1
a1578 1
  bfd_bread ((PTR) (IEEE_DATA (abfd)->h.first_byte),
d1587 1
a1587 1
     section contents. */
d1601 3
a1603 4
ieee_get_symbol_info (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
d1613 4
a1616 5
ieee_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
     PTR afile;
     asymbol *symbol;
     bfd_print_symbol_type how;
d1636 1
a1636 3
	  {
	    fprintf (file, "* empty table entry ");
	  }
d1639 1
a1639 1
	    bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d1653 5
a1657 6
do_one (ieee, current_map, location_ptr, s, iterations)
     ieee_data_type *ieee;
     ieee_per_section_type *current_map;
     unsigned char *location_ptr;
     asection *s;
     int iterations;
d1698 1
a1698 1
		  r = (ieee_reloc_type *) bfd_alloc (ieee->h.abfd, amt);
d1826 1
d1830 1
d1838 1
a1838 3
		    {
		      loop = FALSE;
		    }
d1843 1
a1843 1
	       from being repeated (MRI convention). */
d1855 1
a1855 2
ieee_slurp_section_data (abfd)
     bfd *abfd;
d1860 1
a1860 2

  ieee_per_section_type *current_map = (ieee_per_section_type *) NULL;
d1862 1
d1873 1
d1876 1
a1876 1
      per->data = (bfd_byte *) bfd_alloc (ieee->h.abfd, s->size);
d1984 1
a1984 3
ieee_new_section_hook (abfd, newsect)
     bfd *abfd;
     asection *newsect;
d1986 1
a1986 2
  newsect->used_by_bfd
    = (PTR) bfd_alloc (abfd, (bfd_size_type) sizeof (ieee_per_section_type));
d1989 1
a1989 1
  ieee_per_section (newsect)->data = (bfd_byte *) NULL;
d1995 1
a1995 3
ieee_get_reloc_upper_bound (abfd, asect)
     bfd *abfd;
     sec_ptr asect;
d2005 5
a2009 6
ieee_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
d2016 1
a2016 1
  (void) memcpy ((PTR) location, (PTR) (p->data + offset), (unsigned) count);
d2021 4
a2024 5
ieee_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
d2057 1
a2057 1
  *relptr = (arelent *) NULL;
d2062 1
a2062 3
comp (ap, bp)
     const PTR ap;
     const PTR bp;
d2072 1
a2072 2
ieee_write_section_part (abfd)
     bfd *abfd;
d2076 1
a2157 1

d2159 1
a2159 3
do_with_relocs (abfd, s)
     bfd *abfd;
     asection *s;
d2213 1
a2213 1
	      if (bfd_bwrite ((PTR) (stream + current_byte_index), run, abfd)
d2228 1
a2228 2

      if ((PTR) stream == (PTR) NULL)
d2231 1
a2231 1
	  stream = (unsigned char *) bfd_zalloc (abfd, s->size);
d2257 1
a2257 1
	      if (bfd_bwrite ((PTR) (stream + current_byte_index), run, abfd)
a2273 1

a2303 2
/*		  abort();*/

d2348 1
a2348 3
do_as_repeat (abfd, s)
     bfd *abfd;
     asection *s;
d2386 1
a2386 3
do_without_relocs (abfd, s)
     bfd *abfd;
     asection *s;
d2427 1
a2427 2
ieee_mkobject (abfd)
     bfd *abfd;
d2441 1
a2441 1
  abfd->tdata.ieee_data = (ieee_data_type *) bfd_zalloc (abfd, amt);
d2446 1
a2446 1
fill ()
d2451 1
a2451 1
  bfd_bread ((PTR) input_ptr_start, amt, input_bfd);
d2456 1
a2456 1
flush ()
d2460 1
a2460 1
  if (bfd_bwrite ((PTR) (output_ptr_start), amt, output_bfd) != amt)
d2467 2
a2468 2
#define NEXT() { input_ptr++; if (input_ptr == input_ptr_end) fill(); }
#define OUT(x) { *output_ptr++ = (x); if(output_ptr == output_ptr_end)  flush(); }
d2471 1
a2471 2
write_int (value)
     int value;
d2480 1
d2623 1
a2623 1
   will overwrite later */
d3092 1
a3092 1
  bfd_bread ((PTR) input_ptr_start, (bfd_size_type) IBS, input);
d3179 1
a3179 1
	 places */
d3209 1
a3209 1
	  ieee_per_section (s)->data = (bfd_byte *) (bfd_alloc (abfd, size));
d3226 1
a3226 1
     const PTR location;
d3235 1
a3235 1
	  section->contents = (unsigned char *) bfd_alloc (abfd, size);
d3250 2
a3251 2
  memcpy ((PTR) (ieee_per_section (section)->data + offset),
	  (PTR) location,
d3313 3
a3315 3
		  || ! ieee_write_byte (abfd, 15) /* instruction address */
		  || ! ieee_write_byte (abfd, 19) /* static symbol */
		  || ! ieee_write_byte (abfd, 1)) /* one of them */
d3386 1
a3386 1
  0xf1, 0xce, 0x21, 00, 52, 0x00,	/* exec ok */
d3388 1
a3388 1
  0xf1, 0xce, 0x21, 0, 53, 0x03,/* host unix */
d3542 1
a3542 1
      if (! ieee_write_byte (abfd, 0x1)) /* Absolute */
d3547 1
a3547 1
      if (! ieee_write_byte (abfd, 0x2)) /* Relocateable */
d3616 1
a3616 1
/* Native-level interface to symbols. */
d3627 1
a3627 1
  ieee_symbol_type *new = (ieee_symbol_type *) bfd_zalloc (abfd, amt);
d3814 1
a3814 1
     ieee_get_section_contents, ieee_get_section_contents_in_window  */
d3824 1
a3824 1
     ieee_update_armap_timestamp  */
d3831 1
a3831 1
     ieee_read_minisymbols, ieee_minisymbol_to_symbol */
d3835 1
a3835 1
     ieee_bfd_reloc_type_lookup  */
d3838 1
a3838 1
  /* ieee_set_arch_mach, ieee_set_section_contents  */
d3846 1
a3846 1
     ieee_bfd_merge_sections  */
d3853 1
a3853 1
  (PTR) 0
@


1.42
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
@


1.41
log
@Implement a new BFD API function: bfd_is_target_special_symbol.  Use this in nm
and objdump to skip the displaying of ARM Mapping symbols unless specifically
requested.
@
text
@a1803 4
#if 0
      fprintf (file, "%4x %2x", aout_symbol (symbol)->desc & 0xffff,
	       aout_symbol (symbol)->other & 0xff);
#endif
a2314 5
#if 0
	  ieee_write_int (abfd, 0);	/* Parent */
	  ieee_write_int (abfd, 0);	/* Brother */
	  ieee_write_int (abfd, 0);	/* Context */
#endif
a2464 4
#if 0
		  if (r->howto->pc_relative)
		    r->addend += current_byte_index;
#endif
a3927 62

/* The debug info routines are never used.  */
#if 0

static void
ieee_bfd_debug_info_start (abfd)
     bfd *abfd;
{

}

static void
ieee_bfd_debug_info_end (abfd)
     bfd *abfd;
{

}


/* Add this section to the list of sections we have debug info for, to
   be ready to output it at close time.  */
static void
ieee_bfd_debug_info_accumulate (abfd, section)
     bfd *abfd;
     asection *section;
{
  ieee_data_type *ieee = IEEE_DATA (section->owner);
  ieee_data_type *output_ieee = IEEE_DATA (abfd);

  /* Can only accumulate data from other ieee bfds.  */
  if (section->owner->xvec != abfd->xvec)
    return;
  /* Only bother once per bfd.  */
  if (ieee->done_debug)
    return;
  ieee->done_debug = TRUE;

  /* Don't bother if there is no debug info.  */
  if (ieee->w.r.debug_information_part == 0)
    return;

  /* Add to chain.  */
  {
    bfd_size_type amt = sizeof (bfd_chain_type);
    bfd_chain_type *n = (bfd_chain_type *) bfd_alloc (abfd, amt);

    if (!n)
      abort ();		/* FIXME */
    n->this = section->owner;
    n->next = (bfd_chain_type *) NULL;

    if (output_ieee->chain_head)
      output_ieee->chain_head->next = n;
    else
      output_ieee->chain_root = n;

    output_ieee->chain_head = n;
  }
}

#endif

@


1.40
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d4021 2
@


1.39
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d938 2
a939 3
		      (_("%s: unimplemented ATI record %u for symbol %u"),
		       bfd_archive_filename (abfd), symbol_attribute_def,
		       symbol_name_index);
d962 2
a963 2
		      (_("%s: unexpected ATN type %d in external part"),
			 bfd_archive_filename (abfd), (int) value);
d984 1
a984 2
			  (_("%s: unexpected type after ATN"),
			     bfd_archive_filename (abfd));
@


1.38
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d4042 2
@


1.37
log
@	* section.c (bfd_make_section_anyway): Add all sections to hash tab.

	* elf-bfd.h (bfd_elf_is_group_section): Declare.
	* elf.c (bfd_elf_is_group_section): New function.
	* elfxx-target.h (bfd_elfNN_bfd_is_group_section
	* section.c (bfd_generic_is_group_section): New function.
	* targets.c (struct bfd_target): Add _bfd_is_group_section field.
	(BFD_JUMP_TABLE_LINK): Adjust.
	* aout-adobe.c (aout_32_bfd_is_group_section): Define.
	* aout-target.h (MY_bfd_is_group_section): Define.
	* aout-tic30.c (MY_bfd_is_group_section): Define.
	* bfd.c (bfd_is_group_section): Define.
	* binary.c (binary_bfd_is_group_section): Define.
	* bout.c (b_out_bfd_is_group_section): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-mips.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Adjust.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Adjust.
	* coffcode.h (coff_bfd_is_group_section): Define.
	* i386msdos.c (msdos_bfd_is_group_section): Define.
	* i386os9k.c (os9k_bfd_is_group_section): Define.
	* ieee.c (ieee_bfd_is_group_section): Define.
	* ihex.c (ihex_bfd_is_group_section): Define.
	* libbfd-in.h (_bfd_nolink_bfd_is_group_section): Define.
	* mach-o.c (bfd_mach_o_bfd_is_group_section): Define.
	* mmo.c (mmo_bfd_is_group_section): Define.
	* nlm-target.h (nlm_bfd_is_group_section): Define.
	* oasys.c (oasys_bfd_is_group_section): Define.
	* pef.c (bfd_pef_bfd_is_group_section): Define.
	* ppcboot.c (ppcboot_bfd_is_group_section): Define.
	* srec.c (srec_bfd_is_group_section): Define.
	* tekhex.c (tekhex_bfd_is_group_section): Define.
	* versados.c (versados_bfd_is_group_section): Define.
	* vms.c (vms_bfd_is_group_section): Define.
	* xsym.c (bfd_sym_bfd_is_group_section): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d707 1
a707 1
		ieee->section_table[must_parse_int (&(ieee->h))]->_raw_size);
d1024 1
a1024 1
		    if (val >= s->vma && val < s->vma + s->_raw_size)
d1381 1
a1381 1
		    section->_raw_size = must_parse_int (&(ieee->h));
d1385 1
a1385 1
		    section->_raw_size = must_parse_int (&(ieee->h));
d1444 1
a1444 1
  sec->_raw_size = debug_end - ieee->w.r.debug_information_part;
d2063 1
a2063 1
      per->data = (bfd_byte *) bfd_alloc (ieee->h.abfd, s->_raw_size);
d2109 1
a2109 1
		BFD_ASSERT ((unsigned) (value - s->vma) <= s->_raw_size);
d2339 1
a2339 1
	      || ! ieee_write_int (abfd, s->_raw_size))
d2401 1
a2401 1
      while (current_byte_index < s->_raw_size)
d2407 2
a2408 2
	  if (run > s->_raw_size - current_byte_index)
	    run = s->_raw_size - current_byte_index;
d2436 1
a2436 1
	  stream = (unsigned char *) bfd_zalloc (abfd, s->_raw_size);
d2440 1
a2440 1
      while (current_byte_index < s->_raw_size)
d2454 2
a2455 2
	  if (run > s->_raw_size - current_byte_index)
	    run = s->_raw_size - current_byte_index;
d2564 1
a2564 1
  if (s->_raw_size)
d2589 1
a2589 1
	  || ! ieee_write_int (abfd, s->_raw_size)
d2615 1
a2615 1
      for (i = 0; i < s->_raw_size; i++)
d3345 1
a3345 1
      if (bfd_bwrite (s->contents, s->_raw_size, abfd) != s->_raw_size)
d3423 1
a3423 1
      if (s->_raw_size != 0)
d3425 1
a3425 1
	  bfd_size_type size = s->_raw_size;
d3451 1
a3451 1
	  bfd_size_type size = section->_raw_size;
@


1.36
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d4040 1
@


1.36.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d707 1
a707 1
		ieee->section_table[must_parse_int (&(ieee->h))]->size);
d938 3
a940 2
		      (_("%B: unimplemented ATI record %u for symbol %u"),
		       abfd, symbol_attribute_def, symbol_name_index);
d963 2
a964 2
		      (_("%B: unexpected ATN type %d in external part"),
			 abfd, (int) value);
d985 2
a986 1
			  (_("%B: unexpected type after ATN"), abfd);
d1024 1
a1024 1
		    if (val >= s->vma && val < s->vma + s->size)
d1381 1
a1381 1
		    section->size = must_parse_int (&(ieee->h));
d1385 1
a1385 1
		    section->size = must_parse_int (&(ieee->h));
d1444 1
a1444 1
  sec->size = debug_end - ieee->w.r.debug_information_part;
d2063 1
a2063 1
      per->data = (bfd_byte *) bfd_alloc (ieee->h.abfd, s->size);
d2109 1
a2109 1
		BFD_ASSERT ((unsigned) (value - s->vma) <= s->size);
d2339 1
a2339 1
	      || ! ieee_write_int (abfd, s->size))
d2401 1
a2401 1
      while (current_byte_index < s->size)
d2407 2
a2408 2
	  if (run > s->size - current_byte_index)
	    run = s->size - current_byte_index;
d2436 1
a2436 1
	  stream = (unsigned char *) bfd_zalloc (abfd, s->size);
d2440 1
a2440 1
      while (current_byte_index < s->size)
d2454 2
a2455 2
	  if (run > s->size - current_byte_index)
	    run = s->size - current_byte_index;
d2564 1
a2564 1
  if (s->size)
d2589 1
a2589 1
	  || ! ieee_write_int (abfd, s->size)
d2615 1
a2615 1
      for (i = 0; i < s->size; i++)
d3345 1
a3345 1
      if (bfd_bwrite (s->contents, s->size, abfd) != s->size)
d3423 1
a3423 1
      if (s->size != 0)
d3425 1
a3425 1
	  bfd_size_type size = s->size;
d3451 1
a3451 1
	  bfd_size_type size = section->size;
a4039 1
#define ieee_bfd_is_group_section bfd_generic_is_group_section
a4040 2
#define ieee_section_already_linked \
  _bfd_generic_section_already_linked
@


1.35
log
@	* aout-adobe.c (aout_adobe_set_section_contents): Constify location.
	* aoutx.h (NAME(aout,set_section_contents)): Ditto.
	* bfd-in2.h: Regenerate.
	* binary.c (binary_set_section_contents): Ditto.
	* bout.c (b_out_set_section_contents): Ditto.
	* coff-tic54x.c (tic54x_set_section_contents): Ditto.
	* coffcode.h (coff_set_section_contents): Ditto.
	* ecoff.c (_bfd_ecoff_set_section_contents): Ditto.
	* elf-bfd.h (_bfd_elf_set_section_contents): Ditto.
	* elf.c (_bfd_elf_set_section_contents): Ditto.
	* elfxx-mips.c (_bfd_mips_elf_set_section_contents): Ditto.
	* elfxx-mips.h (_bfd_mips_elf_set_section_contents): Ditto.
	* i386msdos.c (msdos_set_section_contents): Ditto.
	* ieee.c (ieee_set_section_contents): Ditto.
	* ihex.c (ihex_set_section_contents): Ditto.
	* libaout.h (NAME(aout,set_section_contents)): Ditto.
	* libbfd-in.h (_bfd_nowrite_set_section_contents): Ditto.
	(_bfd_generic_set_section_contents): Ditto.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_generic_set_section_contents): Ditto.
	* libecoff.h (_bfd_ecoff_set_section_contents): Ditto.
	* libnlm.h (nlmNAME(set_section_contents)): Ditto.
	(struct nlm_backend_data <nlm_mangle_relocs>): Ditto.
	* mmo.c (mmo_set_section_contents): Ditto.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Ditto.
	* nlm32-i386.c (nlm_i386_mangle_relocs): Ditto.
	* nlm32-ppc.c (nlm_powerpc_mangle_relocs): Ditto.
	* nlm32-sparc.c (nlm_sparc_mangle_relocs): Ditto.
	* nlmcode.h (nlm_set_section_contents): Ditto.
	* oasys.c (oasys_set_section_contents): Ditto.
	* pdp11.c (NAME(aout,set_section_contents)): Ditto.
	* ppcboot.c (ppcboot_set_section_contents): Ditto.
	* srec.c (srec_set_section_contents): Ditto.
	* targets.c (BFD_JUMP_TABLE_WRITE <_bfd_set_section_contents>): Ditto.
	* tekhex.c (tekhex_set_section_contents): Ditto.
	(move_section_contents): Ditto.
	* versados.c (versados_set_section_contents): Ditto.
	* vms-misc.c (_bfd_save_vms_section): Ditto.
	* vms.c (vms_set_section_contents): Ditto.
	* vms.h (_bfd_save_vms_section): Ditto.
@
text
@d1046 1
a1046 1
	    /* Fetch the defautlt value if available.  */
d1642 1
a1642 1
    /* IEEE does not specify the format of the processor identificaton
@


1.34
log
@Add ColfFire v4 support
@
text
@d163 1
a163 1
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d3443 1
a3443 1
     PTR location;
@


1.33
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d3707 1
@


1.32
log
@Correct spelling of "relocatable".
@
text
@d83 1
a83 1
static long ieee_get_symtab
d1148 1
a1148 1
ieee_get_symtab (abfd, location)
d4100 5
a4104 4
  /* ieee_get_symtab_upper_bound, ieee_get_symtab, ieee_make_empty_symbol,
     ieee_print_symbol, ieee_get_symbol_info, ieee_bfd_is_local_label_name,
     ieee_get_lineno, ieee_find_nearest_line, ieee_bfd_make_debug_symbol,
     ieee_read_minisymbols, ieee_minisymbol_to_symbol  */
@


1.31
log
@(ieee_write_expression): Handle the case where symbol is NULL.
@
text
@d3593 1
a3593 1
  0xf1, 0xce, 0x20, 0x00, 38		/* Set object type relocateable to x.  */
@


1.30
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d228 2
a229 2
      /* How many significant bytes ? */
      /* FIXME FOR LONGER INTS */
d304 2
a305 4
/***************************************************************************
Functions for reading from ieee files in the strange way that the
standard requires:
*/
d317 1
d328 1
d330 1
a330 3
    {
      string[i] = this_byte_and_next (ieee);
    }
d339 1
d343 1
a343 1
      /* Simple string of length 0 to 127 */
d347 1
a347 1
      /* Length is next byte, allowing 0..255 */
d352 1
a352 1
      /* Length is next two bytes, allowing 0..65535 */
d356 2
a357 1
  /* Buy memory and read string */
d383 3
a385 10
  if (bfd_is_com_section (symbol->section)
      || bfd_is_und_section (symbol->section))
    {
      /* Def of a common symbol */
      if (! ieee_write_byte (abfd, ieee_variable_X_enum)
	  || ! ieee_write_int (abfd, symbol->value))
	return FALSE;
      term_count++;
    }
  else if (! bfd_is_abs_section (symbol->section))
d387 2
a388 3
      /* Ref to defined symbol - */

      if (symbol->flags & BSF_GLOBAL)
d390 2
a391 1
	  if (! ieee_write_byte (abfd, ieee_variable_I_enum)
d394 1
a394 1
	  term_count++;
d396 1
a396 1
      else if (symbol->flags & (BSF_LOCAL | BSF_SECTION_SYM))
d398 3
a400 9
	  /* This is a reference to a defined local symbol.  We can
	     easily do a local as a section+offset.  */
	  if (! ieee_write_byte (abfd, ieee_variable_R_enum)
	      || ! ieee_write_byte (abfd,
				    (bfd_byte) (symbol->section->index
						+ IEEE_SECTION_NUMBER_BASE)))
	    return FALSE;
	  term_count++;
	  if (symbol->value != 0)
d402 2
a403 1
	      if (! ieee_write_int (abfd, symbol->value))
d407 27
a433 9
	}
      else
	{
	  (*_bfd_error_handler)
	    (_("%s: unrecognized symbol `%s' flags 0x%x"),
	     bfd_get_filename (abfd), bfd_asymbol_name (symbol),
	     symbol->flags);
	  bfd_set_error (bfd_error_invalid_operation);
	  return FALSE;
d439 1
a439 1
      /* subtract the pc from here by asking for PC of this section*/
d449 2
a450 4
    {
      if (! ieee_write_int (abfd, (bfd_vma) 0))
	return FALSE;
    }
d462 1
a462 1
/*****************************************************************************/
a463 3
/*
writes any integer into the buffer supplied and always takes 5 bytes
*/
d496 1
d506 1
d670 1
a670 1
  /* The stack pointer always points to the next unused location */
d681 1
a681 1
	  /* P variable, current program counter for section n */
d684 1
d692 1
a692 1
	  /* L variable  address of section N */
d697 2
a698 2
	  /* R variable, logical address of section module */
	  /* FIXME, this should be different to L */
d703 1
a703 1
	  /* S variable, size in MAUS of section module */
d710 1
a710 1
	  /* Push the address of variable n */
d721 1
a721 1
	  /* Push the address of external variable n */
a782 1

d828 1
a828 1
static char last_type;		/* is the index for an X or a D */
d840 1
a840 1
  /* Need a new symbol */
d842 1
d858 2
a859 3
	{
	  *max_index = new_index;
	}
d947 1
a947 1
		/* Skip over ATX record. */
d956 1
a956 1
		   {$F1}${CE}{index}{$00}{$3F}{$3F}{#_of_ASNs} */
d1042 1
a1042 1
	    /* Throw away the external reference index */
d1044 1
a1044 1
	    /* Fetch the default size if not resolved */
d1046 1
a1046 1
	    /* Fetch the defautlt value if available */
d1051 1
a1051 1
	    /* This turns into a common */
d1142 2
a1143 4
/*
Move from our internal lists to the canon table, and insert in
symbol index order
*/
d1176 2
a1177 2
	  /* Arrgh - there are gaps in the table, run through and fill them */
	  /* up with pointers to a null place */
d1179 1
d1181 1
a1181 3
	    {
	      location[i] = &empty_symbol;
	    }
d1188 2
a1189 4
	{
	  /* Place into table at correct index locations */
	  location[symp->index + ieee->external_symbol_base_offset] = &symp->symbol;
	}
d1191 1
a1191 1
      /* The external refs are indexed in a bit */
d1198 3
a1200 3
	{
	  location[symp->index + ieee->external_reference_base_offset] =
	    &symp->symbol;
a1201 2
	}
    }
d1203 2
a1204 3
    {
      location[abfd->symcount] = (asymbol *) NULL;
    }
d1284 1
a1284 2
		   extended later, based on section contents. */

d1288 1
a1288 1
		    /* Normal attributes for absolute sections	*/
d1293 1
a1293 1
		      case 0xD3:	/* AS Absolute section attributes */
d1299 1
a1299 1
			    /* Normal code */
d1304 1
a1304 1
			    /* Normal data */
d1310 1
a1310 1
			    /* Normal rom data */
d1318 1
a1318 1
		  case 0xC3:	/* Named relocatable sections (type C) */
d1323 1
a1323 1
		      case 0xD0:	/* Normal code (CP) */
d1327 1
a1327 1
		      case 0xC4:	/* Normal data (CD) */
d1331 1
a1331 1
		      case 0xD2:	/* Normal rom data (CR) */
d1340 1
a1340 1
		/* Read section name, use it if non empty. */
d1345 1
a1345 1
		/* Skip these fields, which we don't care about */
d1449 1
a1449 3
/***********************************************************************
*  archive stuff
*/
d1635 3
a1637 5
    {
      abfd->filename = ieee->mb.module_name;
    }
  /* Determine the architecture and machine type of the object file.
     */
d1678 1
a1678 1
	else if ((TOUPPER (processor[3]) == 'C') /* Embedded controllers */
d1687 1
a1687 1
	else				 /* "Regular" processors */
d1709 2
a1710 3
    {
      goto fail;
    }
d1714 2
a1715 3
    {
      goto fail;
    }
d1717 1
a1717 3
    {
      goto fail;
    }
d1719 3
a1721 3
  /* If there is a byte order info, take it */
  if (this_byte (&(ieee->h)) == (int) ieee_variable_L_enum ||
      this_byte (&(ieee->h)) == (int) ieee_variable_M_enum)
d1727 1
d1729 2
a1730 3
	{
	  goto fail;
	}
d1732 1
a1732 3
	{
	  goto fail;
	}
d1736 1
a1736 4
	{
	  goto fail;
	}

d1745 1
a1745 1
     record */
a1765 1

d1818 1
d1852 1
d1867 1
d1909 1
a1909 1
		      /* Fetch number of bytes to pad */
d1927 1
a1927 1
		  /* Build a relocation entry for this type */
d2039 2
a2040 1
/* Read in all the section data and relocation stuff too */
d2051 1
a2051 1
  /* Seek to the start of the data area */
d2057 1
a2057 2
  /* Allocate enough space for all the section contents */

a2065 1
      /*SUPPRESS 68*/
d2074 1
a2074 1
	  /* IF we see anything strange then quit */
d2085 3
a2087 3
	  /* The document I have says that Microtec's compilers reset */
	  /* this after a sec section, even though the standard says not */
	  /* to. SO .. */
d2101 1
d2103 1
a2103 1
		must_parse_int (&(ieee->h));	/* Throw away section #*/
d2118 1
a2118 1
	      /* We've got to the end of the data now - */
d2128 3
a2130 5
		 remembering the stream pointer before running it and
		 resetting it and running it n times. We special case
		 the repetition of a repeat_data/load_constant
		 */

d2133 1
d2137 2
a2138 2
	    if (start[0] == (int) ieee_load_constant_bytes_enum &&
		start[1] == 1)
d2164 2
a2165 4
	  {
	    if (!do_one (ieee, current_map, location_ptr, s, 1))
	      return FALSE;
	  }
d2228 1
a2228 1
      /* Work out which symbol to attach it this reloc to */
d2287 1
a2287 1
	      /* This image is executable, so output absolute sections */
d2326 1
a2326 1
	  /* Alignment */
d2334 1
a2334 1
	  /* Size */
d2343 2
a2344 2
	      /* Relocateable sections don't have asl records */
	      /* Vma */
d2377 1
a2377 1
  /* Output the section preheader */
d2400 1
a2400 2
	 byte opcode rather than the load with relocation opcode */

d2405 1
d2408 1
a2408 3
	    {
	      run = s->_raw_size - current_byte_index;
	    }
d2414 1
a2414 1
	      /* Output a stream of bytes */
d2435 1
a2435 1
	  /* Outputting a section without data, fill it up */
d2444 1
d2452 2
a2453 3
	    {
	      run = MAXRUN;
	    }
d2455 1
a2455 3
	    {
	      run = s->_raw_size - current_byte_index;
	    }
d2459 1
a2459 1
	      /* Output a stream of bytes */
d2467 2
a2468 1
	  /* Output any relocations here */
a2475 1

d2478 1
a2478 3
		    {
		      r->addend += current_byte_index;
		    }
a2479 1

d2614 1
d2676 1
d2698 2
a2699 2
      /* How many significant bytes ? */
      /* FIXME FOR LONGER INTS */
d2701 1
a2701 3
	{
	  length = 4;
	}
d2703 1
a2703 3
	{
	  length = 3;
	}
d2705 1
a2705 3
	{
	  length = 2;
	}
a2720 1

d2729 1
d2747 1
d2795 1
a2795 1
	      /* Not a number, just bug out with the answer */
d2803 1
a2803 1
	  /* PLUS anything */
d2814 1
d2848 1
a2848 1
      /* Still a chance to output the size */
d2863 1
d2937 2
a2938 1
  /* ATN record */
d2978 1
a2978 1
      /* EXternal ref */
a3031 1

d3037 1
a3037 1
  /* Attribute record */
d3048 1
d3107 3
a3109 3
      /* Unique typedefs for module */
      /* GLobal typedefs  */
      /* High level module scope beginning */
d3112 1
d3127 1
a3127 1
      /* Global function */
d3130 1
d3150 1
a3150 1
      /* File name for source line numbers */
d3153 1
d3173 1
a3173 1
      /* Local function */
d3176 1
d3194 1
a3194 1
      /* Assembler module scope beginning -*/
d3223 1
d3260 1
d3292 2
a3293 5

/* relocate_debug,
   moves all the debug information from the source bfd to the output
   bfd, and relocates any expressions it finds
*/
d3354 1
d3365 1
d3367 1
a3367 3
	{
	  ieee->w.r.debug_information_part = here;
	}
d3369 1
a3369 3
	{
	  ieee->w.r.debug_information_part = 0;
	}
d3384 1
d3387 1
d3418 1
d3434 4
a3437 1
/** exec and core file sections */
a3438 3
/* set section contents is complicated with IEEE since the format is
* not a byte image, but a record stream.
*/
a3483 1

d3488 1
d3495 1
d3498 1
a3498 1
	      /* This must be a symbol reference .. */
d3509 1
a3509 1
	      /* This is a weak reference */
d3524 1
a3524 2
	      /* This must be a symbol definition */

d3535 1
a3535 1
	      /* Write out the value */
d3544 1
a3544 1
			 relocated */
d3576 2
a3577 2
	      /* This can happen - when there are gaps in the symbols read */
	      /* from an input ieee file */
d3591 3
a3593 3
  0xf1, 0xce, 0x20, 0x00, 37, 3, 3,	/* Set version 3 rev 3   	*/
  0xf1, 0xce, 0x20, 0x00, 39, 2,/* keep symbol in  original case */
  0xf1, 0xce, 0x20, 0x00, 38	/* set object type relocateable to x */
d3726 1
a3726 1
  /* Fast forward over the header area */
d3735 1
a3735 1
  /* Fast forward over the variable bits */
d3739 1
a3739 1
  /* Bits per MAU */
d3742 1
a3742 1
  /* MAU's per address */
a3802 5
  /*  ieee_write_byte(abfd, ieee_record_seperator_enum);*/

  /*  ieee_write_byte(abfd, ieee_record_seperator_enum);*/


d3817 1
a3817 1
  /* Generate the header */
d3836 1
a3836 1
   hold them all plus all the cached symbol entries. */
d3844 1
d3857 2
a3858 1
  /* take the next one from the arch state, or reset */
d3860 3
a3862 4
    {
      /* Reset the index - the first two entries are bogus*/
      ar->element_index = 2;
    }
d3866 1
a3884 1

d3962 1
a3962 2
   be ready to output it at close time
   */
d3970 2
a3971 1
  /* can only accumulate data from other ieee bfds */
d3974 1
a3974 1
  /* Only bother once per bfd */
d3979 1
a3979 1
  /* Don't bother if there is no debug info */
d3983 1
a3983 2

  /* Add to chain */
d3987 1
d3994 1
a3994 3
      {
	output_ieee->chain_head->next = n;
      }
d3996 1
a3996 2
      {
	output_ieee->chain_root = n;
a3997 1
      }
a4046 1
/*SUPPRESS 460 */
@


1.30.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d228 2
a229 2
      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
d304 4
a307 2
/* Functions for reading from ieee files in the strange way that the
   standard requires.  */
a318 1

a328 1

d330 3
a332 1
    string[i] = this_byte_and_next (ieee);
a340 1

d344 1
a344 1
      /* Simple string of length 0 to 127.  */
d348 1
a348 1
      /* Length is next byte, allowing 0..255.  */
d353 1
a353 1
      /* Length is next two bytes, allowing 0..65535.  */
d357 1
a357 2

  /* Buy memory and read string.  */
d383 10
a392 3
  /* Badly formatted binaries can have a missing symbol,
     so test here to prevent a seg fault.  */
  if (symbol != NULL)
d394 3
a396 2
      if (bfd_is_com_section (symbol->section)
	  || bfd_is_und_section (symbol->section))
d398 1
a398 2
	  /* Def of a common symbol.  */
	  if (! ieee_write_byte (abfd, ieee_variable_X_enum)
d401 1
a401 1
	  term_count ++;
d403 1
a403 1
      else if (! bfd_is_abs_section (symbol->section))
d405 9
a413 3
	  /* Ref to defined symbol -  */

	  if (symbol->flags & BSF_GLOBAL)
d415 1
a415 2
	      if (! ieee_write_byte (abfd, ieee_variable_I_enum)
		  || ! ieee_write_int (abfd, symbol->value))
d419 9
a427 27
	  else if (symbol->flags & (BSF_LOCAL | BSF_SECTION_SYM))
	    {
	      /* This is a reference to a defined local symbol.  We can
		 easily do a local as a section+offset.  */
	      if (! ieee_write_byte (abfd, ieee_variable_R_enum)
		  || ! ieee_write_byte (abfd,
					(bfd_byte) (symbol->section->index
						    + IEEE_SECTION_NUMBER_BASE)))
		return FALSE;

	      term_count++;
	      if (symbol->value != 0)
		{
		  if (! ieee_write_int (abfd, symbol->value))
		    return FALSE;
		  term_count++;
		}
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: unrecognized symbol `%s' flags 0x%x"),
		 bfd_get_filename (abfd), bfd_asymbol_name (symbol),
		 symbol->flags);
	      bfd_set_error (bfd_error_invalid_operation);
	      return FALSE;
	    }
d433 1
a433 1
      /* Subtract the pc from here by asking for PC of this section.  */
d443 4
a446 2
    if (! ieee_write_int (abfd, (bfd_vma) 0))
      return FALSE;
d458 1
a458 1
/* Writes any integer into the buffer supplied and always takes 5 bytes.  */
d460 3
a494 1

a503 1

d667 1
a667 1
  /* The stack pointer always points to the next unused location.  */
d678 1
a678 1
	  /* P variable, current program counter for section n.  */
a680 1

d688 1
a688 1
	  /* L variable  address of section N.  */
d693 2
a694 2
	  /* R variable, logical address of section module.  */
	  /* FIXME, this should be different to L.  */
d699 1
a699 1
	  /* S variable, size in MAUS of section module.  */
d706 1
a706 1
	  /* Push the address of variable n.  */
d717 1
a717 1
	  /* Push the address of external variable n.  */
d779 1
d825 1
a825 1
static char last_type;		/* Is the index for an X or a D.  */
d837 1
a837 1
  /* Need a new symbol.  */
a838 1

d854 3
a856 2
	*max_index = new_index;

d944 1
a944 1
		/* Skip over ATX record.  */
d953 1
a953 1
		   {$F1}${CE}{index}{$00}{$3F}{$3F}{#_of_ASNs}.  */
d1039 1
a1039 1
	    /* Throw away the external reference index.  */
d1041 1
a1041 1
	    /* Fetch the default size if not resolved.  */
d1043 1
a1043 1
	    /* Fetch the defautlt value if available.  */
d1048 1
a1048 1
	    /* This turns into a common.  */
d1139 4
a1142 2
/* Move from our internal lists to the canon table, and insert in
   symbol index order.  */
d1175 2
a1176 2
	  /* Arrgh - there are gaps in the table, run through and fill them
	     up with pointers to a null place.  */
a1177 1

d1179 3
a1181 1
	    location[i] = &empty_symbol;
d1188 4
a1191 2
	/* Place into table at correct index locations.  */
	location[symp->index + ieee->external_symbol_base_offset] = &symp->symbol;
d1193 1
a1193 1
      /* The external refs are indexed in a bit.  */
d1200 5
a1204 2
	location[symp->index + ieee->external_reference_base_offset] =
	  &symp->symbol;
a1205 1

d1207 3
a1209 2
    location[abfd->symcount] = (asymbol *) NULL;

d1289 2
a1290 1
		   extended later, based on section contents.  */
d1294 1
a1294 1
		    /* Normal attributes for absolute sections.  */
d1299 1
a1299 1
		      case 0xD3:	/* AS Absolute section attributes.  */
d1305 1
a1305 1
			    /* Normal code.  */
d1310 1
a1310 1
			    /* Normal data.  */
d1316 1
a1316 1
			    /* Normal rom data.  */
d1324 1
a1324 1
		  case 0xC3:	/* Named relocatable sections (type C).  */
d1329 1
a1329 1
		      case 0xD0:	/* Normal code (CP).  */
d1333 1
a1333 1
		      case 0xC4:	/* Normal data (CD).  */
d1337 1
a1337 1
		      case 0xD2:	/* Normal rom data (CR).  */
d1346 1
a1346 1
		/* Read section name, use it if non empty.  */
d1351 1
a1351 1
		/* Skip these fields, which we don't care about.  */
d1455 3
a1457 1
/* Archive stuff.  */
d1643 5
a1647 3
    abfd->filename = ieee->mb.module_name;

  /* Determine the architecture and machine type of the object file.  */
d1688 1
a1688 1
	else if ((TOUPPER (processor[3]) == 'C') /* Embedded controllers.  */
d1697 1
a1697 1
	else				 /* "Regular" processors.  */
d1719 3
a1721 2
    goto fail;

d1725 3
a1727 2
    goto fail;

d1729 3
a1731 1
    goto fail;
d1733 3
a1735 3
  /* If there is a byte order info, take it.  */
  if (this_byte (&(ieee->h)) == (int) ieee_variable_L_enum
      || this_byte (&(ieee->h)) == (int) ieee_variable_M_enum)
a1740 1

d1742 3
a1744 2
	goto fail;

d1746 3
a1748 1
	goto fail;
d1752 4
a1755 1
	goto fail;
d1764 1
a1764 1
     record.  */
d1785 1
a1837 1

a1870 1

a1884 1

d1926 1
a1926 1
		      /* Fetch number of bytes to pad.  */
d1944 1
a1944 1
		  /* Build a relocation entry for this type.  */
d2056 1
a2056 2
/* Read in all the section data and relocation stuff too.  */

d2067 1
a2067 1
  /* Seek to the start of the data area.  */
d2073 2
a2074 1
  /* Allocate enough space for all the section contents.  */
d2083 1
d2092 1
a2092 1
	  /* IF we see anything strange then quit.  */
d2103 3
a2105 3
	  /* The document I have says that Microtec's compilers reset
	     this after a sec section, even though the standard says not
	     to, SO...  */
a2118 1

d2120 1
a2120 1
		must_parse_int (&(ieee->h));	/* Throw away section #.  */
d2135 1
a2135 1
	      /* We've got to the end of the data now -  */
d2145 5
a2149 3
	       remembering the stream pointer before running it and
	       resetting it and running it n times. We special case
	       the repetition of a repeat_data/load_constant.  */
a2151 1

d2155 2
a2156 2
	    if (start[0] == (int) ieee_load_constant_bytes_enum
		&& start[1] == 1)
d2182 4
a2185 2
	  if (!do_one (ieee, current_map, location_ptr, s, 1))
	    return FALSE;
d2248 1
a2248 1
      /* Work out which symbol to attach it this reloc to.  */
d2307 1
a2307 1
	      /* This image is executable, so output absolute sections.  */
d2346 1
a2346 1
	  /* Alignment.  */
d2354 1
a2354 1
	  /* Size.  */
d2363 2
a2364 2
	      /* Relocateable sections don't have asl records.  */
	      /* Vma.  */
d2397 1
a2397 1
  /* Output the section preheader.  */
d2420 2
a2421 1
	 byte opcode rather than the load with relocation opcode.  */
a2425 1

d2428 3
a2430 1
	    run = s->_raw_size - current_byte_index;
d2436 1
a2436 1
	      /* Output a stream of bytes.  */
d2457 1
a2457 1
	  /* Outputting a section without data, fill it up.  */
a2465 1

d2473 3
a2475 2
	    run = MAXRUN;

d2477 3
a2479 1
	    run = s->_raw_size - current_byte_index;
d2483 1
a2483 1
	      /* Output a stream of bytes.  */
d2491 1
a2491 2

	  /* Output any relocations here.  */
d2499 1
d2502 3
a2504 1
		    r->addend += current_byte_index;
d2506 1
a2640 1

a2701 1

d2723 2
a2724 2
      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
d2726 3
a2728 1
	length = 4;
d2730 3
a2732 1
	length = 3;
d2734 3
a2736 1
	length = 2;
d2752 1
a2760 1

a2777 1

d2825 1
a2825 1
	      /* Not a number, just bug out with the answer.  */
d2833 1
a2833 1
	  /* PLUS anything.  */
a2843 1

d2877 1
a2877 1
      /* Still a chance to output the size.  */
a2891 1

d2965 1
a2965 2

  /* ATN record.  */
d3005 1
a3005 1
      /* EXternal ref.  */
d3059 1
d3065 1
a3065 1
  /* Attribute record.  */
a3075 1

d3134 3
a3136 3
      /* Unique typedefs for module.  */
      /* GLobal typedefs.   */
      /* High level module scope beginning.  */
a3138 1

d3153 1
a3153 1
      /* Global function.  */
a3155 1

d3175 1
a3175 1
      /* File name for source line numbers.  */
a3177 1

d3197 1
a3197 1
      /* Local function.  */
a3199 1

d3217 1
a3217 1
      /* Assembler module scope beginning -  */
a3245 1

a3281 1

d3313 5
a3317 2
/* Moves all the debug information from the source bfd to the output
   bfd, and relocates any expressions it finds.  */
a3377 1

a3387 1

d3389 3
a3391 1
	ieee->w.r.debug_information_part = here;
d3393 3
a3395 1
	ieee->w.r.debug_information_part = 0;
a3409 1

a3411 1

a3441 1

d3457 1
a3457 4
/* Exec and core file sections.  */

/* Set section contents is complicated with IEEE since the format is
   not a byte image, but a record stream.  */
d3459 3
d3507 1
a3511 1

a3517 1

d3520 1
a3520 1
	      /* This must be a symbol reference.  */
d3531 1
a3531 1
	      /* This is a weak reference.  */
d3546 2
a3547 1
	      /* This must be a symbol definition.  */
d3558 1
a3558 1
	      /* Write out the value.  */
d3567 1
a3567 1
			 relocated.  */
d3599 2
a3600 2
	      /* This can happen - when there are gaps in the symbols read
	         from an input ieee file.  */
d3614 3
a3616 3
  0xf1, 0xce, 0x20, 0x00, 37, 3, 3,	/* Set version 3 rev 3.  */
  0xf1, 0xce, 0x20, 0x00, 39, 2,	/* Keep symbol in  original case.  */
  0xf1, 0xce, 0x20, 0x00, 38		/* Set object type relocateable to x.  */
d3749 1
a3749 1
  /* Fast forward over the header area.  */
d3758 1
a3758 1
  /* Fast forward over the variable bits.  */
d3762 1
a3762 1
  /* Bits per MAU.  */
d3765 1
a3765 1
  /* MAU's per address.  */
d3826 5
d3845 1
a3845 1
  /* Generate the header.  */
d3864 1
a3864 1
   hold them all plus all the cached symbol entries.  */
a3871 1

d3884 1
a3884 2

  /* Take the next one from the arch state, or reset.  */
d3886 4
a3889 3
    /* Reset the index - the first two entries are bogus.  */
    ar->element_index = 2;

a3892 1

d3911 1
d3989 2
a3990 1
   be ready to output it at close time.  */
d3998 1
a3998 2

  /* Can only accumulate data from other ieee bfds.  */
d4001 1
a4001 1
  /* Only bother once per bfd.  */
d4006 1
a4006 1
  /* Don't bother if there is no debug info.  */
d4010 2
a4011 1
  /* Add to chain.  */
a4014 1

d4021 3
a4023 1
      output_ieee->chain_head->next = n;
d4025 2
a4026 1
      output_ieee->chain_root = n;
d4028 1
d4078 1
@


1.29
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d2077 1
a2077 1
      ieee_per_section_type *per = (ieee_per_section_type *) s->used_by_bfd;
d2101 1
a2101 1
	  current_map = (ieee_per_section_type *) s->used_by_bfd;
d2195 2
a2196 2
  newsect->used_by_bfd = (PTR)
    bfd_alloc (abfd, (bfd_size_type) sizeof (ieee_per_section_type));
d2224 1
a2224 1
  ieee_per_section_type *p = (ieee_per_section_type *) section->used_by_bfd;
a2239 1
/*  ieee_per_section_type *p = (ieee_per_section_type *) section->used_by_bfd;*/
@


1.28
log
@	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.
@
text
@d43 26
a68 14
static boolean ieee_write_byte PARAMS ((bfd *, int));
static boolean ieee_write_2bytes PARAMS ((bfd *, int));
static boolean ieee_write_int PARAMS ((bfd *, bfd_vma));
static boolean ieee_write_id PARAMS ((bfd *, const char *));
static unsigned short read_2bytes PARAMS ((common_header_type *));
static void bfd_get_string PARAMS ((common_header_type *, char *, size_t));
static char *read_id PARAMS ((common_header_type *));
static boolean ieee_write_expression
  PARAMS ((bfd *, bfd_vma, asymbol *, boolean, unsigned int));
static void ieee_write_int5 PARAMS ((bfd_byte *, bfd_vma));
static boolean ieee_write_int5_out PARAMS ((bfd *, bfd_vma));
static boolean parse_int PARAMS ((common_header_type *, bfd_vma *));
static int parse_i PARAMS ((common_header_type *, boolean *));
static bfd_vma must_parse_int PARAMS ((common_header_type *));
d71 3
a73 2
	   boolean *, unsigned int *, asection **));
static file_ptr ieee_part_after PARAMS ((ieee_data_type *, file_ptr));
d77 8
a84 4
static boolean ieee_slurp_external_symbols PARAMS ((bfd *));
static boolean ieee_slurp_symbol_table PARAMS ((bfd *));
static long ieee_get_symtab_upper_bound PARAMS ((bfd *));
static long ieee_get_symtab PARAMS ((bfd *, asymbol **));
d87 10
a96 5
static void ieee_slurp_sections PARAMS ((bfd *));
static boolean ieee_slurp_debug PARAMS ((bfd *));
const bfd_target *ieee_archive_p PARAMS ((bfd *));
const bfd_target *ieee_object_p PARAMS ((bfd *));
static void ieee_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
d99 1
a99 1
static boolean do_one
d102 7
a108 4
static boolean ieee_slurp_section_data PARAMS ((bfd *));
static boolean ieee_new_section_hook PARAMS ((bfd *, asection *));
static long ieee_get_reloc_upper_bound PARAMS ((bfd *, sec_ptr));
static boolean ieee_get_section_contents
d112 51
a162 26
static int comp PARAMS ((const PTR, const PTR));
static boolean ieee_write_section_part PARAMS ((bfd *));
static boolean do_with_relocs PARAMS ((bfd *, asection *));
static boolean do_as_repeat PARAMS ((bfd *, asection *));
static boolean do_without_relocs PARAMS ((bfd *, asection *));
static boolean ieee_mkobject PARAMS ((bfd *));
static void fill PARAMS ((void));
static void flush PARAMS ((void));
static void write_int PARAMS ((int));
static void copy_id PARAMS ((void));
static void copy_expression PARAMS ((void));
static void fill_int PARAMS ((struct output_buffer_struct *));
static void drop_int PARAMS ((struct output_buffer_struct *));
static void copy_int PARAMS ((void));
static void f1_record PARAMS ((void));
static void f0_record PARAMS ((void));
static void copy_till_end PARAMS ((void));
static void f2_record PARAMS ((void));
static void f8_record PARAMS ((void));
static void e2_record PARAMS ((void));
static void block PARAMS ((void));
static void relocate_debug PARAMS ((bfd *, bfd *));
static boolean ieee_write_debug_part PARAMS ((bfd *));
static boolean ieee_write_data_part PARAMS ((bfd *));
static boolean init_for_output PARAMS ((bfd *));
static boolean ieee_set_section_contents
d164 13
a176 7
static boolean ieee_write_external_part PARAMS ((bfd *));
static boolean ieee_write_me_part PARAMS ((bfd *));
static boolean ieee_write_processor PARAMS ((bfd *));
static boolean ieee_write_object_contents PARAMS ((bfd *));
static asymbol *ieee_make_empty_symbol PARAMS ((bfd *));
static bfd *ieee_openr_next_archived_file PARAMS ((bfd *, bfd *));
static boolean ieee_find_nearest_line
d179 4
a182 2
static int ieee_generic_stat_arch_elt PARAMS ((bfd *, struct stat *));
static int ieee_sizeof_headers PARAMS ((bfd *, boolean));
d187 1
a187 1
static boolean
d196 2
a197 2
    return false;
  return true;
d200 1
a200 1
static boolean
d210 2
a211 2
    return false;
  return true;
d214 1
a214 1
static boolean
d222 1
a222 1
	return false;
d242 1
a242 1
	return false;
d247 1
a247 1
	    return false;
d251 1
a251 1
	    return false;
d255 1
a255 1
	    return false;
d259 1
a259 1
	    return false;
d263 1
a263 1
  return true;
d266 1
a266 1
static boolean
d276 1
a276 1
	return false;
d282 1
a282 1
	return false;
d288 1
a288 1
	return false;
d296 1
a296 1
      return false;
d300 2
a301 2
    return false;
  return true;
d366 1
a366 1
static boolean
d371 1
a371 1
     boolean pcrel;
d379 1
a379 1
	return false;
d389 1
a389 1
	return false;
d400 1
a400 1
	    return false;
d411 1
a411 1
	    return false;
d416 1
a416 1
		return false;
d427 1
a427 1
	  return false;
d438 1
a438 1
	return false;
d445 1
a445 1
	return false;
d451 1
a451 1
	return false;
d455 1
a455 1
  return true;
d475 1
a475 1
static boolean
d484 2
a485 2
    return false;
  return true;
d488 1
a488 1
static boolean
d499 1
a499 1
      return true;
d512 1
a512 1
      return true;
d514 1
a514 1
  return false;
d520 1
a520 1
     boolean *ok;
d547 1
a547 1
#define PCREL_OFFSET false
d552 1
a552 1
#define PCREL_OFFSET true
d561 1
a561 1
	 false,
d566 1
a566 1
	 true,
d569 1
a569 1
	 false);
d576 1
a576 1
	 false,
d581 1
a581 1
	 true,
d584 1
a584 1
	 false);
d591 1
a591 1
	 false,
d596 1
a596 1
	 true,
d599 1
a599 1
	 false);
d606 1
a606 1
	 true,
d611 1
a611 1
	 true,
d621 1
a621 1
	 true,
d626 1
a626 1
	 true,
d636 1
a636 1
	 true,
d641 1
a641 1
	 true,
d653 1
a653 1
     boolean *pcrel;
d664 1
a664 1
  boolean loop = true;
d682 1
a682 1
	    *pcrel = true;
d767 1
a767 1
		loop = false;
d864 1
a864 1
static boolean
d875 1
a875 1
  boolean loop = true;
d877 1
a877 1
  ieee->symbol_table_full = true;
d892 1
a892 1
	    return false;
d906 1
a906 1
	    return false;
d939 1
a939 1
		    return false;
d963 1
a963 1
		    return false;
d985 1
a985 1
			return false;
d995 1
a995 1
	    boolean pcrel_ignore;
d1061 1
a1061 1
	    return false;
d1074 1
a1074 1
	  loop = false;
d1106 1
a1106 1
      ieee->symbol_table_full = false;
d1112 1
a1112 1
  return true;
d1115 1
a1115 1
static boolean
d1122 2
a1123 2
	return false;
      IEEE_DATA (abfd)->read_symbols = true;
d1125 1
a1125 1
  return true;
d1273 1
a1273 1
      while (true)
d1432 1
a1432 1
static boolean
d1441 1
a1441 1
    return true;
d1445 1
a1445 1
    return false;
d1452 1
a1452 1
  return true;
d1627 2
a1628 2
  ieee->read_symbols = false;
  ieee->read_data = false;
d1740 1
a1740 1
      boolean ok;
d1857 1
a1857 1
static boolean
d1884 1
a1884 1
	boolean loop = true;
d1897 1
a1897 1
		  boolean pcrel = false;
d1904 1
a1904 1
		    return false;
d2023 1
a2023 1
		      return false;
d2041 1
a2041 1
		      loop = false;
d2049 1
a2049 1
	      loop = false;
d2053 1
a2053 1
  return true;
d2057 1
a2057 1
static boolean
d2069 2
a2070 2
    return true;
  ieee->read_data = true;
d2082 1
a2082 1
	return false;
d2088 1
a2088 1
  while (true)
d2094 1
a2094 1
	  return true;
d2118 1
a2118 1
		boolean pcrel;
d2136 1
a2136 1
	      return true;
d2139 1
a2139 1
	      return false;
d2174 1
a2174 1
		      return false;
d2184 1
a2184 1
	      return false;
d2190 1
a2190 1
static boolean
d2198 1
a2198 1
    return false;
d2201 1
a2201 1
  return true;
d2216 1
a2216 1
static boolean
d2230 1
a2230 1
  return true;
d2288 1
a2288 1
static boolean
d2304 1
a2304 1
	    return false;
d2311 1
a2311 1
		return false;
d2316 1
a2316 1
		return false;
d2324 1
a2324 1
		return false;
d2329 1
a2329 1
		return false;
d2336 1
a2336 1
		return false;
d2341 1
a2341 1
	    return false;
d2353 1
a2353 1
	    return false;
d2361 1
a2361 1
	    return false;
d2372 1
a2372 1
		return false;
d2377 1
a2377 1
  return true;
d2381 1
a2381 1
static boolean
d2405 1
a2405 1
    return false;
d2410 1
a2410 1
	return false;
d2415 1
a2415 1
	return false;
d2436 1
a2436 1
		return false;
d2439 1
a2439 1
		return false;
d2442 1
a2442 1
		return false;
d2450 1
a2450 1
	return false;
d2461 1
a2461 1
	    return false;
d2486 1
a2486 1
		return false;
d2489 1
a2489 1
		return false;
d2529 1
a2529 1
		      return false;
d2540 1
a2540 1
		    return false;
d2550 1
a2550 1
			return false;
d2558 1
a2558 1
			return false;
d2566 1
a2566 1
			return false;
d2570 1
a2570 1
		    return false;
d2580 1
a2580 1
  return true;
d2587 1
a2587 1
static boolean
d2603 1
a2603 1
	return false;
d2608 1
a2608 1
	    return false;
d2613 1
a2613 1
	    return false;
d2621 1
a2621 1
	return false;
d2624 1
a2624 1
  return true;
d2627 1
a2627 1
static boolean
d2637 1
a2637 1
	return false;
d2647 2
a2648 2
		return false;
	      return true;
d2652 1
a2652 1
	return false;
d2655 1
a2655 1
  return true;
d2669 1
a2669 1
static boolean
d3341 1
a3341 1
static boolean
d3348 1
a3348 1
  boolean some_debug = false;
d3366 1
a3366 1
	  return true;
d3371 1
a3371 1
	return false;
d3383 1
a3383 1
		return false;
d3401 1
a3401 1
  return true;
d3406 1
a3406 1
static boolean
d3425 1
a3425 1
	    return false;
d3430 1
a3430 1
	    return false;
d3434 1
a3434 1
  return true;
d3438 1
a3438 1
static boolean
d3452 1
a3452 1
	    return false;
d3455 1
a3455 1
  return true;
d3463 1
a3463 1
static boolean
d3478 1
a3478 1
	    return false;
d3483 1
a3483 1
      return true;
d3489 1
a3489 1
	return false;
d3494 1
a3494 1
  return true;
d3502 1
a3502 1
static boolean
d3512 1
a3512 1
  boolean hadone = false;
d3525 1
a3525 1
		return false;
d3528 1
a3528 1
	      hadone = true;
d3540 1
a3540 1
		return false;
d3543 1
a3543 1
	      hadone = true;
d3557 1
a3557 1
		return false;
d3562 1
a3562 1
		return false;
d3574 1
a3574 1
			return false;
d3582 2
a3583 2
			      false, 0)))
			return false;
d3591 2
a3592 2
					       false, 0))
		    return false;
d3596 1
a3596 1
	      hadone = true;
d3608 1
a3608 1
  return true;
d3633 1
a3633 1
static boolean
d3645 1
a3645 1
	return false;
d3649 2
a3650 2
    return false;
  return true;
d3655 1
a3655 1
static boolean
d3666 1
a3666 1
	return false;
d3671 1
a3671 1
	return false;
d3676 1
a3676 1
	return false;
d3681 1
a3681 1
	return false;
d3691 1
a3691 1
	    return false;
d3696 1
a3696 1
	    return false;
d3701 1
a3701 1
	    return false;
d3707 1
a3707 1
	    return false;
d3734 1
a3734 1
	  return false;
d3739 1
a3739 1
  return true;
d3742 1
a3742 1
static boolean
d3752 1
a3752 1
    return false;
d3757 1
a3757 1
    return false;
d3761 1
a3761 1
    return false;
d3765 1
a3765 1
    return false;
d3770 1
a3770 1
    return false;
d3774 1
a3774 1
    return false;
d3779 1
a3779 1
    return false;
d3783 1
a3783 1
	return false;
d3788 1
a3788 1
	return false;
d3794 1
a3794 1
    return false;
d3813 1
a3813 1
      return false;
d3821 1
a3821 1
    return false;
d3825 1
a3825 1
    return false;
d3834 1
a3834 1
    return false;
d3840 1
a3840 1
    return false;
d3844 1
a3844 1
    return false;
d3848 1
a3848 1
    return false;
d3855 1
a3855 1
	return false;
d3858 1
a3858 1
  return true;
d3891 1
a3891 1
  while (true)
d3916 1
a3916 1
static boolean
d3927 1
a3927 1
  return false;
d3965 1
a3965 1
     boolean x ATTRIBUTE_UNUSED;
d4005 1
a4005 1
  ieee->done_debug = true;
d4042 2
a4043 1
  ((boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
d4047 1
a4047 1
  ((boolean (*) \
@


1.28.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d43 14
a56 26
static bfd_boolean ieee_write_byte
  PARAMS ((bfd *, int));
static bfd_boolean ieee_write_2bytes
  PARAMS ((bfd *, int));
static bfd_boolean ieee_write_int
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean ieee_write_id
  PARAMS ((bfd *, const char *));
static unsigned short read_2bytes
  PARAMS ((common_header_type *));
static void bfd_get_string
  PARAMS ((common_header_type *, char *, size_t));
static char *read_id
  PARAMS ((common_header_type *));
static bfd_boolean ieee_write_expression
  PARAMS ((bfd *, bfd_vma, asymbol *, bfd_boolean, unsigned int));
static void ieee_write_int5
  PARAMS ((bfd_byte *, bfd_vma));
static bfd_boolean ieee_write_int5_out
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean parse_int
  PARAMS ((common_header_type *, bfd_vma *));
static int parse_i
  PARAMS ((common_header_type *, bfd_boolean *));
static bfd_vma must_parse_int
  PARAMS ((common_header_type *));
d59 2
a60 3
	   bfd_boolean *, unsigned int *, asection **));
static file_ptr ieee_part_after
  PARAMS ((ieee_data_type *, file_ptr));
d64 4
a67 8
static bfd_boolean ieee_slurp_external_symbols
  PARAMS ((bfd *));
static bfd_boolean ieee_slurp_symbol_table
  PARAMS ((bfd *));
static long ieee_get_symtab_upper_bound
  PARAMS ((bfd *));
static long ieee_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
d70 5
a74 10
static void ieee_slurp_sections
  PARAMS ((bfd *));
static bfd_boolean ieee_slurp_debug
  PARAMS ((bfd *));
const bfd_target *ieee_archive_p
  PARAMS ((bfd *));
const bfd_target *ieee_object_p
  PARAMS ((bfd *));
static void ieee_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
d77 1
a77 1
static bfd_boolean do_one
d80 4
a83 7
static bfd_boolean ieee_slurp_section_data
  PARAMS ((bfd *));
static bfd_boolean ieee_new_section_hook
  PARAMS ((bfd *, asection *));
static long ieee_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static bfd_boolean ieee_get_section_contents
d87 34
a120 65
static int comp
  PARAMS ((const PTR, const PTR));
static bfd_boolean ieee_write_section_part
  PARAMS ((bfd *));
static bfd_boolean do_with_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean do_as_repeat
  PARAMS ((bfd *, asection *));
static bfd_boolean do_without_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean ieee_mkobject
  PARAMS ((bfd *));
static void fill
  PARAMS ((void));
static void flush
  PARAMS ((void));
static void write_int
  PARAMS ((int));
static void copy_id
  PARAMS ((void));
static void copy_expression
  PARAMS ((void));
static void fill_int
  PARAMS ((struct output_buffer_struct *));
static void drop_int
  PARAMS ((struct output_buffer_struct *));
static void copy_int
  PARAMS ((void));
static void f1_record
  PARAMS ((void));
static void f0_record
  PARAMS ((void));
static void copy_till_end
  PARAMS ((void));
static void f2_record
  PARAMS ((void));
static void f8_record
  PARAMS ((void));
static void e2_record
  PARAMS ((void));
static void block
  PARAMS ((void));
static void relocate_debug
  PARAMS ((bfd *, bfd *));
static bfd_boolean ieee_write_debug_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_data_part
  PARAMS ((bfd *));
static bfd_boolean init_for_output
  PARAMS ((bfd *));
static bfd_boolean ieee_set_section_contents
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
static bfd_boolean ieee_write_external_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_me_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_processor
  PARAMS ((bfd *));
static bfd_boolean ieee_write_object_contents
  PARAMS ((bfd *));
static asymbol *ieee_make_empty_symbol
  PARAMS ((bfd *));
static bfd *ieee_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd_boolean ieee_find_nearest_line
d123 2
a124 4
static int ieee_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static int ieee_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
d129 1
a129 1
static bfd_boolean
d138 2
a139 2
    return FALSE;
  return TRUE;
d142 1
a142 1
static bfd_boolean
d152 2
a153 2
    return FALSE;
  return TRUE;
d156 1
a156 1
static bfd_boolean
d164 1
a164 1
	return FALSE;
d170 2
a171 2
      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
d184 1
a184 1
	return FALSE;
d189 1
a189 1
	    return FALSE;
d193 1
a193 1
	    return FALSE;
d197 1
a197 1
	    return FALSE;
d201 1
a201 1
	    return FALSE;
d205 1
a205 1
  return TRUE;
d208 1
a208 1
static bfd_boolean
d218 1
a218 1
	return FALSE;
d224 1
a224 1
	return FALSE;
d230 1
a230 1
	return FALSE;
d238 1
a238 1
      return FALSE;
d242 2
a243 2
    return FALSE;
  return TRUE;
d246 4
a249 2
/* Functions for reading from ieee files in the strange way that the
   standard requires.  */
a260 1

a270 1

d272 3
a274 1
    string[i] = this_byte_and_next (ieee);
a282 1

d286 1
a286 1
      /* Simple string of length 0 to 127.  */
d290 1
a290 1
      /* Length is next byte, allowing 0..255.  */
d295 1
a295 1
      /* Length is next two bytes, allowing 0..65535.  */
d299 1
a299 2

  /* Buy memory and read string.  */
d308 1
a308 1
static bfd_boolean
d313 1
a313 1
     bfd_boolean pcrel;
d321 1
a321 1
	return FALSE;
d325 10
a334 3
  /* Badly formatted binaries can have a missing symbol,
     so test here to prevent a seg fault.  */
  if (symbol != NULL)
d336 3
a338 2
      if (bfd_is_com_section (symbol->section)
	  || bfd_is_und_section (symbol->section))
d340 1
a340 2
	  /* Def of a common symbol.  */
	  if (! ieee_write_byte (abfd, ieee_variable_X_enum)
d342 2
a343 2
	    return FALSE;
	  term_count ++;
d345 1
a345 1
      else if (! bfd_is_abs_section (symbol->section))
d347 9
a355 3
	  /* Ref to defined symbol -  */

	  if (symbol->flags & BSF_GLOBAL)
d357 2
a358 3
	      if (! ieee_write_byte (abfd, ieee_variable_I_enum)
		  || ! ieee_write_int (abfd, symbol->value))
		return FALSE;
d361 9
a369 27
	  else if (symbol->flags & (BSF_LOCAL | BSF_SECTION_SYM))
	    {
	      /* This is a reference to a defined local symbol.  We can
		 easily do a local as a section+offset.  */
	      if (! ieee_write_byte (abfd, ieee_variable_R_enum)
		  || ! ieee_write_byte (abfd,
					(bfd_byte) (symbol->section->index
						    + IEEE_SECTION_NUMBER_BASE)))
		return FALSE;

	      term_count++;
	      if (symbol->value != 0)
		{
		  if (! ieee_write_int (abfd, symbol->value))
		    return FALSE;
		  term_count++;
		}
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: unrecognized symbol `%s' flags 0x%x"),
		 bfd_get_filename (abfd), bfd_asymbol_name (symbol),
		 symbol->flags);
	      bfd_set_error (bfd_error_invalid_operation);
	      return FALSE;
	    }
d375 1
a375 1
      /* Subtract the pc from here by asking for PC of this section.  */
d380 1
a380 1
	return FALSE;
d385 4
a388 2
    if (! ieee_write_int (abfd, (bfd_vma) 0))
      return FALSE;
d393 1
a393 1
	return FALSE;
d397 1
a397 1
  return TRUE;
d400 1
a400 1
/* Writes any integer into the buffer supplied and always takes 5 bytes.  */
d402 3
d417 1
a417 1
static bfd_boolean
d426 2
a427 2
    return FALSE;
  return TRUE;
d430 1
a430 1
static bfd_boolean
a436 1

d441 1
a441 1
      return TRUE;
a445 1

d454 1
a454 1
      return TRUE;
d456 1
a456 1
  return FALSE;
d462 1
a462 1
     bfd_boolean *ok;
d489 1
a489 1
#define PCREL_OFFSET FALSE
d494 1
a494 1
#define PCREL_OFFSET TRUE
d503 1
a503 1
	 FALSE,
d508 1
a508 1
	 TRUE,
d511 1
a511 1
	 FALSE);
d518 1
a518 1
	 FALSE,
d523 1
a523 1
	 TRUE,
d526 1
a526 1
	 FALSE);
d533 1
a533 1
	 FALSE,
d538 1
a538 1
	 TRUE,
d541 1
a541 1
	 FALSE);
d548 1
a548 1
	 TRUE,
d553 1
a553 1
	 TRUE,
d563 1
a563 1
	 TRUE,
d568 1
a568 1
	 TRUE,
d578 1
a578 1
	 TRUE,
d583 1
a583 1
	 TRUE,
d595 1
a595 1
     bfd_boolean *pcrel;
d606 1
a606 1
  bfd_boolean loop = TRUE;
d609 1
a609 1
  /* The stack pointer always points to the next unused location.  */
d620 1
a620 1
	  /* P variable, current program counter for section n.  */
a622 1

d624 1
a624 1
	    *pcrel = TRUE;
d630 1
a630 1
	  /* L variable  address of section N.  */
d635 2
a636 2
	  /* R variable, logical address of section module.  */
	  /* FIXME, this should be different to L.  */
d641 1
a641 1
	  /* S variable, size in MAUS of section module.  */
d648 1
a648 1
	  /* Push the address of variable n.  */
d659 1
a659 1
	  /* Push the address of external variable n.  */
d709 1
a709 1
		loop = FALSE;
d721 1
d767 1
a767 1
static char last_type;		/* Is the index for an X or a D.  */
d779 1
a779 1
  /* Need a new symbol.  */
a780 1

d796 3
a798 2
	*max_index = new_index;

d806 1
a806 1
static bfd_boolean
d817 1
a817 1
  bfd_boolean loop = TRUE;
d819 1
a819 1
  ieee->symbol_table_full = TRUE;
d834 1
a834 1
	    return FALSE;
d848 1
a848 1
	    return FALSE;
d881 1
a881 1
		    return FALSE;
d886 1
a886 1
		/* Skip over ATX record.  */
d895 1
a895 1
		   {$F1}${CE}{index}{$00}{$3F}{$3F}{#_of_ASNs}.  */
d905 1
a905 1
		    return FALSE;
d927 1
a927 1
			return FALSE;
d937 1
a937 1
	    bfd_boolean pcrel_ignore;
d981 1
a981 1
	    /* Throw away the external reference index.  */
d983 1
a983 1
	    /* Fetch the default size if not resolved.  */
d985 1
a985 1
	    /* Fetch the default value if available.  */
d990 1
a990 1
	    /* This turns into a common.  */
d1003 1
a1003 1
	    return FALSE;
d1016 1
a1016 1
	  loop = FALSE;
d1048 1
a1048 1
      ieee->symbol_table_full = FALSE;
d1054 1
a1054 1
  return TRUE;
d1057 1
a1057 1
static bfd_boolean
d1064 2
a1065 2
	return FALSE;
      IEEE_DATA (abfd)->read_symbols = TRUE;
d1067 1
a1067 1
  return TRUE;
d1081 4
a1084 2
/* Move from our internal lists to the canon table, and insert in
   symbol index order.  */
d1089 1
a1089 1
ieee_canonicalize_symtab (abfd, location)
d1117 2
a1118 2
	  /* Arrgh - there are gaps in the table, run through and fill them
	     up with pointers to a null place.  */
a1119 1

d1121 3
a1123 1
	    location[i] = &empty_symbol;
d1130 4
a1133 2
	/* Place into table at correct index locations.  */
	location[symp->index + ieee->external_symbol_base_offset] = &symp->symbol;
d1135 1
a1135 1
      /* The external refs are indexed in a bit.  */
d1142 5
a1146 2
	location[symp->index + ieee->external_reference_base_offset] =
	  &symp->symbol;
a1147 1

d1149 3
a1151 2
    location[abfd->symcount] = (asymbol *) NULL;

d1215 1
a1215 1
      while (TRUE)
d1231 2
a1232 1
		   extended later, based on section contents.  */
d1236 1
a1236 1
		    /* Normal attributes for absolute sections.  */
d1241 1
a1241 1
		      case 0xD3:	/* AS Absolute section attributes.  */
d1247 1
a1247 1
			    /* Normal code.  */
d1252 1
a1252 1
			    /* Normal data.  */
d1258 1
a1258 1
			    /* Normal rom data.  */
d1266 1
a1266 1
		  case 0xC3:	/* Named relocatable sections (type C).  */
d1271 1
a1271 1
		      case 0xD0:	/* Normal code (CP).  */
d1275 1
a1275 1
		      case 0xC4:	/* Normal data (CD).  */
d1279 1
a1279 1
		      case 0xD2:	/* Normal rom data (CR).  */
d1288 1
a1288 1
		/* Read section name, use it if non empty.  */
d1293 1
a1293 1
		/* Skip these fields, which we don't care about.  */
d1374 1
a1374 1
static bfd_boolean
d1383 1
a1383 1
    return TRUE;
d1387 1
a1387 1
    return FALSE;
d1394 1
a1394 1
  return TRUE;
d1397 3
a1399 1
/* Archive stuff.  */
d1569 2
a1570 2
  ieee->read_symbols = FALSE;
  ieee->read_data = FALSE;
d1585 5
a1589 3
    abfd->filename = ieee->mb.module_name;

  /* Determine the architecture and machine type of the object file.  */
d1594 1
a1594 1
    /* IEEE does not specify the format of the processor identification
d1630 1
a1630 1
	else if ((TOUPPER (processor[3]) == 'C') /* Embedded controllers.  */
d1639 1
a1639 1
	else				 /* "Regular" processors.  */
d1661 3
a1663 2
    goto fail;

d1667 3
a1669 2
    goto fail;

d1671 3
a1673 1
    goto fail;
d1675 3
a1677 3
  /* If there is a byte order info, take it.  */
  if (this_byte (&(ieee->h)) == (int) ieee_variable_L_enum
      || this_byte (&(ieee->h)) == (int) ieee_variable_M_enum)
d1682 1
a1682 2
      bfd_boolean ok;

d1684 3
a1686 2
	goto fail;

d1688 3
a1690 1
	goto fail;
d1694 4
a1697 1
	goto fail;
d1706 1
a1706 1
     record.  */
d1727 1
a1779 1

d1799 1
a1799 1
static bfd_boolean
a1812 1

d1826 1
a1826 2
	bfd_boolean loop = TRUE;

d1839 1
a1839 1
		  bfd_boolean pcrel = FALSE;
d1846 1
a1846 1
		    return FALSE;
d1868 1
a1868 1
		      /* Fetch number of bytes to pad.  */
d1886 1
a1886 1
		  /* Build a relocation entry for this type.  */
d1965 1
a1965 1
		      return FALSE;
d1983 1
a1983 1
		      loop = FALSE;
d1991 1
a1991 1
	      loop = FALSE;
d1995 1
a1995 1
  return TRUE;
d1998 2
a1999 3
/* Read in all the section data and relocation stuff too.  */

static bfd_boolean
d2009 1
a2009 1
  /* Seek to the start of the data area.  */
d2011 2
a2012 2
    return TRUE;
  ieee->read_data = TRUE;
d2015 2
a2016 1
  /* Allocate enough space for all the section contents.  */
d2019 1
a2019 1
      ieee_per_section_type *per = ieee_per_section (s);
d2024 2
a2025 1
	return FALSE;
d2030 1
a2030 1
  while (TRUE)
d2034 1
a2034 1
	  /* IF we see anything strange then quit.  */
d2036 1
a2036 1
	  return TRUE;
d2043 1
a2043 1
	  current_map = ieee_per_section (s);
d2045 3
a2047 3
	  /* The document I have says that Microtec's compilers reset
	     this after a sec section, even though the standard says not
	     to, SO...  */
d2060 1
a2060 2
		bfd_boolean pcrel;

d2062 1
a2062 1
		must_parse_int (&(ieee->h));	/* Throw away section #.  */
d2077 2
a2078 2
	      /* We've got to the end of the data now -  */
	      return TRUE;
d2081 1
a2081 1
	      return FALSE;
d2087 5
a2091 3
	       remembering the stream pointer before running it and
	       resetting it and running it n times. We special case
	       the repetition of a repeat_data/load_constant.  */
a2093 1

d2097 2
a2098 2
	    if (start[0] == (int) ieee_load_constant_bytes_enum
		&& start[1] == 1)
d2116 1
a2116 1
		      return FALSE;
d2124 4
a2127 2
	  if (!do_one (ieee, current_map, location_ptr, s, 1))
	    return FALSE;
d2132 1
a2132 1
static bfd_boolean
d2137 2
a2138 2
  newsect->used_by_bfd
    = (PTR) bfd_alloc (abfd, (bfd_size_type) sizeof (ieee_per_section_type));
d2140 1
a2140 1
    return FALSE;
d2143 1
a2143 1
  return TRUE;
d2158 1
a2158 1
static bfd_boolean
d2166 1
a2166 1
  ieee_per_section_type *p = ieee_per_section (section);
d2172 1
a2172 1
  return TRUE;
d2182 1
d2191 1
a2191 1
      /* Work out which symbol to attach it this reloc to.  */
d2230 1
a2230 1
static bfd_boolean
d2246 1
a2246 1
	    return FALSE;
d2250 1
a2250 1
	      /* This image is executable, so output absolute sections.  */
d2253 1
a2253 1
		return FALSE;
d2258 1
a2258 1
		return FALSE;
d2266 1
a2266 1
		return FALSE;
d2271 1
a2271 1
		return FALSE;
d2278 1
a2278 1
		return FALSE;
d2283 1
a2283 1
	    return FALSE;
d2289 1
a2289 1
	  /* Alignment.  */
d2295 1
a2295 1
	    return FALSE;
d2297 1
a2297 1
	  /* Size.  */
d2303 1
a2303 1
	    return FALSE;
d2306 2
a2307 2
	      /* Relocateable sections don't have asl records.  */
	      /* Vma.  */
d2314 1
a2314 1
		return FALSE;
d2319 1
a2319 1
  return TRUE;
d2323 1
a2323 1
static bfd_boolean
d2340 1
a2340 1
  /* Output the section preheader.  */
d2347 1
a2347 1
    return FALSE;
d2352 1
a2352 1
	return FALSE;
d2357 1
a2357 1
	return FALSE;
d2363 2
a2364 1
	 byte opcode rather than the load with relocation opcode.  */
a2368 1

d2371 3
a2373 1
	    run = s->_raw_size - current_byte_index;
d2378 2
a2379 2
		return FALSE;
	      /* Output a stream of bytes.  */
d2381 1
a2381 1
		return FALSE;
d2384 1
a2384 1
		return FALSE;
d2392 1
a2392 1
	return FALSE;
d2400 1
a2400 1
	  /* Outputting a section without data, fill it up.  */
d2403 1
a2403 1
	    return FALSE;
a2408 1

d2416 3
a2418 2
	    run = MAXRUN;

d2420 3
a2422 1
	    run = s->_raw_size - current_byte_index;
d2426 1
a2426 1
	      /* Output a stream of bytes.  */
d2428 1
a2428 1
		return FALSE;
d2431 1
a2431 1
		return FALSE;
d2434 1
a2434 2

	  /* Output any relocations here.  */
d2442 1
d2445 3
a2447 1
		    r->addend += current_byte_index;
d2449 1
d2471 1
a2471 1
		      return FALSE;
d2482 1
a2482 1
		    return FALSE;
d2492 1
a2492 1
			return FALSE;
d2500 1
a2500 1
			return FALSE;
d2508 1
a2508 1
			return FALSE;
d2512 1
a2512 1
		    return FALSE;
d2522 1
a2522 1
  return TRUE;
d2529 1
a2529 1
static bfd_boolean
d2545 1
a2545 1
	return FALSE;
d2550 1
a2550 1
	    return FALSE;
d2555 1
a2555 1
	    return FALSE;
d2563 1
a2563 1
	return FALSE;
d2566 1
a2566 1
  return TRUE;
d2569 1
a2569 1
static bfd_boolean
d2579 1
a2579 1
	return FALSE;
a2583 1

d2589 2
a2590 2
		return FALSE;
	      return TRUE;
d2594 1
a2594 1
	return FALSE;
d2597 1
a2597 1
  return TRUE;
d2611 1
a2611 1
static bfd_boolean
a2644 1

d2666 2
a2667 2
      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
d2669 3
a2671 1
	length = 4;
d2673 3
a2675 1
	length = 3;
d2677 3
a2679 1
	length = 2;
d2695 1
a2703 1

a2720 1

d2768 1
a2768 1
	      /* Not a number, just bug out with the answer.  */
d2776 1
a2776 1
	  /* PLUS anything.  */
a2786 1

d2820 1
a2820 1
      /* Still a chance to output the size.  */
a2834 1

d2908 1
a2908 2

  /* ATN record.  */
d2948 1
a2948 1
      /* EXternal ref.  */
d3002 1
d3008 1
a3008 1
  /* Attribute record.  */
a3018 1

d3077 3
a3079 3
      /* Unique typedefs for module.  */
      /* GLobal typedefs.   */
      /* High level module scope beginning.  */
a3081 1

d3096 1
a3096 1
      /* Global function.  */
a3098 1

d3118 1
a3118 1
      /* File name for source line numbers.  */
a3120 1

d3140 1
a3140 1
      /* Local function.  */
a3142 1

d3160 1
a3160 1
      /* Assembler module scope beginning -  */
a3188 1

a3224 1

d3256 5
a3260 2
/* Moves all the debug information from the source bfd to the output
   bfd, and relocates any expressions it finds.  */
d3283 1
a3283 1
static bfd_boolean
d3290 1
a3290 1
  bfd_boolean some_debug = FALSE;
d3308 1
a3308 1
	  return TRUE;
d3313 1
a3313 1
	return FALSE;
a3320 1

d3325 1
a3325 1
		return FALSE;
a3330 1

d3332 3
a3334 1
	ieee->w.r.debug_information_part = here;
d3336 3
a3338 1
	ieee->w.r.debug_information_part = 0;
d3343 1
a3343 1
  return TRUE;
d3348 1
a3348 1
static bfd_boolean
a3352 1

a3354 1

d3367 1
a3367 1
	    return FALSE;
d3372 1
a3372 1
	    return FALSE;
d3376 1
a3376 1
  return TRUE;
d3380 1
a3380 1
static bfd_boolean
a3384 1

d3394 1
a3394 1
	    return FALSE;
d3397 1
a3397 1
  return TRUE;
d3400 1
a3400 1
/* Exec and core file sections.  */
d3402 4
a3405 4
/* Set section contents is complicated with IEEE since the format is
   not a byte image, but a record stream.  */

static bfd_boolean
d3409 1
a3409 1
     const PTR location;
d3420 1
a3420 1
	    return FALSE;
d3425 1
a3425 1
      return TRUE;
d3431 1
a3431 1
	return FALSE;
d3436 1
a3436 1
  return TRUE;
d3444 1
a3444 1
static bfd_boolean
d3450 1
d3454 1
a3454 2
  bfd_boolean hadone = FALSE;

a3460 1

d3463 1
a3463 1
	      /* This must be a symbol reference.  */
d3467 1
a3467 1
		return FALSE;
d3470 1
a3470 1
	      hadone = TRUE;
d3474 1
a3474 1
	      /* This is a weak reference.  */
d3482 1
a3482 1
		return FALSE;
d3485 1
a3485 1
	      hadone = TRUE;
d3489 2
a3490 1
	      /* This must be a symbol definition.  */
d3499 1
a3499 1
		return FALSE;
d3501 1
a3501 1
	      /* Write out the value.  */
d3504 1
a3504 1
		return FALSE;
d3510 1
a3510 1
			 relocated.  */
d3516 1
a3516 1
			return FALSE;
d3524 2
a3525 2
			      FALSE, 0)))
			return FALSE;
d3533 2
a3534 2
					       FALSE, 0))
		    return FALSE;
d3538 1
a3538 1
	      hadone = TRUE;
d3542 2
a3543 2
	      /* This can happen - when there are gaps in the symbols read
	         from an input ieee file.  */
d3550 1
a3550 1
  return TRUE;
d3557 3
a3559 3
  0xf1, 0xce, 0x20, 0x00, 37, 3, 3,	/* Set version 3 rev 3.  */
  0xf1, 0xce, 0x20, 0x00, 39, 2,	/* Keep symbol in  original case.  */
  0xf1, 0xce, 0x20, 0x00, 38		/* Set object type relocatable to x.  */
d3575 1
a3575 1
static bfd_boolean
d3587 1
a3587 1
	return FALSE;
d3591 2
a3592 2
    return FALSE;
  return TRUE;
d3597 1
a3597 1
static bfd_boolean
d3608 1
a3608 1
	return FALSE;
d3613 1
a3613 1
	return FALSE;
d3618 1
a3618 1
	return FALSE;
d3623 1
a3623 1
	return FALSE;
d3633 1
a3633 1
	    return FALSE;
d3638 1
a3638 1
	    return FALSE;
d3643 1
a3643 1
	    return FALSE;
d3649 1
a3649 1
	    return FALSE;
a3672 1
	  case bfd_mach_mcf528x:id = "5282";  break;
d3676 1
a3676 1
	  return FALSE;
d3681 1
a3681 1
  return TRUE;
d3684 1
a3684 1
static bfd_boolean
d3692 1
a3692 1
  /* Fast forward over the header area.  */
d3694 1
a3694 1
    return FALSE;
d3699 1
a3699 1
    return FALSE;
d3701 1
a3701 1
  /* Fast forward over the variable bits.  */
d3703 1
a3703 1
    return FALSE;
d3705 1
a3705 1
  /* Bits per MAU.  */
d3707 2
a3708 2
    return FALSE;
  /* MAU's per address.  */
d3712 1
a3712 1
    return FALSE;
d3716 1
a3716 1
    return FALSE;
d3721 1
a3721 1
    return FALSE;
d3725 1
a3725 1
	return FALSE;
d3730 1
a3730 1
	return FALSE;
d3736 1
a3736 1
    return FALSE;
d3755 1
a3755 1
      return FALSE;
d3763 1
a3763 1
    return FALSE;
d3767 6
a3772 1
    return FALSE;
d3776 1
a3776 1
    return FALSE;
d3782 1
a3782 1
    return FALSE;
d3786 1
a3786 1
    return FALSE;
d3788 1
a3788 1
  /* Generate the header.  */
d3790 1
a3790 1
    return FALSE;
d3797 1
a3797 1
	return FALSE;
d3800 1
a3800 1
  return TRUE;
d3807 1
a3807 1
   hold them all plus all the cached symbol entries.  */
a3814 1

d3827 1
a3827 2

  /* Take the next one from the arch state, or reset.  */
d3829 5
a3833 4
    /* Reset the index - the first two entries are bogus.  */
    ar->element_index = 2;

  while (TRUE)
a3835 1

d3854 1
d3858 1
a3858 1
static bfd_boolean
d3869 1
a3869 1
  return FALSE;
d3907 1
a3907 1
     bfd_boolean x ATTRIBUTE_UNUSED;
d3932 2
a3933 1
   be ready to output it at close time.  */
d3941 1
a3941 2

  /* Can only accumulate data from other ieee bfds.  */
d3944 1
a3944 1
  /* Only bother once per bfd.  */
d3947 1
a3947 1
  ieee->done_debug = TRUE;
d3949 1
a3949 1
  /* Don't bother if there is no debug info.  */
d3953 2
a3954 1
  /* Add to chain.  */
a3957 1

d3964 3
a3966 1
      output_ieee->chain_head->next = n;
d3968 2
a3969 1
      output_ieee->chain_root = n;
d3971 1
d3984 1
a3984 2
  ((bfd_boolean (*) \
    PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
d3988 1
a3988 1
  ((bfd_boolean (*) \
d4020 1
d4074 4
a4077 5
  /* ieee_get_symtab_upper_bound, ieee_canonicalize_symtab,
     ieee_make_empty_symbol, ieee_print_symbol, ieee_get_symbol_info,
     ieee_bfd_is_local_label_name, ieee_get_lineno,
     ieee_find_nearest_line, ieee_bfd_make_debug_symbol,
     ieee_read_minisymbols, ieee_minisymbol_to_symbol */
@


1.28.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d43 14
a56 26
static bfd_boolean ieee_write_byte
  PARAMS ((bfd *, int));
static bfd_boolean ieee_write_2bytes
  PARAMS ((bfd *, int));
static bfd_boolean ieee_write_int
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean ieee_write_id
  PARAMS ((bfd *, const char *));
static unsigned short read_2bytes
  PARAMS ((common_header_type *));
static void bfd_get_string
  PARAMS ((common_header_type *, char *, size_t));
static char *read_id
  PARAMS ((common_header_type *));
static bfd_boolean ieee_write_expression
  PARAMS ((bfd *, bfd_vma, asymbol *, bfd_boolean, unsigned int));
static void ieee_write_int5
  PARAMS ((bfd_byte *, bfd_vma));
static bfd_boolean ieee_write_int5_out
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean parse_int
  PARAMS ((common_header_type *, bfd_vma *));
static int parse_i
  PARAMS ((common_header_type *, bfd_boolean *));
static bfd_vma must_parse_int
  PARAMS ((common_header_type *));
d59 2
a60 3
	   bfd_boolean *, unsigned int *, asection **));
static file_ptr ieee_part_after
  PARAMS ((ieee_data_type *, file_ptr));
d64 4
a67 8
static bfd_boolean ieee_slurp_external_symbols
  PARAMS ((bfd *));
static bfd_boolean ieee_slurp_symbol_table
  PARAMS ((bfd *));
static long ieee_get_symtab_upper_bound
  PARAMS ((bfd *));
static long ieee_get_symtab
  PARAMS ((bfd *, asymbol **));
d70 5
a74 10
static void ieee_slurp_sections
  PARAMS ((bfd *));
static bfd_boolean ieee_slurp_debug
  PARAMS ((bfd *));
const bfd_target *ieee_archive_p
  PARAMS ((bfd *));
const bfd_target *ieee_object_p
  PARAMS ((bfd *));
static void ieee_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
d77 1
a77 1
static bfd_boolean do_one
d80 4
a83 7
static bfd_boolean ieee_slurp_section_data
  PARAMS ((bfd *));
static bfd_boolean ieee_new_section_hook
  PARAMS ((bfd *, asection *));
static long ieee_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static bfd_boolean ieee_get_section_contents
d87 26
a112 51
static int comp
  PARAMS ((const PTR, const PTR));
static bfd_boolean ieee_write_section_part
  PARAMS ((bfd *));
static bfd_boolean do_with_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean do_as_repeat
  PARAMS ((bfd *, asection *));
static bfd_boolean do_without_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean ieee_mkobject
  PARAMS ((bfd *));
static void fill
  PARAMS ((void));
static void flush
  PARAMS ((void));
static void write_int
  PARAMS ((int));
static void copy_id
  PARAMS ((void));
static void copy_expression
  PARAMS ((void));
static void fill_int
  PARAMS ((struct output_buffer_struct *));
static void drop_int
  PARAMS ((struct output_buffer_struct *));
static void copy_int
  PARAMS ((void));
static void f1_record
  PARAMS ((void));
static void f0_record
  PARAMS ((void));
static void copy_till_end
  PARAMS ((void));
static void f2_record
  PARAMS ((void));
static void f8_record
  PARAMS ((void));
static void e2_record
  PARAMS ((void));
static void block
  PARAMS ((void));
static void relocate_debug
  PARAMS ((bfd *, bfd *));
static bfd_boolean ieee_write_debug_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_data_part
  PARAMS ((bfd *));
static bfd_boolean init_for_output
  PARAMS ((bfd *));
static bfd_boolean ieee_set_section_contents
d114 7
a120 13
static bfd_boolean ieee_write_external_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_me_part
  PARAMS ((bfd *));
static bfd_boolean ieee_write_processor
  PARAMS ((bfd *));
static bfd_boolean ieee_write_object_contents
  PARAMS ((bfd *));
static asymbol *ieee_make_empty_symbol
  PARAMS ((bfd *));
static bfd *ieee_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd_boolean ieee_find_nearest_line
d123 2
a124 4
static int ieee_generic_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
static int ieee_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
d129 1
a129 1
static bfd_boolean
d138 2
a139 2
    return FALSE;
  return TRUE;
d142 1
a142 1
static bfd_boolean
d152 2
a153 2
    return FALSE;
  return TRUE;
d156 1
a156 1
static bfd_boolean
d164 1
a164 1
	return FALSE;
d184 1
a184 1
	return FALSE;
d189 1
a189 1
	    return FALSE;
d193 1
a193 1
	    return FALSE;
d197 1
a197 1
	    return FALSE;
d201 1
a201 1
	    return FALSE;
d205 1
a205 1
  return TRUE;
d208 1
a208 1
static bfd_boolean
d218 1
a218 1
	return FALSE;
d224 1
a224 1
	return FALSE;
d230 1
a230 1
	return FALSE;
d238 1
a238 1
      return FALSE;
d242 2
a243 2
    return FALSE;
  return TRUE;
d308 1
a308 1
static bfd_boolean
d313 1
a313 1
     bfd_boolean pcrel;
d321 1
a321 1
	return FALSE;
d331 1
a331 1
	return FALSE;
d342 1
a342 1
	    return FALSE;
d353 1
a353 1
	    return FALSE;
d358 1
a358 1
		return FALSE;
d369 1
a369 1
	  return FALSE;
d380 1
a380 1
	return FALSE;
d387 1
a387 1
	return FALSE;
d393 1
a393 1
	return FALSE;
d397 1
a397 1
  return TRUE;
d417 1
a417 1
static bfd_boolean
d426 2
a427 2
    return FALSE;
  return TRUE;
d430 1
a430 1
static bfd_boolean
d441 1
a441 1
      return TRUE;
d454 1
a454 1
      return TRUE;
d456 1
a456 1
  return FALSE;
d462 1
a462 1
     bfd_boolean *ok;
d489 1
a489 1
#define PCREL_OFFSET FALSE
d494 1
a494 1
#define PCREL_OFFSET TRUE
d503 1
a503 1
	 FALSE,
d508 1
a508 1
	 TRUE,
d511 1
a511 1
	 FALSE);
d518 1
a518 1
	 FALSE,
d523 1
a523 1
	 TRUE,
d526 1
a526 1
	 FALSE);
d533 1
a533 1
	 FALSE,
d538 1
a538 1
	 TRUE,
d541 1
a541 1
	 FALSE);
d548 1
a548 1
	 TRUE,
d553 1
a553 1
	 TRUE,
d563 1
a563 1
	 TRUE,
d568 1
a568 1
	 TRUE,
d578 1
a578 1
	 TRUE,
d583 1
a583 1
	 TRUE,
d595 1
a595 1
     bfd_boolean *pcrel;
d606 1
a606 1
  bfd_boolean loop = TRUE;
d624 1
a624 1
	    *pcrel = TRUE;
d709 1
a709 1
		loop = FALSE;
d806 1
a806 1
static bfd_boolean
d817 1
a817 1
  bfd_boolean loop = TRUE;
d819 1
a819 1
  ieee->symbol_table_full = TRUE;
d834 1
a834 1
	    return FALSE;
d848 1
a848 1
	    return FALSE;
d881 1
a881 1
		    return FALSE;
d905 1
a905 1
		    return FALSE;
d927 1
a927 1
			return FALSE;
d937 1
a937 1
	    bfd_boolean pcrel_ignore;
d1003 1
a1003 1
	    return FALSE;
d1016 1
a1016 1
	  loop = FALSE;
d1048 1
a1048 1
      ieee->symbol_table_full = FALSE;
d1054 1
a1054 1
  return TRUE;
d1057 1
a1057 1
static bfd_boolean
d1064 2
a1065 2
	return FALSE;
      IEEE_DATA (abfd)->read_symbols = TRUE;
d1067 1
a1067 1
  return TRUE;
d1215 1
a1215 1
      while (TRUE)
d1374 1
a1374 1
static bfd_boolean
d1383 1
a1383 1
    return TRUE;
d1387 1
a1387 1
    return FALSE;
d1394 1
a1394 1
  return TRUE;
d1569 2
a1570 2
  ieee->read_symbols = FALSE;
  ieee->read_data = FALSE;
d1682 1
a1682 1
      bfd_boolean ok;
d1799 1
a1799 1
static bfd_boolean
d1826 1
a1826 1
	bfd_boolean loop = TRUE;
d1839 1
a1839 1
		  bfd_boolean pcrel = FALSE;
d1846 1
a1846 1
		    return FALSE;
d1965 1
a1965 1
		      return FALSE;
d1983 1
a1983 1
		      loop = FALSE;
d1991 1
a1991 1
	      loop = FALSE;
d1995 1
a1995 1
  return TRUE;
d1999 1
a1999 1
static bfd_boolean
d2011 2
a2012 2
    return TRUE;
  ieee->read_data = TRUE;
d2024 1
a2024 1
	return FALSE;
d2030 1
a2030 1
  while (TRUE)
d2036 1
a2036 1
	  return TRUE;
d2060 1
a2060 1
		bfd_boolean pcrel;
d2078 1
a2078 1
	      return TRUE;
d2081 1
a2081 1
	      return FALSE;
d2116 1
a2116 1
		      return FALSE;
d2126 1
a2126 1
	      return FALSE;
d2132 1
a2132 1
static bfd_boolean
d2140 1
a2140 1
    return FALSE;
d2143 1
a2143 1
  return TRUE;
d2158 1
a2158 1
static bfd_boolean
d2172 1
a2172 1
  return TRUE;
d2230 1
a2230 1
static bfd_boolean
d2246 1
a2246 1
	    return FALSE;
d2253 1
a2253 1
		return FALSE;
d2258 1
a2258 1
		return FALSE;
d2266 1
a2266 1
		return FALSE;
d2271 1
a2271 1
		return FALSE;
d2278 1
a2278 1
		return FALSE;
d2283 1
a2283 1
	    return FALSE;
d2295 1
a2295 1
	    return FALSE;
d2303 1
a2303 1
	    return FALSE;
d2314 1
a2314 1
		return FALSE;
d2319 1
a2319 1
  return TRUE;
d2323 1
a2323 1
static bfd_boolean
d2347 1
a2347 1
    return FALSE;
d2352 1
a2352 1
	return FALSE;
d2357 1
a2357 1
	return FALSE;
d2378 1
a2378 1
		return FALSE;
d2381 1
a2381 1
		return FALSE;
d2384 1
a2384 1
		return FALSE;
d2392 1
a2392 1
	return FALSE;
d2403 1
a2403 1
	    return FALSE;
d2428 1
a2428 1
		return FALSE;
d2431 1
a2431 1
		return FALSE;
d2471 1
a2471 1
		      return FALSE;
d2482 1
a2482 1
		    return FALSE;
d2492 1
a2492 1
			return FALSE;
d2500 1
a2500 1
			return FALSE;
d2508 1
a2508 1
			return FALSE;
d2512 1
a2512 1
		    return FALSE;
d2522 1
a2522 1
  return TRUE;
d2529 1
a2529 1
static bfd_boolean
d2545 1
a2545 1
	return FALSE;
d2550 1
a2550 1
	    return FALSE;
d2555 1
a2555 1
	    return FALSE;
d2563 1
a2563 1
	return FALSE;
d2566 1
a2566 1
  return TRUE;
d2569 1
a2569 1
static bfd_boolean
d2579 1
a2579 1
	return FALSE;
d2589 2
a2590 2
		return FALSE;
	      return TRUE;
d2594 1
a2594 1
	return FALSE;
d2597 1
a2597 1
  return TRUE;
d2611 1
a2611 1
static bfd_boolean
d3283 1
a3283 1
static bfd_boolean
d3290 1
a3290 1
  bfd_boolean some_debug = FALSE;
d3308 1
a3308 1
	  return TRUE;
d3313 1
a3313 1
	return FALSE;
d3325 1
a3325 1
		return FALSE;
d3343 1
a3343 1
  return TRUE;
d3348 1
a3348 1
static bfd_boolean
d3367 1
a3367 1
	    return FALSE;
d3372 1
a3372 1
	    return FALSE;
d3376 1
a3376 1
  return TRUE;
d3380 1
a3380 1
static bfd_boolean
d3394 1
a3394 1
	    return FALSE;
d3397 1
a3397 1
  return TRUE;
d3405 1
a3405 1
static bfd_boolean
d3420 1
a3420 1
	    return FALSE;
d3425 1
a3425 1
      return TRUE;
d3431 1
a3431 1
	return FALSE;
d3436 1
a3436 1
  return TRUE;
d3444 1
a3444 1
static bfd_boolean
d3454 1
a3454 1
  bfd_boolean hadone = FALSE;
d3467 1
a3467 1
		return FALSE;
d3470 1
a3470 1
	      hadone = TRUE;
d3482 1
a3482 1
		return FALSE;
d3485 1
a3485 1
	      hadone = TRUE;
d3499 1
a3499 1
		return FALSE;
d3504 1
a3504 1
		return FALSE;
d3516 1
a3516 1
			return FALSE;
d3524 2
a3525 2
			      FALSE, 0)))
			return FALSE;
d3533 2
a3534 2
					       FALSE, 0))
		    return FALSE;
d3538 1
a3538 1
	      hadone = TRUE;
d3550 1
a3550 1
  return TRUE;
d3575 1
a3575 1
static bfd_boolean
d3587 1
a3587 1
	return FALSE;
d3591 2
a3592 2
    return FALSE;
  return TRUE;
d3597 1
a3597 1
static bfd_boolean
d3608 1
a3608 1
	return FALSE;
d3613 1
a3613 1
	return FALSE;
d3618 1
a3618 1
	return FALSE;
d3623 1
a3623 1
	return FALSE;
d3633 1
a3633 1
	    return FALSE;
d3638 1
a3638 1
	    return FALSE;
d3643 1
a3643 1
	    return FALSE;
d3649 1
a3649 1
	    return FALSE;
d3676 1
a3676 1
	  return FALSE;
d3681 1
a3681 1
  return TRUE;
d3684 1
a3684 1
static bfd_boolean
d3694 1
a3694 1
    return FALSE;
d3699 1
a3699 1
    return FALSE;
d3703 1
a3703 1
    return FALSE;
d3707 1
a3707 1
    return FALSE;
d3712 1
a3712 1
    return FALSE;
d3716 1
a3716 1
    return FALSE;
d3721 1
a3721 1
    return FALSE;
d3725 1
a3725 1
	return FALSE;
d3730 1
a3730 1
	return FALSE;
d3736 1
a3736 1
    return FALSE;
d3755 1
a3755 1
      return FALSE;
d3763 1
a3763 1
    return FALSE;
d3767 1
a3767 1
    return FALSE;
d3776 1
a3776 1
    return FALSE;
d3782 1
a3782 1
    return FALSE;
d3786 1
a3786 1
    return FALSE;
d3790 1
a3790 1
    return FALSE;
d3797 1
a3797 1
	return FALSE;
d3800 1
a3800 1
  return TRUE;
d3833 1
a3833 1
  while (TRUE)
d3858 1
a3858 1
static bfd_boolean
d3869 1
a3869 1
  return FALSE;
d3907 1
a3907 1
     bfd_boolean x ATTRIBUTE_UNUSED;
d3947 1
a3947 1
  ieee->done_debug = TRUE;
d3984 1
a3984 2
  ((bfd_boolean (*) \
    PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
d3988 1
a3988 1
  ((bfd_boolean (*) \
@


1.28.10.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d2077 1
a2077 1
      ieee_per_section_type *per = ieee_per_section (s);
d2101 1
a2101 1
	  current_map = ieee_per_section (s);
d2195 2
a2196 2
  newsect->used_by_bfd
    = (PTR) bfd_alloc (abfd, (bfd_size_type) sizeof (ieee_per_section_type));
d2224 1
a2224 1
  ieee_per_section_type *p = ieee_per_section (section);
d2240 1
@


1.28.10.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d228 2
a229 2
      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
d304 4
a307 2
/* Functions for reading from ieee files in the strange way that the
   standard requires.  */
a318 1

a328 1

d330 3
a332 1
    string[i] = this_byte_and_next (ieee);
a340 1

d344 1
a344 1
      /* Simple string of length 0 to 127.  */
d348 1
a348 1
      /* Length is next byte, allowing 0..255.  */
d353 1
a353 1
      /* Length is next two bytes, allowing 0..65535.  */
d357 1
a357 2

  /* Buy memory and read string.  */
d383 10
a392 3
  /* Badly formatted binaries can have a missing symbol,
     so test here to prevent a seg fault.  */
  if (symbol != NULL)
d394 3
a396 2
      if (bfd_is_com_section (symbol->section)
	  || bfd_is_und_section (symbol->section))
d398 1
a398 2
	  /* Def of a common symbol.  */
	  if (! ieee_write_byte (abfd, ieee_variable_X_enum)
d401 1
a401 1
	  term_count ++;
d403 1
a403 1
      else if (! bfd_is_abs_section (symbol->section))
d405 9
a413 3
	  /* Ref to defined symbol -  */

	  if (symbol->flags & BSF_GLOBAL)
d415 1
a415 2
	      if (! ieee_write_byte (abfd, ieee_variable_I_enum)
		  || ! ieee_write_int (abfd, symbol->value))
d419 9
a427 27
	  else if (symbol->flags & (BSF_LOCAL | BSF_SECTION_SYM))
	    {
	      /* This is a reference to a defined local symbol.  We can
		 easily do a local as a section+offset.  */
	      if (! ieee_write_byte (abfd, ieee_variable_R_enum)
		  || ! ieee_write_byte (abfd,
					(bfd_byte) (symbol->section->index
						    + IEEE_SECTION_NUMBER_BASE)))
		return FALSE;

	      term_count++;
	      if (symbol->value != 0)
		{
		  if (! ieee_write_int (abfd, symbol->value))
		    return FALSE;
		  term_count++;
		}
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: unrecognized symbol `%s' flags 0x%x"),
		 bfd_get_filename (abfd), bfd_asymbol_name (symbol),
		 symbol->flags);
	      bfd_set_error (bfd_error_invalid_operation);
	      return FALSE;
	    }
d433 1
a433 1
      /* Subtract the pc from here by asking for PC of this section.  */
d443 4
a446 2
    if (! ieee_write_int (abfd, (bfd_vma) 0))
      return FALSE;
d458 1
a458 1
/* Writes any integer into the buffer supplied and always takes 5 bytes.  */
d460 3
a494 1

a503 1

d667 1
a667 1
  /* The stack pointer always points to the next unused location.  */
d678 1
a678 1
	  /* P variable, current program counter for section n.  */
a680 1

d688 1
a688 1
	  /* L variable  address of section N.  */
d693 2
a694 2
	  /* R variable, logical address of section module.  */
	  /* FIXME, this should be different to L.  */
d699 1
a699 1
	  /* S variable, size in MAUS of section module.  */
d706 1
a706 1
	  /* Push the address of variable n.  */
d717 1
a717 1
	  /* Push the address of external variable n.  */
d779 1
d825 1
a825 1
static char last_type;		/* Is the index for an X or a D.  */
d837 1
a837 1
  /* Need a new symbol.  */
a838 1

d854 3
a856 2
	*max_index = new_index;

d944 1
a944 1
		/* Skip over ATX record.  */
d953 1
a953 1
		   {$F1}${CE}{index}{$00}{$3F}{$3F}{#_of_ASNs}.  */
d1039 1
a1039 1
	    /* Throw away the external reference index.  */
d1041 1
a1041 1
	    /* Fetch the default size if not resolved.  */
d1043 1
a1043 1
	    /* Fetch the defautlt value if available.  */
d1048 1
a1048 1
	    /* This turns into a common.  */
d1139 4
a1142 2
/* Move from our internal lists to the canon table, and insert in
   symbol index order.  */
d1175 2
a1176 2
	  /* Arrgh - there are gaps in the table, run through and fill them
	     up with pointers to a null place.  */
a1177 1

d1179 3
a1181 1
	    location[i] = &empty_symbol;
d1188 4
a1191 2
	/* Place into table at correct index locations.  */
	location[symp->index + ieee->external_symbol_base_offset] = &symp->symbol;
d1193 1
a1193 1
      /* The external refs are indexed in a bit.  */
d1200 5
a1204 2
	location[symp->index + ieee->external_reference_base_offset] =
	  &symp->symbol;
a1205 1

d1207 3
a1209 2
    location[abfd->symcount] = (asymbol *) NULL;

d1289 2
a1290 1
		   extended later, based on section contents.  */
d1294 1
a1294 1
		    /* Normal attributes for absolute sections.  */
d1299 1
a1299 1
		      case 0xD3:	/* AS Absolute section attributes.  */
d1305 1
a1305 1
			    /* Normal code.  */
d1310 1
a1310 1
			    /* Normal data.  */
d1316 1
a1316 1
			    /* Normal rom data.  */
d1324 1
a1324 1
		  case 0xC3:	/* Named relocatable sections (type C).  */
d1329 1
a1329 1
		      case 0xD0:	/* Normal code (CP).  */
d1333 1
a1333 1
		      case 0xC4:	/* Normal data (CD).  */
d1337 1
a1337 1
		      case 0xD2:	/* Normal rom data (CR).  */
d1346 1
a1346 1
		/* Read section name, use it if non empty.  */
d1351 1
a1351 1
		/* Skip these fields, which we don't care about.  */
d1455 3
a1457 1
/* Archive stuff.  */
d1643 5
a1647 3
    abfd->filename = ieee->mb.module_name;

  /* Determine the architecture and machine type of the object file.  */
d1688 1
a1688 1
	else if ((TOUPPER (processor[3]) == 'C') /* Embedded controllers.  */
d1697 1
a1697 1
	else				 /* "Regular" processors.  */
d1719 3
a1721 2
    goto fail;

d1725 3
a1727 2
    goto fail;

d1729 3
a1731 1
    goto fail;
d1733 3
a1735 3
  /* If there is a byte order info, take it.  */
  if (this_byte (&(ieee->h)) == (int) ieee_variable_L_enum
      || this_byte (&(ieee->h)) == (int) ieee_variable_M_enum)
a1740 1

d1742 3
a1744 2
	goto fail;

d1746 3
a1748 1
	goto fail;
d1752 4
a1755 1
	goto fail;
d1764 1
a1764 1
     record.  */
d1785 1
a1837 1

a1870 1

a1884 1

d1926 1
a1926 1
		      /* Fetch number of bytes to pad.  */
d1944 1
a1944 1
		  /* Build a relocation entry for this type.  */
d2056 1
a2056 2
/* Read in all the section data and relocation stuff too.  */

d2067 1
a2067 1
  /* Seek to the start of the data area.  */
d2073 2
a2074 1
  /* Allocate enough space for all the section contents.  */
d2083 1
d2092 1
a2092 1
	  /* IF we see anything strange then quit.  */
d2103 3
a2105 3
	  /* The document I have says that Microtec's compilers reset
	     this after a sec section, even though the standard says not
	     to, SO...  */
a2118 1

d2120 1
a2120 1
		must_parse_int (&(ieee->h));	/* Throw away section #.  */
d2135 1
a2135 1
	      /* We've got to the end of the data now -  */
d2145 5
a2149 3
	       remembering the stream pointer before running it and
	       resetting it and running it n times. We special case
	       the repetition of a repeat_data/load_constant.  */
a2151 1

d2155 2
a2156 2
	    if (start[0] == (int) ieee_load_constant_bytes_enum
		&& start[1] == 1)
d2182 4
a2185 2
	  if (!do_one (ieee, current_map, location_ptr, s, 1))
	    return FALSE;
d2248 1
a2248 1
      /* Work out which symbol to attach it this reloc to.  */
d2307 1
a2307 1
	      /* This image is executable, so output absolute sections.  */
d2346 1
a2346 1
	  /* Alignment.  */
d2354 1
a2354 1
	  /* Size.  */
d2363 2
a2364 2
	      /* Relocateable sections don't have asl records.  */
	      /* Vma.  */
d2397 1
a2397 1
  /* Output the section preheader.  */
d2420 2
a2421 1
	 byte opcode rather than the load with relocation opcode.  */
a2425 1

d2428 3
a2430 1
	    run = s->_raw_size - current_byte_index;
d2436 1
a2436 1
	      /* Output a stream of bytes.  */
d2457 1
a2457 1
	  /* Outputting a section without data, fill it up.  */
a2465 1

d2473 3
a2475 2
	    run = MAXRUN;

d2477 3
a2479 1
	    run = s->_raw_size - current_byte_index;
d2483 1
a2483 1
	      /* Output a stream of bytes.  */
d2491 1
a2491 2

	  /* Output any relocations here.  */
d2499 1
d2502 3
a2504 1
		    r->addend += current_byte_index;
d2506 1
a2640 1

a2701 1

d2723 2
a2724 2
      /* How many significant bytes ?  */
      /* FIXME FOR LONGER INTS.  */
d2726 3
a2728 1
	length = 4;
d2730 3
a2732 1
	length = 3;
d2734 3
a2736 1
	length = 2;
d2752 1
a2760 1

a2777 1

d2825 1
a2825 1
	      /* Not a number, just bug out with the answer.  */
d2833 1
a2833 1
	  /* PLUS anything.  */
a2843 1

d2877 1
a2877 1
      /* Still a chance to output the size.  */
a2891 1

d2965 1
a2965 2

  /* ATN record.  */
d3005 1
a3005 1
      /* EXternal ref.  */
d3059 1
d3065 1
a3065 1
  /* Attribute record.  */
a3075 1

d3134 3
a3136 3
      /* Unique typedefs for module.  */
      /* GLobal typedefs.   */
      /* High level module scope beginning.  */
a3138 1

d3153 1
a3153 1
      /* Global function.  */
a3155 1

d3175 1
a3175 1
      /* File name for source line numbers.  */
a3177 1

d3197 1
a3197 1
      /* Local function.  */
a3199 1

d3217 1
a3217 1
      /* Assembler module scope beginning -  */
a3245 1

a3281 1

d3313 5
a3317 2
/* Moves all the debug information from the source bfd to the output
   bfd, and relocates any expressions it finds.  */
a3377 1

a3387 1

d3389 3
a3391 1
	ieee->w.r.debug_information_part = here;
d3393 3
a3395 1
	ieee->w.r.debug_information_part = 0;
a3409 1

a3411 1

a3441 1

d3457 1
a3457 4
/* Exec and core file sections.  */

/* Set section contents is complicated with IEEE since the format is
   not a byte image, but a record stream.  */
d3459 3
d3507 1
a3511 1

a3517 1

d3520 1
a3520 1
	      /* This must be a symbol reference.  */
d3531 1
a3531 1
	      /* This is a weak reference.  */
d3546 2
a3547 1
	      /* This must be a symbol definition.  */
d3558 1
a3558 1
	      /* Write out the value.  */
d3567 1
a3567 1
			 relocated.  */
d3599 2
a3600 2
	      /* This can happen - when there are gaps in the symbols read
	         from an input ieee file.  */
d3614 3
a3616 3
  0xf1, 0xce, 0x20, 0x00, 37, 3, 3,	/* Set version 3 rev 3.  */
  0xf1, 0xce, 0x20, 0x00, 39, 2,	/* Keep symbol in  original case.  */
  0xf1, 0xce, 0x20, 0x00, 38		/* Set object type relocateable to x.  */
d3749 1
a3749 1
  /* Fast forward over the header area.  */
d3758 1
a3758 1
  /* Fast forward over the variable bits.  */
d3762 1
a3762 1
  /* Bits per MAU.  */
d3765 1
a3765 1
  /* MAU's per address.  */
d3826 5
d3845 1
a3845 1
  /* Generate the header.  */
d3864 1
a3864 1
   hold them all plus all the cached symbol entries.  */
a3871 1

d3884 1
a3884 2

  /* Take the next one from the arch state, or reset.  */
d3886 4
a3889 3
    /* Reset the index - the first two entries are bogus.  */
    ar->element_index = 2;

a3892 1

d3911 1
d3989 2
a3990 1
   be ready to output it at close time.  */
d3998 1
a3998 2

  /* Can only accumulate data from other ieee bfds.  */
d4001 1
a4001 1
  /* Only bother once per bfd.  */
d4006 1
a4006 1
  /* Don't bother if there is no debug info.  */
d4010 2
a4011 1
  /* Add to chain.  */
a4014 1

d4021 3
a4023 1
      output_ieee->chain_head->next = n;
d4025 2
a4026 1
      output_ieee->chain_root = n;
d4028 1
d4078 1
@


1.28.10.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3593 1
a3593 1
  0xf1, 0xce, 0x20, 0x00, 38		/* Set object type relocatable to x.  */
@


1.28.10.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d83 1
a83 1
static long ieee_canonicalize_symtab
d163 1
a163 1
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
d1148 1
a1148 1
ieee_canonicalize_symtab (abfd, location)
d3443 1
a3443 1
     const PTR location;
a3706 1
	  case bfd_mach_mcf528x:id = "5282";  break;
d4100 4
a4103 5
  /* ieee_get_symtab_upper_bound, ieee_canonicalize_symtab,
     ieee_make_empty_symbol, ieee_print_symbol, ieee_get_symbol_info,
     ieee_bfd_is_local_label_name, ieee_get_lineno,
     ieee_find_nearest_line, ieee_bfd_make_debug_symbol,
     ieee_read_minisymbols, ieee_minisymbol_to_symbol */
@


1.28.10.6
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1046 1
a1046 1
	    /* Fetch the default value if available.  */
d1642 1
a1642 1
    /* IEEE does not specify the format of the processor identification
@


1.27
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d1417 1
a1417 1
    goto error_return;
a1532 2
  bfd_release (abfd, ieee);
  abfd->tdata.ieee_ar_data = save;
a1533 1

d1537 3
d1735 1
a1735 1
  (void) bfd_release (abfd, ieee);
@


1.27.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d1417 1
a1417 1
    goto error_ret_restore;
d1533 2
d1536 1
a1539 3
  bfd_release (abfd, ieee);
 error_ret_restore:
  abfd->tdata.ieee_ar_data = save;
d1735 1
a1735 1
  bfd_release (abfd, ieee);
@


1.26
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d474 1
a474 1
  BFD_ASSERT (parse_int (ieee, &result) == true);
d986 1
a986 1
	    if (parse_int (&(ieee->h), &value) == false)
d1061 1
a1061 1
  if (IEEE_DATA (abfd)->read_symbols == false)
d1115 1
a1115 1
      if (ieee->symbol_table_full == false)
d1666 1
a1666 1
  if (parse_int (&(ieee->h), &ieee->ad.number_of_bits_mau) == false)
d1670 1
a1670 1
  if (parse_int (&(ieee->h), &ieee->ad.number_of_maus_in_address) == false)
d1693 1
a1693 1
      if (ok == false)
d1898 1
a1898 1
		      if (pcrel == true)
d1920 1
a1920 1
		      if (pcrel == true)
d1944 1
a1944 1
		      if (pcrel == true)
d1972 1
a1972 1
		  if (parse_int (&(ieee->h), &this_size) == true)
d2010 1
a2010 1
  if (ieee->read_data == true)
d2628 1
a2628 1
  return abfd->tdata.ieee_data ? true : false;
d3945 1
a3945 1
  if (ieee->done_debug == true)
@


1.25
log
@	* bfd-in.h: Remove "taken from the source" comment.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	* elf.c (bfd_elf_discard_group): Return true.
	* elf-bfd.h (bfd_elf_discard_group): Declare.
	* bfd-in.h (bfd_elf_discard_group): Don't declare here.
	* section.c (bfd_discard_group): Rename to bfd_generic_discard_group.
	* bfd.c (bfd_discard_group): Define.
	* targets.c (struct bfd_target): Add _bfd_discard_group.
	(BFD_JUMP_TABLE_LINK): Here too.
	* libbfd-in.h (_bfd_nolink_bfd_discard_group): Define.
	* aout-adobe.c (aout_32_bfd_discard_group): Define.
	* aout-target.h (MY_bfd_discard_group): Define.
	* aout-tic30.c (MY_bfd_discard_group): Define.
	* binary.c (binary_bfd_discard_group): Define.
	* bout.c (b_out_bfd_discard_group): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_discard_group): Define.
	* coffcode.h (coff_bfd_discard_group): Define.
	* coff-mips.c (_bfd_ecoff_bfd_discard_group): Define.
	* elfxx-target.h (bfd_elfNN_bfd_discard_group): Define.
	* i386msdos.c (msdos_bfd_discard_group): Define.
	* i386os9k.c (os9k_bfd_discard_group): Define.
	* ieee.c (ieee_bfd_discard_group): Define.
	* ihex.c (ihex_bfd_discard_group): Define.
	* mmo.c (mmo_bfd_discard_group): Define.
	* nlm-target.h (nlm_bfd_discard_group): Define.
	* oasys.c (oasys_bfd_discard_group): Define.
	* ppcboot.c (ppcboot_bfd_discard_group): Define.
	* som.c (som_bfd_discard_group): Define.
	* srec.c (srec_bfd_discard_group): Define.
	* tekhex.c (tekhex_bfd_discard_group): Define.
	* versados.c (versados_bfd_discard_group): Define.
	* vms.c (vms_bfd_discard_group): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_discard_group): Define.
	* coff64-rs6000.c (rs6000coff64_vec): Update initialiser.
	(aix5coff64_vec): Likewise.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
@
text
@d2401 1
a2401 1
	  stream = (unsigned char *) (bfd_alloc (abfd, s->_raw_size));
a2403 1
	  memset ((PTR) stream, 0, (size_t) s->_raw_size);
@


1.24
log
@Fix ld --just-symbols
	* aix5ppc-core.c: Warning fixes.
	* aout-adobe.c (aout_32_bfd_link_just_syms): Define.
	* aout-target.h (MY_bfd_link_just_syms): Define.
	* aout-tic30.c (MY_bfd_link_just_syms): Define.
	* bfd.c (bfd_link_just_syms): Define.
	* binary.c (binary_bfd_link_just_syms): Define.
	* bout.c (b_out_bfd_link_just_syms): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update initializer.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_just_syms): Define.
	* elf-bfd.h (enum elf_link_info_type): Add ELF_INFO_TYPE_JUST_SYMS.
	(elf_discarded_section): Check for ELF_INFO_TYPE_JUST_SYMS.
	(_bfd_elf_link_just_syms): Declare.
	* elf.c (_bfd_elf_link_just_syms): New function.
	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Check that
	sections haven't already been discarded by the linker.
	* elflink.h (elf_link_add_object_symbols): Likewise for stab
	sections and SEC_MERGE sections.
	(elf_bfd_discard_info): Similarly here.
	* elfxx-target.h (bfd_elfNN_bfd_link_just_syms): Define.
	* i386msdos.c (msdos_bfd_link_just_syms): Define.
	* i386os9k.c (os9k_bfd_link_just_syms): Define.
	* ieee.c (ieee_bfd_link_just_syms): Define.
	* ihex.c (ihex_bfd_link_just_syms): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_just_syms): Define.
	(_bfd_generic_link_just_syms): Declare.
	* libecoff.h (_bfd_ecoff_bfd_link_just_syms): Define.
	* linker.c (_bfd_generic_link_just_syms): New function.
	* mmo.c (mmo_bfd_link_just_syms): Define.
	* nlm-target.h (nlm_bfd_link_just_syms): Define.
	* oasys.c (oasys_bfd_link_just_syms): Define.
	* ppcboot.c (ppcboot_bfd_link_just_syms): Define.
	* som.c (som_bfd_link_just_syms): Define.
	* srec.c (srec_bfd_link_just_syms): Define.
	* targets.c (struct bfd_target): Add _bfd_link_just_syms.
	(BFD_JUMP_TABLE_LINK): And here.
	* tekhex.c (tekhex_bfd_link_just_syms): Define.
	* versados.c (versados_bfd_link_just_syms): Define.
	* vms.c (vms_bfd_link_just_syms): Define.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d4013 1
@


1.24.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2401 1
a2401 1
	  stream = (unsigned char *) bfd_zalloc (abfd, s->_raw_size);
d2404 1
a4012 1
#define ieee_bfd_discard_group bfd_generic_discard_group
@


1.24.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d474 1
a474 1
  BFD_ASSERT (parse_int (ieee, &result));
d986 1
a986 1
	    if (! parse_int (&(ieee->h), &value))
d1061 1
a1061 1
  if (! IEEE_DATA (abfd)->read_symbols)
d1115 1
a1115 1
      if (! ieee->symbol_table_full)
d1666 1
a1666 1
  if (! parse_int (&(ieee->h), &ieee->ad.number_of_bits_mau))
d1670 1
a1670 1
  if (! parse_int (&(ieee->h), &ieee->ad.number_of_maus_in_address))
d1693 1
a1693 1
      if (! ok)
d1898 1
a1898 1
		      if (pcrel)
d1920 1
a1920 1
		      if (pcrel)
d1944 1
a1944 1
		      if (pcrel)
d1972 1
a1972 1
		  if (parse_int (&(ieee->h), &this_size))
d2010 1
a2010 1
  if (ieee->read_data)
d2628 1
a2628 1
  return abfd->tdata.ieee_data != NULL;
d3945 1
a3945 1
  if (ieee->done_debug)
@


1.24.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1417 1
a1417 1
    goto error_ret_restore;
d1533 2
d1536 1
a1539 3
  bfd_release (abfd, ieee);
 error_ret_restore:
  abfd->tdata.ieee_ar_data = save;
d1735 1
a1735 1
  bfd_release (abfd, ieee);
@


1.23
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d4016 1
@


1.23.4.1
log
@merge from trunk
@
text
@d2401 1
a2401 1
	  stream = (unsigned char *) bfd_zalloc (abfd, s->_raw_size);
d2404 1
a4012 1
#define ieee_bfd_discard_group bfd_generic_discard_group
a4015 1
#define ieee_bfd_link_just_syms _bfd_generic_link_just_syms
@


1.22
log
@Fixes for better translation into other languages
@
text
@d4014 1
d4088 1
@


1.21
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d3 1
a3 1
   2000, 2001
d8 1
a8 1
This file is part of BFD, the Binary File Descriptor library.
d10 13
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d877 1
a877 1
		      (_("%s: unimplemented ATI record  %u for symbol %u"),
@


1.20
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d878 1
a878 1
		       bfd_get_filename (abfd), symbol_attribute_def,
d903 1
a903 1
			 bfd_get_filename (abfd), (int) value);
d925 1
a925 1
			     bfd_get_filename (abfd));
@


1.19
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d35 1
a35 2

#include <ctype.h>
d1628 6
a1633 6
	else if (toupper (processor[3]) == 'F')   /* 68F333 */
	  strcpy (family, "68332");	          /* CPU32 */
	else if ((toupper (processor[3]) == 'C')  /* Embedded controllers */
		 && ((toupper (processor[2]) == 'E')
		     || (toupper (processor[2]) == 'H')
		     || (toupper (processor[2]) == 'L')))
@


1.18
log
@2001-08-23  H.J. Lu  <hjl@@gnu.org>

	* syms.c (bfd_print_symbol_vandf): Add abfd to arg.
	* bfd-in2.h (bfd_print_symbol_vandf): Regenerated.

	* aoutx.h (NAME(aout,print_symbol)): Pass abfd to
	bfd_print_symbol_vandf.
	* coffgen.c (coff_print_symbol): Likewise.
	* elf.c (bfd_elf_print_symbol): Likewise.
	* ieee.c (ieee_print_symbol): Likewise.
	* nlmcode.h (nlm_print_symbol): Likewise.
	* oasys.c (oasys_print_symbol): Likewise.
	* pdp11.c (NAME(aout,print_symbol)): Likewise.
	* som.c (som_print_symbol): Likewise.
	* srec.c (srec_print_symbol): Likewise.
	* tekhex.c (tekhex_print_symbol): Likewise.
	* versados.c (versados_print_symbol): Likewise.
	* vms.c (vms_print_symbol): Likewise.

	* elf.c (_bfd_elf_print_private_bfd_data): Replace fprintf_vma
	with bfd_fprintf_vma.
	(bfd_elf_print_symbol): Likewise.
	* syms.c (bfd_print_symbol_vandf): Likewise.
@
text
@d64 1
a64 1
	   ieee_symbol_type ***, unsigned int *, char));
d138 1
a138 1
  if (bfd_write ((PTR) &byte, 1, 1, abfd) != 1)
d152 1
a152 1
  if (bfd_write ((PTR) buffer, 1, 2, abfd) != 2)
d242 1
a242 1
  if (bfd_write ((PTR) id, 1, length, abfd) != length)
d301 1
a301 1
  string = bfd_alloc (ieee->abfd, length + 1);
d387 1
a387 1
      if (! ieee_write_int (abfd, 0))
d426 1
a426 1
  if (bfd_write ((PTR) b, 1, 5, abfd) != 5)
d778 1
a778 1
     char this_type;
d784 4
a787 2
      ieee_symbol_type *new_symbol = (ieee_symbol_type *) bfd_alloc (ieee->h.abfd,
						 sizeof (ieee_symbol_type));
d1166 1
d1174 3
a1176 2
      n = ((asection **)
	   bfd_realloc (ieee->section_table, c * sizeof (asection *)));
d1189 1
a1189 1
      char *tmp = bfd_alloc (abfd, 11);
a1209 1
  asection *section = (asection *) NULL;
d1222 1
d1322 2
a1323 1
		ieee_record_enum_type t = (ieee_record_enum_type) (read_2bytes (&(ieee->h)));
d1325 1
d1412 1
a1412 1
  unsigned int alc_elts;
d1414 1
d1416 1
a1416 2
  abfd->tdata.ieee_ar_data =
    (ieee_ar_data_type *) bfd_alloc (abfd, sizeof (ieee_ar_data_type));
d1423 1
a1423 1
  bfd_read ((PTR) buffer, 1, sizeof (buffer), abfd);
d1490 2
a1491 2
	  /* Again ignore return value of bfd_read.  */
	  bfd_read ((PTR) buffer, 1, sizeof (buffer), abfd);
d1497 3
a1499 3
  ieee->elements = ((ieee_ar_obstack_type *)
		    bfd_alloc (abfd,
			       ieee->element_count * sizeof *ieee->elements));
d1503 1
a1503 2
  memcpy (ieee->elements, elts,
	  ieee->element_count * sizeof *ieee->elements);
d1513 2
a1514 2
      /* Again ignore return value of bfd_read.  */
      bfd_read ((PTR) buffer, 1, sizeof (buffer), abfd);
d1521 1
a1521 1
      
d1554 1
d1563 2
a1564 2
     bfd_read return value;  The file might be very small.  */
  bfd_read ((PTR) buffer, 1, sizeof (buffer), abfd);
d1709 1
d1711 1
a1711 1
    (unsigned char *) bfd_alloc (ieee->h.abfd, ieee->w.r.me_record + 1);
d1718 2
a1719 2
  bfd_read ((PTR) (IEEE_DATA (abfd)->h.first_byte), 1,
	    ieee->w.r.me_record + 1, abfd);
d1731 1
a1731 1
    
d1842 4
a1845 3
		  ieee_reloc_type *r =
		  (ieee_reloc_type *) bfd_alloc (ieee->h.abfd,
						 sizeof (ieee_reloc_type));
d1902 2
a1903 2
			  bfd_put_32 (ieee->h.abfd, -current_map->pc, location_ptr +
				      current_map->pc);
d1905 1
a1905 2
			  r->relent.addend -=
			    current_map->pc;
d1907 1
a1907 1
			  bfd_put_32 (ieee->h.abfd, 0, location_ptr +
d1914 2
a1915 2
			  bfd_put_32 (ieee->h.abfd, 0, location_ptr +
				      current_map->pc);
d1924 2
a1925 1
			  bfd_put_16 (ieee->h.abfd, (int) (-current_map->pc), location_ptr + current_map->pc);
d1930 2
a1931 1
			  bfd_put_16 (ieee->h.abfd, 0, location_ptr + current_map->pc);
d1938 2
a1939 1
			  bfd_put_16 (ieee->h.abfd, 0, location_ptr + current_map->pc);
d2116 1
a2116 1
				 iterations))
d2139 1
a2139 1
    bfd_alloc (abfd, sizeof (ieee_per_section_type));
d2295 1
a2295 1
	      || ! ieee_write_int (abfd, 1 << s->alignment_power))
d2357 1
a2357 1
      if (! ieee_write_expression (abfd, 0, s->symbol, 0, 0))
d2383 1
a2383 4
	      if (bfd_write ((PTR) (stream + current_byte_index),
			     1,
			     run,
			     abfd)
d2431 1
a2431 4
	      if (bfd_write ((PTR) (stream + current_byte_index),
			     1,
			     run,
			     abfd)
d2493 1
a2493 1
						   s->index))
d2501 1
a2501 1
						   s->index))
d2508 2
a2509 2
		      if (! ieee_write_int (abfd,
					    bfd_get_reloc_size (r->howto)))
d2556 1
a2556 1
	  if (! ieee_write_expression (abfd, 0, s->symbol, 0, 0))
d2617 2
d2628 2
a2629 1
  abfd->tdata.ieee_data = (ieee_data_type *) bfd_zalloc (abfd, sizeof (ieee_data_type));
d2636 1
d2639 1
a2639 1
  bfd_read ((PTR) input_ptr_start, 1, input_ptr_end - input_ptr_start, input_bfd);
d2646 2
a2647 3
  if (bfd_write ((PTR) (output_ptr_start), 1, output_ptr - output_ptr_start,
		 output_bfd)
      != (bfd_size_type) (output_ptr - output_ptr_start))
d2722 1
a2722 1
  int value = 0;
a2775 1
	  value = 0;
d2779 4
a2782 6
	  {
	    int value = *(--tos);
	    value += *(--tos);
	    *tos++ = value;
	    NEXT ();
	  }
d2795 1
d2797 1
a2797 7
	      {
		value = s->output_section->lma;
	      }
	    else
	      {
		value = 0;
	      }
a2799 1
	    value = 0;
a2807 1

a2810 1

d3278 1
a3278 1
  bfd_read ((PTR) input_ptr_start, 1, IBS, input);
d3291 1
a3291 1
  unsigned char output_buffer[OBS];
d3295 3
a3297 3
  output_ptr_start = output_ptr = output_buffer;
  output_ptr_end = output_buffer + OBS;
  output_ptr = output_buffer;
d3314 1
a3314 1
      if (bfd_write (s->contents, 1, s->_raw_size, abfd) != s->_raw_size)
d3326 1
a3326 2
			    SEEK_SET)
		  != 0)
d3393 2
a3394 1
	  ieee_per_section (s)->data = (bfd_byte *) (bfd_alloc (abfd, s->_raw_size));
d3419 2
a3420 2
	  section->contents = ((unsigned char *)
			       bfd_alloc (abfd, section->_raw_size));
d3426 1
a3426 1
      memcpy (section->contents + offset, location, count);
d3467 1
a3467 1
		  || ! ieee_write_int (abfd, reference_index)
d3478 1
a3478 1
		  || ! ieee_write_int (abfd, reference_index)
d3482 1
a3482 1
		  || ! ieee_write_int (abfd, reference_index)
d3494 1
a3494 1
		  || ! ieee_write_int (abfd, public_index)
d3497 1
a3497 1
		  || ! ieee_write_int (abfd, public_index)
d3505 1
a3505 1
		  || ! ieee_write_int (abfd, public_index))
d3721 2
a3722 1
  if (bfd_write ((char *) exten, 1, sizeof (exten), abfd) != sizeof (exten))
d3736 2
a3737 1
  if (bfd_write ((char *) envi, 1, sizeof (envi), abfd) != sizeof (envi))
d3751 6
a3756 6
	|| ! ieee_write_int (abfd, t->tm_year + 1900)
	|| ! ieee_write_int (abfd, t->tm_mon + 1)
	|| ! ieee_write_int (abfd, t->tm_mday)
	|| ! ieee_write_int (abfd, t->tm_hour)
	|| ! ieee_write_int (abfd, t->tm_min)
	|| ! ieee_write_int (abfd, t->tm_sec))
d3798 1
a3798 1
	  || ! ieee_write_int5_out (abfd, ieee->w.offset[i]))
d3815 2
a3816 2
  ieee_symbol_type *new =
    (ieee_symbol_type *) bfd_zalloc (abfd, sizeof (ieee_symbol_type));
d3958 2
a3959 1
    bfd_chain_type *n = (bfd_chain_type *) bfd_alloc (abfd, sizeof (bfd_chain_type));
d4096 1
a4096 1
  
@


1.17
log
@	* libieee.h (common_header_type): Add last_byte field.

	* ieee.c: Add missing prototypes.  Some format fixes.
	(struct output_buffer_struct): Move for availability to prototypes.
	(ieee_part_after): New function.
	(ieee_slurp_debug): Use it here.
	(ieee_seek): Pass in ieee_data_struct rather than bfd.  Use
	ieee_part_after to set last_byte to one past end of current part.
	Update callers.
	(ieee_pos): Pass in ieee_data_struct rather than bfd.
	Update callers.
	(parse_expression): Don't go beyond the end of the current part.
	(ieee_slurp_external_symbols): Correct type passed to read_2bytes.
	(ieee_get_symtab_upper_bound, ieee_get_symtab,
	ieee_get_symbol_info, ieee_print_symbol, ieee_new_section_hook,
	ieee_get_reloc_upper_bound, ieee_canonicalize_reloc, block,
	ieee_set_section_contents, ieee_write_object_contents,
	ieee_make_empty_symbol): Make static.
	(ieee_archive_p): Correct comments regarding bfd_read.
	(ieee_object_p): Similarly.
	(ieee_mkobject): Move it.  Clear output_ptr_start, output_ptr,
	output_ptr_end, input_ptr_start, input_ptr, input_ptr_end,
	input_bfd, output_bfd, output_buffer.
	(do_as_repeat): Write out ieee_set_current_pc_enum value as for
	do_with_relocs, ie. as a symbol for relocatable files.
	(ieee_vec): Add comments showing functions referenced by macros.
@
text
@d1748 2
a1749 2
ieee_print_symbol (ignore_abfd, afile, symbol, how)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d1780 1
a1780 1
	    bfd_print_symbol_vandf ((PTR) file, symbol);
@


1.16
log
@	* merge.c (struct sec_merge_hash_entry): Add u.entsize and u.suffix
	fields, change sec into secinfo.
	(struct sec_merge_info): Add chain, remove last fields.
	(struct sec_merge_sec_info): Add next, sec, psecinfo fields.
	(sec_merge_hash_lookup): If lookup could not use a string only
	because it has bad alignment, mark the old string for deletion.
	(sec_merge_add): Add secinfo argument. Don't compute entry's
	position, instead record the section.
	(sec_merge_emit): Update for the sec into secinfo change in
	struct sec_merge_hash_entry.
	(_bfd_merge_section): Only record the section for merging, defer
	putting strings into the hash table.
	(cmplengthentry, last4_eq, last_eq, record_section, merge_strings,
	_bfd_merge_sections): New functions.
	(_bfd_merged_section_offset): Update for the sec_merge_hash_entry
	changes.
	* libbfd-in.h (_bfd_merge_sections): Add prototype.
	(_bfd_nolink_bfd_merge_sections): Define.
	* libbfd.h: Likewise.
	(bfd_generic_merge_sections): Add prototype.
	* targets.c (BFD_JUMP_TABLE_LINK): Add _bfd_merge_sections.
	(struct bfd_target): Likewise.
	* bfd.c (bfd_merge_sections): Define.
	* bfd-in2.h: Rebuilt.
	* elf.c (_bfd_elf_merge_sections): New function.
	* elf-bfd.h (_bfd_elf_merge_sections): Add prototype.
	* elfxx-target.h (bfd_elfNN_bfd_merge_sections): Define.
	* reloc.c (bfd_generic_merge_sections): New function.
	* vms.c (vms_bfd_merge_sections): New function.
	* aout-adobe.c (aout_32_bfd_merge_sections): Define.
	* aout-target.h (MY_bfd_merge_sections): Define.
	* aout-tic30.c (MY_bfd_merge_sections): Define.
	* binary.c (binary_bfd_merge_sections): Define.
	* bout.c (b_out_bfd_merge_sections): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_merge_sections): Define.
	* coffcode.c (coff_bfd_merge_sections): Define.
	* coff-mips.c (_bfd_ecoff_bfd_merge_sections): Define.
	* i386msdos.c (msdos_bfd_merge_sections): Define.
	* i386os9k.c (os9k_bfd_merge_sections): Define.
	* ieee.c (ieee_bfd_merge_sections): Define.
	* ihex.c (ihex_bfd_merge_sections): Define.
	* nlm-target.h (nlm_bfd_merge_sections): Define.
	* oasys.c (oasys_bfd_merge_sections): Define.
	* ppcboot.c (ppcboot_bfd_merge_sections): Define.
	* som.c (som_bfd_merge_sections): Define.
	* srec.c (srec_bfd_merge_sections): Define.
	* tekhex.c (tekhex_bfd_merge_sections): Define.
	* versados.c (versados_bfd_merge_sections): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_merge_sections): Define.

	* ldlang.c (lang_process): Call bfd_merge_sections.
@
text
@d38 6
d48 3
d55 34
d93 22
a115 2
static boolean ieee_write_data_part PARAMS ((bfd *));
static boolean ieee_write_debug_part PARAMS ((bfd *));
d118 8
a125 3

static boolean ieee_slurp_debug PARAMS ((bfd *));
static boolean ieee_slurp_section_data PARAMS ((bfd *));
d614 1
d616 1
a616 1
  while (loop)
d709 1
a709 23
		/*
		  Thats all that we can understand. As far as I can see
		  there is a bug in the Microtec IEEE output which I'm
		  using to scan, whereby the comma operator is omitted
		  sometimes in an expression, giving expressions with too
		  many terms. We can tell if that's the case by ensuring
		  that sp == stack here. If not, then we've pushed
		  something too far, so we keep adding.  */

		while (sp != stack + 1)
		  {
		    asection *section1;
		    ieee_symbol_index_type sy1;
		    POP (sy1, section1, *extra);
		  }
		{
		  asection *dummy;

		  POP (*symbol, dummy, *value);
		  if (section)
		    *section = dummy;
		}

d715 18
d736 27
a762 2
#define ieee_seek(abfd, offset) \
  IEEE_DATA(abfd)->h.input_p = IEEE_DATA(abfd)->h.first_byte + offset
d764 2
a765 2
#define ieee_pos(abfd) \
  (IEEE_DATA(abfd)->h.input_p - IEEE_DATA(abfd)->h.first_byte)
d771 1
a771 8
get_symbol (abfd,
	    ieee,
	    last_symbol,
	    symbol_count,
	    pptr,
	    max_index,
	    this_type
)
d778 1
a778 2
     char this_type
      ;
d820 1
a820 1
  ieee_seek (abfd, offset);
d862 1
a862 1
	    switch (read_2bytes (ieee))
d914 1
a914 1
		    switch (read_2bytes (ieee))
d1069 1
a1069 1
long
d1087 1
a1087 1
long
d1212 1
a1212 1
      ieee_seek (abfd, offset);
d1386 1
a1386 5
  debug_end = ieee->w.r.data_part;
  if (debug_end == 0)
    debug_end = ieee->w.r.trailer_part;
  if (debug_end == 0)
    debug_end = ieee->w.r.me_record;
d1415 2
a1416 2
  /* FIXME: Check return value.  I'm not sure whether it needs to read
     the entire buffer or not.  */
d1477 1
a1477 1
      if ((size_t) ieee_pos (abfd) > sizeof (buffer) / 2)
d1480 1
a1480 1
	  buffer_offset += ieee_pos (abfd);
d1484 1
a1484 2
	  /* FIXME: Check return value.  I'm not sure whether it needs
	     to read the entire buffer or not.  */
d1508 1
a1508 2
      /* FIXME: Check return value.  I'm not sure whether it needs to
	 read the entire buffer or not.  */
a1539 8
static boolean
ieee_mkobject (abfd)
     bfd *abfd;
{
  abfd->tdata.ieee_data = (ieee_data_type *) bfd_zalloc (abfd, sizeof (ieee_data_type));
  return abfd->tdata.ieee_data ? true : false;
}

d1556 2
a1557 3
  /* Read the first few bytes in to see if it makes sense */
  /* FIXME: Check return value.  I'm not sure whether it needs to read
     the entire buffer or not.  */
d1579 1
a1579 1
  if (abfd->filename == (CONST char *) NULL)
d1734 1
a1734 1
void
d1747 1
a1747 1
void
d2004 1
a2004 1
  ieee_seek (abfd, ieee->w.r.data_part);
d2053 1
a2053 1
		must_parse_int (&(ieee->h));	/* Thow away section #*/
d2123 1
a2123 1
boolean
d2137 1
a2137 1
long
d2166 1
a2166 1
long
d2211 2
a2212 2
     CONST PTR ap;
     CONST PTR bp;
d2339 1
d2542 15
a2556 3
					    + IEEE_SECTION_NUMBER_BASE))
	  || ! ieee_write_int (abfd, s->lma)
	  || ! ieee_write_byte (abfd, ieee_repeat_data_enum)
d2609 17
d2634 1
a2819 6
struct output_buffer_struct
{
  unsigned char *ptrp;
  int buffer;
};

a2906 1
static void copy_till_end ();
a3071 1
static void block ();
d3411 1
a3411 1
boolean
d3560 1
a3560 1
static CONST unsigned char exten[] =
d3568 1
a3568 1
static CONST unsigned char envi[] =
d3690 1
a3690 1
boolean
d3813 1
a3813 1
asymbol *
d3863 2
a3864 7
ieee_find_nearest_line (abfd,
			section,
			symbols,
			offset,
			filename_ptr,
			functionname_ptr,
			line_ptr)
d4060 2
d4063 1
d4066 6
d4073 5
d4079 3
d4083 2
d4086 6
d4093 1
@


1.15
log
@Update copyright notices
@
text
@d3929 1
@


1.14
log
@Rest of the changes for Coldfire V4.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999, 2001
@


1.13
log
@Plug one of many possible memory leaks in error handling.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d3584 4
@


1.13.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
@


1.13.2.2
log
@Merge from mainline.
@
text
@a3584 4
	  case bfd_mach_mcf5200:id = "5200";  break;
	  case bfd_mach_mcf5206e:id = "5206e"; break;
	  case bfd_mach_mcf5307:id = "5307";  break;
	  case bfd_mach_mcf5407:id = "5407";  break;
@


1.12
log
@Fix my last change to actually compile.
@
text
@d1346 1
a1346 4
    {
      abfd->tdata.ieee_ar_data = save;
      goto got_wrong_format_error;
    }
d1351 3
a1353 6
    {
      bfd_release (abfd, ieee);
      abfd->tdata.ieee_ar_data = save;
      goto got_wrong_format_error;
    }
  /* Throw away the filename */
d1359 2
a1360 2
  next_byte (&(ieee->h));	/* Drop the ad part */
  must_parse_int (&(ieee->h));	/* And the two dummy numbers */
d1368 1
a1368 1
  /* Read the index of the BB table */
d1397 1
a1397 2
      /* Make sure that we don't go over the end of the buffer */

d1400 1
a1400 1
	  /* Past half way, reseek and reprime */
d1404 1
d1418 1
d1424 1
a1424 3
  /* Now scan the area again, and replace BB offsets with file */
  /* offsets */

d1429 1
d1436 4
a1439 3
      next_byte (&(ieee->h));	/* Drop F8 */
      next_byte (&(ieee->h));	/* Drop 14 */
      must_parse_int (&(ieee->h));	/* Drop size of block */
d1441 2
a1442 4
	{
	  /* This object has been deleted */
	  ieee->elements[i].file_offset = 0;
	}
d1444 1
a1444 3
	{
	  ieee->elements[i].file_offset = must_parse_int (&(ieee->h));
	}
d1452 2
d1455 1
d1459 1
@


1.11
log
@(ieee_make_empty_symbol): Use bfd_zalloc, not bfd_zmalloc.
@
text
@d3728 1
a3728 1
    (ieee_symbol_type *) bfd_zalloc (sizeof (ieee_symbol_type));
@


1.10
log
@Apply Nick Clifton's suggestion.
@
text
@d3728 1
a3728 1
    (ieee_symbol_type *) bfd_zmalloc (sizeof (ieee_symbol_type));
@


1.9
log
@2000-08-07  Kazu Hirata  <kazu@@hxi.com>

	* ieee.c: Fix a comment typo.
	* elf64-ia64.c: Likewise.
@
text
@d3200 2
a3201 3
/* During linking, we told about the bfds which made up our contents,
   we have a list of them.  They will still be open, so go to the
   debug info in each, and copy it out, relocating it as we go.  */
@


1.8
log
@K&R compiler fixes
@
text
@d3200 3
a3202 5
/*
  During linking, we we told about the bfds which made up our
  contents, we have a list of them. They will still be open, so go to
  the debug info in each, and copy it out, relocating it as we go.
*/
@


1.7
log
@Return bfd_error_wrong_format on a format mismatch.
@
text
@d1012 11
a1022 2
  /* the_bfd, name, value, attr, section */
  {&dummy_bfd, " ieee empty", (symvalue) 0, BSF_DEBUGGING, bfd_abs_section_ptr, { 0 }};
@


1.7.2.1
log
@K&R compiler fixes.
@
text
@d1012 2
a1013 11
  {
    &dummy_bfd,
    " ieee empty",
    (symvalue) 0,
    BSF_DEBUGGING,
    bfd_abs_section_ptr
#ifdef __STDC__
    /* K&R compilers can't initialise unions.  */
    , { 0 }
#endif
  };
@


1.6
log
@Revert previous patch.
@
text
@d1339 1
a1339 1
      goto error_return;
d1348 1
a1348 1
      goto error_return;
d1451 2
@


1.5
log
@Change AR for ELF so that common symbols are not included in archive map.
Change LD for ELF so that archive elements whoes archive map contains a
 reference to a common symbol will get linkled in.
Add new field to bfd_target structure and initialise it for all bfd targets.
@
text
@a3902 1
#define ieee_allow_commons_in_armap bfd_true
@


1.4
log
@	* ieee.c (ieee_slurp_debug): Get the length of the debug
	information right if there is no data part.
@
text
@d3903 1
@


1.3
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d1283 1
d1293 7
a1299 1
  sec->_raw_size = ieee->w.r.data_part - ieee->w.r.debug_information_part;
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d3969 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d688 1
a688 1
     bfd *abfd;
d1013 1
a1013 1
  {&dummy_bfd, " ieee empty", (symvalue) 0, BSF_DEBUGGING, bfd_abs_section_ptr};
d1655 1
a1655 1
     bfd *ignore_abfd;
d1668 1
a1668 1
     bfd *ignore_abfd;
d3166 1
a3166 1
     bfd *output;
d3765 7
a3771 7
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
d3810 2
a3811 2
     bfd *abfd;
     boolean x;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

