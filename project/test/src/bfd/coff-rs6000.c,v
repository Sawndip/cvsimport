head	1.114;
access;
symbols
	sid-snapshot-20180601:1.114
	sid-snapshot-20180501:1.114
	sid-snapshot-20180401:1.114
	sid-snapshot-20180301:1.114
	sid-snapshot-20180201:1.114
	sid-snapshot-20180101:1.114
	sid-snapshot-20171201:1.114
	sid-snapshot-20171101:1.114
	sid-snapshot-20171001:1.114
	sid-snapshot-20170901:1.114
	sid-snapshot-20170801:1.114
	sid-snapshot-20170701:1.114
	sid-snapshot-20170601:1.114
	sid-snapshot-20170501:1.114
	sid-snapshot-20170401:1.114
	sid-snapshot-20170301:1.114
	sid-snapshot-20170201:1.114
	sid-snapshot-20170101:1.114
	sid-snapshot-20161201:1.114
	sid-snapshot-20161101:1.114
	sid-snapshot-20160901:1.114
	sid-snapshot-20160801:1.114
	sid-snapshot-20160701:1.114
	sid-snapshot-20160601:1.114
	sid-snapshot-20160501:1.114
	sid-snapshot-20160401:1.114
	sid-snapshot-20160301:1.114
	sid-snapshot-20160201:1.114
	sid-snapshot-20160101:1.114
	sid-snapshot-20151201:1.114
	sid-snapshot-20151101:1.114
	sid-snapshot-20151001:1.114
	sid-snapshot-20150901:1.114
	sid-snapshot-20150801:1.114
	sid-snapshot-20150701:1.114
	sid-snapshot-20150601:1.114
	sid-snapshot-20150501:1.114
	sid-snapshot-20150401:1.114
	sid-snapshot-20150301:1.114
	sid-snapshot-20150201:1.114
	sid-snapshot-20150101:1.114
	sid-snapshot-20141201:1.114
	sid-snapshot-20141101:1.114
	sid-snapshot-20141001:1.114
	sid-snapshot-20140901:1.114
	sid-snapshot-20140801:1.114
	sid-snapshot-20140701:1.114
	sid-snapshot-20140601:1.114
	sid-snapshot-20140501:1.114
	sid-snapshot-20140401:1.114
	sid-snapshot-20140301:1.114
	sid-snapshot-20140201:1.114
	sid-snapshot-20140101:1.114
	sid-snapshot-20131201:1.114
	sid-snapshot-20131101:1.114
	sid-snapshot-20131001:1.114
	binutils-2_24-branch:1.114.0.2
	binutils-2_24-branchpoint:1.114
	binutils-2_21_1:1.98
	sid-snapshot-20130901:1.114
	gdb_7_6_1-2013-08-30-release:1.108
	sid-snapshot-20130801:1.113
	sid-snapshot-20130701:1.109
	sid-snapshot-20130601:1.109
	sid-snapshot-20130501:1.108
	gdb_7_6-2013-04-26-release:1.108
	sid-snapshot-20130401:1.108
	binutils-2_23_2:1.106
	gdb_7_6-branch:1.108.0.2
	gdb_7_6-2013-03-12-branchpoint:1.108
	sid-snapshot-20130301:1.108
	sid-snapshot-20130201:1.108
	sid-snapshot-20130101:1.108
	sid-snapshot-20121201:1.108
	gdb_7_5_1-2012-11-29-release:1.105
	binutils-2_23_1:1.106
	sid-snapshot-20121101:1.108
	binutils-2_23:1.106
	sid-snapshot-20121001:1.107
	sid-snapshot-20120901:1.107
	gdb_7_5-2012-08-17-release:1.105
	sid-snapshot-20120801:1.106
	binutils-2_23-branch:1.106.0.2
	binutils-2_23-branchpoint:1.106
	gdb_7_5-branch:1.105.0.2
	gdb_7_5-2012-07-18-branchpoint:1.105
	sid-snapshot-20120701:1.104
	sid-snapshot-20120601:1.104
	sid-snapshot-20120501:1.104
	binutils-2_22_branch:1.103.0.4
	gdb_7_4_1-2012-04-26-release:1.104
	sid-snapshot-20120401:1.104
	sid-snapshot-20120301:1.104
	sid-snapshot-20120201:1.104
	gdb_7_4-2012-01-24-release:1.104
	sid-snapshot-20120101:1.104
	gdb_7_4-branch:1.104.0.2
	gdb_7_4-2011-12-13-branchpoint:1.104
	sid-snapshot-20111201:1.104
	binutils-2_22:1.103
	sid-snapshot-20111101:1.104
	sid-snapshot-20111001:1.104
	binutils-2_22-branch:1.103.0.2
	binutils-2_22-branchpoint:1.103
	gdb_7_3_1-2011-09-04-release:1.98
	sid-snapshot-20110901:1.103
	sid-snapshot-20110801:1.103
	gdb_7_3-2011-07-26-release:1.98
	sid-snapshot-20110701:1.102
	sid-snapshot-20110601:1.101
	sid-snapshot-20110501:1.99
	gdb_7_3-branch:1.98.0.4
	gdb_7_3-2011-04-01-branchpoint:1.98
	sid-snapshot-20110401:1.98
	sid-snapshot-20110301:1.98
	sid-snapshot-20110201:1.98
	sid-snapshot-20110101:1.98
	binutils-2_21:1.98
	sid-snapshot-20101201:1.98
	binutils-2_21-branch:1.98.0.2
	binutils-2_21-branchpoint:1.98
	sid-snapshot-20101101:1.98
	sid-snapshot-20101001:1.98
	binutils-2_20_1:1.90.6.2
	gdb_7_2-2010-09-02-release:1.97
	sid-snapshot-20100901:1.98
	sid-snapshot-20100801:1.97
	gdb_7_2-branch:1.97.0.2
	gdb_7_2-2010-07-07-branchpoint:1.97
	sid-snapshot-20100701:1.97
	sid-snapshot-20100601:1.96
	sid-snapshot-20100501:1.96
	sid-snapshot-20100401:1.96
	gdb_7_1-2010-03-18-release:1.95
	sid-snapshot-20100301:1.95
	gdb_7_1-branch:1.95.0.2
	gdb_7_1-2010-02-18-branchpoint:1.95
	sid-snapshot-20100201:1.95
	sid-snapshot-20100101:1.93
	gdb_7_0_1-2009-12-22-release:1.91
	sid-snapshot-20091201:1.93
	sid-snapshot-20091101:1.91
	binutils-2_20:1.90.6.1
	gdb_7_0-2009-10-06-release:1.91
	sid-snapshot-20091001:1.91
	gdb_7_0-branch:1.91.0.2
	gdb_7_0-2009-09-16-branchpoint:1.91
	arc-sim-20090309:1.82
	binutils-arc-20081103-branch:1.83.0.12
	binutils-arc-20081103-branchpoint:1.83
	binutils-2_20-branch:1.90.0.6
	binutils-2_20-branchpoint:1.90
	sid-snapshot-20090901:1.90
	sid-snapshot-20090801:1.90
	msnyder-checkpoint-072509-branch:1.90.0.4
	msnyder-checkpoint-072509-branchpoint:1.90
	sid-snapshot-20090701:1.90
	dje-cgen-play1-branch:1.90.0.2
	dje-cgen-play1-branchpoint:1.90
	sid-snapshot-20090601:1.89
	sid-snapshot-20090501:1.89
	sid-snapshot-20090401:1.87
	arc-20081103-branch:1.83.0.10
	arc-20081103-branchpoint:1.83
	arc-insight_6_8-branch:1.82.0.14
	arc-insight_6_8-branchpoint:1.82
	insight_6_8-branch:1.82.0.12
	insight_6_8-branchpoint:1.82
	sid-snapshot-20090301:1.84
	binutils-2_19_1:1.83
	sid-snapshot-20090201:1.83
	sid-snapshot-20090101:1.83
	reverse-20081226-branch:1.83.0.8
	reverse-20081226-branchpoint:1.83
	sid-snapshot-20081201:1.83
	multiprocess-20081120-branch:1.83.0.6
	multiprocess-20081120-branchpoint:1.83
	sid-snapshot-20081101:1.83
	binutils-2_19:1.83
	sid-snapshot-20081001:1.83
	reverse-20080930-branch:1.83.0.4
	reverse-20080930-branchpoint:1.83
	binutils-2_19-branch:1.83.0.2
	binutils-2_19-branchpoint:1.83
	sid-snapshot-20080901:1.83
	sid-snapshot-20080801:1.83
	reverse-20080717-branch:1.82.0.10
	reverse-20080717-branchpoint:1.82
	sid-snapshot-20080701:1.82
	msnyder-reverse-20080609-branch:1.82.0.8
	msnyder-reverse-20080609-branchpoint:1.82
	drow-reverse-20070409-branch:1.78.0.2
	drow-reverse-20070409-branchpoint:1.78
	sid-snapshot-20080601:1.82
	sid-snapshot-20080501:1.82
	sid-snapshot-20080403:1.82
	sid-snapshot-20080401:1.82
	gdb_6_8-2008-03-27-release:1.82
	sid-snapshot-20080301:1.82
	gdb_6_8-branch:1.82.0.6
	gdb_6_8-2008-02-26-branchpoint:1.82
	sid-snapshot-20080201:1.82
	sid-snapshot-20080101:1.82
	sid-snapshot-20071201:1.82
	sid-snapshot-20071101:1.82
	gdb_6_7_1-2007-10-29-release:1.82
	gdb_6_7-2007-10-10-release:1.82
	sid-snapshot-20071001:1.82
	gdb_6_7-branch:1.82.0.4
	gdb_6_7-2007-09-07-branchpoint:1.82
	binutils-2_18:1.82
	binutils-2_18-branch:1.82.0.2
	binutils-2_18-branchpoint:1.82
	insight_6_6-20070208-release:1.77
	binutils-csl-coldfire-4_1-32:1.75.6.1
	binutils-csl-sourcerygxx-4_1-32:1.75.6.1
	gdb_6_6-2006-12-18-release:1.77
	binutils-csl-innovasic-fido-3_4_4-33:1.75.6.1
	binutils-csl-sourcerygxx-3_4_4-32:1.67
	binutils-csl-coldfire-4_1-30:1.75.6.1
	binutils-csl-sourcerygxx-4_1-30:1.75.6.1
	binutils-csl-coldfire-4_1-28:1.75.6.1
	binutils-csl-sourcerygxx-4_1-29:1.75.6.1
	binutils-csl-sourcerygxx-4_1-28:1.75.6.1
	gdb_6_6-branch:1.77.0.2
	gdb_6_6-2006-11-15-branchpoint:1.77
	binutils-csl-arm-2006q3-27:1.75.6.1
	binutils-csl-sourcerygxx-4_1-27:1.75.6.1
	binutils-csl-arm-2006q3-26:1.75.6.1
	binutils-csl-sourcerygxx-4_1-26:1.75.6.1
	binutils-csl-sourcerygxx-4_1-25:1.75.6.1
	binutils-csl-sourcerygxx-4_1-24:1.75.6.1
	binutils-csl-sourcerygxx-4_1-23:1.75.6.1
	insight_6_5-20061003-release:1.76
	gdb-csl-symbian-6_4_50_20060226-12:1.75
	binutils-csl-sourcerygxx-4_1-21:1.75.6.1
	binutils-csl-arm-2006q3-21:1.75.6.1
	binutils-csl-sourcerygxx-4_1-22:1.75.6.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.75.6.1
	binutils-csl-sourcerygxx-4_1-20:1.75.6.1
	binutils-csl-arm-2006q3-19:1.75.6.1
	binutils-csl-sourcerygxx-4_1-19:1.75.6.1
	binutils-csl-sourcerygxx-4_1-18:1.75.6.1
	binutils-csl-renesas-4_1-9:1.75.6.1
	gdb-csl-sourcerygxx-3_4_4-25:1.74
	binutils-csl-sourcerygxx-3_4_4-25:1.67
	nickrob-async-20060828-mergepoint:1.77
	gdb-csl-symbian-6_4_50_20060226-11:1.75
	binutils-csl-renesas-4_1-8:1.75
	binutils-csl-renesas-4_1-7:1.75
	binutils-csl-renesas-4_1-6:1.75
	gdb-csl-sourcerygxx-4_1-17:1.75
	binutils-csl-sourcerygxx-4_1-17:1.75
	gdb-csl-20060226-branch-local-2:1.75
	gdb-csl-sourcerygxx-4_1-14:1.75
	binutils-csl-sourcerygxx-4_1-14:1.75
	binutils-csl-sourcerygxx-4_1-15:1.75
	gdb-csl-sourcerygxx-4_1-13:1.75
	binutils-csl-sourcerygxx-4_1-13:1.75
	binutils-2_17:1.75.12.1
	gdb-csl-sourcerygxx-4_1-12:1.75
	binutils-csl-sourcerygxx-4_1-12:1.75
	gdb-csl-sourcerygxx-3_4_4-21:1.75
	binutils-csl-sourcerygxx-3_4_4-21:1.75
	gdb_6_5-20060621-release:1.76
	binutils-csl-wrs-linux-3_4_4-24:1.67
	binutils-csl-wrs-linux-3_4_4-23:1.67
	gdb-csl-sourcerygxx-4_1-9:1.75
	binutils-csl-sourcerygxx-4_1-9:1.75
	gdb-csl-sourcerygxx-4_1-8:1.75
	binutils-csl-sourcerygxx-4_1-8:1.75
	gdb-csl-sourcerygxx-4_1-7:1.75
	binutils-csl-sourcerygxx-4_1-7:1.75
	gdb-csl-arm-2006q1-6:1.75
	binutils-csl-arm-2006q1-6:1.75
	gdb-csl-sourcerygxx-4_1-6:1.75
	binutils-csl-sourcerygxx-4_1-6:1.75
	binutils-csl-wrs-linux-3_4_4-22:1.67
	gdb-csl-symbian-6_4_50_20060226-10:1.75
	gdb-csl-symbian-6_4_50_20060226-9:1.75
	gdb-csl-symbian-6_4_50_20060226-8:1.75
	gdb-csl-coldfire-4_1-11:1.75
	binutils-csl-coldfire-4_1-11:1.75
	gdb-csl-sourcerygxx-3_4_4-19:1.75
	binutils-csl-sourcerygxx-3_4_4-19:1.75
	gdb-csl-coldfire-4_1-10:1.75
	gdb_6_5-branch:1.76.0.6
	gdb_6_5-2006-05-14-branchpoint:1.76
	binutils-csl-coldfire-4_1-10:1.75
	gdb-csl-sourcerygxx-4_1-5:1.75
	binutils-csl-sourcerygxx-4_1-5:1.75
	nickrob-async-20060513-branch:1.76.0.4
	nickrob-async-20060513-branchpoint:1.76
	gdb-csl-sourcerygxx-4_1-4:1.75
	binutils-csl-sourcerygxx-4_1-4:1.75
	msnyder-reverse-20060502-branch:1.76.0.2
	msnyder-reverse-20060502-branchpoint:1.76
	binutils-csl-wrs-linux-3_4_4-21:1.67
	gdb-csl-morpho-4_1-4:1.75
	binutils-csl-morpho-4_1-4:1.75
	gdb-csl-sourcerygxx-3_4_4-17:1.75
	binutils-csl-sourcerygxx-3_4_4-17:1.75
	binutils-csl-wrs-linux-3_4_4-20:1.67
	readline_5_1-import-branch:1.75.0.14
	readline_5_1-import-branchpoint:1.75
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.75
	binutils-2_17-branch:1.75.0.12
	binutils-2_17-branchpoint:1.75
	gdb-csl-symbian-20060226-branch:1.75.0.10
	gdb-csl-symbian-20060226-branchpoint:1.75
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.75
	msnyder-reverse-20060331-branch:1.75.0.8
	msnyder-reverse-20060331-branchpoint:1.75
	binutils-csl-2_17-branch:1.75.0.6
	binutils-csl-2_17-branchpoint:1.75
	gdb-csl-available-20060303-branch:1.75.0.4
	gdb-csl-available-20060303-branchpoint:1.75
	gdb-csl-20060226-branch:1.75.0.2
	gdb-csl-20060226-branchpoint:1.75
	gdb_6_4-20051202-release:1.74
	msnyder-fork-checkpoint-branch:1.74.0.6
	msnyder-fork-checkpoint-branchpoint:1.74
	gdb-csl-gxxpro-6_3-branch:1.74.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.74
	gdb_6_4-branch:1.74.0.2
	gdb_6_4-2005-11-01-branchpoint:1.74
	gdb-csl-arm-20051020-branch:1.73.0.2
	gdb-csl-arm-20051020-branchpoint:1.73
	binutils-csl-gxxpro-3_4-branch:1.67.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.67
	binutils-2_16_1:1.67
	msnyder-tracepoint-checkpoint-branch:1.70.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.70
	gdb-csl-arm-20050325-2005-q1b:1.67
	binutils-csl-arm-2005q1b:1.67
	binutils-2_16:1.67
	gdb-csl-arm-20050325-2005-q1a:1.67
	binutils-csl-arm-2005q1a:1.67
	csl-arm-20050325-branch:1.67.0.6
	csl-arm-20050325-branchpoint:1.67
	binutils-csl-arm-2005q1-branch:1.67.0.4
	binutils-csl-arm-2005q1-branchpoint:1.67
	binutils-2_16-branch:1.67.0.2
	binutils-2_16-branchpoint:1.67
	csl-arm-2004-q3d:1.66
	gdb_6_3-20041109-release:1.65
	gdb_6_3-branch:1.65.0.2
	gdb_6_3-20041019-branchpoint:1.65
	csl-arm-2004-q3:1.64
	drow_intercu-merge-20040921:1.64
	drow_intercu-merge-20040915:1.64
	jimb-gdb_6_2-e500-branch:1.61.0.6
	jimb-gdb_6_2-e500-branchpoint:1.61
	gdb_6_2-20040730-release:1.61
	gdb_6_2-branch:1.61.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.61
	gdb_6_1_1-20040616-release:1.57
	binutils-2_15:1.57
	binutils-2_15-branchpoint:1.57
	csl-arm-2004-q1a:1.59
	csl-arm-2004-q1:1.57
	gdb_6_1-2004-04-05-release:1.57
	drow_intercu-merge-20040402:1.57
	drow_intercu-merge-20040327:1.57
	ezannoni_pie-20040323-branch:1.57.0.14
	ezannoni_pie-20040323-branchpoint:1.57
	cagney_tramp-20040321-mergepoint:1.57
	cagney_tramp-20040309-branch:1.57.0.12
	cagney_tramp-20040309-branchpoint:1.57
	gdb_6_1-branch:1.57.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.57
	drow_intercu-20040221-branch:1.57.0.8
	drow_intercu-20040221-branchpoint:1.57
	binutils-2_15-branch:1.57.0.6
	cagney_bfdfile-20040213-branch:1.57.0.4
	cagney_bfdfile-20040213-branchpoint:1.57
	drow-cplus-merge-20040208:1.57
	carlton_dictionary-20040126-merge:1.57
	cagney_bigcore-20040122-branch:1.57.0.2
	cagney_bigcore-20040122-branchpoint:1.57
	drow-cplus-merge-20040113:1.57
	csl-arm-2003-q4:1.57
	drow-cplus-merge-20031224:1.57
	drow-cplus-merge-20031220:1.57
	carlton_dictionary-20031215-merge:1.57
	drow-cplus-merge-20031214:1.57
	carlton-dictionary-20031111-merge:1.55
	gdb_6_0-2003-10-04-release:1.53
	kettenis_sparc-20030918-branch:1.54.0.6
	kettenis_sparc-20030918-branchpoint:1.54
	carlton_dictionary-20030917-merge:1.54
	ezannoni_pie-20030916-branchpoint:1.54
	ezannoni_pie-20030916-branch:1.54.0.4
	cagney_x86i386-20030821-branch:1.54.0.2
	cagney_x86i386-20030821-branchpoint:1.54
	carlton_dictionary-20030805-merge:1.54
	carlton_dictionary-20030627-merge:1.54
	gdb_6_0-branch:1.53.0.36
	gdb_6_0-2003-06-23-branchpoint:1.53
	jimb-ppc64-linux-20030613-branch:1.53.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.53
	binutils-2_14:1.53
	cagney_convert-20030606-branch:1.53.0.32
	cagney_convert-20030606-branchpoint:1.53
	cagney_writestrings-20030508-branch:1.53.0.30
	cagney_writestrings-20030508-branchpoint:1.53
	jimb-ppc64-linux-20030528-branch:1.53.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.53
	carlton_dictionary-20030523-merge:1.53
	cagney_fileio-20030521-branch:1.53.0.26
	cagney_fileio-20030521-branchpoint:1.53
	kettenis_i386newframe-20030517-mergepoint:1.53
	jimb-ppc64-linux-20030509-branch:1.53.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.53
	kettenis_i386newframe-20030504-mergepoint:1.53
	carlton_dictionary-20030430-merge:1.53
	binutils-2_14-branch:1.53.0.22
	binutils-2_14-branchpoint:1.53
	kettenis_i386newframe-20030419-branch:1.53.0.20
	kettenis_i386newframe-20030419-branchpoint:1.53
	carlton_dictionary-20030416-merge:1.53
	cagney_frameaddr-20030409-mergepoint:1.53
	kettenis_i386newframe-20030406-branch:1.53.0.18
	kettenis_i386newframe-20030406-branchpoint:1.53
	cagney_frameaddr-20030403-branchpoint:1.53
	cagney_frameaddr-20030403-branch:1.53.0.16
	cagney_framebase-20030330-mergepoint:1.53
	cagney_framebase-20030326-branch:1.53.0.14
	cagney_framebase-20030326-branchpoint:1.53
	cagney_lazyid-20030317-branch:1.53.0.12
	cagney_lazyid-20030317-branchpoint:1.53
	kettenis-i386newframe-20030316-mergepoint:1.53
	offbyone-20030313-branch:1.53.0.10
	offbyone-20030313-branchpoint:1.53
	kettenis-i386newframe-20030308-branch:1.53.0.8
	kettenis-i386newframe-20030308-branchpoint:1.53
	carlton_dictionary-20030305-merge:1.53
	cagney_offbyone-20030303-branch:1.53.0.6
	cagney_offbyone-20030303-branchpoint:1.53
	carlton_dictionary-20030207-merge:1.53
	interps-20030202-branch:1.53.0.4
	interps-20030202-branchpoint:1.53
	cagney-unwind-20030108-branch:1.53.0.2
	cagney-unwind-20030108-branchpoint:1.53
	binutils-2_13_2_1:1.45.2.1
	binutils-2_13_2:1.45.2.1
	carlton_dictionary-20021223-merge:1.53
	gdb_5_3-2002-12-12-release:1.52
	carlton_dictionary-20021115-merge:1.52
	binutils-2_13_1:1.45.2.1
	kseitz_interps-20021105-merge:1.52
	kseitz_interps-20021103-merge:1.52
	drow-cplus-merge-20021020:1.52
	drow-cplus-merge-20021025:1.52
	carlton_dictionary-20021025-merge:1.52
	carlton_dictionary-20021011-merge:1.52
	drow-cplus-branch:1.52.0.12
	drow-cplus-branchpoint:1.52
	kseitz_interps-20020930-merge:1.52
	carlton_dictionary-20020927-merge:1.52
	carlton_dictionary-branch:1.52.0.10
	carlton_dictionary-20020920-branchpoint:1.52
	sid-20020905-branchpoint:1.52
	sid-20020905-branch:1.52.0.8
	gdb_5_3-branch:1.52.0.6
	gdb_5_3-2002-09-04-branchpoint:1.52
	kseitz_interps-20020829-merge:1.52
	cagney_sysregs-20020825-branch:1.52.0.4
	cagney_sysregs-20020825-branchpoint:1.52
	readline_4_3-import-branch:1.52.0.2
	readline_4_3-import-branchpoint:1.52
	binutils-2_13:1.45
	gdb_5_2_1-2002-07-23-release:1.33
	binutils-2_13-branchpoint:1.45
	binutils-2_13-branch:1.45.0.2
	kseitz_interps-20020528-branch:1.40.0.2
	kseitz_interps-20020528-branchpoint:1.40
	cagney_regbuf-20020515-branch:1.39.0.2
	cagney_regbuf-20020515-branchpoint:1.39
	binutils-2_12_1:1.29.2.2
	jimb-macro-020506-branch:1.38.0.2
	jimb-macro-020506-branchpoint:1.38
	gdb_5_2-2002-04-29-release:1.33
	binutils-2_12:1.29.2.1
	gdb_5_2-branch:1.33.0.2
	gdb_5_2-2002-03-03-branchpoint:1.33
	binutils-2_12-branch:1.29.0.2
	binutils-2_12-branchpoint:1.29
	gdb_5_1_1-2002-01-24-release:1.20
	gdb_5_1_0_1-2002-01-03-release:1.20
	cygnus_cvs_20020108_pre:1.28
	gdb_5_1_0_1-2002-01-03-branch:1.20.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.20
	gdb_5_1-2001-11-21-release:1.20
	gdb_s390-2001-09-26-branch:1.20.0.4
	gdb_s390-2001-09-26-branchpoint:1.20
	gdb_5_1-2001-07-29-branch:1.20.0.2
	gdb_5_1-2001-07-29-branchpoint:1.20
	binutils-2_11_2:1.17.2.1
	binutils-2_11_1:1.17.2.1
	binutils-2_11:1.17
	x86_64versiong3:1.17
	binutils-2_11-branch:1.17.0.2
	insight-precleanup-2001-01-01:1.16
	binutils-2_10_1:1.6
	binutils-2_10:1.6
	gdb-premipsmulti-2000-06-06-branch:1.9.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.9
	gdb_5_0-2000-05-19-release:1.6
	gdb_4_18_2-2000-05-18-release:1.6
	gdb_4_95_1-2000-05-11-snapshot:1.6
	gdb_4_95_0-2000-04-27-snapshot:1.6
	gdb_5_0-2000-04-10-branch:1.6.0.4
	gdb_5_0-2000-04-10-branchpoint:1.6
	binutils-2_10-branch:1.6.0.2
	binutils-2_10-branchpoint:1.6
	binutils_latest_snapshot:1.114
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.114
date	2013.08.21.08.15.23;	author gingold;	state Exp;
branches;
next	1.113;

1.113
date	2013.07.24.14.12.40;	author gingold;	state Exp;
branches;
next	1.112;

1.112
date	2013.07.02.12.58.17;	author gingold;	state Exp;
branches;
next	1.111;

1.111
date	2013.07.02.07.38.51;	author gingold;	state Exp;
branches;
next	1.110;

1.110
date	2013.07.02.07.34.38;	author gingold;	state Exp;
branches;
next	1.109;

1.109
date	2013.05.16.15.41.40;	author gingold;	state Exp;
branches;
next	1.108;

1.108
date	2012.10.16.22.47.03;	author brobecke;	state Exp;
branches;
next	1.107;

1.107
date	2012.08.20.14.32.30;	author tromey;	state Exp;
branches;
next	1.106;

1.106
date	2012.07.24.21.06.57;	author ccoutant;	state Exp;
branches;
next	1.105;

1.105
date	2012.07.13.14.22.44;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	2011.09.30.10.39.44;	author gingold;	state Exp;
branches;
next	1.103;

1.103
date	2011.07.11.15.03.04;	author clm;	state Exp;
branches;
next	1.102;

1.102
date	2011.06.06.01.26.02;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2011.05.18.07.58.30;	author gingold;	state Exp;
branches;
next	1.100;

1.100
date	2011.05.04.11.05.14;	author gingold;	state Exp;
branches;
next	1.99;

1.99
date	2011.04.18.13.59.06;	author gingold;	state Exp;
branches;
next	1.98;

1.98
date	2010.08.18.12.24.04;	author palves;	state Exp;
branches;
next	1.97;

1.97
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2010.03.24.15.41.58;	author hjl;	state Exp;
branches;
next	1.95;

1.95
date	2010.01.26.13.42.26;	author gingold;	state Exp;
branches;
next	1.94;

1.94
date	2010.01.23.12.05.31;	author rsandifo;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.23.14.41.28;	author pbrook;	state Exp;
branches;
next	1.92;

1.92
date	2009.11.19.10.06.03;	author gingold;	state Exp;
branches;
next	1.91;

1.91
date	2009.09.05.07.56.21;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	2009.06.02.18.51.33;	author rsandifo;	state Exp;
branches
	1.90.6.1;
next	1.89;

1.89
date	2009.04.16.23.06.59;	author rsandifo;	state Exp;
branches;
next	1.88;

1.88
date	2009.04.01.20.04.28;	author rsandifo;	state Exp;
branches;
next	1.87;

1.87
date	2009.03.14.09.34.27;	author rsandifo;	state Exp;
branches;
next	1.86;

1.86
date	2009.03.14.09.17.32;	author rsandifo;	state Exp;
branches;
next	1.85;

1.85
date	2009.03.14.09.16.00;	author rsandifo;	state Exp;
branches;
next	1.84;

1.84
date	2009.02.18.18.23.06;	author davek;	state Exp;
branches;
next	1.83;

1.83
date	2008.07.18.11.30.22;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2007.07.03.14.26.39;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.27.11.54.09;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2007.04.27.03.37.42;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2007.03.26.12.22.59;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2006.04.27.01.19.35;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2005.11.24.06.02.07;	author amodra;	state Exp;
branches
	1.75.6.1
	1.75.12.1;
next	1.74;

1.74
date	2005.10.24.02.50.27;	author hjl;	state Exp;
branches;
next	1.73;

1.73
date	2005.10.15.15.38.12;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2005.07.05.09.45.53;	author jakub;	state Exp;
branches;
next	1.71;

1.71
date	2005.06.07.03.13.04;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2005.05.23.17.44.52;	author fnf;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.04.15.53.03;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2004.10.21.15.28.16;	author hjl;	state Exp;
branches;
next	1.65;

1.65
date	2004.10.09.02.51.30;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2004.08.16.00.25.13;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2004.08.13.03.15.56;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.61;

1.61
date	2004.06.24.04.46.15;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2004.05.17.16.40.00;	author bwilson;	state Exp;
branches;
next	1.59;

1.59
date	2004.04.30.14.23.39;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2004.04.22.14.45.31;	author jakub;	state Exp;
branches;
next	1.57;

1.57
date	2003.12.01.06.33.00;	author kazu;	state Exp;
branches
	1.57.8.1;
next	1.56;

1.56
date	2003.11.24.18.06.40;	author kazu;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.16.04.11.04;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.25.06.40.18;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2002.11.30.08.39.35;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2002.08.22.05.13.04;	author amodra;	state Exp;
branches
	1.52.10.1
	1.52.12.1;
next	1.51;

1.51
date	2002.08.06.08.59.34;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2002.08.06.08.51.42;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2002.08.06.05.52.29;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2002.08.06.03.18.25;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2002.08.06.02.29.24;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2002.07.30.05.49.24;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.25.07.40.49;	author amodra;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2002.06.12.16.04.39;	author trix;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.07.15.04.47;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.05.03.43.09;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.31.01.07.21;	author trix;	state Exp;
branches;
next	1.40;

1.40
date	2002.05.15.00.18.55;	author amodra;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2002.05.10.21.20.10;	author trix;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2002.05.04.10.07.17;	author trix;	state Exp;
branches;
next	1.37;

1.37
date	2002.04.28.14.34.38;	author trix;	state Exp;
branches;
next	1.36;

1.36
date	2002.04.04.19.53.35;	author drow;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.20.16.49.10;	author trix;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.18.12.45.35;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.02.13.23.57;	author trix;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.21.03.57.31;	author trix;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.19.05.01.26;	author trix;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.11.02.17.39;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.08.00.28.36;	author aldyh;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2001.12.31.04.08.23;	author trix;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.22.17.18.34;	author trix;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.20.23.30.34;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.18.09.57.22;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.25.09.47.34;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.23.17.05.52;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.10.06.00.53;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.09.14.38.04;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.25.21.23.48;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.24.20.50.50;	author trix;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.23.11.45.53;	author kazu;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.12.21.18.40.21;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.22.01.08.53;	author kazu;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.16.00.54.12;	author kazu;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.15.20.20.52;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.06.21.21.51;	author geoffk;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.16.00.34.19;	author geoffk;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.25.19.25.40;	author geoffk;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.06.01.47.17;	author cpopetz;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.28.20.02.30;	author cpopetz;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.26.15.09.42;	author cpopetz;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.19.00.59.26;	author geoffk;	state Exp;
branches;
next	1.5;

1.5
date	99.12.10.18.51.34;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	99.12.10.01.41.21;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.07.19.14.55.15;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.10.28.43;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.90.6.1
date	2009.09.05.08.00.18;	author nickc;	state Exp;
branches;
next	1.90.6.2;

1.90.6.2
date	2010.01.30.09.58.01;	author rsandifo;	state Exp;
branches;
next	;

1.75.6.1
date	2006.08.22.15.08.28;	author jsm28;	state Exp;
branches;
next	;

1.75.12.1
date	2006.04.27.01.20.26;	author amodra;	state Exp;
branches;
next	;

1.57.8.1
date	2004.09.16.17.00.13;	author drow;	state Exp;
branches;
next	;

1.52.10.1
date	2002.12.23.19.37.27;	author carlton;	state Exp;
branches;
next	1.52.10.2;

1.52.10.2
date	2003.06.27.21.49.06;	author carlton;	state Exp;
branches;
next	1.52.10.3;

1.52.10.3
date	2003.11.11.23.50.07;	author carlton;	state Exp;
branches;
next	1.52.10.4;

1.52.10.4
date	2003.12.15.23.59.14;	author carlton;	state Exp;
branches;
next	;

1.52.12.1
date	2003.12.14.20.26.35;	author drow;	state Exp;
branches;
next	;

1.45.2.1
date	2002.09.23.22.12.38;	author drow;	state Exp;
branches;
next	;

1.40.2.1
date	2002.06.20.01.29.45;	author kseitz;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2002.07.22.21.46.39;	author kseitz;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2002.08.09.18.34.10;	author kseitz;	state Exp;
branches;
next	1.40.2.4;

1.40.2.4
date	2002.08.30.22.52.35;	author kseitz;	state Exp;
branches;
next	;

1.39.2.1
date	2002.06.15.16.42.34;	author cagney;	state Exp;
branches;
next	;

1.29.2.1
date	2002.02.10.22.16.35;	author drow;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2002.03.20.16.53.20;	author trix;	state Exp;
branches;
next	;

1.17.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.114
log
@2013-08-21  Tristan Gingold  <gingold@@adacore.com>

	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Also count
	.ovrflo sections.
	* coffcode.h (coff_compute_section_file_positions): Force
	match between file offset and vma offset.
@
text
@/* BFD back-end for IBM RS/6000 "XCOFF" files.
   Copyright 1990-1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
   Written by Metin G. Ozisik, Mimi Phuong-Thao Vo, and John Gilmore.
   Archive support from Damon A. Permezel.
   Contributed by IBM Corporation and Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "libiberty.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "coff/xcoff.h"
#include "coff/rs6000.h"
#include "libcoff.h"
#include "libxcoff.h"

extern bfd_boolean _bfd_xcoff_mkobject (bfd *);
extern bfd_boolean _bfd_xcoff_copy_private_bfd_data (bfd *, bfd *);
extern bfd_boolean _bfd_xcoff_is_local_label_name (bfd *, const char *);
extern reloc_howto_type *_bfd_xcoff_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type);
extern bfd_boolean _bfd_xcoff_slurp_armap (bfd *);
extern const bfd_target *_bfd_xcoff_archive_p (bfd *);
extern void * _bfd_xcoff_read_ar_hdr (bfd *);
extern bfd *_bfd_xcoff_openr_next_archived_file (bfd *, bfd *);
extern int _bfd_xcoff_stat_arch_elt (bfd *, struct stat *);
extern bfd_boolean _bfd_xcoff_write_armap
  (bfd *, unsigned int, struct orl *, unsigned int, int);
extern bfd_boolean _bfd_xcoff_write_archive_contents (bfd *);
extern int _bfd_xcoff_sizeof_headers (bfd *, struct bfd_link_info *);
extern void _bfd_xcoff_swap_sym_in (bfd *, void *, void *);
extern unsigned int _bfd_xcoff_swap_sym_out (bfd *, void *, void *);
extern void _bfd_xcoff_swap_aux_in (bfd *, void *, int, int, int, int, void *);
extern unsigned int _bfd_xcoff_swap_aux_out
  (bfd *, void *, int, int, int, int, void *);
static void xcoff_swap_reloc_in (bfd *, void *, void *);
static unsigned int xcoff_swap_reloc_out (bfd *, void *, void *);

/* Forward declare xcoff_rtype2howto for coffcode.h macro.  */
void xcoff_rtype2howto (arelent *, struct internal_reloc *);

/* coffcode.h needs these to be defined.  */
#define RS6000COFF_C 1

#define SELECT_RELOC(internal, howto)					\
  {									\
    internal.r_type = howto->type;					\
    internal.r_size =							\
      ((howto->complain_on_overflow == complain_overflow_signed		\
	? 0x80								\
	: 0)								\
       | (howto->bitsize - 1));						\
  }

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (3)
#define COFF_LONG_FILENAMES
#define NO_COFF_SYMBOLS
#define RTYPE2HOWTO(cache_ptr, dst) xcoff_rtype2howto (cache_ptr, dst)
#define coff_mkobject _bfd_xcoff_mkobject
#define coff_bfd_copy_private_bfd_data _bfd_xcoff_copy_private_bfd_data
#define coff_bfd_is_local_label_name _bfd_xcoff_is_local_label_name
#define coff_bfd_reloc_type_lookup _bfd_xcoff_reloc_type_lookup
#define coff_bfd_reloc_name_lookup _bfd_xcoff_reloc_name_lookup
#ifdef AIX_CORE
extern const bfd_target * rs6000coff_core_p (bfd *abfd);
extern bfd_boolean rs6000coff_core_file_matches_executable_p
  (bfd *cbfd, bfd *ebfd);
extern char *rs6000coff_core_file_failing_command (bfd *abfd);
extern int rs6000coff_core_file_failing_signal (bfd *abfd);
#define CORE_FILE_P rs6000coff_core_p
#define coff_core_file_failing_command \
  rs6000coff_core_file_failing_command
#define coff_core_file_failing_signal \
  rs6000coff_core_file_failing_signal
#define coff_core_file_matches_executable_p \
  rs6000coff_core_file_matches_executable_p
#define coff_core_file_pid \
  _bfd_nocore_core_file_pid
#else
#define CORE_FILE_P _bfd_dummy_target
#define coff_core_file_failing_command \
  _bfd_nocore_core_file_failing_command
#define coff_core_file_failing_signal \
  _bfd_nocore_core_file_failing_signal
#define coff_core_file_matches_executable_p \
  _bfd_nocore_core_file_matches_executable_p
#define coff_core_file_pid \
  _bfd_nocore_core_file_pid
#endif
#define coff_SWAP_sym_in _bfd_xcoff_swap_sym_in
#define coff_SWAP_sym_out _bfd_xcoff_swap_sym_out
#define coff_SWAP_aux_in _bfd_xcoff_swap_aux_in
#define coff_SWAP_aux_out _bfd_xcoff_swap_aux_out
#define coff_swap_reloc_in xcoff_swap_reloc_in
#define coff_swap_reloc_out xcoff_swap_reloc_out
#define NO_COFF_RELOCS

#ifndef bfd_pe_print_pdata
#define bfd_pe_print_pdata	NULL
#endif

#include "coffcode.h"

/* The main body of code is in coffcode.h.  */

static const char *normalize_filename (bfd *);
static bfd_boolean xcoff_write_armap_old
  (bfd *, unsigned int, struct orl *, unsigned int, int);
static bfd_boolean xcoff_write_armap_big
  (bfd *, unsigned int, struct orl *, unsigned int, int);
static bfd_boolean xcoff_write_archive_contents_old (bfd *);
static bfd_boolean xcoff_write_archive_contents_big (bfd *);
static void xcoff_swap_ldhdr_in (bfd *, const void *, struct internal_ldhdr *);
static void xcoff_swap_ldhdr_out (bfd *, const struct internal_ldhdr *, void *);
static void xcoff_swap_ldsym_in (bfd *, const void *, struct internal_ldsym *);
static void xcoff_swap_ldsym_out (bfd *, const struct internal_ldsym *, void *);
static void xcoff_swap_ldrel_in (bfd *, const void *, struct internal_ldrel *);
static void xcoff_swap_ldrel_out (bfd *, const struct internal_ldrel *, void *);
static bfd_boolean xcoff_ppc_relocate_section
  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
   struct internal_reloc *, struct internal_syment *, asection **);
static bfd_boolean _bfd_xcoff_put_ldsymbol_name
  (bfd *, struct xcoff_loader_info *, struct internal_ldsym *, const char *);
static asection *xcoff_create_csect_from_smclas
  (bfd *, union internal_auxent *, const char *);
static bfd_boolean xcoff_is_lineno_count_overflow (bfd *, bfd_vma);
static bfd_boolean xcoff_is_reloc_count_overflow (bfd *, bfd_vma);
static bfd_vma xcoff_loader_symbol_offset (bfd *, struct internal_ldhdr *);
static bfd_vma xcoff_loader_reloc_offset (bfd *, struct internal_ldhdr *);
static bfd_boolean xcoff_generate_rtinit
  (bfd *, const char *, const char *, bfd_boolean);
static bfd_boolean do_pad (bfd *, unsigned int);
static bfd_boolean do_copy (bfd *, bfd *);

/* Relocation functions */
static bfd_boolean xcoff_reloc_type_br (XCOFF_RELOC_FUNCTION_ARGS);

static bfd_boolean xcoff_complain_overflow_dont_func
  (XCOFF_COMPLAIN_FUNCTION_ARGS);
static bfd_boolean xcoff_complain_overflow_bitfield_func
  (XCOFF_COMPLAIN_FUNCTION_ARGS);
static bfd_boolean xcoff_complain_overflow_signed_func
  (XCOFF_COMPLAIN_FUNCTION_ARGS);
static bfd_boolean xcoff_complain_overflow_unsigned_func
  (XCOFF_COMPLAIN_FUNCTION_ARGS);

bfd_boolean (*xcoff_calculate_relocation[XCOFF_MAX_CALCULATE_RELOCATION])
  (XCOFF_RELOC_FUNCTION_ARGS) =
{
  xcoff_reloc_type_pos,	 /* R_POS   (0x00) */
  xcoff_reloc_type_neg,	 /* R_NEG   (0x01) */
  xcoff_reloc_type_rel,	 /* R_REL   (0x02) */
  xcoff_reloc_type_toc,	 /* R_TOC   (0x03) */
  xcoff_reloc_type_fail, /* R_RTB   (0x04) */
  xcoff_reloc_type_toc,	 /* R_GL    (0x05) */
  xcoff_reloc_type_toc,	 /* R_TCL   (0x06) */
  xcoff_reloc_type_fail, /*	    (0x07) */
  xcoff_reloc_type_ba,	 /* R_BA    (0x08) */
  xcoff_reloc_type_fail, /*	    (0x09) */
  xcoff_reloc_type_br,	 /* R_BR    (0x0a) */
  xcoff_reloc_type_fail, /*	    (0x0b) */
  xcoff_reloc_type_pos,	 /* R_RL    (0x0c) */
  xcoff_reloc_type_pos,	 /* R_RLA   (0x0d) */
  xcoff_reloc_type_fail, /*	    (0x0e) */
  xcoff_reloc_type_noop, /* R_REF   (0x0f) */
  xcoff_reloc_type_fail, /*	    (0x10) */
  xcoff_reloc_type_fail, /*	    (0x11) */
  xcoff_reloc_type_toc,	 /* R_TRL   (0x12) */
  xcoff_reloc_type_toc,	 /* R_TRLA  (0x13) */
  xcoff_reloc_type_fail, /* R_RRTBI (0x14) */
  xcoff_reloc_type_fail, /* R_RRTBA (0x15) */
  xcoff_reloc_type_ba,	 /* R_CAI   (0x16) */
  xcoff_reloc_type_crel, /* R_CREL  (0x17) */
  xcoff_reloc_type_ba,	 /* R_RBA   (0x18) */
  xcoff_reloc_type_ba,	 /* R_RBAC  (0x19) */
  xcoff_reloc_type_br,	 /* R_RBR   (0x1a) */
  xcoff_reloc_type_ba,	 /* R_RBRC  (0x1b) */
};

bfd_boolean (*xcoff_complain_overflow[XCOFF_MAX_COMPLAIN_OVERFLOW])
  (XCOFF_COMPLAIN_FUNCTION_ARGS) =
{
  xcoff_complain_overflow_dont_func,
  xcoff_complain_overflow_bitfield_func,
  xcoff_complain_overflow_signed_func,
  xcoff_complain_overflow_unsigned_func,
};

/* Information about one member of an archive.  */
struct member_layout {
  /* The archive member that this structure describes.  */
  bfd *member;

  /* The number of bytes of padding that must be inserted before the
     start of the member in order to ensure that the section contents
     are correctly aligned.  */
  unsigned int leading_padding;

  /* The offset of MEMBER from the start of the archive (i.e. the end
     of the leading padding).  */
  file_ptr offset;

  /* The normalized name of MEMBER.  */
  const char *name;

  /* The length of NAME, without padding.  */
  bfd_size_type namlen;

  /* The length of NAME, with padding.  */
  bfd_size_type padded_namlen;

  /* The size of MEMBER's header, including the name and magic sequence.  */
  bfd_size_type header_size;

  /* The size of the MEMBER's contents.  */
  bfd_size_type contents_size;

  /* The number of bytes of padding that must be inserted after MEMBER
     in order to preserve even alignment.  */
  bfd_size_type trailing_padding;
};

/* A structure used for iterating over the members of an archive.  */
struct archive_iterator {
  /* The archive itself.  */
  bfd *archive;

  /* Information about the current archive member.  */
  struct member_layout current;

  /* Information about the next archive member.  MEMBER is null if there
     are no more archive members, in which case OFFSET is the offset of
     the first unused byte.  */
  struct member_layout next;
};

/* Initialize INFO so that it describes member MEMBER of archive ARCHIVE.
   OFFSET is the even-padded offset of MEMBER, not including any leading
   padding needed for section alignment.  */

static void
member_layout_init (struct member_layout *info, bfd *archive,
		    bfd *member, file_ptr offset)
{
  info->member = member;
  info->leading_padding = 0;
  if (member)
    {
      info->name = normalize_filename (member);
      info->namlen = strlen (info->name);
      info->padded_namlen = info->namlen + (info->namlen & 1);
      if (xcoff_big_format_p (archive))
	info->header_size = SIZEOF_AR_HDR_BIG;
      else
	info->header_size = SIZEOF_AR_HDR;
      info->header_size += info->padded_namlen + SXCOFFARFMAG;
      info->contents_size = arelt_size (member);
      info->trailing_padding = info->contents_size & 1;

      if (bfd_check_format (member, bfd_object)
	  && bfd_get_flavour (member) == bfd_target_xcoff_flavour
	  && (member->flags & DYNAMIC) != 0)
	info->leading_padding
	  = (-(offset + info->header_size)
	     & ((1 << bfd_xcoff_text_align_power (member)) - 1));
    }
  info->offset = offset + info->leading_padding;
}

/* Set up ITERATOR to iterate through archive ARCHIVE.  */

static void
archive_iterator_begin (struct archive_iterator *iterator,
			bfd *archive)
{
  iterator->archive = archive;
  member_layout_init (&iterator->next, archive, archive->archive_head,
		      xcoff_big_format_p (archive)
		      ? SIZEOF_AR_FILE_HDR_BIG
		      : SIZEOF_AR_FILE_HDR);
}

/* Make ITERATOR visit the first unvisited archive member.  Return true
   on success; return false if all members have been visited.  */

static bfd_boolean
archive_iterator_next (struct archive_iterator *iterator)
{
  if (!iterator->next.member)
    return FALSE;

  iterator->current = iterator->next;
  member_layout_init (&iterator->next, iterator->archive,
		      iterator->current.member->archive_next,
		      iterator->current.offset
		      + iterator->current.header_size
		      + iterator->current.contents_size
		      + iterator->current.trailing_padding);
  return TRUE;
}

/* We use our own tdata type.  Its first field is the COFF tdata type,
   so the COFF routines are compatible.  */

bfd_boolean
_bfd_xcoff_mkobject (bfd *abfd)
{
  coff_data_type *coff;
  bfd_size_type amt = sizeof (struct xcoff_tdata);

  abfd->tdata.xcoff_obj_data = (struct xcoff_tdata *) bfd_zalloc (abfd, amt);
  if (abfd->tdata.xcoff_obj_data == NULL)
    return FALSE;
  coff = coff_data (abfd);
  coff->symbols = (coff_symbol_type *) NULL;
  coff->conversion_table = (unsigned int *) NULL;
  coff->raw_syments = (struct coff_ptr_struct *) NULL;
  coff->relocbase = 0;

  xcoff_data (abfd)->modtype = ('1' << 8) | 'L';

  /* We set cputype to -1 to indicate that it has not been
     initialized.  */
  xcoff_data (abfd)->cputype = -1;

  xcoff_data (abfd)->csects = NULL;
  xcoff_data (abfd)->debug_indices = NULL;

  /* text section alignment is different than the default */
  bfd_xcoff_text_align_power (abfd) = 2;

  return TRUE;
}

/* Copy XCOFF data from one BFD to another.  */

bfd_boolean
_bfd_xcoff_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  struct xcoff_tdata *ix, *ox;
  asection *sec;

  if (ibfd->xvec != obfd->xvec)
    return TRUE;
  ix = xcoff_data (ibfd);
  ox = xcoff_data (obfd);
  ox->full_aouthdr = ix->full_aouthdr;
  ox->toc = ix->toc;
  if (ix->sntoc == 0)
    ox->sntoc = 0;
  else
    {
      sec = coff_section_from_bfd_index (ibfd, ix->sntoc);
      if (sec == NULL)
	ox->sntoc = 0;
      else
	ox->sntoc = sec->output_section->target_index;
    }
  if (ix->snentry == 0)
    ox->snentry = 0;
  else
    {
      sec = coff_section_from_bfd_index (ibfd, ix->snentry);
      if (sec == NULL)
	ox->snentry = 0;
      else
	ox->snentry = sec->output_section->target_index;
    }
  bfd_xcoff_text_align_power (obfd) = bfd_xcoff_text_align_power (ibfd);
  bfd_xcoff_data_align_power (obfd) = bfd_xcoff_data_align_power (ibfd);
  ox->modtype = ix->modtype;
  ox->cputype = ix->cputype;
  ox->maxdata = ix->maxdata;
  ox->maxstack = ix->maxstack;
  return TRUE;
}

/* I don't think XCOFF really has a notion of local labels based on
   name.  This will mean that ld -X doesn't actually strip anything.
   The AIX native linker does not have a -X option, and it ignores the
   -x option.  */

bfd_boolean
_bfd_xcoff_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,
                                const char *name ATTRIBUTE_UNUSED)
{
  return FALSE;
}

static const struct dwarf_debug_section xcoff_debug_sections[] =
{
  { ".dwabrev",		NULL },
  { ".dwarnge",		NULL },
  { NULL,	NULL }, /* .debug_frame */
  { ".dwinfo",		NULL },
  { ".dwline",		NULL },
  { NULL,	NULL }, /* .debug_loc */
  { NULL,	NULL }, /* .debug_macinfo */
  { NULL,	NULL }, /* .debug_macro */
  { ".dwpbnms",		NULL },
  { ".dwpbtyp",		NULL },
  { ".dwrnges",		NULL },
  { NULL,	NULL }, /* .debug_static_func */
  { NULL,	NULL }, /* .debug_static_vars */
  { ".dwstr",	NULL },
  { NULL,	NULL }, /* .debug_types */
  /* GNU DWARF 1 extensions */
  { NULL,	NULL }, /* .debug_sfnames */
  { NULL,	NULL }, /* .debug_srcinfo */
  /* SGI/MIPS DWARF 2 extensions */
  { NULL,	NULL }, /* .debug_funcnames */
  { NULL,	NULL }, /* .debug_typenames */
  { NULL,	NULL }, /* .debug_varnames */
  { NULL,	NULL }, /* .debug_weaknames */
  { NULL,	NULL },
};

static bfd_boolean
xcoff_find_nearest_line (bfd *abfd,
                         asection *section,
                         asymbol **symbols,
                         bfd_vma offset,
                         const char **filename_ptr,
                         const char **functionname_ptr,
                         unsigned int *line_ptr)
{
  return coff_find_nearest_line_with_names (abfd, xcoff_debug_sections,
                                            section, symbols, offset,
                                            filename_ptr, functionname_ptr,
                                            line_ptr);
}

static bfd_boolean
xcoff_find_nearest_line_discriminator (bfd *abfd,
                                      asection *section,
                                      asymbol **symbols,
                                      bfd_vma offset,
                                      const char **filename_ptr,
                                      const char **functionname_ptr,
                                      unsigned int *line_ptr,
                                      unsigned int *discriminator)
{
  *discriminator = 0;
  return coff_find_nearest_line_with_names (abfd, xcoff_debug_sections,
                                            section, symbols, offset,
                                            filename_ptr, functionname_ptr,
                                            line_ptr);
}


void
_bfd_xcoff_swap_sym_in (bfd *abfd, void * ext1, void * in1)
{
  SYMENT *ext = (SYMENT *)ext1;
  struct internal_syment * in = (struct internal_syment *)in1;

  if (ext->e.e_name[0] != 0)
    {
      memcpy (in->_n._n_name, ext->e.e_name, SYMNMLEN);
    }
  else
    {
      in->_n._n_n._n_zeroes = 0;
      in->_n._n_n._n_offset = H_GET_32 (abfd, ext->e.e.e_offset);
    }

  in->n_value = H_GET_32 (abfd, ext->e_value);
  in->n_scnum = H_GET_16 (abfd, ext->e_scnum);
  in->n_type = H_GET_16 (abfd, ext->e_type);
  in->n_sclass = H_GET_8 (abfd, ext->e_sclass);
  in->n_numaux = H_GET_8 (abfd, ext->e_numaux);
}

unsigned int
_bfd_xcoff_swap_sym_out (bfd *abfd, void * inp, void * extp)
{
  struct internal_syment *in = (struct internal_syment *)inp;
  SYMENT *ext =(SYMENT *)extp;

  if (in->_n._n_name[0] != 0)
    {
      memcpy (ext->e.e_name, in->_n._n_name, SYMNMLEN);
    }
  else
    {
      H_PUT_32 (abfd, 0, ext->e.e.e_zeroes);
      H_PUT_32 (abfd, in->_n._n_n._n_offset, ext->e.e.e_offset);
    }

  H_PUT_32 (abfd, in->n_value, ext->e_value);
  H_PUT_16 (abfd, in->n_scnum, ext->e_scnum);
  H_PUT_16 (abfd, in->n_type, ext->e_type);
  H_PUT_8 (abfd, in->n_sclass, ext->e_sclass);
  H_PUT_8 (abfd, in->n_numaux, ext->e_numaux);
  return bfd_coff_symesz (abfd);
}

void
_bfd_xcoff_swap_aux_in (bfd *abfd, void * ext1, int type, int in_class,
                        int indx, int numaux, void * in1)
{
  AUXENT * ext = (AUXENT *)ext1;
  union internal_auxent *in = (union internal_auxent *)in1;

  switch (in_class)
    {
    case C_FILE:
      if (ext->x_file.x_n.x_fname[0] == 0)
	{
	  in->x_file.x_n.x_zeroes = 0;
	  in->x_file.x_n.x_offset =
	    H_GET_32 (abfd, ext->x_file.x_n.x_n.x_offset);
	}
      else
	{
	  if (numaux > 1)
	    {
	      if (indx == 0)
		memcpy (in->x_file.x_fname, ext->x_file.x_n.x_fname,
			numaux * sizeof (AUXENT));
	    }
	  else
	    {
	      memcpy (in->x_file.x_fname, ext->x_file.x_n.x_fname, FILNMLEN);
	    }
	}
      goto end;

      /* RS/6000 "csect" auxents */
    case C_EXT:
    case C_AIX_WEAKEXT:
    case C_HIDEXT:
      if (indx + 1 == numaux)
	{
	  in->x_csect.x_scnlen.l = H_GET_32 (abfd, ext->x_csect.x_scnlen);
	  in->x_csect.x_parmhash = H_GET_32 (abfd, ext->x_csect.x_parmhash);
	  in->x_csect.x_snhash   = H_GET_16 (abfd, ext->x_csect.x_snhash);
	  /* We don't have to hack bitfields in x_smtyp because it's
	     defined by shifts-and-ands, which are equivalent on all
	     byte orders.  */
	  in->x_csect.x_smtyp    = H_GET_8 (abfd, ext->x_csect.x_smtyp);
	  in->x_csect.x_smclas   = H_GET_8 (abfd, ext->x_csect.x_smclas);
	  in->x_csect.x_stab     = H_GET_32 (abfd, ext->x_csect.x_stab);
	  in->x_csect.x_snstab   = H_GET_16 (abfd, ext->x_csect.x_snstab);
	  goto end;
	}
      break;

    case C_STAT:
    case C_LEAFSTAT:
    case C_HIDDEN:
      if (type == T_NULL)
	{
	  in->x_scn.x_scnlen = H_GET_32 (abfd, ext->x_scn.x_scnlen);
	  in->x_scn.x_nreloc = H_GET_16 (abfd, ext->x_scn.x_nreloc);
	  in->x_scn.x_nlinno = H_GET_16 (abfd, ext->x_scn.x_nlinno);
	  /* PE defines some extra fields; we zero them out for
	     safety.  */
	  in->x_scn.x_checksum = 0;
	  in->x_scn.x_associated = 0;
	  in->x_scn.x_comdat = 0;

	  goto end;
	}
      break;
    }

  in->x_sym.x_tagndx.l = H_GET_32 (abfd, ext->x_sym.x_tagndx);
  in->x_sym.x_tvndx = H_GET_16 (abfd, ext->x_sym.x_tvndx);

  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)
      || ISTAG (in_class))
    {
      in->x_sym.x_fcnary.x_fcn.x_lnnoptr =
	H_GET_32 (abfd, ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      in->x_sym.x_fcnary.x_fcn.x_endndx.l =
	H_GET_32 (abfd, ext->x_sym.x_fcnary.x_fcn.x_endndx);
    }
  else
    {
      in->x_sym.x_fcnary.x_ary.x_dimen[0] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      in->x_sym.x_fcnary.x_ary.x_dimen[1] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      in->x_sym.x_fcnary.x_ary.x_dimen[2] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      in->x_sym.x_fcnary.x_ary.x_dimen[3] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }

  if (ISFCN (type))
    {
      in->x_sym.x_misc.x_fsize = H_GET_32 (abfd, ext->x_sym.x_misc.x_fsize);
    }
  else
    {
      in->x_sym.x_misc.x_lnsz.x_lnno =
	H_GET_16 (abfd, ext->x_sym.x_misc.x_lnsz.x_lnno);
      in->x_sym.x_misc.x_lnsz.x_size =
	H_GET_16 (abfd, ext->x_sym.x_misc.x_lnsz.x_size);
    }

 end: ;
  /* The semicolon is because MSVC doesn't like labels at
     end of block.  */
}

unsigned int
_bfd_xcoff_swap_aux_out (bfd *abfd, void * inp, int type, int in_class,
                         int indx ATTRIBUTE_UNUSED,
                         int numaux ATTRIBUTE_UNUSED,
                         void * extp)
{
  union internal_auxent *in = (union internal_auxent *)inp;
  AUXENT *ext = (AUXENT *)extp;

  memset (ext, 0, bfd_coff_auxesz (abfd));
  switch (in_class)
    {
    case C_FILE:
      if (in->x_file.x_fname[0] == 0)
	{
	  H_PUT_32 (abfd, 0, ext->x_file.x_n.x_n.x_zeroes);
	  H_PUT_32 (abfd, in->x_file.x_n.x_offset,
                    ext->x_file.x_n.x_n.x_offset);
	}
      else
	{
	  memcpy (ext->x_file.x_n.x_fname, in->x_file.x_fname, FILNMLEN);
	}
      goto end;

      /* RS/6000 "csect" auxents */
    case C_EXT:
    case C_AIX_WEAKEXT:
    case C_HIDEXT:
      if (indx + 1 == numaux)
	{
	  H_PUT_32 (abfd, in->x_csect.x_scnlen.l, ext->x_csect.x_scnlen);
	  H_PUT_32 (abfd, in->x_csect.x_parmhash, ext->x_csect.x_parmhash);
	  H_PUT_16 (abfd, in->x_csect.x_snhash, ext->x_csect.x_snhash);
	  /* We don't have to hack bitfields in x_smtyp because it's
	     defined by shifts-and-ands, which are equivalent on all
	     byte orders.  */
	  H_PUT_8 (abfd, in->x_csect.x_smtyp, ext->x_csect.x_smtyp);
	  H_PUT_8 (abfd, in->x_csect.x_smclas, ext->x_csect.x_smclas);
	  H_PUT_32 (abfd, in->x_csect.x_stab, ext->x_csect.x_stab);
	  H_PUT_16 (abfd, in->x_csect.x_snstab, ext->x_csect.x_snstab);
	  goto end;
	}
      break;

    case C_STAT:
    case C_LEAFSTAT:
    case C_HIDDEN:
      if (type == T_NULL)
	{
	  H_PUT_32 (abfd, in->x_scn.x_scnlen, ext->x_scn.x_scnlen);
	  H_PUT_16 (abfd, in->x_scn.x_nreloc, ext->x_scn.x_nreloc);
	  H_PUT_16 (abfd, in->x_scn.x_nlinno, ext->x_scn.x_nlinno);
	  goto end;
	}
      break;
    }

  H_PUT_32 (abfd, in->x_sym.x_tagndx.l, ext->x_sym.x_tagndx);
  H_PUT_16 (abfd, in->x_sym.x_tvndx, ext->x_sym.x_tvndx);

  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)
      || ISTAG (in_class))
    {
      H_PUT_32 (abfd, in->x_sym.x_fcnary.x_fcn.x_lnnoptr,
		ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      H_PUT_32 (abfd, in->x_sym.x_fcnary.x_fcn.x_endndx.l,
		ext->x_sym.x_fcnary.x_fcn.x_endndx);
    }
  else
    {
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[0],
		ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[1],
		ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[2],
		ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[3],
		ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }

  if (ISFCN (type))
    H_PUT_32 (abfd, in->x_sym.x_misc.x_fsize, ext->x_sym.x_misc.x_fsize);
  else
    {
      H_PUT_16 (abfd, in->x_sym.x_misc.x_lnsz.x_lnno,
		ext->x_sym.x_misc.x_lnsz.x_lnno);
      H_PUT_16 (abfd, in->x_sym.x_misc.x_lnsz.x_size,
		ext->x_sym.x_misc.x_lnsz.x_size);
    }

end:
  return bfd_coff_auxesz (abfd);
}



/* The XCOFF reloc table.  Actually, XCOFF relocations specify the
   bitsize and whether they are signed or not, along with a
   conventional type.  This table is for the types, which are used for
   different algorithms for putting in the reloc.  Many of these
   relocs need special_function entries, which I have not written.  */


reloc_howto_type xcoff_howto_table[] =
{
  /* 0x00: Standard 32 bit relocation.  */
  HOWTO (R_POS,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_POS",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x01: 32 bit relocation, but store negative value.  */
  HOWTO (R_NEG,			/* type */
	 0,			/* rightshift */
	 -2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_NEG",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x02: 32 bit PC relative relocation.  */
  HOWTO (R_REL,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_REL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x03: 16 bit TOC relative relocation.  */
  HOWTO (R_TOC,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_TOC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x04: I don't really know what this is.  */
  HOWTO (R_RTB,			/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RTB",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x05: External TOC relative symbol.  */
  HOWTO (R_GL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_GL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x06: Local TOC relative symbol.	 */
  HOWTO (R_TCL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_TCL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (7),

  /* 0x08: Non modifiable absolute branch.  */
  HOWTO (R_BA,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_BA_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (9),

  /* 0x0a: Non modifiable relative branch.  */
  HOWTO (R_BR,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_BR",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (0xb),

  /* 0x0c: Indirect load.  */
  HOWTO (R_RL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x0d: Load address.  */
  HOWTO (R_RLA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RLA",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (0xe),

  /* 0x0f: Non-relocating reference.  Bitsize is 1 so that r_rsize is 0.  */
  HOWTO (R_REF,			/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 1,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_REF",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (0x10),
  EMPTY_HOWTO (0x11),

  /* 0x12: TOC relative indirect load.  */
  HOWTO (R_TRL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_TRL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x13: TOC relative load address.  */
  HOWTO (R_TRLA,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_TRLA",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x14: Modifiable relative branch.  */
  HOWTO (R_RRTBI,		 /* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RRTBI",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x15: Modifiable absolute branch.  */
  HOWTO (R_RRTBA,		 /* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RRTBA",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x16: Modifiable call absolute indirect.  */
  HOWTO (R_CAI,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_CAI",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x17: Modifiable call relative.  */
  HOWTO (R_CREL,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_CREL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x18: Modifiable branch absolute.  */
  HOWTO (R_RBA,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBA",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x19: Modifiable branch absolute.  */
  HOWTO (R_RBAC,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBAC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x1a: Modifiable branch relative.  */
  HOWTO (R_RBR,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBR_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x1b: Modifiable branch absolute.  */
  HOWTO (R_RBRC,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBRC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x1c: 16 bit Non modifiable absolute branch.  */
  HOWTO (R_BA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_BA_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xfffc,		/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x1d: Modifiable branch relative.  */
  HOWTO (R_RBR,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBR_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xfffc,		/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 0x1e: Modifiable branch relative.  */
  HOWTO (R_RBA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_RBA_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

void
xcoff_rtype2howto (arelent *relent, struct internal_reloc *internal)
{
  if (internal->r_type > R_RBRC)
    abort ();

  /* Default howto layout works most of the time */
  relent->howto = &xcoff_howto_table[internal->r_type];

  /* Special case some 16 bit reloc */
  if (15 == (internal->r_size & 0x1f))
    {
      if (R_BA == internal->r_type)
	relent->howto = &xcoff_howto_table[0x1c];
      else if (R_RBR == internal->r_type)
	relent->howto = &xcoff_howto_table[0x1d];
      else if (R_RBA == internal->r_type)
	relent->howto = &xcoff_howto_table[0x1e];
    }

  /* The r_size field of an XCOFF reloc encodes the bitsize of the
     relocation, as well as indicating whether it is signed or not.
     Doublecheck that the relocation information gathered from the
     type matches this information.  The bitsize is not significant
     for R_REF relocs.  */
  if (relent->howto->dst_mask != 0
      && (relent->howto->bitsize
	  != ((unsigned int) internal->r_size & 0x1f) + 1))
    abort ();
}

reloc_howto_type *
_bfd_xcoff_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
                              bfd_reloc_code_real_type code)
{
  switch (code)
    {
    case BFD_RELOC_PPC_B26:
      return &xcoff_howto_table[0xa];
    case BFD_RELOC_PPC_BA16:
      return &xcoff_howto_table[0x1c];
    case BFD_RELOC_PPC_BA26:
      return &xcoff_howto_table[8];
    case BFD_RELOC_PPC_TOC16:
      return &xcoff_howto_table[3];
    case BFD_RELOC_16:
      /* Note that this relocation is only internally used by gas.  */
      return &xcoff_howto_table[0xc];
    case BFD_RELOC_PPC_B16:
      return &xcoff_howto_table[0x1d];
    case BFD_RELOC_32:
    case BFD_RELOC_CTOR:
      return &xcoff_howto_table[0];
    case BFD_RELOC_NONE:
      return &xcoff_howto_table[0xf];
    default:
      return NULL;
    }
}

static reloc_howto_type *
_bfd_xcoff_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			      const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (xcoff_howto_table) / sizeof (xcoff_howto_table[0]);
       i++)
    if (xcoff_howto_table[i].name != NULL
	&& strcasecmp (xcoff_howto_table[i].name, r_name) == 0)
      return &xcoff_howto_table[i];

  return NULL;
}

/* XCOFF archive support.  The original version of this code was by
   Damon A. Permezel.  It was enhanced to permit cross support, and
   writing archive files, by Ian Lance Taylor, Cygnus Support.

   XCOFF uses its own archive format.  Everything is hooked together
   with file offset links, so it is possible to rapidly update an
   archive in place.  Of course, we don't do that.  An XCOFF archive
   has a real file header, not just an ARMAG string.  The structure of
   the file header and of each archive header appear below.

   An XCOFF archive also has a member table, which is a list of
   elements in the archive (you can get that by looking through the
   linked list, but you have to read a lot more of the file).  The
   member table has a normal archive header with an empty name.  It is
   normally (and perhaps must be) the second to last entry in the
   archive.  The member table data is almost printable ASCII.  It
   starts with a 12 character decimal string which is the number of
   entries in the table.  For each entry it has a 12 character decimal
   string which is the offset in the archive of that member.  These
   entries are followed by a series of null terminated strings which
   are the member names for each entry.

   Finally, an XCOFF archive has a global symbol table, which is what
   we call the armap.  The global symbol table has a normal archive
   header with an empty name.  It is normally (and perhaps must be)
   the last entry in the archive.  The contents start with a four byte
   binary number which is the number of entries.  This is followed by
   a that many four byte binary numbers; each is the file offset of an
   entry in the archive.  These numbers are followed by a series of
   null terminated strings, which are symbol names.

   AIX 4.3 introduced a new archive format which can handle larger
   files and also 32- and 64-bit objects in the same archive.  The
   things said above remain true except that there is now more than
   one global symbol table.  The one is used to index 32-bit objects,
   the other for 64-bit objects.

   The new archives (recognizable by the new ARMAG string) has larger
   field lengths so that we cannot really share any code.  Also we have
   to take care that we are not generating the new form of archives
   on AIX 4.2 or earlier systems.  */

/* XCOFF archives use this as a magic string.  Note that both strings
   have the same length.  */

/* Set the magic for archive.  */

bfd_boolean
bfd_xcoff_ar_archive_set_magic (bfd *abfd ATTRIBUTE_UNUSED,
                                char *magic ATTRIBUTE_UNUSED)
{
  /* Not supported yet.  */
  return FALSE;
 /* bfd_xcoff_archive_set_magic (abfd, magic); */
}

/* Read in the armap of an XCOFF archive.  */

bfd_boolean
_bfd_xcoff_slurp_armap (bfd *abfd)
{
  file_ptr off;
  size_t namlen;
  bfd_size_type sz;
  bfd_byte *contents, *cend;
  bfd_vma c, i;
  carsym *arsym;
  bfd_byte *p;

  if (xcoff_ardata (abfd) == NULL)
    {
      bfd_has_map (abfd) = FALSE;
      return TRUE;
    }

  if (! xcoff_big_format_p (abfd))
    {
      /* This is for the old format.  */
      struct xcoff_ar_hdr hdr;

      off = strtol (xcoff_ardata (abfd)->symoff, (char **) NULL, 10);
      if (off == 0)
	{
	  bfd_has_map (abfd) = FALSE;
	  return TRUE;
	}

      if (bfd_seek (abfd, off, SEEK_SET) != 0)
	return FALSE;

      /* The symbol table starts with a normal archive header.  */
      if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
	  != SIZEOF_AR_HDR)
	return FALSE;

      /* Skip the name (normally empty).  */
      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;
      if (bfd_seek (abfd, off, SEEK_CUR) != 0)
	return FALSE;

      sz = strtol (hdr.size, (char **) NULL, 10);

      /* Read in the entire symbol table.  */
      contents = (bfd_byte *) bfd_alloc (abfd, sz);
      if (contents == NULL)
	return FALSE;
      if (bfd_bread (contents, sz, abfd) != sz)
	return FALSE;

      /* The symbol table starts with a four byte count.  */
      c = H_GET_32 (abfd, contents);

      if (c * 4 >= sz)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      bfd_ardata (abfd)->symdefs =
	((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));
      if (bfd_ardata (abfd)->symdefs == NULL)
	return FALSE;

      /* After the count comes a list of four byte file offsets.  */
      for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 4;
	   i < c;
	   ++i, ++arsym, p += 4)
	arsym->file_offset = H_GET_32 (abfd, p);
    }
  else
    {
      /* This is for the new format.  */
      struct xcoff_ar_hdr_big hdr;

      off = strtol (xcoff_ardata_big (abfd)->symoff, (char **) NULL, 10);
      if (off == 0)
	{
	  bfd_has_map (abfd) = FALSE;
	  return TRUE;
	}

      if (bfd_seek (abfd, off, SEEK_SET) != 0)
	return FALSE;

      /* The symbol table starts with a normal archive header.  */
      if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
	  != SIZEOF_AR_HDR_BIG)
	return FALSE;

      /* Skip the name (normally empty).  */
      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;
      if (bfd_seek (abfd, off, SEEK_CUR) != 0)
	return FALSE;

      /* XXX This actually has to be a call to strtoll (at least on 32-bit
	 machines) since the field width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      sz = strtol (hdr.size, (char **) NULL, 10);

      /* Read in the entire symbol table.  */
      contents = (bfd_byte *) bfd_alloc (abfd, sz);
      if (contents == NULL)
	return FALSE;
      if (bfd_bread (contents, sz, abfd) != sz)
	return FALSE;

      /* The symbol table starts with an eight byte count.  */
      c = H_GET_64 (abfd, contents);

      if (c * 8 >= sz)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      bfd_ardata (abfd)->symdefs =
	((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));
      if (bfd_ardata (abfd)->symdefs == NULL)
	return FALSE;

      /* After the count comes a list of eight byte file offsets.  */
      for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 8;
	   i < c;
	   ++i, ++arsym, p += 8)
	arsym->file_offset = H_GET_64 (abfd, p);
    }

  /* After the file offsets come null terminated symbol names.  */
  cend = contents + sz;
  for (i = 0, arsym = bfd_ardata (abfd)->symdefs;
       i < c;
       ++i, ++arsym, p += strlen ((char *) p) + 1)
    {
      if (p >= cend)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      arsym->name = (char *) p;
    }

  bfd_ardata (abfd)->symdef_count = c;
  bfd_has_map (abfd) = TRUE;

  return TRUE;
}

/* See if this is an XCOFF archive.  */

const bfd_target *
_bfd_xcoff_archive_p (bfd *abfd)
{
  struct artdata *tdata_hold;
  char magic[SXCOFFARMAG];
  bfd_size_type amt = SXCOFFARMAG;

  if (bfd_bread (magic, amt, abfd) != amt)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  if (strncmp (magic, XCOFFARMAG, SXCOFFARMAG) != 0
      && strncmp (magic, XCOFFARMAGBIG, SXCOFFARMAG) != 0)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  tdata_hold = bfd_ardata (abfd);

  amt = sizeof (struct artdata);
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
  if (bfd_ardata (abfd) == (struct artdata *) NULL)
    goto error_ret_restore;

  /* Cleared by bfd_zalloc above.
     bfd_ardata (abfd)->cache = NULL;
     bfd_ardata (abfd)->archive_head = NULL;
     bfd_ardata (abfd)->symdefs = NULL;
     bfd_ardata (abfd)->extended_names = NULL;
     bfd_ardata (abfd)->extended_names_size = 0;  */

  /* Now handle the two formats.  */
  if (magic[1] != 'b')
    {
      /* This is the old format.  */
      struct xcoff_ar_file_hdr hdr;

      /* Copy over the magic string.  */
      memcpy (hdr.magic, magic, SXCOFFARMAG);

      /* Now read the rest of the file header.  */
      amt = SIZEOF_AR_FILE_HDR - SXCOFFARMAG;
      if (bfd_bread (&hdr.memoff, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  goto error_ret;
	}

      bfd_ardata (abfd)->first_file_filepos = strtol (hdr.firstmemoff,
						      (char **) NULL, 10);

      amt = SIZEOF_AR_FILE_HDR;
      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, amt);
      if (bfd_ardata (abfd)->tdata == NULL)
	goto error_ret;

      memcpy (bfd_ardata (abfd)->tdata, &hdr, SIZEOF_AR_FILE_HDR);
    }
  else
    {
      /* This is the new format.  */
      struct xcoff_ar_file_hdr_big hdr;

      /* Copy over the magic string.  */
      memcpy (hdr.magic, magic, SXCOFFARMAG);

      /* Now read the rest of the file header.  */
      amt = SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG;
      if (bfd_bread (&hdr.memoff, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  goto error_ret;
	}

      bfd_ardata (abfd)->first_file_filepos = bfd_scan_vma (hdr.firstmemoff,
							    (const char **) 0,
							    10);

      amt = SIZEOF_AR_FILE_HDR_BIG;
      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, amt);
      if (bfd_ardata (abfd)->tdata == NULL)
	goto error_ret;

      memcpy (bfd_ardata (abfd)->tdata, &hdr, SIZEOF_AR_FILE_HDR_BIG);
    }

  if (! _bfd_xcoff_slurp_armap (abfd))
    {
    error_ret:
      bfd_release (abfd, bfd_ardata (abfd));
    error_ret_restore:
      bfd_ardata (abfd) = tdata_hold;
      return NULL;
    }

  return abfd->xvec;
}

/* Read the archive header in an XCOFF archive.  */

void *
_bfd_xcoff_read_ar_hdr (bfd *abfd)
{
  bfd_size_type namlen;
  struct areltdata *ret;
  bfd_size_type amt = sizeof (struct areltdata);

  ret = (struct areltdata *) bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (! xcoff_big_format_p (abfd))
    {
      struct xcoff_ar_hdr hdr;
      struct xcoff_ar_hdr *hdrp;

      if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
	  != SIZEOF_AR_HDR)
	{
	  free (ret);
	  return NULL;
	}

      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      amt = SIZEOF_AR_HDR + namlen + 1;
      hdrp = (struct xcoff_ar_hdr *) bfd_alloc (abfd, amt);
      if (hdrp == NULL)
	{
	  free (ret);
	  return NULL;
	}
      memcpy (hdrp, &hdr, SIZEOF_AR_HDR);
      if (bfd_bread ((char *) hdrp + SIZEOF_AR_HDR, namlen, abfd) != namlen)
	{
	  free (ret);
	  return NULL;
	}
      ((char *) hdrp)[SIZEOF_AR_HDR + namlen] = '\0';

      ret->arch_header = (char *) hdrp;
      ret->parsed_size = strtol (hdr.size, (char **) NULL, 10);
      ret->filename = (char *) hdrp + SIZEOF_AR_HDR;
    }
  else
    {
      struct xcoff_ar_hdr_big hdr;
      struct xcoff_ar_hdr_big *hdrp;

      if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
	  != SIZEOF_AR_HDR_BIG)
	{
	  free (ret);
	  return NULL;
	}

      namlen = strtol (hdr.namlen, (char **) NULL, 10);
      amt = SIZEOF_AR_HDR_BIG + namlen + 1;
      hdrp = (struct xcoff_ar_hdr_big *) bfd_alloc (abfd, amt);
      if (hdrp == NULL)
	{
	  free (ret);
	  return NULL;
	}
      memcpy (hdrp, &hdr, SIZEOF_AR_HDR_BIG);
      if (bfd_bread ((char *) hdrp + SIZEOF_AR_HDR_BIG, namlen, abfd) != namlen)
	{
	  free (ret);
	  return NULL;
	}
      ((char *) hdrp)[SIZEOF_AR_HDR_BIG + namlen] = '\0';

      ret->arch_header = (char *) hdrp;
      /* XXX This actually has to be a call to strtoll (at least on 32-bit
	 machines) since the field width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      ret->parsed_size = strtol (hdr.size, (char **) NULL, 10);
      ret->filename = (char *) hdrp + SIZEOF_AR_HDR_BIG;
    }

  /* Skip over the XCOFFARFMAG at the end of the file name.  */
  if (bfd_seek (abfd, (file_ptr) ((namlen & 1) + SXCOFFARFMAG), SEEK_CUR) != 0)
    return NULL;

  return ret;
}

/* Open the next element in an XCOFF archive.  */

bfd *
_bfd_xcoff_openr_next_archived_file (bfd *archive, bfd *last_file)
{
  file_ptr filestart;

  if (xcoff_ardata (archive) == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }

  if (! xcoff_big_format_p (archive))
    {
      if (last_file == NULL)
	filestart = bfd_ardata (archive)->first_file_filepos;
      else
	filestart = strtol (arch_xhdr (last_file)->nextoff, (char **) NULL,
			    10);

      if (filestart == 0
	  || filestart == strtol (xcoff_ardata (archive)->memoff,
				  (char **) NULL, 10)
	  || filestart == strtol (xcoff_ardata (archive)->symoff,
				  (char **) NULL, 10))
	{
	  bfd_set_error (bfd_error_no_more_archived_files);
	  return NULL;
	}
    }
  else
    {
      if (last_file == NULL)
	filestart = bfd_ardata (archive)->first_file_filepos;
      else
	/* XXX These actually have to be a calls to strtoll (at least
	   on 32-bit machines) since the fields's width is 20 and
	   there numbers with more than 32 bits can be represented.  */
	filestart = strtol (arch_xhdr_big (last_file)->nextoff, (char **) NULL,
			    10);

      /* XXX These actually have to be calls to strtoll (at least on 32-bit
	 machines) since the fields's width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      if (filestart == 0
	  || filestart == strtol (xcoff_ardata_big (archive)->memoff,
				  (char **) NULL, 10)
	  || filestart == strtol (xcoff_ardata_big (archive)->symoff,
				  (char **) NULL, 10))
	{
	  bfd_set_error (bfd_error_no_more_archived_files);
	  return NULL;
	}
    }

  return _bfd_get_elt_at_filepos (archive, filestart);
}

/* Stat an element in an XCOFF archive.  */

int
_bfd_xcoff_stat_arch_elt (bfd *abfd, struct stat *s)
{
  if (abfd->arelt_data == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  if (! xcoff_big_format_p (abfd->my_archive))
    {
      struct xcoff_ar_hdr *hdrp = arch_xhdr (abfd);

      s->st_mtime = strtol (hdrp->date, (char **) NULL, 10);
      s->st_uid = strtol (hdrp->uid, (char **) NULL, 10);
      s->st_gid = strtol (hdrp->gid, (char **) NULL, 10);
      s->st_mode = strtol (hdrp->mode, (char **) NULL, 8);
      s->st_size = arch_eltdata (abfd)->parsed_size;
    }
  else
    {
      struct xcoff_ar_hdr_big *hdrp = arch_xhdr_big (abfd);

      s->st_mtime = strtol (hdrp->date, (char **) NULL, 10);
      s->st_uid = strtol (hdrp->uid, (char **) NULL, 10);
      s->st_gid = strtol (hdrp->gid, (char **) NULL, 10);
      s->st_mode = strtol (hdrp->mode, (char **) NULL, 8);
      s->st_size = arch_eltdata (abfd)->parsed_size;
    }

  return 0;
}

/* Normalize a file name for inclusion in an archive.  */

static const char *
normalize_filename (bfd *abfd)
{
  const char *file;
  const char *filename;

  file = bfd_get_filename (abfd);
  filename = strrchr (file, '/');
  if (filename != NULL)
    filename++;
  else
    filename = file;
  return filename;
}

/* Write out an XCOFF armap.  */

static bfd_boolean
xcoff_write_armap_old (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,
                       struct orl *map, unsigned int orl_count, int stridx)
{
  struct archive_iterator iterator;
  struct xcoff_ar_hdr hdr;
  char *p;
  unsigned char buf[4];
  unsigned int i;

  memset (&hdr, 0, sizeof hdr);
  sprintf (hdr.size, "%ld", (long) (4 + orl_count * 4 + stridx));
  sprintf (hdr.nextoff, "%d", 0);
  memcpy (hdr.prevoff, xcoff_ardata (abfd)->memoff, XCOFFARMAG_ELEMENT_SIZE);
  sprintf (hdr.date, "%d", 0);
  sprintf (hdr.uid, "%d", 0);
  sprintf (hdr.gid, "%d", 0);
  sprintf (hdr.mode, "%d", 0);
  sprintf (hdr.namlen, "%d", 0);

  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &hdr; p < (char *) &hdr + SIZEOF_AR_HDR; p++)
    if (*p == '\0')
      *p = ' ';

  if (bfd_bwrite (&hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
      != SIZEOF_AR_HDR
      || (bfd_bwrite (XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)
	  != SXCOFFARFMAG))
    return FALSE;

  H_PUT_32 (abfd, orl_count, buf);
  if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
    return FALSE;

  i = 0;
  archive_iterator_begin (&iterator, abfd);
  while (i < orl_count && archive_iterator_next (&iterator))
    while (map[i].u.abfd == iterator.current.member)
      {
	H_PUT_32 (abfd, iterator.current.offset, buf);
	if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
	  return FALSE;
	++i;
      }

  for (i = 0; i < orl_count; i++)
    {
      const char *name;
      size_t namlen;

      name = *map[i].name;
      namlen = strlen (name);
      if (bfd_bwrite (name, (bfd_size_type) (namlen + 1), abfd) != namlen + 1)
	return FALSE;
    }

  if ((stridx & 1) != 0)
    {
      char b;

      b = '\0';
      if (bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
	return FALSE;
    }

  return TRUE;
}

static char buff20[XCOFFARMAGBIG_ELEMENT_SIZE + 1];
#define FMT20  "%-20lld"
#define FMT12  "%-12d"
#define FMT12_OCTAL  "%-12o"
#define FMT4  "%-4d"
#define PRINT20(d, v) \
  sprintf (buff20, FMT20, (long long)(v)), \
  memcpy ((void *) (d), buff20, 20)

#define PRINT12(d, v) \
  sprintf (buff20, FMT12, (int)(v)), \
  memcpy ((void *) (d), buff20, 12)

#define PRINT12_OCTAL(d, v) \
  sprintf (buff20, FMT12_OCTAL, (unsigned int)(v)), \
  memcpy ((void *) (d), buff20, 12)

#define PRINT4(d, v) \
  sprintf (buff20, FMT4, (int)(v)), \
  memcpy ((void *) (d), buff20, 4)

#define READ20(d, v) \
  buff20[20] = 0, \
  memcpy (buff20, (d), 20), \
  (v) = bfd_scan_vma (buff20, (const char **) NULL, 10)

static bfd_boolean
do_pad (bfd *abfd, unsigned int number)
{
  bfd_byte b = 0;

  /* Limit pad to <= 4096.  */
  if (number > 4096)
    return FALSE;

  while (number--)
    if (bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
      return FALSE;

  return TRUE;
}

static bfd_boolean
do_copy (bfd *out_bfd, bfd *in_bfd)
{
  bfd_size_type remaining;
  bfd_byte buffer[DEFAULT_BUFFERSIZE];

  if (bfd_seek (in_bfd, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;

  remaining = arelt_size (in_bfd);

  while (remaining >= DEFAULT_BUFFERSIZE)
    {
      if (bfd_bread (buffer, DEFAULT_BUFFERSIZE, in_bfd) != DEFAULT_BUFFERSIZE
	  || bfd_bwrite (buffer, DEFAULT_BUFFERSIZE, out_bfd) != DEFAULT_BUFFERSIZE)
	return FALSE;

      remaining -= DEFAULT_BUFFERSIZE;
    }

  if (remaining)
    {
      if (bfd_bread (buffer, remaining, in_bfd) != remaining
	  || bfd_bwrite (buffer, remaining, out_bfd) != remaining)
	return FALSE;
    }

  return TRUE;
}

static bfd_boolean
xcoff_write_armap_big (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,
                       struct orl *map, unsigned int orl_count, int stridx)
{
  struct archive_iterator iterator;
  struct xcoff_ar_file_hdr_big *fhdr;
  bfd_vma i, sym_32, sym_64, str_32, str_64;
  const bfd_arch_info_type *arch_info;
  bfd *current_bfd;
  size_t string_length;
  file_ptr nextoff, prevoff;

  /* First, we look through the symbols and work out which are
     from 32-bit objects and which from 64-bit ones.  */
  sym_32 = sym_64 = str_32 = str_64 = 0;

  i = 0;
  for (current_bfd = abfd->archive_head;
       current_bfd != NULL && i < orl_count;
       current_bfd = current_bfd->archive_next)
    {
      arch_info = bfd_get_arch_info (current_bfd);
      while (map[i].u.abfd == current_bfd)
	{
	  string_length = strlen (*map[i].name) + 1;
	  if (arch_info->bits_per_address == 64)
	    {
	      sym_64++;
	      str_64 += string_length;
	    }
	  else
	    {
	      sym_32++;
	      str_32 += string_length;
	    }
	  i++;
	}
    }

  /* A quick sanity check... */
  BFD_ASSERT (sym_64 + sym_32 == orl_count);
  /* Explicit cast to int for compiler.  */
  BFD_ASSERT ((int)(str_64 + str_32) == stridx);

  fhdr = xcoff_ardata_big (abfd);

  /* xcoff_write_archive_contents_big passes nextoff in symoff. */
  READ20 (fhdr->memoff, prevoff);
  READ20 (fhdr->symoff, nextoff);

  BFD_ASSERT (nextoff == bfd_tell (abfd));

  /* Write out the symbol table.
     Layout :

     standard big archive header
     0x0000		      ar_size	[0x14]
     0x0014		      ar_nxtmem [0x14]
     0x0028		      ar_prvmem [0x14]
     0x003C		      ar_date	[0x0C]
     0x0048		      ar_uid	[0x0C]
     0x0054		      ar_gid	[0x0C]
     0x0060		      ar_mod	[0x0C]
     0x006C		      ar_namelen[0x04]
     0x0070		      ar_fmag	[SXCOFFARFMAG]

     Symbol table
     0x0072		      num_syms	[0x08], binary
     0x0078		      offsets	[0x08 * num_syms], binary
     0x0086 + 0x08 * num_syms names	[??]
     ??			      pad to even bytes.
  */

  if (sym_32)
    {
      struct xcoff_ar_hdr_big *hdr;
      char *symbol_table;
      char *st;

      bfd_vma symbol_table_size =
	SIZEOF_AR_HDR_BIG
	+ SXCOFFARFMAG
	+ 8
	+ 8 * sym_32
	+ str_32 + (str_32 & 1);

      symbol_table = bfd_zmalloc (symbol_table_size);
      if (symbol_table == NULL)
	return FALSE;

      hdr = (struct xcoff_ar_hdr_big *) symbol_table;

      PRINT20 (hdr->size, 8 + 8 * sym_32 + str_32 + (str_32 & 1));

      if (sym_64)
	PRINT20 (hdr->nextoff, nextoff + symbol_table_size);
      else
	PRINT20 (hdr->nextoff, 0);

      PRINT20 (hdr->prevoff, prevoff);
      PRINT12 (hdr->date, 0);
      PRINT12 (hdr->uid, 0);
      PRINT12 (hdr->gid, 0);
      PRINT12 (hdr->mode, 0);
      PRINT4 (hdr->namlen, 0) ;

      st = symbol_table + SIZEOF_AR_HDR_BIG;
      memcpy (st, XCOFFARFMAG, SXCOFFARFMAG);
      st += SXCOFFARFMAG;

      bfd_h_put_64 (abfd, sym_32, st);
      st += 8;

      /* loop over the 32 bit offsets */
      i = 0;
      archive_iterator_begin (&iterator, abfd);
      while (i < orl_count && archive_iterator_next (&iterator))
	{
	  arch_info = bfd_get_arch_info (iterator.current.member);
	  while (map[i].u.abfd == iterator.current.member)
	    {
	      if (arch_info->bits_per_address == 32)
		{
		  bfd_h_put_64 (abfd, iterator.current.offset, st);
		  st += 8;
		}
	      i++;
	    }
	}

      /* loop over the 32 bit symbol names */
      i = 0;
      for (current_bfd = abfd->archive_head;
	   current_bfd != NULL && i < orl_count;
	   current_bfd = current_bfd->archive_next)
	{
	  arch_info = bfd_get_arch_info (current_bfd);
	  while (map[i].u.abfd == current_bfd)
	    {
	      if (arch_info->bits_per_address == 32)
		{
		  string_length = sprintf (st, "%s", *map[i].name);
		  st += string_length + 1;
		}
	      i++;
	    }
	}

      bfd_bwrite (symbol_table, symbol_table_size, abfd);

      free (symbol_table);

      prevoff = nextoff;
      nextoff = nextoff + symbol_table_size;
    }
  else
    PRINT20 (fhdr->symoff, 0);

  if (sym_64)
    {
      struct xcoff_ar_hdr_big *hdr;
      char *symbol_table;
      char *st;

      bfd_vma symbol_table_size =
	SIZEOF_AR_HDR_BIG
	+ SXCOFFARFMAG
	+ 8
	+ 8 * sym_64
	+ str_64 + (str_64 & 1);

      symbol_table = bfd_zmalloc (symbol_table_size);
      if (symbol_table == NULL)
	return FALSE;

      hdr = (struct xcoff_ar_hdr_big *) symbol_table;

      PRINT20 (hdr->size, 8 + 8 * sym_64 + str_64 + (str_64 & 1));
      PRINT20 (hdr->nextoff, 0);
      PRINT20 (hdr->prevoff, prevoff);
      PRINT12 (hdr->date, 0);
      PRINT12 (hdr->uid, 0);
      PRINT12 (hdr->gid, 0);
      PRINT12 (hdr->mode, 0);
      PRINT4 (hdr->namlen, 0);

      st = symbol_table + SIZEOF_AR_HDR_BIG;
      memcpy (st, XCOFFARFMAG, SXCOFFARFMAG);
      st += SXCOFFARFMAG;

      bfd_h_put_64 (abfd, sym_64, st);
      st += 8;

      /* loop over the 64 bit offsets */
      i = 0;
      archive_iterator_begin (&iterator, abfd);
      while (i < orl_count && archive_iterator_next (&iterator))
	{
	  arch_info = bfd_get_arch_info (iterator.current.member);
	  while (map[i].u.abfd == iterator.current.member)
	    {
	      if (arch_info->bits_per_address == 64)
		{
		  bfd_h_put_64 (abfd, iterator.current.offset, st);
		  st += 8;
		}
	      i++;
	    }
	}

      /* loop over the 64 bit symbol names */
      i = 0;
      for (current_bfd = abfd->archive_head;
	   current_bfd != NULL && i < orl_count;
	   current_bfd = current_bfd->archive_next)
	{
	  arch_info = bfd_get_arch_info (current_bfd);
	  while (map[i].u.abfd == current_bfd)
	    {
	      if (arch_info->bits_per_address == 64)
		{
		  string_length = sprintf (st, "%s", *map[i].name);
		  st += string_length + 1;
		}
	      i++;
	    }
	}

      bfd_bwrite (symbol_table, symbol_table_size, abfd);

      free (symbol_table);

      PRINT20 (fhdr->symoff64, nextoff);
    }
  else
    PRINT20 (fhdr->symoff64, 0);

  return TRUE;
}

bfd_boolean
_bfd_xcoff_write_armap (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,
                        struct orl *map, unsigned int orl_count, int stridx)
{
  if (! xcoff_big_format_p (abfd))
    return xcoff_write_armap_old (abfd, elength, map, orl_count, stridx);
  else
    return xcoff_write_armap_big (abfd, elength, map, orl_count, stridx);
}

/* Write out an XCOFF archive.  We always write an entire archive,
   rather than fussing with the freelist and so forth.  */

static bfd_boolean
xcoff_write_archive_contents_old (bfd *abfd)
{
  struct archive_iterator iterator;
  struct xcoff_ar_file_hdr fhdr;
  bfd_size_type count;
  bfd_size_type total_namlen;
  file_ptr *offsets;
  bfd_boolean makemap;
  bfd_boolean hasobjects;
  file_ptr prevoff, nextoff;
  bfd *sub;
  size_t i;
  struct xcoff_ar_hdr ahdr;
  bfd_size_type size;
  char *p;
  char decbuf[XCOFFARMAG_ELEMENT_SIZE + 1];

  memset (&fhdr, 0, sizeof fhdr);
  (void) strncpy (fhdr.magic, XCOFFARMAG, SXCOFFARMAG);
  sprintf (fhdr.firstmemoff, "%d", SIZEOF_AR_FILE_HDR);
  sprintf (fhdr.freeoff, "%d", 0);

  count = 0;
  total_namlen = 0;
  for (sub = abfd->archive_head; sub != NULL; sub = sub->archive_next)
    {
      ++count;
      total_namlen += strlen (normalize_filename (sub)) + 1;
      if (sub->arelt_data == NULL)
	{
	  sub->arelt_data = bfd_zmalloc (sizeof (struct areltdata));
	  if (sub->arelt_data == NULL)
	    return FALSE;
	}
      if (arch_xhdr (sub) == NULL)
	{
	  struct xcoff_ar_hdr *ahdrp;
	  struct stat s;

	  if (stat (bfd_get_filename (sub), &s) != 0)
	    {
	      bfd_set_error (bfd_error_system_call);
	      return FALSE;
	    }

	  ahdrp = bfd_zalloc (sub, sizeof (*ahdrp));
	  if (ahdrp == NULL)
	    return FALSE;

	  sprintf (ahdrp->size, "%ld", (long) s.st_size);
	  sprintf (ahdrp->date, "%ld", (long) s.st_mtime);
	  sprintf (ahdrp->uid, "%ld", (long) s.st_uid);
	  sprintf (ahdrp->gid, "%ld", (long) s.st_gid);
	  sprintf (ahdrp->mode, "%o", (unsigned int) s.st_mode);

	  arch_eltdata (sub)->arch_header = (char *) ahdrp;
	  arch_eltdata (sub)->parsed_size = s.st_size;
	}
    }
  offsets = (file_ptr *) bfd_alloc (abfd, count * sizeof (file_ptr));
  if (offsets == NULL)
    return FALSE;

  if (bfd_seek (abfd, (file_ptr) SIZEOF_AR_FILE_HDR, SEEK_SET) != 0)
    return FALSE;

  makemap = bfd_has_map (abfd);
  hasobjects = FALSE;
  prevoff = 0;
  for (archive_iterator_begin (&iterator, abfd), i = 0;
       archive_iterator_next (&iterator);
       i++)
    {
      bfd_size_type namlen;
      struct xcoff_ar_hdr *ahdrp;

      if (makemap && ! hasobjects)
	{
	  if (bfd_check_format (iterator.current.member, bfd_object))
	    hasobjects = TRUE;
	}

      ahdrp = arch_xhdr (iterator.current.member);
      sprintf (ahdrp->prevoff, "%ld", (long) prevoff);
      sprintf (ahdrp->namlen, "%ld", (long) iterator.current.namlen);
      sprintf (ahdrp->nextoff, "%ld", (long) iterator.next.offset);

      /* We need spaces, not null bytes, in the header.  */
      for (p = (char *) ahdrp; p < (char *) ahdrp + SIZEOF_AR_HDR; p++)
	if (*p == '\0')
	  *p = ' ';

      if (!do_pad (abfd, iterator.current.leading_padding))
	return FALSE;

      BFD_ASSERT (iterator.current.offset == bfd_tell (abfd));
      namlen = iterator.current.padded_namlen;
      if (bfd_bwrite (ahdrp, SIZEOF_AR_HDR, abfd) != SIZEOF_AR_HDR
	  || bfd_bwrite (iterator.current.name, namlen, abfd) != namlen
	  || bfd_bwrite (XCOFFARFMAG, SXCOFFARFMAG, abfd) != SXCOFFARFMAG
	  || bfd_seek (iterator.current.member, 0, SEEK_SET) != 0
	  || !do_copy (abfd, iterator.current.member)
	  || !do_pad (abfd, iterator.current.trailing_padding))
	return FALSE;

      offsets[i] = iterator.current.offset;
      prevoff = iterator.current.offset;
    }

  sprintf (fhdr.lastmemoff, "%ld", (long) prevoff);

  /* Write out the member table.  */

  nextoff = iterator.next.offset;
  BFD_ASSERT (nextoff == bfd_tell (abfd));
  sprintf (fhdr.memoff, "%ld", (long) nextoff);

  memset (&ahdr, 0, sizeof ahdr);
  sprintf (ahdr.size, "%ld", (long) (XCOFFARMAG_ELEMENT_SIZE
				     + count * XCOFFARMAG_ELEMENT_SIZE
				     + total_namlen));
  sprintf (ahdr.prevoff, "%ld", (long) prevoff);
  sprintf (ahdr.date, "%d", 0);
  sprintf (ahdr.uid, "%d", 0);
  sprintf (ahdr.gid, "%d", 0);
  sprintf (ahdr.mode, "%d", 0);
  sprintf (ahdr.namlen, "%d", 0);

  size = (SIZEOF_AR_HDR
	  + XCOFFARMAG_ELEMENT_SIZE
	  + count * XCOFFARMAG_ELEMENT_SIZE
	  + total_namlen
	  + SXCOFFARFMAG);

  prevoff = nextoff;
  nextoff += size + (size & 1);

  if (makemap && hasobjects)
    sprintf (ahdr.nextoff, "%ld", (long) nextoff);
  else
    sprintf (ahdr.nextoff, "%d", 0);

  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &ahdr; p < (char *) &ahdr + SIZEOF_AR_HDR; p++)
    if (*p == '\0')
      *p = ' ';

  if ((bfd_bwrite (&ahdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
       != SIZEOF_AR_HDR)
      || (bfd_bwrite (XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)
	  != SXCOFFARFMAG))
    return FALSE;

  sprintf (decbuf, "%-12ld", (long) count);
  if (bfd_bwrite (decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE, abfd)
      != XCOFFARMAG_ELEMENT_SIZE)
    return FALSE;
  for (i = 0; i < (size_t) count; i++)
    {
      sprintf (decbuf, "%-12ld", (long) offsets[i]);
      if (bfd_bwrite (decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE,
		      abfd) != XCOFFARMAG_ELEMENT_SIZE)
	return FALSE;
    }
  for (sub = abfd->archive_head; sub != NULL; sub = sub->archive_next)
    {
      const char *name;
      bfd_size_type namlen;

      name = normalize_filename (sub);
      namlen = strlen (name);
      if (bfd_bwrite (name, namlen + 1, abfd) != namlen + 1)
	return FALSE;
    }

  if (! do_pad (abfd, size & 1))
    return FALSE;

  /* Write out the armap, if appropriate.  */
  if (! makemap || ! hasobjects)
    sprintf (fhdr.symoff, "%d", 0);
  else
    {
      BFD_ASSERT (nextoff == bfd_tell (abfd));
      sprintf (fhdr.symoff, "%ld", (long) nextoff);
      bfd_ardata (abfd)->tdata = &fhdr;
      if (! _bfd_compute_and_write_armap (abfd, 0))
	return FALSE;
    }

  /* Write out the archive file header.  */

  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &fhdr; p < (char *) &fhdr + SIZEOF_AR_FILE_HDR; p++)
    if (*p == '\0')
      *p = ' ';

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || (bfd_bwrite (&fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR, abfd)
	  != SIZEOF_AR_FILE_HDR))
    return FALSE;

  return TRUE;
}

static bfd_boolean
xcoff_write_archive_contents_big (bfd *abfd)
{
  struct xcoff_ar_file_hdr_big fhdr;
  bfd_size_type count;
  bfd_size_type total_namlen;
  file_ptr *offsets;
  bfd_boolean makemap;
  bfd_boolean hasobjects;
  file_ptr prevoff, nextoff;
  bfd *current_bfd;
  size_t i;
  struct xcoff_ar_hdr_big *hdr;
  bfd_size_type size;
  char *member_table, *mt;
  bfd_vma member_table_size;
  struct archive_iterator iterator;

  memset (&fhdr, 0, SIZEOF_AR_FILE_HDR_BIG);
  memcpy (fhdr.magic, XCOFFARMAGBIG, SXCOFFARMAG);

  if (bfd_seek (abfd, (file_ptr) SIZEOF_AR_FILE_HDR_BIG, SEEK_SET) != 0)
    return FALSE;

  /* Calculate count and total_namlen.  */
  makemap = bfd_has_map (abfd);
  hasobjects = FALSE;
  for (current_bfd = abfd->archive_head, count = 0, total_namlen = 0;
       current_bfd != NULL;
       current_bfd = current_bfd->archive_next, count++)
    {
      total_namlen += strlen (normalize_filename (current_bfd)) + 1;

      if (makemap
	  && ! hasobjects
	  && bfd_check_format (current_bfd, bfd_object))
	hasobjects = TRUE;

      if (current_bfd->arelt_data == NULL)
	{
	  size = sizeof (struct areltdata);
	  current_bfd->arelt_data = bfd_zmalloc (size);
	  if (current_bfd->arelt_data == NULL)
	    return FALSE;
	}

      if (arch_xhdr_big (current_bfd) == NULL)
	{
	  struct xcoff_ar_hdr_big *ahdrp;
	  struct stat s;

	  /* XXX This should actually be a call to stat64 (at least on
	     32-bit machines).
	     XXX This call will fail if the original object is not found.  */
	  if (stat (bfd_get_filename (current_bfd), &s) != 0)
	    {
	      bfd_set_error (bfd_error_system_call);
	      return FALSE;
	    }

	  ahdrp = bfd_zalloc (current_bfd, sizeof (*ahdrp));
	  if (ahdrp == NULL)
	    return FALSE;

	  PRINT20 (ahdrp->size, s.st_size);
	  PRINT12 (ahdrp->date, s.st_mtime);
	  PRINT12 (ahdrp->uid,  s.st_uid);
	  PRINT12 (ahdrp->gid,  s.st_gid);
	  PRINT12_OCTAL (ahdrp->mode, s.st_mode);

	  arch_eltdata (current_bfd)->arch_header = (char *) ahdrp;
	  arch_eltdata (current_bfd)->parsed_size = s.st_size;
	}
    }

  offsets = NULL;
  if (count)
    {
      offsets = (file_ptr *) bfd_malloc (count * sizeof (file_ptr));
      if (offsets == NULL)
	return FALSE;
    }

  prevoff = 0;
  for (archive_iterator_begin (&iterator, abfd), i = 0;
       archive_iterator_next (&iterator);
       i++)
    {
      bfd_size_type namlen;
      struct xcoff_ar_hdr_big *ahdrp;

      ahdrp = arch_xhdr_big (iterator.current.member);
      PRINT20 (ahdrp->prevoff, prevoff);
      PRINT4 (ahdrp->namlen, iterator.current.namlen);
      PRINT20 (ahdrp->nextoff, iterator.next.offset);

      if (!do_pad (abfd, iterator.current.leading_padding))
	return FALSE;

      BFD_ASSERT (iterator.current.offset == bfd_tell (abfd));
      namlen = iterator.current.padded_namlen;
      if (bfd_bwrite (ahdrp, SIZEOF_AR_HDR_BIG, abfd) != SIZEOF_AR_HDR_BIG
	  || bfd_bwrite (iterator.current.name, namlen, abfd) != namlen
	  || bfd_bwrite (XCOFFARFMAG, SXCOFFARFMAG, abfd) != SXCOFFARFMAG
	  || bfd_seek (iterator.current.member, 0, SEEK_SET) != 0
	  || !do_copy (abfd, iterator.current.member)
	  || !do_pad (abfd, iterator.current.trailing_padding))
	return FALSE;

      offsets[i] = iterator.current.offset;
      prevoff = iterator.current.offset;
    }

  if (count)
    {
      PRINT20 (fhdr.firstmemoff, offsets[0]);
      PRINT20 (fhdr.lastmemoff, prevoff);
    }

  /* Write out the member table.
     Layout :

     standard big archive header
     0x0000		      ar_size	[0x14]
     0x0014		      ar_nxtmem [0x14]
     0x0028		      ar_prvmem [0x14]
     0x003C		      ar_date	[0x0C]
     0x0048		      ar_uid	[0x0C]
     0x0054		      ar_gid	[0x0C]
     0x0060		      ar_mod	[0x0C]
     0x006C		      ar_namelen[0x04]
     0x0070		      ar_fmag	[0x02]

     Member table
     0x0072		      count	[0x14]
     0x0086		      offsets	[0x14 * counts]
     0x0086 + 0x14 * counts   names	[??]
     ??			      pad to even bytes.
   */

  nextoff = iterator.next.offset;
  BFD_ASSERT (nextoff == bfd_tell (abfd));

  member_table_size = (SIZEOF_AR_HDR_BIG
		       + SXCOFFARFMAG
		       + XCOFFARMAGBIG_ELEMENT_SIZE
		       + count * XCOFFARMAGBIG_ELEMENT_SIZE
		       + total_namlen);

  member_table_size += member_table_size & 1;
  member_table = bfd_zmalloc (member_table_size);
  if (member_table == NULL)
    return FALSE;

  hdr = (struct xcoff_ar_hdr_big *) member_table;

  PRINT20 (hdr->size, (XCOFFARMAGBIG_ELEMENT_SIZE
		       + count * XCOFFARMAGBIG_ELEMENT_SIZE
		       + total_namlen + (total_namlen & 1)));
  if (makemap && hasobjects)
    PRINT20 (hdr->nextoff, nextoff + member_table_size);
  else
    PRINT20 (hdr->nextoff, 0);
  PRINT20 (hdr->prevoff, prevoff);
  PRINT12 (hdr->date, 0);
  PRINT12 (hdr->uid, 0);
  PRINT12 (hdr->gid, 0);
  PRINT12 (hdr->mode, 0);
  PRINT4 (hdr->namlen, 0);

  mt = member_table + SIZEOF_AR_HDR_BIG;
  memcpy (mt, XCOFFARFMAG, SXCOFFARFMAG);
  mt += SXCOFFARFMAG;

  PRINT20 (mt, count);
  mt += XCOFFARMAGBIG_ELEMENT_SIZE;
  for (i = 0; i < (size_t) count; i++)
    {
      PRINT20 (mt, offsets[i]);
      mt += XCOFFARMAGBIG_ELEMENT_SIZE;
    }

  if (count)
    {
      free (offsets);
      offsets = NULL;
    }

  for (current_bfd = abfd->archive_head;
       current_bfd != NULL;
       current_bfd = current_bfd->archive_next)
    {
      const char *name;
      size_t namlen;

      name = normalize_filename (current_bfd);
      namlen = sprintf (mt, "%s", name);
      mt += namlen + 1;
    }

  if (bfd_bwrite (member_table, member_table_size, abfd) != member_table_size)
    return FALSE;

  free (member_table);

  PRINT20 (fhdr.memoff, nextoff);

  prevoff = nextoff;
  nextoff += member_table_size;

  /* Write out the armap, if appropriate.  */

  if (! makemap || ! hasobjects)
    PRINT20 (fhdr.symoff, 0);
  else
    {
      BFD_ASSERT (nextoff == bfd_tell (abfd));

      /* Save nextoff in fhdr.symoff so the armap routine can use it.  */
      PRINT20 (fhdr.symoff, nextoff);

      bfd_ardata (abfd)->tdata = &fhdr;
      if (! _bfd_compute_and_write_armap (abfd, 0))
	return FALSE;
    }

  /* Write out the archive file header.  */

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
      || (bfd_bwrite (&fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR_BIG,
		      abfd) != SIZEOF_AR_FILE_HDR_BIG))
    return FALSE;

  return TRUE;
}

bfd_boolean
_bfd_xcoff_write_archive_contents (bfd *abfd)
{
  if (! xcoff_big_format_p (abfd))
    return xcoff_write_archive_contents_old (abfd);
  else
    return xcoff_write_archive_contents_big (abfd);
}

/* We can't use the usual coff_sizeof_headers routine, because AIX
   always uses an a.out header.  */

int
_bfd_xcoff_sizeof_headers (bfd *abfd,
			   struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  int size;

  size = FILHSZ;
  if (xcoff_data (abfd)->full_aouthdr)
    size += AOUTSZ;
  else
    size += SMALL_AOUTSZ;
  size += abfd->section_count * SCNHSZ;

  if (info->strip != strip_all)
    {
      /* There can be additional sections just for dealing with overflow in
	 reloc and lineno counts. But the numbers of relocs and lineno aren't
	 known when bfd_sizeof_headers is called, so we compute them by
	 summing the numbers from input sections.  */
      struct nbr_reloc_lineno
      {
	unsigned int reloc_count;
	unsigned int lineno_count;
      };
      struct nbr_reloc_lineno *n_rl;
      bfd *sub;
      int max_index;
      asection *s;

      /* Although the number of sections is known, the maximum value of
	 section->index isn't (because some sections may have been removed).
	 Don't try to renumber sections, just compute the upper bound.  */
      max_index = 0;
      for (s = abfd->sections; s != NULL; s = s->next)
	if (s->index > max_index)
	  max_index = s->index;

      /* Allocate the per section counters. It could be possible to use a
	 preallocated array as the number of sections is limited on XCOFF,
	 but this creates a maintainance issue.  */
      n_rl = bfd_zmalloc ((max_index + 1) * sizeof (*n_rl));
      if (n_rl == NULL)
	return -1;

      /* Sum.  */
      for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
	for (s = sub->sections; s != NULL; s = s->next)
	  {
	    struct nbr_reloc_lineno *e = &n_rl[s->output_section->index];
	    e->reloc_count += s->reloc_count;
	    e->lineno_count += s->lineno_count;
	  }

      /* Add the size of a section for each section with an overflow.  */
      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  struct nbr_reloc_lineno *e = &n_rl[s->index];

	  if (e->reloc_count >= 0xffff
	      || (e->lineno_count >= 0xffff && info->strip != strip_debugger))
	    size += SCNHSZ;
	}

      free (n_rl);
    }

  return size;
}

/* Routines to swap information in the XCOFF .loader section.  If we
   ever need to write an XCOFF loader, this stuff will need to be
   moved to another file shared by the linker (which XCOFF calls the
   ``binder'') and the loader.  */

/* Swap in the ldhdr structure.  */

static void
xcoff_swap_ldhdr_in (bfd *abfd, const void * s, struct internal_ldhdr *dst)
{
  const struct external_ldhdr *src = (const struct external_ldhdr *) s;

  dst->l_version = bfd_get_32 (abfd, src->l_version);
  dst->l_nsyms = bfd_get_32 (abfd, src->l_nsyms);
  dst->l_nreloc = bfd_get_32 (abfd, src->l_nreloc);
  dst->l_istlen = bfd_get_32 (abfd, src->l_istlen);
  dst->l_nimpid = bfd_get_32 (abfd, src->l_nimpid);
  dst->l_impoff = bfd_get_32 (abfd, src->l_impoff);
  dst->l_stlen = bfd_get_32 (abfd, src->l_stlen);
  dst->l_stoff = bfd_get_32 (abfd, src->l_stoff);
}

/* Swap out the ldhdr structure.  */

static void
xcoff_swap_ldhdr_out (bfd *abfd, const struct internal_ldhdr *src, void * d)
{
  struct external_ldhdr *dst = (struct external_ldhdr *) d;

  bfd_put_32 (abfd, (bfd_vma) src->l_version, dst->l_version);
  bfd_put_32 (abfd, src->l_nsyms, dst->l_nsyms);
  bfd_put_32 (abfd, src->l_nreloc, dst->l_nreloc);
  bfd_put_32 (abfd, src->l_istlen, dst->l_istlen);
  bfd_put_32 (abfd, src->l_nimpid, dst->l_nimpid);
  bfd_put_32 (abfd, src->l_impoff, dst->l_impoff);
  bfd_put_32 (abfd, src->l_stlen, dst->l_stlen);
  bfd_put_32 (abfd, src->l_stoff, dst->l_stoff);
}

/* Swap in the ldsym structure.  */

static void
xcoff_swap_ldsym_in (bfd *abfd, const void * s, struct internal_ldsym *dst)
{
  const struct external_ldsym *src = (const struct external_ldsym *) s;

  if (bfd_get_32 (abfd, src->_l._l_l._l_zeroes) != 0) {
    memcpy (dst->_l._l_name, src->_l._l_name, SYMNMLEN);
  } else {
    dst->_l._l_l._l_zeroes = 0;
    dst->_l._l_l._l_offset = bfd_get_32 (abfd, src->_l._l_l._l_offset);
  }
  dst->l_value = bfd_get_32 (abfd, src->l_value);
  dst->l_scnum = bfd_get_16 (abfd, src->l_scnum);
  dst->l_smtype = bfd_get_8 (abfd, src->l_smtype);
  dst->l_smclas = bfd_get_8 (abfd, src->l_smclas);
  dst->l_ifile = bfd_get_32 (abfd, src->l_ifile);
  dst->l_parm = bfd_get_32 (abfd, src->l_parm);
}

/* Swap out the ldsym structure.  */

static void
xcoff_swap_ldsym_out (bfd *abfd, const struct internal_ldsym *src, void * d)
{
  struct external_ldsym *dst = (struct external_ldsym *) d;

  if (src->_l._l_l._l_zeroes != 0)
    memcpy (dst->_l._l_name, src->_l._l_name, SYMNMLEN);
  else
    {
      bfd_put_32 (abfd, (bfd_vma) 0, dst->_l._l_l._l_zeroes);
      bfd_put_32 (abfd, (bfd_vma) src->_l._l_l._l_offset,
		  dst->_l._l_l._l_offset);
    }
  bfd_put_32 (abfd, src->l_value, dst->l_value);
  bfd_put_16 (abfd, (bfd_vma) src->l_scnum, dst->l_scnum);
  bfd_put_8 (abfd, src->l_smtype, dst->l_smtype);
  bfd_put_8 (abfd, src->l_smclas, dst->l_smclas);
  bfd_put_32 (abfd, src->l_ifile, dst->l_ifile);
  bfd_put_32 (abfd, src->l_parm, dst->l_parm);
}

static void
xcoff_swap_reloc_in (bfd *abfd, void * s, void * d)
{
  struct external_reloc *src = (struct external_reloc *) s;
  struct internal_reloc *dst = (struct internal_reloc *) d;

  memset (dst, 0, sizeof (struct internal_reloc));

  dst->r_vaddr = bfd_get_32 (abfd, src->r_vaddr);
  dst->r_symndx = bfd_get_32 (abfd, src->r_symndx);
  dst->r_size = bfd_get_8 (abfd, src->r_size);
  dst->r_type = bfd_get_8 (abfd, src->r_type);
}

static unsigned int
xcoff_swap_reloc_out (bfd *abfd, void * s, void * d)
{
  struct internal_reloc *src = (struct internal_reloc *) s;
  struct external_reloc *dst = (struct external_reloc *) d;

  bfd_put_32 (abfd, src->r_vaddr, dst->r_vaddr);
  bfd_put_32 (abfd, src->r_symndx, dst->r_symndx);
  bfd_put_8 (abfd, src->r_type, dst->r_type);
  bfd_put_8 (abfd, src->r_size, dst->r_size);

  return bfd_coff_relsz (abfd);
}

/* Swap in the ldrel structure.  */

static void
xcoff_swap_ldrel_in (bfd *abfd, const void * s, struct internal_ldrel *dst)
{
  const struct external_ldrel *src = (const struct external_ldrel *) s;

  dst->l_vaddr = bfd_get_32 (abfd, src->l_vaddr);
  dst->l_symndx = bfd_get_32 (abfd, src->l_symndx);
  dst->l_rtype = bfd_get_16 (abfd, src->l_rtype);
  dst->l_rsecnm = bfd_get_16 (abfd, src->l_rsecnm);
}

/* Swap out the ldrel structure.  */

static void
xcoff_swap_ldrel_out (bfd *abfd, const struct internal_ldrel *src, void * d)
{
  struct external_ldrel *dst = (struct external_ldrel *) d;

  bfd_put_32 (abfd, src->l_vaddr, dst->l_vaddr);
  bfd_put_32 (abfd, src->l_symndx, dst->l_symndx);
  bfd_put_16 (abfd, (bfd_vma) src->l_rtype, dst->l_rtype);
  bfd_put_16 (abfd, (bfd_vma) src->l_rsecnm, dst->l_rsecnm);
}


bfd_boolean
xcoff_reloc_type_noop (bfd *input_bfd ATTRIBUTE_UNUSED,
                       asection *input_section ATTRIBUTE_UNUSED,
                       bfd *output_bfd ATTRIBUTE_UNUSED,
                       struct internal_reloc *rel ATTRIBUTE_UNUSED,
                       struct internal_syment *sym ATTRIBUTE_UNUSED,
                       struct reloc_howto_struct *howto ATTRIBUTE_UNUSED,
                       bfd_vma val ATTRIBUTE_UNUSED,
                       bfd_vma addend ATTRIBUTE_UNUSED,
                       bfd_vma *relocation ATTRIBUTE_UNUSED,
                       bfd_byte *contents ATTRIBUTE_UNUSED)
{
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_fail (bfd *input_bfd,
                       asection *input_section ATTRIBUTE_UNUSED,
                       bfd *output_bfd ATTRIBUTE_UNUSED,
                       struct internal_reloc *rel,
                       struct internal_syment *sym ATTRIBUTE_UNUSED,
                       struct reloc_howto_struct *howto ATTRIBUTE_UNUSED,
                       bfd_vma val ATTRIBUTE_UNUSED,
                       bfd_vma addend ATTRIBUTE_UNUSED,
                       bfd_vma *relocation ATTRIBUTE_UNUSED,
                       bfd_byte *contents ATTRIBUTE_UNUSED)
{
  (*_bfd_error_handler)
    (_("%s: unsupported relocation type 0x%02x"),
     bfd_get_filename (input_bfd), (unsigned int) rel->r_type);
  bfd_set_error (bfd_error_bad_value);
  return FALSE;
}

bfd_boolean
xcoff_reloc_type_pos (bfd *input_bfd ATTRIBUTE_UNUSED,
                      asection *input_section ATTRIBUTE_UNUSED,
                      bfd *output_bfd ATTRIBUTE_UNUSED,
                      struct internal_reloc *rel ATTRIBUTE_UNUSED,
                      struct internal_syment *sym ATTRIBUTE_UNUSED,
                      struct reloc_howto_struct *howto ATTRIBUTE_UNUSED,
                      bfd_vma val,
                      bfd_vma addend,
                      bfd_vma *relocation,
                      bfd_byte *contents ATTRIBUTE_UNUSED)
{
  *relocation = val + addend;
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_neg (bfd *input_bfd ATTRIBUTE_UNUSED,
                      asection *input_section ATTRIBUTE_UNUSED,
                      bfd *output_bfd ATTRIBUTE_UNUSED,
                      struct internal_reloc *rel ATTRIBUTE_UNUSED,
                      struct internal_syment *sym ATTRIBUTE_UNUSED,
                      struct reloc_howto_struct *howto ATTRIBUTE_UNUSED,
                      bfd_vma val,
                      bfd_vma addend,
                      bfd_vma *relocation,
                      bfd_byte *contents ATTRIBUTE_UNUSED)
{
  *relocation = addend - val;
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_rel (bfd *input_bfd ATTRIBUTE_UNUSED,
                      asection *input_section,
                      bfd *output_bfd ATTRIBUTE_UNUSED,
                      struct internal_reloc *rel ATTRIBUTE_UNUSED,
                      struct internal_syment *sym ATTRIBUTE_UNUSED,
                      struct reloc_howto_struct *howto,
                      bfd_vma val,
                      bfd_vma addend,
                      bfd_vma *relocation,
                      bfd_byte *contents ATTRIBUTE_UNUSED)
{
  howto->pc_relative = TRUE;

  /* A PC relative reloc includes the section address.  */
  addend += input_section->vma;

  *relocation = val + addend;
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_toc (bfd *input_bfd,
                      asection *input_section ATTRIBUTE_UNUSED,
                      bfd *output_bfd,
                      struct internal_reloc *rel,
                      struct internal_syment *sym,
                      struct reloc_howto_struct *howto ATTRIBUTE_UNUSED,
                      bfd_vma val,
                      bfd_vma addend ATTRIBUTE_UNUSED,
                      bfd_vma *relocation,
                      bfd_byte *contents ATTRIBUTE_UNUSED)
{
  struct xcoff_link_hash_entry *h;

  if (0 > rel->r_symndx)
    return FALSE;

  h = obj_xcoff_sym_hashes (input_bfd)[rel->r_symndx];

  if (h != NULL && h->smclas != XMC_TD)
    {
      if (h->toc_section == NULL)
	{
	  (*_bfd_error_handler)
	    (_("%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry"),
	     bfd_get_filename (input_bfd), rel->r_vaddr,
	     h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);
      val = (h->toc_section->output_section->vma
	      + h->toc_section->output_offset);
    }

  *relocation = ((val - xcoff_data (output_bfd)->toc)
		 - (sym->n_value - xcoff_data (input_bfd)->toc));
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_ba (bfd *input_bfd ATTRIBUTE_UNUSED,
                     asection *input_section ATTRIBUTE_UNUSED,
                     bfd *output_bfd ATTRIBUTE_UNUSED,
                     struct internal_reloc *rel ATTRIBUTE_UNUSED,
                     struct internal_syment *sym ATTRIBUTE_UNUSED,
                     struct reloc_howto_struct *howto,
                     bfd_vma val,
                     bfd_vma addend,
                     bfd_vma *relocation,
                     bfd_byte *contents ATTRIBUTE_UNUSED)
{
  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;

  *relocation = val + addend;

  return TRUE;
}

static bfd_boolean
xcoff_reloc_type_br (bfd *input_bfd,
                     asection *input_section,
                     bfd *output_bfd ATTRIBUTE_UNUSED,
                     struct internal_reloc *rel,
                     struct internal_syment *sym ATTRIBUTE_UNUSED,
                     struct reloc_howto_struct *howto,
                     bfd_vma val,
                     bfd_vma addend,
                     bfd_vma *relocation,
                     bfd_byte *contents)
{
  struct xcoff_link_hash_entry *h;
  bfd_vma section_offset;

  if (0 > rel->r_symndx)
    return FALSE;

  h = obj_xcoff_sym_hashes (input_bfd)[rel->r_symndx];
  section_offset = rel->r_vaddr - input_section->vma;

  /* If we see an R_BR or R_RBR reloc which is jumping to global
     linkage code, and it is followed by an appropriate cror nop
     instruction, we replace the cror with lwz r2,20(r1).  This
     restores the TOC after the glink code.  Contrariwise, if the
     call is followed by a lwz r2,20(r1), but the call is not
     going to global linkage code, we can replace the load with a
     cror.  */
  if (NULL != h
      && (bfd_link_hash_defined == h->root.type
	  || bfd_link_hash_defweak == h->root.type)
      && section_offset + 8 <= input_section->size)
    {
      bfd_byte *pnext;
      unsigned long next;

      pnext = contents + section_offset + 4;
      next = bfd_get_32 (input_bfd, pnext);

      /* The _ptrgl function is magic.  It is used by the AIX
	 compiler to call a function through a pointer.  */
      if (h->smclas == XMC_GL || strcmp (h->root.root.string, "._ptrgl") == 0)
	{
	  if (next == 0x4def7b82			/* cror 15,15,15 */
	      || next == 0x4ffffb82			/* cror 31,31,31 */
	      || next == 0x60000000)			/* ori r0,r0,0 */
	    bfd_put_32 (input_bfd, 0x80410014, pnext);	/* lwz r2,20(r1) */

	}
      else
	{
	  if (next == 0x80410014)			/* lwz r2,20(r1) */
	    bfd_put_32 (input_bfd, 0x60000000, pnext);	/* ori r0,r0,0 */
	}
    }
  else if (NULL != h && bfd_link_hash_undefined == h->root.type)
    {
      /* Normally, this relocation is against a defined symbol.  In the
	 case where this is a partial link and the output section offset
	 is greater than 2^25, the linker will return an invalid error
	 message that the relocation has been truncated.  Yes it has been
	 truncated but no it not important.  For this case, disable the
	 overflow checking. */

      howto->complain_on_overflow = complain_overflow_dont;
    }

  /* The original PC-relative relocation is biased by -r_vaddr, so adding
     the value below will give the absolute target address.  */
  *relocation = val + addend + rel->r_vaddr;

  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;

  if (h != NULL
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
      && bfd_is_abs_section (h->root.u.def.section)
      && section_offset + 4 <= input_section->size)
    {
      bfd_byte *ptr;
      bfd_vma insn;

      /* Turn the relative branch into an absolute one by setting the
	 AA bit.  */
      ptr = contents + section_offset;
      insn = bfd_get_32 (input_bfd, ptr);
      insn |= 2;
      bfd_put_32 (input_bfd, insn, ptr);

      /* Make the howto absolute too.  */
      howto->pc_relative = FALSE;
      howto->complain_on_overflow = complain_overflow_bitfield;
    }
  else
    {
      /* Use a PC-relative howto and subtract the instruction's address
	 from the target address we calculated above.  */
      howto->pc_relative = TRUE;
      *relocation -= (input_section->output_section->vma
		      + input_section->output_offset
		      + section_offset);
    }
  return TRUE;
}

bfd_boolean
xcoff_reloc_type_crel (bfd *input_bfd ATTRIBUTE_UNUSED,
                       asection *input_section,
                       bfd *output_bfd ATTRIBUTE_UNUSED,
                       struct internal_reloc *rel ATTRIBUTE_UNUSED,
                       struct internal_syment *sym ATTRIBUTE_UNUSED,
                       struct reloc_howto_struct *howto,
                       bfd_vma val ATTRIBUTE_UNUSED,
                       bfd_vma addend,
                       bfd_vma *relocation,
                       bfd_byte *contents ATTRIBUTE_UNUSED)
{
  howto->pc_relative = TRUE;
  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;

  /* A PC relative reloc includes the section address.  */
  addend += input_section->vma;

  *relocation = val + addend;
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
  return TRUE;
}

static bfd_boolean
xcoff_complain_overflow_dont_func (bfd *input_bfd ATTRIBUTE_UNUSED,
                                   bfd_vma val ATTRIBUTE_UNUSED,
                                   bfd_vma relocation ATTRIBUTE_UNUSED,
                                   struct reloc_howto_struct *
                                      howto ATTRIBUTE_UNUSED)
{
  return FALSE;
}

static bfd_boolean
xcoff_complain_overflow_bitfield_func (bfd *input_bfd,
                                       bfd_vma val,
                                       bfd_vma relocation,
                                       struct reloc_howto_struct *howto)
{
  bfd_vma fieldmask, signmask, ss;
  bfd_vma a, b, sum;

  /* Get the values to be added together.  For signed and unsigned
     relocations, we assume that all values should be truncated to
     the size of an address.  For bitfields, all the bits matter.
     See also bfd_check_overflow.  */
  fieldmask = N_ONES (howto->bitsize);
  a = relocation;
  b = val & howto->src_mask;

  /* Much like unsigned, except no trimming with addrmask.  In
     addition, the sum overflows if there is a carry out of
     the bfd_vma, i.e., the sum is less than either input
     operand.  */
  a >>= howto->rightshift;
  b >>= howto->bitpos;

  /* Bitfields are sometimes used for signed numbers; for
     example, a 13-bit field sometimes represents values in
     0..8191 and sometimes represents values in -4096..4095.
     If the field is signed and a is -4095 (0x1001) and b is
     -1 (0x1fff), the sum is -4096 (0x1000), but (0x1001 +
     0x1fff is 0x3000).  It's not clear how to handle this
     everywhere, since there is not way to know how many bits
     are significant in the relocation, but the original code
     assumed that it was fully sign extended, and we will keep
     that assumption.  */
  signmask = (fieldmask >> 1) + 1;

  if ((a & ~ fieldmask) != 0)
    {
      /* Some bits out of the field are set.  This might not
	 be a problem: if this is a signed bitfield, it is OK
	 iff all the high bits are set, including the sign
	 bit.  We'll try setting all but the most significant
	 bit in the original relocation value: if this is all
	 ones, we are OK, assuming a signed bitfield.  */
      ss = (signmask << howto->rightshift) - 1;
      if ((ss | relocation) != ~ (bfd_vma) 0)
	return TRUE;
      a &= fieldmask;
    }

  /* We just assume (b & ~ fieldmask) == 0.  */

  /* We explicitly permit wrap around if this relocation
     covers the high bit of an address.  The Linux kernel
     relies on it, and it is the only way to write assembler
     code which can run when loaded at a location 0x80000000
     away from the location at which it is linked.  */
  if (howto->bitsize + howto->rightshift
      == bfd_arch_bits_per_address (input_bfd))
    return FALSE;

  sum = a + b;
  if (sum < a || (sum & ~ fieldmask) != 0)
    {
      /* There was a carry out, or the field overflow.  Test
	 for signed operands again.  Here is the overflow test
	 is as for complain_overflow_signed.  */
      if (((~ (a ^ b)) & (a ^ sum)) & signmask)
	return TRUE;
    }

  return FALSE;
}

static bfd_boolean
xcoff_complain_overflow_signed_func (bfd *input_bfd,
                                     bfd_vma val,
                                     bfd_vma relocation,
                                     struct reloc_howto_struct *howto)
{
  bfd_vma addrmask, fieldmask, signmask, ss;
  bfd_vma a, b, sum;

  /* Get the values to be added together.  For signed and unsigned
     relocations, we assume that all values should be truncated to
     the size of an address.  For bitfields, all the bits matter.
     See also bfd_check_overflow.  */
  fieldmask = N_ONES (howto->bitsize);
  addrmask = N_ONES (bfd_arch_bits_per_address (input_bfd)) | fieldmask;
  a = relocation;
  b = val & howto->src_mask;

  a = (a & addrmask) >> howto->rightshift;

  /* If any sign bits are set, all sign bits must be set.
     That is, A must be a valid negative address after
     shifting.  */
  signmask = ~ (fieldmask >> 1);
  ss = a & signmask;
  if (ss != 0 && ss != ((addrmask >> howto->rightshift) & signmask))
    return TRUE;

  /* We only need this next bit of code if the sign bit of B
     is below the sign bit of A.  This would only happen if
     SRC_MASK had fewer bits than BITSIZE.  Note that if
     SRC_MASK has more bits than BITSIZE, we can get into
     trouble; we would need to verify that B is in range, as
     we do for A above.  */
  signmask = ((~ howto->src_mask) >> 1) & howto->src_mask;
  if ((b & signmask) != 0)
    {
      /* Set all the bits above the sign bit.  */
      b -= signmask <<= 1;
    }

  b = (b & addrmask) >> howto->bitpos;

  /* Now we can do the addition.  */
  sum = a + b;

  /* See if the result has the correct sign.  Bits above the
     sign bit are junk now; ignore them.  If the sum is
     positive, make sure we did not have all negative inputs;
     if the sum is negative, make sure we did not have all
     positive inputs.  The test below looks only at the sign
     bits, and it really just
     SIGN (A) == SIGN (B) && SIGN (A) != SIGN (SUM)
  */
  signmask = (fieldmask >> 1) + 1;
  if (((~ (a ^ b)) & (a ^ sum)) & signmask)
    return TRUE;

  return FALSE;
}

static bfd_boolean
xcoff_complain_overflow_unsigned_func (bfd *input_bfd,
                                       bfd_vma val,
                                       bfd_vma relocation,
                                       struct reloc_howto_struct *howto)
{
  bfd_vma addrmask, fieldmask;
  bfd_vma a, b, sum;

  /* Get the values to be added together.  For signed and unsigned
     relocations, we assume that all values should be truncated to
     the size of an address.  For bitfields, all the bits matter.
     See also bfd_check_overflow.  */
  fieldmask = N_ONES (howto->bitsize);
  addrmask = N_ONES (bfd_arch_bits_per_address (input_bfd)) | fieldmask;
  a = relocation;
  b = val & howto->src_mask;

  /* Checking for an unsigned overflow is relatively easy:
     trim the addresses and add, and trim the result as well.
     Overflow is normally indicated when the result does not
     fit in the field.  However, we also need to consider the
     case when, e.g., fieldmask is 0x7fffffff or smaller, an
     input is 0x80000000, and bfd_vma is only 32 bits; then we
     will get sum == 0, but there is an overflow, since the
     inputs did not fit in the field.  Instead of doing a
     separate test, we can check for this by or-ing in the
     operands when testing for the sum overflowing its final
     field.  */
  a = (a & addrmask) >> howto->rightshift;
  b = (b & addrmask) >> howto->bitpos;
  sum = (a + b) & addrmask;
  if ((a | b | sum) & ~ fieldmask)
    return TRUE;

  return FALSE;
}

/* This is the relocation function for the RS/6000/POWER/PowerPC.
   This is currently the only processor which uses XCOFF; I hope that
   will never change.

   I took the relocation type definitions from two documents:
   the PowerPC AIX Version 4 Application Binary Interface, First
   Edition (April 1992), and the PowerOpen ABI, Big-Endian
   32-Bit Hardware Implementation (June 30, 1994).  Differences
   between the documents are noted below.

   Unsupported r_type's

   R_RTB:
   R_RRTBI:
   R_RRTBA:

   These relocs are defined by the PowerPC ABI to be
   relative branches which use half of the difference
   between the symbol and the program counter.  I can't
   quite figure out when this is useful.  These relocs are
   not defined by the PowerOpen ABI.

   Supported r_type's

   R_POS:
   Simple positive relocation.

   R_NEG:
   Simple negative relocation.

   R_REL:
   Simple PC relative relocation.

   R_TOC:
   TOC relative relocation.  The value in the instruction in
   the input file is the offset from the input file TOC to
   the desired location.  We want the offset from the final
   TOC to the desired location.  We have:
   isym = iTOC + in
   iinsn = in + o
   osym = oTOC + on
   oinsn = on + o
   so we must change insn by on - in.

   R_GL:
   GL linkage relocation.  The value of this relocation
   is the address of the entry in the TOC section.

   R_TCL:
   Local object TOC address.  I can't figure out the
   difference between this and case R_GL.

   R_TRL:
   TOC relative relocation.  A TOC relative load instruction
   which may be changed to a load address instruction.
   FIXME: We don't currently implement this optimization.

   R_TRLA:
   TOC relative relocation.  This is a TOC relative load
   address instruction which may be changed to a load
   instruction.  FIXME: I don't know if this is the correct
   implementation.

   R_BA:
   Absolute branch.  We don't want to mess with the lower
   two bits of the instruction.

   R_CAI:
   The PowerPC ABI defines this as an absolute call which
   may be modified to become a relative call.  The PowerOpen
   ABI does not define this relocation type.

   R_RBA:
   Absolute branch which may be modified to become a
   relative branch.

   R_RBAC:
   The PowerPC ABI defines this as an absolute branch to a
   fixed address which may be modified to an absolute branch
   to a symbol.  The PowerOpen ABI does not define this
   relocation type.

   R_RBRC:
   The PowerPC ABI defines this as an absolute branch to a
   fixed address which may be modified to a relative branch.
   The PowerOpen ABI does not define this relocation type.

   R_BR:
   Relative branch.  We don't want to mess with the lower
   two bits of the instruction.

   R_CREL:
   The PowerPC ABI defines this as a relative call which may
   be modified to become an absolute call.  The PowerOpen
   ABI does not define this relocation type.

   R_RBR:
   A relative branch which may be modified to become an
   absolute branch.

   R_RL:
   The PowerPC AIX ABI describes this as a load which may be
   changed to a load address.  The PowerOpen ABI says this
   is the same as case R_POS.

   R_RLA:
   The PowerPC AIX ABI describes this as a load address
   which may be changed to a load.  The PowerOpen ABI says
   this is the same as R_POS.
*/

bfd_boolean
xcoff_ppc_relocate_section (bfd *output_bfd,
                            struct bfd_link_info *info,
                            bfd *input_bfd,
                            asection *input_section,
                            bfd_byte *contents,
                            struct internal_reloc *relocs,
                            struct internal_syment *syms,
                            asection **sections)
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      struct xcoff_link_hash_entry *h;
      struct internal_syment *sym;
      bfd_vma addend;
      bfd_vma val;
      struct reloc_howto_struct howto;
      bfd_vma relocation;
      bfd_vma value_to_relocate;
      bfd_vma address;
      bfd_byte *location;

      /* Relocation type R_REF is a special relocation type which is
	 merely used to prevent garbage collection from occurring for
	 the csect including the symbol which it references.  */
      if (rel->r_type == R_REF)
	continue;

      /* howto */
      howto.type = rel->r_type;
      howto.rightshift = 0;
      howto.bitsize = (rel->r_size & 0x1f) + 1;
      howto.size = howto.bitsize > 16 ? 2 : 1;
      howto.pc_relative = FALSE;
      howto.bitpos = 0;
      howto.complain_on_overflow = (rel->r_size & 0x80
				    ? complain_overflow_signed
				    : complain_overflow_bitfield);
      howto.special_function = NULL;
      howto.name = "internal";
      howto.partial_inplace = TRUE;
      howto.src_mask = howto.dst_mask = N_ONES (howto.bitsize);
      howto.pcrel_offset = FALSE;

      /* symbol */
      val = 0;
      addend = 0;
      h = NULL;
      sym = NULL;
      symndx = rel->r_symndx;

      if (-1 != symndx)
	{
	  asection *sec;

	  h = obj_xcoff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	  addend = - sym->n_value;

	  if (NULL == h)
	    {
	      sec = sections[symndx];
	      /* Hack to make sure we use the right TOC anchor value
		 if this reloc is against the TOC anchor.  */
	      if (sec->name[3] == '0'
		  && strcmp (sec->name, ".tc0") == 0)
		val = xcoff_data (output_bfd)->toc;
	      else
		val = (sec->output_section->vma
		       + sec->output_offset
		       + sym->n_value
		       - sec->vma);
	    }
	  else
	    {
	      if (info->unresolved_syms_in_objects != RM_IGNORE
		  && (h->flags & XCOFF_WAS_UNDEFINED) != 0)
		{
		  if (! ((*info->callbacks->undefined_symbol)
			 (info, h->root.root.string,
			  input_bfd, input_section,
			  rel->r_vaddr - input_section->vma,
			  (info->unresolved_syms_in_objects
			   == RM_GENERATE_ERROR))))
		    return FALSE;
		}
	      if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		{
		  sec = h->root.u.def.section;
		  val = (h->root.u.def.value
			 + sec->output_section->vma
			 + sec->output_offset);
		}
	      else if (h->root.type == bfd_link_hash_common)
		{
		  sec = h->root.u.c.p->section;
		  val = (sec->output_section->vma
			 + sec->output_offset);

		}
	      else
		{
		  BFD_ASSERT (info->relocatable
			      || (info->static_link
				  && (h->flags & XCOFF_WAS_UNDEFINED) != 0)
			      || (h->flags & XCOFF_DEF_DYNAMIC) != 0
			      || (h->flags & XCOFF_IMPORT) != 0);
		}
	    }
	}

      if (rel->r_type >= XCOFF_MAX_CALCULATE_RELOCATION
	  || !((*xcoff_calculate_relocation[rel->r_type])
	       (input_bfd, input_section, output_bfd, rel, sym, &howto, val,
		addend, &relocation, contents)))
	return FALSE;

      /* address */
      address = rel->r_vaddr - input_section->vma;
      location = contents + address;

      if (address > input_section->size)
	abort ();

      /* Get the value we are going to relocate.  */
      if (1 == howto.size)
	value_to_relocate = bfd_get_16 (input_bfd, location);
      else
	value_to_relocate = bfd_get_32 (input_bfd, location);

      /* overflow.

	 FIXME: We may drop bits during the addition
	 which we don't check for.  We must either check at every single
	 operation, which would be tedious, or we must do the computations
	 in a type larger than bfd_vma, which would be inefficient.  */

      if ((unsigned int) howto.complain_on_overflow
	  >= XCOFF_MAX_COMPLAIN_OVERFLOW)
	abort ();

      if (((*xcoff_complain_overflow[howto.complain_on_overflow])
	   (input_bfd, value_to_relocate, relocation, &howto)))
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];
	  char reloc_type_name[10];

	  if (symndx == -1)
	    {
	      name = "*ABS*";
	    }
	  else if (h != NULL)
	    {
	      name = NULL;
	    }
	  else
	    {
	      name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
	      if (name == NULL)
		name = "UNKNOWN";
	    }
	  sprintf (reloc_type_name, "0x%02x", rel->r_type);

	  if (! ((*info->callbacks->reloc_overflow)
		 (info, (h ? &h->root : NULL), name, reloc_type_name,
		  (bfd_vma) 0, input_bfd, input_section,
		  rel->r_vaddr - input_section->vma)))
	    return FALSE;
	}

      /* Add RELOCATION to the right bits of VALUE_TO_RELOCATE.  */
      value_to_relocate = ((value_to_relocate & ~howto.dst_mask)
			   | (((value_to_relocate & howto.src_mask)
			       + relocation) & howto.dst_mask));

      /* Put the value back in the object file.  */
      if (1 == howto.size)
	bfd_put_16 (input_bfd, value_to_relocate, location);
      else
	bfd_put_32 (input_bfd, value_to_relocate, location);
    }

  return TRUE;
}

static bfd_boolean
_bfd_xcoff_put_ldsymbol_name (bfd *abfd ATTRIBUTE_UNUSED,
                              struct xcoff_loader_info *ldinfo,
                              struct internal_ldsym *ldsym,
                              const char *name)
{
  size_t len;
  len = strlen (name);

  if (len <= SYMNMLEN)
    strncpy (ldsym->_l._l_name, name, SYMNMLEN);
  else
    {
      if (ldinfo->string_size + len + 3 > ldinfo->string_alc)
	{
	  bfd_size_type newalc;
	  char *newstrings;

	  newalc = ldinfo->string_alc * 2;
	  if (newalc == 0)
	    newalc = 32;
	  while (ldinfo->string_size + len + 3 > newalc)
	    newalc *= 2;

	  newstrings = bfd_realloc (ldinfo->strings, newalc);
	  if (newstrings == NULL)
	    {
	      ldinfo->failed = TRUE;
	      return FALSE;
	    }
	  ldinfo->string_alc = newalc;
	  ldinfo->strings = newstrings;
	}

      bfd_put_16 (ldinfo->output_bfd, (bfd_vma) (len + 1),
		  ldinfo->strings + ldinfo->string_size);
      strcpy (ldinfo->strings + ldinfo->string_size + 2, name);
      ldsym->_l._l_l._l_zeroes = 0;
      ldsym->_l._l_l._l_offset = ldinfo->string_size + 2;
      ldinfo->string_size += len + 3;
    }

  return TRUE;
}

static bfd_boolean
_bfd_xcoff_put_symbol_name (bfd *abfd, struct bfd_strtab_hash *strtab,
			    struct internal_syment *sym,
			    const char *name)
{
  if (strlen (name) <= SYMNMLEN)
    {
      strncpy (sym->_n._n_name, name, SYMNMLEN);
    }
  else
    {
      bfd_boolean hash;
      bfd_size_type indx;

      hash = TRUE;
      if ((abfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
	hash = FALSE;
      indx = _bfd_stringtab_add (strtab, name, hash, FALSE);
      if (indx == (bfd_size_type) -1)
	return FALSE;
      sym->_n._n_n._n_zeroes = 0;
      sym->_n._n_n._n_offset = STRING_SIZE_SIZE + indx;
    }
  return TRUE;
}

static asection *
xcoff_create_csect_from_smclas (bfd *abfd,
                                union internal_auxent *aux,
                                const char *symbol_name)
{
  asection *return_value = NULL;

  /* .sv64 = x_smclas == 17
     This is an invalid csect for 32 bit apps.  */
  static const char * const names[] =
    {
      ".pr", ".ro", ".db", ".tc", ".ua", ".rw", ".gl", ".xo", /* 0 - 7 */
      ".sv", ".bs", ".ds", ".uc", ".ti", ".tb", NULL, ".tc0", /* 8 - 15 */
      ".td", NULL, ".sv3264", NULL, ".tl", ".ul", ".te"
    };
  
  if ((aux->x_csect.x_smclas < ARRAY_SIZE (names))
      && (NULL != names[aux->x_csect.x_smclas]))
    {
      return_value = bfd_make_section_anyway
	(abfd, names[aux->x_csect.x_smclas]);
    }
  else
    {
      (*_bfd_error_handler)
	(_("%B: symbol `%s' has unrecognized smclas %d"),
	 abfd, symbol_name, aux->x_csect.x_smclas);
      bfd_set_error (bfd_error_bad_value);
    }

  return return_value;
}

static bfd_boolean
xcoff_is_lineno_count_overflow (bfd *abfd ATTRIBUTE_UNUSED, bfd_vma value)
{
  if (0xffff <= value)
    return TRUE;

  return FALSE;
}

static bfd_boolean
xcoff_is_reloc_count_overflow (bfd *abfd ATTRIBUTE_UNUSED, bfd_vma value)
{
  if (0xffff <= value)
    return TRUE;

  return FALSE;
}

static bfd_vma
xcoff_loader_symbol_offset (bfd *abfd,
                            struct internal_ldhdr *ldhdr ATTRIBUTE_UNUSED)
{
  return bfd_xcoff_ldhdrsz (abfd);
}

static bfd_vma
xcoff_loader_reloc_offset (bfd *abfd, struct internal_ldhdr *ldhdr)
{
  return bfd_xcoff_ldhdrsz (abfd) + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (abfd);
}

static bfd_boolean
xcoff_generate_rtinit  (bfd *abfd, const char *init, const char *fini,
                        bfd_boolean rtld)
{
  bfd_byte filehdr_ext[FILHSZ];
  bfd_byte scnhdr_ext[SCNHSZ];
  bfd_byte syment_ext[SYMESZ * 10];
  bfd_byte reloc_ext[RELSZ * 3];
  bfd_byte *data_buffer;
  bfd_size_type data_buffer_size;
  bfd_byte *string_table = NULL, *st_tmp = NULL;
  bfd_size_type string_table_size;
  bfd_vma val;
  size_t initsz, finisz;
  struct internal_filehdr filehdr;
  struct internal_scnhdr scnhdr;
  struct internal_syment syment;
  union internal_auxent auxent;
  struct internal_reloc reloc;

  char *data_name = ".data";
  char *rtinit_name = "__rtinit";
  char *rtld_name = "__rtld";

  if (! bfd_xcoff_rtinit_size (abfd))
    return FALSE;

  initsz = (init == NULL ? 0 : 1 + strlen (init));
  finisz = (fini == NULL ? 0 : 1 + strlen (fini));

  /* file header */
  memset (filehdr_ext, 0, FILHSZ);
  memset (&filehdr, 0, sizeof (struct internal_filehdr));
  filehdr.f_magic = bfd_xcoff_magic_number (abfd);
  filehdr.f_nscns = 1;
  filehdr.f_timdat = 0;
  filehdr.f_nsyms = 0;  /* at least 6, no more than 10 */
  filehdr.f_symptr = 0; /* set below */
  filehdr.f_opthdr = 0;
  filehdr.f_flags = 0;

  /* section header */
  memset (scnhdr_ext, 0, SCNHSZ);
  memset (&scnhdr, 0, sizeof (struct internal_scnhdr));
  memcpy (scnhdr.s_name, data_name, strlen (data_name));
  scnhdr.s_paddr = 0;
  scnhdr.s_vaddr = 0;
  scnhdr.s_size = 0;    /* set below */
  scnhdr.s_scnptr = FILHSZ + SCNHSZ;
  scnhdr.s_relptr = 0;  /* set below */
  scnhdr.s_lnnoptr = 0;
  scnhdr.s_nreloc = 0;  /* either 1 or 2 */
  scnhdr.s_nlnno = 0;
  scnhdr.s_flags = STYP_DATA;

  /* .data
     0x0000	      0x00000000 : rtl
     0x0004	      0x00000010 : offset to init, or 0
     0x0008	      0x00000028 : offset to fini, or 0
     0x000C	      0x0000000C : size of descriptor
     0x0010	      0x00000000 : init, needs a reloc
     0x0014	      0x00000040 : offset to init name
     0x0018	      0x00000000 : flags, padded to a word
     0x001C	      0x00000000 : empty init
     0x0020	      0x00000000 :
     0x0024	      0x00000000 :
     0x0028	      0x00000000 : fini, needs a reloc
     0x002C	      0x00000??? : offset to fini name
     0x0030	      0x00000000 : flags, padded to a word
     0x0034	      0x00000000 : empty fini
     0x0038	      0x00000000 :
     0x003C	      0x00000000 :
     0x0040	      init name
     0x0040 + initsz  fini name */

  data_buffer_size = 0x0040 + initsz + finisz;
  data_buffer_size = (data_buffer_size + 7) &~ (bfd_size_type) 7;
  data_buffer = NULL;
  data_buffer = (bfd_byte *) bfd_zmalloc (data_buffer_size);
  if (data_buffer == NULL)
    return FALSE;

  if (initsz)
    {
      val = 0x10;
      bfd_h_put_32 (abfd, val, &data_buffer[0x04]);
      val = 0x40;
      bfd_h_put_32 (abfd, val, &data_buffer[0x14]);
      memcpy (&data_buffer[val], init, initsz);
    }

  if (finisz)
    {
      val = 0x28;
      bfd_h_put_32 (abfd, val, &data_buffer[0x08]);
      val = 0x40 + initsz;
      bfd_h_put_32 (abfd, val, &data_buffer[0x2C]);
      memcpy (&data_buffer[val], fini, finisz);
    }

  val = 0x0C;
  bfd_h_put_32 (abfd, val, &data_buffer[0x0C]);

  scnhdr.s_size = data_buffer_size;

  /* string table */
  string_table_size = 0;
  if (initsz > 9)
    string_table_size += initsz;
  if (finisz > 9)
    string_table_size += finisz;
  if (string_table_size)
    {
      string_table_size += 4;
      string_table = (bfd_byte *) bfd_zmalloc (string_table_size);
      if (string_table == NULL)
	return FALSE;

      val = string_table_size;
      bfd_h_put_32 (abfd, val, &string_table[0]);
      st_tmp = string_table + 4;
    }

  /* symbols
     0. .data csect
     2. __rtinit
     4. init function
     6. fini function
     8. __rtld  */
  memset (syment_ext, 0, 10 * SYMESZ);
  memset (reloc_ext, 0, 3 * RELSZ);

  /* .data csect */
  memset (&syment, 0, sizeof (struct internal_syment));
  memset (&auxent, 0, sizeof (union internal_auxent));
  memcpy (syment._n._n_name, data_name, strlen (data_name));
  syment.n_scnum = 1;
  syment.n_sclass = C_HIDEXT;
  syment.n_numaux = 1;
  auxent.x_csect.x_scnlen.l = data_buffer_size;
  auxent.x_csect.x_smtyp = 3 << 3 | XTY_SD;
  auxent.x_csect.x_smclas = XMC_RW;
  bfd_coff_swap_sym_out (abfd, &syment,
			 &syment_ext[filehdr.f_nsyms * SYMESZ]);
  bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			 syment.n_numaux,
			 &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);
  filehdr.f_nsyms += 2;

  /* __rtinit */
  memset (&syment, 0, sizeof (struct internal_syment));
  memset (&auxent, 0, sizeof (union internal_auxent));
  memcpy (syment._n._n_name, rtinit_name, strlen (rtinit_name));
  syment.n_scnum = 1;
  syment.n_sclass = C_EXT;
  syment.n_numaux = 1;
  auxent.x_csect.x_smtyp = XTY_LD;
  auxent.x_csect.x_smclas = XMC_RW;
  bfd_coff_swap_sym_out (abfd, &syment,
			 &syment_ext[filehdr.f_nsyms * SYMESZ]);
  bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			 syment.n_numaux,
			 &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);
  filehdr.f_nsyms += 2;

  /* init */
  if (initsz)
    {
      memset (&syment, 0, sizeof (struct internal_syment));
      memset (&auxent, 0, sizeof (union internal_auxent));

      if (initsz > 9)
	{
	  syment._n._n_n._n_offset = st_tmp - string_table;
	  memcpy (st_tmp, init, initsz);
	  st_tmp += initsz;
	}
      else
	memcpy (syment._n._n_name, init, initsz - 1);

      syment.n_sclass = C_EXT;
      syment.n_numaux = 1;
      bfd_coff_swap_sym_out (abfd, &syment,
			     &syment_ext[filehdr.f_nsyms * SYMESZ]);
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
			     &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);

      /* reloc */
      memset (&reloc, 0, sizeof (struct internal_reloc));
      reloc.r_vaddr = 0x0010;
      reloc.r_symndx = filehdr.f_nsyms;
      reloc.r_type = R_POS;
      reloc.r_size = 31;
      bfd_coff_swap_reloc_out (abfd, &reloc, &reloc_ext[0]);

      filehdr.f_nsyms += 2;
      scnhdr.s_nreloc += 1;
    }

  /* fini */
  if (finisz)
    {
      memset (&syment, 0, sizeof (struct internal_syment));
      memset (&auxent, 0, sizeof (union internal_auxent));

      if (finisz > 9)
	{
	  syment._n._n_n._n_offset = st_tmp - string_table;
	  memcpy (st_tmp, fini, finisz);
	  st_tmp += finisz;
	}
      else
	memcpy (syment._n._n_name, fini, finisz - 1);

      syment.n_sclass = C_EXT;
      syment.n_numaux = 1;
      bfd_coff_swap_sym_out (abfd, &syment,
			     &syment_ext[filehdr.f_nsyms * SYMESZ]);
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
			     &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);

      /* reloc */
      memset (&reloc, 0, sizeof (struct internal_reloc));
      reloc.r_vaddr = 0x0028;
      reloc.r_symndx = filehdr.f_nsyms;
      reloc.r_type = R_POS;
      reloc.r_size = 31;
      bfd_coff_swap_reloc_out (abfd, &reloc,
			       &reloc_ext[scnhdr.s_nreloc * RELSZ]);

      filehdr.f_nsyms += 2;
      scnhdr.s_nreloc += 1;
    }

  if (rtld)
    {
      memset (&syment, 0, sizeof (struct internal_syment));
      memset (&auxent, 0, sizeof (union internal_auxent));
      memcpy (syment._n._n_name, rtld_name, strlen (rtld_name));
      syment.n_sclass = C_EXT;
      syment.n_numaux = 1;
      bfd_coff_swap_sym_out (abfd, &syment,
			     &syment_ext[filehdr.f_nsyms * SYMESZ]);
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
			     &syment_ext[(filehdr.f_nsyms + 1) * SYMESZ]);

      /* reloc */
      memset (&reloc, 0, sizeof (struct internal_reloc));
      reloc.r_vaddr = 0x0000;
      reloc.r_symndx = filehdr.f_nsyms;
      reloc.r_type = R_POS;
      reloc.r_size = 31;
      bfd_coff_swap_reloc_out (abfd, &reloc,
			       &reloc_ext[scnhdr.s_nreloc * RELSZ]);

      filehdr.f_nsyms += 2;
      scnhdr.s_nreloc += 1;
    }

  scnhdr.s_relptr = scnhdr.s_scnptr + data_buffer_size;
  filehdr.f_symptr = scnhdr.s_relptr + scnhdr.s_nreloc * RELSZ;

  bfd_coff_swap_filehdr_out (abfd, &filehdr, filehdr_ext);
  bfd_bwrite (filehdr_ext, FILHSZ, abfd);
  bfd_coff_swap_scnhdr_out (abfd, &scnhdr, scnhdr_ext);
  bfd_bwrite (scnhdr_ext, SCNHSZ, abfd);
  bfd_bwrite (data_buffer, data_buffer_size, abfd);
  bfd_bwrite (reloc_ext, scnhdr.s_nreloc * RELSZ, abfd);
  bfd_bwrite (syment_ext, filehdr.f_nsyms * SYMESZ, abfd);
  bfd_bwrite (string_table, string_table_size, abfd);

  free (data_buffer);
  data_buffer = NULL;

  return TRUE;
}


static reloc_howto_type xcoff_dynamic_reloc =
HOWTO (0,			/* type */
       0,			/* rightshift */
       2,			/* size (0 = byte, 1 = short, 2 = long) */
       32,			/* bitsize */
       FALSE,			/* pc_relative */
       0,			/* bitpos */
       complain_overflow_bitfield, /* complain_on_overflow */
       0,			/* special_function */
       "R_POS",			/* name */
       TRUE,			/* partial_inplace */
       0xffffffff,		/* src_mask */
       0xffffffff,		/* dst_mask */
       FALSE);			/* pcrel_offset */

/*  glink

   The first word of global linkage code must be modified by filling in
   the correct TOC offset.  */

static unsigned long xcoff_glink_code[9] =
  {
    0x81820000,	/* lwz r12,0(r2) */
    0x90410014,	/* stw r2,20(r1) */
    0x800c0000,	/* lwz r0,0(r12) */
    0x804c0004,	/* lwz r2,4(r12) */
    0x7c0903a6,	/* mtctr r0 */
    0x4e800420,	/* bctr */
    0x00000000,	/* start of traceback table */
    0x000c8000,	/* traceback table */
    0x00000000,	/* traceback table */
  };

/* Table to convert DWARF flags to section names.  */

const struct xcoff_dwsect_name xcoff_dwsect_names[] = {
  { SSUBTYP_DWINFO,  ".dwinfo",   TRUE },
  { SSUBTYP_DWLINE,  ".dwline",   TRUE },
  { SSUBTYP_DWPBNMS, ".dwpbnms",  TRUE },
  { SSUBTYP_DWPBTYP, ".dwpbtyp",  TRUE },
  { SSUBTYP_DWARNGE, ".dwarnge",  TRUE },
  { SSUBTYP_DWABREV, ".dwabrev",  FALSE },
  { SSUBTYP_DWSTR,   ".dwstr",    TRUE },
  { SSUBTYP_DWRNGES, ".dwrnges",  TRUE }
};

static const struct xcoff_backend_data_rec bfd_xcoff_backend_data =
  {
    { /* COFF backend, defined in libcoff.h.  */
      _bfd_xcoff_swap_aux_in,
      _bfd_xcoff_swap_sym_in,
      coff_swap_lineno_in,
      _bfd_xcoff_swap_aux_out,
      _bfd_xcoff_swap_sym_out,
      coff_swap_lineno_out,
      xcoff_swap_reloc_out,
      coff_swap_filehdr_out,
      coff_swap_aouthdr_out,
      coff_swap_scnhdr_out,
      FILHSZ,
      AOUTSZ,
      SCNHSZ,
      SYMESZ,
      AUXESZ,
      RELSZ,
      LINESZ,
      FILNMLEN,
      TRUE,			/* _bfd_coff_long_filenames */
      XCOFF_NO_LONG_SECTION_NAMES,  /* _bfd_coff_long_section_names */
      3,			/* _bfd_coff_default_section_alignment_power */
      FALSE,			/* _bfd_coff_force_symnames_in_strings */
      2,			/* _bfd_coff_debug_string_prefix_length */
      coff_swap_filehdr_in,
      coff_swap_aouthdr_in,
      coff_swap_scnhdr_in,
      xcoff_swap_reloc_in,
      coff_bad_format_hook,
      coff_set_arch_mach_hook,
      coff_mkobject_hook,
      styp_to_sec_flags,
      coff_set_alignment_hook,
      coff_slurp_symbol_table,
      symname_in_debug_hook,
      coff_pointerize_aux_hook,
      coff_print_aux,
      dummy_reloc16_extra_cases,
      dummy_reloc16_estimate,
      NULL,			/* bfd_coff_sym_is_global */
      coff_compute_section_file_positions,
      NULL,			/* _bfd_coff_start_final_link */
      xcoff_ppc_relocate_section,
      coff_rtype_to_howto,
      NULL,			/* _bfd_coff_adjust_symndx */
      _bfd_generic_link_add_one_symbol,
      coff_link_output_has_begun,
      coff_final_link_postscript,
      NULL			/* print_pdata.  */
    },

    0x01DF,			/* magic number */
    bfd_arch_rs6000,
    bfd_mach_rs6k,

    /* Function pointers to xcoff specific swap routines.  */
    xcoff_swap_ldhdr_in,
    xcoff_swap_ldhdr_out,
    xcoff_swap_ldsym_in,
    xcoff_swap_ldsym_out,
    xcoff_swap_ldrel_in,
    xcoff_swap_ldrel_out,

    /* Sizes.  */
    LDHDRSZ,
    LDSYMSZ,
    LDRELSZ,
    12,				/* _xcoff_function_descriptor_size */
    SMALL_AOUTSZ,

    /* Versions.  */
    1,				/* _xcoff_ldhdr_version */

    _bfd_xcoff_put_symbol_name,
    _bfd_xcoff_put_ldsymbol_name,
    &xcoff_dynamic_reloc,
    xcoff_create_csect_from_smclas,

    /* Lineno and reloc count overflow.  */
    xcoff_is_lineno_count_overflow,
    xcoff_is_reloc_count_overflow,

    xcoff_loader_symbol_offset,
    xcoff_loader_reloc_offset,

    /* glink.  */
    &xcoff_glink_code[0],
    36,				/* _xcoff_glink_size */

    /* rtinit */
    64,				/* _xcoff_rtinit_size */
    xcoff_generate_rtinit,
  };

/* The transfer vector that leads the outside world to all of the above.  */
const bfd_target rs6000coff_vec =
  {
    "aixcoff-rs6000",
    bfd_target_xcoff_flavour,
    BFD_ENDIAN_BIG,		/* data byte order is big */
    BFD_ENDIAN_BIG,		/* header byte order is big */

    (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | DYNAMIC
     | HAS_SYMS | HAS_LOCALS | WP_TEXT),

    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA,
    0,				/* leading char */
    '/',			/* ar_pad_char */
    15,				/* ar_max_namelen */
    0,				/* match priority.  */

    /* data */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    /* hdrs */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    { /* bfd_check_format */
      _bfd_dummy_target,
      coff_object_p,
      _bfd_xcoff_archive_p,
      CORE_FILE_P
    },

    { /* bfd_set_format */
      bfd_false,
      coff_mkobject,
      _bfd_generic_mkarchive,
      bfd_false
    },

    {/* bfd_write_contents */
      bfd_false,
      coff_write_object_contents,
      _bfd_xcoff_write_archive_contents,
      bfd_false
    },

    /* Generic */
    _bfd_archive_close_and_cleanup,
    bfd_true,
    coff_new_section_hook,
    _bfd_generic_get_section_contents,
    _bfd_generic_get_section_contents_in_window,

    /* Copy */
    _bfd_xcoff_copy_private_bfd_data,
    _bfd_generic_bfd_merge_private_bfd_data,
    _bfd_generic_init_private_section_data,
    _bfd_generic_bfd_copy_private_section_data,
    _bfd_generic_bfd_copy_private_symbol_data,
    _bfd_generic_bfd_copy_private_header_data,
    _bfd_generic_bfd_set_private_flags,
    _bfd_generic_bfd_print_private_bfd_data,

    /* Core */
    BFD_JUMP_TABLE_CORE (coff),

    /* Archive */
    _bfd_xcoff_slurp_armap,
    _bfd_noarchive_slurp_extended_name_table,
    _bfd_noarchive_construct_extended_name_table,
    bfd_dont_truncate_arname,
    _bfd_xcoff_write_armap,
    _bfd_xcoff_read_ar_hdr,
    _bfd_generic_write_ar_hdr,
    _bfd_xcoff_openr_next_archived_file,
    _bfd_generic_get_elt_at_index,
    _bfd_xcoff_stat_arch_elt,
    bfd_true,

    /* Symbols */
    coff_get_symtab_upper_bound,
    coff_canonicalize_symtab,
    coff_make_empty_symbol,
    coff_print_symbol,
    coff_get_symbol_info,
    _bfd_xcoff_is_local_label_name,
    coff_bfd_is_target_special_symbol,
    coff_get_lineno,
    xcoff_find_nearest_line,
    xcoff_find_nearest_line_discriminator,
    _bfd_generic_find_line,
    coff_find_inliner_info,
    coff_bfd_make_debug_symbol,
    _bfd_generic_read_minisymbols,
    _bfd_generic_minisymbol_to_symbol,

    /* Reloc */
    coff_get_reloc_upper_bound,
    coff_canonicalize_reloc,
    _bfd_xcoff_reloc_type_lookup,
    _bfd_xcoff_reloc_name_lookup,

    /* Write */
    coff_set_arch_mach,
    coff_set_section_contents,

    /* Link */
    _bfd_xcoff_sizeof_headers,
    bfd_generic_get_relocated_section_contents,
    bfd_generic_relax_section,
    _bfd_xcoff_bfd_link_hash_table_create,
    _bfd_generic_link_hash_table_free,
    _bfd_xcoff_bfd_link_add_symbols,
    _bfd_generic_link_just_syms,
    _bfd_generic_copy_link_hash_symbol_type,
    _bfd_xcoff_bfd_final_link,
    _bfd_generic_link_split_section,
    bfd_generic_gc_sections,
    bfd_generic_lookup_section_flags,
    bfd_generic_merge_sections,
    bfd_generic_is_group_section,
    bfd_generic_discard_group,
    _bfd_generic_section_already_linked,
    _bfd_xcoff_define_common_symbol,

    /* Dynamic */
    _bfd_xcoff_get_dynamic_symtab_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_symtab,
    _bfd_nodynamic_get_synthetic_symtab,
    _bfd_xcoff_get_dynamic_reloc_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_reloc,

    /* Opposite endian version, none exists */
    NULL,

    & bfd_xcoff_backend_data,
  };

/* xcoff-powermac target
   Old target.
   Only difference between this target and the rs6000 target is the
   the default architecture and machine type used in coffcode.h

   PowerPC Macs use the same magic numbers as RS/6000
   (because that's how they were bootstrapped originally),
   but they are always PowerPC architecture.  */
static const struct xcoff_backend_data_rec bfd_pmac_xcoff_backend_data =
  {
    { /* COFF backend, defined in libcoff.h.  */
      _bfd_xcoff_swap_aux_in,
      _bfd_xcoff_swap_sym_in,
      coff_swap_lineno_in,
      _bfd_xcoff_swap_aux_out,
      _bfd_xcoff_swap_sym_out,
      coff_swap_lineno_out,
      xcoff_swap_reloc_out,
      coff_swap_filehdr_out,
      coff_swap_aouthdr_out,
      coff_swap_scnhdr_out,
      FILHSZ,
      AOUTSZ,
      SCNHSZ,
      SYMESZ,
      AUXESZ,
      RELSZ,
      LINESZ,
      FILNMLEN,
      TRUE,			/* _bfd_coff_long_filenames */
      XCOFF_NO_LONG_SECTION_NAMES,  /* _bfd_coff_long_section_names */
      3,			/* _bfd_coff_default_section_alignment_power */
      FALSE,			/* _bfd_coff_force_symnames_in_strings */
      2,			/* _bfd_coff_debug_string_prefix_length */
      coff_swap_filehdr_in,
      coff_swap_aouthdr_in,
      coff_swap_scnhdr_in,
      xcoff_swap_reloc_in,
      coff_bad_format_hook,
      coff_set_arch_mach_hook,
      coff_mkobject_hook,
      styp_to_sec_flags,
      coff_set_alignment_hook,
      coff_slurp_symbol_table,
      symname_in_debug_hook,
      coff_pointerize_aux_hook,
      coff_print_aux,
      dummy_reloc16_extra_cases,
      dummy_reloc16_estimate,
      NULL,			/* bfd_coff_sym_is_global */
      coff_compute_section_file_positions,
      NULL,			/* _bfd_coff_start_final_link */
      xcoff_ppc_relocate_section,
      coff_rtype_to_howto,
      NULL,			/* _bfd_coff_adjust_symndx */
      _bfd_generic_link_add_one_symbol,
      coff_link_output_has_begun,
      coff_final_link_postscript,
      NULL			/* print_pdata.  */
    },

    0x01DF,			/* magic number */
    bfd_arch_powerpc,
    bfd_mach_ppc,

    /* Function pointers to xcoff specific swap routines.  */
    xcoff_swap_ldhdr_in,
    xcoff_swap_ldhdr_out,
    xcoff_swap_ldsym_in,
    xcoff_swap_ldsym_out,
    xcoff_swap_ldrel_in,
    xcoff_swap_ldrel_out,

    /* Sizes.  */
    LDHDRSZ,
    LDSYMSZ,
    LDRELSZ,
    12,				/* _xcoff_function_descriptor_size */
    SMALL_AOUTSZ,

    /* Versions.  */
    1,				/* _xcoff_ldhdr_version */

    _bfd_xcoff_put_symbol_name,
    _bfd_xcoff_put_ldsymbol_name,
    &xcoff_dynamic_reloc,
    xcoff_create_csect_from_smclas,

    /* Lineno and reloc count overflow.  */
    xcoff_is_lineno_count_overflow,
    xcoff_is_reloc_count_overflow,

    xcoff_loader_symbol_offset,
    xcoff_loader_reloc_offset,

    /* glink.  */
    &xcoff_glink_code[0],
    36,				/* _xcoff_glink_size */

    /* rtinit */
    0,				/* _xcoff_rtinit_size */
    xcoff_generate_rtinit,
  };

/* The transfer vector that leads the outside world to all of the above.  */
const bfd_target pmac_xcoff_vec =
  {
    "xcoff-powermac",
    bfd_target_xcoff_flavour,
    BFD_ENDIAN_BIG,		/* data byte order is big */
    BFD_ENDIAN_BIG,		/* header byte order is big */

    (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | DYNAMIC
     | HAS_SYMS | HAS_LOCALS | WP_TEXT),

    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA,
    0,				/* leading char */
    '/',			/* ar_pad_char */
    15,				/* ar_max_namelen */
    0,				/* match priority.  */

    /* data */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    /* hdrs */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    { /* bfd_check_format */
      _bfd_dummy_target,
      coff_object_p,
      _bfd_xcoff_archive_p,
      CORE_FILE_P
    },

    { /* bfd_set_format */
      bfd_false,
      coff_mkobject,
      _bfd_generic_mkarchive,
      bfd_false
    },

    {/* bfd_write_contents */
      bfd_false,
      coff_write_object_contents,
      _bfd_xcoff_write_archive_contents,
      bfd_false
    },

    /* Generic */
    _bfd_archive_close_and_cleanup,
    bfd_true,
    coff_new_section_hook,
    _bfd_generic_get_section_contents,
    _bfd_generic_get_section_contents_in_window,

    /* Copy */
    _bfd_xcoff_copy_private_bfd_data,
    _bfd_generic_bfd_merge_private_bfd_data,
    _bfd_generic_init_private_section_data,
    _bfd_generic_bfd_copy_private_section_data,
    _bfd_generic_bfd_copy_private_symbol_data,
    _bfd_generic_bfd_copy_private_header_data,
    _bfd_generic_bfd_set_private_flags,
    _bfd_generic_bfd_print_private_bfd_data,

    /* Core */
    BFD_JUMP_TABLE_CORE (coff),

    /* Archive */
    _bfd_xcoff_slurp_armap,
    _bfd_noarchive_slurp_extended_name_table,
    _bfd_noarchive_construct_extended_name_table,
    bfd_dont_truncate_arname,
    _bfd_xcoff_write_armap,
    _bfd_xcoff_read_ar_hdr,
    _bfd_generic_write_ar_hdr,
    _bfd_xcoff_openr_next_archived_file,
    _bfd_generic_get_elt_at_index,
    _bfd_xcoff_stat_arch_elt,
    bfd_true,

    /* Symbols */
    coff_get_symtab_upper_bound,
    coff_canonicalize_symtab,
    coff_make_empty_symbol,
    coff_print_symbol,
    coff_get_symbol_info,
    _bfd_xcoff_is_local_label_name,
    coff_bfd_is_target_special_symbol,
    coff_get_lineno,
    xcoff_find_nearest_line,
    _bfd_generic_find_nearest_line_discriminator,
    _bfd_generic_find_line,
    coff_find_inliner_info,
    coff_bfd_make_debug_symbol,
    _bfd_generic_read_minisymbols,
    _bfd_generic_minisymbol_to_symbol,

    /* Reloc */
    coff_get_reloc_upper_bound,
    coff_canonicalize_reloc,
    _bfd_xcoff_reloc_type_lookup,
    _bfd_xcoff_reloc_name_lookup,

    /* Write */
    coff_set_arch_mach,
    coff_set_section_contents,

    /* Link */
    _bfd_xcoff_sizeof_headers,
    bfd_generic_get_relocated_section_contents,
    bfd_generic_relax_section,
    _bfd_xcoff_bfd_link_hash_table_create,
    _bfd_generic_link_hash_table_free,
    _bfd_xcoff_bfd_link_add_symbols,
    _bfd_generic_link_just_syms,
    _bfd_generic_copy_link_hash_symbol_type,
    _bfd_xcoff_bfd_final_link,
    _bfd_generic_link_split_section,
    bfd_generic_gc_sections,
    bfd_generic_lookup_section_flags,
    bfd_generic_merge_sections,
    bfd_generic_is_group_section,
    bfd_generic_discard_group,
    _bfd_generic_section_already_linked,
    _bfd_xcoff_define_common_symbol,

    /* Dynamic */
    _bfd_xcoff_get_dynamic_symtab_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_symtab,
    _bfd_nodynamic_get_synthetic_symtab,
    _bfd_xcoff_get_dynamic_reloc_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_reloc,

    /* Opposite endian version, none exists */
    NULL,

    & bfd_pmac_xcoff_backend_data,
  };
@


1.113
log
@bfd/
2013-07-24  Tristan Gingold  <gingold@@adacore.com>

        * coff-rs6000.c (xcoff_howto_table): Fix masks and pc_relative for
        R_RBR.  Add numbers in comments.
        (_bfd_xcoff_reloc_type_lookup): Handle BFD_RELOC_PPC_B16.
        * coff64-rs6000.c: Likewise.

gas/
2013-07-24  Tristan Gingold  <gingold@@adacore.com>

        * config/tc-ppc.c (md_apply_fix): Adjust BFD_RELOC_PPC_B16 on
        xcoff targets.

gas/testsuite/
2013-07-24  Tristan Gingold  <gingold@@adacore.com>

        * gas/ppc/test2xcoff32.s, gas/ppc/test2xcoff32.d: New files
        * gas/ppc/ppc.exp: Add new test.
        * gas/ppc/xcoff-br16-1.s, gas/ppc/xcoff-br16-1.d,
        gas/ppc/xcoff-br16-2.s, gas/ppc/xcoff-br16-2.d: New files
        * gas/ppc/aix.exp: Add new tests.
@
text
@d2573 54
@


1.112
log
@2013-07-02  Tristan Gingold  <gingold@@adacore.com>

 	* coff-rs6000.c (xcoff_find_nearest_line_discriminator): Add missing
 	line.
@
text
@d734 1
a734 1
  /* Standard 32 bit relocation.  */
d749 1
a749 1
  /* 32 bit relocation, but store negative value.  */
d764 1
a764 1
  /* 32 bit PC relative relocation.  */
d779 1
a779 1
  /* 16 bit TOC relative relocation.  */
d794 1
a794 1
  /* I don't really know what this is.  */
d809 1
a809 1
  /* External TOC relative symbol.  */
d824 1
a824 1
  /* Local TOC relative symbol.	 */
d841 1
a841 1
  /* Non modifiable absolute branch.  */
d858 1
a858 1
  /* Non modifiable relative branch.  */
d875 1
a875 1
  /* Indirect load.  */
d890 1
a890 1
  /* Load address.  */
d907 1
a907 1
  /* Non-relocating reference.  Bitsize is 1 so that r_rsize is 0.  */
d925 1
a925 1
  /* TOC relative indirect load.  */
d940 1
a940 1
  /* TOC relative load address.  */
d955 1
a955 1
  /* Modifiable relative branch.  */
d970 1
a970 1
  /* Modifiable absolute branch.  */
d985 1
a985 1
  /* Modifiable call absolute indirect.  */
d1000 1
a1000 1
  /* Modifiable call relative.  */
d1015 1
a1015 1
  /* Modifiable branch absolute.  */
d1030 1
a1030 1
  /* Modifiable branch absolute.  */
d1045 1
a1045 1
  /* Modifiable branch relative.  */
d1060 1
a1060 1
  /* Modifiable branch absolute.  */
d1075 1
a1075 1
  /* 16 bit Non modifiable absolute branch.  */
d1090 1
a1090 1
  /* Modifiable branch relative.  */
d1095 1
a1095 1
	 FALSE,			/* pc_relative */
d1101 2
a1102 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d1105 1
a1105 1
  /* Modifiable branch relative.  */
d1169 2
@


1.111
log
@2013-07-02  Tristan Gingold  <gingold@@adacore.com>

	* coff-rs6000.c (xcoff_create_csect_from_smclas): Handle more smclas.
@
text
@d453 1
@


1.110
log
@2013-07-02  Tristan Gingold  <gingold@@adacore.com>

	* coff-rs6000.c (xcoff_find_nearest_line_discriminator): New function.
	(rs6000coff_vec): Reference it.
@
text
@d27 1
d3559 8
a3566 8
  static const char *names[19] =
  {
    ".pr", ".ro", ".db", ".tc", ".ua", ".rw", ".gl", ".xo",
    ".sv", ".bs", ".ds", ".uc", ".ti", ".tb", NULL, ".tc0",
    ".td", NULL, ".sv3264"
  };

  if ((19 >= aux->x_csect.x_smclas)
@


1.109
log
@bfd/
2013-05-16  Tristan Gingold  <gingold@@adacore.com>

	* coff-rs6000.c (_bfd_xcoff_reloc_type_lookup): Handle BFD_RELOC_16.
	* coff64-rs6000.c (xcoff64_reloc_type_lookup): Likewise.


gas/
2013-05-16  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ppc.c (ppc_is_toc_sym): Symbols of class XMC_TC
	are also TOC symbols.
@
text
@d452 16
d4139 1
a4139 1
    _bfd_generic_find_nearest_line_discriminator,
@


1.108
log
@Dangling bfd pointer in archive cache.

This dandling pointer eventually leads to a crash when trying to run
on ppc-aix a program using threading...

bfd/ChangeLog:

        * coff-rs6000.c (rs6000coff_vec): Set _close_and_cleanup
        field to _bfd_archive_close_and_cleanup.
        (pmac_xcoff_vec): Likewise.
@
text
@a1100 1

d1148 3
@


1.107
log
@	* vms-lib.c (_bfd_vms_lib_get_module): Use bfd_zmalloc for
	areltdata.
	* opncls.c (_bfd_delete_bfd): Free arelt_data.
	* mach-o.c (bfd_mach_o_fat_member_init): Use bfd_zmalloc for
	areltdata.
	* ecoff.c (_bfd_ecoff_slurp_armap): Use free for mapdata.
	* coff-rs6000.c (_bfd_xcoff_read_ar_hdr): Use bfd_zmalloc for
	areltdata.
	(xcoff_write_archive_contents_old): Likewise.
	(xcoff_write_archive_contents_big): Likewise.
	* archive64.c (bfd_elf64_archive_slurp_armap): Use free for
	areltdata.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Use bfd_zmalloc and
	free for areltdata.
	(_bfd_get_elt_at_filepos): Likewise.  Clear n_nfd->arelt_data on
	failure.
	(do_slurp_bsd_armap): Use bfd_zmalloc and free for areltdata.
	(do_slurp_coff_armap): Likewise.
	(_bfd_slurp_extended_name_table): Likewise.
	(bfd_slurp_bsd_armap_f2): Likewise.  Don't leak 'mapdata'.
@
text
@d4079 1
a4079 1
    bfd_true,
d4335 1
a4335 1
    bfd_true,
@


1.106
log
@2012-07-24  Teresa Johnson  <tejohnson@@google.com>

bfd/
	* bfd.c (bfd_find_nearest_line_discriminator): New macro.
	* coff-rs6000.c: Init _bfd_find_nearest_line_discriminator.
	* coff64-rs6000.c: Likewise.
	* dwarf2.c (struct line_info): Add discriminator field.
	(add_line_info): Fill in new discriminator field.
	(decode_line_info): Record discriminator information instead
        of ignoring it.
	(lookup_address_in_line_info_table): Return discriminator field if
        requested.
	(comp_unit_find_nearest_line): Add discriminator argument.
	(find_line): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.
	(_bfd_dwarf2_find_line): Likewise.
	* elf-bfd.h (_bfd_elf_find_nearest_line_discriminator): New.
        (_bfd_elf_find_line_discriminator): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): Likewise. Defined.
	* elf.c (_bfd_elf_find_nearest_line): Change to a wrapper
        that invokes _bfd_elf_find_nearest_line_discriminator with correct
        arguments.
	(_bfd_elf_find_nearest_line_discriminator): New.
	(_bfd_elf_find_line): Change to a wrapper
        that invokes _bfd_elf_find_line_discriminator with correct
        arguments.
	(_bfd_elf_find_line_discriminator): New.
	* coffgen.c (coff_find_nearest_line_with_names): Handle
        new discriminator argument.
	* elf32-arm.c (elf32_arm_find_nearest_line): Likewise.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Likewise.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Add discriminator
        argument.
        (_bfd_dwarf2_find_line): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): New.
	* libbfd.c (_bfd_generic_find_nearest_line_discriminator): New.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize
        _bfd_find_nearest_line_discriminator with
        _bfd_generic_find_nearest_line_discriminator.
        (bfd_target): Add _bfd_find_nearest_line_discriminator.

binutils/
	* addr2line.c (find_address_in_section): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator.
	(find_offset_in_section): Likewise.
	(translate_addresses): Print discriminator if it is non-zero.
	* objdump.c (show_line): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator,
        and keep track of prev_discriminator. Print discriminator
        if it is non-zero.
	(disassemble_data): Initialize prev_discriminator.
	(dump_reloc_set): Invoke bfd_find_nearest_line_discriminator
        to get the discriminator, and keep track of last_discriminator.
        Print discriminator if it is non-zero.
@
text
@d1499 1
a1499 1
  ret = (struct areltdata *) bfd_alloc (abfd, amt);
d2116 1
a2116 1
	  sub->arelt_data = bfd_zalloc (sub, sizeof (struct areltdata));
d2332 1
a2332 1
	  current_bfd->arelt_data = bfd_zalloc (current_bfd, size);
@


1.105
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d4121 1
d4377 1
@


1.104
log
@2011-09-30  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2.c (struct dwarf2_debug): Add field debug_sections.
	(read_section): Add sec argument. Adjust the code to get section
	names from it.
	(read_indirect_string): Adjust call to read_section.
	(read_abbrevs): Ditto.
	(decode_line_info): Ditto.
	(read_debug_ranges): Ditto.
	(DWARF2_DEBUG_INFO, DWARF2_COMPRESSED_DEBUG_INFO): Remove.
	(find_debug_info): Add debug_sections parameter.  Use it instead
	the above macros.
	(place_sections): Get section names from stash.
	(find_line): Add debug_sections argument.  Initialize
	debug_sections field of stash from it.
	Adjust calls to find_debug_info.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	Adjust call to find_line.
	(_bfd_dwarf2_find_line): Adjust call to find_line.
	* libcoff-in.h (struct dwarf_debug_section): New declaration.
	(coff_find_nearest_line_with_names): Likewise.
	* libcoff.h: Regenerate.
	* libbfd-in.h (struct dwarf_debug_section): Move declaration.
	(dwarf_debug_sections): Likewise.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_find_nearest_line): Adjust call to
	_bfd_dwarf2_find_nearest_line.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Ditto.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Ditto.
	* elf32-arm.c (elf32_arm_find_nearest_line): Ditto.
	* coffgen.c (coff_find_nearest_line_with_names): New function.
	(coff_find_nearest_line): Calls coff_find_nearest_line_with_names.
	* coff-rs6000.c (xcoff_debug_sections): New constant.
	(xcoff_find_nearest_line): New function.
	(rs6000coff_vec): Use xcoff_find_nearest_line.
	(pmac_xcoff_vec): Ditto.
@
text
@d3 1
a3 1
   2008, 2009, 2010, 2011
d43 1
a43 1
extern PTR _bfd_xcoff_read_ar_hdr (bfd *);
d50 3
a52 3
extern void _bfd_xcoff_swap_sym_in (bfd *, PTR, PTR);
extern unsigned int _bfd_xcoff_swap_sym_out (bfd *, PTR, PTR);
extern void _bfd_xcoff_swap_aux_in (bfd *, PTR, int, int, int, int, PTR);
d54 3
a56 3
  (bfd *, PTR, int, int, int, int, PTR);
static void xcoff_swap_reloc_in (bfd *, PTR, PTR);
static unsigned int xcoff_swap_reloc_out (bfd *, PTR, PTR);
d132 6
a137 6
static void xcoff_swap_ldhdr_in (bfd *, const PTR, struct internal_ldhdr *);
static void xcoff_swap_ldhdr_out (bfd *, const struct internal_ldhdr *, PTR);
static void xcoff_swap_ldsym_in (bfd *, const PTR, struct internal_ldsym *);
static void xcoff_swap_ldsym_out (bfd *, const struct internal_ldsym *, PTR);
static void xcoff_swap_ldrel_in (bfd *, const PTR, struct internal_ldrel *);
static void xcoff_swap_ldrel_out (bfd *, const struct internal_ldrel *, PTR);
d454 1
a454 1
_bfd_xcoff_swap_sym_in (bfd *abfd, PTR ext1, PTR in1)
d477 1
a477 1
_bfd_xcoff_swap_sym_out (bfd *abfd, PTR inp, PTR extp)
d501 2
a502 2
_bfd_xcoff_swap_aux_in (bfd *abfd, PTR ext1, int type, int in_class,
                        int indx, int numaux, PTR in1)
d611 1
a611 1
_bfd_xcoff_swap_aux_out (bfd *abfd, PTR inp, int type, int in_class,
d614 1
a614 1
                         PTR extp)
d619 1
a619 1
  memset ((PTR)ext, 0, bfd_coff_auxesz (abfd));
d1266 1
a1266 1
      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
d1282 1
a1282 1
      if (bfd_bread ((PTR) contents, sz, abfd) != sz)
d1321 1
a1321 1
      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
d1340 1
a1340 1
      if (bfd_bread ((PTR) contents, sz, abfd) != sz)
d1393 1
a1393 1
  if (bfd_bread ((PTR) magic, amt, abfd) != amt)
d1432 1
a1432 1
      if (bfd_bread ((PTR) &hdr.memoff, amt, abfd) != amt)
d1459 1
a1459 1
      if (bfd_bread ((PTR) &hdr.memoff, amt, abfd) != amt)
d1492 1
a1492 1
PTR
d1508 1
a1508 1
      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
d1540 1
a1540 1
      if (bfd_bread ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
d1575 1
a1575 1
  return (PTR) ret;
d1716 1
a1716 1
  if (bfd_bwrite ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
d2233 1
a2233 1
  if ((bfd_bwrite ((PTR) &ahdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)
d2235 1
a2235 1
      || (bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)
d2240 1
a2240 1
  if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE, abfd)
d2246 1
a2246 1
      if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE,
d2257 1
a2257 1
      if (bfd_bwrite ((PTR) name, namlen + 1, abfd) != namlen + 1)
d2271 1
a2271 1
      bfd_ardata (abfd)->tdata = (PTR) &fhdr;
d2284 1
a2284 1
      || (bfd_bwrite ((PTR) &fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR, abfd)
d2512 1
a2512 1
      bfd_ardata (abfd)->tdata = (PTR) &fhdr;
d2520 1
a2520 1
      || (bfd_bwrite ((PTR) &fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR_BIG,
d2562 1
a2562 1
xcoff_swap_ldhdr_in (bfd *abfd, const PTR s, struct internal_ldhdr *dst)
d2579 1
a2579 1
xcoff_swap_ldhdr_out (bfd *abfd, const struct internal_ldhdr *src, PTR d)
d2596 1
a2596 1
xcoff_swap_ldsym_in (bfd *abfd, const PTR s, struct internal_ldsym *dst)
d2617 1
a2617 1
xcoff_swap_ldsym_out (bfd *abfd, const struct internal_ldsym *src, PTR d)
d2638 1
a2638 1
xcoff_swap_reloc_in (bfd *abfd, PTR s, PTR d)
d2652 1
a2652 1
xcoff_swap_reloc_out (bfd *abfd, PTR s, PTR d)
d2668 1
a2668 1
xcoff_swap_ldrel_in (bfd *abfd, const PTR s, struct internal_ldrel *dst)
d2681 1
a2681 1
xcoff_swap_ldrel_out (bfd *abfd, const struct internal_ldrel *src, PTR d)
d4166 1
a4166 1
    (void *) &bfd_xcoff_backend_data,
d4421 1
a4421 1
    (void *) &bfd_pmac_xcoff_backend_data,
@


1.103
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@d408 44
d4120 1
a4120 1
    coff_find_nearest_line,
d4375 1
a4375 1
    coff_find_nearest_line,
@


1.102
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d4105 1
d4360 1
@


1.101
log
@bfd
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* libxcoff.h (struct xcoff_dwsect_name): New type.
	(XCOFF_DWSECT_NBR_NAMES): New macro.
	(xcoff_dwsect_names): Declare.
	* coffcode.h (sec_to_styp_flags): Handle xcoff dwarf sections.
	(styp_to_sec_flags): Ditto.
	(coff_new_section_hook): Ditto.
	(coff_slurp_symbol_table): Handle C_DWARF and C_INFO.
	* coff-rs6000.c (xcoff_dwsect_name): New variable.

gas
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ppc.h (ppc_tc_sy): Reorder fields.
	Put size into an union with dw.
	(OBJ_COPY_SYMBOL_ATTRIBUTES): Adjust.
	(ppc_xcoff_end): Declare.
	(md_end): Define.
	* config/tc-ppc.c: Add includes for xcoff.
	(ppc_dwsect): New function.
	(md_pseudo_table): Add dwsect.
	(struct dw_subsection): New.
	(dw_sections): New.
	(ppc_change_debug_section): New function.
	(ppc_xcoff_end): Ditto.
	(ppc_function): Adjust for ppc_tc_sy.
	(ppc_symbol_new_hook): Ditto.
	(ppc_frob_symbol): Ditto.
	(ppc_frob_section): Do not set vma for debug sections.
	(ppc_fix_adjustable): Return true for debug sections.
	* config/obj-coff.c: Add includes for xcoff.
	(coff_frob_section): Handle dwarf section.

gas/testsuite
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* gas/ppc/xcoff-dwsect-1-32.d: New test.
	* gas/ppc/xcoff-dwsect-1-64.d: Ditto.
	* gas/ppc/xcoff-dwsect-1.s: New file.
	* gas/ppc/aix.exp (do_align_test): Add tests.
@
text
@d3 1
a3 1
   2008, 2009, 2010
d3989 1
d4243 1
@


1.100
log
@include/coff
2011-05-04  Tristan Gingold  <gingold@@adacore.com>

	* rs6000.h (union external_auxent): Add x_ftype field.
	* rs6k64.h: (struct external_auxent): Remap x_file field.


bfd/
2011-04-28  Tristan Gingold  <gingold@@adacore.com>

	* coff-rs6000.c (_bfd_xcoff_swap_aux_in): Adjust for x_file.
	(bfd_xcoff_swap_aux_out): Ditto.
	* coff64-rs6000.c (_bfd_xcoff64_swap_aux_in): Ditto.
	(bfd_xcoff64_swap_aux_out): Ditto.
@
text
@d3865 12
@


1.99
log
@2011-04-18  Tristan Gingold  <gingold@@adacore.com>

	* coff-rs6000.c: Convert to ISO-C.  Remove PARAMS macro.
@
text
@d466 1
a466 1
      if (ext->x_file.x_fname[0] == 0)
d470 1
a470 1
	    H_GET_32 (abfd, ext->x_file.x_n.x_offset);
d477 1
a477 1
		memcpy (in->x_file.x_fname, ext->x_file.x_fname,
d482 1
a482 1
	      memcpy (in->x_file.x_fname, ext->x_file.x_fname, FILNMLEN);
d581 3
a583 2
	  H_PUT_32 (abfd, 0, ext->x_file.x_n.x_zeroes);
	  H_PUT_32 (abfd, in->x_file.x_n.x_offset, ext->x_file.x_n.x_offset);
d587 1
a587 1
	  memcpy (ext->x_file.x_fname, in->x_file.x_fname, FILNMLEN);
@


1.98
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d36 3
a38 6
extern bfd_boolean _bfd_xcoff_mkobject
  PARAMS ((bfd *));
extern bfd_boolean _bfd_xcoff_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
extern bfd_boolean _bfd_xcoff_is_local_label_name
  PARAMS ((bfd *, const char *));
d40 6
a45 11
  PARAMS ((bfd *, bfd_reloc_code_real_type));
extern bfd_boolean _bfd_xcoff_slurp_armap
  PARAMS ((bfd *));
extern const bfd_target *_bfd_xcoff_archive_p
  PARAMS ((bfd *));
extern PTR _bfd_xcoff_read_ar_hdr
  PARAMS ((bfd *));
extern bfd *_bfd_xcoff_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
extern int _bfd_xcoff_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
d47 6
a52 11
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
extern bfd_boolean _bfd_xcoff_write_archive_contents
  PARAMS ((bfd *));
extern int _bfd_xcoff_sizeof_headers
  PARAMS ((bfd *, struct bfd_link_info *));
extern void _bfd_xcoff_swap_sym_in
  PARAMS ((bfd *, PTR, PTR));
extern unsigned int _bfd_xcoff_swap_sym_out
  PARAMS ((bfd *, PTR, PTR));
extern void _bfd_xcoff_swap_aux_in
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
d54 3
a56 5
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
static void xcoff_swap_reloc_in
  PARAMS ((bfd *, PTR, PTR));
static unsigned int xcoff_swap_reloc_out
  PARAMS ((bfd *, PTR, PTR));
d59 1
a59 2
void xcoff_rtype2howto
  PARAMS ((arelent *, struct internal_reloc *));
d84 1
a84 2
extern const bfd_target * rs6000coff_core_p
  PARAMS ((bfd *abfd));
d86 3
a88 5
  PARAMS ((bfd *cbfd, bfd *ebfd));
extern char *rs6000coff_core_file_failing_command
  PARAMS ((bfd *abfd));
extern int rs6000coff_core_file_failing_signal
  PARAMS ((bfd *abfd));
d125 1
a125 2
static const char *normalize_filename
  PARAMS ((bfd *));
d127 1
a127 1
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
d129 9
a137 17
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
static bfd_boolean xcoff_write_archive_contents_old
  PARAMS ((bfd *));
static bfd_boolean xcoff_write_archive_contents_big
  PARAMS ((bfd *));
static void xcoff_swap_ldhdr_in
  PARAMS ((bfd *, const PTR, struct internal_ldhdr *));
static void xcoff_swap_ldhdr_out
  PARAMS ((bfd *, const struct internal_ldhdr *, PTR));
static void xcoff_swap_ldsym_in
  PARAMS ((bfd *, const PTR, struct internal_ldsym *));
static void xcoff_swap_ldsym_out
  PARAMS ((bfd *, const struct internal_ldsym *, PTR));
static void xcoff_swap_ldrel_in
  PARAMS ((bfd *, const PTR, struct internal_ldrel *));
static void xcoff_swap_ldrel_out
  PARAMS ((bfd *, const struct internal_ldrel *, PTR));
d139 2
a140 2
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
d142 1
a142 2
  PARAMS ((bfd *, struct xcoff_loader_info *, struct internal_ldsym *,
	   const char *));
d144 5
a148 9
  PARAMS ((bfd *, union internal_auxent *, const char *));
static bfd_boolean xcoff_is_lineno_count_overflow
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean xcoff_is_reloc_count_overflow
  PARAMS ((bfd *, bfd_vma));
static bfd_vma xcoff_loader_symbol_offset
  PARAMS ((bfd *, struct internal_ldhdr *));
static bfd_vma xcoff_loader_reloc_offset
  PARAMS ((bfd *, struct internal_ldhdr *));
d150 3
a152 5
  PARAMS ((bfd *, const char *, const char *, bfd_boolean));
static bfd_boolean do_pad
  PARAMS ((bfd *, unsigned int));
static bfd_boolean do_copy
  PARAMS ((bfd *, bfd *));
d155 1
a155 2
static bfd_boolean xcoff_reloc_type_br
  PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
d158 1
a158 1
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));
d160 1
a160 1
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));
d162 1
a162 1
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));
d164 1
a164 1
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS));
d167 1
a167 1
  PARAMS ((XCOFF_RELOC_FUNCTION_ARGS)) =
d200 1
a200 1
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS)) =
d325 1
a325 2
_bfd_xcoff_mkobject (abfd)
     bfd *abfd;
d357 1
a357 3
_bfd_xcoff_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d403 2
a404 3
_bfd_xcoff_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
d410 1
a410 4
_bfd_xcoff_swap_sym_in (abfd, ext1, in1)
     bfd *abfd;
     PTR ext1;
     PTR in1;
d433 1
a433 4
_bfd_xcoff_swap_sym_out (abfd, inp, extp)
     bfd *abfd;
     PTR inp;
     PTR extp;
d457 2
a458 8
_bfd_xcoff_swap_aux_in (abfd, ext1, type, in_class, indx, numaux, in1)
     bfd *abfd;
     PTR ext1;
     int type;
     int in_class;
     int indx;
     int numaux;
     PTR in1;
a565 4

unsigned int _bfd_xcoff_swap_aux_out
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));

d567 4
a570 8
_bfd_xcoff_swap_aux_out (abfd, inp, type, in_class, indx, numaux, extp)
     bfd * abfd;
     PTR   inp;
     int   type;
     int   in_class;
     int   indx ATTRIBUTE_UNUSED;
     int   numaux ATTRIBUTE_UNUSED;
     PTR   extp;
d1060 1
a1060 3
xcoff_rtype2howto (relent, internal)
     arelent *relent;
     struct internal_reloc *internal;
d1091 2
a1092 3
_bfd_xcoff_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1178 2
a1179 3
bfd_xcoff_ar_archive_set_magic (abfd, magic)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *magic ATTRIBUTE_UNUSED;
d1189 1
a1189 2
_bfd_xcoff_slurp_armap (abfd)
     bfd *abfd;
d1342 1
a1342 2
_bfd_xcoff_archive_p (abfd)
     bfd *abfd;
d1448 1
a1448 2
_bfd_xcoff_read_ar_hdr (abfd)
     bfd *abfd;
d1536 1
a1536 3
_bfd_xcoff_openr_next_archived_file (archive, last_file)
     bfd *archive;
     bfd *last_file;
d1595 1
a1595 3
_bfd_xcoff_stat_arch_elt (abfd, s)
     bfd *abfd;
     struct stat *s;
d1630 1
a1630 2
normalize_filename (abfd)
     bfd *abfd;
d1647 2
a1648 6
xcoff_write_armap_old (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength ATTRIBUTE_UNUSED;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
d1742 1
a1742 3
do_pad (abfd, number)
     bfd *abfd;
     unsigned int number;
d1758 1
a1758 3
do_copy (out_bfd, in_bfd)
     bfd *out_bfd;
     bfd *in_bfd;
d1788 2
a1789 6
xcoff_write_armap_big (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength ATTRIBUTE_UNUSED;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
d2028 2
a2029 6
_bfd_xcoff_write_armap (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength ATTRIBUTE_UNUSED;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
d2041 1
a2041 2
xcoff_write_archive_contents_old (abfd)
     bfd *abfd;
d2247 1
a2247 2
xcoff_write_archive_contents_big (abfd)
     bfd *abfd;
d2483 1
a2483 2
_bfd_xcoff_write_archive_contents (abfd)
     bfd *abfd;
d2517 1
a2517 4
xcoff_swap_ldhdr_in (abfd, s, dst)
     bfd *abfd;
     const PTR s;
     struct internal_ldhdr *dst;
d2534 1
a2534 4
xcoff_swap_ldhdr_out (abfd, src, d)
     bfd *abfd;
     const struct internal_ldhdr *src;
     PTR d;
d2551 1
a2551 4
xcoff_swap_ldsym_in (abfd, s, dst)
     bfd *abfd;
     const PTR s;
     struct internal_ldsym *dst;
d2572 1
a2572 4
xcoff_swap_ldsym_out (abfd, src, d)
     bfd *abfd;
     const struct internal_ldsym *src;
     PTR d;
d2593 1
a2593 4
xcoff_swap_reloc_in (abfd, s, d)
     bfd *abfd;
     PTR s;
     PTR d;
d2607 1
a2607 4
xcoff_swap_reloc_out (abfd, s, d)
     bfd *abfd;
     PTR s;
     PTR d;
d2623 1
a2623 4
xcoff_swap_ldrel_in (abfd, s, dst)
     bfd *abfd;
     const PTR s;
     struct internal_ldrel *dst;
d2636 1
a2636 4
xcoff_swap_ldrel_out (abfd, src, d)
     bfd *abfd;
     const struct internal_ldrel *src;
     PTR d;
d2648 10
a2657 12
xcoff_reloc_type_noop (input_bfd, input_section, output_bfd, rel, sym, howto,
		       val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma addend ATTRIBUTE_UNUSED;
     bfd_vma *relocation ATTRIBUTE_UNUSED;
     bfd_byte *contents ATTRIBUTE_UNUSED;
d2663 10
a2672 12
xcoff_reloc_type_fail (input_bfd, input_section, output_bfd, rel, sym, howto,
		       val, addend, relocation, contents)
     bfd *input_bfd;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma addend ATTRIBUTE_UNUSED;
     bfd_vma *relocation ATTRIBUTE_UNUSED;
     bfd_byte *contents ATTRIBUTE_UNUSED;
d2682 10
a2691 12
xcoff_reloc_type_pos (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
d2698 10
a2707 12
xcoff_reloc_type_neg (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
d2714 10
a2723 12
xcoff_reloc_type_rel (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
d2737 10
a2746 12
xcoff_reloc_type_toc (input_bfd, input_section, output_bfd, rel, sym, howto,
		      val, addend, relocation, contents)
     bfd *input_bfd;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     struct internal_reloc *rel;
     struct internal_syment *sym;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
     bfd_vma val;
     bfd_vma addend ATTRIBUTE_UNUSED;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
d2778 10
a2787 12
xcoff_reloc_type_ba (input_bfd, input_section, output_bfd, rel, sym, howto,
		     val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
d2798 10
a2807 12
xcoff_reloc_type_br (input_bfd, input_section, output_bfd, rel, sym, howto,
		     val, addend, relocation, contents)
     bfd *input_bfd;
     asection *input_section;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents;
d2904 10
a2913 12
xcoff_reloc_type_crel (input_bfd, input_section, output_bfd, rel, sym, howto,
		       val, addend, relocation, contents)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct internal_reloc *rel ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma addend;
     bfd_vma *relocation;
     bfd_byte *contents ATTRIBUTE_UNUSED;
d2929 5
a2933 5
xcoff_complain_overflow_dont_func (input_bfd, val, relocation, howto)
     bfd *input_bfd ATTRIBUTE_UNUSED;
     bfd_vma val ATTRIBUTE_UNUSED;
     bfd_vma relocation ATTRIBUTE_UNUSED;
     struct reloc_howto_struct *howto ATTRIBUTE_UNUSED;
d2939 4
a2942 5
xcoff_complain_overflow_bitfield_func (input_bfd, val, relocation, howto)
     bfd *input_bfd;
     bfd_vma val;
     bfd_vma relocation;
     struct reloc_howto_struct *howto;
d3013 4
a3016 5
xcoff_complain_overflow_signed_func (input_bfd, val, relocation, howto)
     bfd *input_bfd;
     bfd_vma val;
     bfd_vma relocation;
     struct reloc_howto_struct *howto;
d3074 4
a3077 5
xcoff_complain_overflow_unsigned_func (input_bfd, val, relocation, howto)
     bfd *input_bfd;
     bfd_vma val;
     bfd_vma relocation;
     struct reloc_howto_struct *howto;
d3223 8
a3230 11
xcoff_ppc_relocate_section (output_bfd, info, input_bfd,
			    input_section, contents, relocs, syms,
			    sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
d3416 4
a3419 5
_bfd_xcoff_put_ldsymbol_name (abfd, ldinfo, ldsym, name)
     bfd *abfd ATTRIBUTE_UNUSED;
	 struct xcoff_loader_info *ldinfo;
	 struct internal_ldsym *ldsym;
	 const char *name;
d3487 3
a3489 4
xcoff_create_csect_from_smclas (abfd, aux, symbol_name)
     bfd *abfd;
     union internal_auxent *aux;
     const char *symbol_name;
d3520 1
a3520 3
xcoff_is_lineno_count_overflow (abfd, value)
    bfd *abfd ATTRIBUTE_UNUSED;
	bfd_vma value;
d3529 1
a3529 3
xcoff_is_reloc_count_overflow (abfd, value)
    bfd *abfd ATTRIBUTE_UNUSED;
	bfd_vma value;
d3538 2
a3539 3
xcoff_loader_symbol_offset (abfd, ldhdr)
    bfd *abfd;
    struct internal_ldhdr *ldhdr ATTRIBUTE_UNUSED;
d3545 1
a3545 3
xcoff_loader_reloc_offset (abfd, ldhdr)
    bfd *abfd;
    struct internal_ldhdr *ldhdr;
d3551 2
a3552 5
xcoff_generate_rtinit  (abfd, init, fini, rtld)
     bfd *abfd;
     const char *init;
     const char *fini;
     bfd_boolean rtld;
@


1.97
log
@fix set but unused variable warnings
@
text
@d115 2
d125 2
d4189 1
a4189 3
    coff_core_file_failing_command,
    coff_core_file_failing_signal,
    coff_core_file_matches_executable_p,
d4442 1
a4442 3
    coff_core_file_failing_command,
    coff_core_file_failing_signal,
    coff_core_file_matches_executable_p,
@


1.96
log
@Update copyright year.

2010-03-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-target.h: Update copyright year.
	* aout-tic30.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* elf64-mips.c: Likewise.
	* ieee.c: Likewise.
	* libecoff.h: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* oasys.c: Likewise.
	* targets.c: Likewise.
@
text
@d3074 1
a3074 1
  bfd_vma addrmask, fieldmask, signmask, ss;
a3081 1
  addrmask = N_ONES (bfd_arch_bits_per_address (input_bfd)) | fieldmask;
@


1.95
log
@2010-01-26  Tristan Gingold  <gingold@@adacore.com>

	* targets.c (BFD_JUMP_TABLE_ARCHIVE): Add initializer for write_ar_hdr.
	(bfd_target): Add _bfd_write_ar_hdr_fn field.
	* archive.c (is_bsd44_extended_name): New macro.
	(_bfd_generic_read_ar_hdr_mag): Use it.  Add extra_size.
	(bfd_slurp_armap): Also check for "__.SYMDEF" as a BSD4.4 extended
	name.
	(_bfd_archive_bsd44_construct_extended_name_table): New function.
	(_bfd_generic_write_ar_hdr): Ditto.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_archive_contents): Call _bfd_write_ar_hdr.
	(bsd_write_armap): Adjust firstreal computation.
	* libbfd-in.h (struct areltdata): Add extra_size field.
	(_bfd_generic_write_ar_hdr): Add prototype.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_ar_hdr): Define.
	(_bfd_noarchive_write_ar_hdr): Ditto.
	(_bfd_archive_bsd_write_ar_hdr): Ditto.
	(_bfd_archive_coff_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_slurp_armap): Ditto.
	(_bfd_archive_bsd44_slurp_extended_name_table): Ditto.
	(_bfd_archive_bsd44_construct_extended_name_table): New prototype.
	(_bfd_archive_bsd44_truncate_arname): Ditto.
	(_bfd_archive_bsd44_write_armap): Ditto.
	(_bfd_archive_bsd44_read_ar_hdr): Ditto.
	(_bfd_archive_bsd44_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_openr_next_archived_file): Ditto.
	(_bfd_archive_bsd44_get_elt_at_index): Ditto.
	(_bfd_archive_bsd44_generic_stat_arch_elt): Ditto.
	(_bfd_archive_bsd44_update_armap_timestamp): Ditto.
	* libbfd.h: Regenerate.
	* oasys.c (oasys_write_ar_hdr): Define.
	* libecoff.h (_bfd_ecoff_write_ar_hdr): Define.
	* ieee.c (ieee_write_ar_hdr): Define.
	* elf64-mips.c (bfd_elf64_archive_write_ar_hdr): Define.
	* coff-rs6000.c (rs6000coff_vec): Adjust for write_ar_hdr field.
	(bfd_pmac_xcoff_backend_data): Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(bfd_xcoff_aix5_backend_data): Ditto.
	* coff-alpha.c (alpha_ecoff_write_ar_hdr): Define.
	* aout-target.h (MY_write_ar_hdr): Define it if not defined.
	* aout-tic30.c (MY_write_ar_hdr): Ditto.
	* mach-o-target.c (TARGET_NAME): Use _bfd_archive_bsd44 archive.
	(bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved to mach-o.c
	* mach-o.c (bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved from mach-o-target.c
	* bfd-in2.h: Regenerate.
@
text
@d3 2
a4 1
   2008, 2009  Free Software Foundation, Inc.
@


1.94
log
@bfd/
	* coff-rs6000.c (xcoff_howto_table): Change size to 0 and bitsize to 1.
	(_bfd_xcoff_reloc_type_lookup): Handle BFD_RELOC_NONE.
	* coff64-rs6000.c (xcoff64_howto_table): Change size to 0 and
	bitsize to 1.
	(xcoff64_reloc_type_lookup): Handle BFD_RELOC_NONE.

gas/
	* write.h (fix_at_start): Declare.
	* write.c (fix_new_internal): Add at_beginning parameter.
	Use it instead of REVERSE_SORT_RELOCS.  Fix the handling of
	seg_fix_tailP for the at_beginning/REVERSE_SORT_RELOCS case.
	(fix_new, fix_new_exp): Update accordingly.
	(fix_at_start): New function.
	* config/tc-ppc.c (md_pseudo_table): Add .ref to the OBJ_XCOFF section.
	(ppc_ref): New function, for OBJ_XCOFF.
	(md_apply_fix): Handle BFD_RELOC_NONE for OBJ_XCOFF.
	* config/te-i386aix.h (REVERSE_SORT_RELOCS): Remove #undef.

gas/testsuite/
	* gas/ppc/xcoff-ref-1.s, gas/ppc/xcoff-ref-1.l: New test.
	* gas/ppc/aix.exp: Run it.


ld/testsuite/
	* ld-powerpc/aix-ref-1-32.od, ld-powerpc/aix-ref-1-64.od,
	ld-powerpc/aix-ref-1.s: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d4196 1
d4451 1
@


1.93
log
@2009-11-23  Paul Brook  <paul@@codesourcery.com>

	ld/
	* ldexp.c: Copy symbol type for simple assignments.

	bfd/
	* libbfd-in.h (_bfd_generic_copy_link_hash_symbol_type): Add
	prototype.
	* elf-bfd.h (_bfd_elf_copy_link_hash_symbol_type): Add prototype.
	* linker.c (_bfd_generic_copy_link_hash_symbol_type): New function.
	* elflink.c (_bfd_elf_copy_link_hash_symbol_type): New function.
	* targets.c (BFD_JUMP_TABLE_LINK, struct bfd_target): Add
	_copy_link_hash_symbol_type.
	* bfd/coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* bfd/coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* aout-adobe.c (aout_32_bfd_copy_link_hash_symbol_type): Define.
	* aout-target.h (MY_bfd_copy_link_hash_symbol_type): Define.
	* aout-tic30.c (MY_bfd_copy_link_hash_symbol_type): Define.
	* binary.c (binary_bfd_copy_link_hash_symbol_type): Define.
	* bout.c (b_out_bfd_copy_link_hash_symbol_type): Define.
	* coffcode.h (coff_bfd_copy_link_hash_symbol_type): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_link_hash_symbol_type): Define.
	* i386msdos.c (msdos_bfd_copy_link_hash_symbol_type): Define.
	* i386os9k.c (os9k_bfd_copy_link_hash_symbol_type): Define.
	* ieee.c (ieee_bfd_copy_link_hash_symbol_type): Define.
	* ihex.c (ihex_bfd_copy_link_hash_symbol_type): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_link_hash_symbol_type): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_link_hash_symbol_type): Define.
	* mmo.c (mmo_bfd_copy_link_hash_symbol_type): Define.
	* nlm-target.h (nlm_bfd_copy_link_hash_symbol_type): Define.
	* oasys.c (oasys_bfd_copy_link_hash_symbol_type): Define.
	* pef.c (bfd_pef_bfd_copy_link_hash_symbol_type): Define.
	* ppcboot.c (ppcboot_bfd_copy_link_hash_symbol_type): Define.
	* som.c (som_bfd_copy_link_hash_symbol_type): Define.
	* srec.c (srec_bfd_copy_link_hash_symbol_type): Define.
	* tekhex.c (tekhex_bfd_copy_link_hash_symbol_type): Define.
	* versados.c (versados_bfd_copy_link_hash_symbol_type): Define.
	* vms.c (vms_bfd_copy_link_hash_symbol_type): Define.
	* xsym.c (bfd_sym_bfd_copy_link_hash_symbol_type): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	ld/testsuite
	* ld-arm/script-type.sym: New test.
	* ld-arm/script-type.s: New test.
	* ld-arm/script-type.s: New test.
@
text
@d899 1
a899 1
  /* Non-relocating reference.  */
d902 2
a903 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
d1165 2
@


1.92
log
@2009-11-19  Tristan Gingold  <gingold@@adacore.com>

	* coff-rs6000.c (rs6000coff_vec): Use generic routines instead of
	hard-coded casts.
	(pmac_xcoff_vec): Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.
@
text
@d4233 1
d4487 1
@


1.91
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@d4174 1
a4174 1
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
d4176 5
a4180 5
    ((bfd_boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
    ((bfd_boolean (*) (bfd *, flagword)) bfd_true),
    ((bfd_boolean (*) (bfd *, void * )) bfd_true),
d4189 2
a4190 2
    bfd_false,
    ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
d4427 1
a4427 1
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
d4429 5
a4433 5
    ((bfd_boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
    ((bfd_boolean (*) (bfd *, flagword)) bfd_true),
    ((bfd_boolean (*) (bfd *, void * )) bfd_true),
d4442 2
a4443 2
    bfd_false,
    ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
@


1.90
log
@bfd/
	* coff-rs6000.c (xcoff_ppc_relocate_section): Allow undefined
	symbols to be left unimported when linking statically.
	* xcofflink.c (xcoff_link_add_symbols): Ignore global linkage
	code when linking statically.

ld/testsuite/
	* ld-powerpc/aix-glink-3.s, ld-powerpc/aix-glink-3a.s,
	ld-powerpc/aix-glink-3b.s, ld-powerpc/aix-glink-3.dd,
	ld-powerpc/aix-glink-3-32.d, ld-powerpc/aix-glink-3-64.d: New tests.
	* ld-powerpc/aix52.exp: Run them.  Move the lineno tests to maintain
	alphabetical order.
@
text
@d498 1
a498 1
_bfd_xcoff_swap_aux_in (abfd, ext1, type, class, indx, numaux, in1)
d502 1
a502 1
     int class;
d510 1
a510 1
  switch (class)
d576 2
a577 1
  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
d618 1
a618 1
_bfd_xcoff_swap_aux_out (abfd, inp, type, class, indx, numaux, extp)
d622 1
a622 1
     int   class;
d631 1
a631 1
  switch (class)
d681 2
a682 1
  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
@


1.90.6.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d498 1
a498 1
_bfd_xcoff_swap_aux_in (abfd, ext1, type, in_class, indx, numaux, in1)
d502 1
a502 1
     int in_class;
d510 1
a510 1
  switch (in_class)
d576 1
a576 2
  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)
      || ISTAG (in_class))
d617 1
a617 1
_bfd_xcoff_swap_aux_out (abfd, inp, type, in_class, indx, numaux, extp)
d621 1
a621 1
     int   in_class;
d630 1
a630 1
  switch (in_class)
d680 1
a680 2
  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)
      || ISTAG (in_class))
@


1.90.6.2
log
@bfd/
	* coff-rs6000.c (xcoff_howto_table): Change size to 0 and bitsize to 1.
	(_bfd_xcoff_reloc_type_lookup): Handle BFD_RELOC_NONE.
	* coff64-rs6000.c (xcoff64_howto_table): Change size to 0 and
	bitsize to 1.
	(xcoff64_reloc_type_lookup): Handle BFD_RELOC_NONE.

gas/
	* write.h (fix_at_start): Declare.
	* write.c (fix_new_internal): Add at_beginning parameter.
	Use it instead of REVERSE_SORT_RELOCS.  Fix the handling of
	seg_fix_tailP for the at_beginning/REVERSE_SORT_RELOCS case.
	(fix_new, fix_new_exp): Update accordingly.
	(fix_at_start): New function.
	* config/tc-ppc.c (md_pseudo_table): Add .ref to the OBJ_XCOFF section.
	(ppc_ref): New function, for OBJ_XCOFF.
	(md_apply_fix): Handle BFD_RELOC_NONE for OBJ_XCOFF.
	* config/te-i386aix.h (REVERSE_SORT_RELOCS): Remove #undef.

gas/testsuite/
	* gas/ppc/xcoff-ref-1.s, gas/ppc/xcoff-ref-1.l: New test.
	* gas/ppc/aix.exp: Run it.


ld/testsuite/
	* ld-powerpc/aix-ref-1-32.od, ld-powerpc/aix-ref-1-64.od,
	ld-powerpc/aix-ref-1.s: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d899 1
a899 1
  /* Non-relocating reference.  Bitsize is 1 so that r_rsize is 0.  */
d902 2
a903 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 1,			/* bitsize */
a1164 2
    case BFD_RELOC_NONE:
      return &xcoff_howto_table[0xf];
@


1.89
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d3463 2
@


1.88
log
@bfd/
	* coff-rs6000.c (member_layout): New structure.
	(archive_iterator): Likewise.
	(member_layout_init): New function.
	(archive_iterator_begin): Likewise.
	(archive_iterator_next): Likewise.
	(xcoff_write_armap_old): Use the new iterator functions.
	(do_shared_object_padding): Delete.
	(xcoff_write_armap_big): Use the new iterator functions.  Simplify
	handling of arch_info.
	(xcoff_write_archive_contents_old): Allocate arelt_data in the
	first loop rather than the second.  Allocate a member header if
	there isn't one, then work out the stat information and length
	in the first loop too.  Use the new iterators for the second loop.
	(xcoff_write_archive_contents_big): Likewise.
@
text
@d4236 1
d4489 1
@


1.87
log
@include/coff/
	* internal.h (C_AIX_WEAKEXT): New macro.
	(C_WEAKEXT): Use the GNU definition in the generic part of the file,
	and conditionally reset it to C_AIX_WEAKEXT in the XCOFF part of
	the file.
	(CSECT_SYM_P): New macro.
	* xcoff.h (L_WEAK): Define.
	(EXTERN_SYM_P): New macro.

bfd/
	* coffcode.h (coff_pointerize_aux_hook): Update CSECT_SYM_P to
	check whether a symbol has csect information.
	(coff_print_aux): Likewise.
	* coff-rs6000.c (_bfd_xcoff_swap_aux_in): Handle auxillary csect
	information for C_AIX_WEAKEXT too.
	(_bfd_xcoff_swap_aux_out): Likewise.
	(xcoff_reloc_type_br): Handle defweak symbols too.
	* coff64-rs6000.c (_bfd_xcoff64_swap_aux_in): Handle auxillary csect
	information for C_AIX_WEAKEXT too.
	(_bfd_xcoff64_swap_aux_out): Likewise.
	(xcoff64_reloc_type_br): Handle defweak symbols too.
	* coffgen.c (coff_print_symbol): Handle auxillary function
	information for C_AIX_WEAKEXT too.
	* xcofflink.c (_bfd_xcoff_canonicalize_dynamic_symtab): Set BSF_WEAK
	instead of BSF_GLOBAL if the L_WEAK flag is set.
	(xcoff_dynamic_definition_p): New function.
	(xcoff_link_add_dynamic_symbols): Use it to decide whether ldsym
	defines h.  Don't change h if ldsym isn't the definition.  Otherwise,
	always take the symbol class from the ldsym.  Use weak bfd symbol
	types for weak ldsyms.
	(xcoff_link_add_symbols): Use CSECT_SYM_P and EXTERN_SYM_P.
	Fix the check for whether a definition is from a shared object.
	Allow redefinitions of weak symbols.
	(xcoff_link_check_ar_symbols): Use EXTERN_SYM_P.
	(xcoff_keep_symbol_p): Likewise.
	(bfd_xcoff_size_dynamic_sections): Use CSECT_SYM_P.
	(xcoff_link_input_bfd): Use CSECT_SYM_P and EXTERN_SYM_P.
	Add .loader entries for C_AIX_WEAKEXT as well as C_EXT symbols,
	but mark them as L_WEAK.
	(xcoff_write_global_symbol): Treat weak symbols as C_AIX_WEAKEXT
	instead of C_EXT if C_AIX_WEAKEXT == C_WEAKEXT.

gas/
	* config/tc-ppc.c (ppc_frob_symbol): Add csect information for
	C_AIX_WEAKEXT too.

ld/testsuite/
	* ld-powerpc/aix-glink-2a.s, ld-powerpc/aix-glink-2a.ex,
	ld-powerpc/aix-glink-2b.s, ld-powerpc/aix-glink-2c.s,
	ld-powerpc/aix-glink-2c.ex, ld-powerpc/aix-glink-2d.s,
	ld-powerpc/aix-glink-2-32.dd, ld-powerpc/aix-glink-2-64.dd,
	ld-powerpc/aix-weak-1a.s, ld-powerpc/aix-weak-1b.s,
	ld-powerpc/aix-weak-1-rel.hd, ld-powerpc/aix-weak-1-rel.nd,
	ld-powerpc/aix-weak-1-dso.hd, ld-powerpc/aix-weak-1-dso.nd,
	ld-powerpc/aix-weak-1-dso.dnd, ld-powerpc/aix-weak-1.ex,
	ld-powerpc/aix-weak-2a.s, ld-powerpc/aix-weak-2a.ex,
	ld-powerpc/aix-weak-2a.nd, ld-powerpc/aix-weak-2b.s,
	ld-powerpc/aix-weak-2b.nd, ld-powerpc/aix-weak-2c.s,
	ld-powerpc/aix-weak-2c.ex, ld-powerpc/aix-weak-2c.nd,
	ld-powerpc/aix-weak-2c.od, ld-powerpc/aix-weak-3a.s,
	ld-powerpc/aix-weak-3a.ex, ld-powerpc/aix-weak-3b.s,
	ld-powerpc/aix-weak-3b.ex, ld-powerpc/aix-weak-3-32.d,
	ld-powerpc/aix-weak-3-32.dd, ld-powerpc/aix-weak-3-64.d,
	ld-powerpc/aix-weak-3-64.dd: New tests.
	* ld-powerpc/aix52.exp: Run them.  Replace tmp/aix-* with
	tmp/aix64-* in 64-bit ld options.
@
text
@a182 2
static bfd_boolean do_shared_object_padding
  PARAMS ((bfd *, bfd *, file_ptr *, int));
d239 113
d1717 1
a1720 2
  bfd *sub;
  file_ptr fileoff;
a1747 2
  sub = abfd->archive_head;
  fileoff = SIZEOF_AR_FILE_HDR;
d1749 9
a1757 20
  while (sub != NULL && i < orl_count)
    {
      size_t namlen;

      while (map[i].u.abfd == sub)
	{
	  H_PUT_32 (abfd, fileoff, buf);
	  if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
	    return FALSE;
	  ++i;
	}
      namlen = strlen (normalize_filename (sub));
      namlen = (namlen + 1) &~ (size_t) 1;
      fileoff += (SIZEOF_AR_HDR
		  + namlen
		  + SXCOFFARFMAG
		  + arelt_size (sub));
      fileoff = (fileoff + 1) &~ 1;
      sub = sub->archive_next;
    }
a1858 28
do_shared_object_padding (out_bfd, in_bfd, offset, ar_header_size)
     bfd *out_bfd;
     bfd *in_bfd;
     file_ptr *offset;
     int ar_header_size;
{
  if (bfd_check_format (in_bfd, bfd_object)
      && bfd_get_flavour (in_bfd) == bfd_target_xcoff_flavour
      && (in_bfd->flags & DYNAMIC) != 0)
    {
      bfd_size_type pad = 0;
      int text_align_power;

      text_align_power = bfd_xcoff_text_align_power (in_bfd);

      pad = 1 << text_align_power;
      pad -= (*offset + ar_header_size) & (pad - 1);

      if (! do_pad (out_bfd, pad))
	return FALSE;

      *offset += pad;
    }

  return TRUE;
}

static bfd_boolean
d1866 1
d1869 1
a1869 1
  const bfd_arch_info_type *arch_info = NULL;
d1878 4
a1881 5
  current_bfd = abfd->archive_head;
  if (current_bfd != NULL)
    arch_info = bfd_get_arch_info (current_bfd);
    i = 0;
    while (current_bfd != NULL && i < orl_count)
d1883 1
a1886 1

a1898 3
      current_bfd = current_bfd->archive_next;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
a1939 1
      file_ptr fileoff;
a1975 4
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
      fileoff = SIZEOF_AR_FILE_HDR_BIG;
d1977 2
a1978 1
      while (current_bfd != NULL && i < orl_count)
d1980 2
a1981 1
	  while (map[i].u.abfd == current_bfd)
d1985 1
a1985 1
		  bfd_h_put_64 (abfd, fileoff, st);
a1989 10
	  string_length = strlen (normalize_filename (current_bfd));
	  string_length += string_length & 1;
	  fileoff += (SIZEOF_AR_HDR_BIG
		      + string_length
		      + SXCOFFARFMAG
		      + arelt_size (current_bfd));
	  fileoff += fileoff & 1;
	  current_bfd = current_bfd->archive_next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
a1992 3
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
d1994 3
a1996 1
      while (current_bfd != NULL && i < orl_count)
d1998 1
a2007 3
	  current_bfd = current_bfd->archive_next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
a2024 1
      file_ptr fileoff;
a2055 4
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
      fileoff = SIZEOF_AR_FILE_HDR_BIG;
d2057 2
a2058 1
      while (current_bfd != NULL && i < orl_count)
d2060 2
a2061 1
	  while (map[i].u.abfd == current_bfd)
d2065 1
a2065 1
		  bfd_h_put_64 (abfd, fileoff, st);
a2069 10
	  string_length = strlen (normalize_filename (current_bfd));
	  string_length += string_length & 1;
	  fileoff += (SIZEOF_AR_HDR_BIG
		      + string_length
		      + SXCOFFARFMAG
		      + arelt_size (current_bfd));
	  fileoff += fileoff & 1;
	  current_bfd = current_bfd->archive_next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
a2072 3
      current_bfd = abfd->archive_head;
      if (current_bfd != NULL)
	arch_info = bfd_get_arch_info (current_bfd);
d2074 3
a2076 1
      while (current_bfd != NULL && i < orl_count)
d2078 1
a2087 3
	  current_bfd = current_bfd->archive_next;
	  if (current_bfd != NULL)
	    arch_info = bfd_get_arch_info (current_bfd);
d2123 1
d2149 1
a2149 22
    }
  offsets = (file_ptr *) bfd_alloc (abfd, count * sizeof (file_ptr));
  if (offsets == NULL)
    return FALSE;

  if (bfd_seek (abfd, (file_ptr) SIZEOF_AR_FILE_HDR, SEEK_SET) != 0)
    return FALSE;

  makemap = bfd_has_map (abfd);
  hasobjects = FALSE;
  prevoff = 0;
  nextoff = SIZEOF_AR_FILE_HDR;
  for (sub = abfd->archive_head, i = 0;
       sub != NULL;
       sub = sub->archive_next, i++)
    {
      const char *name;
      bfd_size_type namlen;
      struct xcoff_ar_hdr *ahdrp;
      bfd_size_type remaining;

      if (makemap && ! hasobjects)
d2151 3
a2153 2
	  if (bfd_check_format (sub, bfd_object))
	    hasobjects = TRUE;
d2155 1
a2155 10

      name = normalize_filename (sub);
      namlen = strlen (name);

      if (sub->arelt_data != NULL)
	ahdrp = arch_xhdr (sub);
      else
	ahdrp = NULL;

      if (ahdrp == NULL)
d2157 1
a2159 2
	  memset (&ahdr, 0, sizeof ahdr);
	  ahdrp = &ahdr;
d2166 4
d2176 1
a2176 8
	  if (sub->arelt_data == NULL)
	    {
	      size = sizeof (struct areltdata);
	      sub->arelt_data = bfd_alloc (sub, size);
	      if (sub->arelt_data == NULL)
		return FALSE;
	    }

d2179 4
d2184 2
a2185 2
      sprintf (ahdrp->prevoff, "%ld", (long) prevoff);
      sprintf (ahdrp->namlen, "%ld", (long) namlen);
d2187 9
a2195 9
      /* If the length of the name is odd, we write out the null byte
	 after the name as well.  */
      namlen = (namlen + 1) &~ (bfd_size_type) 1;

      remaining = arelt_size (sub);
      size = (SIZEOF_AR_HDR
	      + namlen
	      + SXCOFFARFMAG
	      + remaining);
d2197 5
a2201 1
      BFD_ASSERT (nextoff == bfd_tell (abfd));
d2203 4
a2206 6
      offsets[i] = nextoff;

      prevoff = nextoff;
      nextoff += size + (size & 1);

      sprintf (ahdrp->nextoff, "%ld", (long) nextoff);
d2213 1
a2213 5
      if ((bfd_bwrite ((PTR) ahdrp, (bfd_size_type) SIZEOF_AR_HDR, abfd)
	   != SIZEOF_AR_HDR)
	  || bfd_bwrite ((PTR) name, namlen, abfd) != namlen
	  || bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG,
			 abfd) != SXCOFFARFMAG)
d2216 8
a2223 1
      if (bfd_seek (sub, (file_ptr) 0, SEEK_SET) != 0)
d2226 2
a2227 5
      if (! do_copy (abfd, sub))
	return FALSE;

      if (! do_pad (abfd, size & 1))
	return FALSE;
d2234 1
d2339 1
a2339 1
  struct xcoff_ar_hdr_big *hdr, ahdr;
d2343 1
a2363 1
    }
d2365 7
a2371 26
  offsets = NULL;
  if (count)
    {
      offsets = (file_ptr *) bfd_malloc (count * sizeof (file_ptr));
      if (offsets == NULL)
	return FALSE;
    }

  prevoff = 0;
  nextoff = SIZEOF_AR_FILE_HDR_BIG;
  for (current_bfd = abfd->archive_head, i = 0;
       current_bfd != NULL;
       current_bfd = current_bfd->archive_next, i++)
    {
      const char *name;
      bfd_size_type namlen;
      struct xcoff_ar_hdr_big *ahdrp;
      bfd_size_type remaining;

      name = normalize_filename (current_bfd);
      namlen = strlen (name);

      if (current_bfd->arelt_data != NULL)
	ahdrp = arch_xhdr_big (current_bfd);
      else
	ahdrp = NULL;
d2373 1
a2373 1
      if (ahdrp == NULL)
d2375 1
a2377 1
	  ahdrp = &ahdr;
d2387 4
d2397 1
a2397 8
	  if (current_bfd->arelt_data == NULL)
	    {
	      size = sizeof (struct areltdata);
	      current_bfd->arelt_data = bfd_alloc (current_bfd, size);
	      if (current_bfd->arelt_data == NULL)
		return FALSE;
	    }

d2400 1
d2402 5
a2406 21
      PRINT20 (ahdrp->prevoff, prevoff);
      PRINT4 (ahdrp->namlen, namlen);

      /* If the length of the name is odd, we write out the null byte
	 after the name as well.  */
      namlen = (namlen + 1) &~ (bfd_size_type) 1;

      remaining = arelt_size (current_bfd);
      size = (SIZEOF_AR_HDR_BIG
	      + namlen
	      + SXCOFFARFMAG
	      + remaining);

      BFD_ASSERT (nextoff == bfd_tell (abfd));

      /* Check for xcoff shared objects.
	 Their text section needs to be aligned wrt the archive file position.
	 This requires extra padding before the archive header.  */
      if (! do_shared_object_padding (abfd, current_bfd, & nextoff,
				      SIZEOF_AR_HDR_BIG + namlen
				      + SXCOFFARFMAG))
d2408 1
d2410 7
a2416 1
      offsets[i] = nextoff;
d2418 4
a2421 4
      prevoff = nextoff;
      nextoff += size + (size & 1);

      PRINT20 (ahdrp->nextoff, nextoff);
d2423 1
a2423 5
      if ((bfd_bwrite ((PTR) ahdrp, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
	   != SIZEOF_AR_HDR_BIG)
	  || bfd_bwrite ((PTR) name, (bfd_size_type) namlen, abfd) != namlen
	  || (bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG,
			  abfd) != SXCOFFARFMAG))
d2426 8
a2433 1
      if (bfd_seek (current_bfd, (file_ptr) 0, SEEK_SET) != 0)
d2436 2
a2437 5
      if (! do_copy (abfd, current_bfd))
	return FALSE;

      if (! do_pad (abfd, size & 1))
	return FALSE;
d2467 1
@


1.86
log
@include/coff/
	* xcoff.h (XCOFF_CALLED, XCOFF_IMPORT): Update comments.
	(XCOFF_WAS_UNDEFINED): New flag.
	(xcoff_link_hash_table): Add an "rtld" field.

bfd/
	* coff-rs6000.c (xcoff_ppc_relocate_section): Report relocations
	against undefined symbols if the symbol's XCOFF_WAS_UNDEFINED
	flag is set.  Assert that all undefined symbols are either
	imported or defined by a dynamic object.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* xcofflink.c (xcoff_link_add_symbols): Extend function-symbol
	handling to all relocations.  Only set XCOFF_CALLED for function
	symbols.
	(xcoff_find_function): New function, split out from...
	(bfd_xcoff_export_symbol) ...here.
	(xcoff_set_import_path): New function, split out from...
	(bfd_xcoff_import_symbol): ...here.  Remove assertion for old
	meaning of XCOFF_CALLED.
	(xcoff_mark_symbol): If we mark an undefined and unimported
	symbol, find some way of defining it.  If the symbol is a function
	descriptor, fill in its definition automatically.  If the symbol
	is a function, mark its descriptor and allocate room for global
	linkage code.  Otherwise mark the symbol as implicitly imported.
	Move the code for creating function descriptors from...
	(xcoff_build_ldsyms): ...here.  Use XCOFF_WAS_UNDEFINED to
	check for symbols that were implicitly defined.
	(xcoff_mark): Don't count any dynamic relocations against
	function symbols.
	(bfd_xcoff_size_dynamic_sections): Save the rtld parameter
	in the xcoff link info.
	(xcoff_link_input_bfd): Remove handling of undefined and
	unexported symbols.

ld/
	* emultempl/aix.em (gld${EMULATION_NAME}_handle_option): Make
	-berok and -bernotok control link_info.unresolved_syms_in_objects
	and link_info.unresolved_syms_in_shared_libs instead of
	force_make_executable.

ld/testsuite/
	* ld-powerpc/aix-glink-1.ex, ld-powerpc/aix-glink-1.s,
	ld-powerpc/aix-glink-1-32.dd, ld-powerpc/aix-glink-1-64.dd,
	ld-powerpc/aix-glink-1-32.d, ld-powerpc/aix-glink-1-64.d: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d425 1
d535 1
d2968 2
a2969 1
      && bfd_link_hash_defined == h->root.type
d3014 2
a3015 1
      && h->root.type == bfd_link_hash_defined
@


1.85
log
@bfd/
	* coff-rs6000.c (xcoff_reloc_type_br): Make the branch absolute
	if the target is absolute.  Fix comment typo.
	(xcoff_ppc_relocate_section): Remove FIXME.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Make the branch absolute
	if the target is absolute.

ld/testsuite/
	* ld-powerpc/aix-abs-branch-1.im, ld-powerpc/aix-abs-branch-1.ex,
	ld-powerpc/aix-abs-branch-1.s,
	ld-powerpc/aix-abs-branch-1.dd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d3450 11
d3476 1
a3476 2
	      else if ((0 == (h->flags & (XCOFF_DEF_DYNAMIC | XCOFF_IMPORT)))
		       && ! info->relocatable)
d3478 3
a3480 8
		  if (! ((*info->callbacks->undefined_symbol)
			 (info, h->root.root.string, input_bfd, input_section,
			  rel->r_vaddr - input_section->vma, TRUE)))
		    return FALSE;

		  /* Don't try to process the reloc.  It can't help, and
		     it may generate another error.  */
		  continue;
@


1.84
log
@bfd/ChangeLog

	* coff-alpha.c (alpha_ecoff_backend_data):  Initialise fields which
	control long section name handling with ECOFF_NO_LONG_SECTION_NAMES.
	* coff-mips.c (mips_ecoff_backend_data):  Likewise.
	* coff-rs6000.c (bfd_xcoff_backend_data):  Initialise fields which
	control long section name handling with XCOFF_NO_LONG_SECTION_NAMES.
	(bfd_pmac_xcoff_backend_data):  Likewise.
	* coff64-rs6000.c (bfd_xcoff_backend_data):  Likewise.
	(bfd_xcoff_aix5_backend_data):  Likewise.
	(xcoff64_write_object_contents):  Delete unused long_section_names
	local variable.
	* coff-sh.c (bfd_coff_small_swap_table):  Initialise long section
	name members using COFF_DEFAULT_LONG_SECTION_NAMES and make entire
	struct non-const.
	* coffcode.h (documentation):  Update to describe long section names.
	(COFFLONGSECTIONCATHELPER):  New helper macro.
	(BLANKOR1TOODD):  Likewise.
	(COFF_ENABLE_LONG_SECTION_NAMES):  Likewise.
	(COFF_LONG_SECTION_NAMES_SETTER):  Likewise.
	(COFF_DEFAULT_LONG_SECTION_NAMES):  Likewise.
	(bfd_coff_set_long_section_names_allowed):  New function.
	(bfd_coff_set_long_section_names_disallowed):  Likewise.
	(struct bfd_coff_backend_data):  Add new backend hook function
	pointer _bfd_coff_set_long_section_names.
	(bfd_coff_set_long_section_names):  New backend hook.
	(coff_write_object_contents):  Only generate long section names if
	bfd_coff_long_section_names() indicates they are currently enabled.
	(bfd_coff_std_swap_table):  Make non-const, and initialise long
	section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff0_swap_table):  Likewise to both.
	(ticoff1_swap_table):  Again, likewise to both.
	* coffgen.c (make_a_section_from_file):  Allow long section names
	as inputs even if not currently allowed for outputs.
	* ecoff.c (_bfd_ecoff_no_long_sections):  New function.
	* efi-app-ia32.c (COFF_LONG_SECTION_NAMES):  Define to 0, not blank.
	* efi-app-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-app-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-arm.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-i386.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mcore.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mips.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-ppc.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-sh.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* libcoff-in.h:  Update copyright year to cause updated copyright
	year in generated libcoff.h, and fix typo.
	* libcoff.h:  Regenerated.
	* libecoff.h (ECOFF_NO_LONG_SECTION_NAMES):  New macro.
	(_bfd_ecoff_no_long_sections):  Add prototype.
	* libxcoff.h (XCOFF_NO_LONG_SECTION_NAMES):  New macro.
	* pe-mips.c (COFF_LONG_SECTION_NAMES):  Define empty if not already
	defined by an including .c file.
	* ticoff.h (ticoff0_swap_table):  Make non-const, and initialise
	long section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff1_swap_table):  Likewise to both.

ld/ChangeLog

	* ld.texinfo:  Update to mention long section name options.
	* NEWS:  Mention new behaviour and command-line options.
	* pe-dll.c (pe_use_coff_long_section_names):  New global variable.
	(pe_output_file_set_long_section_names):  New function.
	(pe_dll_build_sections):  Call it on output BFDs.
	(pe_exe_build_sections):  Likewise.
	(pe_dll_fill_sections):  Likewise.
	(pe_exe_fill_sections):  Likewise.
	* pe-dll.h (pe_use_coff_long_section_names):  Declare extern.
	(pe_output_file_set_long_section_names):  Add prototype.
	* pep-dll.c (pe_use_coff_long_section_names):  Define pep_ alias.
	(pe_output_file_set_long_section_names):  Likewise.
	* pep-dll.h (pep_use_coff_long_section_names):  Declare extern.
	(pep_output_file_set_long_section_names):  Add prototype.
	* pe.em (OPTION_ENABLE_LONG_SECTION_NAMES):  New getopt value macro.
	(OPTION_DISABLE_LONG_SECTION_NAMES):  Likewise.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pe_output_file_set_long_section_names.
	* pep.em (enum options):  Extend enum with new getopt option values.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pep_output_file_set_long_section_names.

ld/testsuite/ChangeLog

	* ld-pe/longsecn-1.d:  New test file.
	* ld-pe/longsecn-2.d:  Likewise.
	* ld-pe/longsecn-3.d:  Likewise.
	* ld-pe/longsecn-4.d:  Likewise.
	* ld-pe/longsecn-5.d:  Likewise.
	* ld-pe/longsecn.d:  Likewise.
	* ld-pe/longsecn.exp:  New test control script.
	* ld-pe/longsecn.s:  New test source file.
@
text
@d2950 1
d2956 1
d2967 1
a2967 1
      && rel->r_vaddr - input_section->vma + 8 <= input_section->size)
d2972 1
a2972 1
      pnext = contents + (rel->r_vaddr - input_section->vma) + 4;
d2982 1
a2982 1
	    bfd_put_32 (input_bfd, 0x80410014, pnext);	/* lwz r1,20(r1) */
d2987 1
a2987 1
	  if (next == 0x80410014)			/* lwz r1,20(r1) */
d3003 4
a3006 1
  howto->pc_relative = TRUE;
d3010 7
a3016 2
  /* A PC relative reloc includes the section address.  */
  addend += input_section->vma;
d3018 20
a3037 3
  *relocation = val + addend;
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
d3353 1
a3353 3
   absolute branch.  FIXME: We don't implement this,
   although we should for symbols of storage mapping class
   XMC_XO.
@


1.83
log
@        * pe-arm-wince.c (pe_print_compressed_pdata): Define new function to
        print compressed pdata structure as described on MSDN. This only
        applies to a limited set of architectures (ARM, SH4).
        (slurp_symtab, my_symbol_for_address): Define static helper
        functions for pe_print_compressed_pdata.
        * coffcode.h (bfd_coff_backend_data): Add _bfd_coff_print_pdata field.
        (bfd_coff_have_print_pdata, bfd_coff_print_pdata): Define.
        * bfd/peXXigen.c (_bfd_XX_print_private_bfd_data_common): Add check on
        bfd_coff_backend_data, call the function if non-null.
        * pei-mcore.c: Add target dependent initialisation for
        bfd_coff_backend_data.
        * coff-sh.c: Likewise.
        * coff64-rs6000.c: Likewise.
        * coff-rs6000.c: Likewise.
        * libcoff-in.h: Likewise.
        * cf-i386lynx.c: Likewise.
        * coff-alpha.c: Likewise.
        * coff-apollo.c: Likewise.
        * coff-arm.c: Likewise.
        * coff-aux.c: Likewise.
        * coff-h8300.c: Likewise.
        * coff-h8500.c: Likewise.
        * coff-i386.c: Likewise.
        * coff-i860.c: Likewise.
        * coff-i960.c: Likewise.
        * coff-ia64.c: Likewise.
        * coff-m68k.c: Likewise.
        * coff-m88k.c: Likewise.
        * coff-maxq.c: Likewise.
        * coff-mips.c: Likewise.
        * coff-or32.c: Likewise.
        * coff-sparc.c: Likewise.
        * coff-tic30.c: Likewise.
        * coff-tic4x.c: Likewise.
        * coff-tic54x.c: Likewise.
        * coff-tic80.c: Likewise.
        * coff-w65.c: Likewise.
        * coff-we32k.c: Likewise.
        * coff-x86_64.c: Likewise.
        * coff-z80.c: Likewise.
        * coff-z8k.c: Likewise.
        * pe-mcore.c: Likewise.
        * pe-mips.c: Likewise.
        * pe-ppc.c: Likewise.
        * peXXigen.c: Likewise.
        * pei-ppc.c: Likewise.
        * libcoff.h: Regenerate.
@
text
@d3 1
a3 1
   2008  Free Software Foundation, Inc.
d4014 1
a4014 1
      FALSE,			/* _bfd_coff_long_section_names */
d4266 1
a4266 1
      FALSE,			/* _bfd_coff_long_section_names */
@


1.82
log
@Switch sources over to use the GPL version 3
@
text
@d2 2
a3 2
   Copyright 1990-1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
   Free Software Foundation, Inc.
d131 4
d4041 2
a4042 1
      coff_final_link_postscript
d4293 2
a4294 1
      coff_final_link_postscript
@


1.81
log
@bfd/
	* bfd.c (struct bfd): Rename "next" to "archive_next".
	* archive.c: Rename uses throughout file.
	* archive64.c: Likewise.
	* coff-rs6000.c: Likewise.
	* ecoff.c: Likewise.
	* som.c: Likewise.
	* bfd-in2.h: Regenerate.
binutils/
	* ar.c: Rename uses of bfd.next to bfd.archive_next throughout.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* objcopy.c: Likewise.
	* dlltool.c: Likewise.
ld/
	* pe-dll.c: Rename uses of bfd.next to bfd.archive_next throughout.
@
text
@d8 1
a8 1
This file is part of BFD, the Binary File Descriptor library.
d10 14
a23 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.80
log
@Write Mimi's name in ASCII.
@
text
@d1652 1
a1652 1
      sub = sub->next;
d1823 1
a1823 1
      current_bfd = current_bfd->next;
d1927 1
a1927 1
	  current_bfd = current_bfd->next;
d1948 1
a1948 1
	  current_bfd = current_bfd->next;
d2023 1
a2023 1
	  current_bfd = current_bfd->next;
d2044 1
a2044 1
	  current_bfd = current_bfd->next;
d2103 1
a2103 1
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
d2119 3
a2121 1
  for (sub = abfd->archive_head, i = 0; sub != NULL; sub = sub->next, i++)
d2269 1
a2269 1
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
d2339 1
a2339 1
       current_bfd = current_bfd->next, count++)
d2361 1
a2361 1
       current_bfd = current_bfd->next, i++)
d2528 3
a2530 2
  for (current_bfd = abfd->archive_head; current_bfd != NULL;
       current_bfd = current_bfd->next)
@


1.79
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d4 1
a4 6
   FIXME: Can someone provide a transliteration of this name into ASCII?
   Using the following chars caused a compiler warning on HIUX (so I replaced
   them with octal escapes), and isn't useful without an understanding of what
   character set it is.
   Written by Metin G. Ozisik, Mimi Ph\373\364ng-Th\345o V\365,
     and John Gilmore.
@


1.78
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d29 1
a30 1
#include "sysdep.h"
@


1.77
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d101 1
d1055 15
d4197 1
d4448 1
@


1.76
log
@	* coff-rs6000.c (xcoff_write_archive_contents_old): Warning fix.
@
text
@d62 1
a62 1
  PARAMS ((bfd *, bfd_boolean));
d2576 2
a2577 3
_bfd_xcoff_sizeof_headers (abfd, reloc)
     bfd *abfd;
     bfd_boolean reloc ATTRIBUTE_UNUSED;
@


1.75
log
@bfd/
	* elf-bfd.h (_bfd_generic_match_sections_by_type): Don't define.
	* libbfd-in.h (_bfd_generic_match_sections_by_type): Delete.
	* libbfd.c (_bfd_generic_match_sections_by_type): Delete.
	* targets.c (bfd_match_sections_by_type): Don't define.
	(BFD_JUMP_TABLE_LINK): Remove _bfd_generic_match_sections_by_type.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
ld/
	* ldlang.c (lang_output_section_find_by_flags): Add match_type param.
	Run two passes, first using match_type, second without.
	* ldlang.h (lang_match_sec_type_func): New typedef.
	(lang_output_section_find_by_flags): Update prototype.
	bfd_match_sections_by_type and lang_output_section_find_by_flags.
	* emultempl/pe.em (place_orphan): Likewise.
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002, 2003, 2004, 2005
d2086 1
a2086 1
  strncpy (fhdr.magic, XCOFFARMAG, SXCOFFARMAG);
@


1.75.6.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d2086 1
a2086 1
  (void) strncpy (fhdr.magic, XCOFFARMAG, SXCOFFARMAG);
@


1.75.12.1
log
@	* coff-rs6000.c (xcoff_write_archive_contents_old): Warning fix.
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d2086 1
a2086 1
  (void) strncpy (fhdr.magic, XCOFFARMAG, SXCOFFARMAG);
@


1.74
log
@2005-10-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* coff-rs6000.c (rs6000coff_vec): Initialize
	_bfd_init_private_section_data with
	_bfd_generic_init_private_section_data.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
@
text
@a4198 1
    _bfd_generic_match_sections_by_type,
a4448 1
    _bfd_generic_match_sections_by_type,
@


1.73
log
@2005-10-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* coff-rs6000.c (rs6000coff_vec): Initialize
	_bfd_match_sections_by_type with
	_bfd_generic_match_sections_by_type.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
@
text
@d4138 1
d4389 1
@


1.72
log
@	* libbfd-in.h (struct artdata): Add extended_names_size field.
	* libbfd.h: Rebuilt.
	* coff-rs600.c (_bfd_xcoff_archive_p): Don't clear fields in freshly
	allocated object by bfd_zalloc.
	* coff64-rs6000.c (xcoff64_archive_p): Likewise.
	* ecoff.c (_bfd_ecoff_archive_p): Likewise.
	* archive.c (_bfd_generic_mkarchive, bfd_generic_archive_p): Likewise.
	(get_extended_arelt_filename): Fail if index is bigger or equal to
	extended_names_size.
	(_bfd_generic_read_ar_hdr_mag): Don't set bfd_error_malformed_archive,
	get_extended_arelt_filename already did that.
	(_bfd_slurp_extended_name_table): Initialize extended_names_size field.
	Allocate one extra byte and clear it, in case extended names table
	is not terminated.
@
text
@d4198 1
d4448 1
@


1.71
log
@	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Init _bfd_find_line.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
@
text
@d1297 6
a1302 4
  bfd_ardata (abfd)->cache = NULL;
  bfd_ardata (abfd)->archive_head = NULL;
  bfd_ardata (abfd)->symdefs = NULL;
  bfd_ardata (abfd)->extended_names = NULL;
@


1.70
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@d4169 1
d4418 1
@


1.69
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d4169 1
d4417 1
@


1.68
log
@Update the FSF address in the copyright/GPL notice
@
text
@d27 1
a27 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.67
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d27 1
a27 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.66
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002, 2003, 2004
d1852 2
a1853 2
      bfd_byte *symbol_table;
      bfd_byte *st;
d1863 1
a1863 2
      symbol_table = NULL;
      symbol_table = (bfd_byte *) bfd_zmalloc (symbol_table_size);
a1942 1
      symbol_table = NULL;
d1953 2
a1954 2
      bfd_byte *symbol_table;
      bfd_byte *st;
d1964 1
a1964 2
      symbol_table = NULL;
      symbol_table = (bfd_byte *) bfd_zmalloc (symbol_table_size);
a2038 1
      symbol_table = NULL;
d2310 1
a2310 1
  bfd_byte *member_table, *mt;
d2475 1
a2475 2
  member_table = NULL;
  member_table = (bfd_byte *) bfd_zmalloc (member_table_size);
a2527 1
  member_table = NULL;
d3527 1
a3527 1
	  bfd_byte *newstrings;
d3535 1
a3535 2
	  newstrings = ((bfd_byte *)
			bfd_realloc ((PTR) ldinfo->strings, newalc));
@


1.65
log
@	* coff-rs6000.c (rs6000coff_vec): Add initializer for
	bfd_is_target_special_symbol.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	* som.c (som_bfd_is_target_special_symbol): Define.
@
text
@d3484 1
a3484 1
	      name = h->root.root.string;
d3495 3
a3497 2
		 (info, name, reloc_type_name, (bfd_vma) 0, input_bfd,
		  input_section, rel->r_vaddr - input_section->vma)))
@


1.64
log
@	* pdp11.c (struct pdp11_aout_reloc_external): Delete.  Replace
	occurrences with bfd_btye * thoughout file.

	* coff-rs6000.c (do_shared_object_padding): Warning fix.
	(xcoff_write_armap_big): Likewise.
	(xcoff_write_archive_contents_old): Likewise.
	(xcoff_write_archive_contents_big): Likewise.

	* elf64-mmix.c (mmix_elf_get_section_contents): Delete declaration.
@
text
@d4172 1
d4419 1
@


1.63
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d183 1
a183 1
  PARAMS ((bfd *, bfd *, ufile_ptr *, int));
d1745 1
a1745 1
     ufile_ptr *offset;
d1782 1
a1782 1
  ufile_ptr nextoff, prevoff;
d2079 1
a2079 1
  ufile_ptr prevoff, nextoff;
d2309 1
a2309 1
  ufile_ptr prevoff, nextoff;
@


1.62
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d3614 2
a3615 2
	(_("%s: symbol `%s' has unrecognized smclas %d"),
	 bfd_archive_filename (abfd), symbol_name, aux->x_csect.x_smclas);
@


1.61
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d4201 1
d4447 1
@


1.60
log
@binutils ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* objcopy.c (setup_bfd_headers): New function.
	(copy_object): Call setup_bfd_headers.
bfd ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* aout-target.h (MY_bfd_copy_private_header_data): Define.
	* aout-tic30.c (MY_bfd_copy_private_header_data): Define.
	* bfd.c (bfd_copy_private_header_data): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add entries for new
	interface.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_copy_private_header_data): Define.
	* elf-bfd.h (_bfd_elf_copy_private_header_data): Declare.
	* elf.c (_bfd_elf_copy_private_section_data): Remove code to set up
	segments by calling copy_private_bfd_data.
	(_bfd_elf_copy_private_header_data): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_private_header_data): Define.
	* libbfd-in.h (_bfd_generic_bfd_copy_private_header_data): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_private_header_data): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_private_header_data): Define.
	* mmo.c (mmo_bfd_copy_private_header_data): Define.
	* ppcboot.c (ppcboot_bfd_copy_private_header_data): Define.
	* som.c (som_bfd_copy_private_header_data): Define.
	* targets.c (BFD_JUMP_TABLE_COPY): Add _bfd_copy_private_header_data.
	* vms.c (vms_bfd_copy_private_header_data): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d2951 1
a2951 2
      && (rel->r_vaddr - input_section->vma + 8
	  <= input_section->_cooked_size))
d3451 1
a3451 1
      if (address > input_section->_raw_size)
@


1.59
log
@	* section.c (bfd_make_section_anyway): Add all sections to hash tab.

	* elf-bfd.h (bfd_elf_is_group_section): Declare.
	* elf.c (bfd_elf_is_group_section): New function.
	* elfxx-target.h (bfd_elfNN_bfd_is_group_section
	* section.c (bfd_generic_is_group_section): New function.
	* targets.c (struct bfd_target): Add _bfd_is_group_section field.
	(BFD_JUMP_TABLE_LINK): Adjust.
	* aout-adobe.c (aout_32_bfd_is_group_section): Define.
	* aout-target.h (MY_bfd_is_group_section): Define.
	* aout-tic30.c (MY_bfd_is_group_section): Define.
	* bfd.c (bfd_is_group_section): Define.
	* binary.c (binary_bfd_is_group_section): Define.
	* bout.c (b_out_bfd_is_group_section): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-mips.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Adjust.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Adjust.
	* coffcode.h (coff_bfd_is_group_section): Define.
	* i386msdos.c (msdos_bfd_is_group_section): Define.
	* i386os9k.c (os9k_bfd_is_group_section): Define.
	* ieee.c (ieee_bfd_is_group_section): Define.
	* ihex.c (ihex_bfd_is_group_section): Define.
	* libbfd-in.h (_bfd_nolink_bfd_is_group_section): Define.
	* mach-o.c (bfd_mach_o_bfd_is_group_section): Define.
	* mmo.c (mmo_bfd_is_group_section): Define.
	* nlm-target.h (nlm_bfd_is_group_section): Define.
	* oasys.c (oasys_bfd_is_group_section): Define.
	* pef.c (bfd_pef_bfd_is_group_section): Define.
	* ppcboot.c (ppcboot_bfd_is_group_section): Define.
	* srec.c (srec_bfd_is_group_section): Define.
	* tekhex.c (tekhex_bfd_is_group_section): Define.
	* versados.c (versados_bfd_is_group_section): Define.
	* vms.c (vms_bfd_is_group_section): Define.
	* xsym.c (bfd_sym_bfd_is_group_section): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d4145 1
d4390 1
@


1.58
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Define.
	* targets.c (BFD_JUMP_TABLE_DYNAMIC): Add
	NAME##_get_synthetic_symtab.
	(struct bfd_target): Add _bfd_get_synthetic_symtab.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Define.
	* elf-bfd.h (struct elf_backend_data): Add plt_sym_val and
	relplt_name fields.
	(_bfd_elf_get_synthetic_symtab): New prototype.
	* elfcode.h (elf_get_synthetic_symtab): Define.
	* elf.c (_bfd_elf_get_synthetic_symtab): New function.
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Define.
	(elf_backend_plt_sym_val, elf_backend_relplt_name): Define.
	(elfNN_bed): Add elf_backend_plt_sym_val and elf_backend_relplt_name.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-x86-64.c (elf64_x86_64_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-sparc (elf32_sparc_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-ppc.c (ppc_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* aout-target.h (MY_get_synthetic_symtab): Define.
	* aout-tic30.c (MY_get_synthetic_symtab): Define.
	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(aix5coff64_vec): Likewise.
	* sunos.c (MY_get_synthetic_symtab): Define.
	* vms.c (vms_get_synthetic_symtab): Define.
binutils/
	* objdump.c (synthsyms, synthcount): New variables.
	(disassemble_data): Use dynsyms for stripped binaries or libraries.
	Add synthetized symbols.
	(dump_bfd): For disassemble, initialize dynsyms always and
	also synthsyms.  Free synthsyms and clear {sym,dynsym,synth}count
	before returning.
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002, 2003
d4199 1
d4443 1
@


1.57
log
@	* coff-rs6000.c: Remove ARGSUSED and VARARGS.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* elf32-vax.c: Likewise.
	* hash.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* ihex.c: Likewise.
	* netbsd-core.c: Likewise.
	* osf-core.c: Likewise.
	* pdp11.c: Likewise.
	* ptrace-core.c: Likewise.
	* sco5-core.c: Likewise.
	* section.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
@
text
@d4204 1
d4447 1
@


1.57.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002, 2003, 2004
d183 1
a183 1
  PARAMS ((bfd *, bfd *, file_ptr *, int));
d1745 1
a1745 1
     file_ptr *offset;
d1782 1
a1782 1
  file_ptr nextoff, prevoff;
d2079 1
a2079 1
  file_ptr prevoff, nextoff;
d2309 1
a2309 1
  file_ptr prevoff, nextoff;
d2951 2
a2952 1
      && rel->r_vaddr - input_section->vma + 8 <= input_section->size)
d3452 1
a3452 1
      if (address > input_section->size)
d3615 2
a3616 2
	(_("%B: symbol `%s' has unrecognized smclas %d"),
	 abfd, symbol_name, aux->x_csect.x_smclas);
a4144 1
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
a4198 1
    bfd_generic_is_group_section,
a4199 1
    _bfd_generic_section_already_linked,
a4203 1
    _bfd_nodynamic_get_synthetic_symtab,
a4386 1
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
a4440 1
    bfd_generic_is_group_section,
a4441 1
    _bfd_generic_section_already_linked,
a4445 1
    _bfd_nodynamic_get_synthetic_symtab,
@


1.56
log
@	* aix5ppc-core.c: Fix comment typos.
	* aout-arm.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aoutx.h: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd.c: Likewise.
	* bfdio.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-z8k.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* cofflink.c: Likewise.
	* cpu-alpha.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* dwarf2.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@a1577 1
/*ARGSUSED*/
@


1.55
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d1009 1
a1009 1
  /* Special case some 16 bit reoloc */
@


1.54
log
@Correct spelling of "relocatable".
@
text
@d4168 1
a4168 1
    coff_get_symtab,
d4410 1
a4410 1
    coff_get_symtab,
@


1.53
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002
d3429 1
a3429 1
		       && ! info->relocateable)
@


1.52
log
@	* coff-rs6000.c (rs6000coff_vec <object_flags>): Add SEC_CODE and
	SEC_DATA.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
@
text
@d39 6
a44 3
extern boolean _bfd_xcoff_mkobject PARAMS ((bfd *));
extern boolean _bfd_xcoff_copy_private_bfd_data PARAMS ((bfd *, bfd *));
extern boolean _bfd_xcoff_is_local_label_name PARAMS ((bfd *, const char *));
d47 11
a57 6
extern boolean _bfd_xcoff_slurp_armap PARAMS ((bfd *));
extern const bfd_target *_bfd_xcoff_archive_p PARAMS ((bfd *));
extern PTR _bfd_xcoff_read_ar_hdr PARAMS ((bfd *));
extern bfd *_bfd_xcoff_openr_next_archived_file PARAMS ((bfd *, bfd *));
extern int _bfd_xcoff_stat_arch_elt PARAMS ((bfd *, struct stat *));
extern boolean _bfd_xcoff_write_armap
d59 16
a74 8
extern boolean _bfd_xcoff_write_archive_contents PARAMS ((bfd *));
extern int _bfd_xcoff_sizeof_headers PARAMS ((bfd *, boolean));
extern void _bfd_xcoff_swap_sym_in PARAMS ((bfd *, PTR, PTR));
extern unsigned int _bfd_xcoff_swap_sym_out PARAMS ((bfd *, PTR, PTR));
extern void _bfd_xcoff_swap_aux_in PARAMS ((bfd *, PTR, int, int, int, int, PTR));
extern unsigned int _bfd_xcoff_swap_aux_out PARAMS ((bfd *, PTR, int, int, int, int, PTR));
static void xcoff_swap_reloc_in PARAMS ((bfd *, PTR, PTR));
static unsigned int xcoff_swap_reloc_out PARAMS ((bfd *, PTR, PTR));
d77 2
a78 1
void xcoff_rtype2howto PARAMS ((arelent *, struct internal_reloc *));
d102 3
a104 2
extern const bfd_target * rs6000coff_core_p PARAMS ((bfd *abfd));
extern boolean rs6000coff_core_file_matches_executable_p
d106 4
a109 2
extern char *rs6000coff_core_file_failing_command PARAMS ((bfd *abfd));
extern int rs6000coff_core_file_failing_signal PARAMS ((bfd *abfd));
d138 3
a140 2
static const char *normalize_filename PARAMS ((bfd *));
static boolean xcoff_write_armap_old
d142 1
a142 1
static boolean xcoff_write_armap_big
d144 4
a147 2
static boolean xcoff_write_archive_contents_old PARAMS ((bfd *));
static boolean xcoff_write_archive_contents_big PARAMS ((bfd *));
d160 1
a160 1
static boolean xcoff_ppc_relocate_section
d163 1
a163 1
static boolean _bfd_xcoff_put_ldsymbol_name
d168 4
a171 2
static boolean xcoff_is_lineno_count_overflow PARAMS ((bfd *, bfd_vma));
static boolean xcoff_is_reloc_count_overflow PARAMS ((bfd *, bfd_vma));
d176 8
a183 5
static boolean xcoff_generate_rtinit
  PARAMS ((bfd *, const char *, const char *, boolean));
static boolean do_pad PARAMS ((bfd *, unsigned int));
static boolean do_copy PARAMS ((bfd *, bfd *));
static boolean do_shared_object_padding PARAMS ((bfd *, bfd *, ufile_ptr *, int));
d186 2
a187 1
static boolean xcoff_reloc_type_br PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
d189 1
a189 1
static boolean xcoff_complain_overflow_dont_func
d191 1
a191 1
static boolean xcoff_complain_overflow_bitfield_func
d193 1
a193 1
static boolean xcoff_complain_overflow_signed_func
d195 1
a195 1
static boolean xcoff_complain_overflow_unsigned_func
d198 1
a198 1
boolean (*xcoff_calculate_relocation[XCOFF_MAX_CALCULATE_RELOCATION])
d231 1
a231 1
boolean (*xcoff_complain_overflow[XCOFF_MAX_COMPLAIN_OVERFLOW])
d243 1
a243 1
boolean
d252 1
a252 1
    return false;
d271 1
a271 1
  return true;
d276 1
a276 1
boolean
d285 1
a285 1
    return true;
d316 1
a316 1
  return true;
d324 1
a324 1
boolean
d329 1
a329 1
  return false;
d500 2
a501 1
unsigned int _bfd_xcoff_swap_aux_out PARAMS ((bfd *, PTR, int, int, int, int, PTR));
d615 1
a615 1
	 false,			/* pc_relative */
d620 1
a620 1
	 true,			/* partial_inplace */
d623 1
a623 1
	 false),		/* pcrel_offset */
d630 1
a630 1
	 false,			/* pc_relative */
d635 1
a635 1
	 true,			/* partial_inplace */
d638 1
a638 1
	 false),		/* pcrel_offset */
d645 1
a645 1
	 true,			/* pc_relative */
d650 1
a650 1
	 true,			/* partial_inplace */
d653 1
a653 1
	 false),		/* pcrel_offset */
d660 1
a660 1
	 false,			/* pc_relative */
d665 1
a665 1
	 true,			/* partial_inplace */
d668 1
a668 1
	 false),		/* pcrel_offset */
d675 1
a675 1
	 false,			/* pc_relative */
d680 1
a680 1
	 true,			/* partial_inplace */
d683 1
a683 1
	 false),		/* pcrel_offset */
d690 1
a690 1
	 false,			/* pc_relative */
d695 1
a695 1
	 true,			/* partial_inplace */
d698 1
a698 1
	 false),		/* pcrel_offset */
d705 1
a705 1
	 false,			/* pc_relative */
d710 1
a710 1
	 true,			/* partial_inplace */
d713 1
a713 1
	 false),		/* pcrel_offset */
d722 1
a722 1
	 false,			/* pc_relative */
d727 1
a727 1
	 true,			/* partial_inplace */
d730 1
a730 1
	 false),		/* pcrel_offset */
d739 1
a739 1
	 true,			/* pc_relative */
d744 1
a744 1
	 true,			/* partial_inplace */
d747 1
a747 1
	 false),		/* pcrel_offset */
d756 1
a756 1
	 false,			/* pc_relative */
d761 1
a761 1
	 true,			/* partial_inplace */
d764 1
a764 1
	 false),		/* pcrel_offset */
d771 1
a771 1
	 false,			/* pc_relative */
d776 1
a776 1
	 true,			/* partial_inplace */
d779 1
a779 1
	 false),		/* pcrel_offset */
d788 1
a788 1
	 false,			/* pc_relative */
d793 1
a793 1
	 false,			/* partial_inplace */
d796 1
a796 1
	 false),		/* pcrel_offset */
d806 1
a806 1
	 false,			/* pc_relative */
d811 1
a811 1
	 true,			/* partial_inplace */
d814 1
a814 1
	 false),		/* pcrel_offset */
d821 1
a821 1
	 false,			/* pc_relative */
d826 1
a826 1
	 true,			/* partial_inplace */
d829 1
a829 1
	 false),		/* pcrel_offset */
d836 1
a836 1
	 false,			/* pc_relative */
d841 1
a841 1
	 true,			/* partial_inplace */
d844 1
a844 1
	 false),		/* pcrel_offset */
d851 1
a851 1
	 false,			/* pc_relative */
d856 1
a856 1
	 true,			/* partial_inplace */
d859 1
a859 1
	 false),		/* pcrel_offset */
d866 1
a866 1
	 false,			/* pc_relative */
d871 1
a871 1
	 true,			/* partial_inplace */
d874 1
a874 1
	 false),		/* pcrel_offset */
d881 1
a881 1
	 false,			/* pc_relative */
d886 1
a886 1
	 true,			/* partial_inplace */
d889 1
a889 1
	 false),		/* pcrel_offset */
d896 1
a896 1
	 false,			/* pc_relative */
d901 1
a901 1
	 true,			/* partial_inplace */
d904 1
a904 1
	 false),		/* pcrel_offset */
d911 1
a911 1
	 false,			/* pc_relative */
d916 1
a916 1
	 true,			/* partial_inplace */
d919 1
a919 1
	 false),		/* pcrel_offset */
d926 1
a926 1
	 false,			/* pc_relative */
d931 1
a931 1
	 true,			/* partial_inplace */
d934 1
a934 1
	 false),		/* pcrel_offset */
d941 1
a941 1
	 false,			/* pc_relative */
d946 1
a946 1
	 true,			/* partial_inplace */
d949 1
a949 1
	 false),		/* pcrel_offset */
d956 1
a956 1
	 false,			/* pc_relative */
d961 1
a961 1
	 true,			/* partial_inplace */
d964 1
a964 1
	 false),		/* pcrel_offset */
d971 1
a971 1
	 false,			/* pc_relative */
d976 1
a976 1
	 true,			/* partial_inplace */
d979 1
a979 1
	 false),		/* pcrel_offset */
d986 1
a986 1
	 false,			/* pc_relative */
d991 1
a991 1
	 true,			/* partial_inplace */
d994 1
a994 1
	 false),		/* pcrel_offset */
d1102 1
a1102 1
boolean
d1108 1
a1108 1
  return false;
d1114 1
a1114 1
boolean
d1128 2
a1129 2
      bfd_has_map (abfd) = false;
      return true;
d1140 2
a1141 2
	  bfd_has_map (abfd) = false;
	  return true;
d1145 1
a1145 1
	return false;
d1150 1
a1150 1
	return false;
d1156 1
a1156 1
	return false;
d1163 1
a1163 1
	return false;
d1165 1
a1165 1
	return false;
d1173 1
a1173 1
	  return false;
d1179 1
a1179 1
	return false;
d1195 2
a1196 2
	  bfd_has_map (abfd) = false;
	  return true;
d1200 1
a1200 1
	return false;
d1205 1
a1205 1
	return false;
d1211 1
a1211 1
	return false;
d1221 1
a1221 1
	return false;
d1223 1
a1223 1
	return false;
d1231 1
a1231 1
	  return false;
d1237 1
a1237 1
	return false;
d1255 1
a1255 1
	  return false;
d1261 1
a1261 1
  bfd_has_map (abfd) = true;
d1263 1
a1263 1
  return true;
d1579 1
a1579 1
static boolean
d1613 1
a1613 1
    return false;
d1617 1
a1617 1
    return false;
d1630 1
a1630 1
	    return false;
d1651 1
a1651 1
	return false;
d1660 1
a1660 1
	return false;
d1663 1
a1663 1
  return true;
d1692 1
a1692 1
static boolean
d1701 1
a1701 1
    return false;
d1705 1
a1705 1
      return false;
d1707 1
a1707 1
  return true;
d1710 1
a1710 1
static boolean
d1719 1
a1719 1
    return false;
d1727 1
a1727 1
	return false;
d1736 1
a1736 1
	return false;
d1739 1
a1739 1
  return true;
d1742 1
a1742 1
static boolean
d1762 1
a1762 1
	return false;
d1767 1
a1767 1
  return true;
d1770 1
a1770 1
static boolean
d1867 1
a1867 1
	return false;
d1970 1
a1970 1
	return false;
d2050 1
a2050 1
  return true;
d2053 1
a2053 1
boolean
d2070 1
a2070 1
static boolean
d2078 2
a2079 2
  boolean makemap;
  boolean hasobjects;
d2102 1
a2102 1
    return false;
d2105 1
a2105 1
    return false;
d2108 1
a2108 1
  hasobjects = false;
d2121 1
a2121 1
	    hasobjects = true;
d2141 1
a2141 1
	      return false;
d2155 1
a2155 1
		return false;
d2190 4
a2193 4
	  || (bfd_bwrite ((PTR) name, namlen, abfd) != namlen)
	  || (bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)
	      != SXCOFFARFMAG))
	return false;
d2196 1
a2196 1
	return false;
d2199 1
a2199 1
	return false;
d2202 1
a2202 1
	return false;
d2246 1
a2246 1
    return false;
d2251 1
a2251 1
    return false;
d2257 1
a2257 1
	return false;
d2267 1
a2267 1
	return false;
d2271 1
a2271 1
    return false;
d2282 1
a2282 1
	return false;
d2295 1
a2295 1
    return false;
d2297 1
a2297 1
  return true;
d2300 1
a2300 1
static boolean
d2308 2
a2309 2
  boolean makemap;
  boolean hasobjects;
d2322 1
a2322 1
    return false;
d2326 1
a2326 1
  hasobjects = false;
d2336 1
a2336 1
	hasobjects = true;
d2344 1
a2344 1
	return false;
d2377 1
a2377 1
	      return false;
d2391 1
a2391 1
		return false;
d2418 1
a2418 1
	return false;
d2432 1
a2432 1
	return false;
d2435 1
a2435 1
	return false;
d2438 1
a2438 1
	return false;
d2441 1
a2441 1
	return false;
d2483 1
a2483 1
    return false;
d2531 1
a2531 1
    return false;
d2554 1
a2554 1
	return false;
d2562 1
a2562 1
    return false;
d2564 1
a2564 1
  return true;
d2567 1
a2567 1
boolean
d2583 1
a2583 1
     boolean reloc ATTRIBUTE_UNUSED;
d2758 1
a2758 1
boolean
d2772 1
a2772 1
  return true;
d2775 1
a2775 1
boolean
d2793 1
a2793 1
  return false;
d2796 1
a2796 1
boolean
d2811 1
a2811 1
  return true;
d2814 1
a2814 1
boolean
d2829 1
a2829 1
  return true;
d2832 1
a2832 1
boolean
d2846 1
a2846 1
  howto->pc_relative = true;
d2854 1
a2854 1
  return true;
d2857 1
a2857 1
boolean
d2874 1
a2874 1
    return false;
d2887 1
a2887 1
	  return false;
d2897 1
a2897 1
  return true;
d2900 1
a2900 1
boolean
d2919 1
a2919 1
  return true;
d2922 1
a2922 1
static boolean
d2939 1
a2939 1
    return false;
d2989 1
a2989 1
  howto->pc_relative = true;
d2999 1
a2999 1
  return true;
d3002 1
a3002 1
boolean
d3016 1
a3016 1
  howto->pc_relative = true;
d3026 1
a3026 1
  return true;
d3029 1
a3029 1
static boolean
d3036 1
a3036 1
  return false;
d3039 1
a3039 1
static boolean
d3087 1
a3087 1
	return true;
d3100 1
a3100 1
    return false;
d3109 1
a3109 1
	return true;
d3112 1
a3112 1
  return false;
d3115 1
a3115 1
static boolean
d3142 1
a3142 1
    return true;
d3172 1
a3172 1
    return true;
d3174 1
a3174 1
  return false;
d3177 1
a3177 1
static boolean
d3211 1
a3211 1
    return true;
d3213 1
a3213 1
  return false;
d3329 1
a3329 1
boolean
d3371 1
a3371 1
      howto.pc_relative = false;
d3378 1
a3378 1
      howto.partial_inplace = true;
d3380 1
a3380 1
      howto.pcrel_offset = false;
d3433 2
a3434 2
			  rel->r_vaddr - input_section->vma, true)))
		    return false;
d3447 1
a3447 1
	return false;
d3499 1
a3499 1
	    return false;
d3514 1
a3514 1
  return true;
d3517 1
a3517 1
static boolean
d3546 2
a3547 2
	      ldinfo->failed = true;
	      return false;
d3561 1
a3561 1
  return true;
d3564 1
a3564 1
static boolean
d3575 1
a3575 1
      boolean hash;
d3578 1
a3578 1
      hash = true;
d3580 2
a3581 2
	hash = false;
      indx = _bfd_stringtab_add (strtab, name, hash, false);
d3583 1
a3583 1
	return false;
d3587 1
a3587 1
  return true;
d3624 1
a3624 1
static boolean
d3630 1
a3630 1
    return true;
d3632 1
a3632 1
  return false;
d3635 1
a3635 1
static boolean
d3641 1
a3641 1
    return true;
d3643 1
a3643 1
  return false;
d3662 1
a3662 1
static boolean
d3667 1
a3667 1
     boolean rtld;
d3690 1
a3690 1
    return false;
d3745 1
a3745 1
    return false;
d3781 1
a3781 1
	return false;
d3942 1
a3942 1
  return true;
d3951 1
a3951 1
       false,			/* pc_relative */
d3956 1
a3956 1
       true,			/* partial_inplace */
d3959 1
a3959 1
       false);			/* pcrel_offset */
d4001 2
a4002 2
      true,			/* _bfd_coff_long_filenames */
      false,			/* _bfd_coff_long_section_names */
d4004 1
a4004 1
      false,			/* _bfd_coff_force_symnames_in_strings */
d4143 5
a4147 5
    ((boolean (*) (bfd *, bfd *)) bfd_true),
    ((boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((boolean (*) (bfd *, flagword)) bfd_true),
    ((boolean (*) (bfd *, void * )) bfd_true),
d4157 1
a4157 1
    ((boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
d4243 2
a4244 2
      true,			/* _bfd_coff_long_filenames */
      false,			/* _bfd_coff_long_section_names */
d4246 1
a4246 1
      false,			/* _bfd_coff_force_symnames_in_strings */
d4385 5
a4389 5
    ((boolean (*) (bfd *, bfd *)) bfd_true),
    ((boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((boolean (*) (bfd *, flagword)) bfd_true),
    ((boolean (*) (bfd *, void * )) bfd_true),
d4399 1
a4399 1
    ((boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
@


1.52.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002, 2003
d39 3
a41 6
extern bfd_boolean _bfd_xcoff_mkobject
  PARAMS ((bfd *));
extern bfd_boolean _bfd_xcoff_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
extern bfd_boolean _bfd_xcoff_is_local_label_name
  PARAMS ((bfd *, const char *));
d44 6
a49 11
extern bfd_boolean _bfd_xcoff_slurp_armap
  PARAMS ((bfd *));
extern const bfd_target *_bfd_xcoff_archive_p
  PARAMS ((bfd *));
extern PTR _bfd_xcoff_read_ar_hdr
  PARAMS ((bfd *));
extern bfd *_bfd_xcoff_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
extern int _bfd_xcoff_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
extern bfd_boolean _bfd_xcoff_write_armap
d51 8
a58 16
extern bfd_boolean _bfd_xcoff_write_archive_contents
  PARAMS ((bfd *));
extern int _bfd_xcoff_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
extern void _bfd_xcoff_swap_sym_in
  PARAMS ((bfd *, PTR, PTR));
extern unsigned int _bfd_xcoff_swap_sym_out
  PARAMS ((bfd *, PTR, PTR));
extern void _bfd_xcoff_swap_aux_in
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
extern unsigned int _bfd_xcoff_swap_aux_out
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
static void xcoff_swap_reloc_in
  PARAMS ((bfd *, PTR, PTR));
static unsigned int xcoff_swap_reloc_out
  PARAMS ((bfd *, PTR, PTR));
d61 1
a61 2
void xcoff_rtype2howto
  PARAMS ((arelent *, struct internal_reloc *));
d85 2
a86 3
extern const bfd_target * rs6000coff_core_p
  PARAMS ((bfd *abfd));
extern bfd_boolean rs6000coff_core_file_matches_executable_p
d88 2
a89 4
extern char *rs6000coff_core_file_failing_command
  PARAMS ((bfd *abfd));
extern int rs6000coff_core_file_failing_signal
  PARAMS ((bfd *abfd));
d118 2
a119 3
static const char *normalize_filename
  PARAMS ((bfd *));
static bfd_boolean xcoff_write_armap_old
d121 1
a121 1
static bfd_boolean xcoff_write_armap_big
d123 2
a124 4
static bfd_boolean xcoff_write_archive_contents_old
  PARAMS ((bfd *));
static bfd_boolean xcoff_write_archive_contents_big
  PARAMS ((bfd *));
d137 1
a137 1
static bfd_boolean xcoff_ppc_relocate_section
d140 1
a140 1
static bfd_boolean _bfd_xcoff_put_ldsymbol_name
d145 2
a146 4
static bfd_boolean xcoff_is_lineno_count_overflow
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean xcoff_is_reloc_count_overflow
  PARAMS ((bfd *, bfd_vma));
d151 5
a155 8
static bfd_boolean xcoff_generate_rtinit
  PARAMS ((bfd *, const char *, const char *, bfd_boolean));
static bfd_boolean do_pad
  PARAMS ((bfd *, unsigned int));
static bfd_boolean do_copy
  PARAMS ((bfd *, bfd *));
static bfd_boolean do_shared_object_padding
  PARAMS ((bfd *, bfd *, ufile_ptr *, int));
d158 1
a158 2
static bfd_boolean xcoff_reloc_type_br
  PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
d160 1
a160 1
static bfd_boolean xcoff_complain_overflow_dont_func
d162 1
a162 1
static bfd_boolean xcoff_complain_overflow_bitfield_func
d164 1
a164 1
static bfd_boolean xcoff_complain_overflow_signed_func
d166 1
a166 1
static bfd_boolean xcoff_complain_overflow_unsigned_func
d169 1
a169 1
bfd_boolean (*xcoff_calculate_relocation[XCOFF_MAX_CALCULATE_RELOCATION])
d202 1
a202 1
bfd_boolean (*xcoff_complain_overflow[XCOFF_MAX_COMPLAIN_OVERFLOW])
d214 1
a214 1
bfd_boolean
d223 1
a223 1
    return FALSE;
d242 1
a242 1
  return TRUE;
d247 1
a247 1
bfd_boolean
d256 1
a256 1
    return TRUE;
d287 1
a287 1
  return TRUE;
d295 1
a295 1
bfd_boolean
d300 1
a300 1
  return FALSE;
d471 1
a471 2
unsigned int _bfd_xcoff_swap_aux_out
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
d585 1
a585 1
	 FALSE,			/* pc_relative */
d590 1
a590 1
	 TRUE,			/* partial_inplace */
d593 1
a593 1
	 FALSE),		/* pcrel_offset */
d600 1
a600 1
	 FALSE,			/* pc_relative */
d605 1
a605 1
	 TRUE,			/* partial_inplace */
d608 1
a608 1
	 FALSE),		/* pcrel_offset */
d615 1
a615 1
	 TRUE,			/* pc_relative */
d620 1
a620 1
	 TRUE,			/* partial_inplace */
d623 1
a623 1
	 FALSE),		/* pcrel_offset */
d630 1
a630 1
	 FALSE,			/* pc_relative */
d635 1
a635 1
	 TRUE,			/* partial_inplace */
d638 1
a638 1
	 FALSE),		/* pcrel_offset */
d645 1
a645 1
	 FALSE,			/* pc_relative */
d650 1
a650 1
	 TRUE,			/* partial_inplace */
d653 1
a653 1
	 FALSE),		/* pcrel_offset */
d660 1
a660 1
	 FALSE,			/* pc_relative */
d665 1
a665 1
	 TRUE,			/* partial_inplace */
d668 1
a668 1
	 FALSE),		/* pcrel_offset */
d675 1
a675 1
	 FALSE,			/* pc_relative */
d680 1
a680 1
	 TRUE,			/* partial_inplace */
d683 1
a683 1
	 FALSE),		/* pcrel_offset */
d692 1
a692 1
	 FALSE,			/* pc_relative */
d697 1
a697 1
	 TRUE,			/* partial_inplace */
d700 1
a700 1
	 FALSE),		/* pcrel_offset */
d709 1
a709 1
	 TRUE,			/* pc_relative */
d714 1
a714 1
	 TRUE,			/* partial_inplace */
d717 1
a717 1
	 FALSE),		/* pcrel_offset */
d726 1
a726 1
	 FALSE,			/* pc_relative */
d731 1
a731 1
	 TRUE,			/* partial_inplace */
d734 1
a734 1
	 FALSE),		/* pcrel_offset */
d741 1
a741 1
	 FALSE,			/* pc_relative */
d746 1
a746 1
	 TRUE,			/* partial_inplace */
d749 1
a749 1
	 FALSE),		/* pcrel_offset */
d758 1
a758 1
	 FALSE,			/* pc_relative */
d763 1
a763 1
	 FALSE,			/* partial_inplace */
d766 1
a766 1
	 FALSE),		/* pcrel_offset */
d776 1
a776 1
	 FALSE,			/* pc_relative */
d781 1
a781 1
	 TRUE,			/* partial_inplace */
d784 1
a784 1
	 FALSE),		/* pcrel_offset */
d791 1
a791 1
	 FALSE,			/* pc_relative */
d796 1
a796 1
	 TRUE,			/* partial_inplace */
d799 1
a799 1
	 FALSE),		/* pcrel_offset */
d806 1
a806 1
	 FALSE,			/* pc_relative */
d811 1
a811 1
	 TRUE,			/* partial_inplace */
d814 1
a814 1
	 FALSE),		/* pcrel_offset */
d821 1
a821 1
	 FALSE,			/* pc_relative */
d826 1
a826 1
	 TRUE,			/* partial_inplace */
d829 1
a829 1
	 FALSE),		/* pcrel_offset */
d836 1
a836 1
	 FALSE,			/* pc_relative */
d841 1
a841 1
	 TRUE,			/* partial_inplace */
d844 1
a844 1
	 FALSE),		/* pcrel_offset */
d851 1
a851 1
	 FALSE,			/* pc_relative */
d856 1
a856 1
	 TRUE,			/* partial_inplace */
d859 1
a859 1
	 FALSE),		/* pcrel_offset */
d866 1
a866 1
	 FALSE,			/* pc_relative */
d871 1
a871 1
	 TRUE,			/* partial_inplace */
d874 1
a874 1
	 FALSE),		/* pcrel_offset */
d881 1
a881 1
	 FALSE,			/* pc_relative */
d886 1
a886 1
	 TRUE,			/* partial_inplace */
d889 1
a889 1
	 FALSE),		/* pcrel_offset */
d896 1
a896 1
	 FALSE,			/* pc_relative */
d901 1
a901 1
	 TRUE,			/* partial_inplace */
d904 1
a904 1
	 FALSE),		/* pcrel_offset */
d911 1
a911 1
	 FALSE,			/* pc_relative */
d916 1
a916 1
	 TRUE,			/* partial_inplace */
d919 1
a919 1
	 FALSE),		/* pcrel_offset */
d926 1
a926 1
	 FALSE,			/* pc_relative */
d931 1
a931 1
	 TRUE,			/* partial_inplace */
d934 1
a934 1
	 FALSE),		/* pcrel_offset */
d941 1
a941 1
	 FALSE,			/* pc_relative */
d946 1
a946 1
	 TRUE,			/* partial_inplace */
d949 1
a949 1
	 FALSE),		/* pcrel_offset */
d956 1
a956 1
	 FALSE,			/* pc_relative */
d961 1
a961 1
	 TRUE,			/* partial_inplace */
d964 1
a964 1
	 FALSE),		/* pcrel_offset */
d979 1
a979 1
  /* Special case some 16 bit reloc */
d1072 1
a1072 1
bfd_boolean
d1078 1
a1078 1
  return FALSE;
d1084 1
a1084 1
bfd_boolean
d1098 2
a1099 2
      bfd_has_map (abfd) = FALSE;
      return TRUE;
d1110 2
a1111 2
	  bfd_has_map (abfd) = FALSE;
	  return TRUE;
d1115 1
a1115 1
	return FALSE;
d1120 1
a1120 1
	return FALSE;
d1126 1
a1126 1
	return FALSE;
d1133 1
a1133 1
	return FALSE;
d1135 1
a1135 1
	return FALSE;
d1143 1
a1143 1
	  return FALSE;
d1149 1
a1149 1
	return FALSE;
d1165 2
a1166 2
	  bfd_has_map (abfd) = FALSE;
	  return TRUE;
d1170 1
a1170 1
	return FALSE;
d1175 1
a1175 1
	return FALSE;
d1181 1
a1181 1
	return FALSE;
d1191 1
a1191 1
	return FALSE;
d1193 1
a1193 1
	return FALSE;
d1201 1
a1201 1
	  return FALSE;
d1207 1
a1207 1
	return FALSE;
d1225 1
a1225 1
	  return FALSE;
d1231 1
a1231 1
  bfd_has_map (abfd) = TRUE;
d1233 1
a1233 1
  return TRUE;
d1548 2
a1549 1
static bfd_boolean
d1583 1
a1583 1
    return FALSE;
d1587 1
a1587 1
    return FALSE;
d1600 1
a1600 1
	    return FALSE;
d1621 1
a1621 1
	return FALSE;
d1630 1
a1630 1
	return FALSE;
d1633 1
a1633 1
  return TRUE;
d1662 1
a1662 1
static bfd_boolean
d1671 1
a1671 1
    return FALSE;
d1675 1
a1675 1
      return FALSE;
d1677 1
a1677 1
  return TRUE;
d1680 1
a1680 1
static bfd_boolean
d1689 1
a1689 1
    return FALSE;
d1697 1
a1697 1
	return FALSE;
d1706 1
a1706 1
	return FALSE;
d1709 1
a1709 1
  return TRUE;
d1712 1
a1712 1
static bfd_boolean
d1732 1
a1732 1
	return FALSE;
d1737 1
a1737 1
  return TRUE;
d1740 1
a1740 1
static bfd_boolean
d1837 1
a1837 1
	return FALSE;
d1940 1
a1940 1
	return FALSE;
d2020 1
a2020 1
  return TRUE;
d2023 1
a2023 1
bfd_boolean
d2040 1
a2040 1
static bfd_boolean
d2048 2
a2049 2
  bfd_boolean makemap;
  bfd_boolean hasobjects;
d2072 1
a2072 1
    return FALSE;
d2075 1
a2075 1
    return FALSE;
d2078 1
a2078 1
  hasobjects = FALSE;
d2091 1
a2091 1
	    hasobjects = TRUE;
d2111 1
a2111 1
	      return FALSE;
d2125 1
a2125 1
		return FALSE;
d2160 4
a2163 4
	  || bfd_bwrite ((PTR) name, namlen, abfd) != namlen
	  || bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG,
			 abfd) != SXCOFFARFMAG)
	return FALSE;
d2166 1
a2166 1
	return FALSE;
d2169 1
a2169 1
	return FALSE;
d2172 1
a2172 1
	return FALSE;
d2216 1
a2216 1
    return FALSE;
d2221 1
a2221 1
    return FALSE;
d2227 1
a2227 1
	return FALSE;
d2237 1
a2237 1
	return FALSE;
d2241 1
a2241 1
    return FALSE;
d2252 1
a2252 1
	return FALSE;
d2265 1
a2265 1
    return FALSE;
d2267 1
a2267 1
  return TRUE;
d2270 1
a2270 1
static bfd_boolean
d2278 2
a2279 2
  bfd_boolean makemap;
  bfd_boolean hasobjects;
d2292 1
a2292 1
    return FALSE;
d2296 1
a2296 1
  hasobjects = FALSE;
d2306 1
a2306 1
	hasobjects = TRUE;
d2314 1
a2314 1
	return FALSE;
d2347 1
a2347 1
	      return FALSE;
d2361 1
a2361 1
		return FALSE;
d2388 1
a2388 1
	return FALSE;
d2402 1
a2402 1
	return FALSE;
d2405 1
a2405 1
	return FALSE;
d2408 1
a2408 1
	return FALSE;
d2411 1
a2411 1
	return FALSE;
d2453 1
a2453 1
    return FALSE;
d2501 1
a2501 1
    return FALSE;
d2524 1
a2524 1
	return FALSE;
d2532 1
a2532 1
    return FALSE;
d2534 1
a2534 1
  return TRUE;
d2537 1
a2537 1
bfd_boolean
d2553 1
a2553 1
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d2728 1
a2728 1
bfd_boolean
d2742 1
a2742 1
  return TRUE;
d2745 1
a2745 1
bfd_boolean
d2763 1
a2763 1
  return FALSE;
d2766 1
a2766 1
bfd_boolean
d2781 1
a2781 1
  return TRUE;
d2784 1
a2784 1
bfd_boolean
d2799 1
a2799 1
  return TRUE;
d2802 1
a2802 1
bfd_boolean
d2816 1
a2816 1
  howto->pc_relative = TRUE;
d2824 1
a2824 1
  return TRUE;
d2827 1
a2827 1
bfd_boolean
d2844 1
a2844 1
    return FALSE;
d2857 1
a2857 1
	  return FALSE;
d2867 1
a2867 1
  return TRUE;
d2870 1
a2870 1
bfd_boolean
d2889 1
a2889 1
  return TRUE;
d2892 1
a2892 1
static bfd_boolean
d2909 1
a2909 1
    return FALSE;
d2959 1
a2959 1
  howto->pc_relative = TRUE;
d2969 1
a2969 1
  return TRUE;
d2972 1
a2972 1
bfd_boolean
d2986 1
a2986 1
  howto->pc_relative = TRUE;
d2996 1
a2996 1
  return TRUE;
d2999 1
a2999 1
static bfd_boolean
d3006 1
a3006 1
  return FALSE;
d3009 1
a3009 1
static bfd_boolean
d3057 1
a3057 1
	return TRUE;
d3070 1
a3070 1
    return FALSE;
d3079 1
a3079 1
	return TRUE;
d3082 1
a3082 1
  return FALSE;
d3085 1
a3085 1
static bfd_boolean
d3112 1
a3112 1
    return TRUE;
d3142 1
a3142 1
    return TRUE;
d3144 1
a3144 1
  return FALSE;
d3147 1
a3147 1
static bfd_boolean
d3181 1
a3181 1
    return TRUE;
d3183 1
a3183 1
  return FALSE;
d3299 1
a3299 1
bfd_boolean
d3341 1
a3341 1
      howto.pc_relative = FALSE;
d3348 1
a3348 1
      howto.partial_inplace = TRUE;
d3350 1
a3350 1
      howto.pcrel_offset = FALSE;
d3399 1
a3399 1
		       && ! info->relocatable)
d3403 2
a3404 2
			  rel->r_vaddr - input_section->vma, TRUE)))
		    return FALSE;
d3417 1
a3417 1
	return FALSE;
d3469 1
a3469 1
	    return FALSE;
d3484 1
a3484 1
  return TRUE;
d3487 1
a3487 1
static bfd_boolean
d3516 2
a3517 2
	      ldinfo->failed = TRUE;
	      return FALSE;
d3531 1
a3531 1
  return TRUE;
d3534 1
a3534 1
static bfd_boolean
d3545 1
a3545 1
      bfd_boolean hash;
d3548 1
a3548 1
      hash = TRUE;
d3550 2
a3551 2
	hash = FALSE;
      indx = _bfd_stringtab_add (strtab, name, hash, FALSE);
d3553 1
a3553 1
	return FALSE;
d3557 1
a3557 1
  return TRUE;
d3594 1
a3594 1
static bfd_boolean
d3600 1
a3600 1
    return TRUE;
d3602 1
a3602 1
  return FALSE;
d3605 1
a3605 1
static bfd_boolean
d3611 1
a3611 1
    return TRUE;
d3613 1
a3613 1
  return FALSE;
d3632 1
a3632 1
static bfd_boolean
d3637 1
a3637 1
     bfd_boolean rtld;
d3660 1
a3660 1
    return FALSE;
d3715 1
a3715 1
    return FALSE;
d3751 1
a3751 1
	return FALSE;
d3912 1
a3912 1
  return TRUE;
d3921 1
a3921 1
       FALSE,			/* pc_relative */
d3926 1
a3926 1
       TRUE,			/* partial_inplace */
d3929 1
a3929 1
       FALSE);			/* pcrel_offset */
d3971 2
a3972 2
      TRUE,			/* _bfd_coff_long_filenames */
      FALSE,			/* _bfd_coff_long_section_names */
d3974 1
a3974 1
      FALSE,			/* _bfd_coff_force_symnames_in_strings */
d4113 5
a4117 5
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((bfd_boolean (*) (bfd *, flagword)) bfd_true),
    ((bfd_boolean (*) (bfd *, void * )) bfd_true),
d4127 1
a4127 1
    ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
d4138 1
a4138 1
    coff_canonicalize_symtab,
d4213 2
a4214 2
      TRUE,			/* _bfd_coff_long_filenames */
      FALSE,			/* _bfd_coff_long_section_names */
d4216 1
a4216 1
      FALSE,			/* _bfd_coff_force_symnames_in_strings */
d4355 5
a4359 5
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((bfd_boolean (*) (bfd *, flagword)) bfd_true),
    ((bfd_boolean (*) (bfd *, void * )) bfd_true),
d4369 1
a4369 1
    ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
d4380 1
a4380 1
    coff_canonicalize_symtab,
@


1.52.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d39 3
a41 6
extern bfd_boolean _bfd_xcoff_mkobject
  PARAMS ((bfd *));
extern bfd_boolean _bfd_xcoff_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
extern bfd_boolean _bfd_xcoff_is_local_label_name
  PARAMS ((bfd *, const char *));
d44 6
a49 11
extern bfd_boolean _bfd_xcoff_slurp_armap
  PARAMS ((bfd *));
extern const bfd_target *_bfd_xcoff_archive_p
  PARAMS ((bfd *));
extern PTR _bfd_xcoff_read_ar_hdr
  PARAMS ((bfd *));
extern bfd *_bfd_xcoff_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
extern int _bfd_xcoff_stat_arch_elt
  PARAMS ((bfd *, struct stat *));
extern bfd_boolean _bfd_xcoff_write_armap
d51 8
a58 16
extern bfd_boolean _bfd_xcoff_write_archive_contents
  PARAMS ((bfd *));
extern int _bfd_xcoff_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
extern void _bfd_xcoff_swap_sym_in
  PARAMS ((bfd *, PTR, PTR));
extern unsigned int _bfd_xcoff_swap_sym_out
  PARAMS ((bfd *, PTR, PTR));
extern void _bfd_xcoff_swap_aux_in
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
extern unsigned int _bfd_xcoff_swap_aux_out
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
static void xcoff_swap_reloc_in
  PARAMS ((bfd *, PTR, PTR));
static unsigned int xcoff_swap_reloc_out
  PARAMS ((bfd *, PTR, PTR));
d61 1
a61 2
void xcoff_rtype2howto
  PARAMS ((arelent *, struct internal_reloc *));
d85 2
a86 3
extern const bfd_target * rs6000coff_core_p
  PARAMS ((bfd *abfd));
extern bfd_boolean rs6000coff_core_file_matches_executable_p
d88 2
a89 4
extern char *rs6000coff_core_file_failing_command
  PARAMS ((bfd *abfd));
extern int rs6000coff_core_file_failing_signal
  PARAMS ((bfd *abfd));
d118 2
a119 3
static const char *normalize_filename
  PARAMS ((bfd *));
static bfd_boolean xcoff_write_armap_old
d121 1
a121 1
static bfd_boolean xcoff_write_armap_big
d123 2
a124 4
static bfd_boolean xcoff_write_archive_contents_old
  PARAMS ((bfd *));
static bfd_boolean xcoff_write_archive_contents_big
  PARAMS ((bfd *));
d137 1
a137 1
static bfd_boolean xcoff_ppc_relocate_section
d140 1
a140 1
static bfd_boolean _bfd_xcoff_put_ldsymbol_name
d145 2
a146 4
static bfd_boolean xcoff_is_lineno_count_overflow
  PARAMS ((bfd *, bfd_vma));
static bfd_boolean xcoff_is_reloc_count_overflow
  PARAMS ((bfd *, bfd_vma));
d151 5
a155 8
static bfd_boolean xcoff_generate_rtinit
  PARAMS ((bfd *, const char *, const char *, bfd_boolean));
static bfd_boolean do_pad
  PARAMS ((bfd *, unsigned int));
static bfd_boolean do_copy
  PARAMS ((bfd *, bfd *));
static bfd_boolean do_shared_object_padding
  PARAMS ((bfd *, bfd *, ufile_ptr *, int));
d158 1
a158 2
static bfd_boolean xcoff_reloc_type_br
  PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
d160 1
a160 1
static bfd_boolean xcoff_complain_overflow_dont_func
d162 1
a162 1
static bfd_boolean xcoff_complain_overflow_bitfield_func
d164 1
a164 1
static bfd_boolean xcoff_complain_overflow_signed_func
d166 1
a166 1
static bfd_boolean xcoff_complain_overflow_unsigned_func
d169 1
a169 1
bfd_boolean (*xcoff_calculate_relocation[XCOFF_MAX_CALCULATE_RELOCATION])
d202 1
a202 1
bfd_boolean (*xcoff_complain_overflow[XCOFF_MAX_COMPLAIN_OVERFLOW])
d214 1
a214 1
bfd_boolean
d223 1
a223 1
    return FALSE;
d242 1
a242 1
  return TRUE;
d247 1
a247 1
bfd_boolean
d256 1
a256 1
    return TRUE;
d287 1
a287 1
  return TRUE;
d295 1
a295 1
bfd_boolean
d300 1
a300 1
  return FALSE;
d471 1
a471 2
unsigned int _bfd_xcoff_swap_aux_out
  PARAMS ((bfd *, PTR, int, int, int, int, PTR));
d585 1
a585 1
	 FALSE,			/* pc_relative */
d590 1
a590 1
	 TRUE,			/* partial_inplace */
d593 1
a593 1
	 FALSE),		/* pcrel_offset */
d600 1
a600 1
	 FALSE,			/* pc_relative */
d605 1
a605 1
	 TRUE,			/* partial_inplace */
d608 1
a608 1
	 FALSE),		/* pcrel_offset */
d615 1
a615 1
	 TRUE,			/* pc_relative */
d620 1
a620 1
	 TRUE,			/* partial_inplace */
d623 1
a623 1
	 FALSE),		/* pcrel_offset */
d630 1
a630 1
	 FALSE,			/* pc_relative */
d635 1
a635 1
	 TRUE,			/* partial_inplace */
d638 1
a638 1
	 FALSE),		/* pcrel_offset */
d645 1
a645 1
	 FALSE,			/* pc_relative */
d650 1
a650 1
	 TRUE,			/* partial_inplace */
d653 1
a653 1
	 FALSE),		/* pcrel_offset */
d660 1
a660 1
	 FALSE,			/* pc_relative */
d665 1
a665 1
	 TRUE,			/* partial_inplace */
d668 1
a668 1
	 FALSE),		/* pcrel_offset */
d675 1
a675 1
	 FALSE,			/* pc_relative */
d680 1
a680 1
	 TRUE,			/* partial_inplace */
d683 1
a683 1
	 FALSE),		/* pcrel_offset */
d692 1
a692 1
	 FALSE,			/* pc_relative */
d697 1
a697 1
	 TRUE,			/* partial_inplace */
d700 1
a700 1
	 FALSE),		/* pcrel_offset */
d709 1
a709 1
	 TRUE,			/* pc_relative */
d714 1
a714 1
	 TRUE,			/* partial_inplace */
d717 1
a717 1
	 FALSE),		/* pcrel_offset */
d726 1
a726 1
	 FALSE,			/* pc_relative */
d731 1
a731 1
	 TRUE,			/* partial_inplace */
d734 1
a734 1
	 FALSE),		/* pcrel_offset */
d741 1
a741 1
	 FALSE,			/* pc_relative */
d746 1
a746 1
	 TRUE,			/* partial_inplace */
d749 1
a749 1
	 FALSE),		/* pcrel_offset */
d758 1
a758 1
	 FALSE,			/* pc_relative */
d763 1
a763 1
	 FALSE,			/* partial_inplace */
d766 1
a766 1
	 FALSE),		/* pcrel_offset */
d776 1
a776 1
	 FALSE,			/* pc_relative */
d781 1
a781 1
	 TRUE,			/* partial_inplace */
d784 1
a784 1
	 FALSE),		/* pcrel_offset */
d791 1
a791 1
	 FALSE,			/* pc_relative */
d796 1
a796 1
	 TRUE,			/* partial_inplace */
d799 1
a799 1
	 FALSE),		/* pcrel_offset */
d806 1
a806 1
	 FALSE,			/* pc_relative */
d811 1
a811 1
	 TRUE,			/* partial_inplace */
d814 1
a814 1
	 FALSE),		/* pcrel_offset */
d821 1
a821 1
	 FALSE,			/* pc_relative */
d826 1
a826 1
	 TRUE,			/* partial_inplace */
d829 1
a829 1
	 FALSE),		/* pcrel_offset */
d836 1
a836 1
	 FALSE,			/* pc_relative */
d841 1
a841 1
	 TRUE,			/* partial_inplace */
d844 1
a844 1
	 FALSE),		/* pcrel_offset */
d851 1
a851 1
	 FALSE,			/* pc_relative */
d856 1
a856 1
	 TRUE,			/* partial_inplace */
d859 1
a859 1
	 FALSE),		/* pcrel_offset */
d866 1
a866 1
	 FALSE,			/* pc_relative */
d871 1
a871 1
	 TRUE,			/* partial_inplace */
d874 1
a874 1
	 FALSE),		/* pcrel_offset */
d881 1
a881 1
	 FALSE,			/* pc_relative */
d886 1
a886 1
	 TRUE,			/* partial_inplace */
d889 1
a889 1
	 FALSE),		/* pcrel_offset */
d896 1
a896 1
	 FALSE,			/* pc_relative */
d901 1
a901 1
	 TRUE,			/* partial_inplace */
d904 1
a904 1
	 FALSE),		/* pcrel_offset */
d911 1
a911 1
	 FALSE,			/* pc_relative */
d916 1
a916 1
	 TRUE,			/* partial_inplace */
d919 1
a919 1
	 FALSE),		/* pcrel_offset */
d926 1
a926 1
	 FALSE,			/* pc_relative */
d931 1
a931 1
	 TRUE,			/* partial_inplace */
d934 1
a934 1
	 FALSE),		/* pcrel_offset */
d941 1
a941 1
	 FALSE,			/* pc_relative */
d946 1
a946 1
	 TRUE,			/* partial_inplace */
d949 1
a949 1
	 FALSE),		/* pcrel_offset */
d956 1
a956 1
	 FALSE,			/* pc_relative */
d961 1
a961 1
	 TRUE,			/* partial_inplace */
d964 1
a964 1
	 FALSE),		/* pcrel_offset */
d1072 1
a1072 1
bfd_boolean
d1078 1
a1078 1
  return FALSE;
d1084 1
a1084 1
bfd_boolean
d1098 2
a1099 2
      bfd_has_map (abfd) = FALSE;
      return TRUE;
d1110 2
a1111 2
	  bfd_has_map (abfd) = FALSE;
	  return TRUE;
d1115 1
a1115 1
	return FALSE;
d1120 1
a1120 1
	return FALSE;
d1126 1
a1126 1
	return FALSE;
d1133 1
a1133 1
	return FALSE;
d1135 1
a1135 1
	return FALSE;
d1143 1
a1143 1
	  return FALSE;
d1149 1
a1149 1
	return FALSE;
d1165 2
a1166 2
	  bfd_has_map (abfd) = FALSE;
	  return TRUE;
d1170 1
a1170 1
	return FALSE;
d1175 1
a1175 1
	return FALSE;
d1181 1
a1181 1
	return FALSE;
d1191 1
a1191 1
	return FALSE;
d1193 1
a1193 1
	return FALSE;
d1201 1
a1201 1
	  return FALSE;
d1207 1
a1207 1
	return FALSE;
d1225 1
a1225 1
	  return FALSE;
d1231 1
a1231 1
  bfd_has_map (abfd) = TRUE;
d1233 1
a1233 1
  return TRUE;
d1549 1
a1549 1
static bfd_boolean
d1583 1
a1583 1
    return FALSE;
d1587 1
a1587 1
    return FALSE;
d1600 1
a1600 1
	    return FALSE;
d1621 1
a1621 1
	return FALSE;
d1630 1
a1630 1
	return FALSE;
d1633 1
a1633 1
  return TRUE;
d1662 1
a1662 1
static bfd_boolean
d1671 1
a1671 1
    return FALSE;
d1675 1
a1675 1
      return FALSE;
d1677 1
a1677 1
  return TRUE;
d1680 1
a1680 1
static bfd_boolean
d1689 1
a1689 1
    return FALSE;
d1697 1
a1697 1
	return FALSE;
d1706 1
a1706 1
	return FALSE;
d1709 1
a1709 1
  return TRUE;
d1712 1
a1712 1
static bfd_boolean
d1732 1
a1732 1
	return FALSE;
d1737 1
a1737 1
  return TRUE;
d1740 1
a1740 1
static bfd_boolean
d1837 1
a1837 1
	return FALSE;
d1940 1
a1940 1
	return FALSE;
d2020 1
a2020 1
  return TRUE;
d2023 1
a2023 1
bfd_boolean
d2040 1
a2040 1
static bfd_boolean
d2048 2
a2049 2
  bfd_boolean makemap;
  bfd_boolean hasobjects;
d2072 1
a2072 1
    return FALSE;
d2075 1
a2075 1
    return FALSE;
d2078 1
a2078 1
  hasobjects = FALSE;
d2091 1
a2091 1
	    hasobjects = TRUE;
d2111 1
a2111 1
	      return FALSE;
d2125 1
a2125 1
		return FALSE;
d2160 4
a2163 4
	  || bfd_bwrite ((PTR) name, namlen, abfd) != namlen
	  || bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG,
			 abfd) != SXCOFFARFMAG)
	return FALSE;
d2166 1
a2166 1
	return FALSE;
d2169 1
a2169 1
	return FALSE;
d2172 1
a2172 1
	return FALSE;
d2216 1
a2216 1
    return FALSE;
d2221 1
a2221 1
    return FALSE;
d2227 1
a2227 1
	return FALSE;
d2237 1
a2237 1
	return FALSE;
d2241 1
a2241 1
    return FALSE;
d2252 1
a2252 1
	return FALSE;
d2265 1
a2265 1
    return FALSE;
d2267 1
a2267 1
  return TRUE;
d2270 1
a2270 1
static bfd_boolean
d2278 2
a2279 2
  bfd_boolean makemap;
  bfd_boolean hasobjects;
d2292 1
a2292 1
    return FALSE;
d2296 1
a2296 1
  hasobjects = FALSE;
d2306 1
a2306 1
	hasobjects = TRUE;
d2314 1
a2314 1
	return FALSE;
d2347 1
a2347 1
	      return FALSE;
d2361 1
a2361 1
		return FALSE;
d2388 1
a2388 1
	return FALSE;
d2402 1
a2402 1
	return FALSE;
d2405 1
a2405 1
	return FALSE;
d2408 1
a2408 1
	return FALSE;
d2411 1
a2411 1
	return FALSE;
d2453 1
a2453 1
    return FALSE;
d2501 1
a2501 1
    return FALSE;
d2524 1
a2524 1
	return FALSE;
d2532 1
a2532 1
    return FALSE;
d2534 1
a2534 1
  return TRUE;
d2537 1
a2537 1
bfd_boolean
d2553 1
a2553 1
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d2728 1
a2728 1
bfd_boolean
d2742 1
a2742 1
  return TRUE;
d2745 1
a2745 1
bfd_boolean
d2763 1
a2763 1
  return FALSE;
d2766 1
a2766 1
bfd_boolean
d2781 1
a2781 1
  return TRUE;
d2784 1
a2784 1
bfd_boolean
d2799 1
a2799 1
  return TRUE;
d2802 1
a2802 1
bfd_boolean
d2816 1
a2816 1
  howto->pc_relative = TRUE;
d2824 1
a2824 1
  return TRUE;
d2827 1
a2827 1
bfd_boolean
d2844 1
a2844 1
    return FALSE;
d2857 1
a2857 1
	  return FALSE;
d2867 1
a2867 1
  return TRUE;
d2870 1
a2870 1
bfd_boolean
d2889 1
a2889 1
  return TRUE;
d2892 1
a2892 1
static bfd_boolean
d2909 1
a2909 1
    return FALSE;
d2959 1
a2959 1
  howto->pc_relative = TRUE;
d2969 1
a2969 1
  return TRUE;
d2972 1
a2972 1
bfd_boolean
d2986 1
a2986 1
  howto->pc_relative = TRUE;
d2996 1
a2996 1
  return TRUE;
d2999 1
a2999 1
static bfd_boolean
d3006 1
a3006 1
  return FALSE;
d3009 1
a3009 1
static bfd_boolean
d3057 1
a3057 1
	return TRUE;
d3070 1
a3070 1
    return FALSE;
d3079 1
a3079 1
	return TRUE;
d3082 1
a3082 1
  return FALSE;
d3085 1
a3085 1
static bfd_boolean
d3112 1
a3112 1
    return TRUE;
d3142 1
a3142 1
    return TRUE;
d3144 1
a3144 1
  return FALSE;
d3147 1
a3147 1
static bfd_boolean
d3181 1
a3181 1
    return TRUE;
d3183 1
a3183 1
  return FALSE;
d3299 1
a3299 1
bfd_boolean
d3341 1
a3341 1
      howto.pc_relative = FALSE;
d3348 1
a3348 1
      howto.partial_inplace = TRUE;
d3350 1
a3350 1
      howto.pcrel_offset = FALSE;
d3403 2
a3404 2
			  rel->r_vaddr - input_section->vma, TRUE)))
		    return FALSE;
d3417 1
a3417 1
	return FALSE;
d3469 1
a3469 1
	    return FALSE;
d3484 1
a3484 1
  return TRUE;
d3487 1
a3487 1
static bfd_boolean
d3516 2
a3517 2
	      ldinfo->failed = TRUE;
	      return FALSE;
d3531 1
a3531 1
  return TRUE;
d3534 1
a3534 1
static bfd_boolean
d3545 1
a3545 1
      bfd_boolean hash;
d3548 1
a3548 1
      hash = TRUE;
d3550 2
a3551 2
	hash = FALSE;
      indx = _bfd_stringtab_add (strtab, name, hash, FALSE);
d3553 1
a3553 1
	return FALSE;
d3557 1
a3557 1
  return TRUE;
d3594 1
a3594 1
static bfd_boolean
d3600 1
a3600 1
    return TRUE;
d3602 1
a3602 1
  return FALSE;
d3605 1
a3605 1
static bfd_boolean
d3611 1
a3611 1
    return TRUE;
d3613 1
a3613 1
  return FALSE;
d3632 1
a3632 1
static bfd_boolean
d3637 1
a3637 1
     bfd_boolean rtld;
d3660 1
a3660 1
    return FALSE;
d3715 1
a3715 1
    return FALSE;
d3751 1
a3751 1
	return FALSE;
d3912 1
a3912 1
  return TRUE;
d3921 1
a3921 1
       FALSE,			/* pc_relative */
d3926 1
a3926 1
       TRUE,			/* partial_inplace */
d3929 1
a3929 1
       FALSE);			/* pcrel_offset */
d3971 2
a3972 2
      TRUE,			/* _bfd_coff_long_filenames */
      FALSE,			/* _bfd_coff_long_section_names */
d3974 1
a3974 1
      FALSE,			/* _bfd_coff_force_symnames_in_strings */
d4113 5
a4117 5
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((bfd_boolean (*) (bfd *, flagword)) bfd_true),
    ((bfd_boolean (*) (bfd *, void * )) bfd_true),
d4127 1
a4127 1
    ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
d4213 2
a4214 2
      TRUE,			/* _bfd_coff_long_filenames */
      FALSE,			/* _bfd_coff_long_section_names */
d4216 1
a4216 1
      FALSE,			/* _bfd_coff_force_symnames_in_strings */
d4355 5
a4359 5
    ((bfd_boolean (*) (bfd *, bfd *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((bfd_boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((bfd_boolean (*) (bfd *, flagword)) bfd_true),
    ((bfd_boolean (*) (bfd *, void * )) bfd_true),
d4369 1
a4369 1
    ((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
@


1.52.10.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
   Copyright 1990-1999, 2000, 2001, 2002, 2003
d3429 1
a3429 1
		       && ! info->relocatable)
@


1.52.10.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d4168 1
a4168 1
    coff_canonicalize_symtab,
d4410 1
a4410 1
    coff_canonicalize_symtab,
@


1.52.10.4
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1009 1
a1009 1
  /* Special case some 16 bit reloc */
d1578 1
@


1.51
log
@	* libxcoff.h: Use PARAMS on function declarations.
	* coff-rs6000.c (xcoff_generate_rtinit): Simplify size calc.
	* coff64-rs6000.c (xcoff64_generate_rtinit): Likewise.
@
text
@d4056 1
a4056 1
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
d4298 1
a4298 1
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
@


1.50
log
@	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.
@
text
@d3711 1
a3711 1
  data_buffer_size += (data_buffer_size & 7) ? 8 - (data_buffer_size & 7) : 0;
@


1.49
log
@	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.
@
text
@a998 5

  /* Put a meaningful value in addend */
  relent->addend = (internal->r_size & 0x80
		    ? -internal->r_vaddr
		    : internal->r_vaddr);
@


1.48
log
@	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.
@
text
@d86 1
a86 1
extern boolean rs6000coff_core_file_matches_executable_p 
d151 4
a154 4
static boolean xcoff_generate_rtinit 
  PARAMS((bfd *, const char *, const char *, boolean));
static boolean do_pad PARAMS((bfd *, unsigned int));
static boolean do_copy PARAMS((bfd *, bfd *));
d160 1
a160 1
static boolean xcoff_complain_overflow_dont_func 
d170 1
a170 1
     (XCOFF_RELOC_FUNCTION_ARGS) =
d172 4
a175 4
  xcoff_reloc_type_pos,  /* R_POS   (0x00) */
  xcoff_reloc_type_neg,  /* R_NEG   (0x01) */
  xcoff_reloc_type_rel,  /* R_REL   (0x02) */
  xcoff_reloc_type_toc,  /* R_TOC   (0x03) */
d177 10
a186 10
  xcoff_reloc_type_toc,  /* R_GL    (0x05) */
  xcoff_reloc_type_toc,  /* R_TCL   (0x06) */
  xcoff_reloc_type_fail, /*         (0x07) */
  xcoff_reloc_type_ba,   /* R_BA    (0x08) */
  xcoff_reloc_type_fail, /*         (0x09) */
  xcoff_reloc_type_br,   /* R_BR    (0x0a) */
  xcoff_reloc_type_fail, /*         (0x0b) */
  xcoff_reloc_type_pos,  /* R_RL    (0x0c) */
  xcoff_reloc_type_pos,  /* R_RLA   (0x0d) */
  xcoff_reloc_type_fail, /*         (0x0e) */
d188 4
a191 4
  xcoff_reloc_type_fail, /*         (0x10) */
  xcoff_reloc_type_fail, /*         (0x11) */
  xcoff_reloc_type_toc,  /* R_TRL   (0x12) */
  xcoff_reloc_type_toc,  /* R_TRLA  (0x13) */
d194 1
a194 1
  xcoff_reloc_type_ba,   /* R_CAI   (0x16) */
d196 4
a199 4
  xcoff_reloc_type_ba,   /* R_RBA   (0x18) */
  xcoff_reloc_type_ba,   /* R_RBAC  (0x19) */
  xcoff_reloc_type_br,   /* R_RBR   (0x1a) */
  xcoff_reloc_type_ba,   /* R_RBRC  (0x1b) */
d203 1
a203 1
     (XCOFF_COMPLAIN_FUNCTION_ARGS) = 
d305 1
a305 1
     bfd            *abfd;
d314 1
a314 1
      memcpy(in->_n._n_name, ext->e.e_name, SYMNMLEN);
d331 3
a333 3
     bfd       *abfd;
     PTR	inp;
     PTR	extp;
d340 1
a340 1
      memcpy(ext->e.e_name, in->_n._n_name, SYMNMLEN);
d358 7
a364 7
     bfd            *abfd;
     PTR 	      ext1;
     int             type;
     int             class;
     int	      indx;
     int	      numaux;
     PTR 	      in1;
d421 1
a421 1
             safety.  */
d486 1
a486 1
  memset((PTR)ext, 0, bfd_coff_auxesz (abfd));
d581 6
a586 6
  HOWTO (R_POS,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d588 6
a593 6
	 0,		        /* special_function */
	 "R_POS",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false),                /* pcrel_offset */
d596 6
a601 6
  HOWTO (R_NEG,	                /* type */
	 0,	                /* rightshift */
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d603 6
a608 6
	 0,		        /* special_function */
	 "R_NEG",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false),                /* pcrel_offset */
d611 6
a616 6
  HOWTO (R_REL,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 true,	                /* pc_relative */
	 0,	                /* bitpos */
d618 6
a623 6
	 0,		        /* special_function */
	 "R_REL",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false),                /* pcrel_offset */
d626 6
a631 6
  HOWTO (R_TOC,	                /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d633 6
a638 6
	 0,		        /* special_function */
	 "R_TOC",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d641 6
a646 6
  HOWTO (R_RTB,	                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d648 6
a653 6
	 0,		        /* special_function */
	 "R_RTB",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d656 2
a657 2
  HOWTO (R_GL,	                /* type */
	 0,	                /* rightshift */
d659 3
a661 3
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d663 10
a672 10
	 0,		        /* special_function */
	 "R_GL",                /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */

  /* Local TOC relative symbol.  */
  HOWTO (R_TCL,	                /* type */
	 0,	                /* rightshift */
d674 3
a676 3
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d678 6
a683 6
	 0,		        /* special_function */
	 "R_TCL",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d688 6
a693 6
  HOWTO (R_BA,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d695 3
a697 3
	 0,		        /* special_function */
	 "R_BA_26",             /* name */
	 true,	                /* partial_inplace */
d700 1
a700 1
	 false),                /* pcrel_offset */
d705 6
a710 6
  HOWTO (R_BR,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 true,	                /* pc_relative */
	 0,	                /* bitpos */
d712 3
a714 3
	 0,		        /* special_function */
	 "R_BR",                /* name */
	 true,	                /* partial_inplace */
d717 1
a717 1
	 false),                /* pcrel_offset */
d722 2
a723 2
  HOWTO (R_RL,	                /* type */
	 0,	                /* rightshift */
d725 3
a727 3
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d729 6
a734 6
	 0,		        /* special_function */
	 "R_RL",                /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d737 2
a738 2
  HOWTO (R_RLA,	                /* type */
	 0,	                /* rightshift */
d740 3
a742 3
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d744 6
a749 6
	 0,		        /* special_function */
	 "R_RLA",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d754 6
a759 6
  HOWTO (R_REF,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d761 6
a766 6
	 0,		        /* special_function */
	 "R_REF",               /* name */
	 false,	                /* partial_inplace */
	 0,		        /* src_mask */
	 0,     	   	/* dst_mask */
	 false),                /* pcrel_offset */
d772 2
a773 2
  HOWTO (R_TRL,	                /* type */
	 0,	                /* rightshift */
d775 3
a777 3
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d779 6
a784 6
	 0,		        /* special_function */
	 "R_TRL",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d787 2
a788 2
  HOWTO (R_TRLA,                /* type */
	 0,	                /* rightshift */
d790 3
a792 3
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d794 6
a799 6
	 0,		        /* special_function */
	 "R_TRLA",              /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d802 6
a807 6
  HOWTO (R_RRTBI,                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d809 6
a814 6
	 0,		        /* special_function */
	 "R_RRTBI",             /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d817 6
a822 6
  HOWTO (R_RRTBA,                /* type */
	 1,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d824 6
a829 6
	 0,		        /* special_function */
	 "R_RRTBA",             /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d832 2
a833 2
  HOWTO (R_CAI,	                /* type */
	 0,	                /* rightshift */
d835 3
a837 3
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d839 6
a844 6
	 0,		        /* special_function */
	 "R_CAI",               /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d847 2
a848 2
  HOWTO (R_CREL,                /* type */
	 0,	                /* rightshift */
d850 3
a852 3
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d854 6
a859 6
	 0,		        /* special_function */
	 "R_CREL",              /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d862 6
a867 6
  HOWTO (R_RBA,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d869 3
a871 3
	 0,		        /* special_function */
	 "R_RBA",               /* name */
	 true,	                /* partial_inplace */
d874 1
a874 1
	 false),                /* pcrel_offset */
d877 6
a882 6
  HOWTO (R_RBAC,                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d884 3
a886 3
	 0,		        /* special_function */
	 "R_RBAC",              /* name */
	 true,	                /* partial_inplace */
d889 1
a889 1
	 false),                /* pcrel_offset */
d892 6
a897 6
  HOWTO (R_RBR,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d899 3
a901 3
	 0,		        /* special_function */
	 "R_RBR_26",            /* name */
	 true,	                /* partial_inplace */
d904 1
a904 1
	 false),                /* pcrel_offset */
d907 2
a908 2
  HOWTO (R_RBRC,                /* type */
	 0,	                /* rightshift */
d910 3
a912 3
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d914 6
a919 6
	 0,		        /* special_function */
	 "R_RBRC",              /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d922 6
a927 6
  HOWTO (R_BA,	                /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d929 6
a934 6
	 0,		        /* special_function */
	 "R_BA_16",             /* name */
	 true,	                /* partial_inplace */
	 0xfffc,	        /* src_mask */
	 0xfffc,        	/* dst_mask */
	 false),                /* pcrel_offset */
d937 6
a942 6
  HOWTO (R_RBR,	                /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d944 6
a949 6
	 0,		        /* special_function */
	 "R_RBR_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d952 6
a957 6
  HOWTO (R_RBA,	                /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
d959 6
a964 6
	 0,		        /* special_function */
	 "R_RBA_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */
d978 1
a978 1
  
d982 1
a982 1
      if (R_BA == internal->r_type) 
d984 1
a984 1
      else if (R_RBR == internal->r_type) 
d986 1
a986 1
      else if (R_RBA == internal->r_type) 
d989 1
a989 1
  
d1001 3
a1003 2
  relent->addend = (internal->r_size & 0x80) ? - internal->r_vaddr 
    : internal->r_vaddr;
d1652 1
a1652 1
  memcpy ((void *) (d), buff20, 12) 
d1660 1
a1660 1
  memcpy ((void *) (d), buff20, 4) 
d1709 1
a1709 1
      if (bfd_bread (buffer, remaining, in_bfd) != remaining 
d1717 1
a1717 1
static boolean 
d1759 1
a1759 1
  
d1804 3
a1806 3
  /* Write out the symbol table.  
     Layout : 
     
d1808 15
a1822 15
     0x0000                   ar_size   [0x14]
     0x0014                   ar_nxtmem [0x14]
     0x0028                   ar_prvmem [0x14]
     0x003C                   ar_date   [0x0C]
     0x0048                   ar_uid    [0x0C]
     0x0054                   ar_gid    [0x0C]
     0x0060                   ar_mod    [0x0C]
     0x006C                   ar_namelen[0x04]
     0x0070                   ar_fmag   [SXCOFFARFMAG]
     
     Symbol table 
     0x0072                   num_syms  [0x08], binary
     0x0078                   offsets   [0x08 * num_syms], binary
     0x0086 + 0x08 * num_syms names     [??]
     ??                       pad to even bytes.
d1825 1
a1825 1
  if (sym_32) 
d1832 1
a1832 1
      bfd_vma symbol_table_size = 
d1835 2
a1836 2
	+ 8 
	+ 8 * sym_32 
d1845 1
a1845 1
	
d1847 1
a1847 1
	
d1866 1
a1866 1
      
d1925 1
a1925 1
  else 
d1927 2
a1928 2
  
  if (sym_64) 
d1935 1
a1935 1
      bfd_vma symbol_table_size = 
d1938 2
a1939 2
	+ 8 
	+ 8 * sym_64 
d1964 1
a1964 1
      
d2022 1
a2022 1
  else 
d2024 1
a2024 1
  
d2140 1
a2140 1
         after the name as well.  */
d2175 1
a2175 1
      
d2188 3
a2190 3
  sprintf (ahdr.size, "%ld", (long) (XCOFFARMAG_ELEMENT_SIZE + 
				     count * XCOFFARMAG_ELEMENT_SIZE + 
				     total_namlen));
d2230 1
a2230 1
      if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE, 
d2298 1
a2298 1
  
d2302 2
a2303 2
  for (current_bfd = abfd->archive_head, count = 0, total_namlen = 0; 
       current_bfd != NULL; 
d2324 2
a2325 2
  for (current_bfd = abfd->archive_head, i = 0; 
       current_bfd != NULL; 
d2347 1
a2347 1
	     32-bit machines).  
d2376 1
a2376 1
         after the name as well.  */
d2391 1
a2391 1
				      SIZEOF_AR_HDR_BIG + namlen 
d2405 1
a2405 1
	  || (bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, 
d2413 2
a2414 2
  	return false;
  
d2425 2
a2426 2
  /* Write out the member table.  
     Layout : 
d2429 15
a2443 15
     0x0000                   ar_size   [0x14]
     0x0014                   ar_nxtmem [0x14]
     0x0028                   ar_prvmem [0x14]
     0x003C                   ar_date   [0x0C]
     0x0048                   ar_uid    [0x0C]
     0x0054                   ar_gid    [0x0C]
     0x0060                   ar_mod    [0x0C]
     0x006C                   ar_namelen[0x04]
     0x0070                   ar_fmag   [0x02]

     Member table 
     0x0072                   count     [0x14]
     0x0086                   offsets   [0x14 * counts]
     0x0086 + 0x14 * counts   names     [??]
     ??                       pad to even bytes.
d2462 4
a2465 4
  PRINT20 (hdr->size, (XCOFFARMAGBIG_ELEMENT_SIZE + 
		       count * XCOFFARMAGBIG_ELEMENT_SIZE + 
		       total_namlen + (total_namlen & 1)));
  if (makemap && hasobjects) 
d2475 1
a2475 1
  
d2488 1
a2488 1
  if (count) 
d2494 1
a2494 1
  for (current_bfd = abfd->archive_head; current_bfd != NULL; 
d2501 1
a2501 1
      namlen = sprintf(mt, "%s", name);
d2504 1
a2504 1
  
d2518 1
a2518 1
  if (! makemap || ! hasobjects) 
d2526 1
a2526 1
      
d2535 1
a2535 1
      || (bfd_bwrite ((PTR) &fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR_BIG, 
d2538 1
a2538 1
  
d2733 2
a2734 2
boolean 
xcoff_reloc_type_noop (input_bfd, input_section, output_bfd, rel, sym, howto, 
d2750 2
a2751 2
boolean 
xcoff_reloc_type_fail (input_bfd, input_section, output_bfd, rel, sym, howto, 
d2771 2
a2772 2
boolean 
xcoff_reloc_type_pos (input_bfd, input_section, output_bfd, rel, sym, howto, 
d2789 2
a2790 2
boolean 
xcoff_reloc_type_neg (input_bfd, input_section, output_bfd, rel, sym, howto, 
d2807 2
a2808 2
boolean 
xcoff_reloc_type_rel (input_bfd, input_section, output_bfd, rel, sym, howto, 
d2827 2
a2828 2
  *relocation -= (input_section->output_section->vma + 
		  input_section->output_offset);
d2832 2
a2833 2
boolean 
xcoff_reloc_type_toc (input_bfd, input_section, output_bfd, rel, sym, howto, 
d2848 1
a2848 1
  if (0 > rel->r_symndx) 
d2864 1
a2864 1
      
d2869 3
a2871 3
  
  *relocation = ((val - xcoff_data (output_bfd)->toc) - 
		 (sym->n_value - xcoff_data (input_bfd)->toc));
d2875 2
a2876 2
boolean 
xcoff_reloc_type_ba (input_bfd, input_section, output_bfd, rel, sym, howto, 
d2897 2
a2898 2
static boolean 
xcoff_reloc_type_br (input_bfd, input_section, output_bfd, rel, sym, howto, 
d2913 1
a2913 1
  if (0 > rel->r_symndx) 
d2925 4
a2928 4
  if (NULL != h 
      && bfd_link_hash_defined == h->root.type 
      && (rel->r_vaddr - input_section->vma + 8 <= 
	  input_section->_cooked_size)) 
d2932 1
a2932 1
      
d2935 1
a2935 1
      
d2940 13
a2952 12
	  if (next == 0x4def7b82                        /* cror 15,15,15 */
	      || next == 0x4ffffb82                     /* cror 31,31,31 */
	      || next == 0x60000000)	                /* ori r0,r0,0 */
	    bfd_put_32 (input_bfd, 0x80410014, pnext);  /* lwz r1,20(r1) */
	  
	} else 
	  {
	    if (next == 0x80410014)		         /* lwz r1,20(r1) */
	      bfd_put_32 (input_bfd, 0x60000000, pnext); /* ori r0,r0,0 */
	  }
    } 
  else if (NULL != h && bfd_link_hash_undefined == h->root.type) 
d2956 1
a2956 1
	 is greater than 2^25, the linker will return an invalid error 
d2958 1
a2958 1
	 truncated but no it not important.  For this case, disable the 
d2960 1
a2960 1
      
d2963 1
a2963 1
  
d2970 1
a2970 1
  
d2972 2
a2973 2
  *relocation -= (input_section->output_section->vma + 
		  input_section->output_offset);
d2977 2
a2978 2
boolean 
xcoff_reloc_type_crel (input_bfd, input_section, output_bfd, rel, sym, howto, 
d2999 2
a3000 2
  *relocation -= (input_section->output_section->vma + 
		  input_section->output_offset);
d3004 2
a3005 2
static boolean 
xcoff_complain_overflow_dont_func (input_bfd, val, relocation, howto) 
d3014 2
a3015 2
static boolean 
xcoff_complain_overflow_bitfield_func (input_bfd, val, relocation, howto) 
d3019 1
a3019 1
     struct reloc_howto_struct *howto; 
d3023 1
a3023 1
  
d3039 1
a3039 1
  
d3051 1
a3051 1
		  
d3065 1
a3065 1
  
d3067 1
a3067 1
  
d3076 1
a3076 1
  
d3086 1
a3086 1
  
d3090 2
a3091 2
static boolean 
xcoff_complain_overflow_signed_func (input_bfd, val, relocation, howto) 
d3099 1
a3099 1
  
d3110 1
a3110 1
  
d3118 1
a3118 1
  
d3131 1
a3131 1
  
d3133 1
a3133 1
  
d3136 1
a3136 1
  
d3148 1
a3148 1
  
d3152 2
a3153 2
static boolean 
xcoff_complain_overflow_unsigned_func (input_bfd, val, relocation, howto) 
d3157 1
a3157 1
     struct reloc_howto_struct *howto; 
d3161 1
a3161 1
  
d3187 1
a3187 1
  
d3193 1
a3193 1
   will never change.  
d3199 1
a3199 1
   between the documents are noted below. 
d3201 1
a3201 1
   Unsupported r_type's 
d3206 1
a3206 1
	
d3211 1
a3211 1
   not defined by the PowerOpen ABI. 
d3219 1
a3219 1
   Simple negative relocation. 
d3237 1
a3237 1
   is the address of the entry in the TOC section. 
d3241 1
a3241 1
   difference between this and case R_GL. 
d3246 1
a3246 1
   FIXME: We don't currently implement this optimization. 
d3256 1
a3256 1
   two bits of the instruction. 
d3261 2
a3262 2
   ABI does not define this relocation type. 
   
d3265 1
a3265 1
   relative branch. 
d3271 1
a3271 1
   relocation type. 
d3276 1
a3276 1
   The PowerOpen ABI does not define this relocation type. 
d3280 1
a3280 1
   two bits of the instruction. 
d3285 1
a3285 1
   ABI does not define this relocation type. 
d3291 1
a3291 1
   XMC_XO. 
d3296 1
a3296 1
   is the same as case R_POS. 
d3301 1
a3301 1
   this is the same as R_POS. 
d3336 2
a3337 2
         merely used to prevent garbage collection from occurring for
         the csect including the symbol which it references.  */
d3348 3
a3350 2
      howto.complain_on_overflow = rel->r_size & 0x80 ? 
	complain_overflow_signed : complain_overflow_bitfield;
d3354 1
a3354 1
      howto.src_mask = howto.dst_mask = N_ONES(howto.bitsize);
d3362 1
a3362 1
      symndx = rel->r_symndx;      
d3364 1
a3364 1
      if (-1 != symndx)	
d3367 1
a3367 1
	  
d3371 2
a3372 2
	  
	  if (NULL == h) 
d3385 2
a3386 2
	    } 
	  else 
d3388 2
a3389 2
	      if (h->root.type == bfd_link_hash_defined 
		  || h->root.type == bfd_link_hash_defweak) 
d3395 2
a3396 2
		} 
	      else if (h->root.type == bfd_link_hash_common) 
d3401 4
a3404 4
		  
		} 
	      else if ((0 == (h->flags & (XCOFF_DEF_DYNAMIC | XCOFF_IMPORT))) 
		       && ! info->relocateable) 
d3410 1
a3410 1
		  
d3418 4
a3421 4
      if (rel->r_type >= XCOFF_MAX_CALCULATE_RELOCATION 
	  || (false == xcoff_calculate_relocation[rel->r_type]
	      (input_bfd, input_section, output_bfd, rel, sym, &howto, val, 
	       addend, &relocation, contents))) 
d3423 1
a3423 1
      
d3427 1
a3427 1
      
d3429 1
a3429 1
	abort();
d3434 1
a3434 1
      else 
d3436 3
a3438 3
      
      /* overflow.  
	 
a3442 4
      
      if ((unsigned int) howto.complain_on_overflow >= 
	  XCOFF_MAX_COMPLAIN_OVERFLOW)
	abort();
d3444 6
a3449 2
      if ((true == xcoff_complain_overflow[howto.complain_on_overflow]
	   (input_bfd, value_to_relocate, relocation, &howto))) 
d3454 2
a3455 2
	  
	  if (symndx == -1) 
d3458 2
a3459 2
	    } 
	  else if (h != NULL) 
d3462 2
a3463 2
	    } 
	  else 
d3470 1
a3470 1
	  
d3476 1
a3476 1
      
d3478 4
a3481 4
      value_to_relocate = ((value_to_relocate & ~howto.dst_mask) | 
			   (((value_to_relocate & howto.src_mask) + 
			     relocation) & howto.dst_mask));
      
d3485 1
a3485 1
      else 
d3582 2
a3583 2
  if ((19 >= aux->x_csect.x_smclas) &&
      (NULL != names[aux->x_csect.x_smclas]))
d3626 1
a3626 1
  return bfd_xcoff_ldhdrsz(abfd);
d3634 1
a3634 2
  return bfd_xcoff_ldhdrsz(abfd) +
    (ldhdr->l_nsyms * bfd_xcoff_ldsymsz(abfd));
d3637 1
a3637 1
static boolean 
d3659 1
a3659 1
  
d3663 1
a3663 1
  
d3674 1
a3674 1
  filehdr.f_nscns = 1; 
d3695 18
a3712 18
  /* .data 
     0x0000           0x00000000 : rtl
     0x0004           0x00000010 : offset to init, or 0
     0x0008           0x00000028 : offset to fini, or 0
     0x000C           0x0000000C : size of descriptor 
     0x0010           0x00000000 : init, needs a reloc
     0x0014           0x00000040 : offset to init name
     0x0018           0x00000000 : flags, padded to a word
     0x001C           0x00000000 : empty init
     0x0020           0x00000000 : 
     0x0024           0x00000000 : 
     0x0028           0x00000000 : fini, needs a reloc
     0x002C           0x00000??? : offset to fini name
     0x0030           0x00000000 : flags, padded to a word
     0x0034           0x00000000 : empty fini
     0x0038           0x00000000 : 
     0x003C           0x00000000 : 
     0x0040           init name
d3722 1
a3722 1
  if (initsz) 
d3731 1
a3731 1
  if (finisz) 
d3747 1
a3747 1
  if (initsz > 9) 
d3762 2
a3763 2
  
  /* symbols 
d3766 2
a3767 2
     4. init function 
     6. fini function 
d3782 1
a3782 1
  bfd_coff_swap_sym_out (abfd, &syment, 
d3784 2
a3785 2
  bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0, 
			 syment.n_numaux, 
d3798 1
a3798 1
  bfd_coff_swap_sym_out (abfd, &syment, 
d3800 2
a3801 2
  bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0, 
			 syment.n_numaux, 
d3806 1
a3806 1
  if (initsz) 
d3811 1
a3811 1
      if (initsz > 9) 
d3822 1
a3822 1
      bfd_coff_swap_sym_out (abfd, &syment, 
d3824 2
a3825 2
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0, 
			     syment.n_numaux, 
d3839 1
a3839 1
  
d3841 1
a3841 1
  if (finisz) 
d3846 1
a3846 1
      if (finisz > 9) 
d3857 1
a3857 1
      bfd_coff_swap_sym_out (abfd, &syment, 
d3859 2
a3860 2
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0, 
			     syment.n_numaux, 
d3869 1
a3869 1
      bfd_coff_swap_reloc_out (abfd, &reloc, 
d3883 1
a3883 1
      bfd_coff_swap_sym_out (abfd, &syment, 
d3885 2
a3886 2
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0, 
			     syment.n_numaux, 
d3895 1
a3895 1
      bfd_coff_swap_reloc_out (abfd, &reloc, 
d3922 6
a3927 6
HOWTO (0,	                /* type */
       0,	                /* rightshift */
       2,	                /* size (0 = byte, 1 = short, 2 = long) */
       32,	                /* bitsize */
       false,	                /* pc_relative */
       0,	                /* bitpos */
d3929 6
a3934 6
       0,		        /* special_function */
       "R_POS",               /* name */
       true,	                /* partial_inplace */
       0xffffffff,            /* src_mask */
       0xffffffff,            /* dst_mask */
       false);                /* pcrel_offset */
d3958 47
a4004 47
      _bfd_xcoff_swap_aux_in,           /* _bfd_coff_swap_aux_in */
      _bfd_xcoff_swap_sym_in,           /* _bfd_coff_swap_sym_in */
      coff_swap_lineno_in,              /* _bfd_coff_swap_lineno_in */
      _bfd_xcoff_swap_aux_out,          /* _bfd_swap_aux_out */
      _bfd_xcoff_swap_sym_out,          /* _bfd_swap_sym_out */
      coff_swap_lineno_out,             /* _bfd_swap_lineno_out */
      xcoff_swap_reloc_out,             /* _bfd_swap_reloc_out */
      coff_swap_filehdr_out,            /* _bfd_swap_filehdr_out */
      coff_swap_aouthdr_out,            /* _bfd_swap_aouthdr_out */
      coff_swap_scnhdr_out,             /* _bfd_swap_scnhdr_out */
      FILHSZ,                           /* _bfd_filhsz */
      AOUTSZ,                           /* _bfd_aoutsz */
      SCNHSZ,                           /* _bfd_scnhsz */
      SYMESZ,                           /* _bfd_symesz */
      AUXESZ,                           /* _bfd_auxesz */
      RELSZ,                            /* _bfd_relsz */
      LINESZ,                           /* _bfd_linesz */
      FILNMLEN,                         /* _bfd_filnmlen */
      true,                             /* _bfd_coff_long_filenames */
      false,                            /* _bfd_coff_long_section_names */
      (3),                              /* _bfd_coff_default_section_alignment_power */
      false,                            /* _bfd_coff_force_symnames_in_strings */
      2,                                /* _bfd_coff_debug_string_prefix_length */
      coff_swap_filehdr_in,             /* _bfd_coff_swap_filehdr_in */
      coff_swap_aouthdr_in,             /* _bfd_swap_aouthdr_in */
      coff_swap_scnhdr_in,              /* _bfd_swap_scnhdr_in */
      xcoff_swap_reloc_in,              /* _bfd_reloc_in */
      coff_bad_format_hook,             /* _bfd_bad_format_hook */
      coff_set_arch_mach_hook,          /* _bfd_set_arch_mach_hook */
      coff_mkobject_hook,               /* _bfd_mkobject_hook */
      styp_to_sec_flags,                /* _bfd_syp_to_sec_flags */
      coff_set_alignment_hook,          /* _bfd_set_alignment_hook */
      coff_slurp_symbol_table,          /* _bfd_coff_slurp_symbol_table */
      symname_in_debug_hook,            /* _coff_symname_in_debug_hook */
      coff_pointerize_aux_hook,         /* _bfd_coff_pointerize_aux_hook */
      coff_print_aux,                   /* bfd_coff_print_aux */
      dummy_reloc16_extra_cases,        /* _bfd_coff_reloc16_extra_cases */
      dummy_reloc16_estimate,           /* _bfd_coff_reloc16_estimate */
      NULL,                             /* bfd_coff_sym_is_global */
      coff_compute_section_file_positions, /* _bfd_coff_compute_section_file_positions */
      NULL,                             /* _bfd_coff_start_final_link */
      xcoff_ppc_relocate_section,       /* _bfd_coff_relocate_section */
      coff_rtype_to_howto,              /* _bfd_coff_rtype_to_howto */
      NULL,                             /* _bfd_coff_addust_symndx */
      _bfd_generic_link_add_one_symbol, /* _bfd_coff_add_one_symbol */
      coff_link_output_has_begun,       /* _bfd_coff_link_output_has_begun */
      coff_final_link_postscript        /* _bfd_coff_final_link_postscript */
d4007 3
a4009 3
    0x01DF,                             /* magic number */
    bfd_arch_rs6000,                    /* architecture */
    bfd_mach_rs6k,                      /* machine */
d4012 6
a4017 6
    xcoff_swap_ldhdr_in,                /* _xcoff_swap_ldhdr_in */
    xcoff_swap_ldhdr_out,               /* _xcoff_swap_ldhdr_out */
    xcoff_swap_ldsym_in,                /* _xcoff_swap_ldsym_in */
    xcoff_swap_ldsym_out,               /* _xcoff_swap_ldsym_out */
    xcoff_swap_ldrel_in,                /* _xcoff_swap_ldrel_in */
    xcoff_swap_ldrel_out,               /* _xcoff_swap_ldrel_out */
d4020 13
a4032 13
    LDHDRSZ,                            /* _xcoff_ldhdrsz */
    LDSYMSZ,                            /* _xcoff_ldsymsz */
    LDRELSZ,                            /* _xcoff_ldrelsz */
    12,                                 /* _xcoff_function_descriptor_size */
    SMALL_AOUTSZ,                       /* _xcoff_small_aout_header_size */

  /* Versions. */
    1,                                   /* _xcoff_ldhdr_version */

    _bfd_xcoff_put_symbol_name,          /* _xcoff_put_symbol_name */
    _bfd_xcoff_put_ldsymbol_name,        /* _xcoff_put_ldsymbol_name */
    & xcoff_dynamic_reloc,               /* dynamic reloc howto */
    xcoff_create_csect_from_smclas,      /* _xcoff_create_csect_from_smclas */
d4042 2
a4043 2
    & xcoff_glink_code[0],
    (36),           /* _xcoff_glink_size */
d4046 3
a4048 3
    64,           /* _xcoff_rtinit_size */
    xcoff_generate_rtinit,  /* _xcoff_generate_rtinit */
};
d4052 56
a4107 43
{
  "aixcoff-rs6000",
  bfd_target_xcoff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG | DYNAMIC |
   HAS_SYMS | HAS_LOCALS | WP_TEXT),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
  0,				/* leading char */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen??? FIXMEmgo */

                      /* data */
  bfd_getb64,         /* bfd_getx64 */
  bfd_getb_signed_64, /* bfd_getx_signed_64 */
  bfd_putb64,         /* bfd_putx64 */
  bfd_getb32,         /* bfd_getx32 */
  bfd_getb_signed_32, /* bfd_getx_signed_32 */
  bfd_putb32,         /* bfd_putx32 */
  bfd_getb16,         /* bfd_getx16 */
  bfd_getb_signed_16, /* bfd_getx_signed_16 */
  bfd_putb16,         /* bfd_putx16 */

                      /* hdrs */
  bfd_getb64,         /* bfd_h_getx64 */
  bfd_getb_signed_64, /* bfd_h_getx_signed_64 */
  bfd_putb64,         /* bfd_h_putx64 */
  bfd_getb32,         /* bfd_h_getx32 */
  bfd_getb_signed_32, /* bfd_h_getx_signed_32 */
  bfd_putb32,         /* bfd_h_putx32 */
  bfd_getb16,         /* bfd_h_getx16 */
  bfd_getb_signed_16, /* bfd_h_getx_signed_16 */
  bfd_putb16,         /* bfd_h_putx16 */

  { /* bfd_check_format */
    _bfd_dummy_target,
    coff_object_p,
    _bfd_xcoff_archive_p,
    CORE_FILE_P
  },
d4109 19
a4127 6
  { /* bfd_set_format */
    bfd_false,
    coff_mkobject,
    _bfd_generic_mkarchive,
    bfd_false
  },
d4129 2
a4130 1
  {/* bfd_write_contents */
d4132 50
a4181 91
    coff_write_object_contents,
    _bfd_xcoff_write_archive_contents,
    bfd_false
  },

  /* Generic */
  bfd_true,                          /* _close_and_cleanup */
  bfd_true,                          /* _bfd_free_cached_info */
  coff_new_section_hook,             /* _new_section_hook */
  _bfd_generic_get_section_contents, /* _bfd_get_section_contents */
                                     /* _bfd_get_section_contents_in_window */
  _bfd_generic_get_section_contents_in_window,

  /* Copy */
  _bfd_xcoff_copy_private_bfd_data, /* _bfd_copy_private_bfd */
                                    /* _bfd_merge_private_bfd_data */
  ((boolean (*) (bfd *, bfd *)) bfd_true),
                                    /* _bfd_copy_pivate_section_data */
  ((boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
                                    /* _bfd_copy_private_symbol_data */
  ((boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
  ((boolean (*) (bfd *, flagword)) bfd_true), /* _bfd_set_private_flags */
  ((boolean (*) (bfd *, void * )) bfd_true),  /* _bfd_print_private_bfd_data */

  /* Core */
  coff_core_file_failing_command,    /* _core_file_failing_command */
  coff_core_file_failing_signal,     /* _core_file_failing_signal */
                                          /* _core_file_matches_executable_p */
  coff_core_file_matches_executable_p,

  /* Archive */
  _bfd_xcoff_slurp_armap,                  /* _slurp_armap */
                                           /* XCOFF archives do not have
					      anything which corresponds to
					      an extended name table.  */
  bfd_false,                               /* _slurp_extended_name_table */
                                           /* _construct_extended_name_table */
  ((boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
  bfd_dont_truncate_arname,                /* _truncate_arname */
  _bfd_xcoff_write_armap,                  /* _write_armap */
  _bfd_xcoff_read_ar_hdr,                  /* _read_ar_hdr */
  _bfd_xcoff_openr_next_archived_file,     /* _openr_next_archived_file */
  _bfd_generic_get_elt_at_index,           /* _get_elt_at_index */
  _bfd_xcoff_stat_arch_elt,                /* _generic_stat_arch_elt */
                                           /* XCOFF archives do not have
					      a timestamp.  */
  bfd_true,                                /* _update_armap_timestamp */

  /* Symbols */
  coff_get_symtab_upper_bound,             /* _get_symtab_upper_bound */
  coff_get_symtab,                         /* _get_symtab */
  coff_make_empty_symbol,                  /* _make_empty_symbol */
  coff_print_symbol,                       /* _print_symbol */
  coff_get_symbol_info,                    /* _get_symbol_info */
  _bfd_xcoff_is_local_label_name,          /* _bfd_is_local_label_name */
  coff_get_lineno,                         /* _get_lineno */
  coff_find_nearest_line,                  /* _find_nearest_line */
  coff_bfd_make_debug_symbol,              /* _bfd_make_debug_symbol */
  _bfd_generic_read_minisymbols,           /* _read_minisymbols */
  _bfd_generic_minisymbol_to_symbol,       /* _minsymbol_to_symbol */

  /* Reloc */
  coff_get_reloc_upper_bound,              /* _get_reloc_upper_bound */
  coff_canonicalize_reloc,                 /* _cononicalize_reloc */
  _bfd_xcoff_reloc_type_lookup,            /* _bfd_reloc_type_lookup */

  /* Write */
  coff_set_arch_mach,                      /* _set_arch_mach */
  coff_set_section_contents,               /* _set_section_contents */

  /* Link */
  _bfd_xcoff_sizeof_headers,               /* _sizeof_headers */
                                      /* _bfd_get_relocated_section_contents */
  bfd_generic_get_relocated_section_contents,
  bfd_generic_relax_section,               /* _bfd_relax_section */
  _bfd_xcoff_bfd_link_hash_table_create,   /* _bfd_link_hash_table_create */
  _bfd_generic_link_hash_table_free,       /* _bfd_link_hash_table_free */
  _bfd_xcoff_bfd_link_add_symbols,         /* _bfd_link_add_symbols */
  _bfd_generic_link_just_syms,             /* _bfd_link_just_syms */
  _bfd_xcoff_bfd_final_link,               /* _bfd_final_link */
  _bfd_generic_link_split_section,         /* _bfd_link_split_section */
  bfd_generic_gc_sections,                 /* _bfd_gc_sections */
  bfd_generic_merge_sections,              /* _bfd_merge_sections */
  bfd_generic_discard_group,               /* _bfd_discard_group */

  /* Dynamic */
                                          /* _get_dynamic_symtab_upper_bound */
  _bfd_xcoff_get_dynamic_symtab_upper_bound,
  _bfd_xcoff_canonicalize_dynamic_symtab,  /* _cononicalize_dynamic_symtab */
  _bfd_xcoff_get_dynamic_reloc_upper_bound,/* _get_dynamic_reloc_upper_bound */
  _bfd_xcoff_canonicalize_dynamic_reloc,   /* _cononicalize_dynamic_reloc */
d4183 2
a4184 2
  /* Opposite endian version, none exists */
  NULL,
d4186 2
a4187 3
  /* back end data */
  (void *) &bfd_xcoff_backend_data,
};
d4189 8
a4196 10
/*
 * xcoff-powermac target
 * Old target.
 * Only difference between this target and the rs6000 target is the
 * the default architecture and machine type used in coffcode.h
 *
 * PowerPC Macs use the same magic numbers as RS/6000
 * (because that's how they were bootstrapped originally),
 * but they are always PowerPC architecture.
 */
d4198 93
a4290 97
{
  { /* COFF backend, defined in libcoff.h */
    _bfd_xcoff_swap_aux_in,           /* _bfd_coff_swap_aux_in */
    _bfd_xcoff_swap_sym_in,           /* _bfd_coff_swap_sym_in */
    coff_swap_lineno_in,              /* _bfd_coff_swap_lineno_in */
    _bfd_xcoff_swap_aux_out,          /* _bfd_swap_aux_out */
    _bfd_xcoff_swap_sym_out,          /* _bfd_swap_sym_out */
    coff_swap_lineno_out,             /* _bfd_swap_lineno_out */
    xcoff_swap_reloc_out,             /* _bfd_swap_reloc_out */
    coff_swap_filehdr_out,            /* _bfd_swap_filehdr_out */
    coff_swap_aouthdr_out,            /* _bfd_swap_aouthdr_out */
    coff_swap_scnhdr_out,             /* _bfd_swap_scnhdr_out */
    FILHSZ,                           /* _bfd_filhsz */
    AOUTSZ,                           /* _bfd_aoutsz */
    SCNHSZ,                           /* _bfd_scnhsz */
    SYMESZ,                           /* _bfd_symesz */
    AUXESZ,                           /* _bfd_auxesz */
    RELSZ,                            /* _bfd_relsz */
    LINESZ,                           /* _bfd_linesz */
    FILNMLEN,                         /* _bfd_filnmlen */
    true,                             /* _bfd_coff_long_filenames */
    false,                            /* _bfd_coff_long_section_names */
    (3),                        /* _bfd_coff_default_section_alignment_power */
    false,                            /* _bfd_coff_force_symnames_in_strings */
    2,                               /* _bfd_coff_debug_string_prefix_length */
    coff_swap_filehdr_in,             /* _bfd_coff_swap_filehdr_in */
    coff_swap_aouthdr_in,             /* _bfd_swap_aouthdr_in */
    coff_swap_scnhdr_in,              /* _bfd_swap_scnhdr_in */
    xcoff_swap_reloc_in,              /* _bfd_reloc_in */
    coff_bad_format_hook,             /* _bfd_bad_format_hook */
    coff_set_arch_mach_hook,          /* _bfd_set_arch_mach_hook */
    coff_mkobject_hook,               /* _bfd_mkobject_hook */
    styp_to_sec_flags,                /* _bfd_syp_to_sec_flags */
    coff_set_alignment_hook,          /* _bfd_set_alignment_hook */
    coff_slurp_symbol_table,          /* _bfd_coff_slurp_symbol_table */
    symname_in_debug_hook,            /* _coff_symname_in_debug_hook */
    coff_pointerize_aux_hook,         /* _bfd_coff_pointerize_aux_hook */
    coff_print_aux,                   /* bfd_coff_print_aux */
    dummy_reloc16_extra_cases,        /* _bfd_coff_reloc16_extra_cases */
    dummy_reloc16_estimate,           /* _bfd_coff_reloc16_estimate */
    NULL,                             /* bfd_coff_sym_is_global */
                                 /* _bfd_coff_compute_section_file_positions */
    coff_compute_section_file_positions,
    NULL,                             /* _bfd_coff_start_final_link */
    xcoff_ppc_relocate_section,       /* _bfd_coff_relocate_section */
    coff_rtype_to_howto,              /* _bfd_coff_rtype_to_howto */
    NULL,                             /* _bfd_coff_addust_symndx */
    _bfd_generic_link_add_one_symbol, /* _bfd_coff_add_one_symbol */
    coff_link_output_has_begun,       /* _bfd_coff_link_output_has_begun */
    coff_final_link_postscript        /* _bfd_coff_final_link_postscript */
  },

  0x01DF,                             /* magic number */
  bfd_arch_powerpc,                   /* architecture */
  bfd_mach_ppc,                       /* machine */

  /* function pointers to xcoff specific swap routines */
  xcoff_swap_ldhdr_in,                /* _xcoff_swap_ldhdr_in */
  xcoff_swap_ldhdr_out,               /* _xcoff_swap_ldhdr_out */
  xcoff_swap_ldsym_in,                /* _xcoff_swap_ldsym_in */
  xcoff_swap_ldsym_out,               /* _xcoff_swap_ldsym_out */
  xcoff_swap_ldrel_in,                /* _xcoff_swap_ldrel_in */
  xcoff_swap_ldrel_out,               /* _xcoff_swap_ldrel_out */

  /* sizes */
  LDHDRSZ,                            /* _xcoff_ldhdrsz */
  LDSYMSZ,                            /* _xcoff_ldsymsz */
  LDRELSZ,                            /* _xcoff_ldrelsz */
  12,                                 /* _xcoff_function_descriptor_size */
  SMALL_AOUTSZ,                       /* _xcoff_small_aout_header_size */

  /* versions */
  1,                                    /* _xcoff_ldhdr_version */

  /* xcoff vs xcoff64 putting symbol names */
  _bfd_xcoff_put_symbol_name,          /* _xcoff_put_symbol_name */
  _bfd_xcoff_put_ldsymbol_name,          /* _xcoff_put_ldsymbol_name */

  &xcoff_dynamic_reloc,                  /* dynamic reloc howto */

  xcoff_create_csect_from_smclas,      /* _xcoff_create_csect_from_smclas */

  /* lineno and reloc count overflow */
  xcoff_is_lineno_count_overflow,
  xcoff_is_reloc_count_overflow,

  xcoff_loader_symbol_offset,
  xcoff_loader_reloc_offset,

  /* glink */
  &xcoff_glink_code[0],
  (36),           /* _xcoff_glink_size */

  /* rtinit */
  0,           /* _xcoff_rtinit_size */
  xcoff_generate_rtinit,  /* _xcoff_generate_rtinit */
};
d4292 1
a4292 1
/* The transfer vector that leads the outside world to all of the above. */
d4294 56
a4349 43
{
  "xcoff-powermac",
  bfd_target_xcoff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG | DYNAMIC |
   HAS_SYMS | HAS_LOCALS | WP_TEXT),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
  0,				/* leading char */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen??? FIXMEmgo */

                      /* data */
  bfd_getb64,         /* bfd_getx64 */
  bfd_getb_signed_64, /* bfd_getx_signed_64 */
  bfd_putb64,         /* bfd_putx64 */
  bfd_getb32,         /* bfd_getx32 */
  bfd_getb_signed_32, /* bfd_getx_signed_32 */
  bfd_putb32,         /* bfd_putx32 */
  bfd_getb16,         /* bfd_getx16 */
  bfd_getb_signed_16, /* bfd_getx_signed_16 */
  bfd_putb16,         /* bfd_putx16 */

                      /* hdrs */
  bfd_getb64,         /* bfd_h_getx64 */
  bfd_getb_signed_64, /* bfd_h_getx_signed_64 */
  bfd_putb64,         /* bfd_h_putx64 */
  bfd_getb32,         /* bfd_h_getx32 */
  bfd_getb_signed_32, /* bfd_h_getx_signed_32 */
  bfd_putb32,         /* bfd_h_putx32 */
  bfd_getb16,         /* bfd_h_getx16 */
  bfd_getb_signed_16, /* bfd_h_getx_signed_16 */
  bfd_putb16,         /* bfd_h_putx16 */

  { /* bfd_check_format */
    _bfd_dummy_target,
    coff_object_p,
    _bfd_xcoff_archive_p,
    CORE_FILE_P
  },
d4351 19
a4369 6
  { /* bfd_set_format */
    bfd_false,
    coff_mkobject,
    _bfd_generic_mkarchive,
    bfd_false
  },
d4371 2
a4372 1
  {/* bfd_write_contents */
d4374 50
a4423 91
    coff_write_object_contents,
    _bfd_xcoff_write_archive_contents,
    bfd_false
  },

  /* Generic */
  bfd_true,                          /* _close_and_cleanup */
  bfd_true,                          /* _bfd_free_cached_info */
  coff_new_section_hook,             /* _new_section_hook */
  _bfd_generic_get_section_contents, /* _bfd_get_section_contents */
                                     /* _bfd_get_section_contents_in_window */
  _bfd_generic_get_section_contents_in_window,

  /* Copy */
  _bfd_xcoff_copy_private_bfd_data, /* _bfd_copy_private_bfd */
                                    /* _bfd_merge_private_bfd_data */
  ((boolean (*) (bfd *, bfd *)) bfd_true),
                                    /* _bfd_copy_pivate_section_data */
  ((boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
                                    /* _bfd_copy_private_symbol_data */
  ((boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
  ((boolean (*) (bfd *, flagword)) bfd_true), /* _bfd_set_private_flags */
  ((boolean (*) (bfd *, void * )) bfd_true),  /* _bfd_print_private_bfd_data */

  /* Core */
  coff_core_file_failing_command,    /* _core_file_failing_command */
  coff_core_file_failing_signal,     /* _core_file_failing_signal */
                                          /* _core_file_matches_executable_p */
  coff_core_file_matches_executable_p,

  /* Archive */
  _bfd_xcoff_slurp_armap,                  /* _slurp_armap */
                                           /* XCOFF archives do not have
					      anything which corresponds to
					      an extended name table.  */
  bfd_false,                               /* _slurp_extended_name_table */
                                           /* _construct_extended_name_table */
  ((boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
  bfd_dont_truncate_arname,                /* _truncate_arname */
  _bfd_xcoff_write_armap,                  /* _write_armap */
  _bfd_xcoff_read_ar_hdr,                  /* _read_ar_hdr */
  _bfd_xcoff_openr_next_archived_file,     /* _openr_next_archived_file */
  _bfd_generic_get_elt_at_index,           /* _get_elt_at_index */
  _bfd_xcoff_stat_arch_elt,                /* _generic_stat_arch_elt */
                                           /* XCOFF archives do not have
					      a timestamp.  */
  bfd_true,                                /* _update_armap_timestamp */

  /* Symbols */
  coff_get_symtab_upper_bound,             /* _get_symtab_upper_bound */
  coff_get_symtab,                         /* _get_symtab */
  coff_make_empty_symbol,                  /* _make_empty_symbol */
  coff_print_symbol,                       /* _print_symbol */
  coff_get_symbol_info,                    /* _get_symbol_info */
  _bfd_xcoff_is_local_label_name,          /* _bfd_is_local_label_name */
  coff_get_lineno,                         /* _get_lineno */
  coff_find_nearest_line,                  /* _find_nearest_line */
  coff_bfd_make_debug_symbol,              /* _bfd_make_debug_symbol */
  _bfd_generic_read_minisymbols,           /* _read_minisymbols */
  _bfd_generic_minisymbol_to_symbol,       /* _minsymbol_to_symbol */

  /* Reloc */
  coff_get_reloc_upper_bound,              /* _get_reloc_upper_bound */
  coff_canonicalize_reloc,                 /* _cononicalize_reloc */
  _bfd_xcoff_reloc_type_lookup,            /* _bfd_reloc_type_lookup */

  /* Write */
  coff_set_arch_mach,                      /* _set_arch_mach */
  coff_set_section_contents,               /* _set_section_contents */

  /* Link */
  _bfd_xcoff_sizeof_headers,               /* _sizeof_headers */
                                      /* _bfd_get_relocated_section_contents */
  bfd_generic_get_relocated_section_contents,
  bfd_generic_relax_section,               /* _bfd_relax_section */
  _bfd_xcoff_bfd_link_hash_table_create,   /* _bfd_link_hash_table_create */
  _bfd_generic_link_hash_table_free,       /* _bfd_link_hash_table_free */
  _bfd_xcoff_bfd_link_add_symbols,         /* _bfd_link_add_symbols */
  _bfd_generic_link_just_syms,             /* _bfd_link_just_syms */
  _bfd_xcoff_bfd_final_link,               /* _bfd_final_link */
  _bfd_generic_link_split_section,         /* _bfd_link_split_section */
  bfd_generic_gc_sections,                 /* _bfd_gc_sections */
  bfd_generic_merge_sections,              /* _bfd_merge_sections */
  bfd_generic_discard_group,               /* _bfd_discard_group */

  /* Dynamic */
                                          /* _get_dynamic_symtab_upper_bound */
  _bfd_xcoff_get_dynamic_symtab_upper_bound,
  _bfd_xcoff_canonicalize_dynamic_symtab,  /* _cononicalize_dynamic_symtab */
  _bfd_xcoff_get_dynamic_reloc_upper_bound,/* _get_dynamic_reloc_upper_bound */
  _bfd_xcoff_canonicalize_dynamic_reloc,   /* _cononicalize_dynamic_reloc */
d4425 2
a4426 2
  /* Opposite endian version, none exists */
  NULL,
d4428 2
a4429 3
  /* back end data */
  (void *) &bfd_pmac_xcoff_backend_data,
};
@


1.47
log
@	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.
@
text
@d591 1
a591 1
	 0,			/* src_mask */
d606 1
a606 1
	 0,			/* src_mask */
d621 1
a621 1
	 0,			/* src_mask */
d636 1
a636 1
	 0,			/* src_mask */
d651 1
a651 1
	 0,			/* src_mask */
d666 1
a666 1
	 0,			/* src_mask */
d681 1
a681 1
	 0,			/* src_mask */
d698 1
a698 1
	 0xfc000003,		/* src_mask */
d715 1
a715 1
	 0xfc000003,		/* src_mask */
d732 1
a732 1
	 0,			/* src_mask */
d747 1
a747 1
	 0,			/* src_mask */
d782 1
a782 1
	 0,			/* src_mask */
d797 1
a797 1
	 0,			/* src_mask */
d812 1
a812 1
	 0,			/* src_mask */
d827 1
a827 1
	 0,			/* src_mask */
d842 1
a842 1
	 0,			/* src_mask */
d857 1
a857 1
	 0,			/* src_mask */
d872 1
a872 1
	 0xfc000003,		/* src_mask */
d887 1
a887 1
	 0,			/* src_mask */
d902 1
a902 1
	 0xfc000003,		/* src_mask */
d917 1
a917 1
	 0,			/* src_mask */
d932 1
a932 1
	 0x0003,		/* src_mask */
d947 1
a947 1
	 0,			/* src_mask */
d962 1
a962 1
	 0,			/* src_mask */
d2888 2
a2889 2
  howto->src_mask |= 3;
  howto->dst_mask &= ~3;
d2963 2
a2964 2
  howto->src_mask |= 3;
  howto->dst_mask &= ~3;
d2990 2
a2991 2
  howto->src_mask |= 3;
  howto->dst_mask &= ~3;
d3351 1
a3351 2
      howto.dst_mask = N_ONES (howto.bitsize);
      howto.src_mask = ~howto.dst_mask & N_ONES (8 << howto.size);
@


1.46
log
@	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.
@
text
@d591 1
a591 1
	 0xffffffff,            /* src_mask */
d606 1
a606 1
	 0xffffffff,            /* src_mask */
d621 1
a621 1
	 0xffffffff,            /* src_mask */
d636 1
a636 1
	 0xffff,	        /* src_mask */
d651 1
a651 1
	 0xffffffff,	        /* src_mask */
d658 1
a658 1
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
d666 1
a666 1
	 0xffff,	        /* src_mask */
d673 1
a673 1
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
d681 1
a681 1
	 0xffff,	        /* src_mask */
d698 2
a699 2
	 0x3fffffc,	        /* src_mask */
	 0x3fffffc,        	/* dst_mask */
d715 2
a716 2
	 0x3fffffc,	        /* src_mask */
	 0x3fffffc,        	/* dst_mask */
d724 1
a724 1
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
d732 1
a732 1
	 0xffff,	        /* src_mask */
d739 1
a739 1
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
d747 1
a747 1
	 0xffff,	        /* src_mask */
d760 1
a760 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d774 1
a774 1
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
d782 1
a782 1
	 0xffff,	        /* src_mask */
d789 1
a789 1
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
d797 1
a797 1
	 0xffff,	        /* src_mask */
d812 1
a812 1
	 0xffffffff,	        /* src_mask */
d827 1
a827 1
	 0xffffffff,	        /* src_mask */
d834 1
a834 1
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
d842 1
a842 1
	 0xffff,	        /* src_mask */
d849 1
a849 1
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
d857 1
a857 1
	 0xffff,	        /* src_mask */
d872 2
a873 2
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d887 2
a888 2
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d902 2
a903 2
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
d909 1
a909 1
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
d917 1
a917 1
	 0xffff,	        /* src_mask */
d932 1
a932 1
	 0xfffc,	        /* src_mask */
d947 1
a947 1
	 0xffff,	        /* src_mask */
d962 1
a962 1
	 0xffff,	        /* src_mask */
d2888 2
a2889 2
  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;
d2963 2
a2964 2
  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;
d2990 2
a2991 2
  howto->src_mask &= ~3;
  howto->dst_mask = howto->src_mask;
d3351 2
a3352 1
      howto.src_mask = howto.dst_mask = N_ONES(howto.bitsize);
@


1.45
log
@	* coff-rs6000.c (xcoff_generate_rtinit): Fix typo.
@
text
@d1246 1
d1248 1
a1248 1
  bfd_size_type amt;
d1250 1
a1250 1
  if (bfd_bread ((PTR) magic, (bfd_size_type) SXCOFFARMAG, abfd) != SXCOFFARMAG)
d1264 2
a1265 3
  /* We are setting bfd_ardata(abfd) here, but since bfd_ardata
     involves a cast, we can't do it as the left operand of
     assignment.  */
d1267 1
a1267 1
  abfd->tdata.aout_ar_data = (struct artdata *) bfd_zalloc (abfd, amt);
d1269 1
a1269 1
    return NULL;
d1286 2
a1287 3
      if (bfd_bread ((PTR) &hdr.memoff,
		    (bfd_size_type) SIZEOF_AR_FILE_HDR - SXCOFFARMAG, abfd)
	  != SIZEOF_AR_FILE_HDR - SXCOFFARMAG)
d1291 1
a1291 1
	  return NULL;
d1300 1
a1300 1
	return NULL;
d1313 2
a1314 3
      if (bfd_bread ((PTR) &hdr.memoff,
		    (bfd_size_type) SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG, abfd)
	  != SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG)
d1318 1
a1318 1
	  return NULL;
d1321 3
a1323 5
      /* XXX This actually has to be a call to strtoll (at least on 32-bit
	 machines) since the field width is 20 and there numbers with more
	 than 32 bits can be represented.  */
      bfd_ardata (abfd)->first_file_filepos = strtol (hdr.firstmemoff,
						      (char **) NULL, 10);
d1328 1
a1328 1
	return NULL;
d1335 1
d1337 2
a1338 1
      abfd->tdata.aout_ar_data = (struct artdata *) NULL;
@


1.45.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d170 1
a170 1
  PARAMS ((XCOFF_RELOC_FUNCTION_ARGS)) =
d203 1
a203 1
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS)) =
d658 1
a658 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d673 1
a673 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d698 2
a699 2
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
d724 1
a724 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d739 1
a739 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d760 1
a760 1
	 complain_overflow_dont, /* complain_on_overflow */
d774 1
a774 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d789 1
a789 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d834 1
a834 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d849 1
a849 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d872 2
a873 2
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
d887 2
a888 2
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
d902 2
a903 2
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
d909 1
a909 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d999 4
a1245 1
  struct artdata *tdata_hold;
d1247 1
a1247 1
  bfd_size_type amt = SXCOFFARMAG;
d1249 1
a1249 1
  if (bfd_bread ((PTR) magic, amt, abfd) != amt)
d1263 3
a1265 2
  tdata_hold = bfd_ardata (abfd);

d1267 1
a1267 1
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
d1269 1
a1269 1
    goto error_ret_restore;
d1286 3
a1288 2
      amt = SIZEOF_AR_FILE_HDR - SXCOFFARMAG;
      if (bfd_bread ((PTR) &hdr.memoff, amt, abfd) != amt)
d1292 1
a1292 1
	  goto error_ret;
d1301 1
a1301 1
	goto error_ret;
d1314 3
a1316 2
      amt = SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG;
      if (bfd_bread ((PTR) &hdr.memoff, amt, abfd) != amt)
d1320 1
a1320 1
	  goto error_ret;
d1323 5
a1327 3
      bfd_ardata (abfd)->first_file_filepos = bfd_scan_vma (hdr.firstmemoff,
							    (const char **) 0,
							    10);
d1332 1
a1332 1
	goto error_ret;
a1338 1
    error_ret:
d1340 1
a1340 2
    error_ret_restore:
      bfd_ardata (abfd) = tdata_hold;
d2189 3
a2191 3
  sprintf (ahdr.size, "%ld", (long) (XCOFFARMAG_ELEMENT_SIZE
				     + count * XCOFFARMAG_ELEMENT_SIZE
				     + total_namlen));
d2463 3
a2465 3
  PRINT20 (hdr->size, (XCOFFARMAGBIG_ELEMENT_SIZE
		       + count * XCOFFARMAGBIG_ELEMENT_SIZE
		       + total_namlen + (total_namlen & 1)));
d2828 2
a2829 2
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
d2871 2
a2872 2
  *relocation = ((val - xcoff_data (output_bfd)->toc)
		 - (sym->n_value - xcoff_data (input_bfd)->toc));
d2928 2
a2929 2
      && (rel->r_vaddr - input_section->vma + 8
	  <= input_section->_cooked_size))
d2946 1
a2946 2
	}
      else
d2972 2
a2973 2
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
d2999 2
a3000 2
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
d3348 2
a3349 3
      howto.complain_on_overflow = (rel->r_size & 0x80
				    ? complain_overflow_signed
				    : complain_overflow_bitfield);
d3418 1
a3418 1
	  || !((*xcoff_calculate_relocation[rel->r_type])
d3443 2
a3444 2
      if ((unsigned int) howto.complain_on_overflow
	  >= XCOFF_MAX_COMPLAIN_OVERFLOW)
d3447 1
a3447 1
      if (((*xcoff_complain_overflow[howto.complain_on_overflow])
d3477 3
a3479 3
      value_to_relocate = ((value_to_relocate & ~howto.dst_mask)
			   | (((value_to_relocate & howto.src_mask)
			       + relocation) & howto.dst_mask));
d3581 2
a3582 2
  if ((19 >= aux->x_csect.x_smclas)
      && (NULL != names[aux->x_csect.x_smclas]))
d3633 2
a3634 1
  return bfd_xcoff_ldhdrsz (abfd) + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (abfd);
d3958 18
a3975 18
      _bfd_xcoff_swap_aux_in,
      _bfd_xcoff_swap_sym_in,
      coff_swap_lineno_in,
      _bfd_xcoff_swap_aux_out,
      _bfd_xcoff_swap_sym_out,
      coff_swap_lineno_out,
      xcoff_swap_reloc_out,
      coff_swap_filehdr_out,
      coff_swap_aouthdr_out,
      coff_swap_scnhdr_out,
      FILHSZ,
      AOUTSZ,
      SCNHSZ,
      SYMESZ,
      AUXESZ,
      RELSZ,
      LINESZ,
      FILNMLEN,
d3978 1
a3978 1
      3,			/* _bfd_coff_default_section_alignment_power */
d3981 15
a3995 15
      coff_swap_filehdr_in,
      coff_swap_aouthdr_in,
      coff_swap_scnhdr_in,
      xcoff_swap_reloc_in,
      coff_bad_format_hook,
      coff_set_arch_mach_hook,
      coff_mkobject_hook,
      styp_to_sec_flags,
      coff_set_alignment_hook,
      coff_slurp_symbol_table,
      symname_in_debug_hook,
      coff_pointerize_aux_hook,
      coff_print_aux,
      dummy_reloc16_extra_cases,
      dummy_reloc16_estimate,
d3997 1
a3997 1
      coff_compute_section_file_positions,
d3999 6
a4004 6
      xcoff_ppc_relocate_section,
      coff_rtype_to_howto,
      NULL,			/* _bfd_coff_adjust_symndx */
      _bfd_generic_link_add_one_symbol,
      coff_link_output_has_begun,
      coff_final_link_postscript
d4008 2
a4009 2
    bfd_arch_rs6000,
    bfd_mach_rs6k,
d4012 6
a4017 6
    xcoff_swap_ldhdr_in,
    xcoff_swap_ldhdr_out,
    xcoff_swap_ldsym_in,
    xcoff_swap_ldsym_out,
    xcoff_swap_ldrel_in,
    xcoff_swap_ldrel_out,
d4020 3
a4022 3
    LDHDRSZ,
    LDSYMSZ,
    LDRELSZ,
d4024 1
a4024 1
    SMALL_AOUTSZ,
d4029 4
a4032 4
    _bfd_xcoff_put_symbol_name,
    _bfd_xcoff_put_ldsymbol_name,
    &xcoff_dynamic_reloc,
    xcoff_create_csect_from_smclas,
d4043 1
a4043 1
    36,				/* _xcoff_glink_size */
d4047 1
a4047 1
    xcoff_generate_rtinit,
d4058 3
a4060 2
    (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | DYNAMIC
     | HAS_SYMS | HAS_LOCALS | WP_TEXT),
d4062 1
a4062 1
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
d4065 1
a4065 1
    15,				/* ar_max_namelen */
d4068 9
a4076 9
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,
d4079 9
a4087 9
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,
d4111 5
a4115 4
    bfd_true,
    bfd_true,
    coff_new_section_hook,
    _bfd_generic_get_section_contents,
d4119 2
a4120 1
    _bfd_xcoff_copy_private_bfd_data,
d4122 1
d4124 1
d4126 2
a4127 2
    ((boolean (*) (bfd *, flagword)) bfd_true),
    ((boolean (*) (bfd *, void * )) bfd_true),
d4130 3
a4132 2
    coff_core_file_failing_command,
    coff_core_file_failing_signal,
d4136 6
a4141 2
    _bfd_xcoff_slurp_armap,
    bfd_false,
d4143 9
a4151 7
    bfd_dont_truncate_arname,
    _bfd_xcoff_write_armap,
    _bfd_xcoff_read_ar_hdr,
    _bfd_xcoff_openr_next_archived_file,
    _bfd_generic_get_elt_at_index,
    _bfd_xcoff_stat_arch_elt,
    bfd_true,
d4154 11
a4164 11
    coff_get_symtab_upper_bound,
    coff_get_symtab,
    coff_make_empty_symbol,
    coff_print_symbol,
    coff_get_symbol_info,
    _bfd_xcoff_is_local_label_name,
    coff_get_lineno,
    coff_find_nearest_line,
    coff_bfd_make_debug_symbol,
    _bfd_generic_read_minisymbols,
    _bfd_generic_minisymbol_to_symbol,
d4167 3
a4169 3
    coff_get_reloc_upper_bound,
    coff_canonicalize_reloc,
    _bfd_xcoff_reloc_type_lookup,
d4172 2
a4173 2
    coff_set_arch_mach,
    coff_set_section_contents,
d4176 2
a4177 1
    _bfd_xcoff_sizeof_headers,
d4179 10
a4188 10
    bfd_generic_relax_section,
    _bfd_xcoff_bfd_link_hash_table_create,
    _bfd_generic_link_hash_table_free,
    _bfd_xcoff_bfd_link_add_symbols,
    _bfd_generic_link_just_syms,
    _bfd_xcoff_bfd_final_link,
    _bfd_generic_link_split_section,
    bfd_generic_gc_sections,
    bfd_generic_merge_sections,
    bfd_generic_discard_group,
d4191 1
d4193 3
a4195 3
    _bfd_xcoff_canonicalize_dynamic_symtab,
    _bfd_xcoff_get_dynamic_reloc_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_reloc,
d4200 1
d4204 10
a4213 8
/* xcoff-powermac target
   Old target.
   Only difference between this target and the rs6000 target is the
   the default architecture and machine type used in coffcode.h

   PowerPC Macs use the same magic numbers as RS/6000
   (because that's how they were bootstrapped originally),
   but they are always PowerPC architecture.  */
d4216 19
a4234 19
    { /* COFF backend, defined in libcoff.h.  */
      _bfd_xcoff_swap_aux_in,
      _bfd_xcoff_swap_sym_in,
      coff_swap_lineno_in,
      _bfd_xcoff_swap_aux_out,
      _bfd_xcoff_swap_sym_out,
      coff_swap_lineno_out,
      xcoff_swap_reloc_out,
      coff_swap_filehdr_out,
      coff_swap_aouthdr_out,
      coff_swap_scnhdr_out,
      FILHSZ,
      AOUTSZ,
      SCNHSZ,
      SYMESZ,
      AUXESZ,
      RELSZ,
      LINESZ,
      FILNMLEN,
d4237 1
a4237 1
      3,			/* _bfd_coff_default_section_alignment_power */
d4240 15
a4254 15
      coff_swap_filehdr_in,
      coff_swap_aouthdr_in,
      coff_swap_scnhdr_in,
      xcoff_swap_reloc_in,
      coff_bad_format_hook,
      coff_set_arch_mach_hook,
      coff_mkobject_hook,
      styp_to_sec_flags,
      coff_set_alignment_hook,
      coff_slurp_symbol_table,
      symname_in_debug_hook,
      coff_pointerize_aux_hook,
      coff_print_aux,
      dummy_reloc16_extra_cases,
      dummy_reloc16_estimate,
d4256 1
d4259 6
a4264 6
      xcoff_ppc_relocate_section,
      coff_rtype_to_howto,
      NULL,			/* _bfd_coff_adjust_symndx */
      _bfd_generic_link_add_one_symbol,
      coff_link_output_has_begun,
      coff_final_link_postscript
d4268 2
a4269 2
    bfd_arch_powerpc,
    bfd_mach_ppc,
d4271 12
a4282 12
    /* Function pointers to xcoff specific swap routines.  */
    xcoff_swap_ldhdr_in,
    xcoff_swap_ldhdr_out,
    xcoff_swap_ldsym_in,
    xcoff_swap_ldsym_out,
    xcoff_swap_ldrel_in,
    xcoff_swap_ldrel_out,

    /* Sizes.  */
    LDHDRSZ,
    LDSYMSZ,
    LDRELSZ,
d4284 1
a4284 1
    SMALL_AOUTSZ,
d4286 1
a4286 1
    /* Versions.  */
d4289 3
a4291 4
    _bfd_xcoff_put_symbol_name,
    _bfd_xcoff_put_ldsymbol_name,
    &xcoff_dynamic_reloc,
    xcoff_create_csect_from_smclas,
d4293 5
a4297 1
    /* Lineno and reloc count overflow.  */
d4304 1
a4304 1
    /* glink.  */
d4306 1
a4306 1
    36,				/* _xcoff_glink_size */
d4310 1
a4310 1
    xcoff_generate_rtinit,
d4321 3
a4323 2
    (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | DYNAMIC
     | HAS_SYMS | HAS_LOCALS | WP_TEXT),
d4325 1
a4325 1
    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
d4328 1
a4328 1
    15,				/* ar_max_namelen */
d4331 9
a4339 9
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,
d4342 9
a4350 9
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,
d4374 5
a4378 4
    bfd_true,
    bfd_true,
    coff_new_section_hook,
    _bfd_generic_get_section_contents,
d4382 2
a4383 1
    _bfd_xcoff_copy_private_bfd_data,
d4385 1
d4387 1
d4389 2
a4390 2
    ((boolean (*) (bfd *, flagword)) bfd_true),
    ((boolean (*) (bfd *, void * )) bfd_true),
d4393 3
a4395 2
    coff_core_file_failing_command,
    coff_core_file_failing_signal,
d4399 6
a4404 2
    _bfd_xcoff_slurp_armap,
    bfd_false,
d4406 9
a4414 7
    bfd_dont_truncate_arname,
    _bfd_xcoff_write_armap,
    _bfd_xcoff_read_ar_hdr,
    _bfd_xcoff_openr_next_archived_file,
    _bfd_generic_get_elt_at_index,
    _bfd_xcoff_stat_arch_elt,
    bfd_true,
d4417 11
a4427 11
    coff_get_symtab_upper_bound,
    coff_get_symtab,
    coff_make_empty_symbol,
    coff_print_symbol,
    coff_get_symbol_info,
    _bfd_xcoff_is_local_label_name,
    coff_get_lineno,
    coff_find_nearest_line,
    coff_bfd_make_debug_symbol,
    _bfd_generic_read_minisymbols,
    _bfd_generic_minisymbol_to_symbol,
d4430 3
a4432 3
    coff_get_reloc_upper_bound,
    coff_canonicalize_reloc,
    _bfd_xcoff_reloc_type_lookup,
d4435 2
a4436 2
    coff_set_arch_mach,
    coff_set_section_contents,
d4439 2
a4440 1
    _bfd_xcoff_sizeof_headers,
d4442 10
a4451 10
    bfd_generic_relax_section,
    _bfd_xcoff_bfd_link_hash_table_create,
    _bfd_generic_link_hash_table_free,
    _bfd_xcoff_bfd_link_add_symbols,
    _bfd_generic_link_just_syms,
    _bfd_xcoff_bfd_final_link,
    _bfd_generic_link_split_section,
    bfd_generic_gc_sections,
    bfd_generic_merge_sections,
    bfd_generic_discard_group,
d4454 1
d4456 3
a4458 3
    _bfd_xcoff_canonicalize_dynamic_symtab,
    _bfd_xcoff_get_dynamic_reloc_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_reloc,
d4463 1
@


1.44
log
@Change text alignement to 4 bytes.
@
text
@d3755 1
a3755 1
      if (string_table_size == NULL)
@


1.43
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d240 1
a240 1
  /* xcoff_data (abfd)->text_align_power = 5; */
d281 2
a282 2
  ox->text_align_power = ix->text_align_power;
  ox->data_align_power = ix->data_align_power;
a1732 1
      BFD_ASSERT (2 < text_align_power);
@


1.42
log
@	* bfd-in.h: Remove "taken from the source" comment.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	* elf.c (bfd_elf_discard_group): Return true.
	* elf-bfd.h (bfd_elf_discard_group): Declare.
	* bfd-in.h (bfd_elf_discard_group): Don't declare here.
	* section.c (bfd_discard_group): Rename to bfd_generic_discard_group.
	* bfd.c (bfd_discard_group): Define.
	* targets.c (struct bfd_target): Add _bfd_discard_group.
	(BFD_JUMP_TABLE_LINK): Here too.
	* libbfd-in.h (_bfd_nolink_bfd_discard_group): Define.
	* aout-adobe.c (aout_32_bfd_discard_group): Define.
	* aout-target.h (MY_bfd_discard_group): Define.
	* aout-tic30.c (MY_bfd_discard_group): Define.
	* binary.c (binary_bfd_discard_group): Define.
	* bout.c (b_out_bfd_discard_group): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_discard_group): Define.
	* coffcode.h (coff_bfd_discard_group): Define.
	* coff-mips.c (_bfd_ecoff_bfd_discard_group): Define.
	* elfxx-target.h (bfd_elfNN_bfd_discard_group): Define.
	* i386msdos.c (msdos_bfd_discard_group): Define.
	* i386os9k.c (os9k_bfd_discard_group): Define.
	* ieee.c (ieee_bfd_discard_group): Define.
	* ihex.c (ihex_bfd_discard_group): Define.
	* mmo.c (mmo_bfd_discard_group): Define.
	* nlm-target.h (nlm_bfd_discard_group): Define.
	* oasys.c (oasys_bfd_discard_group): Define.
	* ppcboot.c (ppcboot_bfd_discard_group): Define.
	* som.c (som_bfd_discard_group): Define.
	* srec.c (srec_bfd_discard_group): Define.
	* tekhex.c (tekhex_bfd_discard_group): Define.
	* versados.c (versados_bfd_discard_group): Define.
	* vms.c (vms_bfd_discard_group): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_discard_group): Define.
	* coff64-rs6000.c (rs6000coff64_vec): Update initialiser.
	(aix5coff64_vec): Likewise.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
@
text
@d1842 1
a1842 1
      symbol_table = (bfd_byte *) bfd_malloc (symbol_table_size);
a1844 1
      memset (symbol_table, 0, symbol_table_size);
d1945 1
a1945 1
      symbol_table = (bfd_byte *) bfd_malloc (symbol_table_size);
a1947 1
      memset (symbol_table, 0, symbol_table_size);
d2458 1
a2458 1
  member_table = (bfd_byte *) bfd_malloc (member_table_size);
a2460 1
  memset (member_table, 0, member_table_size);
d3719 1
a3719 1
  data_buffer = (bfd_byte *) bfd_malloc (data_buffer_size);
a3721 2
  
  memset (data_buffer, 0, data_buffer_size);
d3755 4
a3758 2
      string_table = (bfd_byte *)bfd_malloc (string_table_size);
      memset (string_table, 0, string_table_size);
@


1.41
log
@Add 16 bit R_RBA.
@
text
@d4192 1
d4454 2
a4455 1
  bfd_generic_merge_sections,               /* _bfd_merge_sections */
@


1.40
log
@Fix ld --just-symbols
	* aix5ppc-core.c: Warning fixes.
	* aout-adobe.c (aout_32_bfd_link_just_syms): Define.
	* aout-target.h (MY_bfd_link_just_syms): Define.
	* aout-tic30.c (MY_bfd_link_just_syms): Define.
	* bfd.c (bfd_link_just_syms): Define.
	* binary.c (binary_bfd_link_just_syms): Define.
	* bout.c (b_out_bfd_link_just_syms): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update initializer.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_just_syms): Define.
	* elf-bfd.h (enum elf_link_info_type): Add ELF_INFO_TYPE_JUST_SYMS.
	(elf_discarded_section): Check for ELF_INFO_TYPE_JUST_SYMS.
	(_bfd_elf_link_just_syms): Declare.
	* elf.c (_bfd_elf_link_just_syms): New function.
	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Check that
	sections haven't already been discarded by the linker.
	* elflink.h (elf_link_add_object_symbols): Likewise for stab
	sections and SEC_MERGE sections.
	(elf_bfd_discard_info): Similarly here.
	* elfxx-target.h (bfd_elfNN_bfd_link_just_syms): Define.
	* i386msdos.c (msdos_bfd_link_just_syms): Define.
	* i386os9k.c (os9k_bfd_link_just_syms): Define.
	* ieee.c (ieee_bfd_link_just_syms): Define.
	* ihex.c (ihex_bfd_link_just_syms): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_just_syms): Define.
	(_bfd_generic_link_just_syms): Declare.
	* libecoff.h (_bfd_ecoff_bfd_link_just_syms): Define.
	* linker.c (_bfd_generic_link_just_syms): New function.
	* mmo.c (mmo_bfd_link_just_syms): Define.
	* nlm-target.h (nlm_bfd_link_just_syms): Define.
	* oasys.c (oasys_bfd_link_just_syms): Define.
	* ppcboot.c (ppcboot_bfd_link_just_syms): Define.
	* som.c (som_bfd_link_just_syms): Define.
	* srec.c (srec_bfd_link_just_syms): Define.
	* targets.c (struct bfd_target): Add _bfd_link_just_syms.
	(BFD_JUMP_TABLE_LINK): And here.
	* tekhex.c (tekhex_bfd_link_just_syms): Define.
	* versados.c (versados_bfd_link_just_syms): Define.
	* vms.c (vms_bfd_link_just_syms): Define.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d951 15
d986 2
@


1.40.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d240 1
a240 1
  bfd_xcoff_text_align_power (abfd) = 2;
d281 2
a282 2
  bfd_xcoff_text_align_power (obfd) = bfd_xcoff_text_align_power (ibfd);
  bfd_xcoff_data_align_power (obfd) = bfd_xcoff_data_align_power (ibfd);
a950 15
  /* Modifiable branch relative.  */
  HOWTO (R_RBA,	                /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RBA_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */

a970 2
      else if (R_RBA == internal->r_type) 
	relent->howto = &xcoff_howto_table[0x1e];
d1716 1
d1825 1
a1825 1
      symbol_table = (bfd_byte *) bfd_zmalloc (symbol_table_size);
d1828 1
d1929 1
a1929 1
      symbol_table = (bfd_byte *) bfd_zmalloc (symbol_table_size);
d1932 1
d2443 1
a2443 1
  member_table = (bfd_byte *) bfd_zmalloc (member_table_size);
d2446 1
d3705 1
a3705 1
  data_buffer = (bfd_byte *) bfd_zmalloc (data_buffer_size);
d3708 2
d3743 2
a3744 4
      string_table = (bfd_byte *) bfd_zmalloc (string_table_size);
      if (string_table_size == NULL)
	return false;

a4174 1
  bfd_generic_discard_group,               /* _bfd_discard_group */
d4436 1
a4436 2
  bfd_generic_merge_sections,              /* _bfd_merge_sections */
  bfd_generic_discard_group,               /* _bfd_discard_group */
@


1.40.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d3755 1
a3755 1
      if (string_table == NULL)
@


1.40.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d86 1
a86 1
extern boolean rs6000coff_core_file_matches_executable_p
d151 4
a154 4
static boolean xcoff_generate_rtinit
  PARAMS ((bfd *, const char *, const char *, boolean));
static boolean do_pad PARAMS ((bfd *, unsigned int));
static boolean do_copy PARAMS ((bfd *, bfd *));
d160 1
a160 1
static boolean xcoff_complain_overflow_dont_func
d170 1
a170 1
  PARAMS ((XCOFF_RELOC_FUNCTION_ARGS)) =
d172 4
a175 4
  xcoff_reloc_type_pos,	 /* R_POS   (0x00) */
  xcoff_reloc_type_neg,	 /* R_NEG   (0x01) */
  xcoff_reloc_type_rel,	 /* R_REL   (0x02) */
  xcoff_reloc_type_toc,	 /* R_TOC   (0x03) */
d177 10
a186 10
  xcoff_reloc_type_toc,	 /* R_GL    (0x05) */
  xcoff_reloc_type_toc,	 /* R_TCL   (0x06) */
  xcoff_reloc_type_fail, /*	    (0x07) */
  xcoff_reloc_type_ba,	 /* R_BA    (0x08) */
  xcoff_reloc_type_fail, /*	    (0x09) */
  xcoff_reloc_type_br,	 /* R_BR    (0x0a) */
  xcoff_reloc_type_fail, /*	    (0x0b) */
  xcoff_reloc_type_pos,	 /* R_RL    (0x0c) */
  xcoff_reloc_type_pos,	 /* R_RLA   (0x0d) */
  xcoff_reloc_type_fail, /*	    (0x0e) */
d188 4
a191 4
  xcoff_reloc_type_fail, /*	    (0x10) */
  xcoff_reloc_type_fail, /*	    (0x11) */
  xcoff_reloc_type_toc,	 /* R_TRL   (0x12) */
  xcoff_reloc_type_toc,	 /* R_TRLA  (0x13) */
d194 1
a194 1
  xcoff_reloc_type_ba,	 /* R_CAI   (0x16) */
d196 4
a199 4
  xcoff_reloc_type_ba,	 /* R_RBA   (0x18) */
  xcoff_reloc_type_ba,	 /* R_RBAC  (0x19) */
  xcoff_reloc_type_br,	 /* R_RBR   (0x1a) */
  xcoff_reloc_type_ba,	 /* R_RBRC  (0x1b) */
d203 1
a203 1
  PARAMS ((XCOFF_COMPLAIN_FUNCTION_ARGS)) =
d305 1
a305 1
     bfd *abfd;
d314 1
a314 1
      memcpy (in->_n._n_name, ext->e.e_name, SYMNMLEN);
d331 3
a333 3
     bfd *abfd;
     PTR inp;
     PTR extp;
d340 1
a340 1
      memcpy (ext->e.e_name, in->_n._n_name, SYMNMLEN);
d358 7
a364 7
     bfd *abfd;
     PTR ext1;
     int type;
     int class;
     int indx;
     int numaux;
     PTR in1;
d421 1
a421 1
	     safety.  */
d486 1
a486 1
  memset ((PTR)ext, 0, bfd_coff_auxesz (abfd));
d581 6
a586 6
  HOWTO (R_POS,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d588 6
a593 6
	 0,			/* special_function */
	 "R_POS",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d596 6
a601 6
  HOWTO (R_NEG,			/* type */
	 0,			/* rightshift */
	 -2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d603 6
a608 6
	 0,			/* special_function */
	 "R_NEG",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d611 6
a616 6
  HOWTO (R_REL,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
d618 6
a623 6
	 0,			/* special_function */
	 "R_REL",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d626 6
a631 6
  HOWTO (R_TOC,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d633 6
a638 6
	 0,			/* special_function */
	 "R_TOC",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d641 6
a646 6
  HOWTO (R_RTB,			/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d648 6
a653 6
	 0,			/* special_function */
	 "R_RTB",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d656 6
a661 6
  HOWTO (R_GL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d663 14
a676 14
	 0,			/* special_function */
	 "R_GL",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Local TOC relative symbol.	 */
  HOWTO (R_TCL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d678 6
a683 6
	 0,			/* special_function */
	 "R_TCL",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d688 6
a693 6
  HOWTO (R_BA,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d695 6
a700 6
	 0,			/* special_function */
	 "R_BA_26",		/* name */
	 true,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 false),		/* pcrel_offset */
d705 6
a710 6
  HOWTO (R_BR,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 true,			/* pc_relative */
	 0,			/* bitpos */
d712 6
a717 6
	 0,			/* special_function */
	 "R_BR",		/* name */
	 true,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 false),		/* pcrel_offset */
d722 6
a727 6
  HOWTO (R_RL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d729 6
a734 6
	 0,			/* special_function */
	 "R_RL",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d737 6
a742 6
  HOWTO (R_RLA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d744 6
a749 6
	 0,			/* special_function */
	 "R_RLA",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d754 13
a766 13
  HOWTO (R_REF,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "R_REF",		/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d772 6
a777 6
  HOWTO (R_TRL,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d779 6
a784 6
	 0,			/* special_function */
	 "R_TRL",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d787 6
a792 6
  HOWTO (R_TRLA,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d794 6
a799 6
	 0,			/* special_function */
	 "R_TRLA",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d802 6
a807 6
  HOWTO (R_RRTBI,		 /* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d809 6
a814 6
	 0,			/* special_function */
	 "R_RRTBI",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d817 6
a822 6
  HOWTO (R_RRTBA,		 /* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d824 6
a829 6
	 0,			/* special_function */
	 "R_RRTBA",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d832 6
a837 6
  HOWTO (R_CAI,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d839 6
a844 6
	 0,			/* special_function */
	 "R_CAI",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d847 6
a852 6
  HOWTO (R_CREL,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d854 6
a859 6
	 0,			/* special_function */
	 "R_CREL",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d862 6
a867 6
  HOWTO (R_RBA,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d869 6
a874 6
	 0,			/* special_function */
	 "R_RBA",		/* name */
	 true,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 false),		/* pcrel_offset */
d877 6
a882 6
  HOWTO (R_RBAC,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d884 6
a889 6
	 0,			/* special_function */
	 "R_RBAC",		/* name */
	 true,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d892 6
a897 6
  HOWTO (R_RBR,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d899 6
a904 6
	 0,			/* special_function */
	 "R_RBR_26",		/* name */
	 true,			/* partial_inplace */
	 0x03fffffc,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 false),		/* pcrel_offset */
d907 6
a912 6
  HOWTO (R_RBRC,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d914 6
a919 6
	 0,			/* special_function */
	 "R_RBRC",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d922 6
a927 6
  HOWTO (R_BA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d929 6
a934 6
	 0,			/* special_function */
	 "R_BA_16",		/* name */
	 true,			/* partial_inplace */
	 0xfffc,		/* src_mask */
	 0xfffc,		/* dst_mask */
	 false),		/* pcrel_offset */
d937 6
a942 6
  HOWTO (R_RBR,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d944 6
a949 6
	 0,			/* special_function */
	 "R_RBR_16",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d952 6
a957 6
  HOWTO (R_RBA,			/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
d959 6
a964 6
	 0,			/* special_function */
	 "R_RBA_16",		/* name */
	 true,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d978 1
a978 1

d982 1
a982 1
      if (R_BA == internal->r_type)
d984 1
a984 1
      else if (R_RBR == internal->r_type)
d986 1
a986 1
      else if (R_RBA == internal->r_type)
d989 1
a989 1

d999 4
a1245 1
  struct artdata *tdata_hold;
d1247 1
a1247 1
  bfd_size_type amt = SXCOFFARMAG;
d1249 1
a1249 1
  if (bfd_bread ((PTR) magic, amt, abfd) != amt)
d1263 3
a1265 2
  tdata_hold = bfd_ardata (abfd);

d1267 1
a1267 1
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
d1269 1
a1269 1
    goto error_ret_restore;
d1286 3
a1288 2
      amt = SIZEOF_AR_FILE_HDR - SXCOFFARMAG;
      if (bfd_bread ((PTR) &hdr.memoff, amt, abfd) != amt)
d1292 1
a1292 1
	  goto error_ret;
d1301 1
a1301 1
	goto error_ret;
d1314 3
a1316 2
      amt = SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG;
      if (bfd_bread ((PTR) &hdr.memoff, amt, abfd) != amt)
d1320 1
a1320 1
	  goto error_ret;
d1323 5
a1327 3
      bfd_ardata (abfd)->first_file_filepos = bfd_scan_vma (hdr.firstmemoff,
							    (const char **) 0,
							    10);
d1332 1
a1332 1
	goto error_ret;
a1338 1
    error_ret:
d1340 1
a1340 2
    error_ret_restore:
      bfd_ardata (abfd) = tdata_hold;
d1653 1
a1653 1
  memcpy ((void *) (d), buff20, 12)
d1661 1
a1661 1
  memcpy ((void *) (d), buff20, 4)
d1710 1
a1710 1
      if (bfd_bread (buffer, remaining, in_bfd) != remaining
d1718 1
a1718 1
static boolean
d1760 1
a1760 1

d1805 3
a1807 3
  /* Write out the symbol table.
     Layout :

d1809 15
a1823 15
     0x0000		      ar_size	[0x14]
     0x0014		      ar_nxtmem [0x14]
     0x0028		      ar_prvmem [0x14]
     0x003C		      ar_date	[0x0C]
     0x0048		      ar_uid	[0x0C]
     0x0054		      ar_gid	[0x0C]
     0x0060		      ar_mod	[0x0C]
     0x006C		      ar_namelen[0x04]
     0x0070		      ar_fmag	[SXCOFFARFMAG]

     Symbol table
     0x0072		      num_syms	[0x08], binary
     0x0078		      offsets	[0x08 * num_syms], binary
     0x0086 + 0x08 * num_syms names	[??]
     ??			      pad to even bytes.
d1826 1
a1826 1
  if (sym_32)
d1833 1
a1833 1
      bfd_vma symbol_table_size =
d1836 2
a1837 2
	+ 8
	+ 8 * sym_32
d1846 1
a1846 1

d1848 1
a1848 1

d1867 1
a1867 1

d1926 1
a1926 1
  else
d1928 2
a1929 2

  if (sym_64)
d1936 1
a1936 1
      bfd_vma symbol_table_size =
d1939 2
a1940 2
	+ 8
	+ 8 * sym_64
d1965 1
a1965 1

d2023 1
a2023 1
  else
d2025 1
a2025 1

d2141 1
a2141 1
	 after the name as well.  */
d2176 1
a2176 1

d2189 3
a2191 3
  sprintf (ahdr.size, "%ld", (long) (XCOFFARMAG_ELEMENT_SIZE
				     + count * XCOFFARMAG_ELEMENT_SIZE
				     + total_namlen));
d2231 1
a2231 1
      if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE,
d2299 1
a2299 1

d2303 2
a2304 2
  for (current_bfd = abfd->archive_head, count = 0, total_namlen = 0;
       current_bfd != NULL;
d2325 2
a2326 2
  for (current_bfd = abfd->archive_head, i = 0;
       current_bfd != NULL;
d2348 1
a2348 1
	     32-bit machines).
d2377 1
a2377 1
	 after the name as well.  */
d2392 1
a2392 1
				      SIZEOF_AR_HDR_BIG + namlen
d2406 1
a2406 1
	  || (bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG,
d2414 2
a2415 2
	return false;

d2426 2
a2427 2
  /* Write out the member table.
     Layout :
d2430 15
a2444 15
     0x0000		      ar_size	[0x14]
     0x0014		      ar_nxtmem [0x14]
     0x0028		      ar_prvmem [0x14]
     0x003C		      ar_date	[0x0C]
     0x0048		      ar_uid	[0x0C]
     0x0054		      ar_gid	[0x0C]
     0x0060		      ar_mod	[0x0C]
     0x006C		      ar_namelen[0x04]
     0x0070		      ar_fmag	[0x02]

     Member table
     0x0072		      count	[0x14]
     0x0086		      offsets	[0x14 * counts]
     0x0086 + 0x14 * counts   names	[??]
     ??			      pad to even bytes.
d2463 4
a2466 4
  PRINT20 (hdr->size, (XCOFFARMAGBIG_ELEMENT_SIZE
		       + count * XCOFFARMAGBIG_ELEMENT_SIZE
		       + total_namlen + (total_namlen & 1)));
  if (makemap && hasobjects)
d2476 1
a2476 1

d2489 1
a2489 1
  if (count)
d2495 1
a2495 1
  for (current_bfd = abfd->archive_head; current_bfd != NULL;
d2502 1
a2502 1
      namlen = sprintf (mt, "%s", name);
d2505 1
a2505 1

d2519 1
a2519 1
  if (! makemap || ! hasobjects)
d2527 1
a2527 1

d2536 1
a2536 1
      || (bfd_bwrite ((PTR) &fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR_BIG,
d2539 1
a2539 1

d2734 2
a2735 2
boolean
xcoff_reloc_type_noop (input_bfd, input_section, output_bfd, rel, sym, howto,
d2751 2
a2752 2
boolean
xcoff_reloc_type_fail (input_bfd, input_section, output_bfd, rel, sym, howto,
d2772 2
a2773 2
boolean
xcoff_reloc_type_pos (input_bfd, input_section, output_bfd, rel, sym, howto,
d2790 2
a2791 2
boolean
xcoff_reloc_type_neg (input_bfd, input_section, output_bfd, rel, sym, howto,
d2808 2
a2809 2
boolean
xcoff_reloc_type_rel (input_bfd, input_section, output_bfd, rel, sym, howto,
d2828 2
a2829 2
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
d2833 2
a2834 2
boolean
xcoff_reloc_type_toc (input_bfd, input_section, output_bfd, rel, sym, howto,
d2849 1
a2849 1
  if (0 > rel->r_symndx)
d2865 1
a2865 1

d2870 3
a2872 3

  *relocation = ((val - xcoff_data (output_bfd)->toc)
		 - (sym->n_value - xcoff_data (input_bfd)->toc));
d2876 2
a2877 2
boolean
xcoff_reloc_type_ba (input_bfd, input_section, output_bfd, rel, sym, howto,
d2898 2
a2899 2
static boolean
xcoff_reloc_type_br (input_bfd, input_section, output_bfd, rel, sym, howto,
d2914 1
a2914 1
  if (0 > rel->r_symndx)
d2926 4
a2929 4
  if (NULL != h
      && bfd_link_hash_defined == h->root.type
      && (rel->r_vaddr - input_section->vma + 8
	  <= input_section->_cooked_size))
d2933 1
a2933 1

d2936 1
a2936 1

d2941 12
a2952 13
	  if (next == 0x4def7b82			/* cror 15,15,15 */
	      || next == 0x4ffffb82			/* cror 31,31,31 */
	      || next == 0x60000000)			/* ori r0,r0,0 */
	    bfd_put_32 (input_bfd, 0x80410014, pnext);	/* lwz r1,20(r1) */

	}
      else
	{
	  if (next == 0x80410014)			/* lwz r1,20(r1) */
	    bfd_put_32 (input_bfd, 0x60000000, pnext);	/* ori r0,r0,0 */
	}
    }
  else if (NULL != h && bfd_link_hash_undefined == h->root.type)
d2956 1
a2956 1
	 is greater than 2^25, the linker will return an invalid error
d2958 1
a2958 1
	 truncated but no it not important.  For this case, disable the
d2960 1
a2960 1

d2963 1
a2963 1

d2970 1
a2970 1

d2972 2
a2973 2
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
d2977 2
a2978 2
boolean
xcoff_reloc_type_crel (input_bfd, input_section, output_bfd, rel, sym, howto,
d2999 2
a3000 2
  *relocation -= (input_section->output_section->vma
		  + input_section->output_offset);
d3004 2
a3005 2
static boolean
xcoff_complain_overflow_dont_func (input_bfd, val, relocation, howto)
d3014 2
a3015 2
static boolean
xcoff_complain_overflow_bitfield_func (input_bfd, val, relocation, howto)
d3019 1
a3019 1
     struct reloc_howto_struct *howto;
d3023 1
a3023 1

d3039 1
a3039 1

d3051 1
a3051 1

d3065 1
a3065 1

d3067 1
a3067 1

d3076 1
a3076 1

d3086 1
a3086 1

d3090 2
a3091 2
static boolean
xcoff_complain_overflow_signed_func (input_bfd, val, relocation, howto)
d3099 1
a3099 1

d3110 1
a3110 1

d3118 1
a3118 1

d3131 1
a3131 1

d3133 1
a3133 1

d3136 1
a3136 1

d3148 1
a3148 1

d3152 2
a3153 2
static boolean
xcoff_complain_overflow_unsigned_func (input_bfd, val, relocation, howto)
d3157 1
a3157 1
     struct reloc_howto_struct *howto;
d3161 1
a3161 1

d3187 1
a3187 1

d3193 1
a3193 1
   will never change.
d3199 1
a3199 1
   between the documents are noted below.
d3201 1
a3201 1
   Unsupported r_type's
d3206 1
a3206 1

d3211 1
a3211 1
   not defined by the PowerOpen ABI.
d3219 1
a3219 1
   Simple negative relocation.
d3237 1
a3237 1
   is the address of the entry in the TOC section.
d3241 1
a3241 1
   difference between this and case R_GL.
d3246 1
a3246 1
   FIXME: We don't currently implement this optimization.
d3256 1
a3256 1
   two bits of the instruction.
d3261 2
a3262 2
   ABI does not define this relocation type.

d3265 1
a3265 1
   relative branch.
d3271 1
a3271 1
   relocation type.
d3276 1
a3276 1
   The PowerOpen ABI does not define this relocation type.
d3280 1
a3280 1
   two bits of the instruction.
d3285 1
a3285 1
   ABI does not define this relocation type.
d3291 1
a3291 1
   XMC_XO.
d3296 1
a3296 1
   is the same as case R_POS.
d3301 1
a3301 1
   this is the same as R_POS.
d3336 2
a3337 2
	 merely used to prevent garbage collection from occurring for
	 the csect including the symbol which it references.  */
d3348 2
a3349 3
      howto.complain_on_overflow = (rel->r_size & 0x80
				    ? complain_overflow_signed
				    : complain_overflow_bitfield);
d3353 1
a3353 1
      howto.src_mask = howto.dst_mask = N_ONES (howto.bitsize);
d3361 1
a3361 1
      symndx = rel->r_symndx;
d3363 1
a3363 1
      if (-1 != symndx)
d3366 1
a3366 1

d3370 2
a3371 2

	  if (NULL == h)
d3384 2
a3385 2
	    }
	  else
d3387 2
a3388 2
	      if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
d3394 2
a3395 2
		}
	      else if (h->root.type == bfd_link_hash_common)
d3400 4
a3403 4

		}
	      else if ((0 == (h->flags & (XCOFF_DEF_DYNAMIC | XCOFF_IMPORT)))
		       && ! info->relocateable)
d3409 1
a3409 1

d3417 4
a3420 4
      if (rel->r_type >= XCOFF_MAX_CALCULATE_RELOCATION
	  || !((*xcoff_calculate_relocation[rel->r_type])
	       (input_bfd, input_section, output_bfd, rel, sym, &howto, val,
		addend, &relocation, contents)))
d3422 1
a3422 1

d3426 1
a3426 1

d3428 1
a3428 1
	abort ();
d3433 1
a3433 1
      else
d3435 3
a3437 3

      /* overflow.

d3442 4
d3447 2
a3448 6
      if ((unsigned int) howto.complain_on_overflow
	  >= XCOFF_MAX_COMPLAIN_OVERFLOW)
	abort ();

      if (((*xcoff_complain_overflow[howto.complain_on_overflow])
	   (input_bfd, value_to_relocate, relocation, &howto)))
d3453 2
a3454 2

	  if (symndx == -1)
d3457 2
a3458 2
	    }
	  else if (h != NULL)
d3461 2
a3462 2
	    }
	  else
d3469 1
a3469 1

d3475 1
a3475 1

d3477 4
a3480 4
      value_to_relocate = ((value_to_relocate & ~howto.dst_mask)
			   | (((value_to_relocate & howto.src_mask)
			       + relocation) & howto.dst_mask));

d3484 1
a3484 1
      else
d3581 2
a3582 2
  if ((19 >= aux->x_csect.x_smclas)
      && (NULL != names[aux->x_csect.x_smclas]))
d3625 1
a3625 1
  return bfd_xcoff_ldhdrsz (abfd);
d3633 2
a3634 1
  return bfd_xcoff_ldhdrsz (abfd) + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (abfd);
d3637 1
a3637 1
static boolean
d3659 1
a3659 1

d3663 1
a3663 1

d3674 1
a3674 1
  filehdr.f_nscns = 1;
d3695 18
a3712 18
  /* .data
     0x0000	      0x00000000 : rtl
     0x0004	      0x00000010 : offset to init, or 0
     0x0008	      0x00000028 : offset to fini, or 0
     0x000C	      0x0000000C : size of descriptor
     0x0010	      0x00000000 : init, needs a reloc
     0x0014	      0x00000040 : offset to init name
     0x0018	      0x00000000 : flags, padded to a word
     0x001C	      0x00000000 : empty init
     0x0020	      0x00000000 :
     0x0024	      0x00000000 :
     0x0028	      0x00000000 : fini, needs a reloc
     0x002C	      0x00000??? : offset to fini name
     0x0030	      0x00000000 : flags, padded to a word
     0x0034	      0x00000000 : empty fini
     0x0038	      0x00000000 :
     0x003C	      0x00000000 :
     0x0040	      init name
d3716 1
a3716 1
  data_buffer_size = (data_buffer_size + 7) &~ (bfd_size_type) 7;
d3722 1
a3722 1
  if (initsz)
d3731 1
a3731 1
  if (finisz)
d3747 1
a3747 1
  if (initsz > 9)
d3762 2
a3763 2

  /* symbols
d3766 2
a3767 2
     4. init function
     6. fini function
d3782 1
a3782 1
  bfd_coff_swap_sym_out (abfd, &syment,
d3784 2
a3785 2
  bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			 syment.n_numaux,
d3798 1
a3798 1
  bfd_coff_swap_sym_out (abfd, &syment,
d3800 2
a3801 2
  bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			 syment.n_numaux,
d3806 1
a3806 1
  if (initsz)
d3811 1
a3811 1
      if (initsz > 9)
d3822 1
a3822 1
      bfd_coff_swap_sym_out (abfd, &syment,
d3824 2
a3825 2
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
d3839 1
a3839 1

d3841 1
a3841 1
  if (finisz)
d3846 1
a3846 1
      if (finisz > 9)
d3857 1
a3857 1
      bfd_coff_swap_sym_out (abfd, &syment,
d3859 2
a3860 2
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
d3869 1
a3869 1
      bfd_coff_swap_reloc_out (abfd, &reloc,
d3883 1
a3883 1
      bfd_coff_swap_sym_out (abfd, &syment,
d3885 2
a3886 2
      bfd_coff_swap_aux_out (abfd, &auxent, syment.n_type, syment.n_sclass, 0,
			     syment.n_numaux,
d3895 1
a3895 1
      bfd_coff_swap_reloc_out (abfd, &reloc,
d3922 6
a3927 6
HOWTO (0,			/* type */
       0,			/* rightshift */
       2,			/* size (0 = byte, 1 = short, 2 = long) */
       32,			/* bitsize */
       false,			/* pc_relative */
       0,			/* bitpos */
d3929 6
a3934 6
       0,			/* special_function */
       "R_POS",			/* name */
       true,			/* partial_inplace */
       0xffffffff,		/* src_mask */
       0xffffffff,		/* dst_mask */
       false);			/* pcrel_offset */
d3958 47
a4004 47
      _bfd_xcoff_swap_aux_in,
      _bfd_xcoff_swap_sym_in,
      coff_swap_lineno_in,
      _bfd_xcoff_swap_aux_out,
      _bfd_xcoff_swap_sym_out,
      coff_swap_lineno_out,
      xcoff_swap_reloc_out,
      coff_swap_filehdr_out,
      coff_swap_aouthdr_out,
      coff_swap_scnhdr_out,
      FILHSZ,
      AOUTSZ,
      SCNHSZ,
      SYMESZ,
      AUXESZ,
      RELSZ,
      LINESZ,
      FILNMLEN,
      true,			/* _bfd_coff_long_filenames */
      false,			/* _bfd_coff_long_section_names */
      3,			/* _bfd_coff_default_section_alignment_power */
      false,			/* _bfd_coff_force_symnames_in_strings */
      2,			/* _bfd_coff_debug_string_prefix_length */
      coff_swap_filehdr_in,
      coff_swap_aouthdr_in,
      coff_swap_scnhdr_in,
      xcoff_swap_reloc_in,
      coff_bad_format_hook,
      coff_set_arch_mach_hook,
      coff_mkobject_hook,
      styp_to_sec_flags,
      coff_set_alignment_hook,
      coff_slurp_symbol_table,
      symname_in_debug_hook,
      coff_pointerize_aux_hook,
      coff_print_aux,
      dummy_reloc16_extra_cases,
      dummy_reloc16_estimate,
      NULL,			/* bfd_coff_sym_is_global */
      coff_compute_section_file_positions,
      NULL,			/* _bfd_coff_start_final_link */
      xcoff_ppc_relocate_section,
      coff_rtype_to_howto,
      NULL,			/* _bfd_coff_adjust_symndx */
      _bfd_generic_link_add_one_symbol,
      coff_link_output_has_begun,
      coff_final_link_postscript
d4007 3
a4009 3
    0x01DF,			/* magic number */
    bfd_arch_rs6000,
    bfd_mach_rs6k,
d4012 6
a4017 6
    xcoff_swap_ldhdr_in,
    xcoff_swap_ldhdr_out,
    xcoff_swap_ldsym_in,
    xcoff_swap_ldsym_out,
    xcoff_swap_ldrel_in,
    xcoff_swap_ldrel_out,
d4020 13
a4032 13
    LDHDRSZ,
    LDSYMSZ,
    LDRELSZ,
    12,				/* _xcoff_function_descriptor_size */
    SMALL_AOUTSZ,

    /* Versions.  */
    1,				/* _xcoff_ldhdr_version */

    _bfd_xcoff_put_symbol_name,
    _bfd_xcoff_put_ldsymbol_name,
    &xcoff_dynamic_reloc,
    xcoff_create_csect_from_smclas,
d4042 2
a4043 2
    &xcoff_glink_code[0],
    36,				/* _xcoff_glink_size */
d4046 3
a4048 3
    64,				/* _xcoff_rtinit_size */
    xcoff_generate_rtinit,
  };
d4052 43
a4094 42
  {
    "aixcoff-rs6000",
    bfd_target_xcoff_flavour,
    BFD_ENDIAN_BIG,		/* data byte order is big */
    BFD_ENDIAN_BIG,		/* header byte order is big */

    (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | DYNAMIC
     | HAS_SYMS | HAS_LOCALS | WP_TEXT),

    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
    0,				/* leading char */
    '/',			/* ar_pad_char */
    15,				/* ar_max_namelen */

    /* data */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    /* hdrs */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    { /* bfd_check_format */
      _bfd_dummy_target,
      coff_object_p,
      _bfd_xcoff_archive_p,
      CORE_FILE_P
    },
d4096 6
a4101 33
    { /* bfd_set_format */
      bfd_false,
      coff_mkobject,
      _bfd_generic_mkarchive,
      bfd_false
    },

    {/* bfd_write_contents */
      bfd_false,
      coff_write_object_contents,
      _bfd_xcoff_write_archive_contents,
      bfd_false
    },

    /* Generic */
    bfd_true,
    bfd_true,
    coff_new_section_hook,
    _bfd_generic_get_section_contents,
    _bfd_generic_get_section_contents_in_window,

    /* Copy */
    _bfd_xcoff_copy_private_bfd_data,
    ((boolean (*) (bfd *, bfd *)) bfd_true),
    ((boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((boolean (*) (bfd *, flagword)) bfd_true),
    ((boolean (*) (bfd *, void * )) bfd_true),

    /* Core */
    coff_core_file_failing_command,
    coff_core_file_failing_signal,
    coff_core_file_matches_executable_p,
d4103 1
a4103 2
    /* Archive */
    _bfd_xcoff_slurp_armap,
d4105 91
a4195 50
    ((boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
    bfd_dont_truncate_arname,
    _bfd_xcoff_write_armap,
    _bfd_xcoff_read_ar_hdr,
    _bfd_xcoff_openr_next_archived_file,
    _bfd_generic_get_elt_at_index,
    _bfd_xcoff_stat_arch_elt,
    bfd_true,

    /* Symbols */
    coff_get_symtab_upper_bound,
    coff_get_symtab,
    coff_make_empty_symbol,
    coff_print_symbol,
    coff_get_symbol_info,
    _bfd_xcoff_is_local_label_name,
    coff_get_lineno,
    coff_find_nearest_line,
    coff_bfd_make_debug_symbol,
    _bfd_generic_read_minisymbols,
    _bfd_generic_minisymbol_to_symbol,

    /* Reloc */
    coff_get_reloc_upper_bound,
    coff_canonicalize_reloc,
    _bfd_xcoff_reloc_type_lookup,

    /* Write */
    coff_set_arch_mach,
    coff_set_section_contents,

    /* Link */
    _bfd_xcoff_sizeof_headers,
    bfd_generic_get_relocated_section_contents,
    bfd_generic_relax_section,
    _bfd_xcoff_bfd_link_hash_table_create,
    _bfd_generic_link_hash_table_free,
    _bfd_xcoff_bfd_link_add_symbols,
    _bfd_generic_link_just_syms,
    _bfd_xcoff_bfd_final_link,
    _bfd_generic_link_split_section,
    bfd_generic_gc_sections,
    bfd_generic_merge_sections,
    bfd_generic_discard_group,

    /* Dynamic */
    _bfd_xcoff_get_dynamic_symtab_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_symtab,
    _bfd_xcoff_get_dynamic_reloc_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_reloc,
d4197 2
a4198 2
    /* Opposite endian version, none exists */
    NULL,
d4200 3
a4202 2
    (void *) &bfd_xcoff_backend_data,
  };
d4204 10
a4213 8
/* xcoff-powermac target
   Old target.
   Only difference between this target and the rs6000 target is the
   the default architecture and machine type used in coffcode.h

   PowerPC Macs use the same magic numbers as RS/6000
   (because that's how they were bootstrapped originally),
   but they are always PowerPC architecture.  */
d4215 97
a4311 88
  {
    { /* COFF backend, defined in libcoff.h.  */
      _bfd_xcoff_swap_aux_in,
      _bfd_xcoff_swap_sym_in,
      coff_swap_lineno_in,
      _bfd_xcoff_swap_aux_out,
      _bfd_xcoff_swap_sym_out,
      coff_swap_lineno_out,
      xcoff_swap_reloc_out,
      coff_swap_filehdr_out,
      coff_swap_aouthdr_out,
      coff_swap_scnhdr_out,
      FILHSZ,
      AOUTSZ,
      SCNHSZ,
      SYMESZ,
      AUXESZ,
      RELSZ,
      LINESZ,
      FILNMLEN,
      true,			/* _bfd_coff_long_filenames */
      false,			/* _bfd_coff_long_section_names */
      3,			/* _bfd_coff_default_section_alignment_power */
      false,			/* _bfd_coff_force_symnames_in_strings */
      2,			/* _bfd_coff_debug_string_prefix_length */
      coff_swap_filehdr_in,
      coff_swap_aouthdr_in,
      coff_swap_scnhdr_in,
      xcoff_swap_reloc_in,
      coff_bad_format_hook,
      coff_set_arch_mach_hook,
      coff_mkobject_hook,
      styp_to_sec_flags,
      coff_set_alignment_hook,
      coff_slurp_symbol_table,
      symname_in_debug_hook,
      coff_pointerize_aux_hook,
      coff_print_aux,
      dummy_reloc16_extra_cases,
      dummy_reloc16_estimate,
      NULL,			/* bfd_coff_sym_is_global */
      coff_compute_section_file_positions,
      NULL,			/* _bfd_coff_start_final_link */
      xcoff_ppc_relocate_section,
      coff_rtype_to_howto,
      NULL,			/* _bfd_coff_adjust_symndx */
      _bfd_generic_link_add_one_symbol,
      coff_link_output_has_begun,
      coff_final_link_postscript
    },

    0x01DF,			/* magic number */
    bfd_arch_powerpc,
    bfd_mach_ppc,

    /* Function pointers to xcoff specific swap routines.  */
    xcoff_swap_ldhdr_in,
    xcoff_swap_ldhdr_out,
    xcoff_swap_ldsym_in,
    xcoff_swap_ldsym_out,
    xcoff_swap_ldrel_in,
    xcoff_swap_ldrel_out,

    /* Sizes.  */
    LDHDRSZ,
    LDSYMSZ,
    LDRELSZ,
    12,				/* _xcoff_function_descriptor_size */
    SMALL_AOUTSZ,

    /* Versions.  */
    1,				/* _xcoff_ldhdr_version */

    _bfd_xcoff_put_symbol_name,
    _bfd_xcoff_put_ldsymbol_name,
    &xcoff_dynamic_reloc,
    xcoff_create_csect_from_smclas,

    /* Lineno and reloc count overflow.  */
    xcoff_is_lineno_count_overflow,
    xcoff_is_reloc_count_overflow,

    xcoff_loader_symbol_offset,
    xcoff_loader_reloc_offset,

    /* glink.  */
    &xcoff_glink_code[0],
    36,				/* _xcoff_glink_size */
d4313 1
a4313 6
    /* rtinit */
    0,				/* _xcoff_rtinit_size */
    xcoff_generate_rtinit,
  };

/* The transfer vector that leads the outside world to all of the above.  */
d4315 43
a4357 42
  {
    "xcoff-powermac",
    bfd_target_xcoff_flavour,
    BFD_ENDIAN_BIG,		/* data byte order is big */
    BFD_ENDIAN_BIG,		/* header byte order is big */

    (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | DYNAMIC
     | HAS_SYMS | HAS_LOCALS | WP_TEXT),

    (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC),
    0,				/* leading char */
    '/',			/* ar_pad_char */
    15,				/* ar_max_namelen */

    /* data */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    /* hdrs */
    bfd_getb64,
    bfd_getb_signed_64,
    bfd_putb64,
    bfd_getb32,
    bfd_getb_signed_32,
    bfd_putb32,
    bfd_getb16,
    bfd_getb_signed_16,
    bfd_putb16,

    { /* bfd_check_format */
      _bfd_dummy_target,
      coff_object_p,
      _bfd_xcoff_archive_p,
      CORE_FILE_P
    },
d4359 6
a4364 6
    { /* bfd_set_format */
      bfd_false,
      coff_mkobject,
      _bfd_generic_mkarchive,
      bfd_false
    },
d4366 1
a4366 29
    {/* bfd_write_contents */
      bfd_false,
      coff_write_object_contents,
      _bfd_xcoff_write_archive_contents,
      bfd_false
    },

    /* Generic */
    bfd_true,
    bfd_true,
    coff_new_section_hook,
    _bfd_generic_get_section_contents,
    _bfd_generic_get_section_contents_in_window,

    /* Copy */
    _bfd_xcoff_copy_private_bfd_data,
    ((boolean (*) (bfd *, bfd *)) bfd_true),
    ((boolean (*) (bfd *, asection *, bfd *, asection *)) bfd_true),
    ((boolean (*) (bfd *, asymbol *, bfd *, asymbol *)) bfd_true),
    ((boolean (*) (bfd *, flagword)) bfd_true),
    ((boolean (*) (bfd *, void * )) bfd_true),

    /* Core */
    coff_core_file_failing_command,
    coff_core_file_failing_signal,
    coff_core_file_matches_executable_p,

    /* Archive */
    _bfd_xcoff_slurp_armap,
d4368 91
a4458 50
    ((boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_false),
    bfd_dont_truncate_arname,
    _bfd_xcoff_write_armap,
    _bfd_xcoff_read_ar_hdr,
    _bfd_xcoff_openr_next_archived_file,
    _bfd_generic_get_elt_at_index,
    _bfd_xcoff_stat_arch_elt,
    bfd_true,

    /* Symbols */
    coff_get_symtab_upper_bound,
    coff_get_symtab,
    coff_make_empty_symbol,
    coff_print_symbol,
    coff_get_symbol_info,
    _bfd_xcoff_is_local_label_name,
    coff_get_lineno,
    coff_find_nearest_line,
    coff_bfd_make_debug_symbol,
    _bfd_generic_read_minisymbols,
    _bfd_generic_minisymbol_to_symbol,

    /* Reloc */
    coff_get_reloc_upper_bound,
    coff_canonicalize_reloc,
    _bfd_xcoff_reloc_type_lookup,

    /* Write */
    coff_set_arch_mach,
    coff_set_section_contents,

    /* Link */
    _bfd_xcoff_sizeof_headers,
    bfd_generic_get_relocated_section_contents,
    bfd_generic_relax_section,
    _bfd_xcoff_bfd_link_hash_table_create,
    _bfd_generic_link_hash_table_free,
    _bfd_xcoff_bfd_link_add_symbols,
    _bfd_generic_link_just_syms,
    _bfd_xcoff_bfd_final_link,
    _bfd_generic_link_split_section,
    bfd_generic_gc_sections,
    bfd_generic_merge_sections,
    bfd_generic_discard_group,

    /* Dynamic */
    _bfd_xcoff_get_dynamic_symtab_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_symtab,
    _bfd_xcoff_get_dynamic_reloc_upper_bound,
    _bfd_xcoff_canonicalize_dynamic_reloc,
d4460 2
a4461 2
    /* Opposite endian version, none exists */
    NULL,
d4463 3
a4465 2
    (void *) &bfd_pmac_xcoff_backend_data,
  };
@


1.40.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d4056 1
a4056 1
    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA,
d4298 1
a4298 1
    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA,
@


1.39
log
@XCOFF64 fixes. For setting arch/mach and for R_BR relocations.
@
text
@d4170 2
a4171 1
  _bfd_xcoff_bfd_final_link,               /* _bfd_filnal_link */
d4432 2
a4433 1
  _bfd_xcoff_bfd_final_link,               /* _bfd_filnal_link */
@


1.39.2.1
log
@merge from trunk
@
text
@d240 1
a240 1
  bfd_xcoff_text_align_power (abfd) = 2;
d281 2
a282 2
  bfd_xcoff_text_align_power (obfd) = bfd_xcoff_text_align_power (ibfd);
  bfd_xcoff_data_align_power (obfd) = bfd_xcoff_data_align_power (ibfd);
a950 15
  /* Modifiable branch relative.  */
  HOWTO (R_RBA,	                /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_RBA_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 false),                /* pcrel_offset */

a970 2
      else if (R_RBA == internal->r_type) 
	relent->howto = &xcoff_howto_table[0x1e];
d1716 1
d1825 1
a1825 1
      symbol_table = (bfd_byte *) bfd_zmalloc (symbol_table_size);
d1828 1
d1929 1
a1929 1
      symbol_table = (bfd_byte *) bfd_zmalloc (symbol_table_size);
d1932 1
d2443 1
a2443 1
  member_table = (bfd_byte *) bfd_zmalloc (member_table_size);
d2446 1
d3705 1
a3705 1
  data_buffer = (bfd_byte *) bfd_zmalloc (data_buffer_size);
d3708 2
d3743 2
a3744 4
      string_table = (bfd_byte *) bfd_zmalloc (string_table_size);
      if (string_table_size == NULL)
	return false;

d4170 1
a4170 2
  _bfd_generic_link_just_syms,             /* _bfd_link_just_syms */
  _bfd_xcoff_bfd_final_link,               /* _bfd_final_link */
a4173 1
  bfd_generic_discard_group,               /* _bfd_discard_group */
d4431 1
a4431 2
  _bfd_generic_link_just_syms,             /* _bfd_link_just_syms */
  _bfd_xcoff_bfd_final_link,               /* _bfd_final_link */
d4434 1
a4434 2
  bfd_generic_merge_sections,              /* _bfd_merge_sections */
  bfd_generic_discard_group,               /* _bfd_discard_group */
@


1.38
log
@Fix problem with objdump and 16 bit R_BA.
@
text
@a157 7
static boolean xcoff_reloc_type_noop PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
static boolean xcoff_reloc_type_fail PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
static boolean xcoff_reloc_type_pos PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
static boolean xcoff_reloc_type_neg PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
static boolean xcoff_reloc_type_rel PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
static boolean xcoff_reloc_type_toc PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
static boolean xcoff_reloc_type_ba PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
a158 1
static boolean xcoff_reloc_type_crel PARAMS ((XCOFF_RELOC_FUNCTION_ARGS));
d2721 1
a2721 1
static boolean 
d2738 1
a2738 1
static boolean 
d2759 1
a2759 1
static boolean 
d2777 1
a2777 1
static boolean 
d2795 1
a2795 1
static boolean 
d2819 2
a2820 1
static boolean 
d2862 2
a2863 1
static boolean 
d2964 1
a2964 1
static boolean 
@


1.37
log
@Rewrite xcoff*_ppc_relocate_section.
@
text
@d57 2
d60 2
a61 2
/* Forward declare _bfd_xcoff_rtype2howto for coffcode.h macro.  */
void _bfd_xcoff_rtype2howto PARAMS ((arelent *, struct internal_reloc *));
d79 1
a79 1
#define RTYPE2HOWTO(cache_ptr, dst) _bfd_xcoff_rtype2howto (cache_ptr, dst)
d110 3
d704 1
a704 1
	 "R_BA",                /* name */
d908 1
a908 1
	 "R_RBR",               /* name */
a928 14
  HOWTO (R_POS,                 /* type */
         0,                     /* rightshift */
         4,                     /* size (0 = byte, 1 = short, 2 = long) */
         64,                    /* bitsize */
         false,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield, /* complain_on_overflow */
         0,                     /* special_function */
         "R_POS",               /* name */
         true,                  /* partial_inplace */
         MINUS_ONE,             /* src_mask */
	 MINUS_ONE,             /* dst_mask */
	 false),                /* pcrel_offset */

d932 1
a932 1
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
d938 1
a938 1
	 "R_BA",                /* name */
d943 16
d962 1
a962 1
_bfd_xcoff_rtype2howto (relent, internal)
d966 1
a966 7
  relent->howto = xcoff_howto_table + internal->r_type;

  /* Check for relocs we don't know of.  */
  if (internal->r_type
      >= sizeof (xcoff_howto_table) / sizeof (xcoff_howto_table[0]))
    abort ();
  if (internal->r_type != relent->howto->type)
d969 12
d988 1
a988 1
	  != ((unsigned int) internal->r_size & 0x3f) + 1))
d990 4
a993 6
#if 0
  if ((internal->r_size & 0x80) != 0
      ? (relent->howto->complain_on_overflow != complain_overflow_signed)
      : (relent->howto->complain_on_overflow != complain_overflow_bitfield))
    abort ();
#endif
d1006 1
a1006 1
      return &xcoff_howto_table[0x1d];
a1013 2
    case BFD_RELOC_64:
      return &xcoff_howto_table[0x1c];
d2662 34
d3957 1
a3957 1
      coff_swap_reloc_out,              /* _bfd_swap_reloc_out */
d3977 1
a3977 1
      coff_swap_reloc_in,               /* _bfd_reloc_in */
d4214 1
a4214 1
    coff_swap_reloc_out,              /* _bfd_swap_reloc_out */
d4234 1
a4234 1
    coff_swap_reloc_in,               /* _bfd_reloc_in */
@


1.36
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d152 62
d2686 454
d3143 110
a3252 1
   will never change.  */
d3254 1
a3254 1
static boolean
a3271 1

d3280 4
a3283 1
      bfd_reloc_status_type rstat;
d3291 1
a3291 18
      symndx = rel->r_symndx;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	  addend = 0;
	}
      else
	{
	  h = obj_xcoff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	  addend = - sym->n_value;

	}

      /* We build the howto information on the fly.  */

a3293 1
      howto.size = 2;
d3295 1
d3298 2
a3299 4
      if ((rel->r_size & 0x80) != 0)
	howto.complain_on_overflow = complain_overflow_signed;
      else
	howto.complain_on_overflow = complain_overflow_bitfield;
d3303 1
a3303 8
      if (howto.bitsize == 32)
	howto.src_mask = howto.dst_mask = 0xffffffff;
      else
	{
	  howto.src_mask = howto.dst_mask = (1 << howto.bitsize) - 1;
	  if (howto.bitsize == 16)
	    howto.size = 1;
	}
d3306 1
d3308 4
d3313 1
a3313 1
      if (h == NULL)
d3316 6
a3321 7

	  if (symndx == -1)
	    {
	      sec = bfd_abs_section_ptr;
	      val = 0;
	    }
	  else
d3325 1
a3325 2
                 if this reloc is against the TOC anchor.  */

d3327 12
a3338 1
			  && strcmp (sec->name, ".tc0") == 0)
d3340 6
a3345 3
		  val = xcoff_data (output_bfd)->toc;
		}
	      else
d3347 1
d3349 14
a3362 3
			 + sec->output_offset
			 + sym->n_value
			 - sec->vma);
a3365 6
      else
	{
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      asection *sec;
d3367 12
a3378 8
	      sec = h->root.u.def.section;
	      val = (h->root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_common)
	    {
	      asection *sec;
d3380 25
a3404 6
	      sec = h->root.u.c.p->section;
	      val = (sec->output_section->vma
		     + sec->output_offset);
	    }
	  else if ((h->flags & XCOFF_DEF_DYNAMIC) != 0
		   || (h->flags & XCOFF_IMPORT) != 0)
d3406 3
a3408 4
	      /* Every symbol in a shared object is defined somewhere.  */
	      val = 0;
	    }
	  else if (! info->relocateable)
d3410 3
a3412 71
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, true)))
		return false;

	      /* Don't try to process the reloc.  It can't help, and
                 it may generate another error.  */
	      continue;
	    }
	}

      /* I took the relocation type definitions from two documents:
	 the PowerPC AIX Version 4 Application Binary Interface, First
	 Edition (April 1992), and the PowerOpen ABI, Big-Endian
	 32-Bit Hardware Implementation (June 30, 1994).  Differences
	 between the documents are noted below.  */

      switch (rel->r_type)
	{
	case R_RTB:
	case R_RRTBI:
	case R_RRTBA:
	  /* These relocs are defined by the PowerPC ABI to be
             relative branches which use half of the difference
             between the symbol and the program counter.  I can't
             quite figure out when this is useful.  These relocs are
             not defined by the PowerOpen ABI.  */
	default:
	  (*_bfd_error_handler)
	    (_("%s: unsupported relocation type 0x%02x"),
	     bfd_archive_filename (input_bfd), (unsigned int) rel->r_type);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	case R_POS:
	  /* Simple positive relocation.  */
	  break;
	case R_NEG:
	  /* Simple negative relocation.  */
	  val = - val;
	  break;
	case R_REL:
	  /* Simple PC relative relocation.  */
	  howto.pc_relative = true;
	  break;
	case R_TOC:
	  /* TOC relative relocation.  The value in the instruction in
             the input file is the offset from the input file TOC to
             the desired location.  We want the offset from the final
             TOC to the desired location.  We have:
	         isym = iTOC + in
		 iinsn = in + o
		 osym = oTOC + on
		 oinsn = on + o
	     so we must change insn by on - in.
	     */
	case R_GL:
	  /* Global linkage relocation.  The value of this relocation
             is the address of the entry in the TOC section.  */
	case R_TCL:
	  /* Local object TOC address.  I can't figure out the
             difference between this and case R_GL.  */
	case R_TRL:
	  /* TOC relative relocation.  A TOC relative load instruction
             which may be changed to a load address instruction.
             FIXME: We don't currently implement this optimization.  */
	case R_TRLA:
	  /* TOC relative relocation.  This is a TOC relative load
             address instruction which may be changed to a load
             instruction.  FIXME: I don't know if this is the correct
             implementation.  */
	  if (h != NULL && h->smclas != XMC_TD)
d3414 10
a3423 148
	      if (h->toc_section == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry"),
		     bfd_archive_filename (input_bfd), rel->r_vaddr,
		     h->root.root.string);
		  bfd_set_error (bfd_error_bad_value);
		  return false;
		}

	      BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);
	      val = (h->toc_section->output_section->vma
		     + h->toc_section->output_offset);
	    }

	  val = ((val - xcoff_data (output_bfd)->toc)
		 - (sym->n_value - xcoff_data (input_bfd)->toc));
	  addend = 0;
	  break;
	case R_BA:
	  /* Absolute branch.  We don't want to mess with the lower
             two bits of the instruction.  */
	case R_CAI:
	  /* The PowerPC ABI defines this as an absolute call which
             may be modified to become a relative call.  The PowerOpen
             ABI does not define this relocation type.  */
	case R_RBA:
	  /* Absolute branch which may be modified to become a
             relative branch.  */
	case R_RBAC:
	  /* The PowerPC ABI defines this as an absolute branch to a
             fixed address which may be modified to an absolute branch
             to a symbol.  The PowerOpen ABI does not define this
             relocation type.  */
	case R_RBRC:
	  /* The PowerPC ABI defines this as an absolute branch to a
             fixed address which may be modified to a relative branch.
             The PowerOpen ABI does not define this relocation type.  */
	  howto.src_mask &= ~3;
	  howto.dst_mask = howto.src_mask;
	  break;
	case R_BR:
	  /* Relative branch.  We don't want to mess with the lower
             two bits of the instruction.  */
	case R_CREL:
	  /* The PowerPC ABI defines this as a relative call which may
             be modified to become an absolute call.  The PowerOpen
             ABI does not define this relocation type.  */
	case R_RBR:
	  /* A relative branch which may be modified to become an
             absolute branch.  FIXME: We don't implement this,
             although we should for symbols of storage mapping class
             XMC_XO.  */
	  howto.pc_relative = true;
	  howto.src_mask &= ~3;
	  howto.dst_mask = howto.src_mask;
	  break;
	case R_RL:
	  /* The PowerPC AIX ABI describes this as a load which may be
             changed to a load address.  The PowerOpen ABI says this
             is the same as case R_POS.  */
	  break;
	case R_RLA:
	  /* The PowerPC AIX ABI describes this as a load address
             which may be changed to a load.  The PowerOpen ABI says
             this is the same as R_POS.  */
	  break;
	}

      /* If we see an R_BR or R_RBR reloc which is jumping to global
         linkage code, and it is followed by an appropriate cror nop
         instruction, we replace the cror with lwz r2,20(r1).  This
         restores the TOC after the glink code.  Contrariwise, if the
         call is followed by a lwz r2,20(r1), but the call is not
         going to global linkage code, we can replace the load with a
         cror.  */
      if ((rel->r_type == R_BR || rel->r_type == R_RBR)
	  && h != NULL
	  && h->root.type == bfd_link_hash_defined
	  && (rel->r_vaddr - input_section->vma + 8
	      <= input_section->_cooked_size))
	{
	  bfd_byte *pnext;
	  unsigned long next;

	  pnext = contents + (rel->r_vaddr - input_section->vma) + 4;
	  next = bfd_get_32 (input_bfd, pnext);

	  /* The _ptrgl function is magic.  It is used by the AIX
             compiler to call a function through a pointer.  */
	  if (h->smclas == XMC_GL
	      || strcmp (h->root.root.string, "._ptrgl") == 0)
	    {
	      if (next == 0x4def7b82		/* cror 15,15,15 */
		  || next == 0x4ffffb82		/* cror 31,31,31 */
		  || next == 0x60000000)	/* ori r0,r0,0 */
		bfd_put_32 (input_bfd,
			    (bfd_vma) 0x80410014, /* lwz r1,20(r1) */
			    pnext);
	    }
	  else
	    {
	      if (next == 0x80410014)		/* lwz r1,20(r1) */
		bfd_put_32 (input_bfd,
			    (bfd_vma) 0x60000000, /* ori r0,r0,0 */
			    pnext);
	    }
	}

      /* A PC relative reloc includes the section address.  */
      if (howto.pc_relative)
	addend += input_section->vma;

      rstat = _bfd_final_link_relocate (&howto, input_bfd, input_section,
					contents,
					rel->r_vaddr - input_section->vma,
					val, addend);

      switch (rstat)
	{
	default:
	  abort ();
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_overflow:
	  {
	    const char *name;
	    char buf[SYMNMLEN + 1];
	    char howto_name[10];

	    if (symndx == -1)
	      name = "*ABS*";
	    else if (h != NULL)
	      name = h->root.root.string;
	    else
	      {
		name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);

		if (name == NULL)
		  return false;
	      }
	    sprintf (howto_name, "0x%02x", rel->r_type);

	    if (! ((*info->callbacks->reloc_overflow)
		   (info, name, howto_name, (bfd_vma) 0, input_bfd,
		    input_section, rel->r_vaddr - input_section->vma)))
	      return false;
	  }
d3425 11
@


1.35
log
@Fix extracting from AIX big archives.
@
text
@d3680 1
d3941 1
@


1.34
log
@Add AIX 64 shared library support and emulation layer for binutils
@
text
@d48 1
a48 1
extern int _bfd_xcoff_generic_stat_arch_elt PARAMS ((bfd *, struct stat *));
d1420 1
a1420 1
_bfd_xcoff_generic_stat_arch_elt (abfd, s)
d1430 1
a1430 1
  if (! xcoff_big_format_p (abfd))
d3647 1
a3647 1
  _bfd_xcoff_generic_stat_arch_elt,        /* _generic_dtat_arch_elt */
d3907 1
a3907 1
  _bfd_xcoff_generic_stat_arch_elt,        /* _generic_dtat_arch_elt */
@


1.33
log
@Replace immediate howto type initializers with symbolic.
@
text
@d148 3
d994 1
d996 9
d1589 79
a2095 4
      while (remaining != 0)
	{
	  bfd_size_type amt;
	  bfd_byte buffer[DEFAULT_BUFFERSIZE];
d2097 5
a2101 17
	  amt = sizeof buffer;
	  if (amt > remaining)
	    amt = remaining;
	  if (bfd_bread (buffer, amt, sub) != amt
	      || bfd_bwrite (buffer, amt, abfd) != amt)
	    return false;
	  remaining -= amt;
	}

      if ((size & 1) != 0)
	{
	  bfd_byte b;

	  b = '\0';
	  if (bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
	    return false;
	}
a2167 3
  if ((size & 1) != 0)
    {
      bfd_byte b;
d2169 2
a2170 4
      b = '\0';
      if (bfd_bwrite ((PTR) &b, (bfd_size_type) 1, abfd) != 1)
	return false;
    }
d2217 1
a2218 2
  PRINT20 (fhdr.firstmemoff, SIZEOF_AR_FILE_HDR_BIG);
  PRINT20 (fhdr.freeoff, 0);
d2220 6
a2225 1
  /* Calculate count and total_namlen */
d2229 8
a2236 1
    total_namlen += strlen (normalize_filename (current_bfd)) + 1;
a2244 2
  if (bfd_seek (abfd, (file_ptr) SIZEOF_AR_FILE_HDR_BIG, SEEK_SET) != 0)
    return false;
a2245 2
  makemap = bfd_has_map (abfd);
  hasobjects = false;
a2256 6
      if (makemap && ! hasobjects)
	{
	  if (bfd_check_format (current_bfd, bfd_object))
	    hasobjects = true;
	}

d2311 8
a2334 4
      while (remaining != 0)
	{
	  bfd_size_type amt;
	  bfd_byte buffer[DEFAULT_BUFFERSIZE];
d2336 6
a2341 8
	  amt = sizeof buffer;
	  if (amt > remaining)
	    amt = remaining;
	  if (bfd_bread (buffer, amt, current_bfd) != amt
	      || bfd_bwrite (buffer, amt, abfd) != amt)
	    return false;
	  remaining -= amt;
	}
d2343 4
a2346 8
      if ((size & 1) != 0)
	{
	  bfd_byte b;

	  b = '\0';
	  if (bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
	    return false;
	}
a2348 2
  PRINT20 (fhdr.lastmemoff, prevoff);

d3526 1
a3526 1
    1,                                    /* _xcoff_ldhdr_version */
a3527 1
    /* Xcoff vs xcoff64 putting symbol names.  */
d3529 2
a3530 4
    _bfd_xcoff_put_ldsymbol_name,          /* _xcoff_put_ldsymbol_name */

    & xcoff_dynamic_reloc,                  /* dynamic reloc howto */

d3549 1
a3549 1
/* The transfer vector that leads the outside world to all of the above. */
@


1.32
log
@XCOFF booke tests.  Fix tlbre, tlbwe ppc WS field.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
d519 1
a519 1
  HOWTO (0,	                /* type */
d534 1
a534 1
  HOWTO (1,	                /* type */
d549 1
a549 1
  HOWTO (2,	                /* type */
d564 1
a564 1
  HOWTO (3,	                /* type */
d579 1
a579 1
  HOWTO (4,	                /* type */
d594 1
a594 1
  HOWTO (5,	                /* type */
d609 1
a609 1
  HOWTO (6,	                /* type */
d626 1
a626 1
  HOWTO (8,	                /* type */
d643 1
a643 1
  HOWTO (0xa,	                /* type */
d660 1
a660 1
  HOWTO (0xc,	                /* type */
d675 1
a675 1
  HOWTO (0xd,	                /* type */
d692 1
a692 1
  HOWTO (0xf,	                /* type */
d710 1
a710 1
  HOWTO (0x12,	                /* type */
d725 1
a725 1
  HOWTO (0x13,	                /* type */
d740 1
a740 1
  HOWTO (0x14,	                /* type */
d755 1
a755 1
  HOWTO (0x15,	                /* type */
d770 1
a770 1
  HOWTO (0x16,	                /* type */
d785 1
a785 1
  HOWTO (0x17,	                /* type */
d800 1
a800 1
  HOWTO (0x18,	                /* type */
d815 1
a815 1
  HOWTO (0x19,	                /* type */
d830 1
a830 1
  HOWTO (0x1a,	                /* type */
d845 1
a845 1
  HOWTO (0x1b,	                /* type */
d859 1
a859 1
  HOWTO (0x1c,                  /* type */
d874 1
a874 1
  HOWTO (0x1d,	                /* type */
@


1.31
log
@Add support for -brtl, run time linking, to AIX ld.
@
text
@d860 1
a860 1
  HOWTO (0,                     /* type */
d872 1
a872 1
	 false)                 /* pcrel_offset */
d874 14
d930 2
@


1.30
log
@2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * coff-rs6000.c (xcoff_generate_rtinit): Silence uninitialized
        variable warnings.
        * elf32-sh.c (sh_elf_relax_section): Silence signed/unsigned
        comparison warning.
        * trad-core.c (trad_unix_core_file_p): Silence pointer/integer
        cast warnings for the common case.
@
text
@d84 3
a86 2
extern const bfd_target * rs6000coff_core_p ();
extern boolean rs6000coff_core_file_matches_executable_p ();
d148 1
a148 2
  PARAMS((bfd *, const char *, const char *));

d3054 1
a3054 1
xcoff_generate_rtinit  (abfd, init, fini)
d3058 1
d3062 2
a3063 2
  bfd_byte syment_ext[SYMESZ * 8];
  bfd_byte reloc_ext[RELSZ * 2];
d3078 1
d3080 1
a3080 2
  if (! bfd_xcoff_rtinit_size (abfd) 
      || (init == NULL && fini == NULL))
d3092 1
a3092 1
  filehdr.f_nsyms = 0;  /* at least 6, no more than 8 */
d3183 4
a3186 3
     6. fini function */
  memset (syment_ext, 0, 8 * SYMESZ);
  memset (reloc_ext, 0, 2 * RELSZ);
d3292 26
a3726 1

@


1.29
log
@* bfd/coff-rs6000.c (READ20): Use bfd_scan_vma.
@
text
@d3065 1
a3065 1
  bfd_byte *string_table, *st_tmp;
@


1.29.2.1
log
@2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * coff-rs6000.c (xcoff_generate_rtinit): Silence uninitialized
        variable warnings.
        * elf32-sh.c (sh_elf_relax_section): Silence signed/unsigned
        comparison warning.
        * trad-core.c (trad_unix_core_file_p): Silence pointer/integer
        cast warnings for the common case.
@
text
@d3065 1
a3065 1
  bfd_byte *string_table = NULL, *st_tmp = NULL;
@


1.29.2.2
log
@Fix extracting from AIX big archives.
@
text
@d49 1
a49 1
extern int _bfd_xcoff_stat_arch_elt PARAMS ((bfd *, struct stat *));
d1392 1
a1392 1
_bfd_xcoff_stat_arch_elt (abfd, s)
d1402 1
a1402 1
  if (! xcoff_big_format_p (abfd->my_archive))
d3539 1
a3539 1
  _bfd_xcoff_stat_arch_elt,                /* _generic_stat_arch_elt */
d3800 1
a3800 1
  _bfd_xcoff_stat_arch_elt,                /* _generic_stat_arch_elt */
@


1.28
log
@Fix for xcoff <bigaf> big archive format support.
@
text
@d1558 1
a1558 1
  (v) = strtoull (buff20, (char **) NULL, 10)
@


1.27
log
@-binitfini emulation, put __rtinit symbol generation into linker.
@
text
@a115 3
static boolean xcoff_write_one_armap_big
  PARAMS ((bfd *, struct orl *, unsigned int, unsigned int, unsigned int,
	   int, const char *, char *));
d146 3
d1465 1
a1465 1
  memcpy (hdr.prevoff, xcoff_ardata (abfd)->memoff, 12);
d1534 25
a1558 1
/* Write a single armap in the big format.  */
d1561 1
a1561 2
xcoff_write_one_armap_big (abfd, map, orl_count, orl_ccount, stridx, bits64,
			   prevoff, nextoff)
d1563 1
d1566 1
a1566 5
     unsigned int orl_ccount;
     unsigned int stridx;
     int bits64;
     const char *prevoff;
     char *nextoff;
d1568 2
a1569 5
  struct xcoff_ar_hdr_big hdr;
  char *p;
  unsigned char buf[4];
  bfd *sub;
  file_ptr fileoff;
d1571 7
a1577 2
  bfd *object_bfd;
  unsigned int i;
d1579 5
a1583 6
  memset (&hdr, 0, sizeof hdr);
  /* XXX This call actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (hdr.size, "%ld", (long) (4 + orl_ccount * 4 + stridx));
  if (bits64)
d1585 19
a1603 7
      sprintf (hdr.nextoff, "%d", 0);
    }
  else
    {
      /* Do explict cast to long to remove compiler warning.  */
      sprintf (hdr.nextoff, "%ld", (strtol (prevoff, (char **) NULL, 10)
				    + (long) (4 + orl_ccount * 4 + stridx)));
d1606 4
a1609 6
  memcpy (hdr.prevoff, prevoff, sizeof (hdr.prevoff));
  sprintf (hdr.date, "%d", 0);
  sprintf (hdr.uid, "%d", 0);
  sprintf (hdr.gid, "%d", 0);
  sprintf (hdr.mode, "%d", 0);
  sprintf (hdr.namlen, "%d", 0);
d1611 1
a1611 4
  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &hdr; p < (char *) &hdr + SIZEOF_AR_HDR_BIG; p++)
    if (*p == '\0')
      *p = ' ';
d1613 3
a1615 1
  memcpy (nextoff, hdr.nextoff, sizeof (hdr.nextoff));
d1617 1
a1617 9
  if ((bfd_bwrite ((PTR) &hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
       != SIZEOF_AR_HDR_BIG)
      || (bfd_bwrite (XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)
	  != SXCOFFARFMAG))
    return false;

  H_PUT_32 (abfd, orl_ccount, buf);
  if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
    return false;
d1619 47
a1665 15
  sub = abfd->archive_head;
  fileoff = SIZEOF_AR_FILE_HDR_BIG;
  i = 0;
  while (sub != NULL && i < orl_count)
    {
      size_t namlen;

      if ((bfd_arch_bits_per_address (map[i].u.abfd) == 64) == bits64)
	while (map[i].u.abfd == sub)
	  {
	    H_PUT_32 (abfd, fileoff, buf);
	    if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
	      return false;
	    i++;
	  }
d1667 1
a1667 2
	while (map[i].u.abfd == sub)
	  i++;
d1669 63
a1731 9
      namlen = strlen (normalize_filename (sub));
      namlen = (namlen + 1) &~ (size_t) 1;
      fileoff += (SIZEOF_AR_HDR_BIG
		  + namlen
		  + SXCOFFARFMAG
		  + arelt_size (sub));
      fileoff = (fileoff + 1) &~ 1;
      sub = sub->next;
    }
d1733 1
a1733 6
  object_bfd = NULL;
  for (i = 0; i < orl_count; i++)
    {
      const char *name;
      size_t namlen;
      bfd *ob = map[i].u.abfd;
d1735 2
a1736 4
      if (ob != object_bfd)
	arch_info = bfd_get_arch_info (ob);
      if ((arch_info->bits_per_address == 64) != bits64)
	continue;
d1738 2
a1739 4
      name = *map[i].name;
      namlen = strlen (name);
      if (bfd_bwrite (name, (bfd_size_type) (namlen + 1), abfd) != namlen + 1)
	return false;
d1741 4
a1744 2

  if ((stridx & 1) != 0)
d1746 43
a1788 39
      char b;

      b = '\0';
      if (bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
	return false;
    }

  return true;
}

static boolean
xcoff_write_armap_big (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength ATTRIBUTE_UNUSED;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
{
  unsigned int i;
  unsigned int orl_count_32, orl_count_64;
  unsigned int stridx_32, stridx_64;
  const bfd_arch_info_type *arch_info = NULL;
  bfd *object_bfd;

  /* First, we look through the symbols and work out which are
     from 32-bit objects and which from 64-bit ones.  */
  orl_count_32 = 0;
  orl_count_64 = 0;
  stridx_32 = 0;
  stridx_64 = 0;
  object_bfd = NULL;
  for (i = 0; i < orl_count; i++)
    {
      bfd *ob = map[i].u.abfd;
      unsigned int len;
      if (ob != object_bfd)
	arch_info = bfd_get_arch_info (ob);
      len = strlen (*map[i].name) + 1;
      if (arch_info->bits_per_address == 64)
d1790 27
a1816 4
	  orl_count_64++;
	  stridx_64 += len;
	}
      else
d1818 12
a1829 2
	  orl_count_32++;
	  stridx_32 += len;
a1830 6
      object_bfd = ob;
    }
  /* A quick sanity check... */
  BFD_ASSERT (orl_count_64 + orl_count_32 == orl_count);
  /* Explicit cast to int for compiler.  */
  BFD_ASSERT ((int)(stridx_64 + stridx_32) == stridx);
d1832 4
a1835 11
  /* Now write out each map.  */
  if (! xcoff_write_one_armap_big (abfd, map, orl_count, orl_count_32,
				   stridx_32, false,
				   xcoff_ardata_big (abfd)->memoff,
				   xcoff_ardata_big (abfd)->symoff))
    return false;
  if (! xcoff_write_one_armap_big (abfd, map, orl_count, orl_count_64,
				   stridx_64, true,
				   xcoff_ardata_big (abfd)->symoff,
				   xcoff_ardata_big (abfd)->symoff64))
    return false;
d1837 5
d1878 1
a1878 1
  char decbuf[13];
d2021 3
a2023 1
  sprintf (ahdr.size, "%ld", (long) (12 + count * 12 + total_namlen));
d2032 2
a2033 2
	  + 12
	  + count * 12
d2057 2
a2058 1
  if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) 12, abfd) != 12)
d2063 2
a2064 1
      if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) 12, abfd) != 12)
a2086 1

d2124 1
a2124 1
  bfd *sub;
d2126 1
a2126 1
  struct xcoff_ar_hdr_big ahdr;
d2128 2
a2129 2
  char *p;
  char decbuf[13];
d2131 9
a2139 4
  memset (&fhdr, 0, sizeof fhdr);
  strncpy (fhdr.magic, XCOFFARMAGBIG, SXCOFFARMAG);
  sprintf (fhdr.firstmemoff, "%d", SIZEOF_AR_FILE_HDR_BIG);
  sprintf (fhdr.freeoff, "%d", 0);
d2141 2
a2142 3
  count = 0;
  total_namlen = 0;
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
d2144 3
a2146 2
      ++count;
      total_namlen += strlen (normalize_filename (sub)) + 1;
a2147 4
  offsets = (file_ptr *) bfd_alloc (abfd, count * sizeof (file_ptr));
  if (offsets == NULL)
    return false;

d2155 3
a2157 1
  for (sub = abfd->archive_head, i = 0; sub != NULL; sub = sub->next, i++)
d2166 1
a2166 1
	  if (bfd_check_format (sub, bfd_object))
d2170 1
a2170 1
      name = normalize_filename (sub);
d2173 2
a2174 2
      if (sub->arelt_data != NULL)
	ahdrp = arch_xhdr_big (sub);
a2181 1
	  memset (&ahdr, 0, sizeof ahdr);
d2184 3
a2186 2
	     32-bit machines).  */
	  if (stat (bfd_get_filename (sub), &s) != 0)
d2192 5
a2196 8
	  /* XXX This call actually should use %lld (at least on 32-bit
	     machines) since the fields's width is 20 and there numbers with
	     more than 32 bits can be represented.  */
	  sprintf (ahdrp->size, "%ld", (long) s.st_size);
	  sprintf (ahdrp->date, "%ld", (long) s.st_mtime);
	  sprintf (ahdrp->uid, "%ld", (long) s.st_uid);
	  sprintf (ahdrp->gid, "%ld", (long) s.st_gid);
	  sprintf (ahdrp->mode, "%o", (unsigned int) s.st_mode);
d2198 1
a2198 1
	  if (sub->arelt_data == NULL)
d2201 2
a2202 2
	      sub->arelt_data = bfd_alloc (sub, size);
	      if (sub->arelt_data == NULL)
d2206 1
a2206 1
	  arch_eltdata (sub)->parsed_size = s.st_size;
d2209 2
a2210 5
      /* XXX These calls actually should use %lld (at least on 32-bit
	 machines) since the fields's width is 20 and there numbers with
	 more than 32 bits can be represented.  */
      sprintf (ahdrp->prevoff, "%ld", (long) prevoff);
      sprintf (ahdrp->namlen, "%ld", (long) namlen);
d2216 1
a2216 1
      remaining = arelt_size (sub);
d2229 1
a2229 6
      sprintf (ahdrp->nextoff, "%ld", (long) nextoff);

      /* We need spaces, not null bytes, in the header.  */
      for (p = (char *) ahdrp; p < (char *) ahdrp + SIZEOF_AR_HDR_BIG; p++)
	if (*p == '\0')
	  *p = ' ';
d2234 2
a2235 2
	  || (bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)
	      != SXCOFFARFMAG))
d2238 1
a2238 1
      if (bfd_seek (sub, (file_ptr) 0, SEEK_SET) != 0)
d2248 1
a2248 1
	  if (bfd_bread (buffer, amt, sub) != amt
d2264 4
a2267 4
  /* XXX This call actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (fhdr.lastmemoff, "%ld", (long) prevoff);
d2269 17
a2285 1
  /* Write out the member table.  */
a2287 4
  /* XXX This call actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (fhdr.memoff, "%ld", (long) nextoff);
d2289 12
a2300 11
  memset (&ahdr, 0, sizeof ahdr);
  /* XXX The next two calls actually should use %lld (at least on 32-bit
     machines) since the fields's width is 20 and there numbers with
     more than 32 bits can be represented.  */
  sprintf (ahdr.size, "%ld", (long) (12 + count * 12 + total_namlen));
  sprintf (ahdr.prevoff, "%ld", (long) prevoff);
  sprintf (ahdr.date, "%d", 0);
  sprintf (ahdr.uid, "%d", 0);
  sprintf (ahdr.gid, "%d", 0);
  sprintf (ahdr.mode, "%d", 0);
  sprintf (ahdr.namlen, "%d", 0);
d2302 1
a2302 5
  size = (SIZEOF_AR_HDR_BIG
	  + 12
	  + count * 12
	  + total_namlen
	  + SXCOFFARFMAG);
d2304 17
a2320 2
  prevoff = nextoff;
  nextoff += size + (size & 1);
d2322 7
a2328 18
  if (makemap && hasobjects)
    /* XXX This call actually should use %lld (at least on 32-bit
       machines) since the fields's width is 20 and there numbers with
       more than 32 bits can be represented.  */
    sprintf (ahdr.nextoff, "%ld", (long) nextoff);
  else
    sprintf (ahdr.nextoff, "%d", 0);

  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &ahdr; p < (char *) &ahdr + SIZEOF_AR_HDR_BIG; p++)
    if (*p == '\0')
      *p = ' ';

  if ((bfd_bwrite ((PTR) &ahdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)
       != SIZEOF_AR_HDR_BIG)
      || (bfd_bwrite ((PTR) XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)
	  != SXCOFFARFMAG))
    return false;
d2330 1
a2330 4
  sprintf (decbuf, "%-12ld", (long) count);
  if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) 12, abfd) != 12)
    return false;
  for (i = 0; i < (size_t) count; i++)
d2332 2
a2333 3
      sprintf (decbuf, "%-12ld", (long) offsets[i]);
      if (bfd_bwrite ((PTR) decbuf, (bfd_size_type) 12, abfd) != 12)
	return false;
d2335 3
a2337 1
  for (sub = abfd->archive_head; sub != NULL; sub = sub->next)
d2342 3
a2344 5
      name = normalize_filename (sub);
      namlen = strlen (name);
      if (bfd_bwrite ((PTR) name, (bfd_size_type) (namlen + 1), abfd)
	  != namlen + 1)
	return false;
d2346 8
a2353 3
  if ((size & 1) != 0)
    {
      bfd_byte b;
d2355 2
a2356 4
      b = '\0';
      if (bfd_bwrite ((PTR) &b, (bfd_size_type) 1, abfd) != 1)
	return false;
    }
d2360 2
a2361 2
  if (! makemap || ! hasobjects)
    sprintf (fhdr.symoff, "%d", 0);
d2365 4
a2368 3
      /* XXX This call actually should use %lld (at least on 32-bit
	 machines) since the fields's width is 20 and there numbers with
	 more than 32 bits can be represented.  */
a2375 5
  /* We need spaces, not null bytes, in the header.  */
  for (p = (char *) &fhdr; p < (char *) &fhdr + SIZEOF_AR_FILE_HDR_BIG; p++)
    if (*p == '\0')
      *p = ' ';

d2377 2
a2378 2
      || (bfd_bwrite ((PTR) &fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR_BIG, abfd)
	  != SIZEOF_AR_FILE_HDR_BIG))
d2380 1
a2380 1

d3132 5
a3136 1
  data_buffer = (bfd_byte *)bfd_malloc (data_buffer_size);
d3301 3
@


1.26
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d2921 248
d3296 4
d3556 4
@


1.25
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d2579 1
a2579 1
	     bfd_get_filename (input_bfd), (unsigned int) rel->r_type);
d2625 1
a2625 1
		     bfd_get_filename (input_bfd), rel->r_vaddr,
d2875 1
a2875 1
	 bfd_get_filename (abfd), symbol_name, aux->x_csect.x_smclas);
@


1.24
log
@Add missing prototypes
@
text
@d79 4
a82 4
#define coff_mkobject _bfd_xcoff_mkobject 
#define coff_bfd_copy_private_bfd_data _bfd_xcoff_copy_private_bfd_data 
#define coff_bfd_is_local_label_name _bfd_xcoff_is_local_label_name 
#define coff_bfd_reloc_type_lookup _bfd_xcoff_reloc_type_lookup 
d158 1
d160 1
a160 3
  abfd->tdata.xcoff_obj_data =
    ((struct xcoff_tdata *)
     bfd_zalloc (abfd, sizeof (struct xcoff_tdata)));
a241 2


d258 1
a258 2
      in->_n._n_n._n_offset = 
	bfd_h_get_32 (abfd, (bfd_byte *) ext->e.e.e_offset);
d261 5
a265 5
  in->n_value = bfd_h_get_32 (abfd, (bfd_byte *) ext->e_value); 
  in->n_scnum = bfd_h_get_16 (abfd, (bfd_byte *) ext->e_scnum);
  in->n_type = bfd_h_get_16 (abfd, (bfd_byte *) ext->e_type);
  in->n_sclass = bfd_h_get_8 (abfd, ext->e_sclass);
  in->n_numaux = bfd_h_get_8 (abfd, ext->e_numaux);
d283 2
a284 3
      bfd_h_put_32 (abfd, 0, (bfd_byte *) ext->e.e.e_zeroes);
      bfd_h_put_32 (abfd, in->_n._n_n._n_offset, 
		    (bfd_byte *)  ext->e.e.e_offset);
d287 5
a291 5
  bfd_h_put_32 (abfd,  in->n_value , (bfd_byte *) ext->e_value);
  bfd_h_put_16 (abfd,  in->n_scnum , (bfd_byte *) ext->e_scnum);
  bfd_h_put_16 (abfd,  in->n_type , (bfd_byte *) ext->e_type);
  bfd_h_put_8  (abfd,  in->n_sclass , ext->e_sclass);
  bfd_h_put_8  (abfd,  in->n_numaux , ext->e_numaux);
a294 7
#define PUTWORD bfd_h_put_32
#define PUTHALF bfd_h_put_16
#define PUTBYTE bfd_h_put_8
#define GETWORD bfd_h_get_32
#define GETHALF bfd_h_get_16
#define GETBYTE bfd_h_get_8

d314 2
a315 2
	  in->x_file.x_n.x_offset = 
	    bfd_h_get_32 (abfd, (bfd_byte *) ext->x_file.x_n.x_offset);
d337 3
a339 5
	  in->x_csect.x_scnlen.l = 
	      bfd_h_get_32 (abfd, ext->x_csect.x_scnlen);
	  in->x_csect.x_parmhash = bfd_h_get_32 (abfd,
						 ext->x_csect.x_parmhash);
	  in->x_csect.x_snhash   = bfd_h_get_16 (abfd, ext->x_csect.x_snhash);
d343 4
a346 4
	  in->x_csect.x_smtyp    = bfd_h_get_8  (abfd, ext->x_csect.x_smtyp);
	  in->x_csect.x_smclas   = bfd_h_get_8  (abfd, ext->x_csect.x_smclas);
	  in->x_csect.x_stab     = bfd_h_get_32 (abfd, ext->x_csect.x_stab);
	  in->x_csect.x_snstab   = bfd_h_get_16 (abfd, ext->x_csect.x_snstab);
d356 3
a358 6
	  in->x_scn.x_scnlen = bfd_h_get_32(abfd, 
		  (bfd_byte *) ext->x_scn.x_scnlen);
	  in->x_scn.x_nreloc = bfd_h_get_16(abfd, 
		  (bfd_byte *) ext->x_scn.x_nreloc);
	  in->x_scn.x_nlinno = bfd_h_get_16(abfd, 
		  (bfd_byte *) ext->x_scn.x_nlinno);
d370 2
a371 2
  in->x_sym.x_tagndx.l = bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_tagndx);
  in->x_sym.x_tvndx = bfd_h_get_16(abfd, (bfd_byte *) ext->x_sym.x_tvndx);
d375 4
a378 4
      in->x_sym.x_fcnary.x_fcn.x_lnnoptr = bfd_h_get_32(abfd, (bfd_byte *)
	      ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      in->x_sym.x_fcnary.x_fcn.x_endndx.l = bfd_h_get_32(abfd, (bfd_byte *)
	      ext->x_sym.x_fcnary.x_fcn.x_endndx);
d383 1
a383 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
d385 1
a385 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
d387 1
a387 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
d389 1
a389 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
d394 1
a394 1
      in->x_sym.x_misc.x_fsize = bfd_h_get_32 (abfd, (bfd_byte *) ext->x_sym.x_misc.x_fsize);
d398 4
a401 4
      in->x_sym.x_misc.x_lnsz.x_lnno = bfd_h_get_16 (abfd, (bfd_byte *)
						     ext->x_sym.x_misc.x_lnsz.x_lnno);
      in->x_sym.x_misc.x_lnsz.x_size = bfd_h_get_16 (abfd, (bfd_byte *)
						     ext->x_sym.x_misc.x_lnsz.x_size);
d431 2
a432 4
	  PUTWORD (abfd, 0, (bfd_byte *) ext->x_file.x_n.x_zeroes);
	  PUTWORD (abfd,
		   in->x_file.x_n.x_offset,
		   (bfd_byte *) ext->x_file.x_n.x_offset);
d445 3
a447 3
	  PUTWORD (abfd, in->x_csect.x_scnlen.l,ext->x_csect.x_scnlen);
	  PUTWORD (abfd, in->x_csect.x_parmhash,	ext->x_csect.x_parmhash);
	  PUTHALF (abfd, in->x_csect.x_snhash,	ext->x_csect.x_snhash);
d451 4
a454 4
	  PUTBYTE (abfd, in->x_csect.x_smtyp,	ext->x_csect.x_smtyp);
	  PUTBYTE (abfd, in->x_csect.x_smclas,	ext->x_csect.x_smclas);
	  PUTWORD (abfd, in->x_csect.x_stab,	ext->x_csect.x_stab);
	  PUTHALF (abfd, in->x_csect.x_snstab,	ext->x_csect.x_snstab);
d464 3
a466 3
	  bfd_h_put_32(abfd, in->x_scn.x_scnlen, (bfd_byte *) ext->x_scn.x_scnlen);
	  bfd_h_put_16(abfd, in->x_scn.x_nreloc, (bfd_byte *) ext->x_scn.x_nreloc);
	  bfd_h_put_16(abfd, in->x_scn.x_nlinno, (bfd_byte *) ext->x_scn.x_nlinno);
d472 2
a473 2
  PUTWORD (abfd, in->x_sym.x_tagndx.l, (bfd_byte *) ext->x_sym.x_tagndx);
  bfd_h_put_16 (abfd, in->x_sym.x_tvndx , (bfd_byte *) ext->x_sym.x_tvndx);
d477 4
a480 4
      bfd_h_put_32 (abfd,  in->x_sym.x_fcnary.x_fcn.x_lnnoptr, 
		    (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      PUTWORD (abfd,  in->x_sym.x_fcnary.x_fcn.x_endndx.l, 
	       (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_endndx);
d484 8
a491 8
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[0],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[1],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[2],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[3],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
d495 1
a495 2
    PUTWORD (abfd, in->x_sym.x_misc.x_fsize,
	     (bfd_byte *)  ext->x_sym.x_misc.x_fsize);
d498 4
a501 4
      bfd_h_put_16 (abfd, in->x_sym.x_misc.x_lnsz.x_lnno, 
		    (bfd_byte *)ext->x_sym.x_misc.x_lnsz.x_lnno);
      bfd_h_put_16 (abfd, in->x_sym.x_misc.x_lnsz.x_size, 
		    (bfd_byte *)ext->x_sym.x_misc.x_lnsz.x_size);
d896 1
a896 1
      && (relent->howto->bitsize 
d1014 2
a1015 1
      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR)
d1020 2
a1021 1
      if (bfd_seek (abfd, ((namlen + 1) & ~1) + SXCOFFARFMAG, SEEK_CUR) != 0)
d1030 1
a1030 1
      if (bfd_read ((PTR) contents, 1, sz, abfd) != sz)
d1034 2
a1035 2
      c = bfd_h_get_32 (abfd, contents);
      
d1041 3
a1043 3
      
      bfd_ardata (abfd)->symdefs = ((carsym *)
				    bfd_alloc (abfd, c * sizeof (carsym)));
d1046 1
a1046 1
      
d1051 1
a1051 1
	arsym->file_offset = bfd_h_get_32 (abfd, p);
d1069 1
a1069 1
      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR_BIG, 1, abfd)
d1075 2
a1076 1
      if (bfd_seek (abfd, ((namlen + 1) & ~1) + SXCOFFARFMAG, SEEK_CUR) != 0)
d1088 1
a1088 1
      if (bfd_read ((PTR) contents, 1, sz, abfd) != sz)
d1092 1
a1092 1
      c = bfd_h_get_64 (abfd, contents);
d1099 3
a1101 3
      
      bfd_ardata (abfd)->symdefs = ((carsym *)
				    bfd_alloc (abfd, c * sizeof (carsym)));
d1104 1
a1104 1
      
d1109 1
a1109 1
	arsym->file_offset = bfd_h_get_64 (abfd, p);
d1139 1
d1141 1
a1141 1
  if (bfd_read ((PTR) magic, SXCOFFARMAG, 1, abfd) != SXCOFFARMAG)
d1158 2
a1159 3
  abfd->tdata.aout_ar_data =
    (struct artdata *) bfd_zalloc (abfd, sizeof (struct artdata));

d1178 3
a1180 2
      if (bfd_read ((PTR) &hdr.memoff, SIZEOF_AR_FILE_HDR - SXCOFFARMAG, 1,
		    abfd) != SIZEOF_AR_FILE_HDR - SXCOFFARMAG)
d1190 2
a1191 1
      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, SIZEOF_AR_FILE_HDR);
d1206 3
a1208 2
      if (bfd_read ((PTR) &hdr.memoff, SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG, 1,
		    abfd) != SIZEOF_AR_FILE_HDR_BIG - SXCOFFARMAG)
d1221 2
a1222 1
      bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, SIZEOF_AR_FILE_HDR_BIG);
d1245 1
a1245 1
  size_t namlen;
d1247 1
d1249 1
a1249 1
  ret = (struct areltdata *) bfd_alloc (abfd, sizeof (struct areltdata));
d1258 2
a1259 1
      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR)
d1266 2
a1267 2
      hdrp = (struct xcoff_ar_hdr *) bfd_alloc (abfd,
						SIZEOF_AR_HDR + namlen + 1);
d1274 1
a1274 1
      if (bfd_read ((char *) hdrp + SIZEOF_AR_HDR, 1, namlen, abfd) != namlen)
d1290 1
a1290 1
      if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR_BIG, 1, abfd)
d1298 2
a1299 3
      hdrp = (struct xcoff_ar_hdr_big *) bfd_alloc (abfd,
						    SIZEOF_AR_HDR_BIG
						    + namlen + 1);
d1306 1
a1306 1
      if (bfd_read ((char *) hdrp + SIZEOF_AR_HDR_BIG, 1, namlen, abfd) != namlen)
d1322 1
a1322 1
  if (bfd_seek (abfd, (namlen & 1) + SXCOFFARFMAG, SEEK_CUR) != 0)
d1477 4
a1480 2
  if (bfd_write ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR
      || bfd_write (XCOFFARFMAG, 1, SXCOFFARFMAG, abfd) != SXCOFFARFMAG)
d1483 2
a1484 2
  bfd_h_put_32 (abfd, orl_count, buf);
  if (bfd_write (buf, 1, 4, abfd) != 4)
d1494 1
a1494 1
      while (((bfd *) (map[i]).pos) == sub)
d1496 2
a1497 2
	  bfd_h_put_32 (abfd, fileoff, buf);
	  if (bfd_write (buf, 1, 4, abfd) != 4)
d1502 1
a1502 1
      namlen = (namlen + 1) &~ 1;
d1518 1
a1518 1
      if (bfd_write (name, 1, namlen + 1, abfd) != namlen + 1)
d1527 1
a1527 1
      if (bfd_write (&b, 1, 1, abfd) != 1)
d1572 1
a1572 1
  
d1587 4
a1590 2
  if (bfd_write ((PTR) &hdr, SIZEOF_AR_HDR_BIG, 1, abfd) != SIZEOF_AR_HDR_BIG
      || bfd_write (XCOFFARFMAG, 1, SXCOFFARFMAG, abfd) != SXCOFFARFMAG)
d1593 2
a1594 2
  bfd_h_put_32 (abfd, orl_ccount, buf);
  if (bfd_write (buf, 1, 4, abfd) != 4)
d1604 2
a1605 2
      if ((bfd_arch_bits_per_address ((bfd *) map[i].pos) == 64) == bits64)
	while (((bfd *) (map[i]).pos) == sub)
d1607 2
a1608 2
	    bfd_h_put_32 (abfd, fileoff, buf);
	    if (bfd_write (buf, 1, 4, abfd) != 4)
d1613 1
a1613 1
	while (((bfd *) (map[i]).pos) == sub)
d1617 1
a1617 1
      namlen = (namlen + 1) &~ 1;
d1631 1
a1631 1
      bfd *ob = (bfd *)map[i].pos;
d1640 1
a1640 1
      if (bfd_write (name, 1, namlen + 1, abfd) != namlen + 1)
d1649 1
a1649 1
      if (bfd_write (&b, 1, 1, abfd) != 1)
d1679 1
a1679 1
      bfd *ob = (bfd *)map[i].pos;
d1703 1
a1703 1
				   stridx_32, false, 
d1712 1
a1712 1
    
d1738 2
a1739 2
  size_t count;
  size_t total_namlen;
d1743 1
a1743 1
  file_ptr prevoff, nextoff;
d1745 1
a1745 1
  unsigned int i;
d1767 1
a1767 1
  if (bfd_seek (abfd, SIZEOF_AR_FILE_HDR, SEEK_SET) != 0)
d1777 1
a1777 1
      size_t namlen;
d1815 2
a1816 1
	      sub->arelt_data = bfd_alloc (sub, sizeof (struct areltdata));
d1829 1
a1829 1
      namlen = (namlen + 1) &~ 1;
d1851 4
a1854 3
      if (bfd_write ((PTR) ahdrp, 1, SIZEOF_AR_HDR, abfd) != SIZEOF_AR_HDR
	  || bfd_write ((PTR) name, 1, namlen, abfd) != namlen
	  || (bfd_write ((PTR) XCOFFARFMAG, 1, SXCOFFARFMAG, abfd)
d1868 2
a1869 2
	  if (bfd_read (buffer, 1, amt, sub) != amt
	      || bfd_write (buffer, 1, amt, abfd) != amt)
d1879 1
a1879 1
	  if (bfd_write (&b, 1, 1, abfd) != 1)
d1919 3
a1921 2
  if (bfd_write ((PTR) &ahdr, 1, SIZEOF_AR_HDR, abfd) != SIZEOF_AR_HDR
      || (bfd_write ((PTR) XCOFFARFMAG, 1, SXCOFFARFMAG, abfd)
d1926 1
a1926 1
  if (bfd_write ((PTR) decbuf, 1, 12, abfd) != 12)
d1928 1
a1928 1
  for (i = 0; i < count; i++)
d1931 1
a1931 1
      if (bfd_write ((PTR) decbuf, 1, 12, abfd) != 12)
d1937 1
a1937 1
      size_t namlen;
d1941 1
a1941 1
      if (bfd_write ((PTR) name, 1, namlen + 1, abfd) != namlen + 1)
d1949 1
a1949 1
      if (bfd_write ((PTR) &b, 1, 1, abfd) != 1)
d1974 2
a1975 2
      || (bfd_write ((PTR) &fhdr, SIZEOF_AR_FILE_HDR, 1, abfd) !=
	  SIZEOF_AR_FILE_HDR))
d1986 2
a1987 2
  size_t count;
  size_t total_namlen;
d1991 1
a1991 1
  file_ptr prevoff, nextoff;
d1993 1
a1993 1
  unsigned int i;
d2015 1
a2015 1
  if (bfd_seek (abfd, SIZEOF_AR_FILE_HDR_BIG, SEEK_SET) != 0)
d2025 1
a2025 1
      size_t namlen;
d2068 2
a2069 1
	      sub->arelt_data = bfd_alloc (sub, sizeof (struct areltdata));
d2085 1
a2085 1
      namlen = (namlen + 1) &~ 1;
d2107 4
a2110 4
      if (bfd_write ((PTR) ahdrp, 1, SIZEOF_AR_HDR_BIG, abfd)
	  != SIZEOF_AR_HDR_BIG
	  || bfd_write ((PTR) name, 1, namlen, abfd) != namlen
	  || (bfd_write ((PTR) XCOFFARFMAG, 1, SXCOFFARFMAG, abfd)
d2124 2
a2125 2
	  if (bfd_read (buffer, 1, amt, sub) != amt
	      || bfd_write (buffer, 1, amt, abfd) != amt)
d2135 1
a2135 1
	  if (bfd_write (&b, 1, 1, abfd) != 1)
d2187 3
a2189 2
  if (bfd_write ((PTR) &ahdr, 1, SIZEOF_AR_HDR_BIG, abfd) != SIZEOF_AR_HDR_BIG
      || (bfd_write ((PTR) XCOFFARFMAG, 1, SXCOFFARFMAG, abfd)
d2194 1
a2194 1
  if (bfd_write ((PTR) decbuf, 1, 12, abfd) != 12)
d2196 1
a2196 1
  for (i = 0; i < count; i++)
d2199 1
a2199 1
      if (bfd_write ((PTR) decbuf, 1, 12, abfd) != 12)
d2209 2
a2210 1
      if (bfd_write ((PTR) name, 1, namlen + 1, abfd) != namlen + 1)
d2218 1
a2218 1
      if (bfd_write ((PTR) &b, 1, 1, abfd) != 1)
d2245 2
a2246 2
      || (bfd_write ((PTR) &fhdr, SIZEOF_AR_FILE_HDR_BIG, 1, abfd) !=
	  SIZEOF_AR_FILE_HDR_BIG))
d2316 1
a2316 1
  bfd_put_32 (abfd, src->l_version, dst->l_version);
d2364 3
a2366 2
      bfd_put_32 (abfd, 0, dst->_l._l_l._l_zeroes);
      bfd_put_32 (abfd, src->_l._l_l._l_offset, dst->_l._l_l._l_offset);
d2369 1
a2369 1
  bfd_put_16 (abfd, src->l_scnum, dst->l_scnum);
d2404 2
a2405 2
  bfd_put_16 (abfd, src->l_rtype, dst->l_rtype);
  bfd_put_16 (abfd, src->l_rsecnm, dst->l_rsecnm);
d2458 1
a2458 1
	{    
d2717 3
a2719 1
		bfd_put_32 (input_bfd, 0x80410014, pnext); /* lwz r1,20(r1) */
d2724 3
a2726 1
		bfd_put_32 (input_bfd, 0x60000000, pnext); /* ori r0,r0,0 */
d2791 1
a2791 1
	  size_t newalc;
d2811 2
a2812 2
      bfd_put_16 (ldinfo->output_bfd, len + 1,
				  ldinfo->strings + ldinfo->string_size);
d2823 1
a2823 1
_bfd_xcoff_put_symbol_name (bfd *abfd, struct bfd_strtab_hash *strtab, 
d2849 1
a2849 1
xcoff_create_csect_from_smclas (abfd, aux, symbol_name) 
d2862 1
a2862 1
    ".td", NULL, ".sv3264" 
d2868 1
a2868 1
      return_value = bfd_make_section_anyway 
d2882 1
a2882 1
static boolean 
d2893 1
a2893 1
static boolean 
d2917 1
a2917 1
  return bfd_xcoff_ldhdrsz(abfd) + 
d2923 6
a2928 6
HOWTO (0,	                /* type */                                 
       0,	                /* rightshift */                           
       2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
       32,	                /* bitsize */                   
       false,	                /* pc_relative */                          
       0,	                /* bitpos */                               
d2930 5
a2934 5
       0,		        /* special_function */                     
       "R_POS",               /* name */                                 
       true,	                /* partial_inplace */                      
       0xffffffff,            /* src_mask */                             
       0xffffffff,            /* dst_mask */                             
d2937 3
a2939 3
/*  glink 
 
   The first word of global linkage code must be modified by filling in 
d2956 1
a2956 1
static const struct xcoff_backend_data_rec bfd_xcoff_backend_data = 
d2960 1
a2960 1
      _bfd_xcoff_swap_sym_in,           /* _bfd_coff_swap_sym_in */ 
d2999 1
a2999 1
      NULL ,                            /* _bfd_coff_start_final_link */
d3002 1
a3002 1
      NULL ,                            /* _bfd_coff_addust_symndx */
d3011 1
a3011 1
  
d3076 1
a3076 1
  bfd_putb16,         /* bfd_putx16 */ 
d3088 1
a3088 1
  
d3090 3
a3092 3
    _bfd_dummy_target, 
    coff_object_p, 	
    _bfd_xcoff_archive_p, 
d3095 1
a3095 1
  
d3097 1
a3097 1
    bfd_false, 
d3099 1
a3099 1
    _bfd_generic_mkarchive, 
d3102 1
a3102 1
  
d3104 1
a3104 1
    bfd_false, 
d3106 1
a3106 1
    _bfd_xcoff_write_archive_contents, 
d3109 1
a3109 1
  
d3116 1
a3116 1
  _bfd_generic_get_section_contents_in_window, 
d3120 1
a3120 1
                                    /* _bfd_merge_private_bfd_data */ 
d3133 1
a3133 1
  coff_core_file_matches_executable_p, 
d3137 2
a3138 2
                                           /* XCOFF archives do not have 
					      anything which corresponds to 
d3149 1
a3149 1
                                           /* XCOFF archives do not have 
d3185 1
a3185 1
  bfd_generic_merge_sections,               /* _bfd_merge_sections */
d3189 1
a3189 1
  _bfd_xcoff_get_dynamic_symtab_upper_bound,  
d3196 1
a3196 1
  
d3201 1
a3201 1
/* 
d3204 1
a3204 1
 * Only difference between this target and the rs6000 target is the 
d3209 1
a3209 1
 * but they are always PowerPC architecture. 
d3211 1
a3211 1
static const struct xcoff_backend_data_rec bfd_pmac_xcoff_backend_data = 
d3215 1
a3215 1
    _bfd_xcoff_swap_sym_in,           /* _bfd_coff_swap_sym_in */ 
d3231 1
a3231 1
	FILNMLEN,                         /* _bfd_filnmlen */
d3246 1
a3246 1
    coff_slurp_symbol_table,     /* _bfd_coff_slurp_symbol_table */
d3255 2
a3256 2
    NULL ,                            /* _bfd_coff_start_final_link */
    xcoff_ppc_relocate_section,  /* _bfd_coff_relocate_section */
d3258 1
a3258 1
    NULL ,                            /* _bfd_coff_addust_symndx */
d3304 1
a3304 1
  
d3333 1
a3333 1
  bfd_putb16,         /* bfd_putx16 */ 
d3345 1
a3345 1
  
d3347 3
a3349 3
    _bfd_dummy_target, 
    coff_object_p, 	
    _bfd_xcoff_archive_p, 
d3352 1
a3352 1
  
d3354 1
a3354 1
    bfd_false, 
d3356 1
a3356 1
    _bfd_generic_mkarchive, 
d3359 1
a3359 1
  
d3361 1
a3361 1
    bfd_false, 
d3363 1
a3363 1
    _bfd_xcoff_write_archive_contents, 
d3366 1
a3366 1
  
d3373 1
a3373 1
  _bfd_generic_get_section_contents_in_window, 
d3377 1
a3377 1
                                    /* _bfd_merge_private_bfd_data */ 
d3390 1
a3390 1
  coff_core_file_matches_executable_p, 
d3394 2
a3395 2
                                           /* XCOFF archives do not have 
					      anything which corresponds to 
d3406 1
a3406 1
                                           /* XCOFF archives do not have 
d3446 1
a3446 1
  _bfd_xcoff_get_dynamic_symtab_upper_bound,  
d3453 1
a3453 1
  
@


1.23
log
@Add more missing prototypes
@
text
@d427 1
d431 2
a432 2
     bfd   *abfd;
     PTR 	inp;
d437 1
a437 1
     PTR	extp;
@


1.22
log
@	* libxcoff.h (struct xcoff_backend_data_rec): Constify src param
	of _xcoff_swap_ld*.
	* coff-rs6000.c (xcoff_swap_ldhdr_in): Modify type of external
	param to agree with libxcoff.h.
	(xcoff_swap_ldhdr_out): Likewise.
	(xcoff_swap_ldsym_in): Likewise.
	(xcoff_swap_ldsym_out): Likewise.
	(xcoff_swap_ldrel_in): Likewise.
	(xcoff_swap_ldrel_out): Likewise.
	(xcoff_create_csect_from_smclas): Likewise.
	* coff64-rs6000.c: Add missing prototypes.
	(xcoff64_swap_ldhdr_in): Modify type of external param to agree
	with libxcoff.h.
	(xcoff64_swap_ldhdr_out): Likewise.
	(xcoff64_swap_ldsym_in): Likewise.
	(xcoff64_swap_ldsym_out): Likewise.
	(xcoff64_swap_ldrel_in): Likewise.
	(xcoff64_swap_ldrel_out): Likewise.
	(xcoff64_ppc_relocate_section): Make static.
	(xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_sizeof_headers): Likewise.
	(xcoff64_is_lineno_count_overflow): Likewise.
	(xcoff64_is_reloc_count_overflow): Likewise.
	(xcoff64_loader_symbol_offset): Likewise.
	(xcoff64_loader_reloc_offset): Likewise.
	* elf64-gen.c: Add missing prototypes.
@
text
@d59 1
a59 1
/* Forward declare _bfd_xcoff_rtype2howto for coffcode.h macro */
d62 1
a62 1
/* coffcode.h needs these to be defined */
d252 1
a252 1
  struct internal_syment      *in = (struct internal_syment *)in1;
d254 10
a263 7
  if(ext->e.e_name[0] != 0) {
    memcpy(in->_n._n_name, ext->e.e_name, SYMNMLEN);
  } else {
    in->_n._n_n._n_zeroes = 0;
    in->_n._n_n._n_offset = 
      bfd_h_get_32(abfd, (bfd_byte *) ext->e.e.e_offset);
  }
d265 5
a269 5
  in->n_value = bfd_h_get_32(abfd, (bfd_byte *) ext->e_value); 
  in->n_scnum = bfd_h_get_16(abfd, (bfd_byte *) ext->e_scnum);
  in->n_type = bfd_h_get_16(abfd, (bfd_byte *) ext->e_type);
  in->n_sclass = bfd_h_get_8(abfd, ext->e_sclass);
  in->n_numaux = bfd_h_get_8(abfd, ext->e_numaux);
d281 10
a290 7
  if(in->_n._n_name[0] != 0) {
    memcpy(ext->e.e_name, in->_n._n_name, SYMNMLEN);
  } else {
    bfd_h_put_32(abfd, 0, (bfd_byte *) ext->e.e.e_zeroes);
    bfd_h_put_32(abfd, in->_n._n_n._n_offset, 
		 (bfd_byte *)  ext->e.e.e_offset);
  }
d292 5
a296 5
  bfd_h_put_32(abfd,  in->n_value , (bfd_byte *) ext->e_value);
  bfd_h_put_16(abfd,  in->n_scnum , (bfd_byte *) ext->e_scnum);
  bfd_h_put_16(abfd,  in->n_type , (bfd_byte *) ext->e_type);
  bfd_h_put_8(abfd,  in->n_sclass , ext->e_sclass);
  bfd_h_put_8(abfd,  in->n_numaux , ext->e_numaux);
d317 1
a317 1
  AUXENT    *ext = (AUXENT *)ext1;
d320 2
a321 1
  switch (class) {
d323 2
a324 1
      if (ext->x_file.x_fname[0] == 0) {
d327 15
a341 13
	   bfd_h_get_32(abfd, (bfd_byte *) ext->x_file.x_n.x_offset);
	} else {
	    if (numaux > 1)
	      {
		if (indx == 0)
		  memcpy (in->x_file.x_fname, ext->x_file.x_fname,
			  numaux * sizeof (AUXENT));
	      }
	    else
	      {
		memcpy (in->x_file.x_fname, ext->x_file.x_fname, FILNMLEN);
	      }
	  }
d368 2
a369 1
      if (type == T_NULL) {
a407 9
  if (ISFCN(type)) {
    in->x_sym.x_misc.x_fsize = bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_misc.x_fsize);
  }
  else {
    in->x_sym.x_misc.x_lnsz.x_lnno = bfd_h_get_16(abfd, (bfd_byte *)
	    ext->x_sym.x_misc.x_lnsz.x_lnno);
    in->x_sym.x_misc.x_lnsz.x_size = bfd_h_get_16(abfd, (bfd_byte *)
	    ext->x_sym.x_misc.x_lnsz.x_size);
  }
d409 11
a419 3
end: ;
  /* the semicolon is because MSVC doesn't like labels at
     end of block. */
d421 3
d444 12
a455 40
  case C_FILE:
    if (in->x_file.x_fname[0] == 0)
      {
      PUTWORD(abfd, 0, (bfd_byte *) ext->x_file.x_n.x_zeroes);
      PUTWORD(abfd,
	      in->x_file.x_n.x_offset,
	      (bfd_byte *) ext->x_file.x_n.x_offset);
    }
    else
      {
      memcpy (ext->x_file.x_fname, in->x_file.x_fname, FILNMLEN);
      }
    goto end;

  /* RS/6000 "csect" auxents */
  case C_EXT:
  case C_HIDEXT:
    if (indx + 1 == numaux)
      {
	PUTWORD (abfd, in->x_csect.x_scnlen.l,ext->x_csect.x_scnlen);
	PUTWORD (abfd, in->x_csect.x_parmhash,	ext->x_csect.x_parmhash);
	PUTHALF (abfd, in->x_csect.x_snhash,	ext->x_csect.x_snhash);
	/* We don't have to hack bitfields in x_smtyp because it's
	   defined by shifts-and-ands, which are equivalent on all
	   byte orders.  */
	PUTBYTE (abfd, in->x_csect.x_smtyp,	ext->x_csect.x_smtyp);
	PUTBYTE (abfd, in->x_csect.x_smclas,	ext->x_csect.x_smclas);
	PUTWORD (abfd, in->x_csect.x_stab,	ext->x_csect.x_stab);
	PUTHALF (abfd, in->x_csect.x_snstab,	ext->x_csect.x_snstab);
	goto end;
      }
    break;

  case C_STAT:
  case C_LEAFSTAT:
  case C_HIDDEN:
    if (type == T_NULL) {
      bfd_h_put_32(abfd, in->x_scn.x_scnlen, (bfd_byte *) ext->x_scn.x_scnlen);
      bfd_h_put_16(abfd, in->x_scn.x_nreloc, (bfd_byte *) ext->x_scn.x_nreloc);
      bfd_h_put_16(abfd, in->x_scn.x_nlinno, (bfd_byte *) ext->x_scn.x_nlinno);
d457 31
a488 2
    break;
  }
d490 1
a490 1
  PUTWORD(abfd, in->x_sym.x_tagndx.l, (bfd_byte *) ext->x_sym.x_tagndx);
d495 4
a498 4
      bfd_h_put_32(abfd,  in->x_sym.x_fcnary.x_fcn.x_lnnoptr, 
	      (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_lnnoptr);
      PUTWORD(abfd,  in->x_sym.x_fcnary.x_fcn.x_endndx.l, 
	      (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_endndx);
d517 4
a520 4
      bfd_h_put_16(abfd, in->x_sym.x_misc.x_lnsz.x_lnno, 
	      (bfd_byte *)ext->x_sym.x_misc.x_lnsz.x_lnno);
      bfd_h_put_16(abfd, in->x_sym.x_misc.x_lnsz.x_size, 
	      (bfd_byte *)ext->x_sym.x_misc.x_lnsz.x_size);
d1544 1
d1562 1
a1562 1
  const bfd_arch_info_type *arch_info;
d1571 10
a1580 7
  if (bits64) {
    sprintf (hdr.nextoff, "%d", 0);
  } else {
	  /* do explict cast to long to remove compiler warning */
	  sprintf (hdr.nextoff, "%ld", (strtol (prevoff, (char **) NULL, 10)
								   + (long) (4 + orl_ccount * 4 + stridx)));
  }
a1662 1
/*ARGSUSED*/
d1674 1
a1674 1
  const bfd_arch_info_type *arch_info;
d1705 1
a1705 1
  /* explicit cast to int for compiler */
a1722 1
/*ARGSUSED*/
a2265 1
/*ARGSUSED*/
d2508 11
a2518 11
			  && strcmp (sec->name, ".tc0") == 0) {
			  
			  val = xcoff_data (output_bfd)->toc;
	      } else {
			  
			  val = (sec->output_section->vma
					 + sec->output_offset
					 + sym->n_value
					 - sec->vma);
		  }
		  
a2752 1

d2821 10
a2830 1
			    const char *name) {
d2832 9
a2840 15
  if (strlen (name) <= SYMNMLEN) {
    strncpy (sym->_n._n_name, name, SYMNMLEN);
  } else {
    boolean hash;
    bfd_size_type indx;

    hash = true;
    if ((abfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
      hash = false;
    indx = _bfd_stringtab_add (strtab, name, hash, false);
    if (indx == (bfd_size_type) -1)
      return false;
    sym->_n._n_n._n_zeroes = 0;
    sym->_n._n_n._n_offset = STRING_SIZE_SIZE + indx;
  }
a2849 1

d2852 4
a2855 5
  /*
   * .sv64 = x_smclas == 17
   * This is an invalid csect for 32 bit apps.
   */
  static const char *names[19] = {
d2862 12
a2873 12
      (NULL != names[aux->x_csect.x_smclas])) {

    return_value = bfd_make_section_anyway 
      (abfd, names[aux->x_csect.x_smclas]);


  } else {
    (*_bfd_error_handler)
      (_("%s: symbol `%s' has unrecognized smclas %d"),
       bfd_get_filename (abfd), symbol_name, aux->x_csect.x_smclas);
    bfd_set_error (bfd_error_bad_value);
  }
d2883 1
a2883 1
  if (0xffff <= value) {
d2885 1
a2885 1
  }
d2894 1
a2894 1
  if (0xffff <= value) {
d2896 1
a2896 1
  }
d2903 1
a2903 1
	struct internal_ldhdr *ldhdr ATTRIBUTE_UNUSED;
d2911 1
a2911 1
	struct internal_ldhdr *ldhdr;
d2933 5
a2937 6
/* 
 * glink 
 *
 * The first word of global linkage code must be modified by filling in 
 * the correct TOC offset.  
 */
d2939 11
a2949 11
{
  0x81820000,	/* lwz r12,0(r2) */
  0x90410014,	/* stw r2,20(r1) */
  0x800c0000,	/* lwz r0,0(r12) */
  0x804c0004,	/* lwz r2,4(r12) */
  0x7c0903a6,	/* mtctr r0 */
  0x4e800420,	/* bctr */
  0x00000000,	/* start of traceback table */
  0x000c8000,	/* traceback table */
  0x00000000,	/* traceback table */
};
d2953 54
a3006 93
{
  { /* COFF backend, defined in libcoff.h */
    _bfd_xcoff_swap_aux_in,           /* _bfd_coff_swap_aux_in */
    _bfd_xcoff_swap_sym_in,           /* _bfd_coff_swap_sym_in */ 
    coff_swap_lineno_in,              /* _bfd_coff_swap_lineno_in */
    _bfd_xcoff_swap_aux_out,          /* _bfd_swap_aux_out */
    _bfd_xcoff_swap_sym_out,          /* _bfd_swap_sym_out */
    coff_swap_lineno_out,             /* _bfd_swap_lineno_out */
    coff_swap_reloc_out,              /* _bfd_swap_reloc_out */
    coff_swap_filehdr_out,            /* _bfd_swap_filehdr_out */
    coff_swap_aouthdr_out,            /* _bfd_swap_aouthdr_out */
    coff_swap_scnhdr_out,             /* _bfd_swap_scnhdr_out */
    FILHSZ,                           /* _bfd_filhsz */
    AOUTSZ,                           /* _bfd_aoutsz */
    SCNHSZ,                           /* _bfd_scnhsz */
    SYMESZ,                           /* _bfd_symesz */
    AUXESZ,                           /* _bfd_auxesz */
    RELSZ,                            /* _bfd_relsz */
    LINESZ,                           /* _bfd_linesz */
	FILNMLEN,                         /* _bfd_filnmlen */
    true,                             /* _bfd_coff_long_filenames */
    false,                            /* _bfd_coff_long_section_names */
    (3),                        /* _bfd_coff_default_section_alignment_power */
    false,                            /* _bfd_coff_force_symnames_in_strings */
    2,                               /* _bfd_coff_debug_string_prefix_length */
    coff_swap_filehdr_in,             /* _bfd_coff_swap_filehdr_in */
    coff_swap_aouthdr_in,             /* _bfd_swap_aouthdr_in */
    coff_swap_scnhdr_in,              /* _bfd_swap_scnhdr_in */
    coff_swap_reloc_in,               /* _bfd_reloc_in */
    coff_bad_format_hook,             /* _bfd_bad_format_hook */
    coff_set_arch_mach_hook,          /* _bfd_set_arch_mach_hook */
    coff_mkobject_hook,               /* _bfd_mkobject_hook */
    styp_to_sec_flags,                /* _bfd_syp_to_sec_flags */
    coff_set_alignment_hook,          /* _bfd_set_alignment_hook */
    coff_slurp_symbol_table,     /* _bfd_coff_slurp_symbol_table */
    symname_in_debug_hook,            /* _coff_symname_in_debug_hook */
    coff_pointerize_aux_hook,         /* _bfd_coff_pointerize_aux_hook */
    coff_print_aux,                   /* bfd_coff_print_aux */
    dummy_reloc16_extra_cases,        /* _bfd_coff_reloc16_extra_cases */
    dummy_reloc16_estimate,           /* _bfd_coff_reloc16_estimate */
    NULL,                             /* bfd_coff_sym_is_global */
                                 /* _bfd_coff_compute_section_file_positions */
    coff_compute_section_file_positions,
    NULL ,                            /* _bfd_coff_start_final_link */
    xcoff_ppc_relocate_section,  /* _bfd_coff_relocate_section */
    coff_rtype_to_howto,              /* _bfd_coff_rtype_to_howto */
    NULL ,                            /* _bfd_coff_addust_symndx */
    _bfd_generic_link_add_one_symbol, /* _bfd_coff_add_one_symbol */
    coff_link_output_has_begun,       /* _bfd_coff_link_output_has_begun */
    coff_final_link_postscript        /* _bfd_coff_final_link_postscript */
  },

  0x01DF,                             /* magic number */
  bfd_arch_rs6000,                    /* architecture */
  bfd_mach_rs6k,                      /* machine */
  

  /* function pointers to xcoff specific swap routines */
  xcoff_swap_ldhdr_in,                /* _xcoff_swap_ldhdr_in */
  xcoff_swap_ldhdr_out,               /* _xcoff_swap_ldhdr_out */
  xcoff_swap_ldsym_in,                /* _xcoff_swap_ldsym_in */
  xcoff_swap_ldsym_out,               /* _xcoff_swap_ldsym_out */
  xcoff_swap_ldrel_in,                /* _xcoff_swap_ldrel_in */
  xcoff_swap_ldrel_out,               /* _xcoff_swap_ldrel_out */

  /* sizes */
  LDHDRSZ,                            /* _xcoff_ldhdrsz */
  LDSYMSZ,                            /* _xcoff_ldsymsz */
  LDRELSZ,                            /* _xcoff_ldrelsz */
  12,                                 /* _xcoff_function_descriptor_size */
  SMALL_AOUTSZ,                       /* _xcoff_small_aout_header_size */

  /* versions */
  1,                                    /* _xcoff_ldhdr_version */

  /* xcoff vs xcoff64 putting symbol names */
  _bfd_xcoff_put_symbol_name,          /* _xcoff_put_symbol_name */
  _bfd_xcoff_put_ldsymbol_name,          /* _xcoff_put_ldsymbol_name */

  &xcoff_dynamic_reloc,                  /* dynamic reloc howto */

  xcoff_create_csect_from_smclas,      /* _xcoff_create_csect_from_smclas */

  /* lineno and reloc count overflow */
  xcoff_is_lineno_count_overflow,
  xcoff_is_reloc_count_overflow,

  xcoff_loader_symbol_offset,
  xcoff_loader_reloc_offset,

  /* glink */
  &xcoff_glink_code[0],
  (36),           /* _xcoff_glink_size */
d3008 36
@


1.21
log
@	* coff-rs6000.c: Add missing prototypes.
	(xcoff_ppc_relocate_section, xcoff_is_lineno_count_overflow,
	xcoff_is_reloc_count_overflow, xcoff_loader_symbol_offset,
	xcoff_loader_reloc_offset): Make static.
	* dwarf1.c: Add missing prototypes.
	* dwarf2.c: Add missing prototypes.
	(struct abbrev_info): Move definition.
	(struct attr_abbrev, ABBREV_HASH_SIZE, ATTR_ALLOC_CHUNK): Likewise.
	* elf.c: Add missing prototypes.
	* elf32-gen.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-ppc.c: Likewise.
	(ppc_elf_sort_rela): Use PTR instead of "void *".
	* elflink.h: Add missing prototypes.  Formatting fixes.
	* merge.c: Add missing prototypes.
	(last4_eq): Use PTR instead of "void *".
	(last_eq): Likewise.
	* syms.c: Add missing prototypes.
@
text
@d124 1
a124 1
  PARAMS ((bfd *, const struct external_ldhdr *, struct internal_ldhdr *));
d126 1
a126 1
  PARAMS ((bfd *, const struct internal_ldhdr *, struct external_ldhdr *));
d128 1
a128 1
  PARAMS ((bfd *, const struct external_ldsym *, struct internal_ldsym *));
d130 1
a130 1
  PARAMS ((bfd *, const struct internal_ldsym *, struct external_ldsym *));
d132 1
a132 1
  PARAMS ((bfd *, const struct external_ldrel *, struct internal_ldrel *));
d134 1
a134 1
  PARAMS ((bfd *, const struct internal_ldrel *, struct external_ldrel *));
d142 1
a142 1
  PARAMS ((bfd *, union internal_auxent *, char *));
d2275 1
a2275 1
xcoff_swap_ldhdr_in (abfd, src, dst)
d2277 1
a2277 1
     const struct external_ldhdr *src;
d2280 2
d2295 1
a2295 1
xcoff_swap_ldhdr_out (abfd, src, dst)
d2298 1
a2298 1
     struct external_ldhdr *dst;
d2300 2
d2315 1
a2315 1
xcoff_swap_ldsym_in (abfd, src, dst)
d2317 1
a2317 1
     const struct external_ldsym *src;
d2320 2
d2339 1
a2339 1
xcoff_swap_ldsym_out (abfd, src, dst)
d2342 1
a2342 1
     struct external_ldsym *dst;
d2344 1
d2364 1
a2364 1
xcoff_swap_ldrel_in (abfd, src, dst)
d2366 1
a2366 1
     const struct external_ldrel *src;
d2369 2
d2380 1
a2380 1
xcoff_swap_ldrel_out (abfd, src, dst)
d2383 1
a2383 1
     struct external_ldrel *dst;
d2385 2
d2831 1
a2831 1
     char *symbol_name;
@


1.20
log
@2001-05-25  H.J. Lu  <hjl@@gnu.org>

	* coff-rs6000.c (rs6000coff_vec): Use rs6000coff_core_p,
	rs6000coff_core_file_matches_executable_p,
	rs6000coff_core_file_failing_command and
	rs6000coff_core_file_failing_signal only if AIX_CORE is
	defined.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
@
text
@d114 35
d2388 1
a2388 1
boolean
d2852 1
a2852 1
boolean 
d2863 1
a2863 1
boolean 
d2874 1
a2874 1
bfd_vma
d2882 1
a2882 1
bfd_vma
a3430 1

@


1.19
log
@Support for xcoff64
@
text
@a39 4
extern const bfd_target * rs6000coff_core_p ();
extern boolean rs6000coff_core_file_matches_executable_p ();
extern char *rs6000coff_core_file_failing_command PARAMS ((bfd *abfd));
extern int rs6000coff_core_file_failing_signal PARAMS ((bfd *abfd));
d83 5
d89 15
d3069 2
a3070 2
  rs6000coff_core_file_failing_command,    /* _core_file_failing_command */
  rs6000coff_core_file_failing_signal,     /* _core_file_failing_signal */
d3072 1
a3072 1
  rs6000coff_core_file_matches_executable_p, 
d3326 2
a3327 2
  rs6000coff_core_file_failing_command,    /* _core_file_failing_command */
  rs6000coff_core_file_failing_signal,     /* _core_file_failing_signal */
d3329 1
a3329 1
  rs6000coff_core_file_matches_executable_p, 
@


1.18
log
@Update copyright notices
@
text
@d32 1
d35 1
d38 56
a93 3
#define TARGET_NAME "aixcoff-rs6000"
#define TARGET_SYM rs6000coff_vec
#include "xcoff-target.h"
d128 3
d192 2
d203 7
a209 10
  if (ext->e.e_name[0] != 0)
    {
      memcpy(in->_n._n_name, ext->e.e_name, SYMNMLEN);
    }
  else
    {
      in->_n._n_n._n_zeroes = 0;
      in->_n._n_n._n_offset =
	  bfd_h_get_32(abfd, (bfd_byte *) ext->e.e.e_offset);
    }
d211 1
a211 1
  in->n_value = bfd_h_get_32(abfd, (bfd_byte *) ext->e_value);
d227 7
a233 10
  if (in->_n._n_name[0] != 0)
    {
      memcpy(ext->e.e_name, in->_n._n_name, SYMNMLEN);
    }
  else
    {
      bfd_h_put_32(abfd, 0, (bfd_byte *) ext->e.e.e_zeroes);
      bfd_h_put_32(abfd, in->_n._n_n._n_offset,
	      (bfd_byte *)  ext->e.e.e_offset);
    }
d267 1
a267 1
	  in->x_file.x_n.x_offset =
d288 1
a288 1
	  in->x_csect.x_scnlen.l =
d308 1
a308 1
	  in->x_scn.x_scnlen = bfd_h_get_32(abfd,
d310 1
a310 1
	  in->x_scn.x_nreloc = bfd_h_get_16(abfd,
d312 1
a312 1
	  in->x_scn.x_nlinno = bfd_h_get_16(abfd,
d358 1
a358 1
     end of block.  */
d362 2
d430 1
a430 1
      bfd_h_put_32(abfd,  in->x_sym.x_fcnary.x_fcn.x_lnnoptr,
d432 1
a432 1
      PUTWORD(abfd,  in->x_sym.x_fcnary.x_fcn.x_endndx.l,
d452 1
a452 1
      bfd_h_put_16(abfd, in->x_sym.x_misc.x_lnsz.x_lnno,
d454 1
a454 1
      bfd_h_put_16(abfd, in->x_sym.x_misc.x_lnsz.x_size,
d461 2
a469 3
/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE       (((bfd_vma)0) - 1)
d813 1
a829 49
/* These are the first two like the above but for 16-bit relocs.  */
static reloc_howto_type xcoff_howto_table_16[] =
{
  /* Standard 16 bit relocation.  */
  HOWTO (0,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_POS_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false),                /* pcrel_offset */

  /* 16 bit relocation, but store negative value.  */
  HOWTO (1,	                /* type */
	 0,	                /* rightshift */
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_NEG_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false),                /* pcrel_offset */

  /* 16 bit PC relative relocation.  */
  HOWTO (2,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 true,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_REL_16",            /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false)                /* pcrel_offset */
  };

d837 6
a842 4
  if (relent->howto->bitsize != ((unsigned int) internal->r_size & 0x1f) + 1
      && (internal->r_type
	  < sizeof (xcoff_howto_table_16)/sizeof (xcoff_howto_table_16[0])))
    relent->howto = xcoff_howto_table_16 + internal->r_type;
d850 1
a850 1
      && (relent->howto->bitsize
d883 1
a929 18
#define XCOFFARMAG    "<aiaff>\012"
#define XCOFFARMAGBIG "<bigaf>\012"
#define SXCOFFARMAG   8

/* This terminates an XCOFF archive member name.  */

#define XCOFFARFMAG "`\012"
#define SXCOFFARFMAG 2

/* XCOFF archives start with this (printable) structure.  */

struct xcoff_ar_file_hdr
{
  /* Magic string.  */
  char magic[SXCOFFARMAG];

  /* Offset of the member table (decimal ASCII string).  */
  char memoff[12];
a930 143
  /* Offset of the global symbol table (decimal ASCII string).  */
  char symoff[12];

  /* Offset of the first member in the archive (decimal ASCII string).  */
  char firstmemoff[12];

  /* Offset of the last member in the archive (decimal ASCII string).  */
  char lastmemoff[12];

  /* Offset of the first member on the free list (decimal ASCII
     string).  */
  char freeoff[12];
};

#define SIZEOF_AR_FILE_HDR (5 * 12 + SXCOFFARMAG)

/* This is the equivalent data structure for the big archive format.  */

struct xcoff_ar_file_hdr_big
{
  /* Magic string.  */
  char magic[SXCOFFARMAG];

  /* Offset of the member table (decimal ASCII string).  */
  char memoff[20];

  /* Offset of the global symbol table for 32-bit objects (decimal ASCII
     string).  */
  char symoff[20];

  /* Offset of the global symbol table for 64-bit objects (decimal ASCII
     string).  */
  char symoff64[20];

  /* Offset of the first member in the archive (decimal ASCII string).  */
  char firstmemoff[20];

  /* Offset of the last member in the archive (decimal ASCII string).  */
  char lastmemoff[20];

  /* Offset of the first member on the free list (decimal ASCII
     string).  */
  char freeoff[20];
};

#define SIZEOF_AR_FILE_HDR_BIG (6 * 20 + SXCOFFARMAG)

/* Each XCOFF archive member starts with this (printable) structure.  */

struct xcoff_ar_hdr
{
  /* File size not including the header (decimal ASCII string).  */
  char size[12];

  /* File offset of next archive member (decimal ASCII string).  */
  char nextoff[12];

  /* File offset of previous archive member (decimal ASCII string).  */
  char prevoff[12];

  /* File mtime (decimal ASCII string).  */
  char date[12];

  /* File UID (decimal ASCII string).  */
  char uid[12];

  /* File GID (decimal ASCII string).  */
  char gid[12];

  /* File mode (octal ASCII string).  */
  char mode[12];

  /* Length of file name (decimal ASCII string).  */
  char namlen[4];

  /* This structure is followed by the file name.  The length of the
     name is given in the namlen field.  If the length of the name is
     odd, the name is followed by a null byte.  The name and optional
     null byte are followed by XCOFFARFMAG, which is not included in
     namlen.  The contents of the archive member follow; the number of
     bytes is given in the size field.  */
};

#define SIZEOF_AR_HDR (7 * 12 + 4)

/* The equivalent for the big archive format.  */

struct xcoff_ar_hdr_big
{
  /* File size not including the header (decimal ASCII string).  */
  char size[20];

  /* File offset of next archive member (decimal ASCII string).  */
  char nextoff[20];

  /* File offset of previous archive member (decimal ASCII string).  */
  char prevoff[20];

  /* File mtime (decimal ASCII string).  */
  char date[12];

  /* File UID (decimal ASCII string).  */
  char uid[12];

  /* File GID (decimal ASCII string).  */
  char gid[12];

  /* File mode (octal ASCII string).  */
  char mode[12];

  /* Length of file name (decimal ASCII string).  */
  char namlen[4];

  /* This structure is followed by the file name.  The length of the
     name is given in the namlen field.  If the length of the name is
     odd, the name is followed by a null byte.  The name and optional
     null byte are followed by XCOFFARFMAG, which is not included in
     namlen.  The contents of the archive member follow; the number of
     bytes is given in the size field.  */
};

#define SIZEOF_AR_HDR_BIG (3 * 20 + 4 * 12 + 4)

/* We often have to distinguish between the old and big file format.
   Make it a bit cleaner.  We can use `xcoff_ardata' here because the
   `hdr' member has the same size and position in both formats.  */
#define xcoff_big_format_p(abfd) \
  (xcoff_ardata (abfd)->magic[1] == 'b')

/* We store a copy of the xcoff_ar_file_hdr in the tdata field of the
   artdata structure.  Similar for the big archive.  */
#define xcoff_ardata(abfd) \
  ((struct xcoff_ar_file_hdr *) bfd_ardata (abfd)->tdata)
#define xcoff_ardata_big(abfd) \
  ((struct xcoff_ar_file_hdr_big *) bfd_ardata (abfd)->tdata)

/* We store a copy of the xcoff_ar_hdr in the arelt_data field of an
   archive element.  Similar for the big archive.  */
#define arch_eltdata(bfd) ((struct areltdata *) ((bfd)->arelt_data))
#define arch_xhdr(bfd) \
  ((struct xcoff_ar_hdr *) arch_eltdata (bfd)->arch_header)
#define arch_xhdr_big(bfd) \
  ((struct xcoff_ar_hdr_big *) arch_eltdata (bfd)->arch_header)
d987 1
a987 1

d993 1
a993 1

d998 1
a998 1

d1050 1
a1050 1

d1055 1
a1055 1

d1392 1
a1493 1
  const bfd_arch_info_type *arch_info = NULL;
d1496 1
d1505 1
a1505 1
  if (bits64)
d1507 6
a1512 3
  else
    sprintf (hdr.nextoff, "%ld", (strtol (prevoff, (char **) NULL, 10)
				 + 4 + orl_ccount * 4 + stridx));
d1573 1
a1573 2

      if (arch_info && (arch_info->bits_per_address == 64) != bits64)
d1594 1
d1606 1
a1606 1
  const bfd_arch_info_type *arch_info = NULL;
d1623 1
a1623 1
      if (arch_info && arch_info->bits_per_address == 64)
d1635 1
a1635 1
  /* A quick sanity check...  */
d1637 2
a1638 1
  BFD_ASSERT (stridx_64 + stridx_32 == stridx);
d1642 1
a1642 1
				   stridx_32, false,
d1651 1
a1651 1

d1655 1
d2199 1
d2215 1166
@


1.17
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
@


1.17.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
@


1.16
log
@Fixes to allow sources to compile under Solaris 2.8
@
text
@a132 1

a403 1

a872 1

@


1.15
log
@2000-11-21  Kazu Hirata  <kazu@@hxi.com>

	* coff-a29k.c: Fix formatting.
	* coff-h8500.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-w65.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-hppa.c: Likewise.
	* cpu-ns32k.c: Likewise.
@
text
@d1646 1
a1648 1
  const bfd_arch_info_type *arch_info;
d1660 1
a1660 1
    sprintf (hdr.nextoff, "%d", (strtol (prevoff, (char **) NULL, 10)
d1722 2
a1723 1
      if ((arch_info->bits_per_address == 64) != bits64)
d1755 1
a1755 1
  const bfd_arch_info_type *arch_info;
d1772 1
a1772 1
      if (arch_info->bits_per_address == 64)
@


1.14
log
@2000-11-15  Kazu Hirata  <kazu@@hxi.com>

	* coff-rs6000.c: Fix formatting.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* coff-we32k.c: Likewise.
	* coff-z8k.c: Likewise.
@
text
@d143 1
a143 1
  if(ext->e.e_name[0] != 0)
d170 1
a170 1
  if(in->_n._n_name[0] != 0)
@


1.13
log
@2000-11-15  Kazu Hirata  <kazu@@hxi.com>

	* coff-arm.c: Fix formatting.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
@
text
@a1544 1
/*ARGSUSED*/
a1742 1
/*ARGSUSED*/
a1801 1
/*ARGSUSED*/
a2344 1
/*ARGSUSED*/
a2359 2


@


1.12
log
@	* xcofflink.c (xcoff_link_input_bfd): Include the .tocbss
 	pseduo-section when determining where the TOC ends.

	* coff-rs6000.c (_bfd_xcoff_swap_aux_out): Use bfd_h_put_16 to
	output x_tvndx as it is only two bytes wide.

	* coff-rs6000.c (xcoff_howto_table): A modifiable branch-absolute
        reloc is 26 or 32 bits wide.

	* coff-rs6000.c (_bfd_xcoff_rtype2howto): The bitsize is irrelevant
        for relocs that don't change anything.  Also look at the full
        6 bits of bitsize.
@
text
@d8 1
a8 1
   Written by Metin G. Ozisik, Mimi Ph\373\364ng-Th\345o V\365, 
a28 1

a38 1

a133 1

a142 1

d147 1
a147 1
  else 
d150 1
a150 1
      in->_n._n_n._n_offset = 
d154 1
a154 1
  in->n_value = bfd_h_get_32(abfd, (bfd_byte *) ext->e_value); 
d177 1
a177 1
      bfd_h_put_32(abfd, in->_n._n_n._n_offset, 
d213 1
a213 1
	  in->x_file.x_n.x_offset = 
d234 1
a234 1
	  in->x_csect.x_scnlen.l = 
d254 1
a254 1
	  in->x_scn.x_scnlen = bfd_h_get_32(abfd, 
d256 1
a256 1
	  in->x_scn.x_nreloc = bfd_h_get_16(abfd, 
d258 1
a258 1
	  in->x_scn.x_nlinno = bfd_h_get_16(abfd, 
d304 1
a304 1
     end of block. */
a307 2


d374 1
a374 1
      bfd_h_put_32(abfd,  in->x_sym.x_fcnary.x_fcn.x_lnnoptr, 
d376 1
a376 1
      PUTWORD(abfd,  in->x_sym.x_fcnary.x_fcn.x_endndx.l, 
d396 1
a396 1
      bfd_h_put_16(abfd, in->x_sym.x_misc.x_lnsz.x_lnno, 
d398 1
a398 1
      bfd_h_put_16(abfd, in->x_sym.x_misc.x_lnsz.x_size, 
a405 1

d420 12
a431 12
  HOWTO (0,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_POS",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d435 12
a446 12
  HOWTO (1,	                /* type */                                 
	 0,	                /* rightshift */                           
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_NEG",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d450 6
a455 6
  HOWTO (2,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 true,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d457 5
a461 5
	 0,		        /* special_function */                     
	 "R_REL",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d463 1
a463 1
  
d465 12
a476 12
  HOWTO (3,	                /* type */                                 
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_TOC",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d478 1
a478 1
  
d480 12
a491 12
  HOWTO (4,	                /* type */                                 
	 1,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RTB",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d493 1
a493 1
  
d495 12
a506 12
  HOWTO (5,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_GL",                /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d508 1
a508 1
  
d510 12
a521 12
  HOWTO (6,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_TCL",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d523 1
a523 1
  
d525 1
a525 1
  
d527 12
a538 12
  HOWTO (8,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 26,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_BA",                /* name */                                 
	 true,	                /* partial_inplace */                      
	 0x3fffffc,	        /* src_mask */                             
	 0x3fffffc,        	/* dst_mask */                             
d540 1
a540 1
  
d544 6
a549 6
  HOWTO (0xa,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 26,	                /* bitsize */                   
	 true,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d551 5
a555 5
	 0,		        /* special_function */                     
	 "R_BR",                /* name */                                 
	 true,	                /* partial_inplace */                      
	 0x3fffffc,	        /* src_mask */                             
	 0x3fffffc,        	/* dst_mask */                             
d557 1
a557 1
  
d561 12
a572 12
  HOWTO (0xc,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RL",                /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d574 1
a574 1
  
d576 12
a587 12
  HOWTO (0xd,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RLA",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d589 1
a589 1
  
d591 1
a591 1
  
d593 12
a604 12
  HOWTO (0xf,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_REF",               /* name */                                 
	 false,	                /* partial_inplace */                      
	 0,		        /* src_mask */                             
	 0,     	   	/* dst_mask */                             
d606 1
a606 1
  
d609 1
a609 1
  
d611 12
a622 12
  HOWTO (0x12,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_TRL",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d624 1
a624 1
  
d626 12
a637 12
  HOWTO (0x13,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_TRLA",              /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d639 1
a639 1
  
d641 12
a652 12
  HOWTO (0x14,	                /* type */                                 
	 1,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RRTBI",             /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d654 1
a654 1
  
d656 12
a667 12
  HOWTO (0x15,	                /* type */                                 
	 1,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RRTBA",             /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d669 1
a669 1
  
d671 12
a682 12
  HOWTO (0x16,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_CAI",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d684 1
a684 1
  
d686 12
a697 12
  HOWTO (0x17,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_CREL",              /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d699 1
a699 1
  
d701 12
a712 12
  HOWTO (0x18,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 26,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RBA",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d714 1
a714 1
  
d716 12
a727 12
  HOWTO (0x19,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RBAC",              /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d729 1
a729 1
  
d731 6
a736 6
  HOWTO (0x1a,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 26,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d738 5
a742 5
	 0,		        /* special_function */                     
	 "R_RBR",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d744 1
a744 1
  
d746 12
a757 12
  HOWTO (0x1b,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_RBRC",              /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d779 12
a790 12
  HOWTO (0,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_POS_16",            /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d794 12
a805 12
  HOWTO (1,	                /* type */                                 
	 0,	                /* rightshift */                           
	 -2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */                     
	 "R_NEG_16",            /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d809 6
a814 6
  HOWTO (2,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 true,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d816 5
a820 5
	 0,		        /* special_function */                     
	 "R_REL_16",            /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d823 1
a823 1
  
d832 2
a833 2
      && (internal->r_type 
	  < sizeof(xcoff_howto_table_16)/sizeof(xcoff_howto_table_16[0])))
d839 5
a843 5
     type matches this information.  The bitsize is not significant 
     for R_REF relocs.  */ 
  if (relent->howto->dst_mask != 0 
      && (relent->howto->bitsize  
	  != ((unsigned int) internal->r_size & 0x3f) + 1)) 
a987 1

a1063 1

d1140 1
a1140 1
      
d1146 1
a1146 1
      
d1151 1
a1151 1
      
d1203 1
a1203 1
      
d1208 1
a1208 1
      
d1785 1
a1785 1
  /* A quick sanity check... */
d1791 1
a1791 1
				   stridx_32, false, 
d1800 1
a1800 1
    
@


1.11
log
@* xcofflink.c (_bfd_ppc_xcoff_relocate_section): Add ori r0,r0,0
to the list of NOPs we recognize after a branch-and-link.
Use the ori NOP when one is needed.

* coff-rs6000.c (_bfd_xcoff_slurp_armap): Finish implementation
for large archives.
@
text
@d376 1
a376 1
  PUTWORD(abfd, in->x_sym.x_tvndx , (bfd_byte *) ext->x_sym.x_tvndx);
d711 1
a711 1
	 16,	                /* bitsize */                   
d726 1
a726 1
	 16,	                /* bitsize */                   
d846 5
a850 2
     type matches this information.  */
  if (relent->howto->bitsize != ((unsigned int) internal->r_size & 0x1f) + 1)
@


1.10
log
@* coff-rs6000.c (xcoff_write_one_armap_big): New procedure.
(xcoff_write_armap_big): Write both 32-bit and 64-bit armaps.
(xcoff_write_archive_contents_big): Don't update the offset
of the symbol table, xcoff_write_armap will do it.
@
text
@d1101 1
a1101 1
  unsigned int c, i;
d1136 27
a1192 1
    }
d1194 6
a1199 6
  /* Read in the entire symbol table.  */
  contents = (bfd_byte *) bfd_alloc (abfd, sz);
  if (contents == NULL)
    return false;
  if (bfd_read ((PTR) contents, 1, sz, abfd) != sz)
    return false;
d1201 2
a1202 2
  /* The symbol table starts with a four byte count.  */
  c = bfd_h_get_32 (abfd, contents);
d1204 16
a1219 4
  if (c * 4 >= sz)
    {
      bfd_set_error (bfd_error_bad_value);
      return false;
a1220 11

  bfd_ardata (abfd)->symdefs = ((carsym *)
				bfd_alloc (abfd, c * sizeof (carsym)));
  if (bfd_ardata (abfd)->symdefs == NULL)
    return false;

  /* After the count comes a list of four byte file offsets.  */
  for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 4;
       i < c;
       ++i, ++arsym, p += 4)
    arsym->file_offset = bfd_h_get_32 (abfd, p);
@


1.9
log
@	* xcoff.h: Rename to xcoff-target.h
	* Makefile.am: Change all instances of xcoff.h to xcoff-target.h
	* coff-rs6000.c: Ditto.
	* coff64-rs6000.c: Ditto.
	* coff-pmac.c: Ditto.
	* Makefile.in: Regenerate.
@
text
@d1610 1
a1610 1
/*ARGSUSED*/
d1612 2
a1613 1
xcoff_write_armap_big (abfd, elength, map, orl_count, stridx)
a1614 1
     unsigned int elength ATTRIBUTE_UNUSED;
d1617 5
a1621 1
     int stridx;
d1628 2
d1636 7
a1642 3
  sprintf (hdr.size, "%ld", (long) (4 + orl_count * 4 + stridx));
  sprintf (hdr.nextoff, "%d", 0);
  memcpy (hdr.prevoff, xcoff_ardata (abfd)->memoff, 12);
d1654 2
d1660 1
a1660 1
  bfd_h_put_32 (abfd, orl_count, buf);
d1671 12
a1682 7
      while (((bfd *) (map[i]).pos) == sub)
	{
	  bfd_h_put_32 (abfd, fileoff, buf);
	  if (bfd_write (buf, 1, 4, abfd) != 4)
	    return false;
	  ++i;
	}
d1693 1
d1698 6
d1724 60
a2293 1
      sprintf (fhdr.symoff, "%ld", (long) nextoff);
@


1.8
log
@	* Makefile.am (BFD64_BACKENDS, BFD64_BACKENDS_CFILES): Add
	coffdu-rs6000.{lo,c}.
	(coff-pmac.lo, coff-rs6000.lo, coff64-rs6000.lo): Add dependency
	on xcoff.h
	* Makefile.in: Regenerate.
	* xcoff.h: New file.
	* coff-pmac.c: Use xcoff.h instead of coff-rs6000.c.
	* coff-rs6000.c: Move all declarations and defines that are
	common to the xcoff backends into xcoff.h
	* coff64-rs6000.c: Ditto,
@
text
@d38 1
a38 1
#include "xcoff.h"
@


1.7
log
@	Add XCOFF64 support.

	bfd:
	* Makefile.am (coff64-rs6000.lo): New rule.
	* Makefile.in: Regenerate.
	* coff-rs6000.c (xcoff_mkobject, xcoff_copy_private_bfd_data,
	xcoff_is_local_label_name, xcoff_rtype2howto,
	xcoff_reloc_type_lookup, xcoff_slurp_armap, xcoff_archive_p,
	xcoff_read_ar_hdr, xcoff_openr_next_archived_file, xcoff_write_armap,
	xcoff_write_archive_contents): No longer static, and prefix with _bfd_.
	(NO_COFF_SYMBOLS): Define.
	(xcoff64_swap_sym_in, xcoff64_swap_sym_out, xcoff64_swap_aux_in,
	xcoff64_swap_aux_out): New functions; handle xcoff symbol tables
	internally.
	(MINUS_ONE): New macro.
	(xcoff_howto_tabl, xcoff_reloc_type_lookup): Add 64 bit POS
	relocation.
	(coff_SWAP_sym_in, coff_SWAP_sym_out, coff_SWAP_aux_in,
	coff_SWAP_aux_out): Map to the new functions.
	* coff64-rs6000.c: New file.
	* libcoff.h (bfd_coff_backend_data): Add new fields
	_bfd_coff_force_symnames_in_strings and
	_bfd_coff_debug_string_prefix_length.
	(bfd_coff_force_symnames_in_strings,
	bfd_coff_debug_string_prefix_length): New macros for above fields.
	* coffcode.h (coff_set_arch_mach_hook): Handle XCOFF64 magic.
	Set machine to 620 for XCOFF64.  Use bfd_coff_swap_sym_in instead
	of using coff_swap_sym_in directly.
	(FORCE_SYMNAMES_IN_STRINGS): New macro, defined for XCOFF64.
	(coff_set_flags) Set magic for XCOFF64.
	(coff_compute_section_file_positions): Add symbol name length to
	string section length if bfd_coff_debug_string_prefix_length is
	true.
	(coff_write_object_contents): Don't do reloc overflow for XCOFF64.
	(coff_slurp_line_table): Use bfd_coff_swap_lineno_in instead of
	using coff_swap_lineno_in directly.
	(bfd_coff_backend_data): Add _bfd_coff_force_symnames_in_strings
	and _bfd_coff_debug_string_prefix_length fields.
	* coffgen.c (coff_fix_symbol_name, coff_write_symbols): Force
	symbol names into strings table when
	bfd_coff_force_symnames_in_strings is true.
	* coffswap.h (MAX_SCNHDR_NRELOC, MAX_SCNHDR_NLNNO, GET_RELOC_VADDR,
	SET_RELOC_VADDR): New macros.
	(coff_swap_reloc_in, coff_swap_reloc_out): Use above macros.
	(coff_swap_aux_in, coff_swap_aux_out): Remove RS6000COFF_C
	code.
	(coff_swap_aouthdr_in, coff_swap_aouthdr_out): Handle XCOFF64
	changes within RS6000COFF_C specific code.
	(coff_swap_scnhdr_out): Use PUT_SCNHDR_NLNNO, PUT_SCNHDR_NRELOC,
	MAX_SCNHDR_NRELOC, and MAX_SCNHDR_NLNNO.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation):
	Extend existing hack on target name.
	* xcofflink.c (XCOFF_XVECP): Extend existing hack on
	target name.
	* coff-tic54x.c (ticof): Keep up to date with new fields
	in bfd_coff_backend_data.
	* config.bfd: Add bfd_powerpc_64_arch to targ_arch and define
	targ_selvecs to include rs6000coff64_vec for rs6000.
	* configure.in: Add rs6000coff64_vec case.
 	* cpu-powerpc.c: New bfd_arch_info_type.

	gas:
	* as.c (parse_args): Allow md_parse_option to override -a listing
	option.
	* config/obj-coff.c (add_lineno): Change type of offset parameter
	from "int" to "bfd_vma."
	* config/tc-ppc.c (md_pseudo_table): Add "llong" and "machine."
	(ppc_mach, ppc_subseg_align, ppc_target_format): New.
	(ppc_change_csect): Align correctly for XCOFF64.
	(ppc_machine): New function, which discards "ppc_machine" line.
	(ppc_tc): Cons for 8 when code is 64 bit.
	(md_apply_fix3): Don't check operand->insert.  Handle 64 bit
	relocations.
	(md_parse_option): Handle -a64 and -a32.
	(ppc_xcoff64): New.
	* config/tc-ppc.h (TARGET_MACH): Define.
	(TARGET_FORMAT): Move to function.
	(SUB_SEGMENT_ALIGN): Use ppc_subseg_align.

	include:
	* include/coff/rs6k64.h: New file.

	opcodes:
	* configure.in: Add bfd_powerpc_64_arch.
	* disassemble.c (disassembler): Use print_insn_big_powerpc for
	64 bit code.
@
text
@a28 2
/* Internalcoff.h and coffcode.h modify themselves based on this flag.  */
#define RS6000COFF_C 1
d36 4
a42 12
boolean _bfd_xcoff_mkobject PARAMS ((bfd *));
boolean _bfd_xcoff_copy_private_bfd_data PARAMS ((bfd *, bfd *));
boolean _bfd_xcoff_is_local_label_name PARAMS ((bfd *, const char *));
void _bfd_xcoff_rtype2howto
  PARAMS ((arelent *, struct internal_reloc *));
reloc_howto_type *_bfd_xcoff_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
boolean _bfd_xcoff_slurp_armap PARAMS ((bfd *));
const bfd_target *_bfd_xcoff_archive_p PARAMS ((bfd *));
PTR _bfd_xcoff_read_ar_hdr PARAMS ((bfd *));
bfd *_bfd_xcoff_openr_next_archived_file PARAMS ((bfd *, bfd *));
int _bfd_xcoff_generic_stat_arch_elt PARAMS ((bfd *, struct stat *));
d44 1
a44 5
boolean _bfd_xcoff_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
boolean _bfd_xcoff_write_archive_contents PARAMS ((bfd *));
int _bfd_xcoff_sizeof_headers PARAMS ((bfd *, boolean));

a135 1
#define NO_COFF_SYMBOLS
d137 2
a138 7
static void xcoff_swap_sym_in PARAMS ((bfd *, PTR, PTR));
static unsigned int xcoff_swap_sym_out PARAMS ((bfd *, PTR, PTR));
static void xcoff_swap_aux_in PARAMS ((bfd *, PTR, int, int, int, int, PTR));
static unsigned int xcoff_swap_aux_out PARAMS ((bfd *, PTR, int, int, int, int, PTR));

static void
xcoff_swap_sym_in (abfd, ext1, in1)
d165 2
a166 2
static unsigned int
xcoff_swap_sym_out (abfd, inp, extp)
d200 2
a201 2
static void
xcoff_swap_aux_in (abfd, ext1, type, class, indx, numaux, in1)
d314 2
a315 2
static unsigned int
xcoff_swap_aux_out (abfd, inp, type, class, indx, numaux, extp)
a879 27
#define SELECT_RELOC(internal, howto)					\
  {									\
    internal.r_type = howto->type;					\
    internal.r_size =							\
      ((howto->complain_on_overflow == complain_overflow_signed		\
	? 0x80								\
	: 0)								\
       | (howto->bitsize - 1));						\
  }

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (3)

#define COFF_LONG_FILENAMES

#define RTYPE2HOWTO(cache_ptr, dst) _bfd_xcoff_rtype2howto (cache_ptr, dst)

#define coff_SWAP_sym_in xcoff_swap_sym_in
#define coff_SWAP_sym_out xcoff_swap_sym_out
#define coff_SWAP_aux_in xcoff_swap_aux_in
#define coff_SWAP_aux_out xcoff_swap_aux_out
#define coff_mkobject _bfd_xcoff_mkobject
#define coff_bfd_copy_private_bfd_data _bfd_xcoff_copy_private_bfd_data
#define coff_bfd_is_local_label_name _bfd_xcoff_is_local_label_name
#define coff_bfd_reloc_type_lookup _bfd_xcoff_reloc_type_lookup
#define coff_relocate_section _bfd_ppc_xcoff_relocate_section

#include "coffcode.h"
a1090 17
/* XCOFF archives do not have anything which corresponds to an
   extended name table.  */

#define _bfd_xcoff_slurp_extended_name_table bfd_false
#define _bfd_xcoff_construct_extended_name_table \
  ((boolean (*) PARAMS ((bfd *, char **, bfd_size_type *, const char **))) \
   bfd_false)
#define _bfd_xcoff_truncate_arname bfd_dont_truncate_arname

/* We can use the standard get_elt_at_index routine.  */

#define _bfd_xcoff_get_elt_at_index _bfd_generic_get_elt_at_index

/* XCOFF archives do not have a timestamp.  */

#define _bfd_xcoff_update_armap_timestamp bfd_true

a2260 1
#define CORE_FILE_P _bfd_dummy_target
a2261 110
#define coff_core_file_failing_command _bfd_nocore_core_file_failing_command
#define coff_core_file_failing_signal _bfd_nocore_core_file_failing_signal
#define coff_core_file_matches_executable_p \
  _bfd_nocore_core_file_matches_executable_p

#ifdef AIX_CORE
#undef CORE_FILE_P
#define CORE_FILE_P rs6000coff_core_p
extern const bfd_target * rs6000coff_core_p ();
extern boolean rs6000coff_get_section_contents ();
extern boolean rs6000coff_core_file_matches_executable_p ();

#undef	coff_core_file_matches_executable_p
#define coff_core_file_matches_executable_p  \
				     rs6000coff_core_file_matches_executable_p

extern char *rs6000coff_core_file_failing_command PARAMS ((bfd *abfd));
#undef coff_core_file_failing_command
#define coff_core_file_failing_command rs6000coff_core_file_failing_command

extern int rs6000coff_core_file_failing_signal PARAMS ((bfd *abfd));
#undef coff_core_file_failing_signal
#define coff_core_file_failing_signal rs6000coff_core_file_failing_signal

#undef	coff_get_section_contents
#define	coff_get_section_contents	rs6000coff_get_section_contents
#endif /* AIX_CORE */

#ifdef LYNX_CORE

#undef CORE_FILE_P
#define CORE_FILE_P lynx_core_file_p
extern const bfd_target *lynx_core_file_p PARAMS ((bfd *abfd));

extern boolean lynx_core_file_matches_executable_p PARAMS ((bfd *core_bfd,
							    bfd *exec_bfd));
#undef	coff_core_file_matches_executable_p
#define coff_core_file_matches_executable_p lynx_core_file_matches_executable_p

extern char *lynx_core_file_failing_command PARAMS ((bfd *abfd));
#undef coff_core_file_failing_command
#define coff_core_file_failing_command lynx_core_file_failing_command

extern int lynx_core_file_failing_signal PARAMS ((bfd *abfd));
#undef coff_core_file_failing_signal
#define coff_core_file_failing_signal lynx_core_file_failing_signal

#endif /* LYNX_CORE */

#define _bfd_xcoff_bfd_get_relocated_section_contents \
  coff_bfd_get_relocated_section_contents
#define _bfd_xcoff_bfd_relax_section coff_bfd_relax_section
#define _bfd_xcoff_bfd_gc_sections coff_bfd_gc_sections
#define _bfd_xcoff_bfd_link_split_section coff_bfd_link_split_section

/* The transfer vector that leads the outside world to all of the above. */

const bfd_target
#ifdef TARGET_SYM
  TARGET_SYM =
#else
  rs6000coff_vec =
#endif
{
#ifdef TARGET_NAME
  TARGET_NAME,
#else
  "aixcoff-rs6000",		/* name */
#endif
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG | DYNAMIC |
   HAS_SYMS | HAS_LOCALS | WP_TEXT),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
  0,				/* leading char */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen??? FIXMEmgo */

  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */

  {_bfd_dummy_target, coff_object_p, 	/* bfd_check_format */
     _bfd_xcoff_archive_p, CORE_FILE_P},
  {bfd_false, coff_mkobject,		/* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
  {bfd_false, coff_write_object_contents,	/* bfd_write_contents */
     _bfd_xcoff_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (coff),
     BFD_JUMP_TABLE_COPY (coff),
     BFD_JUMP_TABLE_CORE (coff),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_xcoff),
     BFD_JUMP_TABLE_SYMBOLS (coff),
     BFD_JUMP_TABLE_RELOCS (coff),
     BFD_JUMP_TABLE_WRITE (coff),
     BFD_JUMP_TABLE_LINK (_bfd_xcoff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_xcoff),

  NULL,
  
  COFF_SWAP_TABLE
};
@


1.6
log
@* coffcode.h (coff_set_arch_mach_hook): Don't use variable-size
arrays.
(coff_compute_section_file_positions): Use bfd_free to pair
bfd_malloc.
(coff_write_object_contents): Likewise.

* coff-rs6000.c (xcoff_howto_table_16): New variable.
(xcoff_rtype2howto): Handle 16-bit variants of 32-bit relocs.
@
text
@d41 4
a44 4
static boolean xcoff_mkobject PARAMS ((bfd *));
static boolean xcoff_copy_private_bfd_data PARAMS ((bfd *, bfd *));
static boolean xcoff_is_local_label_name PARAMS ((bfd *, const char *));
static void xcoff_rtype2howto
d46 1
a46 1
static reloc_howto_type *xcoff_reloc_type_lookup
d48 5
a52 5
static boolean xcoff_slurp_armap PARAMS ((bfd *));
static const bfd_target *xcoff_archive_p PARAMS ((bfd *));
static PTR xcoff_read_ar_hdr PARAMS ((bfd *));
static bfd *xcoff_openr_next_archived_file PARAMS ((bfd *, bfd *));
static int xcoff_generic_stat_arch_elt PARAMS ((bfd *, struct stat *));
d54 1
a54 1
static boolean xcoff_write_armap
d56 2
a57 2
static boolean xcoff_write_archive_contents PARAMS ((bfd *));
static int _bfd_xcoff_sizeof_headers PARAMS ((bfd *, boolean));
d62 2
a63 2
static boolean
xcoff_mkobject (abfd)
d93 2
a94 2
static boolean
xcoff_copy_private_bfd_data (ibfd, obfd)
d141 2
a142 2
static boolean
xcoff_is_local_label_name (abfd, name)
d149 285
d440 5
a444 1
static reloc_howto_type xcoff_howto_table[] =
d785 13
d799 1
d848 2
a849 2
	 false),                /* pcrel_offset */
};
d851 2
a852 2
static void
xcoff_rtype2howto (relent, internal)
d877 2
a878 2
static reloc_howto_type *
xcoff_reloc_type_lookup (abfd, code)
d893 2
d914 1
a914 1
#define RTYPE2HOWTO(cache_ptr, dst) xcoff_rtype2howto (cache_ptr, dst)
d916 8
a923 4
#define coff_mkobject xcoff_mkobject
#define coff_bfd_copy_private_bfd_data xcoff_copy_private_bfd_data
#define coff_bfd_is_local_label_name xcoff_is_local_label_name
#define coff_bfd_reloc_type_lookup xcoff_reloc_type_lookup
d1141 2
a1142 2
#define xcoff_slurp_extended_name_table bfd_false
#define xcoff_construct_extended_name_table \
d1145 1
a1145 1
#define xcoff_truncate_arname bfd_dont_truncate_arname
d1149 1
a1149 1
#define xcoff_get_elt_at_index _bfd_generic_get_elt_at_index
d1153 1
a1153 1
#define xcoff_update_armap_timestamp bfd_true
d1157 2
a1158 2
static boolean
xcoff_slurp_armap (abfd)
d1281 2
a1282 2
static const bfd_target *
xcoff_archive_p (abfd)
d1372 1
a1372 1
  if (! xcoff_slurp_armap (abfd))
d1384 2
a1385 2
static PTR
xcoff_read_ar_hdr (abfd)
d1472 2
a1473 2
static bfd *
xcoff_openr_next_archived_file (archive, last_file)
d1533 2
a1534 2
static int
xcoff_generic_stat_arch_elt (abfd, s)
d1764 2
a1765 2
static boolean
xcoff_write_armap (abfd, elength, map, orl_count, stridx)
d2295 2
a2296 2
static boolean
xcoff_write_archive_contents (abfd)
d2309 1
a2309 1
static int
d2417 1
a2417 1
     xcoff_archive_p, CORE_FILE_P},
d2421 1
a2421 1
     xcoff_write_archive_contents, bfd_false},
d2426 1
a2426 1
     BFD_JUMP_TABLE_ARCHIVE (xcoff),
@


1.5
log
@Revert previous patch.
@
text
@d499 49
d555 5
d648 1
a648 1
   null terminated strings, which are symbol names.  */
d650 17
a666 4
/* XCOFF archives use this as a magic string.  */

#define XCOFFARMAG "<aiaff>\012"
#define SXCOFFARMAG 8
d699 32
d769 45
d815 1
a815 1
   artdata structure.  */
d818 2
d822 1
a822 1
   archive element.  */
d826 2
a852 1
  struct xcoff_ar_hdr hdr;
d866 1
a866 2
  off = strtol (xcoff_ardata (abfd)->symoff, (char **) NULL, 10);
  if (off == 0)
d868 23
a890 2
      bfd_has_map (abfd) = false;
      return true;
d892 14
d907 4
a910 2
  if (bfd_seek (abfd, off, SEEK_SET) != 0)
    return false;
d912 4
a915 3
  /* The symbol table starts with a normal archive header.  */
  if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR)
    return false;
d917 5
a921 4
  /* Skip the name (normally empty).  */
  namlen = strtol (hdr.namlen, (char **) NULL, 10);
  if (bfd_seek (abfd, ((namlen + 1) & ~1) + SXCOFFARFMAG, SEEK_CUR) != 0)
    return false;
a923 1
  sz = strtol (hdr.size, (char **) NULL, 10);
d976 1
a976 1
  struct xcoff_ar_file_hdr hdr;
d978 1
a978 2
  if (bfd_read ((PTR) &hdr, SIZEOF_AR_FILE_HDR, 1, abfd)
      != SIZEOF_AR_FILE_HDR)
d985 2
a986 1
  if (strncmp (hdr.magic, XCOFFARMAG, SXCOFFARMAG) != 0)
a1000 2
  bfd_ardata (abfd)->first_file_filepos = strtol (hdr.firstmemoff,
						  (char **) NULL, 10);
d1006 53
a1058 3
  bfd_ardata (abfd)->tdata = bfd_zalloc (abfd, SIZEOF_AR_FILE_HDR);
  if (bfd_ardata (abfd)->tdata == NULL)
    return NULL;
d1060 2
a1061 1
  memcpy (bfd_ardata (abfd)->tdata, &hdr, SIZEOF_AR_FILE_HDR);
a1078 1
  struct xcoff_ar_hdr hdr;
a1079 1
  struct xcoff_ar_hdr *hdrp;
d1082 2
a1083 1
  if (bfd_read ((PTR) &hdr, SIZEOF_AR_HDR, 1, abfd) != SIZEOF_AR_HDR)
d1086 59
a1144 8
  namlen = strtol (hdr.namlen, (char **) NULL, 10);
  hdrp = (struct xcoff_ar_hdr *) bfd_alloc (abfd, SIZEOF_AR_HDR + namlen + 1);
  if (hdrp == NULL)
    return NULL;
  memcpy (hdrp, &hdr, SIZEOF_AR_HDR);
  if (bfd_read ((char *) hdrp + SIZEOF_AR_HDR, 1, namlen, abfd) != namlen)
    return NULL;
  ((char *) hdrp)[SIZEOF_AR_HDR + namlen] = '\0';
d1146 7
a1152 6
  ret = (struct areltdata *) bfd_alloc (abfd, sizeof (struct areltdata));
  if (ret == NULL)
    return NULL;
  ret->arch_header = (char *) hdrp;
  ret->parsed_size = strtol (hdr.size, (char **) NULL, 10);
  ret->filename = (char *) hdrp + SIZEOF_AR_HDR;
d1176 18
a1193 2
  if (last_file == NULL)
    filestart = bfd_ardata (archive)->first_file_filepos;
a1194 7
    filestart = strtol (arch_xhdr (last_file)->nextoff, (char **) NULL, 10);

  if (filestart == 0
      || filestart == strtol (xcoff_ardata (archive)->memoff,
			      (char **) NULL, 10)
      || filestart == strtol (xcoff_ardata (archive)->symoff,
			      (char **) NULL, 10))
d1196 21
a1216 2
      bfd_set_error (bfd_error_no_more_archived_files);
      return NULL;
a1228 2
  struct xcoff_ar_hdr *hdrp;

d1235 3
a1237 1
  hdrp = arch_xhdr (abfd);
d1239 16
a1254 5
  s->st_mtime = strtol (hdrp->date, (char **) NULL, 10);
  s->st_uid = strtol (hdrp->uid, (char **) NULL, 10);
  s->st_gid = strtol (hdrp->gid, (char **) NULL, 10);
  s->st_mode = strtol (hdrp->mode, (char **) NULL, 8);
  s->st_size = arch_eltdata (abfd)->parsed_size;
d1281 1
a1281 1
xcoff_write_armap (abfd, elength, map, orl_count, stridx)
d1313 1
a1313 1
  
d1365 104
d1473 1
a1473 1
xcoff_write_archive_contents (abfd)
d1716 279
d2087 1
a2087 1
  bfd_target_coff_flavour,	
@


1.4
log
@Change AR for ELF so that common symbols are not included in archive map.
Change LD for ELF so that archive elements whoes archive map contains a
 reference to a common symbol will get linkled in.
Add new field to bfd_target structure and initialise it for all bfd targets.
@
text
@a696 1
#define xcoff_allow_commons_in_armap bfd_true
@


1.3
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d697 1
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d1418 3
a1420 1
  COFF_SWAP_TABLE,
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d143 2
a144 2
     bfd *abfd;
     const char *name;
d262 1
a262 1
  { 7 },
d279 1
a279 1
  { 9 },
d296 1
a296 1
  { 0xb },
d328 1
a328 1
  { 0xe },
d345 2
a346 2
  { 0x10 },
  { 0x11 },
d522 1
a522 1
     bfd *abfd;
d960 1
a960 1
     unsigned int elength;
d1297 1
a1297 1
     boolean reloc;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

