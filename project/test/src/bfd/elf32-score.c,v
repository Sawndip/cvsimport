head	1.29;
access;
symbols
	sid-snapshot-20180601:1.29
	sid-snapshot-20180501:1.29
	sid-snapshot-20180401:1.29
	sid-snapshot-20180301:1.29
	sid-snapshot-20180201:1.29
	sid-snapshot-20180101:1.29
	sid-snapshot-20171201:1.29
	sid-snapshot-20171101:1.29
	sid-snapshot-20171001:1.29
	sid-snapshot-20170901:1.29
	sid-snapshot-20170801:1.29
	sid-snapshot-20170701:1.29
	sid-snapshot-20170601:1.29
	sid-snapshot-20170501:1.29
	sid-snapshot-20170401:1.29
	sid-snapshot-20170301:1.29
	sid-snapshot-20170201:1.29
	sid-snapshot-20170101:1.29
	sid-snapshot-20161201:1.29
	sid-snapshot-20161101:1.29
	sid-snapshot-20160901:1.29
	sid-snapshot-20160801:1.29
	sid-snapshot-20160701:1.29
	sid-snapshot-20160601:1.29
	sid-snapshot-20160501:1.29
	sid-snapshot-20160401:1.29
	sid-snapshot-20160301:1.29
	sid-snapshot-20160201:1.29
	sid-snapshot-20160101:1.29
	sid-snapshot-20151201:1.29
	sid-snapshot-20151101:1.29
	sid-snapshot-20151001:1.29
	sid-snapshot-20150901:1.29
	sid-snapshot-20150801:1.29
	sid-snapshot-20150701:1.29
	sid-snapshot-20150601:1.29
	sid-snapshot-20150501:1.29
	sid-snapshot-20150401:1.29
	sid-snapshot-20150301:1.29
	sid-snapshot-20150201:1.29
	sid-snapshot-20150101:1.29
	sid-snapshot-20141201:1.29
	sid-snapshot-20141101:1.29
	sid-snapshot-20141001:1.29
	sid-snapshot-20140901:1.29
	sid-snapshot-20140801:1.29
	sid-snapshot-20140701:1.29
	sid-snapshot-20140601:1.29
	sid-snapshot-20140501:1.29
	sid-snapshot-20140401:1.29
	sid-snapshot-20140301:1.29
	sid-snapshot-20140201:1.29
	sid-snapshot-20140101:1.29
	sid-snapshot-20131201:1.29
	sid-snapshot-20131101:1.29
	sid-snapshot-20131001:1.29
	binutils-2_24-branch:1.29.0.2
	binutils-2_24-branchpoint:1.29
	binutils-2_21_1:1.21
	sid-snapshot-20130901:1.29
	gdb_7_6_1-2013-08-30-release:1.28
	sid-snapshot-20130801:1.29
	sid-snapshot-20130701:1.29
	sid-snapshot-20130601:1.29
	sid-snapshot-20130501:1.29
	gdb_7_6-2013-04-26-release:1.28
	sid-snapshot-20130401:1.29
	binutils-2_23_2:1.25
	gdb_7_6-branch:1.28.0.2
	gdb_7_6-2013-03-12-branchpoint:1.28
	sid-snapshot-20130301:1.28
	sid-snapshot-20130201:1.26
	sid-snapshot-20130101:1.26
	sid-snapshot-20121201:1.26
	gdb_7_5_1-2012-11-29-release:1.25
	binutils-2_23_1:1.25
	sid-snapshot-20121101:1.26
	binutils-2_23:1.25
	sid-snapshot-20121001:1.26
	sid-snapshot-20120901:1.25
	gdb_7_5-2012-08-17-release:1.25
	sid-snapshot-20120801:1.25
	binutils-2_23-branch:1.25.0.4
	binutils-2_23-branchpoint:1.25
	gdb_7_5-branch:1.25.0.2
	gdb_7_5-2012-07-18-branchpoint:1.25
	sid-snapshot-20120701:1.25
	sid-snapshot-20120601:1.24
	sid-snapshot-20120501:1.23
	binutils-2_22_branch:1.22.0.6
	gdb_7_4_1-2012-04-26-release:1.22
	sid-snapshot-20120401:1.22
	sid-snapshot-20120301:1.22
	sid-snapshot-20120201:1.22
	gdb_7_4-2012-01-24-release:1.22
	sid-snapshot-20120101:1.22
	gdb_7_4-branch:1.22.0.4
	gdb_7_4-2011-12-13-branchpoint:1.22
	sid-snapshot-20111201:1.22
	binutils-2_22:1.22
	sid-snapshot-20111101:1.22
	sid-snapshot-20111001:1.22
	binutils-2_22-branch:1.22.0.2
	binutils-2_22-branchpoint:1.22
	gdb_7_3_1-2011-09-04-release:1.21
	sid-snapshot-20110901:1.22
	sid-snapshot-20110801:1.22
	gdb_7_3-2011-07-26-release:1.21
	sid-snapshot-20110701:1.22
	sid-snapshot-20110601:1.21
	sid-snapshot-20110501:1.21
	gdb_7_3-branch:1.21.0.4
	gdb_7_3-2011-04-01-branchpoint:1.21
	sid-snapshot-20110401:1.21
	sid-snapshot-20110301:1.21
	sid-snapshot-20110201:1.21
	sid-snapshot-20110101:1.21
	binutils-2_21:1.21
	sid-snapshot-20101201:1.21
	binutils-2_21-branch:1.21.0.2
	binutils-2_21-branchpoint:1.21
	sid-snapshot-20101101:1.21
	sid-snapshot-20101001:1.20
	binutils-2_20_1:1.15
	gdb_7_2-2010-09-02-release:1.18
	sid-snapshot-20100901:1.19
	sid-snapshot-20100801:1.18
	gdb_7_2-branch:1.18.0.2
	gdb_7_2-2010-07-07-branchpoint:1.18
	sid-snapshot-20100701:1.18
	sid-snapshot-20100601:1.17
	sid-snapshot-20100501:1.17
	sid-snapshot-20100401:1.17
	gdb_7_1-2010-03-18-release:1.17
	sid-snapshot-20100301:1.17
	gdb_7_1-branch:1.17.0.2
	gdb_7_1-2010-02-18-branchpoint:1.17
	sid-snapshot-20100201:1.16
	sid-snapshot-20100101:1.16
	gdb_7_0_1-2009-12-22-release:1.15
	sid-snapshot-20091201:1.15
	sid-snapshot-20091101:1.15
	binutils-2_20:1.15
	gdb_7_0-2009-10-06-release:1.15
	sid-snapshot-20091001:1.15
	gdb_7_0-branch:1.15.0.8
	gdb_7_0-2009-09-16-branchpoint:1.15
	arc-sim-20090309:1.13
	binutils-arc-20081103-branch:1.13.0.22
	binutils-arc-20081103-branchpoint:1.13
	binutils-2_20-branch:1.15.0.6
	binutils-2_20-branchpoint:1.15
	sid-snapshot-20090901:1.15
	sid-snapshot-20090801:1.15
	msnyder-checkpoint-072509-branch:1.15.0.4
	msnyder-checkpoint-072509-branchpoint:1.15
	sid-snapshot-20090701:1.15
	dje-cgen-play1-branch:1.15.0.2
	dje-cgen-play1-branchpoint:1.15
	sid-snapshot-20090601:1.15
	sid-snapshot-20090501:1.14
	sid-snapshot-20090401:1.14
	arc-20081103-branch:1.13.0.20
	arc-20081103-branchpoint:1.13
	arc-insight_6_8-branch:1.13.0.18
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.16
	insight_6_8-branchpoint:1.13
	sid-snapshot-20090301:1.13
	binutils-2_19_1:1.13
	sid-snapshot-20090201:1.13
	sid-snapshot-20090101:1.13
	reverse-20081226-branch:1.13.0.14
	reverse-20081226-branchpoint:1.13
	sid-snapshot-20081201:1.13
	multiprocess-20081120-branch:1.13.0.12
	multiprocess-20081120-branchpoint:1.13
	sid-snapshot-20081101:1.13
	binutils-2_19:1.13
	sid-snapshot-20081001:1.13
	reverse-20080930-branch:1.13.0.10
	reverse-20080930-branchpoint:1.13
	binutils-2_19-branch:1.13.0.8
	binutils-2_19-branchpoint:1.13
	sid-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	reverse-20080717-branch:1.13.0.6
	reverse-20080717-branchpoint:1.13
	sid-snapshot-20080701:1.13
	msnyder-reverse-20080609-branch:1.13.0.4
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.9.0.2
	drow-reverse-20070409-branchpoint:1.9
	sid-snapshot-20080601:1.13
	sid-snapshot-20080501:1.13
	sid-snapshot-20080403:1.13
	sid-snapshot-20080401:1.13
	gdb_6_8-2008-03-27-release:1.13
	sid-snapshot-20080301:1.13
	gdb_6_8-branch:1.13.0.2
	gdb_6_8-2008-02-26-branchpoint:1.13
	sid-snapshot-20080201:1.13
	sid-snapshot-20080101:1.13
	sid-snapshot-20071201:1.13
	sid-snapshot-20071101:1.13
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	sid-snapshot-20071001:1.13
	gdb_6_7-branch:1.11.0.4
	gdb_6_7-2007-09-07-branchpoint:1.11
	binutils-2_18:1.11
	binutils-2_18-branch:1.11.0.2
	binutils-2_18-branchpoint:1.11
	insight_6_6-20070208-release:1.5
	gdb_6_6-2006-12-18-release:1.5
	gdb_6_6-branch:1.5.0.2
	gdb_6_6-2006-11-15-branchpoint:1.5
	binutils_latest_snapshot:1.29;
locks; strict;
comment	@ * @;


1.29
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2013.02.21.03.02.29;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2013.02.10.04.36.32;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2012.09.02.12.17.26;	author hjl;	state Exp;
branches;
next	1.25;

1.25
date	2012.06.29.14.46.00;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2012.05.07.03.27.50;	author macro;	state Exp;
branches;
next	1.23;

1.23
date	2012.04.24.05.12.35;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.13.00.59.11;	author amodra;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.24.12.14.24;	author tschwinge;	state Exp;
branches;
next	1.19;

1.19
date	2010.08.18.12.24.06;	author palves;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2010.02.04.09.16.40;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.11.13.42.03;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.21.14.15.48;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.02.10.33.05;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.28.08.43.45;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.29.16.29.21;	author jules;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.25.09.22.06;	author ligang;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.23.02.41.11;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.19.15.47.33;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.27.04.07.57;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.16.23.51.50;	author nickc;	state Exp;
branches;
next	;

1.22.2.1
date	2012.05.11.12.24.27;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.29
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@/* 32-bit ELF support for S+core.
   Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
   Contributed by
   Brain.lin (brain.lin@@sunplusct.com)
   Mei Ligang (ligang@@sunnorth.com.cn)
   Pei-Lin Tsai (pltsai@@sunplus.com)

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "libiberty.h"
#include "elf-bfd.h"
#include "elf/score.h"
#include "elf/common.h"
#include "elf/internal.h"
#include "hashtab.h"
#include "elf32-score.h"


int score3 = 0;
int score7 = 1;

/* The SCORE ELF linker needs additional information for each symbol in
   the global hash table.  */
struct score_elf_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* Number of R_SCORE_ABS32, R_SCORE_REL32 relocs against this symbol.  */
  unsigned int possibly_dynamic_relocs;

  /* If the R_SCORE_ABS32, R_SCORE_REL32 reloc is against a readonly section.  */
  bfd_boolean readonly_reloc;

  /* We must not create a stub for a symbol that has relocations related to
     taking the function's address, i.e. any but R_SCORE_CALL15 ones.  */
  bfd_boolean no_fn_stub;

  /* Are we forced local?  This will only be set if we have converted
     the initial global GOT entry to a local GOT entry.  */
  bfd_boolean forced_local;
};

/* Traverse a score ELF linker hash table.  */
#define score_elf_link_hash_traverse(table, func, info) \
  (elf_link_hash_traverse \
   ((table),							     \
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func), \
    (info)))

/* This structure is used to hold .got entries while estimating got sizes.  */
struct score_got_entry
{
  /* The input bfd in which the symbol is defined.  */
  bfd *abfd;
  /* The index of the symbol, as stored in the relocation r_info, if
     we have a local symbol; -1 otherwise.  */
  long symndx;
  union
  {
    /* If abfd == NULL, an address that must be stored in the got.  */
    bfd_vma address;
    /* If abfd != NULL && symndx != -1, the addend of the relocation
       that should be added to the symbol value.  */
    bfd_vma addend;
    /* If abfd != NULL && symndx == -1, the hash table entry
       corresponding to a global symbol in the got (or, local, if
       h->forced_local).  */
    struct score_elf_link_hash_entry *h;
  } d;

  /* The offset from the beginning of the .got section to the entry
     corresponding to this symbol+addend.  If it's a global symbol
     whose offset is yet to be decided, it's going to be -1.  */
  long gotidx;
};

/* This structure is passed to score_elf_sort_hash_table_f when sorting
   the dynamic symbols.  */

struct score_elf_hash_sort_data
{
  /* The symbol in the global GOT with the lowest dynamic symbol table index.  */
  struct elf_link_hash_entry *low;
  /* The least dynamic symbol table index corresponding to a symbol with a GOT entry.  */
  long min_got_dynindx;
  /* The greatest dynamic symbol table index corresponding to a symbol
     with a GOT entry that is not referenced (e.g., a dynamic symbol
     with dynamic relocations pointing to it from non-primary GOTs).  */
  long max_unref_got_dynindx;
  /* The greatest dynamic symbol table index not corresponding to a
     symbol without a GOT entry.  */
  long max_non_got_dynindx;
};

struct score_got_info
{
  /* The global symbol in the GOT with the lowest index in the dynamic
     symbol table.  */
  struct elf_link_hash_entry *global_gotsym;
  /* The number of global .got entries.  */
  unsigned int global_gotno;
  /* The number of local .got entries.  */
  unsigned int local_gotno;
  /* The number of local .got entries we have used.  */
  unsigned int assigned_gotno;
  /* A hash table holding members of the got.  */
  struct htab *got_entries;
  /* In multi-got links, a pointer to the next got (err, rather, most
     of the time, it points to the previous got).  */
  struct score_got_info *next;
};

/* A structure used to count GOT entries, for GOT entry or ELF symbol table traversal.  */
struct _score_elf_section_data
{
  struct bfd_elf_section_data elf;
  union
  {
    struct score_got_info *got_info;
    bfd_byte *tdata;
  }
  u;
};

#define score_elf_section_data(sec) \
  ((struct _score_elf_section_data *) elf_section_data (sec))

/* The size of a symbol-table entry.  */
#define SCORE_ELF_SYM_SIZE(abfd)  \
  (get_elf_backend_data (abfd)->s->sizeof_sym)

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE (((bfd_vma)0) - 1)
#define MINUS_TWO (((bfd_vma)0) - 2)

#define PDR_SIZE 32


/* The number of local .got entries we reserve.  */
#define SCORE_RESERVED_GOTNO (2)
#define ELF_DYNAMIC_INTERPRETER     "/usr/lib/ld.so.1"

/* The offset of $gp from the beginning of the .got section.  */
#define ELF_SCORE_GP_OFFSET(abfd) (0x3ff0)
/* The maximum size of the GOT for it to be addressable using 15-bit offsets from $gp.  */
#define SCORE_ELF_GOT_MAX_SIZE(abfd) (ELF_SCORE_GP_OFFSET(abfd) + 0x3fff)

#define SCORE_ELF_STUB_SECTION_NAME  (".SCORE.stub")
#define SCORE_FUNCTION_STUB_SIZE (16)

#define STUB_LW      0xc3bcc010     /* lw r29, [r28, -0x3ff0]  */
#define STUB_MOVE    0x8363bc56     /* mv r27, r3  */
#define STUB_LI16    0x87548000     /* ori r26, .dynsym_index  */
#define STUB_BRL     0x801dbc09     /* brl r29  */

#define SCORE_ELF_GOT_SIZE(abfd)   \
  (get_elf_backend_data (abfd)->s->arch_size / 8)

#define SCORE_ELF_ADD_DYNAMIC_ENTRY(info, tag, val) \
        (_bfd_elf_add_dynamic_entry (info, (bfd_vma) tag, (bfd_vma) val))

/* The size of an external dynamic table entry.  */
#define SCORE_ELF_DYN_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_dyn)

/* The size of an external REL relocation.  */
#define SCORE_ELF_REL_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_rel)

/* The default alignment for sections, as a power of two.  */
#define SCORE_ELF_LOG_FILE_ALIGN(abfd)\
  (get_elf_backend_data (abfd)->s->log_file_align)

static bfd_byte *hi16_rel_addr;

/* This will be used when we sort the dynamic relocation records.  */
static bfd *reldyn_sorting_bfd;

/* SCORE ELF uses two common sections.  One is the usual one, and the
   other is for small objects.  All the small objects are kept
   together, and then referenced via the gp pointer, which yields
   faster assembler code.  This is what we use for the small common
   section.  This approach is copied from ecoff.c.  */
static asection score_elf_scom_section;
static asymbol  score_elf_scom_symbol;
static asymbol  *score_elf_scom_symbol_ptr;

static bfd_vma
score_bfd_get_16 (bfd *abfd, const void *data)
{
  return bfd_get_16 (abfd, data);
}

static bfd_vma
score3_bfd_getl32 (const void *p)
{
  const bfd_byte *addr = p;
  unsigned long v;

  v = (unsigned long) addr[2];
  v |= (unsigned long) addr[3] << 8;
  v |= (unsigned long) addr[0] << 16;
  v |= (unsigned long) addr[1] << 24;
  return v;
}

static bfd_vma
score3_bfd_getl48 (const void *p)
{
  const bfd_byte *addr = p;
  unsigned long long v;

  v = (unsigned long long) addr[4];
  v |= (unsigned long long) addr[5] << 8;
  v |= (unsigned long long) addr[2] << 16;
  v |= (unsigned long long) addr[3] << 24;
  v |= (unsigned long long) addr[0] << 32;
  v |= (unsigned long long) addr[1] << 40;
  return v;
}

static bfd_vma
score_bfd_get_32 (bfd *abfd, const void *data)
{
  if (/* score3 && */ abfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
    return score3_bfd_getl32 (data);
  else
    return bfd_get_32 (abfd, data);
}

static bfd_vma
score_bfd_get_48 (bfd *abfd, const void *p)
{
  if (/* score3 && */ abfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
    return score3_bfd_getl48 (p);
  else
    return bfd_get_bits (p, 48, 1);
}

static void
score_bfd_put_16 (bfd *abfd, bfd_vma addr, void *data)
{
  return bfd_put_16 (abfd, addr, data);
}

static void
score3_bfd_putl32 (bfd_vma data, void *p)
{
  bfd_byte *addr = p;
  addr[0] = (data >> 16) & 0xff;
  addr[1] = (data >> 24) & 0xff;
  addr[2] = data & 0xff;
  addr[3] = (data >>  8) & 0xff;
}

static void
score3_bfd_putl48 (bfd_vma data, void *p)
{
  bfd_byte *addr = p;
  addr[0] = (data >> 32) & 0xff;
  addr[1] = (data >> 40) & 0xff;
  addr[2] = (data >> 16) & 0xff;
  addr[3] = (data >> 24) & 0xff;
  addr[4] = data & 0xff;
  addr[5] = (data >>  8) & 0xff;
}

static void
score_bfd_put_32 (bfd *abfd, bfd_vma addr, void *data)
{
  if (/* score3 && */ abfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
    return score3_bfd_putl32 (addr, data);
  else
    return bfd_put_32 (abfd, addr, data);
}

static void
score_bfd_put_48 (bfd *abfd, bfd_vma val, void *p)
{
  if (/* score3 && */ abfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
    return score3_bfd_putl48 (val, p);
  else
    return bfd_put_bits (val, p, 48, 1);
}

static bfd_reloc_status_type
score_elf_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED,
                      arelent *reloc_entry,
                      asymbol *symbol ATTRIBUTE_UNUSED,
                      void * data,
                      asection *input_section ATTRIBUTE_UNUSED,
                      bfd *output_bfd ATTRIBUTE_UNUSED,
                      char **error_message ATTRIBUTE_UNUSED)
{
  hi16_rel_addr = (bfd_byte *) data + reloc_entry->address;
  return bfd_reloc_ok;
}

static bfd_reloc_status_type
score_elf_lo16_reloc (bfd *abfd,
                      arelent *reloc_entry,
                      asymbol *symbol ATTRIBUTE_UNUSED,
                      void * data,
                      asection *input_section,
                      bfd *output_bfd ATTRIBUTE_UNUSED,
                      char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma addend = 0, offset = 0;
  unsigned long val;
  unsigned long hi16_offset, hi16_value, uvalue;

  hi16_value = score_bfd_get_32 (abfd, hi16_rel_addr);
  hi16_offset = ((((hi16_value >> 16) & 0x3) << 15) | (hi16_value & 0x7fff)) >> 1;
  addend = score_bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  offset = ((((addend >> 16) & 0x3) << 15) | (addend & 0x7fff)) >> 1;
  val = reloc_entry->addend;
  if (reloc_entry->address > input_section->size)
    return bfd_reloc_outofrange;
  uvalue = ((hi16_offset << 16) | (offset & 0xffff)) + val;
  hi16_offset = (uvalue >> 16) << 1;
  hi16_value = (hi16_value & ~0x37fff) | (hi16_offset & 0x7fff) | ((hi16_offset << 1) & 0x30000);
  score_bfd_put_32 (abfd, hi16_value, hi16_rel_addr);
  offset = (uvalue & 0xffff) << 1;
  addend = (addend & ~0x37fff) | (offset & 0x7fff) | ((offset << 1) & 0x30000);
  score_bfd_put_32 (abfd, addend, (bfd_byte *) data + reloc_entry->address);
  return bfd_reloc_ok;
}

/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
   dangerous relocation.  */

static bfd_boolean
score_elf_assign_gp (bfd *output_bfd, bfd_vma *pgp)
{
  unsigned int count;
  asymbol **sym;
  unsigned int i;

  /* If we've already figured out what GP will be, just return it.  */
  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp)
    return TRUE;

  count = bfd_get_symcount (output_bfd);
  sym = bfd_get_outsymbols (output_bfd);

  /* The linker script will have created a symbol named `_gp' with the
     appropriate value.  */
  if (sym == NULL)
    i = count;
  else
    {
      for (i = 0; i < count; i++, sym++)
        {
          const char *name;

          name = bfd_asymbol_name (*sym);
          if (*name == '_' && strcmp (name, "_gp") == 0)
            {
              *pgp = bfd_asymbol_value (*sym);
              _bfd_set_gp_value (output_bfd, *pgp);
              break;
            }
        }
    }

  if (i >= count)
    {
      /* Only get the error once.  */
      *pgp = 4;
      _bfd_set_gp_value (output_bfd, *pgp);
      return FALSE;
    }

  return TRUE;
}

/* We have to figure out the gp value, so that we can adjust the
   symbol value correctly.  We look up the symbol _gp in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocatable output.  */
static bfd_reloc_status_type
score_elf_final_gp (bfd *output_bfd,
                    asymbol *symbol,
                    bfd_boolean relocatable,
                     char **error_message,
                    bfd_vma *pgp)
{
  if (bfd_is_und_section (symbol->section)
      && ! relocatable)
    {
      *pgp = 0;
      return bfd_reloc_undefined;
    }

  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp == 0
      && (! relocatable
          || (symbol->flags & BSF_SECTION_SYM) != 0))
    {
      if (relocatable)
        {
          /* Make up a value.  */
          *pgp = symbol->section->output_section->vma + 0x4000;
          _bfd_set_gp_value (output_bfd, *pgp);
        }
      else if (!score_elf_assign_gp (output_bfd, pgp))
        {
            *error_message =
              (char *) _("GP relative relocation when _gp not defined");
            return bfd_reloc_dangerous;
        }
    }

  return bfd_reloc_ok;
}

static bfd_reloc_status_type
score_elf_gprel15_with_gp (bfd *abfd,
                           asymbol *symbol,
                           arelent *reloc_entry,
                           asection *input_section,
                           bfd_boolean relocateable,
                           void * data,
                           bfd_vma gp ATTRIBUTE_UNUSED)
{
  bfd_vma relocation;
  unsigned long insn;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  if (reloc_entry->address > input_section->size)
    return bfd_reloc_outofrange;

  insn = score_bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  if (((reloc_entry->addend & 0xffffc000) != 0)
      && ((reloc_entry->addend & 0xffffc000) != 0xffffc000))
    return bfd_reloc_overflow;

  insn = (insn & ~0x7fff) | (reloc_entry->addend & 0x7fff);
  score_bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);
  if (relocateable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

static bfd_reloc_status_type
gprel32_with_gp (bfd *abfd, asymbol *symbol, arelent *reloc_entry,
                 asection *input_section, bfd_boolean relocatable,
                 void *data, bfd_vma gp)
{
  bfd_vma relocation;
  bfd_vma val;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    val += score_bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    score_bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

static bfd_reloc_status_type
score_elf_gprel15_reloc (bfd *abfd,
                         arelent *reloc_entry,
                         asymbol *symbol,
                         void * data,
                         asection *input_section,
                         bfd *output_bfd,
                         char **error_message)
{
  bfd_boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0 && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
  if (output_bfd != NULL)
    relocateable = TRUE;
  else
    {
      relocateable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = score_elf_final_gp (output_bfd, symbol, relocateable, error_message, &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  return score_elf_gprel15_with_gp (abfd, symbol, reloc_entry,
                                         input_section, relocateable, data, gp);
}

/* Do a R_SCORE_GPREL32 relocation.  This is a 32 bit value which must
   become the offset from the gp register.  */

static bfd_reloc_status_type
score_elf_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
                        void *data, asection *input_section, bfd *output_bfd,
                        char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  /* R_SCORE_GPREL32 relocations are defined for local symbols only.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      *error_message = (char *)
        _("32bits gp relative relocation occurs for an external symbol");
      return bfd_reloc_outofrange;
    }

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = score_elf_final_gp (output_bfd, symbol, relocatable, error_message, &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  gp = 0;
  return gprel32_with_gp (abfd, symbol, reloc_entry, input_section,
                          relocatable, data, gp);
}

/* A howto special_function for R_SCORE_GOT15 relocations.  This is just
   like any other 16-bit relocation when applied to global symbols, but is
   treated in the same as R_SCORE_HI16 when applied to local symbols.  */
static bfd_reloc_status_type
score_elf_got15_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
                       void *data, asection *input_section,
                       bfd *output_bfd, char **error_message)
{
  if ((symbol->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
      || bfd_is_und_section (bfd_get_section (symbol))
      || bfd_is_com_section (bfd_get_section (symbol)))
    /* The relocation is against a global symbol.  */
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
                                  input_section, output_bfd,
                                  error_message);

  return score_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
                               input_section, output_bfd, error_message);
}

static bfd_reloc_status_type
score_elf_got_lo16_reloc (bfd *abfd,
                          arelent *reloc_entry,
                          asymbol *symbol ATTRIBUTE_UNUSED,
                          void * data,
                          asection *input_section,
                          bfd *output_bfd ATTRIBUTE_UNUSED,
                          char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma addend = 0, offset = 0;
  signed long val;
  signed long hi16_offset, hi16_value, uvalue;

  hi16_value = score_bfd_get_32 (abfd, hi16_rel_addr);
  hi16_offset = ((((hi16_value >> 16) & 0x3) << 15) | (hi16_value & 0x7fff)) >> 1;
  addend = score_bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  offset = ((((addend >> 16) & 0x3) << 15) | (addend & 0x7fff)) >> 1;
  val = reloc_entry->addend;
  if (reloc_entry->address > input_section->size)
    return bfd_reloc_outofrange;
  uvalue = ((hi16_offset << 16) | (offset & 0xffff)) + val;
  if ((uvalue > -0x8000) && (uvalue < 0x7fff))
    hi16_offset = 0;
  else
    hi16_offset = (uvalue >> 16) & 0x7fff;
  hi16_value = (hi16_value & ~0x37fff) | (hi16_offset & 0x7fff) | ((hi16_offset << 1) & 0x30000);
  score_bfd_put_32 (abfd, hi16_value, hi16_rel_addr);
  offset = (uvalue & 0xffff) << 1;
  addend = (addend & ~0x37fff) | (offset & 0x7fff) | ((offset << 1) & 0x30000);
  score_bfd_put_32 (abfd, addend, (bfd_byte *) data + reloc_entry->address);
  return bfd_reloc_ok;
}

static reloc_howto_type elf32_score_howto_table[] =
{
  /* No relocation.  */
  HOWTO (R_SCORE_NONE,          /* type */
         0,                     /* rightshift */
         0,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE_NONE",        /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* R_SCORE_HI16 */
  HOWTO (R_SCORE_HI16,          /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         16,                    /* bitsize */
         FALSE,                 /* pc_relative */
         1,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         score_elf_hi16_reloc,  /* special_function */
         "R_SCORE_HI16",        /* name */
         TRUE,                  /* partial_inplace */
         0x37fff,               /* src_mask */
         0x37fff,               /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* R_SCORE_LO16 */
  HOWTO (R_SCORE_LO16,          /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         16,                    /* bitsize */
         FALSE,                 /* pc_relative */
         1,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         score_elf_lo16_reloc,  /* special_function */
         "R_SCORE_LO16",        /* name */
         TRUE,                  /* partial_inplace */
         0x37fff,               /* src_mask */
         0x37fff,               /* dst_mask */
         FALSE),                /* pcrel_offset */

  /*  R_SCORE_BCMP */
  HOWTO (R_SCORE_BCMP,          /* type */
         1,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         16,                    /* bitsize */
         TRUE,                  /* pc_relative */
         1,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE_BCMP",        /* name */
         FALSE,                 /* partial_inplace */
         0x03e00381,            /* src_mask */
         0x03e00381,            /* dst_mask */
         FALSE),                /* pcrel_offset */

  /*R_SCORE_24 */
  HOWTO (R_SCORE_24,            /* type */
         1,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         24,                    /* bitsize */
         FALSE,                 /* pc_relative */
         1,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE_24",          /* name */
         FALSE,                 /* partial_inplace */
         0x3ff7fff,             /* src_mask */
         0x3ff7fff,             /* dst_mask */
         FALSE),                /* pcrel_offset */

  /*R_SCORE_PC19 */
  HOWTO (R_SCORE_PC19,          /* type */
         1,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         19,                    /* bitsize */
         TRUE,                  /* pc_relative */
         1,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE_PC19",        /* name */
         FALSE,                 /* partial_inplace */
         0x3ff03fe,             /* src_mask */
         0x3ff03fe,             /* dst_mask */
         FALSE),                /* pcrel_offset */

  /*R_SCORE16_11 */
  HOWTO (R_SCORE16_11,          /* type */
         1,                     /* rightshift */
         1,                     /* size (0 = byte, 1 = short, 2 = long) */
         11,                    /* bitsize */
         FALSE,                 /* pc_relative */
         1,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE16_11",        /* name */
         FALSE,                 /* partial_inplace */
         0x000000ffe,           /* src_mask */
         0x000000ffe,           /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* R_SCORE16_PC8 */
  HOWTO (R_SCORE16_PC8,         /* type */
         1,                     /* rightshift */
         1,                     /* size (0 = byte, 1 = short, 2 = long) */
         9,                     /* bitsize */
         TRUE,                  /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE16_PC8",       /* name */
         FALSE,                 /* partial_inplace */
         0x000001ff,            /* src_mask */
         0x000001ff,            /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* 32 bit absolute */
  HOWTO (R_SCORE_ABS32,         /* type  8 */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,    /* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE_ABS32",       /* name */
         FALSE,                 /* partial_inplace */
         0xffffffff,            /* src_mask */
         0xffffffff,            /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* 16 bit absolute */
  HOWTO (R_SCORE_ABS16,         /* type 11 */
         0,                     /* rightshift */
         1,                     /* size (0 = byte, 1 = short, 2 = long) */
         16,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,    /* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE_ABS16",       /* name */
         FALSE,                 /* partial_inplace */
         0x0000ffff,            /* src_mask */
         0x0000ffff,            /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* R_SCORE_DUMMY2 */
  HOWTO (R_SCORE_DUMMY2,        /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         16,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE_DUMMY2",      /* name */
         TRUE,                  /* partial_inplace */
         0x00007fff,            /* src_mask */
         0x00007fff,            /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* R_SCORE_GP15 */
  HOWTO (R_SCORE_GP15,          /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         16,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         score_elf_gprel15_reloc,/* special_function */
         "R_SCORE_GP15",        /* name */
         TRUE,                  /* partial_inplace */
         0x00007fff,            /* src_mask */
         0x00007fff,            /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_SCORE_GNU_VTINHERIT, /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         NULL,                  /* special_function */
         "R_SCORE_GNU_VTINHERIT",       /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_SCORE_GNU_VTENTRY,   /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_SCORE_GNU_VTENTRY", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* Reference to global offset table.  */
  HOWTO (R_SCORE_GOT15,         /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         16,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_signed,      /* complain_on_overflow */
         score_elf_got15_reloc, /* special_function */
         "R_SCORE_GOT15",       /* name */
         TRUE,                  /* partial_inplace */
         0x00007fff,            /* src_mask */
         0x00007fff,            /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_SCORE_GOT_LO16,      /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         16,                    /* bitsize */
         FALSE,                 /* pc_relative */
         1,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         score_elf_got_lo16_reloc, /* special_function */
         "R_SCORE_GOT_LO16",    /* name */
         TRUE,                  /* partial_inplace */
         0x37ffe,               /* src_mask */
         0x37ffe,               /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* 15 bit call through global offset table.  */
  HOWTO (R_SCORE_CALL15,        /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         16,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_signed, /* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE_CALL15",      /* name */
         TRUE,                  /* partial_inplace */
         0x0000ffff,            /* src_mask */
         0x0000ffff,            /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* 32 bit GP relative reference.  */
  HOWTO (R_SCORE_GPREL32,       /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         score_elf_gprel32_reloc, /* special_function */
         "R_SCORE_GPREL32",     /* name */
         TRUE,                  /* partial_inplace */
         0xffffffff,            /* src_mask */
         0xffffffff,            /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* 32 bit symbol relative relocation.  */
  HOWTO (R_SCORE_REL32,         /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE_REL32",       /* name */
         TRUE,                  /* partial_inplace */
         0xffffffff,            /* src_mask */
         0xffffffff,            /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* R_SCORE_DUMMY_HI16 */
  HOWTO (R_SCORE_DUMMY_HI16,    /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         16,                    /* bitsize */
         FALSE,                 /* pc_relative */
         1,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         score_elf_hi16_reloc,  /* special_function */
         "R_SCORE_DUMMY_HI16",  /* name */
         TRUE,                  /* partial_inplace */
         0x37fff,               /* src_mask */
         0x37fff,               /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* R_SCORE_IMM30 */
  HOWTO (R_SCORE_IMM30,         /* type */
         2,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         30,                    /* bitsize */
         FALSE,                 /* pc_relative */
         7,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE_IMM30",       /* name */
         FALSE,                 /* partial_inplace */
         0x7f7fff7f80LL,        /* src_mask */
         0x7f7fff7f80LL,        /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* R_SCORE_IMM32 */
  HOWTO (R_SCORE_IMM32,         /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         5,                     /* bitpos */
         complain_overflow_dont,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_SCORE_IMM32",       /* name */
         FALSE,                 /* partial_inplace */
         0x7f7fff7fe0LL,        /* src_mask */
         0x7f7fff7fe0LL,        /* dst_mask */
         FALSE),                /* pcrel_offset */
};

struct score_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char elf_reloc_val;
};

static const struct score_reloc_map elf32_score_reloc_map[] =
{
  {BFD_RELOC_NONE,               R_SCORE_NONE},
  {BFD_RELOC_HI16_S,             R_SCORE_HI16},
  {BFD_RELOC_LO16,               R_SCORE_LO16},
  {BFD_RELOC_SCORE_BCMP,         R_SCORE_BCMP},
  {BFD_RELOC_SCORE_JMP,          R_SCORE_24},
  {BFD_RELOC_SCORE_BRANCH,       R_SCORE_PC19},
  {BFD_RELOC_SCORE16_JMP,        R_SCORE16_11},
  {BFD_RELOC_SCORE16_BRANCH,     R_SCORE16_PC8},
  {BFD_RELOC_32,                 R_SCORE_ABS32},
  {BFD_RELOC_16,                 R_SCORE_ABS16},
  {BFD_RELOC_SCORE_DUMMY2,       R_SCORE_DUMMY2},
  {BFD_RELOC_SCORE_GPREL15,      R_SCORE_GP15},
  {BFD_RELOC_VTABLE_INHERIT,     R_SCORE_GNU_VTINHERIT},
  {BFD_RELOC_VTABLE_ENTRY,       R_SCORE_GNU_VTENTRY},
  {BFD_RELOC_SCORE_GOT15,        R_SCORE_GOT15},
  {BFD_RELOC_SCORE_GOT_LO16,     R_SCORE_GOT_LO16},
  {BFD_RELOC_SCORE_CALL15,       R_SCORE_CALL15},
  {BFD_RELOC_GPREL32,            R_SCORE_GPREL32},
  {BFD_RELOC_32_PCREL,           R_SCORE_REL32},
  {BFD_RELOC_SCORE_DUMMY_HI16,   R_SCORE_DUMMY_HI16},
  {BFD_RELOC_SCORE_IMM30,        R_SCORE_IMM30},
  {BFD_RELOC_SCORE_IMM32,        R_SCORE_IMM32},
};

/* got_entries only match if they're identical, except for gotidx, so
   use all fields to compute the hash, and compare the appropriate
   union members.  */
static hashval_t
score_elf_got_entry_hash (const void *entry_)
{
  const struct score_got_entry *entry = (struct score_got_entry *)entry_;

  return entry->symndx
    + (!entry->abfd ? entry->d.address : entry->abfd->id);
}

static int
score_elf_got_entry_eq (const void *entry1, const void *entry2)
{
  const struct score_got_entry *e1 = (struct score_got_entry *)entry1;
  const struct score_got_entry *e2 = (struct score_got_entry *)entry2;

  return e1->abfd == e2->abfd && e1->symndx == e2->symndx
    && (! e1->abfd ? e1->d.address == e2->d.address
        : e1->symndx >= 0 ? e1->d.addend == e2->d.addend
        : e1->d.h == e2->d.h);
}

/* If H needs a GOT entry, assign it the highest available dynamic
   index.  Otherwise, assign it the lowest available dynamic
   index.  */
static bfd_boolean
score_elf_sort_hash_table_f (struct score_elf_link_hash_entry *h, void *data)
{
  struct score_elf_hash_sort_data *hsd = data;

  /* Symbols without dynamic symbol table entries aren't interesting at all.  */
  if (h->root.dynindx == -1)
    return TRUE;

  /* Global symbols that need GOT entries that are not explicitly
     referenced are marked with got offset 2.  Those that are
     referenced get a 1, and those that don't need GOT entries get
     -1.  */
  if (h->root.got.offset == 2)
    {
      if (hsd->max_unref_got_dynindx == hsd->min_got_dynindx)
        hsd->low = (struct elf_link_hash_entry *) h;
      h->root.dynindx = hsd->max_unref_got_dynindx++;
    }
  else if (h->root.got.offset != 1)
    h->root.dynindx = hsd->max_non_got_dynindx++;
  else
    {
      h->root.dynindx = --hsd->min_got_dynindx;
      hsd->low = (struct elf_link_hash_entry *) h;
    }

  return TRUE;
}

static asection *
score_elf_got_section (bfd *abfd, bfd_boolean maybe_excluded)
{
  asection *sgot = bfd_get_linker_section (abfd, ".got");

  if (sgot == NULL || (! maybe_excluded && (sgot->flags & SEC_EXCLUDE) != 0))
    return NULL;
  return sgot;
}

/* Returns the GOT information associated with the link indicated by
   INFO.  If SGOTP is non-NULL, it is filled in with the GOT section.  */
static struct score_got_info *
score_elf_got_info (bfd *abfd, asection **sgotp)
{
  asection *sgot;
  struct score_got_info *g;

  sgot = score_elf_got_section (abfd, TRUE);
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = score_elf_section_data (sgot)->u.got_info;
  BFD_ASSERT (g != NULL);

  if (sgotp)
    *sgotp = sgot;
  return g;
}

/* Sort the dynamic symbol table so that symbols that need GOT entries
   appear towards the end.  This reduces the amount of GOT space
   required.  MAX_LOCAL is used to set the number of local symbols
   known to be in the dynamic symbol table.  During
   s3_bfd_score_elf_size_dynamic_sections, this value is 1.  Afterward, the
   section symbols are added and the count is higher.  */
static bfd_boolean
score_elf_sort_hash_table (struct bfd_link_info *info,
                           unsigned long max_local)
{
  struct score_elf_hash_sort_data hsd;
  struct score_got_info *g;
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  g = score_elf_got_info (dynobj, NULL);

  hsd.low = NULL;
  hsd.max_unref_got_dynindx =
    hsd.min_got_dynindx = elf_hash_table (info)->dynsymcount
    /* In the multi-got case, assigned_gotno of the master got_info
       indicate the number of entries that aren't referenced in the
       primary GOT, but that must have entries because there are
       dynamic relocations that reference it.  Since they aren't
       referenced, we move them to the end of the GOT, so that they
       don't prevent other entries that are referenced from getting
       too large offsets.  */
    - (g->next ? g->assigned_gotno : 0);
  hsd.max_non_got_dynindx = max_local;
  score_elf_link_hash_traverse (elf_hash_table (info),
				score_elf_sort_hash_table_f,
				&hsd);

  /* There should have been enough room in the symbol table to
     accommodate both the GOT and non-GOT symbols.  */
  BFD_ASSERT (hsd.max_non_got_dynindx <= hsd.min_got_dynindx);
  BFD_ASSERT ((unsigned long)hsd.max_unref_got_dynindx
              <= elf_hash_table (info)->dynsymcount);

  /* Now we know which dynamic symbol has the lowest dynamic symbol
     table index in the GOT.  */
  g->global_gotsym = hsd.low;

  return TRUE;
}

/* Create an entry in an score ELF linker hash table.  */

static struct bfd_hash_entry *
score_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
                             struct bfd_hash_table *table,
                             const char *string)
{
  struct score_elf_link_hash_entry *ret = (struct score_elf_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a subclass.  */
  if (ret == NULL)
    ret = bfd_hash_allocate (table, sizeof (struct score_elf_link_hash_entry));
  if (ret == NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct score_elf_link_hash_entry *)
         _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));

  if (ret != NULL)
    {
      ret->possibly_dynamic_relocs = 0;
      ret->readonly_reloc = FALSE;
      ret->no_fn_stub = FALSE;
      ret->forced_local = FALSE;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Returns the first relocation of type r_type found, beginning with
   RELOCATION.  RELEND is one-past-the-end of the relocation table.  */
static const Elf_Internal_Rela *
score_elf_next_relocation (bfd *abfd ATTRIBUTE_UNUSED, unsigned int r_type,
                            const Elf_Internal_Rela *relocation,
                           const Elf_Internal_Rela *relend)
{
  while (relocation < relend)
    {
      if (ELF32_R_TYPE (relocation->r_info) == r_type)
        return relocation;

      ++relocation;
    }

  /* We didn't find it.  */
  bfd_set_error (bfd_error_bad_value);
  return NULL;
}

/* This function is called via qsort() to sort the dynamic relocation
   entries by increasing r_symndx value.  */
static int
score_elf_sort_dynamic_relocs (const void *arg1, const void *arg2)
{
  Elf_Internal_Rela int_reloc1;
  Elf_Internal_Rela int_reloc2;

  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, arg1, &int_reloc1);
  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, arg2, &int_reloc2);

  return (ELF32_R_SYM (int_reloc1.r_info) - ELF32_R_SYM (int_reloc2.r_info));
}

/* Return whether a relocation is against a local symbol.  */
static bfd_boolean
score_elf_local_relocation_p (bfd *input_bfd,
                              const Elf_Internal_Rela *relocation,
                              asection **local_sections,
                              bfd_boolean check_forced)
{
  unsigned long r_symndx;
  Elf_Internal_Shdr *symtab_hdr;
  struct score_elf_link_hash_entry *h;
  size_t extsymoff;

  r_symndx = ELF32_R_SYM (relocation->r_info);
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  extsymoff = (elf_bad_symtab (input_bfd)) ? 0 : symtab_hdr->sh_info;

  if (r_symndx < extsymoff)
    return TRUE;
  if (elf_bad_symtab (input_bfd) && local_sections[r_symndx] != NULL)
    return TRUE;

  if (check_forced)
    {
      /* Look up the hash table to check whether the symbol was forced local.  */
      h = (struct score_elf_link_hash_entry *)
        elf_sym_hashes (input_bfd) [r_symndx - extsymoff];
      /* Find the real hash-table entry for this symbol.  */
      while (h->root.root.type == bfd_link_hash_indirect
             || h->root.root.type == bfd_link_hash_warning)
        h = (struct score_elf_link_hash_entry *) h->root.root.u.i.link;
      if (h->root.forced_local)
        return TRUE;
    }

  return FALSE;
}

/* Returns the dynamic relocation section for DYNOBJ.  */
static asection *
score_elf_rel_dyn_section (bfd *dynobj, bfd_boolean create_p)
{
  static const char dname[] = ".rel.dyn";
  asection *sreloc;

  sreloc = bfd_get_linker_section (dynobj, dname);
  if (sreloc == NULL && create_p)
    {
      sreloc = bfd_make_section_anyway_with_flags (dynobj, dname,
						   (SEC_ALLOC
						    | SEC_LOAD
						    | SEC_HAS_CONTENTS
						    | SEC_IN_MEMORY
						    | SEC_LINKER_CREATED
						    | SEC_READONLY));
      if (sreloc == NULL
          || ! bfd_set_section_alignment (dynobj, sreloc,
                                          SCORE_ELF_LOG_FILE_ALIGN (dynobj)))
        return NULL;
    }
  return sreloc;
}

static void
score_elf_allocate_dynamic_relocations (bfd *abfd, unsigned int n)
{
  asection *s;

  s = score_elf_rel_dyn_section (abfd, FALSE);
  BFD_ASSERT (s != NULL);

  if (s->size == 0)
    {
      /* Make room for a null element.  */
      s->size += SCORE_ELF_REL_SIZE (abfd);
      ++s->reloc_count;
    }
  s->size += n * SCORE_ELF_REL_SIZE (abfd);
}

/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL
   is the original relocation, which is now being transformed into a
   dynamic relocation.  The ADDENDP is adjusted if necessary; the
   caller should store the result in place of the original addend.  */
static bfd_boolean
score_elf_create_dynamic_relocation (bfd *output_bfd,
                                     struct bfd_link_info *info,
                                     const Elf_Internal_Rela *rel,
                                     struct score_elf_link_hash_entry *h,
                                     bfd_vma symbol,
                                     bfd_vma *addendp, asection *input_section)
{
  Elf_Internal_Rela outrel[3];
  asection *sreloc;
  bfd *dynobj;
  int r_type;
  long indx;
  bfd_boolean defined_p;

  r_type = ELF32_R_TYPE (rel->r_info);
  dynobj = elf_hash_table (info)->dynobj;
  sreloc = score_elf_rel_dyn_section (dynobj, FALSE);
  BFD_ASSERT (sreloc != NULL);
  BFD_ASSERT (sreloc->contents != NULL);
  BFD_ASSERT (sreloc->reloc_count * SCORE_ELF_REL_SIZE (output_bfd) < sreloc->size);

  outrel[0].r_offset =
    _bfd_elf_section_offset (output_bfd, info, input_section, rel[0].r_offset);
  outrel[1].r_offset =
    _bfd_elf_section_offset (output_bfd, info, input_section, rel[1].r_offset);
  outrel[2].r_offset =
    _bfd_elf_section_offset (output_bfd, info, input_section, rel[2].r_offset);

  if (outrel[0].r_offset == MINUS_ONE)
    /* The relocation field has been deleted.  */
    return TRUE;

  if (outrel[0].r_offset == MINUS_TWO)
    {
      /* The relocation field has been converted into a relative value of
         some sort.  Functions like _bfd_elf_write_section_eh_frame expect
         the field to be fully relocated, so add in the symbol's value.  */
      *addendp += symbol;
      return TRUE;
    }

  /* We must now calculate the dynamic symbol table index to use
     in the relocation.  */
  if (h != NULL
      && (! info->symbolic || !h->root.def_regular)
      /* h->root.dynindx may be -1 if this symbol was marked to
         become local.  */
      && h->root.dynindx != -1)
    {
      indx = h->root.dynindx;
        /* ??? glibc's ld.so just adds the final GOT entry to the
           relocation field.  It therefore treats relocs against
           defined symbols in the same way as relocs against
           undefined symbols.  */
      defined_p = FALSE;
    }
  else
    {
      indx = 0;
      defined_p = TRUE;
    }

  /* If the relocation was previously an absolute relocation and
     this symbol will not be referred to by the relocation, we must
     adjust it by the value we give it in the dynamic symbol table.
     Otherwise leave the job up to the dynamic linker.  */
  if (defined_p && r_type != R_SCORE_REL32)
    *addendp += symbol;

  /* The relocation is always an REL32 relocation because we don't
     know where the shared library will wind up at load-time.  */
  outrel[0].r_info = ELF32_R_INFO ((unsigned long) indx, R_SCORE_REL32);

  /* For strict adherence to the ABI specification, we should
     generate a R_SCORE_64 relocation record by itself before the
     _REL32/_64 record as well, such that the addend is read in as
     a 64-bit value (REL32 is a 32-bit relocation, after all).
     However, since none of the existing ELF64 SCORE dynamic
     loaders seems to care, we don't waste space with these
     artificial relocations.  If this turns out to not be true,
     score_elf_allocate_dynamic_relocations() should be tweaked so
     as to make room for a pair of dynamic relocations per
     invocation if ABI_64_P, and here we should generate an
     additional relocation record with R_SCORE_64 by itself for a
     NULL symbol before this relocation record.  */
  outrel[1].r_info = ELF32_R_INFO (0, R_SCORE_NONE);
  outrel[2].r_info = ELF32_R_INFO (0, R_SCORE_NONE);

  /* Adjust the output offset of the relocation to reference the
     correct location in the output file.  */
  outrel[0].r_offset += (input_section->output_section->vma
                         + input_section->output_offset);
  outrel[1].r_offset += (input_section->output_section->vma
                         + input_section->output_offset);
  outrel[2].r_offset += (input_section->output_section->vma
                         + input_section->output_offset);

  /* Put the relocation back out.  We have to use the special
     relocation outputter in the 64-bit case since the 64-bit
     relocation format is non-standard.  */
  bfd_elf32_swap_reloc_out
      (output_bfd, &outrel[0],
       (sreloc->contents + sreloc->reloc_count * sizeof (Elf32_External_Rel)));

  /* We've now added another relocation.  */
  ++sreloc->reloc_count;

  /* Make sure the output section is writable.  The dynamic linker
     will be writing to it.  */
  elf_section_data (input_section->output_section)->this_hdr.sh_flags |= SHF_WRITE;

  return TRUE;
}

static bfd_boolean
score_elf_create_got_section (bfd *abfd,
                              struct bfd_link_info *info,
                              bfd_boolean maybe_exclude)
{
  flagword flags;
  asection *s;
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  struct score_got_info *g;
  bfd_size_type amt;

  /* This function may be called more than once.  */
  s = score_elf_got_section (abfd, TRUE);
  if (s)
    {
      if (! maybe_exclude)
        s->flags &= ~SEC_EXCLUDE;
      return TRUE;
    }

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);

  if (maybe_exclude)
    flags |= SEC_EXCLUDE;

  /* We have to use an alignment of 2**4 here because this is hardcoded
     in the function stub generation and in the linker script.  */
  s = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
   if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, 4))
    return FALSE;

  /* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the
     linker script because we don't want to define the symbol if we
     are not creating a global offset table.  */
  bh = NULL;
  if (! (_bfd_generic_link_add_one_symbol
         (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
          0, NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;

  h = (struct elf_link_hash_entry *) bh;
  h->non_elf = 0;
  h->def_regular = 1;
  h->type = STT_OBJECT;

  if (info->shared && ! bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;

  amt = sizeof (struct score_got_info);
  g = bfd_alloc (abfd, amt);
  if (g == NULL)
    return FALSE;

  g->global_gotsym = NULL;
  g->global_gotno = 0;

  g->local_gotno = SCORE_RESERVED_GOTNO;
  g->assigned_gotno = SCORE_RESERVED_GOTNO;
  g->next = NULL;

  g->got_entries = htab_try_create (1, score_elf_got_entry_hash,
                                    score_elf_got_entry_eq, NULL);
  if (g->got_entries == NULL)
    return FALSE;
  score_elf_section_data (s)->u.got_info = g;
  score_elf_section_data (s)->elf.this_hdr.sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_SCORE_GPREL;

  return TRUE;
}

/* Calculate the %high function.  */
static bfd_vma
score_elf_high (bfd_vma value)
{
  return ((value + (bfd_vma) 0x8000) >> 16) & 0xffff;
}

/* Create a local GOT entry for VALUE.  Return the index of the entry,
   or -1 if it could not be created.  */
static struct score_got_entry *
score_elf_create_local_got_entry (bfd *abfd,
                                  bfd *ibfd ATTRIBUTE_UNUSED,
                                  struct score_got_info *gg,
                                  asection *sgot, bfd_vma value,
                                  unsigned long r_symndx ATTRIBUTE_UNUSED,
                                  struct score_elf_link_hash_entry *h ATTRIBUTE_UNUSED,
                                  int r_type ATTRIBUTE_UNUSED)
{
  struct score_got_entry entry, **loc;
  struct score_got_info *g;

  entry.abfd = NULL;
  entry.symndx = -1;
  entry.d.address = value;

  g = gg;
  loc = (struct score_got_entry **) htab_find_slot (g->got_entries, &entry, INSERT);
  if (*loc)
    return *loc;

  entry.gotidx = SCORE_ELF_GOT_SIZE (abfd) * g->assigned_gotno++;

  *loc = bfd_alloc (abfd, sizeof entry);

  if (! *loc)
    return NULL;

  memcpy (*loc, &entry, sizeof entry);

  if (g->assigned_gotno >= g->local_gotno)
    {
      (*loc)->gotidx = -1;
      /* We didn't allocate enough space in the GOT.  */
      (*_bfd_error_handler)
        (_("not enough GOT space for local GOT entries"));
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  score_bfd_put_32 (abfd, value, (sgot->contents + entry.gotidx));

  return *loc;
}

/* Find a GOT entry whose higher-order 16 bits are the same as those
   for value.  Return the index into the GOT for this entry.  */
static bfd_vma
score_elf_got16_entry (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
                       bfd_vma value, bfd_boolean external)
{
  asection *sgot;
  struct score_got_info *g;
  struct score_got_entry *entry;

  if (!external)
    {
      /* Although the ABI says that it is "the high-order 16 bits" that we
         want, it is really the %high value.  The complete value is
         calculated with a `addiu' of a LO16 relocation, just as with a
         HI16/LO16 pair.  */
      value = score_elf_high (value) << 16;
    }

  g = score_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  entry = score_elf_create_local_got_entry (abfd, ibfd, g, sgot, value, 0, NULL,
                                            R_SCORE_GOT15);
  if (entry)
    return entry->gotidx;
  else
    return MINUS_ONE;
}

static void
s3_bfd_score_elf_hide_symbol (struct bfd_link_info *info,
                              struct elf_link_hash_entry *entry,
                              bfd_boolean force_local)
{
  bfd *dynobj;
  asection *got;
  struct score_got_info *g;
  struct score_elf_link_hash_entry *h;

  h = (struct score_elf_link_hash_entry *) entry;
  if (h->forced_local)
    return;
  h->forced_local = TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj != NULL && force_local)
    {
      got = score_elf_got_section (dynobj, FALSE);
      if (got == NULL)
        return;
      g = score_elf_section_data (got)->u.got_info;

      if (g->next)
        {
          struct score_got_entry e;
          struct score_got_info *gg = g;

          /* Since we're turning what used to be a global symbol into a
             local one, bump up the number of local entries of each GOT
             that had an entry for it.  This will automatically decrease
             the number of global entries, since global_gotno is actually
             the upper limit of global entries.  */
          e.abfd = dynobj;
          e.symndx = -1;
          e.d.h = h;

          for (g = g->next; g != gg; g = g->next)
            if (htab_find (g->got_entries, &e))
              {
                BFD_ASSERT (g->global_gotno > 0);
                g->local_gotno++;
                g->global_gotno--;
              }

          /* If this was a global symbol forced into the primary GOT, we
             no longer need an entry for it.  We can't release the entry
             at this point, but we must at least stop counting it as one
             of the symbols that required a forced got entry.  */
          if (h->root.got.offset == 2)
            {
              BFD_ASSERT (gg->assigned_gotno > 0);
              gg->assigned_gotno--;
            }
        }
      else if (g->global_gotno == 0 && g->global_gotsym == NULL)
        /* If we haven't got through GOT allocation yet, just bump up the
              number of local entries, as this symbol won't be counted as
              global.  */
        g->local_gotno++;
      else if (h->root.got.offset == 1)
        {
          /* If we're past non-multi-GOT allocation and this symbol had
                  been marked for a global got entry, give it a local entry
                  instead.  */
          BFD_ASSERT (g->global_gotno > 0);
          g->local_gotno++;
          g->global_gotno--;
        }
    }

  _bfd_elf_link_hash_hide_symbol (info, &h->root, force_local);
}

/* If H is a symbol that needs a global GOT entry, but has a dynamic
   symbol table index lower than any we've seen to date, record it for
   posterity.  */
static bfd_boolean
score_elf_record_global_got_symbol (struct elf_link_hash_entry *h,
                                    bfd *abfd,
                                    struct bfd_link_info *info,
                                    struct score_got_info *g)
{
  struct score_got_entry entry, **loc;

  /* A global symbol in the GOT must also be in the dynamic symbol table.  */
  if (h->dynindx == -1)
    {
      switch (ELF_ST_VISIBILITY (h->other))
        {
        case STV_INTERNAL:
        case STV_HIDDEN:
          s3_bfd_score_elf_hide_symbol (info, h, TRUE);
          break;
        }
      if (!bfd_elf_link_record_dynamic_symbol (info, h))
        return FALSE;
    }

  entry.abfd = abfd;
  entry.symndx = -1;
  entry.d.h = (struct score_elf_link_hash_entry *)h;

  loc = (struct score_got_entry **)htab_find_slot (g->got_entries, &entry, INSERT);

  /* If we've already marked this entry as needing GOT space, we don't
     need to do it again.  */
  if (*loc)
    return TRUE;

  *loc = bfd_alloc (abfd, sizeof entry);
  if (! *loc)
    return FALSE;

  entry.gotidx = -1;

  memcpy (*loc, &entry, sizeof (entry));

  if (h->got.offset != MINUS_ONE)
    return TRUE;

  /* By setting this to a value other than -1, we are indicating that
     there needs to be a GOT entry for H.  Avoid using zero, as the
     generic ELF copy_indirect_symbol tests for <= 0.  */
  h->got.offset = 1;

  return TRUE;
}

/* Reserve space in G for a GOT entry containing the value of symbol
   SYMNDX in input bfd ABDF, plus ADDEND.  */
static bfd_boolean
score_elf_record_local_got_symbol (bfd *abfd,
                                   long symndx,
                                   bfd_vma addend,
                                   struct score_got_info *g)
{
  struct score_got_entry entry, **loc;

  entry.abfd = abfd;
  entry.symndx = symndx;
  entry.d.addend = addend;
  loc = (struct score_got_entry **)htab_find_slot (g->got_entries, &entry, INSERT);

  if (*loc)
    return TRUE;

  entry.gotidx = g->local_gotno++;

  *loc = bfd_alloc (abfd, sizeof(entry));
  if (! *loc)
    return FALSE;

  memcpy (*loc, &entry, sizeof (entry));

  return TRUE;
}

/* Returns the GOT offset at which the indicated address can be found.
   If there is not yet a GOT entry for this value, create one.
   Returns -1 if no satisfactory GOT offset can be found.  */
static bfd_vma
score_elf_local_got_index (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
                           bfd_vma value, unsigned long r_symndx,
                           struct score_elf_link_hash_entry *h, int r_type)
{
  asection *sgot;
  struct score_got_info *g;
  struct score_got_entry *entry;

  g = score_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  entry = score_elf_create_local_got_entry (abfd, ibfd, g, sgot, value,
                                             r_symndx, h, r_type);
  if (!entry)
    return MINUS_ONE;

  else
    return entry->gotidx;
}

/* Returns the GOT index for the global symbol indicated by H.  */

static bfd_vma
score_elf_global_got_index (bfd *abfd, struct elf_link_hash_entry *h)
{
  bfd_vma got_index;
  asection *sgot;
  struct score_got_info *g;
  long global_got_dynindx = 0;

  g = score_elf_got_info (abfd, &sgot);
  if (g->global_gotsym != NULL)
    global_got_dynindx = g->global_gotsym->dynindx;

  /* Once we determine the global GOT entry with the lowest dynamic
     symbol table index, we must put all dynamic symbols with greater
     indices into the GOT.  That makes it easy to calculate the GOT
     offset.  */
  BFD_ASSERT (h->dynindx >= global_got_dynindx);
  got_index = ((h->dynindx - global_got_dynindx + g->local_gotno) * SCORE_ELF_GOT_SIZE (abfd));
  BFD_ASSERT (got_index < sgot->size);

  return got_index;
}

/* Returns the offset for the entry at the INDEXth position in the GOT.  */

static bfd_vma
score_elf_got_offset_from_index (bfd *dynobj,
				 bfd *output_bfd,
                                 bfd *input_bfd ATTRIBUTE_UNUSED,
				 bfd_vma got_index)
{
  asection *sgot;
  bfd_vma gp;

  score_elf_got_info (dynobj, &sgot);
  gp = _bfd_get_gp_value (output_bfd);

  return sgot->output_section->vma + sgot->output_offset + got_index - gp;
}

/* Follow indirect and warning hash entries so that each got entry
   points to the final symbol definition.  P must point to a pointer
   to the hash table we're traversing.  Since this traversal may
   modify the hash table, we set this pointer to NULL to indicate
   we've made a potentially-destructive change to the hash table, so
   the traversal must be restarted.  */
static int
score_elf_resolve_final_got_entry (void **entryp, void *p)
{
  struct score_got_entry *entry = (struct score_got_entry *)*entryp;
  htab_t got_entries = *(htab_t *)p;

  if (entry->abfd != NULL && entry->symndx == -1)
    {
      struct score_elf_link_hash_entry *h = entry->d.h;

      while (h->root.root.type == bfd_link_hash_indirect
             || h->root.root.type == bfd_link_hash_warning)
        h = (struct score_elf_link_hash_entry *) h->root.root.u.i.link;

      if (entry->d.h == h)
        return 1;

      entry->d.h = h;

      /* If we can't find this entry with the new bfd hash, re-insert
         it, and get the traversal restarted.  */
      if (! htab_find (got_entries, entry))
        {
          htab_clear_slot (got_entries, entryp);
          entryp = htab_find_slot (got_entries, entry, INSERT);
          if (! *entryp)
            *entryp = entry;
          /* Abort the traversal, since the whole table may have
             moved, and leave it up to the parent to restart the
             process.  */
          *(htab_t *)p = NULL;
          return 0;
        }
      /* We might want to decrement the global_gotno count, but it's
         either too early or too late for that at this point.  */
    }

  return 1;
}

/* Turn indirect got entries in a got_entries table into their final locations.  */
static void
score_elf_resolve_final_got_entries (struct score_got_info *g)
{
  htab_t got_entries;

  do
    {
      got_entries = g->got_entries;

      htab_traverse (got_entries,
                     score_elf_resolve_final_got_entry,
                     &got_entries);
    }
  while (got_entries == NULL);
}

/* Add INCREMENT to the reloc (of type HOWTO) at ADDRESS. for -r  */
static void
score_elf_add_to_rel (bfd *abfd,
                      bfd_byte *address,
                      reloc_howto_type *howto,
                      bfd_signed_vma increment)
{
  bfd_signed_vma addend;
  bfd_vma contents;
  unsigned long offset;
  unsigned long r_type = howto->type;
  unsigned long hi16_addend, hi16_offset, hi16_value, uvalue;

  contents = score_bfd_get_32 (abfd, address);
  /* Get the (signed) value from the instruction.  */
  addend = contents & howto->src_mask;
  if (addend & ((howto->src_mask + 1) >> 1))
    {
      bfd_signed_vma mask;

      mask = -1;
      mask &= ~howto->src_mask;
      addend |= mask;
    }
  /* Add in the increment, (which is a byte value).  */
  switch (r_type)
    {
    case R_SCORE_PC19:
      offset =
        (((contents & howto->src_mask) & 0x3ff0000) >> 6) | ((contents & howto->src_mask) & 0x3ff);
      offset += increment;
      contents =
        (contents & ~howto->
         src_mask) | (((offset << 6) & howto->src_mask) & 0x3ff0000) | (offset & 0x3ff);
      score_bfd_put_32 (abfd, contents, address);
      break;
    case R_SCORE_HI16:
      break;
    case R_SCORE_LO16:
      hi16_addend = score_bfd_get_32 (abfd, address - 4);
      hi16_offset = ((((hi16_addend >> 16) & 0x3) << 15) | (hi16_addend & 0x7fff)) >> 1;
      offset = ((((contents >> 16) & 0x3) << 15) | (contents & 0x7fff)) >> 1;
      offset = (hi16_offset << 16) | (offset & 0xffff);
      uvalue = increment + offset;
      hi16_offset = (uvalue >> 16) << 1;
      hi16_value = (hi16_addend & (~(howto->dst_mask)))
        | (hi16_offset & 0x7fff) | ((hi16_offset << 1) & 0x30000);
      score_bfd_put_32 (abfd, hi16_value, address - 4);
      offset = (uvalue & 0xffff) << 1;
      contents = (contents & (~(howto->dst_mask))) | (offset & 0x7fff) | ((offset << 1) & 0x30000);
      score_bfd_put_32 (abfd, contents, address);
      break;
    case R_SCORE_24:
      offset =
        (((contents & howto->src_mask) >> 1) & 0x1ff8000) | ((contents & howto->src_mask) & 0x7fff);
      offset += increment;
      contents =
        (contents & ~howto->
         src_mask) | (((offset << 1) & howto->src_mask) & 0x3ff0000) | (offset & 0x7fff);
      score_bfd_put_32 (abfd, contents, address);
      break;

    case R_SCORE16_11:

      contents = score_bfd_get_16 (abfd, address);
      offset = contents & howto->src_mask;
      offset += increment;
      contents = (contents & ~howto->src_mask) | (offset & howto->src_mask);
      score_bfd_put_16 (abfd, contents, address);

      break;
    case R_SCORE16_PC8:

      contents = score_bfd_get_16 (abfd, address);
      offset = (contents & howto->src_mask) + ((increment >> 1) & 0x1ff);
      contents = (contents & (~howto->src_mask)) | (offset & howto->src_mask);
      score_bfd_put_16 (abfd, contents, address);

      break;

    case R_SCORE_BCMP:
      contents = score_bfd_get_32 (abfd, address);
      offset = (contents & howto->src_mask);
      offset <<= howto->rightshift;
      offset += increment;
      offset >>= howto->rightshift;
      contents = (contents & (~howto->src_mask)) | (offset & howto->src_mask);
      score_bfd_put_32 (abfd, contents, address);
      break;

    case R_SCORE_IMM30:
      contents = score_bfd_get_48 (abfd, address);
      offset = (contents & howto->src_mask);
      offset <<= howto->rightshift;
      offset += increment;
      offset >>= howto->rightshift;
      contents = (contents & (~howto->src_mask)) | (offset & howto->src_mask);
      score_bfd_put_48 (abfd, contents, address);
      break;

    case R_SCORE_IMM32:
      contents = score_bfd_get_48 (abfd, address);
      offset = (contents & howto->src_mask);
      offset += increment;
      contents = (contents & (~howto->src_mask)) | (offset & howto->src_mask);
      score_bfd_put_48 (abfd, contents, address);
      break;

    default:
      addend += increment;
      contents = (contents & ~howto->dst_mask) | (addend & howto->dst_mask);
      score_bfd_put_32 (abfd, contents, address);
      break;
    }
}

/* Perform a relocation as part of a final link.  */
static bfd_reloc_status_type
score_elf_final_link_relocate (reloc_howto_type *howto,
                               bfd *input_bfd,
                               bfd *output_bfd,
                               asection *input_section,
                               bfd_byte *contents,
                               Elf_Internal_Rela *rel,
                               Elf_Internal_Rela *relocs,
                               bfd_vma symbol,
                               struct bfd_link_info *info,
                               const char *sym_name ATTRIBUTE_UNUSED,
                               int sym_flags ATTRIBUTE_UNUSED,
                               struct score_elf_link_hash_entry *h,
                               asection **local_sections,
                               bfd_boolean gp_disp_p)
{
  unsigned long r_type;
  unsigned long r_symndx;
  bfd_byte *hit_data = contents + rel->r_offset;
  bfd_vma addend;
  /* The final GP value to be used for the relocatable, executable, or
     shared object file being produced.  */
  bfd_vma gp = MINUS_ONE;
  /* The place (section offset or address) of the storage unit being relocated.  */
  bfd_vma rel_addr;
  /* The offset into the global offset table at which the address of the relocation entry
     symbol, adjusted by the addend, resides during execution.  */
  bfd_vma g = MINUS_ONE;
  /* TRUE if the symbol referred to by this relocation is a local symbol.  */
  bfd_boolean local_p;
  /* The eventual value we will relocate.  */
  bfd_vma value = symbol;
  unsigned long hi16_addend, hi16_offset, hi16_value, uvalue, offset, abs_value = 0;


  if (elf_gp (output_bfd) == 0)
    {
      struct bfd_link_hash_entry *bh;
      asection *o;

      bh = bfd_link_hash_lookup (info->hash, "_gp", 0, 0, 1);
      if (bh != NULL && bh->type == bfd_link_hash_defined)
        elf_gp (output_bfd) = (bh->u.def.value
                               + bh->u.def.section->output_section->vma
                               + bh->u.def.section->output_offset);
      else if (info->relocatable)
        {
          bfd_vma lo = -1;

          /* Find the GP-relative section with the lowest offset.  */
          for (o = output_bfd->sections; o != NULL; o = o->next)
            if (o->vma < lo)
              lo = o->vma;
          /* And calculate GP relative to that.  */
          elf_gp (output_bfd) = lo + ELF_SCORE_GP_OFFSET (input_bfd);
        }
      else
        {
          /* If the relocate_section function needs to do a reloc
             involving the GP value, it should make a reloc_dangerous
             callback to warn that GP is not defined.  */
        }
    }

  /* Parse the relocation.  */
  r_symndx = ELF32_R_SYM (rel->r_info);
  r_type = ELF32_R_TYPE (rel->r_info);
  rel_addr = (input_section->output_section->vma + input_section->output_offset + rel->r_offset);
  local_p = score_elf_local_relocation_p (input_bfd, rel, local_sections, TRUE);

  if (r_type == R_SCORE_GOT15)
    {
      const Elf_Internal_Rela *relend;
      const Elf_Internal_Rela *lo16_rel;
      const struct elf_backend_data *bed;
      bfd_vma lo_value = 0;

      bed = get_elf_backend_data (output_bfd);
      relend = relocs + input_section->reloc_count * bed->s->int_rels_per_ext_rel;
      lo16_rel = score_elf_next_relocation (input_bfd, R_SCORE_GOT_LO16, rel, relend);
      if ((local_p) && (lo16_rel != NULL))
        {
          bfd_vma tmp = 0;
          tmp = score_bfd_get_32 (input_bfd, contents + lo16_rel->r_offset);
          lo_value = (((tmp >> 16) & 0x3) << 14) | ((tmp & 0x7fff) >> 1);
        }
      addend = lo_value;
    }
  /* For score3 R_SCORE_ABS32.  */
  else if (r_type == R_SCORE_ABS32 || r_type == R_SCORE_REL32)
    {
      addend = (bfd_get_32 (input_bfd, hit_data) >> howto->bitpos) & howto->src_mask;
    }
  else
    {
      addend = (score_bfd_get_32 (input_bfd, hit_data) >> howto->bitpos) & howto->src_mask;
    }

  /* If we haven't already determined the GOT offset, or the GP value,
     and we're going to need it, get it now.  */
  switch (r_type)
    {
    case R_SCORE_CALL15:
    case R_SCORE_GOT15:
      if (!local_p)
        {
          g = score_elf_global_got_index (elf_hash_table (info)->dynobj,
                                          (struct elf_link_hash_entry *) h);
          if ((! elf_hash_table (info)->dynamic_sections_created
               || (info->shared
                   && (info->symbolic || h->root.dynindx == -1)
                   && h->root.def_regular)))
            {
              /* This is a static link or a -Bsymbolic link.  The
                 symbol is defined locally, or was forced to be local.
                 We must initialize this entry in the GOT.  */
              bfd *tmpbfd = elf_hash_table (info)->dynobj;
              asection *sgot = score_elf_got_section (tmpbfd, FALSE);
              score_bfd_put_32 (tmpbfd, value, sgot->contents + g);
            }
        }
      else if (r_type == R_SCORE_GOT15 || r_type == R_SCORE_CALL15)
        {
          /* There's no need to create a local GOT entry here; the
             calculation for a local GOT15 entry does not involve G.  */
          ;
        }
      else
        {
          g = score_elf_local_got_index (output_bfd, input_bfd, info,
                                         symbol + addend, r_symndx, h, r_type);
            if (g == MINUS_ONE)
            return bfd_reloc_outofrange;
        }

      /* Convert GOT indices to actual offsets.  */
      g = score_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
                                           output_bfd, input_bfd, g);
      break;

    case R_SCORE_HI16:
    case R_SCORE_LO16:
    case R_SCORE_GPREL32:
      gp = _bfd_get_gp_value (output_bfd);
      break;

    case R_SCORE_GP15:
      gp = _bfd_get_gp_value (output_bfd);

    default:
      break;
    }

  switch (r_type)
    {
    case R_SCORE_NONE:
      return bfd_reloc_ok;

    case R_SCORE_ABS32:
    case R_SCORE_REL32:
      if ((info->shared
           || (elf_hash_table (info)->dynamic_sections_created
               && h != NULL
               && h->root.def_dynamic
               && !h->root.def_regular))
           && r_symndx != STN_UNDEF
           && (input_section->flags & SEC_ALLOC) != 0)
        {
          /* If we're creating a shared library, or this relocation is against a symbol
             in a shared library, then we can't know where the symbol will end up.
             So, we create a relocation record in the output, and leave the job up
             to the dynamic linker.  */
          value = addend;
          if (!score_elf_create_dynamic_relocation (output_bfd, info, rel, h,
                                                    symbol, &value,
                                                    input_section))
            return bfd_reloc_undefined;
        }
      else if (r_symndx == STN_UNDEF)
        /* r_symndx will be STN_UNDEF (zero) only for relocs against symbols
           from removed linkonce sections, or sections discarded by
           a linker script.  */
        value = 0;
      else
        {
          if (r_type != R_SCORE_REL32)
            value = symbol + addend;
          else
            value = addend;
        }
      value &= howto->dst_mask;
      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_SCORE_ABS16:
      value += addend;
      if ((long)value > 0x7fff || (long)value < -0x8000)
        return bfd_reloc_overflow;
      score_bfd_put_16 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_SCORE_24:
      addend = score_bfd_get_32 (input_bfd, hit_data);
      offset = (((addend & howto->src_mask) >> 1) & 0x1ff8000) | ((addend & howto->src_mask) & 0x7fff);
      if ((offset & 0x1000000) != 0)
        offset |= 0xfe000000;
      value += offset;
      abs_value = abs (value - rel_addr);
      if ((abs_value & 0xfe000000) != 0)
        return bfd_reloc_overflow;
      addend = (addend & ~howto->src_mask)
                | (((value << 1) & howto->src_mask) & 0x3ff0000) | (value & 0x7fff);
      score_bfd_put_32 (input_bfd, addend, hit_data);
      return bfd_reloc_ok;

    /* signed imm32.  */
    case R_SCORE_IMM30:
      {
        int not_word_align_p = 0;
        bfd_vma imm_offset = 0;
        addend = score_bfd_get_48 (input_bfd, hit_data);
        imm_offset = ((addend >> 7) & 0xff)
                     | (((addend >> 16) & 0x7fff) << 8)
                     | (((addend >> 32) & 0x7f) << 23);
        imm_offset <<= howto->rightshift;
        value += imm_offset;
        value &= 0xffffffff;

        /* Check lw48/sw48 rd, value/label word align.  */
        if ((value & 0x3) != 0)
          not_word_align_p = 1;

        value >>= howto->rightshift;
        addend = (addend & ~howto->src_mask)
                 | (((value & 0xff) >> 0) << 7)
                 | (((value & 0x7fff00) >> 8) << 16)
                 | (((value & 0x3f800000) >> 23) << 32);
        score_bfd_put_48 (input_bfd, addend, hit_data);
        if (not_word_align_p)
          return bfd_reloc_other;
        else
          return bfd_reloc_ok;
      }

    case R_SCORE_IMM32:
      {
        bfd_vma imm_offset = 0;
        addend = score_bfd_get_48 (input_bfd, hit_data);
        imm_offset = ((addend >> 5) & 0x3ff)
                     | (((addend >> 16) & 0x7fff) << 10)
                     | (((addend >> 32) & 0x7f) << 25);
        value += imm_offset;
        value &= 0xffffffff;
        addend = (addend & ~howto->src_mask)
                 | ((value & 0x3ff) << 5)
                 | (((value >> 10) & 0x7fff) << 16)
                 | (((value >> 25) & 0x7f) << 32);
        score_bfd_put_48 (input_bfd, addend, hit_data);
        return bfd_reloc_ok;
      }

    case R_SCORE_PC19:
      addend = score_bfd_get_32 (input_bfd, hit_data);
      offset = (((addend & howto->src_mask) & 0x3ff0000) >> 6) | ((addend & howto->src_mask) & 0x3ff);
      if ((offset & 0x80000) != 0)
        offset |= 0xfff00000;
      abs_value = value = value - rel_addr + offset;
      /* exceed 20 bit : overflow.  */
      if ((abs_value & 0x80000000) == 0x80000000)
        abs_value = 0xffffffff - value + 1;
      if ((abs_value & 0xfff80000) != 0)
        return bfd_reloc_overflow;
      addend = (addend & ~howto->src_mask)
                | (((value << 6) & howto->src_mask) & 0x3ff0000) | (value & 0x3ff);
      score_bfd_put_32 (input_bfd, addend, hit_data);
      return bfd_reloc_ok;

    case R_SCORE16_11:
      addend = score_bfd_get_16 (input_bfd, hit_data);
      offset = addend & howto->src_mask;
      if ((offset & 0x800) != 0)        /* Offset is negative.  */
        offset |= 0xfffff000;
      value += offset;
      abs_value = abs (value - rel_addr);
      if ((abs_value & 0xfffff000) != 0)
        return bfd_reloc_overflow;
      addend = (addend & ~howto->src_mask) | (value & howto->src_mask);
      score_bfd_put_16 (input_bfd, addend, hit_data);
      return bfd_reloc_ok;

    case R_SCORE16_PC8:
      addend = score_bfd_get_16 (input_bfd, hit_data);
      offset = (addend & howto->src_mask) << 1;
      if ((offset & 0x200) != 0)        /* Offset is negative.  */
        offset |= 0xfffffe00;
      abs_value = value = value - rel_addr + offset;
      /* Sign bit + exceed 9 bit.  */
      if (((value & 0xfffffe00) != 0) && ((value & 0xfffffe00) != 0xfffffe00))
        return bfd_reloc_overflow;
      value >>= 1;
      addend = (addend & ~howto->src_mask) | (value & howto->src_mask);
      score_bfd_put_16 (input_bfd, addend, hit_data);
      return bfd_reloc_ok;

    case R_SCORE_BCMP:
      addend = score_bfd_get_32 (input_bfd, hit_data);
      offset = (addend & howto->src_mask) << howto->rightshift;
      if ((offset & 0x200) != 0)        /* Offset is negative.  */
        offset |= 0xfffffe00;
      value = value - rel_addr + offset;
      /* Sign bit + exceed 9 bit.  */
      if (((value & 0xfffffe00) != 0) && ((value & 0xfffffe00) != 0xfffffe00))
        return bfd_reloc_overflow;
      value >>= howto->rightshift;
      addend = (addend & ~howto->src_mask)
               | (value & 0x1)
               | (((value >> 1) & 0x7) << 7)
               | (((value >> 4) & 0x1f) << 21);
      score_bfd_put_32 (input_bfd, addend, hit_data);
      return bfd_reloc_ok;

    case R_SCORE_HI16:
      return bfd_reloc_ok;

    case R_SCORE_LO16:
      hi16_addend = score_bfd_get_32 (input_bfd, hit_data - 4);
      hi16_offset = ((((hi16_addend >> 16) & 0x3) << 15) | (hi16_addend & 0x7fff)) >> 1;
      addend = score_bfd_get_32 (input_bfd, hit_data);
      offset = ((((addend >> 16) & 0x3) << 15) | (addend & 0x7fff)) >> 1;
      offset = (hi16_offset << 16) | (offset & 0xffff);

      if (!gp_disp_p)
        uvalue = value + offset;
      else
        uvalue = offset + gp - rel_addr + 4;

      hi16_offset = (uvalue >> 16) << 1;
      hi16_value = (hi16_addend & (~(howto->dst_mask)))
                        | (hi16_offset & 0x7fff) | ((hi16_offset << 1) & 0x30000);
      score_bfd_put_32 (input_bfd, hi16_value, hit_data - 4);
      offset = (uvalue & 0xffff) << 1;
      value = (addend & (~(howto->dst_mask))) | (offset & 0x7fff) | ((offset << 1) & 0x30000);
      score_bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_SCORE_GP15:
      addend = score_bfd_get_32 (input_bfd, hit_data);
      offset = addend & 0x7fff;
      if ((offset & 0x4000) == 0x4000)
        offset |= 0xffffc000;
      value = value + offset - gp;
      if (((value & 0xffffc000) != 0) && ((value & 0xffffc000) != 0xffffc000))
        return bfd_reloc_overflow;
      value = (addend & ~howto->src_mask) | (value & howto->src_mask);
      score_bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_SCORE_GOT15:
    case R_SCORE_CALL15:
      if (local_p)
        {
          bfd_boolean forced;

          /* The special case is when the symbol is forced to be local.  We need the
             full address in the GOT since no R_SCORE_GOT_LO16 relocation follows.  */
          forced = ! score_elf_local_relocation_p (input_bfd, rel,
                                                   local_sections, FALSE);
          value = score_elf_got16_entry (output_bfd, input_bfd, info,
                                         symbol + addend, forced);
          if (value == MINUS_ONE)
            return bfd_reloc_outofrange;
          value = score_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
                                                   output_bfd, input_bfd, value);
        }
      else
        {
          value = g;
        }

      if ((long) value > 0x3fff || (long) value < -0x4000)
        return bfd_reloc_overflow;

      addend = score_bfd_get_32 (input_bfd, hit_data);
      value = (addend & ~howto->dst_mask) | (value & howto->dst_mask);
      score_bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_SCORE_GPREL32:
      value = (addend + symbol - gp);
      value &= howto->dst_mask;
      score_bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_SCORE_GOT_LO16:
      addend = score_bfd_get_32 (input_bfd, hit_data);
      value = (((addend >> 16) & 0x3) << 14) | ((addend & 0x7fff) >> 1);
      value += symbol;
      value = (addend & (~(howto->dst_mask))) | ((value & 0x3fff) << 1)
               | (((value >> 14) & 0x3) << 16);

      score_bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_SCORE_DUMMY_HI16:
      return bfd_reloc_ok;

    case R_SCORE_GNU_VTINHERIT:
    case R_SCORE_GNU_VTENTRY:
      /* We don't do anything with these at present.  */
      return bfd_reloc_continue;

    default:
      return bfd_reloc_notsupported;
    }
}

/* Score backend functions.  */
static void
s3_bfd_score_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
                            arelent *bfd_reloc,
                            Elf_Internal_Rela *elf_reloc)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (elf_reloc->r_info);
  if (r_type >= ARRAY_SIZE (elf32_score_howto_table))
    bfd_reloc->howto = NULL;
  else
    bfd_reloc->howto = &elf32_score_howto_table[r_type];
}

/* Relocate an score ELF section.  */
static bfd_boolean
s3_bfd_score_elf_relocate_section (bfd *output_bfd,
                                   struct bfd_link_info *info,
                                   bfd *input_bfd,
                                   asection *input_section,
                                   bfd_byte *contents,
                                   Elf_Internal_Rela *relocs,
                                   Elf_Internal_Sym *local_syms,
                                   asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  const char *name;
  unsigned long offset;
  unsigned long hi16_addend, hi16_offset, hi16_value, uvalue;
  size_t extsymoff;
  bfd_boolean gp_disp_p = FALSE;

  /* Sort dynsym.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd_size_type dynsecsymcount = 0;
      if (info->shared)
        {
          asection * p;
          const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);

          for (p = output_bfd->sections; p ; p = p->next)
            if ((p->flags & SEC_EXCLUDE) == 0
                && (p->flags & SEC_ALLOC) != 0
                && !(*bed->elf_backend_omit_section_dynsym) (output_bfd, info, p))
              ++ dynsecsymcount;
        }

      if (!score_elf_sort_hash_table (info, dynsecsymcount + 1))
        return FALSE;
    }

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  extsymoff = (elf_bad_symtab (input_bfd)) ? 0 : symtab_hdr->sh_info;
  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct score_elf_link_hash_entry *h;
      bfd_vma relocation = 0;
      bfd_reloc_status_type r;
      arelent bfd_reloc;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);

      s3_bfd_score_info_to_howto (input_bfd, &bfd_reloc, (Elf_Internal_Rela *) rel);
      howto = bfd_reloc.howto;

      h = NULL;
      sym = NULL;
      sec = NULL;

      if (r_symndx < extsymoff)
        {
          sym = local_syms + r_symndx;
          sec = local_sections[r_symndx];
          relocation = (sec->output_section->vma
                        + sec->output_offset
                        + sym->st_value);
          name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym, sec);

          if (!info->relocatable
              && (sec->flags & SEC_MERGE)
              && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
            {
              asection *msec;
              bfd_vma addend, value;

              switch (r_type)
                {
                case R_SCORE_HI16:
                  break;
                case R_SCORE_LO16:
                  hi16_addend = score_bfd_get_32 (input_bfd, contents + rel->r_offset - 4);
                  hi16_offset = ((((hi16_addend >> 16) & 0x3) << 15) | (hi16_addend & 0x7fff)) >> 1;
                  value = score_bfd_get_32 (input_bfd, contents + rel->r_offset);
                  offset = ((((value >> 16) & 0x3) << 15) | (value & 0x7fff)) >> 1;
                  addend = (hi16_offset << 16) | (offset & 0xffff);
                  msec = sec;
                  addend = _bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend);
                  addend -= relocation;
                  addend += msec->output_section->vma + msec->output_offset;
                  uvalue = addend;
                  hi16_offset = (uvalue >> 16) << 1;
                  hi16_value = (hi16_addend & (~(howto->dst_mask)))
                    | (hi16_offset & 0x7fff) | ((hi16_offset << 1) & 0x30000);
                  score_bfd_put_32 (input_bfd, hi16_value, contents + rel->r_offset - 4);
                  offset = (uvalue & 0xffff) << 1;
                  value = (value & (~(howto->dst_mask)))
                    | (offset & 0x7fff) | ((offset << 1) & 0x30000);
                  score_bfd_put_32 (input_bfd, value, contents + rel->r_offset);
                  break;

                case R_SCORE_IMM32:
                  {
                    value = score_bfd_get_48 (input_bfd, contents + rel->r_offset);
                    addend = ((value >> 5) & 0x3ff)
                              | (((value >> 16) & 0x7fff) << 10)
                              | (((value >> 32) & 0x7f) << 25);
                    msec = sec;
                    addend = _bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend);
                    addend -= relocation;
                    addend += msec->output_section->vma + msec->output_offset;
                    addend &= 0xffffffff;
                    value = (value & ~howto->src_mask)
                             | ((addend & 0x3ff) << 5)
                             | (((addend >> 10) & 0x7fff) << 16)
                             | (((addend >> 25) & 0x7f) << 32);
                    score_bfd_put_48 (input_bfd, value, contents + rel->r_offset);
                    break;
                  }

                case R_SCORE_IMM30:
                  {
                    int not_word_align_p = 0;
                    value = score_bfd_get_48 (input_bfd, contents + rel->r_offset);
                    addend = ((value >> 7) & 0xff)
                              | (((value >> 16) & 0x7fff) << 8)
                              | (((value >> 32) & 0x7f) << 23);
                    addend <<= howto->rightshift;
                    msec = sec;
                    addend = _bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend);
                    addend -= relocation;
                    addend += msec->output_section->vma + msec->output_offset;
                    addend &= 0xffffffff;

                    /* Check lw48/sw48 rd, value/label word align.  */
                    if ((addend & 0x3) != 0)
                      not_word_align_p = 1;

                    addend >>= howto->rightshift;
                    value = (value & ~howto->src_mask)
                             | (((addend & 0xff) >> 0) << 7)
                             | (((addend & 0x7fff00) >> 8) << 16)
                             | (((addend & 0x3f800000) >> 23) << 32);
                    score_bfd_put_48 (input_bfd, value, contents + rel->r_offset);

                    if (not_word_align_p)
                      return bfd_reloc_other;
                    else
                      break;
                  }

                case R_SCORE_GOT_LO16:
                  value = score_bfd_get_32 (input_bfd, contents + rel->r_offset);
                  addend = (((value >> 16) & 0x3) << 14) | ((value & 0x7fff) >> 1);
                  msec = sec;
                  addend = _bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend) - relocation;
                  addend += msec->output_section->vma + msec->output_offset;
                  value = (value & (~(howto->dst_mask))) | ((addend & 0x3fff) << 1)
                           | (((addend >> 14) & 0x3) << 16);

                  score_bfd_put_32 (input_bfd, value, contents + rel->r_offset);
                  break;

                case R_SCORE_ABS32:
                case R_SCORE_REL32:
                  value = bfd_get_32 (input_bfd, contents + rel->r_offset);
                  /* Get the (signed) value from the instruction.  */
                  addend = value & howto->src_mask;
                  if (addend & ((howto->src_mask + 1) >> 1))
                    {
                      bfd_signed_vma mask;

                      mask = -1;
                      mask &= ~howto->src_mask;
                      addend |= mask;
                    }
                  msec = sec;
                  addend = _bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend) - relocation;
                  addend += msec->output_section->vma + msec->output_offset;
                  value = (value & ~howto->dst_mask) | (addend & howto->dst_mask);
                  bfd_put_32 (input_bfd, value, contents + rel->r_offset);
                  break;

                default:
                  value = score_bfd_get_32 (input_bfd, contents + rel->r_offset);
                  /* Get the (signed) value from the instruction.  */
                  addend = value & howto->src_mask;
                  if (addend & ((howto->src_mask + 1) >> 1))
                    {
                      bfd_signed_vma mask;

                      mask = -1;
                      mask &= ~howto->src_mask;
                      addend |= mask;
                    }
                  msec = sec;
                  addend = _bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend) - relocation;
                  addend += msec->output_section->vma + msec->output_offset;
                  value = (value & ~howto->dst_mask) | (addend & howto->dst_mask);
                  score_bfd_put_32 (input_bfd, value, contents + rel->r_offset);
                  break;
                }
            }
        }
      else
        {
          /* For global symbols we look up the symbol in the hash-table.  */
          h = ((struct score_elf_link_hash_entry *)
               elf_sym_hashes (input_bfd) [r_symndx - extsymoff]);
          /* Find the real hash-table entry for this symbol.  */
          while (h->root.root.type == bfd_link_hash_indirect
                 || h->root.root.type == bfd_link_hash_warning)
            h = (struct score_elf_link_hash_entry *) h->root.root.u.i.link;

          /* Record the name of this symbol, for our caller.  */
          name = h->root.root.root.string;

          /* See if this is the special GP_DISP_LABEL symbol.  Note that such a
             symbol must always be a global symbol.  */
          if (strcmp (name, GP_DISP_LABEL) == 0)
            {
              /* Relocations against GP_DISP_LABEL are permitted only with
                 R_SCORE_HI16 and R_SCORE_LO16 relocations.  */
              if (r_type != R_SCORE_HI16 && r_type != R_SCORE_LO16)
                return bfd_reloc_notsupported;

              gp_disp_p = TRUE;
            }

          /* If this symbol is defined, calculate its address.  Note that
              GP_DISP_LABEL is a magic symbol, always implicitly defined by the
              linker, so it's inappropriate to check to see whether or not
              its defined.  */
          else if ((h->root.root.type == bfd_link_hash_defined
                    || h->root.root.type == bfd_link_hash_defweak)
                   && h->root.root.u.def.section)
            {
              sec = h->root.root.u.def.section;
              if (sec->output_section)
                relocation = (h->root.root.u.def.value
                              + sec->output_section->vma
                              + sec->output_offset);
              else
                {
                  relocation = h->root.root.u.def.value;
                }
            }
          else if (h->root.root.type == bfd_link_hash_undefweak)
            /* We allow relocations against undefined weak symbols, giving
               it the value zero, so that you can undefined weak functions
               and check to see if they exist by looking at their addresses.  */
            relocation = 0;
          else if (info->unresolved_syms_in_objects == RM_IGNORE
                   && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
            relocation = 0;
          else if (strcmp (name, "_DYNAMIC_LINK") == 0)
            {
              /* If this is a dynamic link, we should have created a _DYNAMIC_LINK symbol
                 in s3_bfd_score_elf_create_dynamic_sections.  Otherwise, we should define
                 the symbol with a value of 0.  */
              BFD_ASSERT (! info->shared);
              BFD_ASSERT (bfd_get_section_by_name (output_bfd, ".dynamic") == NULL);
              relocation = 0;
            }
          else if (!info->relocatable)
            {
              if (! ((*info->callbacks->undefined_symbol)
                     (info, h->root.root.root.string, input_bfd,
                      input_section, rel->r_offset,
                      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
                      || ELF_ST_VISIBILITY (h->root.other))))
                return bfd_reloc_undefined;
              relocation = 0;
            }
        }

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
        {
          /* This is a relocatable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
          if (r_symndx < symtab_hdr->sh_info)
            {
              sym = local_syms + r_symndx;
              if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
                {
                  sec = local_sections[r_symndx];
                  score_elf_add_to_rel (input_bfd, contents + rel->r_offset,
                                    howto, (bfd_signed_vma) (sec->output_offset + sym->st_value));
                }
            }
          continue;
        }

      /* This is a final link.  */
      r = score_elf_final_link_relocate (howto, input_bfd, output_bfd,
                                         input_section, contents, rel, relocs,
                                         relocation, info, name,
                                         (h ? ELF_ST_TYPE ((unsigned int)h->root.root.type) :
                                         ELF_ST_TYPE ((unsigned int)sym->st_info)), h, local_sections,
                                         gp_disp_p);

      if (r != bfd_reloc_ok)
        {
          const char *msg = (const char *)0;

          switch (r)
            {
            case bfd_reloc_overflow:
              /* If the overflowing reloc was to an undefined symbol,
                 we have already printed one error message and there
                 is no point complaining again.  */
              if (((!h) || (h->root.root.type != bfd_link_hash_undefined))
                  && (!((*info->callbacks->reloc_overflow)
                        (info, NULL, name, howto->name, (bfd_vma) 0,
                         input_bfd, input_section, rel->r_offset))))
                return FALSE;
              break;
            case bfd_reloc_undefined:
              if (!((*info->callbacks->undefined_symbol)
                    (info, name, input_bfd, input_section, rel->r_offset, TRUE)))
                return FALSE;
              break;

            case bfd_reloc_outofrange:
              msg = _("internal error: out of range error");
              goto common_error;

            case bfd_reloc_notsupported:
              msg = _("internal error: unsupported relocation error");
              goto common_error;

            case bfd_reloc_dangerous:
              msg = _("internal error: dangerous error");
              goto common_error;

            /* Use bfd_reloc_other to check lw48, sw48 word align.  */
            case bfd_reloc_other:
              msg = _("address not word align");
              goto common_error;

            default:
              msg = _("internal error: unknown error");
              /* fall through */

            common_error:
              if (!((*info->callbacks->warning)
                    (info, msg, name, input_bfd, input_section, rel->r_offset)))
                return FALSE;
              break;
            }
        }
    }

  return TRUE;
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table.  */
static bfd_boolean
s3_bfd_score_elf_check_relocs (bfd *abfd,
                               struct bfd_link_info *info,
                               asection *sec,
                               const Elf_Internal_Rela *relocs)
{
  const char *name;
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct score_got_info *g;
  size_t extsymoff;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *sreloc;
  const struct elf_backend_data *bed;

  if (info->relocatable)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;

  name = bfd_get_section_name (abfd, sec);

  if (dynobj == NULL)
    {
      sgot = NULL;
      g = NULL;
    }
  else
    {
      sgot = score_elf_got_section (dynobj, FALSE);
      if (sgot == NULL)
        g = NULL;
      else
        {
          BFD_ASSERT (score_elf_section_data (sgot) != NULL);
          g = score_elf_section_data (sgot)->u.got_info;
          BFD_ASSERT (g != NULL);
        }
    }

  sreloc = NULL;
  bed = get_elf_backend_data (abfd);
  rel_end = relocs + sec->reloc_count * bed->s->int_rels_per_ext_rel;
  for (rel = relocs; rel < rel_end; ++rel)
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);

      if (r_symndx < extsymoff)
        {
          h = NULL;
        }
      else if (r_symndx >= extsymoff + NUM_SHDR_ENTRIES (symtab_hdr))
        {
          (*_bfd_error_handler) (_("%s: Malformed reloc detected for section %s"), abfd, name);
          bfd_set_error (bfd_error_bad_value);
          return FALSE;
        }
      else
        {
          h = sym_hashes[r_symndx - extsymoff];

          /* This may be an indirect symbol created because of a version.  */
          if (h != NULL)
            {
              while (h->root.type == bfd_link_hash_indirect)
                h = (struct elf_link_hash_entry *)h->root.u.i.link;

	      /* PR15323, ref flags aren't set for references in the
		 same object.  */
	      h->root.non_ir_ref = 1;
            }
        }

      /* Some relocs require a global offset table.  */
      if (dynobj == NULL || sgot == NULL)
        {
          switch (r_type)
            {
            case R_SCORE_GOT15:
            case R_SCORE_CALL15:
              if (dynobj == NULL)
                elf_hash_table (info)->dynobj = dynobj = abfd;
              if (!score_elf_create_got_section (dynobj, info, FALSE))
                return FALSE;
              g = score_elf_got_info (dynobj, &sgot);
              break;
            case R_SCORE_ABS32:
            case R_SCORE_REL32:
              if (dynobj == NULL && (info->shared || h != NULL) && (sec->flags & SEC_ALLOC) != 0)
                elf_hash_table (info)->dynobj = dynobj = abfd;
              break;
            default:
              break;
            }
        }

      if (!h && (r_type == R_SCORE_GOT_LO16))
        {
          if (! score_elf_record_local_got_symbol (abfd, r_symndx, rel->r_addend, g))
            return FALSE;
        }

      switch (r_type)
        {
        case R_SCORE_CALL15:
          if (h == NULL)
            {
              (*_bfd_error_handler)
                (_("%B: CALL15 reloc at 0x%lx not against global symbol"),
                 abfd, (unsigned long) rel->r_offset);
              bfd_set_error (bfd_error_bad_value);
              return FALSE;
            }
          else
            {
              /* This symbol requires a global offset table entry.  */
              if (! score_elf_record_global_got_symbol (h, abfd, info, g))
                return FALSE;

              /* We need a stub, not a plt entry for the undefined function.  But we record
                 it as if it needs plt.  See _bfd_elf_adjust_dynamic_symbol.  */
              h->needs_plt = 1;
              h->type = STT_FUNC;
            }
          break;
        case R_SCORE_GOT15:
          if (h && ! score_elf_record_global_got_symbol (h, abfd, info, g))
            return FALSE;
          break;
        case R_SCORE_ABS32:
        case R_SCORE_REL32:
          if ((info->shared || h != NULL) && (sec->flags & SEC_ALLOC) != 0)
            {
              if (sreloc == NULL)
                {
                  sreloc = score_elf_rel_dyn_section (dynobj, TRUE);
                  if (sreloc == NULL)
                    return FALSE;
                }
#define SCORE_READONLY_SECTION (SEC_ALLOC | SEC_LOAD | SEC_READONLY)
              if (info->shared)
                {
                  /* When creating a shared object, we must copy these reloc types into
                     the output file as R_SCORE_REL32 relocs.  We make room for this reloc
                     in the .rel.dyn reloc section.  */
                  score_elf_allocate_dynamic_relocations (dynobj, 1);
                  if ((sec->flags & SCORE_READONLY_SECTION)
                      == SCORE_READONLY_SECTION)
                    /* We tell the dynamic linker that there are
                       relocations against the text segment.  */
                    info->flags |= DF_TEXTREL;
                }
              else
                {
                  struct score_elf_link_hash_entry *hscore;

                  /* We only need to copy this reloc if the symbol is
                     defined in a dynamic object.  */
                  hscore = (struct score_elf_link_hash_entry *)h;
                  ++hscore->possibly_dynamic_relocs;
                  if ((sec->flags & SCORE_READONLY_SECTION)
                      == SCORE_READONLY_SECTION)
                    /* We need it to tell the dynamic linker if there
                       are relocations against the text segment.  */
                    hscore->readonly_reloc = TRUE;
                }

              /* Even though we don't directly need a GOT entry for this symbol,
                 a symbol must have a dynamic symbol table index greater that
                 DT_SCORE_GOTSYM if there are dynamic relocations against it.  */
              if (h != NULL)
                {
                  if (dynobj == NULL)
                    elf_hash_table (info)->dynobj = dynobj = abfd;
                  if (! score_elf_create_got_section (dynobj, info, TRUE))
                    return FALSE;
                  g = score_elf_got_info (dynobj, &sgot);
                  if (! score_elf_record_global_got_symbol (h, abfd, info, g))
                    return FALSE;
                }
            }
          break;

          /* This relocation describes the C++ object vtable hierarchy.
             Reconstruct it for later use during GC.  */
        case R_SCORE_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

          /* This relocation describes which C++ vtable entries are actually
             used.  Record for later use during GC.  */
        case R_SCORE_GNU_VTENTRY:
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;
        default:
          break;
        }

      /* We must not create a stub for a symbol that has relocations
         related to taking the function's address.  */
      switch (r_type)
        {
        default:
          if (h != NULL)
            {
              struct score_elf_link_hash_entry *sh;

              sh = (struct score_elf_link_hash_entry *) h;
              sh->no_fn_stub = TRUE;
            }
          break;
        case R_SCORE_CALL15:
          break;
        }
    }

  return TRUE;
}

static bfd_boolean
s3_bfd_score_elf_add_symbol_hook (bfd *abfd,
                                  struct bfd_link_info *info ATTRIBUTE_UNUSED,
                                  Elf_Internal_Sym *sym,
                                  const char **namep ATTRIBUTE_UNUSED,
                                  flagword *flagsp ATTRIBUTE_UNUSED,
                                  asection **secp,
                                  bfd_vma *valp)
{
  switch (sym->st_shndx)
    {
    case SHN_COMMON:
      if (sym->st_size > elf_gp_size (abfd))
        break;
      /* Fall through.  */
    case SHN_SCORE_SCOMMON:
      *secp = bfd_make_section_old_way (abfd, ".scommon");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;
    }

  return TRUE;
}

static void
s3_bfd_score_elf_symbol_processing (bfd *abfd, asymbol *asym)
{
  elf_symbol_type *elfsym;

  elfsym = (elf_symbol_type *) asym;
  switch (elfsym->internal_elf_sym.st_shndx)
    {
    case SHN_COMMON:
      if (asym->value > elf_gp_size (abfd))
        break;
      /* Fall through.  */
    case SHN_SCORE_SCOMMON:
      if (score_elf_scom_section.name == NULL)
        {
          /* Initialize the small common section.  */
          score_elf_scom_section.name = ".scommon";
          score_elf_scom_section.flags = SEC_IS_COMMON;
          score_elf_scom_section.output_section = &score_elf_scom_section;
          score_elf_scom_section.symbol = &score_elf_scom_symbol;
          score_elf_scom_section.symbol_ptr_ptr = &score_elf_scom_symbol_ptr;
          score_elf_scom_symbol.name = ".scommon";
          score_elf_scom_symbol.flags = BSF_SECTION_SYM;
          score_elf_scom_symbol.section = &score_elf_scom_section;
          score_elf_scom_symbol_ptr = &score_elf_scom_symbol;
        }
      asym->section = &score_elf_scom_section;
      asym->value = elfsym->internal_elf_sym.st_size;
      break;
    }
}

static int
s3_bfd_score_elf_link_output_symbol_hook (struct bfd_link_info *info ATTRIBUTE_UNUSED,
                                          const char *name ATTRIBUTE_UNUSED,
                                          Elf_Internal_Sym *sym,
                                          asection *input_sec,
                                          struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
{
  /* If we see a common symbol, which implies a relocatable link, then
     if a symbol was small common in an input file, mark it as small
     common in the output file.  */
  if (sym->st_shndx == SHN_COMMON && strcmp (input_sec->name, ".scommon") == 0)
    sym->st_shndx = SHN_SCORE_SCOMMON;

  return 1;
}

static bfd_boolean
s3_bfd_score_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
                                           asection *sec,
                                           int *retval)
{
  if (strcmp (bfd_get_section_name (abfd, sec), ".scommon") == 0)
    {
      *retval = SHN_SCORE_SCOMMON;
      return TRUE;
    }

  return FALSE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can understand.  */
static bfd_boolean
s3_bfd_score_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
                                        struct elf_link_hash_entry *h)
{
  bfd *dynobj;
  struct score_elf_link_hash_entry *hscore;
  asection *s;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
              && (h->needs_plt
                  || h->u.weakdef != NULL
                  || (h->def_dynamic && h->ref_regular && !h->def_regular)));

  /* If this symbol is defined in a dynamic object, we need to copy
     any R_SCORE_ABS32 or R_SCORE_REL32 relocs against it into the output
     file.  */
  hscore = (struct score_elf_link_hash_entry *)h;
  if (!info->relocatable
      && hscore->possibly_dynamic_relocs != 0
      && (h->root.type == bfd_link_hash_defweak || !h->def_regular))
    {
      score_elf_allocate_dynamic_relocations (dynobj, hscore->possibly_dynamic_relocs);
      if (hscore->readonly_reloc)
        /* We tell the dynamic linker that there are relocations
           against the text segment.  */
        info->flags |= DF_TEXTREL;
    }

  /* For a function, create a stub, if allowed.  */
  if (!hscore->no_fn_stub && h->needs_plt)
    {
      if (!elf_hash_table (info)->dynamic_sections_created)
        return TRUE;

      /* If this symbol is not defined in a regular file, then set
         the symbol to the stub location.  This is required to make
         function pointers compare as equal between the normal
         executable and the shared library.  */
      if (!h->def_regular)
        {
          /* We need .stub section.  */
          s = bfd_get_linker_section (dynobj, SCORE_ELF_STUB_SECTION_NAME);
          BFD_ASSERT (s != NULL);

          h->root.u.def.section = s;
          h->root.u.def.value = s->size;

          /* XXX Write this stub address somewhere.  */
          h->plt.offset = s->size;

          /* Make room for this stub code.  */
          s->size += SCORE_FUNCTION_STUB_SIZE;

          /* The last half word of the stub will be filled with the index
             of this symbol in .dynsym section.  */
          return TRUE;
        }
    }
  else if ((h->type == STT_FUNC) && !h->needs_plt)
    {
      /* This will set the entry for this symbol in the GOT to 0, and
         the dynamic linker will take care of this.  */
      h->root.u.def.value = 0;
      return TRUE;
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
                  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */
  return TRUE;
}

/* This function is called after all the input files have been read,
   and the input sections have been assigned to output sections.  */
static bfd_boolean
s3_bfd_score_elf_always_size_sections (bfd *output_bfd,
                                       struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  struct score_got_info *g;
  int i;
  bfd_size_type loadable_size = 0;
  bfd_size_type local_gotno;
  bfd *sub;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    /* Relocatable links don't have it.  */
    return TRUE;

  g = score_elf_got_info (dynobj, &s);
  if (s == NULL)
    return TRUE;

  /* Calculate the total loadable size of the output.  That will give us the
     maximum number of GOT_PAGE entries required.  */
  for (sub = info->input_bfds; sub; sub = sub->link_next)
    {
      asection *subsection;

      for (subsection = sub->sections;
           subsection;
           subsection = subsection->next)
        {
          if ((subsection->flags & SEC_ALLOC) == 0)
            continue;
          loadable_size += ((subsection->size + 0xf)
                            &~ (bfd_size_type) 0xf);
        }
    }

  /* There has to be a global GOT entry for every symbol with
     a dynamic symbol table index of DT_SCORE_GOTSYM or
     higher.  Therefore, it make sense to put those symbols
     that need GOT entries at the end of the symbol table.  We
     do that here.  */
  if (! score_elf_sort_hash_table (info, 1))
    return FALSE;

  if (g->global_gotsym != NULL)
    i = elf_hash_table (info)->dynsymcount - g->global_gotsym->dynindx;
  else
    /* If there are no global symbols, or none requiring
       relocations, then GLOBAL_GOTSYM will be NULL.  */
    i = 0;

  /* In the worst case, we'll get one stub per dynamic symbol.  */
  loadable_size += SCORE_FUNCTION_STUB_SIZE * i;

  /* Assume there are two loadable segments consisting of
     contiguous sections.  Is 5 enough?  */
  local_gotno = (loadable_size >> 16) + 5;

  g->local_gotno += local_gotno;
  s->size += g->local_gotno * SCORE_ELF_GOT_SIZE (output_bfd);

  g->global_gotno = i;
  s->size += i * SCORE_ELF_GOT_SIZE (output_bfd);

  score_elf_resolve_final_got_entries (g);

  if (s->size > SCORE_ELF_GOT_MAX_SIZE (output_bfd))
    {
      /* Fixme. Error message or Warning message should be issued here.  */
    }

  return TRUE;
}

/* Set the sizes of the dynamic sections.  */
static bfd_boolean
s3_bfd_score_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  bfd_boolean reltext;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (!info->shared)
        {
          s = bfd_get_linker_section (dynobj, ".interp");
          BFD_ASSERT (s != NULL);
          s->size = strlen (ELF_DYNAMIC_INTERPRETER) + 1;
          s->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
        }
    }

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  reltext = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
        continue;

      /* It's OK to base decisions on the section name, because none
         of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if (CONST_STRNEQ (name, ".rel"))
        {
          if (s->size == 0)
            {
              /* We only strip the section if the output section name
                 has the same name.  Otherwise, there might be several
                 input sections for this output section.  FIXME: This
                 code is probably not needed these days anyhow, since
                 the linker now does not create empty output sections.  */
              if (s->output_section != NULL
                  && strcmp (name,
                             bfd_get_section_name (s->output_section->owner,
                                                   s->output_section)) == 0)
                s->flags |= SEC_EXCLUDE;
            }
          else
            {
              const char *outname;
              asection *target;

              /* If this relocation section applies to a read only
                 section, then we probably need a DT_TEXTREL entry.
                 If the relocation section is .rel.dyn, we always
                 assert a DT_TEXTREL entry rather than testing whether
                 there exists a relocation to a read only section or
                 not.  */
              outname = bfd_get_section_name (output_bfd, s->output_section);
              target = bfd_get_section_by_name (output_bfd, outname + 4);
              if ((target != NULL
                   && (target->flags & SEC_READONLY) != 0
                   && (target->flags & SEC_ALLOC) != 0) || strcmp (outname, ".rel.dyn") == 0)
                reltext = TRUE;

              /* We use the reloc_count field as a counter if we need
                 to copy relocs into the output file.  */
              if (strcmp (name, ".rel.dyn") != 0)
                s->reloc_count = 0;
            }
        }
      else if (CONST_STRNEQ (name, ".got"))
        {
          /* s3_bfd_score_elf_always_size_sections() has already done
             most of the work, but some symbols may have been mapped
             to versions that we must now resolve in the got_entries
             hash tables.  */
        }
      else if (strcmp (name, SCORE_ELF_STUB_SECTION_NAME) == 0)
        {
          /* IRIX rld assumes that the function stub isn't at the end
             of .text section. So put a dummy. XXX  */
          s->size += SCORE_FUNCTION_STUB_SIZE;
        }
      else if (! CONST_STRNEQ (name, ".init"))
        {
          /* It's not one of our sections, so don't allocate space.  */
          continue;
        }

      /* Allocate memory for the section contents.  */
      s->contents = bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
        {
          bfd_set_error (bfd_error_no_memory);
          return FALSE;
        }
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
         values later, in s3_bfd_score_elf_finish_dynamic_sections, but we
         must add the entries now so that we get the correct size for
         the .dynamic section.  The DT_DEBUG entry is filled in by the
         dynamic linker and used by the debugger.  */

      if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
        return FALSE;

      if (reltext)
        info->flags |= DF_TEXTREL;

      if ((info->flags & DF_TEXTREL) != 0)
        {
          if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_TEXTREL, 0))
            return FALSE;
        }

      if (! SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTGOT, 0))
        return FALSE;

      if (score_elf_rel_dyn_section (dynobj, FALSE))
        {
          if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_REL, 0))
            return FALSE;

          if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELSZ, 0))
            return FALSE;

          if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELENT, 0))
            return FALSE;
        }

      if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_SCORE_BASE_ADDRESS, 0))
        return FALSE;

      if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_SCORE_LOCAL_GOTNO, 0))
        return FALSE;

      if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_SCORE_SYMTABNO, 0))
        return FALSE;

      if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_SCORE_UNREFEXTNO, 0))
        return FALSE;

      if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_SCORE_GOTSYM, 0))
        return FALSE;

      if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_SCORE_HIPAGENO, 0))
        return FALSE;
    }

  return TRUE;
}

static bfd_boolean
s3_bfd_score_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  flagword flags;
  asection *s;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
           | SEC_LINKER_CREATED | SEC_READONLY);

  /* ABI requests the .dynamic section to be read only.  */
  s = bfd_get_linker_section (abfd, ".dynamic");
  if (s != NULL)
    {
      if (!bfd_set_section_flags (abfd, s, flags))
        return FALSE;
    }

  /* We need to create .got section.  */
  if (!score_elf_create_got_section (abfd, info, FALSE))
    return FALSE;

  if (!score_elf_rel_dyn_section (elf_hash_table (info)->dynobj, TRUE))
    return FALSE;

  /* Create .stub section.  */
  if (bfd_get_linker_section (abfd, SCORE_ELF_STUB_SECTION_NAME) == NULL)
    {
      s = bfd_make_section_anyway_with_flags (abfd, SCORE_ELF_STUB_SECTION_NAME,
					      flags | SEC_CODE);
      if (s == NULL
          || !bfd_set_section_alignment (abfd, s, 2))

        return FALSE;
    }

  if (!info->shared)
    {
      const char *name;

      name = "_DYNAMIC_LINK";
      bh = NULL;
      if (!(_bfd_generic_link_add_one_symbol
            (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr,
             (bfd_vma) 0, NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
        return FALSE;

      h = (struct elf_link_hash_entry *)bh;
      h->non_elf = 0;
      h->def_regular = 1;
      h->type = STT_SECTION;

      if (!bfd_elf_link_record_dynamic_symbol (info, h))
        return FALSE;
    }

  return TRUE;
}


/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */
static bfd_boolean
s3_bfd_score_elf_finish_dynamic_symbol (bfd *output_bfd,
                                        struct bfd_link_info *info,
                                        struct elf_link_hash_entry *h,
                                        Elf_Internal_Sym *sym)
{
  bfd *dynobj;
  asection *sgot;
  struct score_got_info *g;
  const char *name;

  dynobj = elf_hash_table (info)->dynobj;

  if (h->plt.offset != MINUS_ONE)
    {
      asection *s;
      bfd_byte stub[SCORE_FUNCTION_STUB_SIZE];

      /* This symbol has a stub.  Set it up.  */
      BFD_ASSERT (h->dynindx != -1);

      s = bfd_get_linker_section (dynobj, SCORE_ELF_STUB_SECTION_NAME);
      BFD_ASSERT (s != NULL);

      /* FIXME: Can h->dynindex be more than 64K?  */
      if (h->dynindx & 0xffff0000)
        return FALSE;

      /* Fill the stub.  */
      score_bfd_put_32 (output_bfd, STUB_LW, stub);
      score_bfd_put_32 (output_bfd, STUB_MOVE, stub + 4);
      score_bfd_put_32 (output_bfd, STUB_LI16 | (h->dynindx << 1), stub + 8);
      score_bfd_put_32 (output_bfd, STUB_BRL, stub + 12);

      BFD_ASSERT (h->plt.offset <= s->size);
      memcpy (s->contents + h->plt.offset, stub, SCORE_FUNCTION_STUB_SIZE);

      /* Mark the symbol as undefined.  plt.offset != -1 occurs
         only for the referenced symbol.  */
      sym->st_shndx = SHN_UNDEF;

      /* The run-time linker uses the st_value field of the symbol
          to reset the global offset table entry for this external
          to its stub address when unlinking a shared object.  */
      sym->st_value = (s->output_section->vma + s->output_offset + h->plt.offset);
    }

  BFD_ASSERT (h->dynindx != -1 || h->forced_local);

  sgot = score_elf_got_section (dynobj, FALSE);
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (score_elf_section_data (sgot) != NULL);
  g = score_elf_section_data (sgot)->u.got_info;
  BFD_ASSERT (g != NULL);

  /* Run through the global symbol table, creating GOT entries for all
     the symbols that need them.  */
  if (g->global_gotsym != NULL && h->dynindx >= g->global_gotsym->dynindx)
    {
      bfd_vma offset;
      bfd_vma value;

      value = sym->st_value;
      offset = score_elf_global_got_index (dynobj, h);
      score_bfd_put_32 (output_bfd, value, sgot->contents + offset);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  name = h->root.root.string;
  if (h == elf_hash_table (info)->hdynamic
      || h == elf_hash_table (info)->hgot)
    sym->st_shndx = SHN_ABS;
  else if (strcmp (name, "_DYNAMIC_LINK") == 0)
    {
      sym->st_shndx = SHN_ABS;
      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
      sym->st_value = 1;
    }
  else if (strcmp (name, GP_DISP_LABEL) == 0)
    {
      sym->st_shndx = SHN_ABS;
      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
      sym->st_value = elf_gp (output_bfd);
    }

  return TRUE;
}

/* Finish up the dynamic sections.  */
static bfd_boolean
s3_bfd_score_elf_finish_dynamic_sections (bfd *output_bfd,
                                          struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sdyn;
  asection *sgot;
  asection *s;
  struct score_got_info *g;

  dynobj = elf_hash_table (info)->dynobj;

  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  sgot = score_elf_got_section (dynobj, FALSE);
  if (sgot == NULL)
    g = NULL;
  else
    {
      BFD_ASSERT (score_elf_section_data (sgot) != NULL);
      g = score_elf_section_data (sgot)->u.got_info;
      BFD_ASSERT (g != NULL);
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd_byte *b;

      BFD_ASSERT (sdyn != NULL);
      BFD_ASSERT (g != NULL);

      for (b = sdyn->contents;
           b < sdyn->contents + sdyn->size;
           b += SCORE_ELF_DYN_SIZE (dynobj))
        {
          Elf_Internal_Dyn dyn;
          const char *name;
          size_t elemsize;
          bfd_boolean swap_out_p;

          /* Read in the current dynamic entry.  */
          (*get_elf_backend_data (dynobj)->s->swap_dyn_in) (dynobj, b, &dyn);

          /* Assume that we're going to modify it and write it out.  */
          swap_out_p = TRUE;

          switch (dyn.d_tag)
            {
            case DT_RELENT:
              s = score_elf_rel_dyn_section (dynobj, FALSE);
              BFD_ASSERT (s != NULL);
              dyn.d_un.d_val = SCORE_ELF_REL_SIZE (dynobj);
              break;

            case DT_STRSZ:
              /* Rewrite DT_STRSZ.  */
              dyn.d_un.d_val = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
                    break;

            case DT_PLTGOT:
              name = ".got";
              s = bfd_get_section_by_name (output_bfd, name);
              BFD_ASSERT (s != NULL);
              dyn.d_un.d_ptr = s->vma;
              break;

            case DT_SCORE_BASE_ADDRESS:
              s = output_bfd->sections;
              BFD_ASSERT (s != NULL);
              dyn.d_un.d_ptr = s->vma & ~(bfd_vma) 0xffff;
              break;

            case DT_SCORE_LOCAL_GOTNO:
              dyn.d_un.d_val = g->local_gotno;
              break;

            case DT_SCORE_UNREFEXTNO:
              /* The index into the dynamic symbol table which is the
                 entry of the first external symbol that is not
                 referenced within the same object.  */
              dyn.d_un.d_val = bfd_count_sections (output_bfd) + 1;
              break;

            case DT_SCORE_GOTSYM:
              if (g->global_gotsym)
                {
                  dyn.d_un.d_val = g->global_gotsym->dynindx;
                  break;
                }
              /* In case if we don't have global got symbols we default
                  to setting DT_SCORE_GOTSYM to the same value as
                  DT_SCORE_SYMTABNO, so we just fall through.  */

            case DT_SCORE_SYMTABNO:
              name = ".dynsym";
              elemsize = SCORE_ELF_SYM_SIZE (output_bfd);
              s = bfd_get_section_by_name (output_bfd, name);
              BFD_ASSERT (s != NULL);

              dyn.d_un.d_val = s->size / elemsize;
              break;

            case DT_SCORE_HIPAGENO:
              dyn.d_un.d_val = g->local_gotno - SCORE_RESERVED_GOTNO;
              break;

            default:
              swap_out_p = FALSE;
              break;
            }

          if (swap_out_p)
            (*get_elf_backend_data (dynobj)->s->swap_dyn_out) (dynobj, &dyn, b);
        }
    }

  /* The first entry of the global offset table will be filled at
     runtime. The second entry will be used by some runtime loaders.
     This isn't the case of IRIX rld.  */
  if (sgot != NULL && sgot->size > 0)
    {
      score_bfd_put_32 (output_bfd, 0, sgot->contents);
      score_bfd_put_32 (output_bfd, 0x80000000, sgot->contents + SCORE_ELF_GOT_SIZE (output_bfd));
    }

  if (sgot != NULL)
    elf_section_data (sgot->output_section)->this_hdr.sh_entsize
      = SCORE_ELF_GOT_SIZE (output_bfd);


  /* We need to sort the entries of the dynamic relocation section.  */
  s = score_elf_rel_dyn_section (dynobj, FALSE);

  if (s != NULL && s->size > (bfd_vma)2 * SCORE_ELF_REL_SIZE (output_bfd))
    {
      reldyn_sorting_bfd = output_bfd;
      qsort ((Elf32_External_Rel *) s->contents + 1, s->reloc_count - 1,
             sizeof (Elf32_External_Rel), score_elf_sort_dynamic_relocs);
    }

  return TRUE;
}

/* This function set up the ELF section header for a BFD section in preparation for writing
   it out.  This is where the flags and type fields are set for unusual sections.  */
static bfd_boolean
s3_bfd_score_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
                                Elf_Internal_Shdr *hdr,
                                asection *sec)
{
  const char *name;

  name = bfd_get_section_name (abfd, sec);

  if (strcmp (name, ".got") == 0
      || strcmp (name, ".srdata") == 0
      || strcmp (name, ".sdata") == 0
      || strcmp (name, ".sbss") == 0)
    hdr->sh_flags |= SHF_SCORE_GPREL;

  return TRUE;
}

/* This function do additional processing on the ELF section header before writing
   it out.  This is used to set the flags and type fields for some sections.  */

/* assign_file_positions_except_relocs() check section flag and if it is allocatable,
   warning message will be issued.  backend_fake_section is called before
   assign_file_positions_except_relocs(); backend_section_processing after it.  so, we
   modify section flag there, but not backend_fake_section.  */
static bfd_boolean
s3_bfd_score_elf_section_processing (bfd *abfd ATTRIBUTE_UNUSED, Elf_Internal_Shdr *hdr)
{
  if (hdr->bfd_section != NULL)
    {
      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);

      if (strcmp (name, ".sdata") == 0)
        {
          hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_SCORE_GPREL;
          hdr->sh_type = SHT_PROGBITS;
        }
      else if (strcmp (name, ".sbss") == 0)
        {
          hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_SCORE_GPREL;
          hdr->sh_type = SHT_NOBITS;
        }
      else if (strcmp (name, ".srdata") == 0)
        {
          hdr->sh_flags |= SHF_ALLOC | SHF_SCORE_GPREL;
          hdr->sh_type = SHT_PROGBITS;
        }
    }

  return TRUE;
}

static bfd_boolean
s3_bfd_score_elf_write_section (bfd *output_bfd, asection *sec, bfd_byte *contents)
{
  bfd_byte *to, *from, *end;
  int i;

  if (strcmp (sec->name, ".pdr") != 0)
    return FALSE;

  if (score_elf_section_data (sec)->u.tdata == NULL)
    return FALSE;

  to = contents;
  end = contents + sec->size;
  for (from = contents, i = 0; from < end; from += PDR_SIZE, i++)
    {
      if ((score_elf_section_data (sec)->u.tdata)[i] == 1)
        continue;

      if (to != from)
        memcpy (to, from, PDR_SIZE);

      to += PDR_SIZE;
    }
  bfd_set_section_contents (output_bfd, sec->output_section, contents,
                            (file_ptr) sec->output_offset, sec->size);

  return TRUE;
}

/* Copy data from a SCORE ELF indirect symbol to its direct symbol, hiding the old
   indirect symbol.  Process additional relocation information.  */
static void
s3_bfd_score_elf_copy_indirect_symbol (struct bfd_link_info *info,
                                       struct elf_link_hash_entry *dir,
                                       struct elf_link_hash_entry *ind)
{
  struct score_elf_link_hash_entry *dirscore, *indscore;

  _bfd_elf_link_hash_copy_indirect (info, dir, ind);

  if (ind->root.type != bfd_link_hash_indirect)
    return;

  dirscore = (struct score_elf_link_hash_entry *) dir;
  indscore = (struct score_elf_link_hash_entry *) ind;
  dirscore->possibly_dynamic_relocs += indscore->possibly_dynamic_relocs;

  if (indscore->readonly_reloc)
    dirscore->readonly_reloc = TRUE;

  if (indscore->no_fn_stub)
    dirscore->no_fn_stub = TRUE;
}

/* Remove information about discarded functions from other sections which mention them.  */
static bfd_boolean
s3_bfd_score_elf_discard_info (bfd *abfd, struct elf_reloc_cookie *cookie,
                               struct bfd_link_info *info)
{
  asection *o;
  bfd_boolean ret = FALSE;
  unsigned char *tdata;
  size_t i, skip;

  o = bfd_get_section_by_name (abfd, ".pdr");
  if ((!o) || (o->size == 0) || (o->size % PDR_SIZE != 0)
      || (o->output_section != NULL && bfd_is_abs_section (o->output_section)))
    return FALSE;

  tdata = bfd_zmalloc (o->size / PDR_SIZE);
  if (!tdata)
    return FALSE;

  cookie->rels = _bfd_elf_link_read_relocs (abfd, o, NULL, NULL, info->keep_memory);
  if (!cookie->rels)
    {
      free (tdata);
      return FALSE;
    }

  cookie->rel = cookie->rels;
  cookie->relend = cookie->rels + o->reloc_count;

  for (i = 0, skip = 0; i < o->size; i++)
    {
      if (bfd_elf_reloc_symbol_deleted_p (i * PDR_SIZE, cookie))
        {
          tdata[i] = 1;
          skip++;
        }
    }

  if (skip != 0)
    {
      score_elf_section_data (o)->u.tdata = tdata;
      o->size -= skip * PDR_SIZE;
      ret = TRUE;
    }
  else
    free (tdata);

  if (!info->keep_memory)
    free (cookie->rels);

  return ret;
}

/* Signal that discard_info() has removed the discarded relocations for this section.  */
static bfd_boolean
s3_bfd_score_elf_ignore_discarded_relocs (asection *sec)
{
  if (strcmp (sec->name, ".pdr") == 0)
    return TRUE;
  return FALSE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */
static asection *
s3_bfd_score_elf_gc_mark_hook (asection *sec,
                               struct bfd_link_info *info,
                               Elf_Internal_Rela *rel,
                               struct elf_link_hash_entry *h,
                               Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_SCORE_GNU_VTINHERIT:
      case R_SCORE_GNU_VTENTRY:
        return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Support for core dump NOTE sections.  */

static bfd_boolean
s3_bfd_score_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  unsigned int raw_size;

  switch (note->descsz)
    {
    default:
      return FALSE;

    case 148:                  /* Linux/Score 32-bit.  */
      /* pr_cursig */
      elf_tdata (abfd)->core->signal
	= score_bfd_get_16 (abfd, note->descdata + 12);

      /* pr_pid */
      elf_tdata (abfd)->core->lwpid
	= score_bfd_get_32 (abfd, note->descdata + 24);

      /* pr_reg */
      offset = 72;
      raw_size = 72;

      break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg", raw_size,
					  note->descpos + offset);
}

static bfd_boolean
s3_bfd_score_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
    default:
      return FALSE;

    case 124:                  /* Linux/Score elf_prpsinfo.  */
      elf_tdata (abfd)->core->program
	= _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
      elf_tdata (abfd)->core->command
	= _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}


/* Score BFD functions.  */
static reloc_howto_type *
s3_elf32_score_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED, bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = 0; i < ARRAY_SIZE (elf32_score_reloc_map); i++)
    if (elf32_score_reloc_map[i].bfd_reloc_val == code)
      return &elf32_score_howto_table[elf32_score_reloc_map[i].elf_reloc_val];

  return NULL;
}

static reloc_howto_type *
elf32_score_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
                               const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < (sizeof (elf32_score_howto_table)
            / sizeof (elf32_score_howto_table[0]));
       i++)
    if (elf32_score_howto_table[i].name != NULL
        && strcasecmp (elf32_score_howto_table[i].name, r_name) == 0)
      return &elf32_score_howto_table[i];

  return NULL;
}

static bfd_boolean
s3_elf32_score_print_private_bfd_data (bfd *abfd, void * ptr)
{
  FILE *file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);
  if (elf_elfheader (abfd)->e_flags & EF_SCORE_PIC)
    {
      fprintf (file, _(" [pic]"));
    }
  if (elf_elfheader (abfd)->e_flags & EF_SCORE_FIXDEP)
    {
      fprintf (file, _(" [fix dep]"));
    }
  fputc ('\n', file);

  return TRUE;
}

static bfd_boolean
s3_elf32_score_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword in_flags;
  flagword out_flags;

  if (!_bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  in_flags  = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  in_flags = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  if (! elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = in_flags;

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
          && bfd_get_arch_info (obfd)->the_default)
        {
          return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
        }

      return TRUE;
    }

  if (((in_flags & EF_SCORE_PIC) != 0) != ((out_flags & EF_SCORE_PIC) != 0))
    {
      (*_bfd_error_handler) (_("%B: warning: linking PIC files with non-PIC files"), ibfd);
    }

  /* FIXME: Maybe dependency fix compatibility should be checked here.  */

  return TRUE;
}

static bfd_boolean
s3_elf32_score_new_section_hook (bfd *abfd, asection *sec)
{
  struct _score_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = sdata;

  return _bfd_elf_new_section_hook (abfd, sec);
}

/*****************************************************************************/

/* s3_s7: backend hooks.  */
static void
_bfd_score_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
                          arelent *bfd_reloc,
                          Elf_Internal_Rela *elf_reloc)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_bfd_score_info_to_howto (abfd, bfd_reloc, elf_reloc);
  else
    return s7_bfd_score_info_to_howto (abfd, bfd_reloc, elf_reloc);
}

static bfd_boolean
_bfd_score_elf_relocate_section (bfd *output_bfd,
                                 struct bfd_link_info *info,
                                 bfd *input_bfd,
                                 asection *input_section,
                                 bfd_byte *contents,
                                 Elf_Internal_Rela *relocs,
                                 Elf_Internal_Sym *local_syms,
                                 asection **local_sections)
{
  if (bfd_get_mach (output_bfd) == bfd_mach_score3)
    return s3_bfd_score_elf_relocate_section (output_bfd,
             info, input_bfd, input_section, contents, relocs,
             local_syms, local_sections);
  else
    return s7_bfd_score_elf_relocate_section (output_bfd,
             info, input_bfd, input_section, contents, relocs,
             local_syms, local_sections);
}

static bfd_boolean
_bfd_score_elf_check_relocs (bfd *abfd,
                             struct bfd_link_info *info,
                             asection *sec,
                             const Elf_Internal_Rela *relocs)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_bfd_score_elf_check_relocs (abfd, info, sec, relocs);
  else
    return s7_bfd_score_elf_check_relocs (abfd, info, sec, relocs);
}

static bfd_boolean
_bfd_score_elf_add_symbol_hook (bfd *abfd,
                                struct bfd_link_info *info ATTRIBUTE_UNUSED,
                                Elf_Internal_Sym *sym,
                                const char **namep ATTRIBUTE_UNUSED,
                                flagword *flagsp ATTRIBUTE_UNUSED,
                                asection **secp,
                                bfd_vma *valp)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_bfd_score_elf_add_symbol_hook (abfd, info, sym, namep, flagsp,
                                             secp, valp);
  else
    return s7_bfd_score_elf_add_symbol_hook (abfd, info, sym, namep, flagsp,
                                             secp, valp);
}

static void
_bfd_score_elf_symbol_processing (bfd *abfd, asymbol *asym)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_bfd_score_elf_symbol_processing (abfd, asym);
  else
    return s7_bfd_score_elf_symbol_processing (abfd, asym);
}

static int
_bfd_score_elf_link_output_symbol_hook (struct bfd_link_info *info ATTRIBUTE_UNUSED,
     const char *name ATTRIBUTE_UNUSED,
     Elf_Internal_Sym *sym,
     asection *input_sec,
     struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
{
  /* If link a empty .o, then this filed is NULL.  */
  if (info->input_bfds == NULL)
    {
      /* If we see a common symbol, which implies a relocatable link, then
         if a symbol was small common in an input file, mark it as small
         common in the output file.  */
      if (sym->st_shndx == SHN_COMMON && strcmp (input_sec->name, ".scommon") == 0)
        sym->st_shndx = SHN_SCORE_SCOMMON;
      return 1;
    }

  if (bfd_get_mach (info->input_bfds) == bfd_mach_score3)
    return s3_bfd_score_elf_link_output_symbol_hook (info, name, sym, input_sec, h);
  else
    return s7_bfd_score_elf_link_output_symbol_hook (info, name, sym, input_sec, h);
}

static bfd_boolean
_bfd_score_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
                                         asection *sec,
                                         int *retval)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_bfd_score_elf_section_from_bfd_section (abfd, sec, retval);
  else
    return s7_bfd_score_elf_section_from_bfd_section (abfd, sec, retval);
}

static bfd_boolean
_bfd_score_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
                                      struct elf_link_hash_entry *h)
{
  if (bfd_get_mach (info->input_bfds) == bfd_mach_score3)
    return s3_bfd_score_elf_adjust_dynamic_symbol (info, h);
  else
    return s7_bfd_score_elf_adjust_dynamic_symbol (info, h);
}

static bfd_boolean
_bfd_score_elf_always_size_sections (bfd *output_bfd,
                                     struct bfd_link_info *info)
{
  if (bfd_get_mach (output_bfd) == bfd_mach_score3)
    return s3_bfd_score_elf_always_size_sections (output_bfd, info);
  else
    return s7_bfd_score_elf_always_size_sections (output_bfd, info);
}

static bfd_boolean
_bfd_score_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  if (bfd_get_mach (output_bfd) == bfd_mach_score3)
    return s3_bfd_score_elf_size_dynamic_sections (output_bfd, info);
  else
    return s7_bfd_score_elf_size_dynamic_sections (output_bfd, info);
}

static bfd_boolean
_bfd_score_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_bfd_score_elf_create_dynamic_sections (abfd, info);
  else
    return s7_bfd_score_elf_create_dynamic_sections (abfd, info);
}

static bfd_boolean
_bfd_score_elf_finish_dynamic_symbol (bfd *output_bfd,
                                      struct bfd_link_info *info,
                                      struct elf_link_hash_entry *h,
                                      Elf_Internal_Sym *sym)
{
  if (bfd_get_mach (output_bfd) == bfd_mach_score3)
    return s3_bfd_score_elf_finish_dynamic_symbol (output_bfd, info, h, sym);
  else
    return s7_bfd_score_elf_finish_dynamic_symbol (output_bfd, info, h, sym);
}

static bfd_boolean
_bfd_score_elf_finish_dynamic_sections (bfd *output_bfd,
                                        struct bfd_link_info *info)
{
  if (bfd_get_mach (output_bfd) == bfd_mach_score3)
    return s3_bfd_score_elf_finish_dynamic_sections (output_bfd, info);
  else
    return s7_bfd_score_elf_finish_dynamic_sections (output_bfd, info);
}

static bfd_boolean
_bfd_score_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
                              Elf_Internal_Shdr *hdr,
                              asection *sec)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_bfd_score_elf_fake_sections (abfd, hdr, sec);
  else
    return s7_bfd_score_elf_fake_sections (abfd, hdr, sec);
}

static bfd_boolean
_bfd_score_elf_section_processing (bfd *abfd ATTRIBUTE_UNUSED, Elf_Internal_Shdr *hdr)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_bfd_score_elf_section_processing (abfd, hdr);
  else
    return s7_bfd_score_elf_section_processing (abfd, hdr);
}

static bfd_boolean
_bfd_score_elf_write_section (bfd *output_bfd,
                              struct bfd_link_info *link_info ATTRIBUTE_UNUSED,
                              asection *sec, bfd_byte *contents)
{
  if (bfd_get_mach (output_bfd) == bfd_mach_score3)
    return s3_bfd_score_elf_write_section (output_bfd, sec, contents);
  else
    return s7_bfd_score_elf_write_section (output_bfd, sec, contents);
}

static void
_bfd_score_elf_copy_indirect_symbol (struct bfd_link_info *info,
                                     struct elf_link_hash_entry *dir,
                                     struct elf_link_hash_entry *ind)
{
  if (bfd_get_mach (info->input_bfds) == bfd_mach_score3)
    return s3_bfd_score_elf_copy_indirect_symbol (info, dir, ind);
  else
    return s7_bfd_score_elf_copy_indirect_symbol (info, dir, ind);
}

static void
_bfd_score_elf_hide_symbol (struct bfd_link_info *info,
                            struct elf_link_hash_entry *entry,
                            bfd_boolean force_local)
{
  if (bfd_get_mach (info->input_bfds) == bfd_mach_score3)
    return s3_bfd_score_elf_hide_symbol (info, entry, force_local);
  else
    return s7_bfd_score_elf_hide_symbol (info, entry, force_local);
}

static bfd_boolean
_bfd_score_elf_discard_info (bfd *abfd, struct elf_reloc_cookie *cookie,
                         struct bfd_link_info *info)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_bfd_score_elf_discard_info (abfd, cookie, info);
  else
    return s7_bfd_score_elf_discard_info (abfd, cookie, info);
}

static bfd_boolean
_bfd_score_elf_ignore_discarded_relocs (asection *sec)
{
  if (bfd_get_mach (sec->owner) == bfd_mach_score3)
    return s3_bfd_score_elf_ignore_discarded_relocs (sec);
  else
    return s7_bfd_score_elf_ignore_discarded_relocs (sec);
}

static asection *
_bfd_score_elf_gc_mark_hook (asection *sec,
                             struct bfd_link_info *info,
                             Elf_Internal_Rela *rel,
                             struct elf_link_hash_entry *h,
                             Elf_Internal_Sym *sym)
{
  if (bfd_get_mach (info->input_bfds) == bfd_mach_score3)
    return s3_bfd_score_elf_gc_mark_hook (sec, info, rel, h, sym);
  else
    return s7_bfd_score_elf_gc_mark_hook (sec, info, rel, h, sym);
}

static bfd_boolean
_bfd_score_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_bfd_score_elf_grok_prstatus (abfd, note);
  else
    return s7_bfd_score_elf_grok_prstatus (abfd, note);
}

static bfd_boolean
_bfd_score_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_bfd_score_elf_grok_psinfo (abfd, note);
  else
    return s7_bfd_score_elf_grok_psinfo (abfd, note);
}

static reloc_howto_type *
elf32_score_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED, bfd_reloc_code_real_type code)
{
  /* s3: NOTE!!!
     gas will call elf32_score_reloc_type_lookup, and don't write elf file.
     So just using score3, but we don't know ld will call this or not.
     If so, this way can't work.  */

  if (score3)
    return s3_elf32_score_reloc_type_lookup (abfd, code);
  else
    return s7_elf32_score_reloc_type_lookup (abfd, code);
}

/* Create a score elf linker hash table.
   This is a copy of _bfd_elf_link_hash_table_create() except with a
   different hash table entry creation function.  */

static struct bfd_link_hash_table *
elf32_score_link_hash_table_create (bfd *abfd)
{
  struct elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_link_hash_table);

  ret = (struct elf_link_hash_table *) bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (ret, abfd, score_elf_link_hash_newfunc,
                                      sizeof (struct score_elf_link_hash_entry),
				      GENERIC_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  return &ret->root;
}

static bfd_boolean
elf32_score_print_private_bfd_data (bfd *abfd, void * ptr)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_elf32_score_print_private_bfd_data (abfd, ptr);
  else
    return s7_elf32_score_print_private_bfd_data (abfd, ptr);
}

static bfd_boolean
elf32_score_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_mach (obfd) == bfd_mach_score3)
    return s3_elf32_score_merge_private_bfd_data (ibfd, obfd);
  else
    return s7_elf32_score_merge_private_bfd_data (ibfd, obfd);
}

static bfd_boolean
elf32_score_new_section_hook (bfd *abfd, asection *sec)
{
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_elf32_score_new_section_hook (abfd, sec);
  else
    return s7_elf32_score_new_section_hook (abfd, sec);
}


/* s3_s7: don't need to split.  */

/* Set the right machine number.  */
static bfd_boolean
_bfd_score_elf_score_object_p (bfd * abfd)
{
  int e_set = bfd_mach_score7;

  if (elf_elfheader (abfd)->e_machine == EM_SCORE)
    {
      int e_mach = elf_elfheader (abfd)->e_flags & EF_SCORE_MACH & EF_OMIT_PIC_FIXDD;
      switch (e_mach)
        {
        /* Set default target is score7.  */
        default:
        case E_SCORE_MACH_SCORE7:
          e_set = bfd_mach_score7;
          break;

        case E_SCORE_MACH_SCORE3:
          e_set = bfd_mach_score3;
          break;
        }
    }

  return bfd_default_set_arch_mach (abfd, bfd_arch_score, e_set);
}

bfd_boolean
_bfd_score_elf_common_definition (Elf_Internal_Sym *sym)
{
  return (sym->st_shndx == SHN_COMMON || sym->st_shndx == SHN_SCORE_SCOMMON);
}

/*****************************************************************************/


#define USE_REL                         1
#define TARGET_LITTLE_SYM               bfd_elf32_littlescore_vec
#define TARGET_LITTLE_NAME              "elf32-littlescore"
#define TARGET_BIG_SYM                  bfd_elf32_bigscore_vec
#define TARGET_BIG_NAME                 "elf32-bigscore"
#define ELF_ARCH                        bfd_arch_score
#define ELF_MACHINE_CODE                EM_SCORE
#define ELF_MACHINE_ALT1                EM_SCORE_OLD
#define ELF_MAXPAGESIZE                 0x8000

#define elf_info_to_howto               0
#define elf_info_to_howto_rel           _bfd_score_info_to_howto
#define elf_backend_relocate_section    _bfd_score_elf_relocate_section
#define elf_backend_check_relocs        _bfd_score_elf_check_relocs
#define elf_backend_add_symbol_hook     _bfd_score_elf_add_symbol_hook
#define elf_backend_symbol_processing   _bfd_score_elf_symbol_processing
#define elf_backend_link_output_symbol_hook \
  _bfd_score_elf_link_output_symbol_hook
#define elf_backend_section_from_bfd_section \
  _bfd_score_elf_section_from_bfd_section
#define elf_backend_adjust_dynamic_symbol \
  _bfd_score_elf_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
  _bfd_score_elf_always_size_sections
#define elf_backend_size_dynamic_sections \
  _bfd_score_elf_size_dynamic_sections
#define elf_backend_omit_section_dynsym \
  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
#define elf_backend_create_dynamic_sections \
  _bfd_score_elf_create_dynamic_sections
#define elf_backend_finish_dynamic_symbol \
  _bfd_score_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
  _bfd_score_elf_finish_dynamic_sections
#define elf_backend_fake_sections         _bfd_score_elf_fake_sections
#define elf_backend_section_processing    _bfd_score_elf_section_processing
#define elf_backend_write_section         _bfd_score_elf_write_section
#define elf_backend_copy_indirect_symbol  _bfd_score_elf_copy_indirect_symbol
#define elf_backend_hide_symbol           _bfd_score_elf_hide_symbol
#define elf_backend_discard_info          _bfd_score_elf_discard_info
#define elf_backend_ignore_discarded_relocs \
  _bfd_score_elf_ignore_discarded_relocs
#define elf_backend_gc_mark_hook          _bfd_score_elf_gc_mark_hook
#define elf_backend_grok_prstatus         _bfd_score_elf_grok_prstatus
#define elf_backend_grok_psinfo           _bfd_score_elf_grok_psinfo
#define elf_backend_can_gc_sections       1
#define elf_backend_want_plt_sym          0
#define elf_backend_got_header_size       (4 * SCORE_RESERVED_GOTNO)
#define elf_backend_plt_header_size       0
#define elf_backend_collect               TRUE
#define elf_backend_type_change_ok        TRUE
#define elf_backend_object_p                  _bfd_score_elf_score_object_p

#define bfd_elf32_bfd_reloc_type_lookup      elf32_score_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup \
  elf32_score_reloc_name_lookup
#define bfd_elf32_bfd_link_hash_table_create elf32_score_link_hash_table_create
#define bfd_elf32_bfd_print_private_bfd_data elf32_score_print_private_bfd_data
#define bfd_elf32_bfd_merge_private_bfd_data elf32_score_merge_private_bfd_data
#define bfd_elf32_new_section_hook           elf32_score_new_section_hook

#include "elf32-target.h"
@


1.28
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d2840 4
@


1.27
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d3909 2
a3910 1
      elf_tdata (abfd)->core_signal = score_bfd_get_16 (abfd, note->descdata + 12);
d3913 2
a3914 1
      elf_tdata (abfd)->core_lwpid = score_bfd_get_32 (abfd, note->descdata + 24);
d3924 2
a3925 1
  return _bfd_elfcore_make_pseudosection (abfd, ".reg", raw_size, note->descpos + offset);
d3937 4
a3940 2
      elf_tdata (abfd)->core_program = _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
      elf_tdata (abfd)->core_command = _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
d3948 1
a3948 1
    char *command = elf_tdata (abfd)->core_command;
@


1.26
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d4360 1
a4360 1
  ret = (struct elf_link_hash_table *) bfd_malloc (amt);
@


1.25
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d3540 2
a3541 1
  if (strcmp (name, "_DYNAMIC") == 0 || strcmp (name, "_GLOBAL_OFFSET_TABLE_") == 0)
@


1.24
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d1069 1
a1069 1
  asection *sgot = bfd_get_section_by_name (abfd, ".got");
d1250 1
a1250 1
  sreloc = bfd_get_section_by_name (dynobj, dname);
d1253 7
a1259 7
      sreloc = bfd_make_section_with_flags (dynobj, dname,
                                            (SEC_ALLOC
                                             | SEC_LOAD
                                             | SEC_HAS_CONTENTS
                                             | SEC_IN_MEMORY
                                             | SEC_LINKER_CREATED
                                             | SEC_READONLY));
d1432 1
a1432 1
  s = bfd_make_section_with_flags (abfd, ".got", flags);
d3126 1
a3126 1
          s = bfd_get_section_by_name (dynobj, SCORE_ELF_STUB_SECTION_NAME);
d3262 1
a3262 1
          s = bfd_get_section_by_name (dynobj, ".interp");
d3420 1
a3420 1
  s = bfd_get_section_by_name (abfd, ".dynamic");
d3435 1
a3435 1
  if (bfd_get_section_by_name (abfd, SCORE_ELF_STUB_SECTION_NAME) == NULL)
d3437 2
a3438 2
      s = bfd_make_section_with_flags (abfd, SCORE_ELF_STUB_SECTION_NAME,
                                       flags | SEC_CODE);
d3492 1
a3492 1
      s = bfd_get_section_by_name (dynobj, SCORE_ELF_STUB_SECTION_NAME);
d3571 1
a3571 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
@


1.23
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2677 1
a2677 1
					 rel, relend, howto, contents);
@


1.22
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d2 1
a2 1
   Copyright 2006, 2007, 2008, 2009, 2010, 2011
d2675 1
a2675 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.22.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2675 1
a2675 1
      if (sec != NULL && discarded_section (sec))
@


1.21
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d2 2
a3 1
   Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
a1040 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct score_elf_link_hash_entry *) h->root.root.u.i.link;

@


1.20
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d2678 2
a2679 9
        {
          /* For relocs against symbols from removed linkonce sections,
             or sections discarded by a linker script, we just want the
             section contents zeroed.  Avoid any special processing.  */
          _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
          rel->r_info = 0;
          rel->r_addend = 0;
          continue;
        }
@


1.19
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d2129 1
a2129 1
           && r_symndx != 0
d2142 2
a2143 2
      else if (r_symndx == 0)
        /* r_symndx will be zero only for relocs against symbols
@


1.18
log
@fix set but unused variable warnings
@
text
@d3920 1
a3920 1
      elf_tdata (abfd)->core_pid = score_bfd_get_32 (abfd, note->descdata + 24);
@


1.17
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@a1776 1
  struct score_got_info *g;
d1778 1
a1778 1
  g = score_elf_got_info (dynobj, &sgot);
a1988 2
  /* The value of GP used to create the relocatable object.  */
  bfd_vma gp0 = MINUS_ONE;
a2106 1
      gp0 = _bfd_get_gp_value (input_bfd);
a2406 1
  struct elf_link_hash_entry **sym_hashes;
a2436 1
  sym_hashes = elf_sym_hashes (input_bfd);
@


1.16
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
a39 7
/* Score ELF linker hash table.  */
struct score_elf_link_hash_table
{
  /* The main hash table.  */
  struct elf_link_hash_table root;
};

d64 1
a64 1
   (&(table)->root, \
a67 4
/* Get the SCORE elf linker hash table from a link_info structure.  */
#define score_elf_hash_table(info) \
  ((struct score_elf_link_hash_table *) ((info)->hash))

d1127 3
a1129 4
  score_elf_link_hash_traverse (((struct score_elf_link_hash_table *)
                                 elf_hash_table (info)),
                                 score_elf_sort_hash_table_f,
                                 &hsd);
d1145 1
d1151 1
a1151 1
  struct score_elf_link_hash_entry *ret = (struct score_elf_link_hash_entry *)entry;
d1157 1
a1157 1
    return (struct bfd_hash_entry *)ret;
d1161 1
a1161 1
         _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *)ret, table, string));
d1171 1
a1171 1
  return (struct bfd_hash_entry *)ret;
d2075 1
a2075 1
          if ((! elf_hash_table(info)->dynamic_sections_created
a3997 22
/* Create a score elf linker hash table.  */

static struct bfd_link_hash_table *
s3_elf32_score_link_hash_table_create (bfd *abfd)
{
  struct score_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct score_elf_link_hash_table);

  ret = bfd_malloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd, score_elf_link_hash_newfunc,
                                      sizeof (struct score_elf_link_hash_entry)))
    {
      free (ret);
      return NULL;
    }

  return &ret->root.root;
}

d4364 4
d4371 16
a4386 4
  if (bfd_get_mach (abfd) == bfd_mach_score3)
    return s3_elf32_score_link_hash_table_create (abfd);
  else
    return s7_elf32_score_link_hash_table_create (abfd);
@


1.15
log
@	* elf-bfd.h (struct elf_backend_data
	<elf_backend_link_output_symbol_hook>): Return an int.
	* elf64-ppc.c (ppc64_elf_output_symbol_hook): Return 2 to drop
	symbols on deleted .opd entries.
	* elflink.c (elf_link_output_sym): Return without outputting sym
	if output_symbol_hook returns 2.
	(elf_link_output_extsym): Don't assign h->indx when symbol discarded.
	Abort if we must not discard sym.
	(elf_link_input_bfd): Similarly, don't set finfo->indices for
	local syms.
	(bfd_elf_final_link): Adjust elf_link_output_sym calls.
	* elf-vxworks.c (elf_vxworks_link_output_symbol_hook): Adjust for
	elf_backend_link_output_symbol_hook return type change.
	* elf32-arm.c (output_arch_syminfo): Likewise.
	(elf32_arm_output_map_sym, elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_output_arch_local_syms): Likewise.
	* elf32-cr16c.c (elf32_cr16c_link_output_symbol_hook): Likewise.
	* elf32-score.c (s3_bfd_score_elf_link_output_symbol_hook): Likewise.
	(bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score.h (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Likewise.
	* elf32-spu.c (spu_elf_output_symbol_hook): Likewise.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
@
text
@d1758 1
a1758 1
  bfd_vma index;
d1772 2
a1773 2
  index = ((h->dynindx - global_got_dynindx + g->local_gotno) * SCORE_ELF_GOT_SIZE (abfd));
  BFD_ASSERT (index < sgot->size);
d1775 1
a1775 1
  return index;
d1779 1
d1781 4
a1784 2
score_elf_got_offset_from_index (bfd *dynobj, bfd *output_bfd,
                                 bfd *input_bfd ATTRIBUTE_UNUSED, bfd_vma index)
d1793 1
a1793 1
  return sgot->output_section->vma + sgot->output_offset + index - gp;
@


1.14
log
@Add support for Score7 architecture.
@
text
@d3071 1
a3071 1
static bfd_boolean
d3084 1
a3084 1
  return TRUE;
d4182 1
a4182 1
static bfd_boolean
d4197 1
a4197 1
      return TRUE;
@


1.13
log
@	* elf-m10300.c (mn10300_elf_check_relocs): Delete dead code.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-bfin.c (bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (_frvfdpic_check_discarded_relocs): Likewise.
	(elf32_frv_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	(score_elf_local_relocation_p): Likewise.
	(_bfd_score_elf_relocate_section): Likewise.
	(score_elf_final_link_relocate): Likewise.
@
text
@d2 1
a2 1
   Copyright 2006, 2007 Free Software Foundation, Inc.
d4 1
d34 1
d37 3
a40 1

a48 1

d181 1
a181 1
#define STUB_LW	     0xc3bcc010     /* lw r29, [r28, -0x3ff0]  */
a203 4
#ifndef NUM_ELEM
#define NUM_ELEM(a)  (sizeof (a) / (sizeof (a)[0]))
#endif

d218 98
d318 6
a323 6
		      arelent *reloc_entry,
		      asymbol *symbol ATTRIBUTE_UNUSED,
		      void * data,
		      asection *input_section ATTRIBUTE_UNUSED,
		      bfd *output_bfd ATTRIBUTE_UNUSED,
		      char **error_message ATTRIBUTE_UNUSED)
d331 6
a336 6
		      arelent *reloc_entry,
		      asymbol *symbol ATTRIBUTE_UNUSED,
		      void * data,
		      asection *input_section,
		      bfd *output_bfd ATTRIBUTE_UNUSED,
		      char **error_message ATTRIBUTE_UNUSED)
d342 1
a342 1
  hi16_value = bfd_get_32 (abfd, hi16_rel_addr);
d344 1
a344 1
  addend = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d352 1
a352 1
  bfd_put_32 (abfd, hi16_value, hi16_rel_addr);
d355 1
a355 1
  bfd_put_32 (abfd, addend, (bfd_byte *) data + reloc_entry->address);
d384 2
a385 2
	{
	  const char *name;
d387 8
a394 8
	  name = bfd_asymbol_name (*sym);
	  if (*name == '_' && strcmp (name, "_gp") == 0)
	    {
	      *pgp = bfd_asymbol_value (*sym);
	      _bfd_set_gp_value (output_bfd, *pgp);
	      break;
	    }
	}
a412 1

d415 4
a418 4
		    asymbol *symbol,
		    bfd_boolean relocatable,
 		    char **error_message,
		    bfd_vma *pgp)
d430 1
a430 1
	  || (symbol->flags & BSF_SECTION_SYM) != 0))
d433 5
a437 5
	{
	  /* Make up a value.  */
	  *pgp = symbol->section->output_section->vma + 0x4000;
	  _bfd_set_gp_value (output_bfd, *pgp);
	}
d439 5
a443 5
	{
	    *error_message =
	      (char *) _("GP relative relocation when _gp not defined");
	    return bfd_reloc_dangerous;
	}
d451 6
a456 6
			   asymbol *symbol,
			   arelent *reloc_entry,
			   asection *input_section,
			   bfd_boolean relocateable,
			   void * data,
			   bfd_vma gp ATTRIBUTE_UNUSED)
d471 1
a471 1
  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d477 1
a477 1
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);
d486 2
a487 2
		 asection *input_section, bfd_boolean relocatable,
		 void *data, bfd_vma gp)
d507 1
a507 1
    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d517 1
a517 1
    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
d529 6
a534 6
			 arelent *reloc_entry,
			 asymbol *symbol,
			 void * data,
			 asection *input_section,
			 bfd *output_bfd,
			 char **error_message)
d540 1
a540 1
  if (output_bfd != (bfd *) NULL
d546 1
a546 1
  if (output_bfd != (bfd *) NULL)
d567 2
a568 2
			void *data, asection *input_section, bfd *output_bfd,
			char **error_message)
d580 1
a580 1
	_("32bits gp relative relocation occurs for an external symbol");
d596 1
a596 1
  gp = 0;   /* FIXME.  */
d598 1
a598 1
			  relocatable, data, gp);
a603 1

d606 2
a607 2
		       void *data, asection *input_section,
		       bfd *output_bfd, char **error_message)
d614 2
a615 2
				  input_section, output_bfd,
				  error_message);
d618 1
a618 1
			       input_section, output_bfd, error_message);
d623 6
a628 6
		          arelent *reloc_entry,
		          asymbol *symbol ATTRIBUTE_UNUSED,
		          void * data,
		          asection *input_section,
		          bfd *output_bfd ATTRIBUTE_UNUSED,
		          char **error_message ATTRIBUTE_UNUSED)
d634 1
a634 1
  hi16_value = bfd_get_32 (abfd, hi16_rel_addr);
d636 1
a636 1
  addend = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d647 1
a647 1
  bfd_put_32 (abfd, hi16_value, hi16_rel_addr);
d650 1
a650 1
  bfd_put_32 (abfd, addend, (bfd_byte *) data + reloc_entry->address);
d679 1
a679 1
	 score_elf_hi16_reloc,  /* special_function */
d701 3
a703 3
  /*  R_SCORE_DUMMY1 */
  HOWTO (R_SCORE_DUMMY1,        /* type */
         0,                     /* rightshift */
d706 1
a706 1
         FALSE,                 /* pc_relative */
d710 4
a713 4
         "R_SCORE_DUMMY1",      /* name */
         TRUE,                  /* partial_inplace */
         0x0000ffff,            /* src_mask */
         0x0000ffff,            /* dst_mask */
d765 1
a765 1
         8,                     /* bitsize */
d772 2
a773 2
         0x000000ff,            /* src_mask */
         0x000000ff,            /* dst_mask */
d928 12
a939 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_SCORE_REL32",       /* name */
	 TRUE,                  /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 FALSE),                /* pcrel_offset */
d949 1
a949 1
	 score_elf_hi16_reloc,  /* special_function */
d955 30
d998 1
a998 1
  {BFD_RELOC_SCORE_DUMMY1,       R_SCORE_DUMMY1},
d1015 2
a1021 1

d1039 2
a1040 2
	: e1->symndx >= 0 ? e1->d.addend == e2->d.addend
	: e1->d.h == e2->d.h);
a1045 1

d1065 1
a1065 1
	hsd->low = (struct elf_link_hash_entry *) h;
a1090 1

d1112 1
a1112 1
   _bfd_score_elf_size_dynamic_sections, this value is 1.  Afterward, the
a1113 1

d1116 1
a1116 1
			   unsigned long max_local)
d1139 3
a1141 3
				 elf_hash_table (info)),
			         score_elf_sort_hash_table_f,
			         &hsd);
d1147 1
a1147 1
	      <= elf_hash_table (info)->dynsymcount);
a1156 1

d1159 2
a1160 2
			     struct bfd_hash_table *table,
			     const char *string)
a1186 1

d1189 2
a1190 2
	 		   const Elf_Internal_Rela *relocation,
			   const Elf_Internal_Rela *relend)
d1195 1
a1195 1
	return relocation;
a1206 1

a1219 1

d1222 3
a1224 2
			      const Elf_Internal_Rela *relocation,
			      bfd_boolean check_forced)
d1233 1
a1233 1
  extsymoff = symtab_hdr->sh_info;
d1237 2
d1244 1
a1244 1
	elf_sym_hashes (input_bfd) [r_symndx - extsymoff];
d1247 2
a1248 2
	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct score_elf_link_hash_entry *) h->root.root.u.i.link;
d1250 1
a1250 1
	return TRUE;
a1256 1

d1274 3
a1276 3
	  || ! bfd_set_section_alignment (dynobj, sreloc,
					  SCORE_ELF_LOG_FILE_ALIGN (dynobj)))
	return NULL;
d1278 1
a1278 1
  return sreloc; 
a1301 1

d1304 5
a1308 5
				     struct bfd_link_info *info,
				     const Elf_Internal_Rela *rel,
				     struct score_elf_link_hash_entry *h,
				     bfd_vma symbol,
				     bfd_vma *addendp, asection *input_section)
d1338 2
a1339 2
	 some sort.  Functions like _bfd_elf_write_section_eh_frame expect
	 the field to be fully relocated, so add in the symbol's value.  */
d1349 1
a1349 1
	 become local.  */
d1353 4
a1356 4
	/* ??? glibc's ld.so just adds the final GOT entry to the
	   relocation field.  It therefore treats relocs against
	   defined symbols in the same way as relocs against
	   undefined symbols.  */
d1394 1
a1394 1
			 + input_section->output_offset);
d1396 1
a1396 1
			 + input_section->output_offset);
d1398 1
a1398 1
			 + input_section->output_offset);
d1420 1
a1420 1
			      bfd_boolean maybe_exclude)
d1434 1
a1434 1
	s->flags &= ~SEC_EXCLUDE;
d1455 2
a1456 2
	 (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
	  0, NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
d1480 1
a1480 1
				    score_elf_got_entry_eq, NULL);
a1489 1

a1497 1

d1501 5
a1505 5
				  struct score_got_info *gg,
				  asection *sgot, bfd_vma value,
				  unsigned long r_symndx ATTRIBUTE_UNUSED,
				  struct score_elf_link_hash_entry *h ATTRIBUTE_UNUSED,
				  int r_type ATTRIBUTE_UNUSED)
d1533 1
a1533 1
	(_("not enough GOT space for local GOT entries"));
d1538 1
a1538 1
  bfd_put_32 (abfd, value, (sgot->contents + entry.gotidx));
a1544 1

d1547 1
a1547 1
		      bfd_vma value, bfd_boolean external)
d1556 3
a1558 3
	 want, it is really the %high value.  The complete value is
	 calculated with a `addiu' of a LO16 relocation, just as with a
	 HI16/LO16 pair.  */
d1565 1
a1565 1
					    R_SCORE_GOT15);
d1573 3
a1575 3
_bfd_score_elf_hide_symbol (struct bfd_link_info *info,
			    struct elf_link_hash_entry *entry,
			    bfd_boolean force_local)
d1592 1
a1592 1
	return;
d1596 31
a1626 31
	{
	  struct score_got_entry e;
	  struct score_got_info *gg = g;

	  /* Since we're turning what used to be a global symbol into a
	     local one, bump up the number of local entries of each GOT
	     that had an entry for it.  This will automatically decrease
	     the number of global entries, since global_gotno is actually
	     the upper limit of global entries.  */
	  e.abfd = dynobj;
	  e.symndx = -1;
	  e.d.h = h;

	  for (g = g->next; g != gg; g = g->next)
	    if (htab_find (g->got_entries, &e))
	      {
		BFD_ASSERT (g->global_gotno > 0);
		g->local_gotno++;
		g->global_gotno--;
	      }

	  /* If this was a global symbol forced into the primary GOT, we
	     no longer need an entry for it.  We can't release the entry
	     at this point, but we must at least stop counting it as one
	     of the symbols that required a forced got entry.  */
	  if (h->root.got.offset == 2)
	    {
	      BFD_ASSERT (gg->assigned_gotno > 0);
	      gg->assigned_gotno--;
	    }
	}
d1628 4
a1631 4
	/* If we haven't got through GOT allocation yet, just bump up the
	      number of local entries, as this symbol won't be counted as
	      global.  */
	g->local_gotno++;
d1633 8
a1640 8
	{
	  /* If we're past non-multi-GOT allocation and this symbol had
	          been marked for a global got entry, give it a local entry
		  instead.  */
	  BFD_ASSERT (g->global_gotno > 0);
	  g->local_gotno++;
	  g->global_gotno--;
	}
a1648 1

d1651 1
a1651 1
	 			    bfd *abfd,
d1653 1
a1653 1
				    struct score_got_info *g)
d1661 6
a1666 6
	{
	case STV_INTERNAL:
	case STV_HIDDEN:
	  _bfd_score_elf_hide_symbol (info, h, TRUE);
	  break;
	}
d1668 1
a1668 1
	return FALSE;
a1702 1

d1707 1
a1707 1
	  			   struct score_got_info *g)
a1732 1

d1735 2
a1736 2
			  bfd_vma value, unsigned long r_symndx,
			  struct score_elf_link_hash_entry *h, int r_type)
d1745 1
a1745 1
		 			    r_symndx, h, r_type);
a1778 1

d1781 1
a1781 1
	 			 bfd *input_bfd ATTRIBUTE_UNUSED, bfd_vma index)
d1810 2
a1811 2
	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct score_elf_link_hash_entry *) h->root.root.u.i.link;
d1814 1
a1814 1
	return 1;
d1819 1
a1819 1
	 it, and get the traversal restarted.  */
d1821 11
a1831 11
	{
	  htab_clear_slot (got_entries, entryp);
	  entryp = htab_find_slot (got_entries, entry, INSERT);
	  if (! *entryp)
	    *entryp = entry;
	  /* Abort the traversal, since the whole table may have
	     moved, and leave it up to the parent to restart the
	     process.  */
	  *(htab_t *)p = NULL;
	  return 0;
	}
d1833 1
a1833 1
	 either too early or too late for that at this point.  */
d1850 2
a1851 2
		     score_elf_resolve_final_got_entry,
		     &got_entries);
a1856 1

d1859 3
a1861 3
		      bfd_byte *address,
		      reloc_howto_type *howto,
		      bfd_signed_vma increment)
d1869 1
a1869 1
  contents = bfd_get_32 (abfd, address);
d1890 1
a1890 1
      bfd_put_32 (abfd, contents, address);
d1895 1
a1895 1
      hi16_addend = bfd_get_32 (abfd, address - 4);
d1903 1
a1903 1
      bfd_put_32 (abfd, hi16_value, address - 4);
d1906 1
a1906 1
      bfd_put_32 (abfd, contents, address);
d1915 1
a1915 1
      bfd_put_32 (abfd, contents, address);
d1917 1
d1920 1
a1920 1
      contents = bfd_get_16 (abfd, address);
d1924 1
a1924 1
      bfd_put_16 (abfd, contents, address);
d1929 23
a1951 2
      contents = bfd_get_16 (abfd, address);
      offset = (contents & howto->src_mask) + ((increment >> 1) & 0xff);
d1953 2
a1954 1
      bfd_put_16 (abfd, contents, address);
d1956 6
d1963 1
d1967 1
a1967 1
      bfd_put_32 (abfd, contents, address);
a1972 1

d1975 12
a1986 11
			       bfd *input_bfd,
			       bfd *output_bfd,
			       asection *input_section,
			       bfd_byte *contents,
			       Elf_Internal_Rela *rel,
			       Elf_Internal_Rela *relocs,
			       bfd_vma symbol,
			       struct bfd_link_info *info,
			       const char *sym_name ATTRIBUTE_UNUSED,
			       int sym_flags ATTRIBUTE_UNUSED,
			       struct score_elf_link_hash_entry *h,
d2009 1
d2016 1
a2016 1
      if (bh != (struct bfd_link_hash_entry *)NULL && bh->type == bfd_link_hash_defined)
d2025 1
a2025 1
          for (o = output_bfd->sections; o != (asection *) NULL; o = o->next)
d2043 1
a2043 1
  local_p = score_elf_local_relocation_p (input_bfd, rel, TRUE);
d2056 5
a2060 5
	{
	  bfd_vma tmp = 0;
	  tmp = bfd_get_32 (input_bfd, contents + lo16_rel->r_offset);
	  lo_value = (((tmp >> 16) & 0x3) << 14) | ((tmp & 0x7fff) >> 1);
	}
d2063 5
d2070 1
a2070 1
      addend = (bfd_get_32 (input_bfd, hit_data) >> howto->bitpos) & howto->src_mask;
d2093 1
a2093 1
              bfd_put_32 (tmpbfd, value, sgot->contents + g);
d2098 4
a2101 4
	  /* There's no need to create a local GOT entry here; the
	     calculation for a local GOT15 entry does not involve G.  */
	  ;
	}
d2104 1
a2104 1
	  g = score_elf_local_got_index (output_bfd, input_bfd, info,
d2106 2
a2107 2
  	  if (g == MINUS_ONE)
	    return bfd_reloc_outofrange;
d2112 1
a2112 1
					   output_bfd, input_bfd, g);
d2137 8
a2144 8
	   || (elf_hash_table (info)->dynamic_sections_created
	       && h != NULL
	       && h->root.def_dynamic
	       && !h->root.def_regular))
	   && r_symndx != 0
	   && (input_section->flags & SEC_ALLOC) != 0)
	{
	  /* If we're creating a shared library, or this relocation is against a symbol
d2148 11
a2158 6
	  value = addend;
	  if (!score_elf_create_dynamic_relocation (output_bfd, info, rel, h,
						    symbol, &value,
						    input_section))
	    return bfd_reloc_undefined;
	}
d2160 6
a2165 6
	{
	  if (r_type != R_SCORE_REL32)
	    value = symbol + addend;
	  else
	    value = addend;
	}
d2174 1
a2174 1
      bfd_put_16 (input_bfd, value, hit_data);
d2178 1
a2178 1
      addend = bfd_get_32 (input_bfd, hit_data);
d2183 3
d2188 1
a2188 1
      bfd_put_32 (input_bfd, addend, hit_data);
d2191 46
d2238 1
a2238 1
      addend = bfd_get_32 (input_bfd, hit_data);
d2250 1
a2250 1
      bfd_put_32 (input_bfd, addend, hit_data);
d2254 1
a2254 1
      addend = bfd_get_16 (input_bfd, hit_data);
d2259 3
d2263 1
a2263 1
      bfd_put_16 (input_bfd, addend, hit_data);
d2267 1
a2267 1
      addend = bfd_get_16 (input_bfd, hit_data);
d2269 1
a2269 1
      if ((offset & 0x100) != 0)        /* Offset is negative.  */
d2273 1
a2273 1
      if (((value & 0xffffff00) != 0) && ((value & 0xffffff00) != 0xffffff00))
d2277 18
a2294 1
      bfd_put_16 (input_bfd, addend, hit_data);
d2301 1
a2301 1
      hi16_addend = bfd_get_32 (input_bfd, hit_data - 4);
d2303 1
a2303 1
      addend = bfd_get_32 (input_bfd, hit_data);
d2308 1
a2308 1
	uvalue = value + offset;
d2310 1
a2310 1
	uvalue = offset + gp - rel_addr + 4;
d2315 1
a2315 1
      bfd_put_32 (input_bfd, hi16_value, hit_data - 4);
d2318 1
a2318 1
      bfd_put_32 (input_bfd, value, hit_data);
d2322 1
a2322 1
      addend = bfd_get_32 (input_bfd, hit_data);
d2330 1
a2330 1
      bfd_put_32 (input_bfd, value, hit_data);
d2336 2
a2337 2
	{
	  bfd_boolean forced;
d2339 1
a2339 1
	  /* The special case is when the symbol is forced to be local.  We need the
d2341 9
a2349 8
	  forced = ! score_elf_local_relocation_p (input_bfd, rel, FALSE);
	  value = score_elf_got16_entry (output_bfd, input_bfd, info,
					 symbol + addend, forced);
	  if (value == MINUS_ONE)
	    return bfd_reloc_outofrange;
	  value = score_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
						   output_bfd, input_bfd, value);
	}
d2351 3
a2353 3
	{
	  value = g;
	}
d2358 1
a2358 1
      addend = bfd_get_32 (input_bfd, hit_data);
d2360 1
a2360 1
      bfd_put_32 (input_bfd, value, hit_data);
d2366 1
a2366 1
      bfd_put_32 (input_bfd, value, hit_data);
d2370 1
a2370 1
      addend = bfd_get_32 (input_bfd, hit_data);
d2373 1
a2373 1
      value = (addend & (~(howto->dst_mask))) | ((value & 0x3fff) << 1)  
d2376 1
a2376 1
      bfd_put_32 (input_bfd, value, hit_data);
a2392 1

d2394 3
a2396 3
_bfd_score_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
			  arelent *bfd_reloc,
			  Elf_Internal_Rela *elf_reloc)
d2401 1
a2401 1
  if (r_type >= NUM_ELEM (elf32_score_howto_table))
a2407 1

d2409 8
a2416 8
_bfd_score_elf_relocate_section (bfd *output_bfd,
			         struct bfd_link_info *info,
			         bfd *input_bfd,
			         asection *input_section,
			         bfd_byte *contents,
			         Elf_Internal_Rela *relocs,
			         Elf_Internal_Sym *local_syms,
			         asection **local_sections)
d2433 10
a2442 10
	{
	  asection * p;
	  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);

	  for (p = output_bfd->sections; p ; p = p->next)
	    if ((p->flags & SEC_EXCLUDE) == 0
		&& (p->flags & SEC_ALLOC) != 0
		&& !(*bed->elf_backend_omit_section_dynsym) (output_bfd, info, p))
	      ++ dynsecsymcount;
	}
d2445 1
a2445 1
	return FALSE;
d2449 1
a2449 1
  extsymoff = symtab_hdr->sh_info;
d2468 1
a2468 1
      _bfd_score_info_to_howto (input_bfd, &bfd_reloc, (Elf_Internal_Rela *) rel);
d2480 2
a2481 2
			+ sec->output_offset
			+ sym->st_value);
d2485 2
a2486 2
	      && (sec->flags & SEC_MERGE) != 0
	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
d2496 1
a2496 1
                  hi16_addend = bfd_get_32 (input_bfd, contents + rel->r_offset - 4);
d2498 1
a2498 1
                  value = bfd_get_32 (input_bfd, contents + rel->r_offset);
d2509 1
a2509 1
                  bfd_put_32 (input_bfd, hi16_value, contents + rel->r_offset - 4);
d2513 1
a2513 1
                  bfd_put_32 (input_bfd, value, contents + rel->r_offset);
d2515 51
d2567 1
a2567 1
                  value = bfd_get_32 (input_bfd, contents + rel->r_offset);
d2575 20
d2597 1
d2599 1
a2599 1
                  value = bfd_get_32 (input_bfd, contents + rel->r_offset);
d2614 1
a2614 1
                  bfd_put_32 (input_bfd, value, contents + rel->r_offset);
d2621 53
a2673 53
	  /* For global symbols we look up the symbol in the hash-table.  */
	  h = ((struct score_elf_link_hash_entry *)
	       elf_sym_hashes (input_bfd) [r_symndx - extsymoff]);
	  /* Find the real hash-table entry for this symbol.  */
	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct score_elf_link_hash_entry *) h->root.root.u.i.link;

	  /* Record the name of this symbol, for our caller.  */
	  name = h->root.root.root.string;

	  /* See if this is the special GP_DISP_LABEL symbol.  Note that such a
	     symbol must always be a global symbol.  */
	  if (strcmp (name, GP_DISP_LABEL) == 0)
	    {
	      /* Relocations against GP_DISP_LABEL are permitted only with
		 R_SCORE_HI16 and R_SCORE_LO16 relocations.  */
	      if (r_type != R_SCORE_HI16 && r_type != R_SCORE_LO16)
		return bfd_reloc_notsupported;

	      gp_disp_p = TRUE;
	    }

	  /* If this symbol is defined, calculate its address.  Note that
	      GP_DISP_LABEL is a magic symbol, always implicitly defined by the
	      linker, so it's inappropriate to check to see whether or not
	      its defined.  */
	  else if ((h->root.root.type == bfd_link_hash_defined
		    || h->root.root.type == bfd_link_hash_defweak)
		   && h->root.root.u.def.section)
	    {
	      sec = h->root.root.u.def.section;
	      if (sec->output_section)
		relocation = (h->root.root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	      else
		{
		  relocation = h->root.root.u.def.value;
		}
	    }
	  else if (h->root.root.type == bfd_link_hash_undefweak)
	    /* We allow relocations against undefined weak symbols, giving
	       it the value zero, so that you can undefined weak functions
	       and check to see if they exist by looking at their addresses.  */
	    relocation = 0;
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
	    relocation = 0;
	  else if (strcmp (name, "_DYNAMIC_LINK") == 0)
	    {
	      /* If this is a dynamic link, we should have created a _DYNAMIC_LINK symbol
	         in _bfd_score_elf_create_dynamic_sections.  Otherwise, we should define
d2675 14
a2688 14
	      BFD_ASSERT (! info->shared);
	      BFD_ASSERT (bfd_get_section_by_name (output_bfd, ".dynamic") == NULL);
	      relocation = 0;
	    }
	  else if (!info->relocatable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.root.string, input_bfd,
		      input_section, rel->r_offset,
		      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
		      || ELF_ST_VISIBILITY (h->root.other))))
		return bfd_reloc_undefined;
	      relocation = 0;
	    }
d2692 9
a2700 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
d2708 10
a2717 3
          if (sym != NULL && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    score_elf_add_to_rel (input_bfd, contents + rel->r_offset,
				  howto, (bfd_signed_vma) sec->output_offset);
d2721 1
d2726 1
a2726 1
					 ELF_ST_TYPE ((unsigned int)sym->st_info)), h,
d2763 5
a2785 1

d2787 4
a2790 4
_bfd_score_elf_check_relocs (bfd *abfd,
			     struct bfd_link_info *info,
			     asection *sec,
			     const Elf_Internal_Rela *relocs)
d2810 1
a2810 1
  extsymoff = symtab_hdr->sh_info;
d2845 1
a2845 1
	{
d2847 1
a2847 1
	}
d2891 2
a2892 2
	  if (! score_elf_record_local_got_symbol (abfd, r_symndx, rel->r_addend, g))
	    return FALSE;
d2898 13
a2910 13
	  if (h == NULL)
	    {
	      (*_bfd_error_handler)
		(_("%B: CALL15 reloc at 0x%lx not against global symbol"),
		 abfd, (unsigned long) rel->r_offset);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  else
	    {
	      /* This symbol requires a global offset table entry.  */
	      if (! score_elf_record_global_got_symbol (h, abfd, info, g))
		return FALSE;
d2912 1
a2912 1
	      /* We need a stub, not a plt entry for the undefined function.  But we record
d2914 7
a2920 3
	      h->needs_plt = 1;
	      h->type = STT_FUNC;
	    }
a2921 4
	case R_SCORE_GOT15:
	  if (h && ! score_elf_record_global_got_symbol (h, abfd, info, g))
	    return FALSE;
	  break;
d2924 8
a2931 8
	  if ((info->shared || h != NULL) && (sec->flags & SEC_ALLOC) != 0)
	    {
	      if (sreloc == NULL)
		{
		  sreloc = score_elf_rel_dyn_section (dynobj, TRUE);
		  if (sreloc == NULL)
		    return FALSE;
		}
d2933 3
a2935 3
	      if (info->shared)
		{
		  /* When creating a shared object, we must copy these reloc types into
d2938 10
a2947 10
		  score_elf_allocate_dynamic_relocations (dynobj, 1);
		  if ((sec->flags & SCORE_READONLY_SECTION)
		      == SCORE_READONLY_SECTION)
		    /* We tell the dynamic linker that there are
		       relocations against the text segment.  */
		    info->flags |= DF_TEXTREL;
		}
	      else
		{
		  struct score_elf_link_hash_entry *hscore;
d2949 1
a2949 1
		  /* We only need to copy this reloc if the symbol is
d2951 8
a2958 8
		  hscore = (struct score_elf_link_hash_entry *)h;
		  ++hscore->possibly_dynamic_relocs;
		  if ((sec->flags & SCORE_READONLY_SECTION)
		      == SCORE_READONLY_SECTION)
		    /* We need it to tell the dynamic linker if there
		       are relocations against the text segment.  */
		    hscore->readonly_reloc = TRUE;
		}
d2960 1
a2960 1
	      /* Even though we don't directly need a GOT entry for this symbol,
d2963 12
a2974 12
	      if (h != NULL)
		{
		  if (dynobj == NULL)
		    elf_hash_table (info)->dynobj = dynobj = abfd;
		  if (! score_elf_create_got_section (dynobj, info, TRUE))
		    return FALSE;
		  g = score_elf_got_info (dynobj, &sgot);
		  if (! score_elf_record_global_got_symbol (h, abfd, info, g))
		    return FALSE;
		}
	    }
	  break;
d2986 1
a2986 3
          BFD_ASSERT (h != NULL);
          if (h != NULL
              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d2996 13
a3008 13
	{
	default:
	  if (h != NULL)
	    {
	      struct score_elf_link_hash_entry *sh;

	      sh = (struct score_elf_link_hash_entry *) h;
	      sh->no_fn_stub = TRUE;
	    }
	  break;
	case R_SCORE_CALL15:
	  break;
	}
d3015 7
a3021 7
_bfd_score_elf_add_symbol_hook (bfd *abfd,
				struct bfd_link_info *info ATTRIBUTE_UNUSED,
				Elf_Internal_Sym *sym,
				const char **namep ATTRIBUTE_UNUSED,
				flagword *flagsp ATTRIBUTE_UNUSED,
				asection **secp,
				bfd_vma *valp)
d3040 1
a3040 1
_bfd_score_elf_symbol_processing (bfd *abfd, asymbol *asym)
d3072 5
a3076 5
_bfd_score_elf_link_output_symbol_hook (struct bfd_link_info *info ATTRIBUTE_UNUSED,
     const char *name ATTRIBUTE_UNUSED,
     Elf_Internal_Sym *sym,
     asection *input_sec,
     struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
d3088 3
a3090 3
_bfd_score_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
					 asection *sec,
					 int *retval)
a3104 1

d3106 2
a3107 2
_bfd_score_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
				      struct elf_link_hash_entry *h)
a3192 1

d3194 2
a3195 2
_bfd_score_elf_always_size_sections (bfd *output_bfd,
				     struct bfd_link_info *info)
d3221 8
a3228 8
	   subsection;
	   subsection = subsection->next)
	{
	  if ((subsection->flags & SEC_ALLOC) == 0)
	    continue;
	  loadable_size += ((subsection->size + 0xf)
			    &~ (bfd_size_type) 0xf);
	}
a3269 1

d3271 1
a3271 1
_bfd_score_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
d3348 4
a3351 4
	  /* _bfd_score_elf_always_size_sections() has already done
	     most of the work, but some symbols may have been mapped
	     to versions that we must now resolve in the got_entries
	     hash tables.  */
d3377 4
a3380 4
	 values later, in _bfd_score_elf_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
d3383 1
a3383 1
	return FALSE;
d3386 1
a3386 1
	info->flags |= DF_TEXTREL;
d3389 4
a3392 4
	{
	  if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_TEXTREL, 0))
	    return FALSE;
	}
d3395 1
a3395 1
	return FALSE;
d3398 10
a3407 10
	{
	  if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_REL, 0))
	    return FALSE;

	  if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELSZ, 0))
	    return FALSE;

	  if (!SCORE_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELENT, 0))
	    return FALSE;
	}
d3425 1
a3425 1
	return FALSE;
d3432 1
a3432 1
_bfd_score_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d3476 1
a3476 1
             (bfd_vma) 0, (const char *)NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
a3493 1

d3495 4
a3498 4
_bfd_score_elf_finish_dynamic_symbol (bfd *output_bfd,
				      struct bfd_link_info *info,
				      struct elf_link_hash_entry *h,
				      Elf_Internal_Sym *sym)
d3520 1
a3520 1
	return FALSE;
d3523 4
a3526 4
      bfd_put_32 (output_bfd, STUB_LW, stub);
      bfd_put_32 (output_bfd, STUB_MOVE, stub + 4);
      bfd_put_32 (output_bfd, STUB_LI16 | (h->dynindx << 1), stub + 8);
      bfd_put_32 (output_bfd, STUB_BRL, stub + 12);
d3532 1
a3532 1
	 only for the referenced symbol.  */
d3536 2
a3537 2
	  to reset the global offset table entry for this external
	  to its stub address when unlinking a shared object.  */
d3558 1
a3558 1
      bfd_put_32 (output_bfd, value, sgot->contents + offset);
a3581 1

d3583 2
a3584 2
_bfd_score_elf_finish_dynamic_sections (bfd *output_bfd,
				        struct bfd_link_info *info)
d3614 82
a3695 82
	   b < sdyn->contents + sdyn->size;
	   b += SCORE_ELF_DYN_SIZE (dynobj))
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  size_t elemsize;
	  bfd_boolean swap_out_p;

	  /* Read in the current dynamic entry.  */
	  (*get_elf_backend_data (dynobj)->s->swap_dyn_in) (dynobj, b, &dyn);

	  /* Assume that we're going to modify it and write it out.  */
	  swap_out_p = TRUE;

	  switch (dyn.d_tag)
	    {
	    case DT_RELENT:
	      s = score_elf_rel_dyn_section (dynobj, FALSE);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = SCORE_ELF_REL_SIZE (dynobj);
	      break;

	    case DT_STRSZ:
	      /* Rewrite DT_STRSZ.  */
	      dyn.d_un.d_val = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
		    break;

	    case DT_PLTGOT:
	      name = ".got";
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    case DT_SCORE_BASE_ADDRESS:
	      s = output_bfd->sections;
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma & ~(bfd_vma) 0xffff;
	      break;

	    case DT_SCORE_LOCAL_GOTNO:
	      dyn.d_un.d_val = g->local_gotno;
	      break;

	    case DT_SCORE_UNREFEXTNO:
	      /* The index into the dynamic symbol table which is the
		 entry of the first external symbol that is not
		 referenced within the same object.  */
	      dyn.d_un.d_val = bfd_count_sections (output_bfd) + 1;
	      break;

	    case DT_SCORE_GOTSYM:
	      if (g->global_gotsym)
		{
		  dyn.d_un.d_val = g->global_gotsym->dynindx;
		  break;
		}
	      /* In case if we don't have global got symbols we default
		  to setting DT_SCORE_GOTSYM to the same value as
		  DT_SCORE_SYMTABNO, so we just fall through.  */

	    case DT_SCORE_SYMTABNO:
	      name = ".dynsym";
	      elemsize = SCORE_ELF_SYM_SIZE (output_bfd);
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);

	      dyn.d_un.d_val = s->size / elemsize;
	      break;

	    case DT_SCORE_HIPAGENO:
	      dyn.d_un.d_val = g->local_gotno - SCORE_RESERVED_GOTNO;
	      break;

	    default:
	      swap_out_p = FALSE;
	      break;
	    }

	  if (swap_out_p)
	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out) (dynobj, &dyn, b);
	}
d3703 2
a3704 2
      bfd_put_32 (output_bfd, 0, sgot->contents);
      bfd_put_32 (output_bfd, 0x80000000, sgot->contents + SCORE_ELF_GOT_SIZE (output_bfd));
d3719 1
a3719 1
	     sizeof (Elf32_External_Rel), score_elf_sort_dynamic_relocs);
a3726 1

d3728 3
a3730 3
_bfd_score_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
			      Elf_Internal_Shdr *hdr,
			      asection *sec)
a3751 1

d3753 1
a3753 1
_bfd_score_elf_section_processing (bfd *abfd ATTRIBUTE_UNUSED, Elf_Internal_Shdr *hdr)
d3760 4
a3763 4
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_SCORE_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
d3765 4
a3768 4
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_SCORE_GPREL;
	  hdr->sh_type = SHT_NOBITS;
	}
d3770 4
a3773 4
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_SCORE_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
d3780 1
a3780 3
_bfd_score_elf_write_section (bfd *output_bfd,
			      struct bfd_link_info *link_info ATTRIBUTE_UNUSED,
                              asection *sec, bfd_byte *contents)
a3810 1

d3812 3
a3814 3
_bfd_score_elf_copy_indirect_symbol (struct bfd_link_info *info,
				     struct elf_link_hash_entry *dir,
				     struct elf_link_hash_entry *ind)
a3834 1

d3836 2
a3837 2
_bfd_score_elf_discard_info (bfd *abfd, struct elf_reloc_cookie *cookie,
                         struct bfd_link_info *info)
a3887 1

d3889 1
a3889 1
_bfd_score_elf_ignore_discarded_relocs (asection *sec)
a3897 1

d3899 5
a3903 5
_bfd_score_elf_gc_mark_hook (asection *sec,
			     struct bfd_link_info *info,
			     Elf_Internal_Rela *rel,
			     struct elf_link_hash_entry *h,
			     Elf_Internal_Sym *sym)
d3910 1
a3910 1
	return NULL;
d3919 1
a3919 1
_bfd_score_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d3931 1
a3931 1
      elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d3934 1
a3934 1
      elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
d3948 1
a3948 1
_bfd_score_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
a3976 1

d3978 1
a3978 1
elf32_score_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED, bfd_reloc_code_real_type code)
d3982 1
a3982 1
  for (i = 0; i < NUM_ELEM (elf32_score_reloc_map); i++)
d3991 1
a3991 1
			       const char *r_name)
d3997 1
a3997 1
	    / sizeof (elf32_score_howto_table[0]));
d4000 1
a4000 1
	&& strcasecmp (elf32_score_howto_table[i].name, r_name) == 0)
d4009 1
a4009 1
elf32_score_link_hash_table_create (bfd *abfd)
d4019 1
a4019 1
				      sizeof (struct score_elf_link_hash_entry)))
d4029 1
a4029 1
elf32_score_print_private_bfd_data (bfd *abfd, void * ptr)
d4054 1
a4054 1
elf32_score_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
d4078 4
a4081 4
	  && bfd_get_arch_info (obfd)->the_default)
	{
	  return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
	}
d4097 1
a4097 1
elf32_score_new_section_hook (bfd *abfd, asection *sec)
d4110 357
d4475 1
d4519 1
@


1.12
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@a1103 1
			      asection **local_sections,
d1113 1
a1113 1
  extsymoff = (elf_bad_symtab (input_bfd)) ? 0 : symtab_hdr->sh_info;
a1116 2
  if (elf_bad_symtab (input_bfd) && local_sections[r_symndx] != NULL)
    return TRUE;
a1844 1
	                       asection **local_sections,
d1900 1
a1900 1
  local_p = score_elf_local_relocation_p (input_bfd, rel, local_sections, TRUE);
d2119 1
a2119 2
	  forced = ! score_elf_local_relocation_p (input_bfd, rel,
						   local_sections, FALSE);
d2228 1
a2228 1
  extsymoff = (elf_bad_symtab (input_bfd)) ? 0 : symtab_hdr->sh_info;
d2425 1
a2425 1
					 ELF_ST_TYPE ((unsigned int)sym->st_info)), h, local_sections,
d2505 1
a2505 1
  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;
@


1.11
log
@Switch sources over to use the GPL version 3
@
text
@d2686 3
a2688 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
@


1.10
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.9
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.8
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d3702 17
d3876 2
@


1.7
log
@	* bfd-in2.h: Regenerate.
	* bfd-in.h (bfd_arm_vfp11_fix): New enum. Specify how VFP11
	instruction scanning should be done.
	(bfd_elf32_arm_init_maps, bfd_elf32_arm_vfp11_erratum_scan)
	(bfd_elf32_arm_vfp11_fix_veneer_locations): Add prototypes.
	(bfd_elf32_arm_set_target_relocs): Add vfp11 fix type argument to
	prototype.
	* elf-bfd.h (elf_backend_write_section): Add struct bfd_link_info
	argument.
	* elf32-arm.c (VFP11_ERRATUM_VENEER_SECTION_NAME)
	(VFP11_ERRATUM_VENEER_ENTRY_NAME): Define macros.
	(elf32_vfp11_erratum_type): New enum.
	(elf32_vfp11_erratum_list): New struct. List of veneers or jumps to
	veneers.
	(_arm_elf_section_data): Add mapsize, erratumcount, erratumlist.
	(elf32_arm_link_hash_table): Add vfp11_erratum_glue_size,
	vfp11_fix and num_vfp11_fixes fields.
	(elf32_arm_link_hash_table_create): Initialise vfp11_fix,
	vfp11_erratum_glue_size, num_vfp11_fixes fields.
	(VFP11_ERRATUM_VENEER_SIZE): Define. Size of an (ARM) veneer.
	(bfd_elf32_arm_allocate_interworking_sections): Initialise erratum
	glue section.
	(elf32_arm_section_map_add): Add an code/data mapping symbol entry
	to a section's map.
	(record_vfp11_erratum_veneer): Create a single veneer, and its
	associated symbols.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Add vfp11 erratum glue.
	(bfd_elf32_arm_init_maps): Initialise mapping symbol table for input
	BFDs.
	(bfd_elf32_arm_set_vfp11_fix): Set the type of erratum workaround
	required.
	(bfd_arm_vfp11_pipe): Define VFP11 instruction pipes.
	(bfd_arm_vfp11_regno): Recode a register number from a VFP11 insn.
	(bfd_arm_vfp11_write_mask): Update write mask according to coded
	register number.
	(bfd_arm_vfp11_antidependency): New function.
	(bfd_arm_vfp11_insn_decode): Decode a VFP11 insn.
	(elf32_arm_compare_mapping): Declare.
	(bfd_elf32_arm_vfp11_erratum_scan): Scan the sections of an input
	BFD for potential erratum-triggering insns. Record results.
	(bfd_elf32_arm_vfp11_fix_veneer_locations): Find out where veneers
	and branches to veneers have been placed in virtual memory after
	layout.
	(bfd_elf32_arm_set_target_relocs): Set vfp11_fix field in global
	hash table.
	(elf32_arm_output_symbol_hook): Remove.
	(elf32_arm_write_section): Output veneers, and branches to veneers.
	Use maps from input sections, not output sections, for code
	byte-swapping.
	* elf32-ppc.c (ppc_elf_write_section): Add dummy link_info argument.
	* elf32-score.c (_bfd_score_elf_write_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_write_section): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_write_section): Likewise.
@
text
@d2 1
a2 1
   Copyright 2006 Free Software Foundation, Inc.
a2008 5
      else if (r_symndx == 0)
        /* r_symndx will be zero only for relocs against symbols
           from removed linkonce sections, or sections discarded by
           a linker script.  */
        value = 0;
a2210 5
#ifndef USE_REL
  if (info->relocatable)
    return TRUE;
#endif

a2253 20
      if (info->relocatable)
        {
          /* This is a relocatable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
          if (r_symndx < symtab_hdr->sh_info)
            {
              sym = local_syms + r_symndx;
              if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
                {
                  sec = local_sections[r_symndx];
                  score_elf_add_to_rel (input_bfd, contents + rel->r_offset,
                                    howto, (bfd_signed_vma) (sec->output_offset + sym->st_value));
                }
            }
          continue;
        }

      /* This is a final link.  */
d2267 2
a2268 1
          if ((sec->flags & SEC_MERGE)
d2390 1
a2390 1
	  else
d2402 23
@


1.6
log
@	* elf32-score.c (score_elf_got_lo16_reloc): Change some variables type from
	unsigned to signed.
	(score_elf_final_link_relocate): Fix bugs of handling relocation type R_SCORE_GOT15,
	R_SCORE_GOT_LO16, and R_SCORE_REL32.
	(_bfd_score_elf_relocate_section): Handle R_SCORE_GOT_LO16 specially.
@
text
@d3492 3
a3494 1
_bfd_score_elf_write_section (bfd *output_bfd, asection *sec, bfd_byte *contents)
@


1.5
log
@	* elf32-score.c: Formatting.
	(elf_backend_omit_section_dynsym): Define.
	(score_elf_create_dynamic_relocation): Remove code copied from mips.
	Don't use section syms in dynamic relocs.  Remove unused param.
	(score_elf_final_link_relocate): Remove unused param.
@
text
@d535 2
a536 2
  unsigned long val;
  unsigned long hi16_offset, hi16_value, uvalue;
d546 4
a549 1
  hi16_offset = (uvalue >> 16) & 0x7fff;
d1903 1
a1911 2
      addend = (bfd_get_32 (input_bfd, hit_data) >> howto->bitpos) & howto->src_mask;

d1915 1
a1915 1
      if (lo16_rel != NULL)
d1917 3
a1919 2
          lo_value = (bfd_get_32 (input_bfd, contents + lo16_rel->r_offset) >> howto->bitpos)
                      & howto->src_mask;
d1921 1
a1921 1
      addend = (addend << 16) + lo_value;
a1927 2
  local_p = score_elf_local_relocation_p (input_bfd, rel, local_sections, TRUE);

d1936 15
a1950 3
	  g = score_elf_global_got_index (elf_hash_table (info)->dynobj,
				          (struct elf_link_hash_entry *) h);
	}
d2009 5
d2143 4
a2146 1
      bfd_put_16 (input_bfd, value, hit_data + 2);
d2157 1
a2157 1
      value = ((((addend >> 16) & 0x3) << 15) | (addend & 0x7fff)) >> 1;
d2159 2
a2160 2
      offset = (value & 0xffff) << 1;
      value = (addend & (~(howto->dst_mask))) | (offset & 0x7fff) | ((offset << 1) & 0x30000);
d2327 11
@


1.4
log
@Fix score bugs
@
text
@d1186 1
a1186 1
				     asection *sec, bfd_vma symbol,
d1240 1
a1240 29
      if (sec != NULL && bfd_is_abs_section (sec))
	indx = 0;
      else if (sec == NULL || sec->owner == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      else
	{
	  indx = elf_section_data (sec->output_section)->dynindx;
	  if (indx == 0)
	    abort ();
	}

      /* Instead of generating a relocation using the section
	 symbol, we may as well make it a fully relative
	 relocation.  We want to avoid generating relocations to
	 local symbols because we used to generate them
	 incorrectly, without adding the original symbol value,
	 which is mandated by the ABI for section symbols.  In
	 order to give dynamic loaders and applications time to
	 phase out the incorrect use, we refrain from emitting
	 section-relative relocations.  It's not like they're
	 useful, after all.  This should be a bit more efficient
	 as well.  */
      /* ??? Although this behavior is compatible with glibc's ld.so,
	 the ABI says that relocations against STN_UNDEF should have
	 a symbol value of 0.  Irix rld honors this, so relocations
	 against STN_UNDEF have no effect.  */
a1840 1
			       asection *sym_sec,
d1992 1
a1992 1
						    sym_sec, symbol, &value,
d2401 1
a2401 1
                                         relocation, info, sec, name,
d3788 47
a3834 36
#define elf_info_to_howto                             0
#define elf_info_to_howto_rel                         _bfd_score_info_to_howto
#define elf_backend_relocate_section                  _bfd_score_elf_relocate_section
#define elf_backend_check_relocs                      _bfd_score_elf_check_relocs
#define elf_backend_add_symbol_hook                   _bfd_score_elf_add_symbol_hook
#define elf_backend_symbol_processing                 _bfd_score_elf_symbol_processing
#define elf_backend_link_output_symbol_hook           _bfd_score_elf_link_output_symbol_hook
#define elf_backend_section_from_bfd_section          _bfd_score_elf_section_from_bfd_section
#define elf_backend_adjust_dynamic_symbol             _bfd_score_elf_adjust_dynamic_symbol
#define elf_backend_always_size_sections              _bfd_score_elf_always_size_sections
#define elf_backend_size_dynamic_sections             _bfd_score_elf_size_dynamic_sections
#define elf_backend_create_dynamic_sections           _bfd_score_elf_create_dynamic_sections
#define elf_backend_finish_dynamic_symbol             _bfd_score_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections           _bfd_score_elf_finish_dynamic_sections
#define elf_backend_fake_sections                     _bfd_score_elf_fake_sections
#define elf_backend_section_processing                _bfd_score_elf_section_processing
#define elf_backend_write_section                     _bfd_score_elf_write_section
#define elf_backend_copy_indirect_symbol              _bfd_score_elf_copy_indirect_symbol
#define elf_backend_hide_symbol                       _bfd_score_elf_hide_symbol
#define elf_backend_discard_info                      _bfd_score_elf_discard_info
#define elf_backend_ignore_discarded_relocs           _bfd_score_elf_ignore_discarded_relocs
#define elf_backend_gc_mark_hook                      _bfd_score_elf_gc_mark_hook
#define elf_backend_grok_prstatus                     _bfd_score_elf_grok_prstatus
#define elf_backend_grok_psinfo                       _bfd_score_elf_grok_psinfo
#define elf_backend_can_gc_sections                   1
#define elf_backend_want_plt_sym                      0
#define elf_backend_got_header_size                   (4 * SCORE_RESERVED_GOTNO)
#define elf_backend_plt_header_size                   0
#define elf_backend_collect                           TRUE
#define elf_backend_type_change_ok                    TRUE

#define bfd_elf32_bfd_reloc_type_lookup               elf32_score_reloc_type_lookup
#define bfd_elf32_bfd_link_hash_table_create          elf32_score_link_hash_table_create
#define bfd_elf32_bfd_print_private_bfd_data          elf32_score_print_private_bfd_data
#define bfd_elf32_bfd_merge_private_bfd_data          elf32_score_merge_private_bfd_data
#define bfd_elf32_new_section_hook                    elf32_score_new_section_hook
@


1.3
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d1144 7
a1150 1
      sreloc = bfd_make_section (dynobj, dname);
d1152 2
a1153 8
	  || ! bfd_set_section_flags (dynobj, sreloc,
				      (SEC_ALLOC
				       | SEC_LOAD
				       | SEC_HAS_CONTENTS
				       | SEC_IN_MEMORY
				       | SEC_LINKER_CREATED
				       | SEC_READONLY))
	  || ! bfd_set_section_alignment (dynobj, sreloc, SCORE_ELF_LOG_FILE_ALIGN (dynobj)))
d1156 1
a1156 2

  return sreloc;
d1352 2
a1353 3
  s = bfd_make_section (abfd, ".got");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags)
a1929 9
  /* If the start address has been set, then set the EF_SCORE_HASENTRY
     flag.  Setting this more than once is redundant, but the cost is
     not too high, and it keeps the code simple.
     The test is done  here, rather than somewhere else, because the
     start address is only set just before the final link commences.
     Note - if the user deliberately sets a start address of 0, the flag will not be set.  */
  if (bfd_get_start_address (output_bfd) != 0)
    elf_elfheader (output_bfd)->e_flags |= EF_SCORE_HASENTRY;

d3165 2
a3166 1
      s = bfd_make_section (abfd, SCORE_ELF_STUB_SECTION_NAME);
a3167 1
          || !bfd_set_section_flags (abfd, s, flags | SEC_CODE)
@


1.2
log
@	* elf32-score.c (_bfd_score_elf_relocate_section): Move assignment
	to "name" so that compiler realizes it is never uninitialized.
	Use bfd_elf_sym_name.
@
text
@d3619 2
a3620 2
/* This function discover the section a particular relocation refers to.
   Return the section that should be marked against GC for a given relocation.  */
d3624 1
a3624 1
			     struct bfd_link_info *info ATTRIBUTE_UNUSED,
d3630 6
a3635 21
    {
      switch (ELF32_R_TYPE (rel->r_info))
        {
        case R_SCORE_GNU_VTINHERIT:
        case R_SCORE_GNU_VTENTRY:
          break;
        default:
          switch (h->root.type)
            {
            case bfd_link_hash_defined:
            case bfd_link_hash_defweak:
              return h->root.u.def.section;
            case bfd_link_hash_common:
              return h->root.u.c.p->section;
            default:
              break;
            }
        }
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d3637 1
a3637 1
  return NULL;
@


1.1
log
@Add support for Score target.
@
text
@d2311 4
a2314 1
          relocation = (sec->output_section->vma + sec->output_offset + sym->st_value);
d2316 2
a2317 1
          if ((sec->flags & SEC_MERGE) && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
a2438 7
      if (h == NULL)
        {
          name = (bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link, sym->st_name));
          if (name == NULL || *name == '\0')
            name = bfd_section_name (input_bfd, sec);
        }

@

