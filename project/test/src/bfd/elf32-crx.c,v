head	1.20;
access;
symbols
	sid-snapshot-20180601:1.20
	sid-snapshot-20180501:1.20
	sid-snapshot-20180401:1.20
	sid-snapshot-20180301:1.20
	sid-snapshot-20180201:1.20
	sid-snapshot-20180101:1.20
	sid-snapshot-20171201:1.20
	sid-snapshot-20171101:1.20
	sid-snapshot-20171001:1.20
	sid-snapshot-20170901:1.20
	sid-snapshot-20170801:1.20
	sid-snapshot-20170701:1.20
	sid-snapshot-20170601:1.20
	sid-snapshot-20170501:1.20
	sid-snapshot-20170401:1.20
	sid-snapshot-20170301:1.20
	sid-snapshot-20170201:1.20
	sid-snapshot-20170101:1.20
	sid-snapshot-20161201:1.20
	sid-snapshot-20161101:1.20
	sid-snapshot-20160901:1.20
	sid-snapshot-20160801:1.20
	sid-snapshot-20160701:1.20
	sid-snapshot-20160601:1.20
	sid-snapshot-20160501:1.20
	sid-snapshot-20160401:1.20
	sid-snapshot-20160301:1.20
	sid-snapshot-20160201:1.20
	sid-snapshot-20160101:1.20
	sid-snapshot-20151201:1.20
	sid-snapshot-20151101:1.20
	sid-snapshot-20151001:1.20
	sid-snapshot-20150901:1.20
	sid-snapshot-20150801:1.20
	sid-snapshot-20150701:1.20
	sid-snapshot-20150601:1.20
	sid-snapshot-20150501:1.20
	sid-snapshot-20150401:1.20
	sid-snapshot-20150301:1.20
	sid-snapshot-20150201:1.20
	sid-snapshot-20150101:1.20
	sid-snapshot-20141201:1.20
	sid-snapshot-20141101:1.20
	sid-snapshot-20141001:1.20
	sid-snapshot-20140901:1.20
	sid-snapshot-20140801:1.20
	sid-snapshot-20140701:1.20
	sid-snapshot-20140601:1.20
	sid-snapshot-20140501:1.20
	sid-snapshot-20140401:1.20
	sid-snapshot-20140301:1.20
	sid-snapshot-20140201:1.20
	sid-snapshot-20140101:1.20
	sid-snapshot-20131201:1.20
	sid-snapshot-20131101:1.20
	sid-snapshot-20131001:1.20
	binutils-2_24-branch:1.20.0.4
	binutils-2_24-branchpoint:1.20
	binutils-2_21_1:1.16
	sid-snapshot-20130901:1.20
	gdb_7_6_1-2013-08-30-release:1.20
	sid-snapshot-20130801:1.20
	sid-snapshot-20130701:1.20
	sid-snapshot-20130601:1.20
	sid-snapshot-20130501:1.20
	gdb_7_6-2013-04-26-release:1.20
	sid-snapshot-20130401:1.20
	binutils-2_23_2:1.19
	gdb_7_6-branch:1.20.0.2
	gdb_7_6-2013-03-12-branchpoint:1.20
	sid-snapshot-20130301:1.20
	sid-snapshot-20130201:1.20
	sid-snapshot-20130101:1.19
	sid-snapshot-20121201:1.19
	gdb_7_5_1-2012-11-29-release:1.19
	binutils-2_23_1:1.19
	sid-snapshot-20121101:1.19
	binutils-2_23:1.19
	sid-snapshot-20121001:1.19
	sid-snapshot-20120901:1.19
	gdb_7_5-2012-08-17-release:1.19
	sid-snapshot-20120801:1.19
	binutils-2_23-branch:1.19.0.4
	binutils-2_23-branchpoint:1.19
	gdb_7_5-branch:1.19.0.2
	gdb_7_5-2012-07-18-branchpoint:1.19
	sid-snapshot-20120701:1.18
	sid-snapshot-20120601:1.18
	sid-snapshot-20120501:1.17
	binutils-2_22_branch:1.16.0.10
	gdb_7_4_1-2012-04-26-release:1.16
	sid-snapshot-20120401:1.16
	sid-snapshot-20120301:1.16
	sid-snapshot-20120201:1.16
	gdb_7_4-2012-01-24-release:1.16
	sid-snapshot-20120101:1.16
	gdb_7_4-branch:1.16.0.8
	gdb_7_4-2011-12-13-branchpoint:1.16
	sid-snapshot-20111201:1.16
	binutils-2_22:1.16
	sid-snapshot-20111101:1.16
	sid-snapshot-20111001:1.16
	binutils-2_22-branch:1.16.0.6
	binutils-2_22-branchpoint:1.16
	gdb_7_3_1-2011-09-04-release:1.16
	sid-snapshot-20110901:1.16
	sid-snapshot-20110801:1.16
	gdb_7_3-2011-07-26-release:1.16
	sid-snapshot-20110701:1.16
	sid-snapshot-20110601:1.16
	sid-snapshot-20110501:1.16
	gdb_7_3-branch:1.16.0.4
	gdb_7_3-2011-04-01-branchpoint:1.16
	sid-snapshot-20110401:1.16
	sid-snapshot-20110301:1.16
	sid-snapshot-20110201:1.16
	sid-snapshot-20110101:1.16
	binutils-2_21:1.16
	sid-snapshot-20101201:1.16
	binutils-2_21-branch:1.16.0.2
	binutils-2_21-branchpoint:1.16
	sid-snapshot-20101101:1.16
	sid-snapshot-20101001:1.15
	binutils-2_20_1:1.14
	gdb_7_2-2010-09-02-release:1.15
	sid-snapshot-20100901:1.15
	sid-snapshot-20100801:1.15
	gdb_7_2-branch:1.15.0.2
	gdb_7_2-2010-07-07-branchpoint:1.15
	sid-snapshot-20100701:1.15
	sid-snapshot-20100601:1.14
	sid-snapshot-20100501:1.14
	sid-snapshot-20100401:1.14
	gdb_7_1-2010-03-18-release:1.14
	sid-snapshot-20100301:1.14
	gdb_7_1-branch:1.14.0.6
	gdb_7_1-2010-02-18-branchpoint:1.14
	sid-snapshot-20100201:1.14
	sid-snapshot-20100101:1.14
	gdb_7_0_1-2009-12-22-release:1.14
	sid-snapshot-20091201:1.14
	sid-snapshot-20091101:1.14
	binutils-2_20:1.14
	gdb_7_0-2009-10-06-release:1.14
	sid-snapshot-20091001:1.14
	gdb_7_0-branch:1.14.0.4
	gdb_7_0-2009-09-16-branchpoint:1.14
	arc-sim-20090309:1.12
	binutils-arc-20081103-branch:1.12.0.26
	binutils-arc-20081103-branchpoint:1.12
	binutils-2_20-branch:1.14.0.2
	binutils-2_20-branchpoint:1.14
	sid-snapshot-20090901:1.13
	sid-snapshot-20090801:1.13
	msnyder-checkpoint-072509-branch:1.13.0.4
	msnyder-checkpoint-072509-branchpoint:1.13
	sid-snapshot-20090701:1.13
	dje-cgen-play1-branch:1.13.0.2
	dje-cgen-play1-branchpoint:1.13
	sid-snapshot-20090601:1.13
	sid-snapshot-20090501:1.13
	sid-snapshot-20090401:1.13
	arc-20081103-branch:1.12.0.24
	arc-20081103-branchpoint:1.12
	arc-insight_6_8-branch:1.12.0.22
	arc-insight_6_8-branchpoint:1.12
	insight_6_8-branch:1.12.0.20
	insight_6_8-branchpoint:1.12
	sid-snapshot-20090301:1.12
	binutils-2_19_1:1.12
	sid-snapshot-20090201:1.12
	sid-snapshot-20090101:1.12
	reverse-20081226-branch:1.12.0.18
	reverse-20081226-branchpoint:1.12
	sid-snapshot-20081201:1.12
	multiprocess-20081120-branch:1.12.0.16
	multiprocess-20081120-branchpoint:1.12
	sid-snapshot-20081101:1.12
	binutils-2_19:1.12
	sid-snapshot-20081001:1.12
	reverse-20080930-branch:1.12.0.14
	reverse-20080930-branchpoint:1.12
	binutils-2_19-branch:1.12.0.12
	binutils-2_19-branchpoint:1.12
	sid-snapshot-20080901:1.12
	sid-snapshot-20080801:1.12
	reverse-20080717-branch:1.12.0.10
	reverse-20080717-branchpoint:1.12
	sid-snapshot-20080701:1.12
	msnyder-reverse-20080609-branch:1.12.0.8
	msnyder-reverse-20080609-branchpoint:1.12
	drow-reverse-20070409-branch:1.10.0.2
	drow-reverse-20070409-branchpoint:1.10
	sid-snapshot-20080601:1.12
	sid-snapshot-20080501:1.12
	sid-snapshot-20080403:1.12
	sid-snapshot-20080401:1.12
	gdb_6_8-2008-03-27-release:1.12
	sid-snapshot-20080301:1.12
	gdb_6_8-branch:1.12.0.6
	gdb_6_8-2008-02-26-branchpoint:1.12
	sid-snapshot-20080201:1.12
	sid-snapshot-20080101:1.12
	sid-snapshot-20071201:1.12
	sid-snapshot-20071101:1.12
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	sid-snapshot-20071001:1.12
	gdb_6_7-branch:1.12.0.4
	gdb_6_7-2007-09-07-branchpoint:1.12
	binutils-2_18:1.12
	binutils-2_18-branch:1.12.0.2
	binutils-2_18-branchpoint:1.12
	insight_6_6-20070208-release:1.8
	binutils-csl-coldfire-4_1-32:1.7
	binutils-csl-sourcerygxx-4_1-32:1.7
	gdb_6_6-2006-12-18-release:1.8
	binutils-csl-innovasic-fido-3_4_4-33:1.7
	binutils-csl-sourcerygxx-3_4_4-32:1.5
	binutils-csl-coldfire-4_1-30:1.7
	binutils-csl-sourcerygxx-4_1-30:1.7
	binutils-csl-coldfire-4_1-28:1.7
	binutils-csl-sourcerygxx-4_1-29:1.7
	binutils-csl-sourcerygxx-4_1-28:1.7
	gdb_6_6-branch:1.8.0.2
	gdb_6_6-2006-11-15-branchpoint:1.8
	binutils-csl-arm-2006q3-27:1.7
	binutils-csl-sourcerygxx-4_1-27:1.7
	binutils-csl-arm-2006q3-26:1.7
	binutils-csl-sourcerygxx-4_1-26:1.7
	binutils-csl-sourcerygxx-4_1-25:1.7
	binutils-csl-sourcerygxx-4_1-24:1.7
	binutils-csl-sourcerygxx-4_1-23:1.7
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.7
	binutils-csl-sourcerygxx-4_1-21:1.7
	binutils-csl-arm-2006q3-21:1.7
	binutils-csl-sourcerygxx-4_1-22:1.7
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.7
	binutils-csl-sourcerygxx-4_1-20:1.7
	binutils-csl-arm-2006q3-19:1.7
	binutils-csl-sourcerygxx-4_1-19:1.7
	binutils-csl-sourcerygxx-4_1-18:1.7
	binutils-csl-renesas-4_1-9:1.7
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	binutils-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.7
	binutils-csl-renesas-4_1-8:1.7
	binutils-csl-renesas-4_1-7:1.7
	binutils-csl-renesas-4_1-6:1.7
	gdb-csl-sourcerygxx-4_1-17:1.7
	binutils-csl-sourcerygxx-4_1-17:1.7
	gdb-csl-20060226-branch-local-2:1.7
	gdb-csl-sourcerygxx-4_1-14:1.7
	binutils-csl-sourcerygxx-4_1-14:1.7
	binutils-csl-sourcerygxx-4_1-15:1.7
	gdb-csl-sourcerygxx-4_1-13:1.7
	binutils-csl-sourcerygxx-4_1-13:1.7
	binutils-2_17:1.7
	gdb-csl-sourcerygxx-4_1-12:1.7
	binutils-csl-sourcerygxx-4_1-12:1.7
	gdb-csl-sourcerygxx-3_4_4-21:1.7
	binutils-csl-sourcerygxx-3_4_4-21:1.7
	gdb_6_5-20060621-release:1.7
	binutils-csl-wrs-linux-3_4_4-24:1.5
	binutils-csl-wrs-linux-3_4_4-23:1.5
	gdb-csl-sourcerygxx-4_1-9:1.7
	binutils-csl-sourcerygxx-4_1-9:1.7
	gdb-csl-sourcerygxx-4_1-8:1.7
	binutils-csl-sourcerygxx-4_1-8:1.7
	gdb-csl-sourcerygxx-4_1-7:1.7
	binutils-csl-sourcerygxx-4_1-7:1.7
	gdb-csl-arm-2006q1-6:1.7
	binutils-csl-arm-2006q1-6:1.7
	gdb-csl-sourcerygxx-4_1-6:1.7
	binutils-csl-sourcerygxx-4_1-6:1.7
	binutils-csl-wrs-linux-3_4_4-22:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.7
	gdb-csl-symbian-6_4_50_20060226-9:1.7
	gdb-csl-symbian-6_4_50_20060226-8:1.7
	gdb-csl-coldfire-4_1-11:1.7
	binutils-csl-coldfire-4_1-11:1.7
	gdb-csl-sourcerygxx-3_4_4-19:1.7
	binutils-csl-sourcerygxx-3_4_4-19:1.7
	gdb-csl-coldfire-4_1-10:1.7
	gdb_6_5-branch:1.7.0.30
	gdb_6_5-2006-05-14-branchpoint:1.7
	binutils-csl-coldfire-4_1-10:1.7
	gdb-csl-sourcerygxx-4_1-5:1.7
	binutils-csl-sourcerygxx-4_1-5:1.7
	nickrob-async-20060513-branch:1.7.0.28
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.7
	binutils-csl-sourcerygxx-4_1-4:1.7
	msnyder-reverse-20060502-branch:1.7.0.26
	msnyder-reverse-20060502-branchpoint:1.7
	binutils-csl-wrs-linux-3_4_4-21:1.5
	gdb-csl-morpho-4_1-4:1.7
	binutils-csl-morpho-4_1-4:1.7
	gdb-csl-sourcerygxx-3_4_4-17:1.7
	binutils-csl-sourcerygxx-3_4_4-17:1.7
	binutils-csl-wrs-linux-3_4_4-20:1.5
	readline_5_1-import-branch:1.7.0.24
	readline_5_1-import-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7
	binutils-2_17-branch:1.7.0.22
	binutils-2_17-branchpoint:1.7
	gdb-csl-symbian-20060226-branch:1.7.0.20
	gdb-csl-symbian-20060226-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7
	msnyder-reverse-20060331-branch:1.7.0.18
	msnyder-reverse-20060331-branchpoint:1.7
	binutils-csl-2_17-branch:1.7.0.16
	binutils-csl-2_17-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.14
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.12
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.10
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.6
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.4
	gdb-csl-arm-20051020-branchpoint:1.7
	binutils-csl-gxxpro-3_4-branch:1.5.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.5
	binutils-2_16_1:1.5
	msnyder-tracepoint-checkpoint-branch:1.7.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.5
	binutils-csl-arm-2005q1b:1.5
	binutils-2_16:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	binutils-csl-arm-2005q1a:1.5
	csl-arm-20050325-branch:1.5.0.6
	csl-arm-20050325-branchpoint:1.5
	binutils-csl-arm-2005q1-branch:1.5.0.4
	binutils-csl-arm-2005q1-branchpoint:1.5
	binutils-2_16-branch:1.5.0.2
	binutils-2_16-branchpoint:1.5
	csl-arm-2004-q3d:1.3
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.4
	gdb_6_3-20041019-branchpoint:1.2
	csl-arm-2004-q3:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-20040221-branch:1.2.0.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.1.0.6
	jimb-gdb_6_2-e500-branchpoint:1.1
	gdb_6_2-20040730-release:1.1
	gdb_6_2-branch:1.1.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1
	binutils_latest_snapshot:1.20;
locks; strict;
comment	@ * @;


1.20
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2012.07.13.14.22.46;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2012.05.07.03.27.49;	author macro;	state Exp;
branches;
next	1.17;

1.17
date	2012.04.24.05.12.33;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.25.15.54.13;	author drow;	state Exp;
branches
	1.16.6.1;
next	1.15;

1.15
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.25.08.05.57;	author swami;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.04.15.53.12;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.04.07.19.22;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.23.13.47.31;	author tomerl;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.14.15.36.23;	author tomerl;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.21.15.28.20;	author hjl;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.27.11.37.06;	author nickc;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.07.07.17.28.46;	author nickc;	state Exp;
branches;
next	;

1.16.6.1
date	2012.05.11.12.24.23;	author nickc;	state Exp;
branches;
next	;

1.2.2.1
date	2004.09.16.17.00.22;	author drow;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* BFD back-end for National Semiconductor's CRX ELF
   Copyright 2004, 2005, 2006, 2007, 2009, 2010, 2012
   Free Software Foundation, Inc.
   Written by Tomer Levi, NSC, Israel.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/crx.h"

static reloc_howto_type *elf_crx_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type);
static void elf_crx_info_to_howto
  (bfd *, arelent *, Elf_Internal_Rela *);
static bfd_boolean elf32_crx_relax_delete_bytes
  (struct bfd_link_info *, bfd *, asection *, bfd_vma, int);
static bfd_reloc_status_type crx_elf_final_link_relocate
  (reloc_howto_type *, bfd *, bfd *, asection *,
   bfd_byte *, bfd_vma, bfd_vma, bfd_vma,
   struct bfd_link_info *, asection *, int);
static bfd_boolean elf32_crx_relocate_section
  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
static bfd_boolean elf32_crx_relax_section
  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
static bfd_byte * elf32_crx_get_relocated_section_contents
  (bfd *, struct bfd_link_info *, struct bfd_link_order *,
   bfd_byte *, bfd_boolean, asymbol **);

/* crx_reloc_map array maps BFD relocation enum into a CRGAS relocation type.  */

struct crx_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_enum; /* BFD relocation enum.  */
  unsigned short crx_reloc_type;	   /* CRX relocation type.  */
};

static const struct crx_reloc_map crx_reloc_map[R_CRX_MAX] =
{
  {BFD_RELOC_NONE,	    R_CRX_NONE},
  {BFD_RELOC_CRX_REL4,	    R_CRX_REL4},
  {BFD_RELOC_CRX_REL8,	    R_CRX_REL8},
  {BFD_RELOC_CRX_REL8_CMP,  R_CRX_REL8_CMP},
  {BFD_RELOC_CRX_REL16,	    R_CRX_REL16},
  {BFD_RELOC_CRX_REL24,	    R_CRX_REL24},
  {BFD_RELOC_CRX_REL32,	    R_CRX_REL32},
  {BFD_RELOC_CRX_REGREL12,  R_CRX_REGREL12},
  {BFD_RELOC_CRX_REGREL22,  R_CRX_REGREL22},
  {BFD_RELOC_CRX_REGREL28,  R_CRX_REGREL28},
  {BFD_RELOC_CRX_REGREL32,  R_CRX_REGREL32},
  {BFD_RELOC_CRX_ABS16,	    R_CRX_ABS16},
  {BFD_RELOC_CRX_ABS32,	    R_CRX_ABS32},
  {BFD_RELOC_CRX_NUM8,	    R_CRX_NUM8},
  {BFD_RELOC_CRX_NUM16,	    R_CRX_NUM16},
  {BFD_RELOC_CRX_NUM32,	    R_CRX_NUM32},
  {BFD_RELOC_CRX_IMM16,	    R_CRX_IMM16},
  {BFD_RELOC_CRX_IMM32,	    R_CRX_IMM32},
  {BFD_RELOC_CRX_SWITCH8,   R_CRX_SWITCH8},
  {BFD_RELOC_CRX_SWITCH16,  R_CRX_SWITCH16},
  {BFD_RELOC_CRX_SWITCH32,  R_CRX_SWITCH32}
};

static reloc_howto_type crx_elf_howto_table[] =
{
  HOWTO (R_CRX_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_REL4,		/* type */
	 1,			/* rightshift */
	 0,			/* size */
	 4,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_REL4",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xf,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_REL8,		/* type */
	 1,			/* rightshift */
	 0,			/* size */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_REL8",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_REL8_CMP,	/* type */
	 1,			/* rightshift */
	 0,			/* size */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_REL8_CMP",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_REL16,		/* type */
	 1,			/* rightshift */
	 1,			/* size */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_REL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_REL24,		/* type */
	 1,			/* rightshift */
	 2,			/* size */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_REL24",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_REL32,		/* type */
	 1,			/* rightshift */
	 2,			/* size */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_REL32",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_REGREL12,	/* type */
	 0,			/* rightshift */
	 1,			/* size */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_REGREL12",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xfff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_REGREL22,	/* type */
	 0,			/* rightshift */
	 2,			/* size */
	 22,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_REGREL22",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0x3fffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_REGREL28,	/* type */
	 0,			/* rightshift */
	 2,			/* size */
	 28,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_REGREL28",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xfffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_REGREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_REGREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_ABS16,		/* type */
	 0,			/* rightshift */
	 1,			/* size */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_ABS16",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_ABS32,		/* type */
	 0,			/* rightshift */
	 2,			/* size */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_ABS32",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_NUM8,		/* type */
	 0,			/* rightshift */
	 0,			/* size */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_NUM8",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,	  		/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_NUM16,		/* type */
	 0,			/* rightshift */
	 1,			/* size */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_NUM16",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,	  		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_NUM32,		/* type */
	 0,			/* rightshift */
	 2,			/* size */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_NUM32",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,	  		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_IMM16,		/* type */
	 0,			/* rightshift */
	 1,			/* size */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_IMM16",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0, 	 		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_CRX_IMM32,		/* type */
	 0,			/* rightshift */
	 2,			/* size */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_IMM32",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,  			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An 8 bit switch table entry.  This is generated for an expression
     such as ``.byte L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_CRX_SWITCH8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_SWITCH8",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 16 bit switch table entry.  This is generated for an expression
     such as ``.word L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_CRX_SWITCH16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_SWITCH16",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 32 bit switch table entry.  This is generated for an expression
     such as ``.long L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_CRX_SWITCH32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_CRX_SWITCH32",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE)			/* pcrel_offset */
};

/* Retrieve a howto ptr using a BFD reloc_code.  */

static reloc_howto_type *
elf_crx_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			   bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = 0; i < R_CRX_MAX; i++)
    if (code == crx_reloc_map[i].bfd_reloc_enum)
      return &crx_elf_howto_table[crx_reloc_map[i].crx_reloc_type];

  printf ("This relocation Type is not supported -0x%x\n", code);
  return 0;
}

static reloc_howto_type *
elf_crx_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			   const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (crx_elf_howto_table) / sizeof (crx_elf_howto_table[0]);
       i++)
    if (crx_elf_howto_table[i].name != NULL
	&& strcasecmp (crx_elf_howto_table[i].name, r_name) == 0)
      return &crx_elf_howto_table[i];

  return NULL;
}

/* Retrieve a howto ptr using an internal relocation entry.  */

static void
elf_crx_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
		       Elf_Internal_Rela *dst)
{
  unsigned int r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_CRX_MAX);
  cache_ptr->howto = &crx_elf_howto_table[r_type];
}

/* Perform a relocation as part of a final link.  */

static bfd_reloc_status_type
crx_elf_final_link_relocate (reloc_howto_type *howto, bfd *input_bfd,
			     bfd *output_bfd ATTRIBUTE_UNUSED,
			     asection *input_section, bfd_byte *contents,
			     bfd_vma offset, bfd_vma Rvalue, bfd_vma addend,
			     struct bfd_link_info *info ATTRIBUTE_UNUSED,
			     asection *sec ATTRIBUTE_UNUSED,
			     int is_local ATTRIBUTE_UNUSED)
{
  unsigned short r_type = howto->type;
  bfd_byte *hit_data = contents + offset;
  bfd_vma reloc_bits, check;

  switch (r_type)
    {
     case R_CRX_IMM16:
     case R_CRX_IMM32:
     case R_CRX_ABS16:
     case R_CRX_ABS32:
     case R_CRX_REL8_CMP:
     case R_CRX_REL16:
     case R_CRX_REL24:
     case R_CRX_REL32:
     case R_CRX_REGREL12:
     case R_CRX_REGREL22:
     case R_CRX_REGREL28:
     case R_CRX_REGREL32:
       /* 'hit_data' is relative to the start of the instruction, not the
	  relocation offset. Advance it to account for the exact offset.  */
       hit_data += 2;
       break;

     case R_CRX_REL4:
       /* This relocation type is used only in 'Branch if Equal to 0'
	  instructions and requires special handling.  */
       Rvalue -= 1;
       break;

     case R_CRX_NONE:
       return bfd_reloc_ok;
       break;

     case R_CRX_SWITCH8:
     case R_CRX_SWITCH16:
     case R_CRX_SWITCH32:
       /* We only care about the addend, where the difference between
	  expressions is kept.  */
       Rvalue = 0;

     default:
       break;
    }

  if (howto->pc_relative)
    {
      /* Subtract the address of the section containing the location.  */
      Rvalue -= (input_section->output_section->vma
		 + input_section->output_offset);
      /* Subtract the position of the location within the section.  */
      Rvalue -= offset;
    }

  /* Add in supplied addend.  */
  Rvalue += addend;

  /* Complain if the bitfield overflows, whether it is considered
     as signed or unsigned.  */
  check = Rvalue >> howto->rightshift;

  /* Assumes two's complement.  This expression avoids
     overflow if howto->bitsize is the number of bits in
     bfd_vma.  */
  reloc_bits = (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;

  if (((bfd_vma) check & ~reloc_bits) != 0
      && (((bfd_vma) check & ~reloc_bits)
	  != (-(bfd_vma) 1 & ~reloc_bits)))
    {
      /* The above right shift is incorrect for a signed
	 value.  See if turning on the upper bits fixes the
	 overflow.  */
      if (howto->rightshift && (bfd_signed_vma) Rvalue < 0)
	{
	  check |= ((bfd_vma) - 1
		    & ~((bfd_vma) - 1
			>> howto->rightshift));
	  if (((bfd_vma) check & ~reloc_bits)
	      != (-(bfd_vma) 1 & ~reloc_bits))
	    return bfd_reloc_overflow;
	}
      else
	return bfd_reloc_overflow;
    }

  /* Drop unwanted bits from the value we are relocating to.  */
  Rvalue >>= (bfd_vma) howto->rightshift;

  /* Apply dst_mask to select only relocatable part of the insn.  */
  Rvalue &= howto->dst_mask;

  switch (howto->size)
    {
     case 0:
       if (r_type == R_CRX_REL4)
	 {
	   Rvalue <<= 4;
	   Rvalue |= (bfd_get_8 (input_bfd, hit_data) & 0x0f);
	 }

       bfd_put_8 (input_bfd, (unsigned char) Rvalue, hit_data);
       break;

     case 1:
       if (r_type == R_CRX_REGREL12)
	 Rvalue |= (bfd_get_16 (input_bfd, hit_data) & 0xf000);

       bfd_put_16 (input_bfd, Rvalue, hit_data);
       break;

     case 2:
       if (r_type == R_CRX_REL24
	   || r_type == R_CRX_REGREL22
	   || r_type == R_CRX_REGREL28)
	 Rvalue |= (((bfd_get_16 (input_bfd, hit_data) << 16) |
		      bfd_get_16 (input_bfd, hit_data + 2)) & ~howto->dst_mask);

       if (r_type == R_CRX_NUM32 || r_type == R_CRX_SWITCH32)
	 /* Relocation on DATA is purely little-endian, that is, for a
	    multi-byte datum, the lowest address in memory contains the
	    little end of the datum, that is, the least significant byte.
	    Therefore we use BFD's byte Putting functions.  */
	 bfd_put_32 (input_bfd, Rvalue, hit_data);
       else
	 /* Relocation on INSTRUCTIONS is different : Instructions are
	    word-addressable, that is, each word itself is arranged according
	    to little-endian convention, whereas the words are arranged with
	    respect to one another in BIG ENDIAN fashion.
	    When there is an immediate value that spans a word boundary, it is
	    split in a big-endian way with respect to the words.  */
	 {
	   bfd_put_16 (input_bfd, (Rvalue >> 16) & 0xffff, hit_data);
	   bfd_put_16 (input_bfd, Rvalue & 0xffff, hit_data + 2);
	 }
     break;

     default:
       return bfd_reloc_notsupported;
    }

  return bfd_reloc_ok;
}

/* Delete some bytes from a section while relaxing.  */

static bfd_boolean
elf32_crx_relax_delete_bytes (struct bfd_link_info *link_info, bfd *abfd,
			      asection *sec, bfd_vma addr, int count)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel, *irelend;
  bfd_vma toaddr;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  struct elf_link_hash_entry **start_hashes;
  unsigned int symcount;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  contents = elf_section_data (sec)->this_hdr.contents;

  toaddr = sec->size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   (size_t) (toaddr - addr - count));
  sec->size -= count;

  /* Adjust all the relocs.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
    {
      /* Get the new reloc address.  */
      if ((irel->r_offset > addr
	   && irel->r_offset < toaddr))
	irel->r_offset -= count;
    }

  /* Adjust the local symbols defined in this section.  */
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
    {
      if (isym->st_shndx == sec_shndx
	  && isym->st_value > addr
	  && isym->st_value < toaddr)
	{
	  /* Adjust the addend of SWITCH relocations in this section,
	     which reference this local symbol.  */
	  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
	    {
	      unsigned long r_symndx;
	      Elf_Internal_Sym *rsym;
	      bfd_vma addsym, subsym;

	      /* Skip if not a SWITCH relocation.  */
	      if (ELF32_R_TYPE (irel->r_info) != (int) R_CRX_SWITCH8
		  && ELF32_R_TYPE (irel->r_info) != (int) R_CRX_SWITCH16
		  && ELF32_R_TYPE (irel->r_info) != (int) R_CRX_SWITCH32)
		  continue;

	      r_symndx = ELF32_R_SYM (irel->r_info);
	      rsym = (Elf_Internal_Sym *) symtab_hdr->contents + r_symndx;

	      /* Skip if not the local adjusted symbol.  */
	      if (rsym != isym)
		continue;

	      addsym = isym->st_value;
	      subsym = addsym - irel->r_addend;

	      /* Fix the addend only when -->> (addsym > addr >= subsym).  */
	      if (subsym <= addr)
		irel->r_addend -= count;
	      else
		continue;
	    }

	  isym->st_value -= count;
	}
    }

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = start_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;

  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      /* The '--wrap SYMBOL' option is causing a pain when the object file,
	 containing the definition of __wrap_SYMBOL, includes a direct
	 call to SYMBOL as well. Since both __wrap_SYMBOL and SYMBOL reference
	 the same symbol (which is __wrap_SYMBOL), but still exist as two
	 different symbols in 'sym_hashes', we don't want to adjust
	 the global symbol __wrap_SYMBOL twice.
	 This check is only relevant when symbols are being wrapped.  */
      if (link_info->wrap_hash != NULL)
	{
	  struct elf_link_hash_entry **cur_sym_hashes;

	  /* Loop only over the symbols whom been already checked.  */
	  for (cur_sym_hashes = start_hashes; cur_sym_hashes < sym_hashes;
	       cur_sym_hashes++)
	    {
	      /* If the current symbol is identical to 'sym_hash', that means
		 the symbol was already adjusted (or at least checked).  */
	      if (*cur_sym_hashes == sym_hash)
		break;
	    }
	  /* Don't adjust the symbol again.  */
	  if (cur_sym_hashes < sym_hashes)
	    continue;
	}

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value > addr
	  && sym_hash->root.u.def.value < toaddr)
	sym_hash->root.u.def.value -= count;
    }

  return TRUE;
}

/* This is a version of bfd_generic_get_relocated_section_contents
   which uses elf32_crx_relocate_section.  */

static bfd_byte *
elf32_crx_get_relocated_section_contents (bfd *output_bfd,
					  struct bfd_link_info *link_info,
					  struct bfd_link_order *link_order,
					  bfd_byte *data,
					  bfd_boolean relocatable,
					  asymbol **symbols)
{
  Elf_Internal_Shdr *symtab_hdr;
  asection *input_section = link_order->u.indirect.section;
  bfd *input_bfd = input_section->owner;
  asection **sections = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Sym *isymbuf = NULL;

  /* We only need to handle the case of relaxing, or of having a
     particular set of section contents, specially.  */
  if (relocatable
      || elf_section_data (input_section)->this_hdr.contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
						       link_order, data,
						       relocatable,
						       symbols);

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  memcpy (data, elf_section_data (input_section)->this_hdr.contents,
	  (size_t) input_section->size);

  if ((input_section->flags & SEC_RELOC) != 0
      && input_section->reloc_count > 0)
    {
      Elf_Internal_Sym *isym;
      Elf_Internal_Sym *isymend;
      asection **secpp;
      bfd_size_type amt;

      internal_relocs = (_bfd_elf_link_read_relocs
			 (input_bfd, input_section, NULL,
			  (Elf_Internal_Rela *) NULL, FALSE));
      if (internal_relocs == NULL)
	goto error_return;

      if (symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      amt = symtab_hdr->sh_info;
      amt *= sizeof (asection *);
      sections = bfd_malloc (amt);
      if (sections == NULL && amt != 0)
	goto error_return;

      isymend = isymbuf + symtab_hdr->sh_info;
      for (isym = isymbuf, secpp = sections; isym < isymend; ++isym, ++secpp)
	{
	  asection *isec;

	  if (isym->st_shndx == SHN_UNDEF)
	    isec = bfd_und_section_ptr;
	  else if (isym->st_shndx == SHN_ABS)
	    isec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    isec = bfd_com_section_ptr;
	  else
	    isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);

	  *secpp = isec;
	}

      if (! elf32_crx_relocate_section (output_bfd, link_info, input_bfd,
				     input_section, data, internal_relocs,
				     isymbuf, sections))
	goto error_return;

      if (sections != NULL)
	free (sections);
      if (isymbuf != NULL
	  && symtab_hdr->contents != (unsigned char *) isymbuf)
	free (isymbuf);
      if (elf_section_data (input_section)->relocs != internal_relocs)
	free (internal_relocs);
    }

  return data;

 error_return:
  if (sections != NULL)
    free (sections);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (input_section)->relocs != internal_relocs)
    free (internal_relocs);
  return NULL;
}

/* Relocate a CRX ELF section.  */

static bfd_boolean
elf32_crx_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
			    bfd *input_bfd, asection *input_section,
			    bfd_byte *contents, Elf_Internal_Rela *relocs,
			    Elf_Internal_Sym *local_syms,
			    asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel, *relend;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);
      howto = crx_elf_howto_table + (r_type);

      h = NULL;
      sym = NULL;
      sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean unresolved_reloc, warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      r = crx_elf_final_link_relocate (howto, input_bfd, output_bfd,
					input_section,
					contents, rel->r_offset,
					relocation, rel->r_addend,
					info, sec, h == NULL);

      if (r != bfd_reloc_ok)
	{
	  const char *name;
	  const char *msg = (const char *) 0;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    {
	      name = (bfd_elf_string_from_elf_section
		      (input_bfd, symtab_hdr->sh_link, sym->st_name));
	      if (name == NULL || *name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  switch (r)
	    {
	     case bfd_reloc_overflow:
	       if (!((*info->callbacks->reloc_overflow)
		     (info, (h ? &h->root : NULL), name, howto->name,
		      (bfd_vma) 0, input_bfd, input_section,
		      rel->r_offset)))
		 return FALSE;
	       break;

	     case bfd_reloc_undefined:
	       if (!((*info->callbacks->undefined_symbol)
		     (info, name, input_bfd, input_section,
		      rel->r_offset, TRUE)))
		 return FALSE;
	       break;

	     case bfd_reloc_outofrange:
	       msg = _("internal error: out of range error");
	       goto common_error;

	     case bfd_reloc_notsupported:
	       msg = _("internal error: unsupported relocation error");
	       goto common_error;

	     case bfd_reloc_dangerous:
	       msg = _("internal error: dangerous error");
	       goto common_error;

	     default:
	       msg = _("internal error: unknown error");
	       /* Fall through.  */

	     common_error:
	       if (!((*info->callbacks->warning)
		     (info, msg, name, input_bfd, input_section,
		      rel->r_offset)))
		 return FALSE;
	       break;
	    }
	}
    }

  return TRUE;
}

/* This function handles relaxing for the CRX.

   There's quite a few relaxing opportunites available on the CRX:

	* bal/bcond:32 -> bal/bcond:16				   2 bytes
	* bcond:16 -> bcond:8					   2 bytes
	* cmpbcond:24 -> cmpbcond:8				   2 bytes
	* arithmetic imm32 -> arithmetic imm16			   2 bytes

   Symbol- and reloc-reading infrastructure copied from elf-m10200.c.  */

static bfd_boolean
elf32_crx_relax_section (bfd *abfd, asection *sec,
			 struct bfd_link_info *link_info, bfd_boolean *again)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;
  Elf_Internal_Sym *isymbuf = NULL;

  /* Assume nothing changes.  */
  *again = FALSE;

  /* We don't have to do anything for a relocatable link, if
     this section does not have relocs, or if this is not a
     code section.  */
  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;

  /* Walk through them looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;

      /* If this isn't something that can be relaxed, then ignore
	 this reloc.  */
      if (ELF32_R_TYPE (irel->r_info) != (int) R_CRX_REL32
	  && ELF32_R_TYPE (irel->r_info) != (int) R_CRX_REL16
	  && ELF32_R_TYPE (irel->r_info) != (int) R_CRX_REL24
	  && ELF32_R_TYPE (irel->r_info) != (int) R_CRX_IMM32)
	continue;

      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  /* Go get them off disk.  */
	  else if (!bfd_malloc_and_get_section (abfd, sec, &contents))
	    goto error_return;
	}

      /* Read this BFD's local symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;
	  asection *sym_sec;

	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
	    sym_sec = bfd_und_section_ptr;
	  else if (isym->st_shndx == SHN_ABS)
	    sym_sec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    sym_sec = bfd_com_section_ptr;
	  else
	    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);

	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    /* This appears to be a reference to an undefined
	       symbol.  Just ignore it--it will be caught by the
	       regular reloc processing.  */
	    continue;

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}

      /* For simplicity of coding, we are going to modify the section
	 contents, the section relocs, and the BFD symbol table.  We
	 must tell the rest of the code not to free up this
	 information.  It would be possible to instead create a table
	 of changes which have to be made, as is done in coff-mips.c;
	 that would be more work, but would require less memory when
	 the linker is run.  */

      /* Try to turn a 32bit pc-relative branch/call into
	 a 16bit pc-relative branch/call.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_CRX_REL32)
	{
	  bfd_vma value = symval;

	  /* Deal with pc-relative gunk.  */
	  value -= (sec->output_section->vma + sec->output_offset);
	  value -= irel->r_offset;
	  value += irel->r_addend;

	  /* See if the value will fit in 16 bits, note the high value is
	     0xfffe + 2 as the target will be two bytes closer if we are
	     able to relax.  */
	  if ((long) value < 0x10000 && (long) value > -0x10002)
	    {
	      unsigned short code;

	      /* Get the opcode.  */
	      code = (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset);

	      /* Verify it's a 'bal'/'bcond' and fix the opcode.  */
	      if ((code & 0xfff0) == 0x3170)
		bfd_put_8 (abfd, 0x30, contents + irel->r_offset + 1);
	      else if ((code & 0xf0ff) == 0x707f)
		bfd_put_8 (abfd, 0x7e, contents + irel->r_offset);
	      else
		continue;

	      /* Note that we've changed the relocs, section contents, etc.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      elf_section_data (sec)->this_hdr.contents = contents;
	      symtab_hdr->contents = (unsigned char *) isymbuf;

	      /* Fix the relocation's type.  */
	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					   R_CRX_REL16);

	      /* Delete two bytes of data.  */
	      if (!elf32_crx_relax_delete_bytes (link_info, abfd, sec,
						   irel->r_offset + 2, 2))
		goto error_return;

	      /* That will change things, so, we should relax again.
		 Note that this is not required, and it may be slow.  */
	      *again = TRUE;
	    }
	}

      /* Try to turn a 16bit pc-relative branch into an
	 8bit pc-relative branch.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_CRX_REL16)
	{
	  bfd_vma value = symval;

	  /* Deal with pc-relative gunk.  */
	  value -= (sec->output_section->vma + sec->output_offset);
	  value -= irel->r_offset;
	  value += irel->r_addend;

	  /* See if the value will fit in 8 bits, note the high value is
	     0xfc + 2 as the target will be two bytes closer if we are
	     able to relax.  */
	  if ((long) value < 0xfe && (long) value > -0x100)
	    {
	      unsigned short code;

	      /* Get the opcode.  */
	      code = (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset);

	      /* Verify it's a 'bcond' opcode.  */
	      if ((code & 0xf0ff) != 0x707e)
		continue;

	      /* Note that we've changed the relocs, section contents, etc.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      elf_section_data (sec)->this_hdr.contents = contents;
	      symtab_hdr->contents = (unsigned char *) isymbuf;

	      /* Fix the relocation's type.  */
	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					   R_CRX_REL8);

	      /* Delete two bytes of data.  */
	      if (!elf32_crx_relax_delete_bytes (link_info, abfd, sec,
						   irel->r_offset + 2, 2))
		goto error_return;

	      /* That will change things, so, we should relax again.
		 Note that this is not required, and it may be slow.  */
	      *again = TRUE;
	    }
	}

      /* Try to turn a 24bit pc-relative cmp&branch into
	 an 8bit pc-relative cmp&branch.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_CRX_REL24)
	{
	  bfd_vma value = symval;

	  /* Deal with pc-relative gunk.  */
	  value -= (sec->output_section->vma + sec->output_offset);
	  value -= irel->r_offset;
	  value += irel->r_addend;

	  /* See if the value will fit in 8 bits, note the high value is
	     0x7e + 2 as the target will be two bytes closer if we are
	     able to relax.  */
	  if ((long) value < 0x100 && (long) value > -0x100)
	    {
	      unsigned short code;

	      /* Get the opcode.  */
	      code = (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset);

	      /* Verify it's a 'cmp&branch' opcode.  */
	      if ((code & 0xfff0) != 0x3180 && (code & 0xfff0) != 0x3190
	       && (code & 0xfff0) != 0x31a0 && (code & 0xfff0) != 0x31c0
	       && (code & 0xfff0) != 0x31d0 && (code & 0xfff0) != 0x31e0
	       /* Or a Co-processor branch ('bcop').  */
	       && (code & 0xfff0) != 0x3010 && (code & 0xfff0) != 0x3110)
		continue;

	      /* Note that we've changed the relocs, section contents, etc.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      elf_section_data (sec)->this_hdr.contents = contents;
	      symtab_hdr->contents = (unsigned char *) isymbuf;

	      /* Fix the opcode.  */
	      bfd_put_8 (abfd, 0x30, contents + irel->r_offset + 1);

	      /* Fix the relocation's type.  */
	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					   R_CRX_REL8_CMP);

	      /* Delete two bytes of data.  */
	      if (!elf32_crx_relax_delete_bytes (link_info, abfd, sec,
						   irel->r_offset + 4, 2))
		goto error_return;

	      /* That will change things, so, we should relax again.
		 Note that this is not required, and it may be slow.  */
	      *again = TRUE;
	    }
	}

      /* Try to turn a 32bit immediate address into
	 a 16bit immediate address.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_CRX_IMM32)
	{
	  bfd_vma value = symval;

	  /* See if the value will fit in 16 bits.  */
	  if ((long) value < 0x7fff && (long) value > -0x8000)
	    {
	      unsigned short code;

	      /* Get the opcode.  */
	      code = (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset);

	      /* Verify it's a 'arithmetic double'.  */
	      if ((code & 0xf0f0) != 0x20f0)
		continue;

	      /* Note that we've changed the relocs, section contents, etc.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      elf_section_data (sec)->this_hdr.contents = contents;
	      symtab_hdr->contents = (unsigned char *) isymbuf;

	      /* Fix the opcode.  */
	      bfd_put_8 (abfd, (code & 0xff) - 0x10, contents + irel->r_offset);

	      /* Fix the relocation's type.  */
	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					   R_CRX_IMM16);

	      /* Delete two bytes of data.  */
	      if (!elf32_crx_relax_delete_bytes (link_info, abfd, sec,
						   irel->r_offset + 2, 2))
		goto error_return;

	      /* That will change things, so, we should relax again.
		 Note that this is not required, and it may be slow.  */
	      *again = TRUE;
	    }
	}
    }

  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (! link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
    }

  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return TRUE;

 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return FALSE;
}

/* Definitions for setting CRX target vector.  */
#define TARGET_LITTLE_SYM		bfd_elf32_crx_vec
#define TARGET_LITTLE_NAME		"elf32-crx"
#define ELF_ARCH			bfd_arch_crx
#define ELF_MACHINE_CODE		EM_CRX
#define ELF_MAXPAGESIZE			0x1
#define elf_symbol_leading_char		'_'

#define bfd_elf32_bfd_reloc_type_lookup	elf_crx_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup \
					elf_crx_reloc_name_lookup
#define elf_info_to_howto		elf_crx_info_to_howto
#define elf_info_to_howto_rel		0
#define elf_backend_relocate_section	elf32_crx_relocate_section
#define bfd_elf32_bfd_relax_section	elf32_crx_relax_section
#define bfd_elf32_bfd_get_relocated_section_contents \
				elf32_crx_get_relocated_section_contents
#define elf_backend_can_gc_sections     1
#define elf_backend_rela_normal		1

#include "elf32-target.h"
@


1.19
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d335 1
a335 1
 
d478 1
a478 1
       /* We only care about the addend, where the difference between 
d481 1
a481 1
       
d588 1
a588 1
elf32_crx_relax_delete_bytes (struct bfd_link_info *link_info, bfd *abfd, 
d635 1
a635 1
	  /* Adjust the addend of SWITCH relocations in this section, 
d680 6
a685 6
      /* The '--wrap SYMBOL' option is causing a pain when the object file, 
	 containing the definition of __wrap_SYMBOL, includes a direct 
	 call to SYMBOL as well. Since both __wrap_SYMBOL and SYMBOL reference 
	 the same symbol (which is __wrap_SYMBOL), but still exist as two 
	 different symbols in 'sym_hashes', we don't want to adjust 
	 the global symbol __wrap_SYMBOL twice.  
d690 1
a690 1
	  
d692 1
a692 1
	  for (cur_sym_hashes = start_hashes; cur_sym_hashes < sym_hashes; 
d695 1
a695 1
	      /* If the current symbol is identical to 'sym_hash', that means 
@


1.18
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d757 1
a757 1
			 (input_bfd, input_section, (PTR) NULL,
d987 1
a987 1
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
@


1.17
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d878 1
a878 1
					 rel, relend, howto, contents);
@


1.16
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d2 1
a2 1
   Copyright 2004, 2005, 2006, 2007, 2009, 2010
d876 1
a876 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.16.6.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d876 1
a876 1
      if (sec != NULL && discarded_section (sec))
@


1.15
log
@fix set but unused variable warnings
@
text
@d877 2
a878 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.14
log
@update copyright dates
@
text
@d2 2
a3 1
   Copyright 2004, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
a594 1
  Elf_Internal_Rela *irelalign;
a606 4
  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */

  irelalign = NULL;
@


1.13
log
@

2009-03-25  M R Swami Reddy <MR.Swami.Reddy@@nsc.com>

	* elf32-crx.c (crx_elf_howto_table): Zero the src_mask field of
	the reloc descriptions.
@
text
@d2 1
a2 1
   Copyright 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.12
log
@Switch sources over to use the GPL version 3
@
text
@d107 1
a107 1
	 0xf,			/* src_mask */
d121 1
a121 1
	 0xff,			/* src_mask */
d135 1
a135 1
	 0xff,			/* src_mask */
d149 1
a149 1
	 0xffff,		/* src_mask */
d163 1
a163 1
	 0xffffff,		/* src_mask */
d177 1
a177 1
	 0xffffffff,		/* src_mask */
d191 1
a191 1
	 0xfff,			/* src_mask */
d205 1
a205 1
	 0x3fffff,		/* src_mask */
d219 1
a219 1
	 0xfffffff,		/* src_mask */
d233 1
a233 1
	 0xffffffff,		/* src_mask */
d247 1
a247 1
	 0xffff,		/* src_mask */
d261 1
a261 1
	 0xffffffff,		/* src_mask */
d275 1
a275 1
	 0xff,	  		/* src_mask */
d289 1
a289 1
	 0xffff,  		/* src_mask */
d303 1
a303 1
	 0xffffffff,  		/* src_mask */
d317 1
a317 1
	 0xffff,  		/* src_mask */
d331 1
a331 1
	 0xffffffff,  		/* src_mask */
d348 1
a348 1
	 0xff,			/* src_mask */
d365 1
a365 1
	 0xffff,		/* src_mask */
d382 1
a382 1
	 0xffffffff,		/* src_mask */
@


1.11
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.10
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.9
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d402 16
d1330 2
@


1.8
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2 1
a2 1
   Copyright 2004, 2005, 2006 Free Software Foundation, Inc.
a823 3
  if (info->relocatable)
    return TRUE;

d863 14
@


1.7
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2 1
a2 1
   Copyright 2004 Free Software Foundation, Inc.
a40 6
static asection * elf32_crx_gc_mark_hook
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);
static bfd_boolean elf32_crx_gc_sweep_hook
  (bfd *, struct bfd_link_info *, asection *,
   const Elf_Internal_Rela *);
a1293 36
static asection *
elf32_crx_gc_mark_hook (asection *sec,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			Elf_Internal_Rela *rel ATTRIBUTE_UNUSED,
			struct elf_link_hash_entry *h,
			Elf_Internal_Sym *sym)
{
  if (h == NULL)
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  switch (h->root.type)
    {
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      return h->root.u.def.section;

    case bfd_link_hash_common:
      return h->root.u.c.p->section;

    default:
      return NULL;
    }
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf32_crx_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 asection *sec ATTRIBUTE_UNUSED,
			 const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  /* We don't support garbage collection of GOT and PLT relocs yet.  */
  return TRUE;
}

a1308 2
#define elf_backend_gc_mark_hook        elf32_crx_gc_mark_hook
#define elf_backend_gc_sweep_hook       elf32_crx_gc_sweep_hook
@


1.6
log
@Update the FSF address in the copyright/GPL notice
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.5
log
@2004-12-23  Tomer Levi  <Tomer.Levi@@nsc.com>

	* elf32-crx.c (elf32_crx_relax_section): Support 'bcop' relaxation.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.4
log
@2004-12-14  Tomer Levi  <Tomer.Levi@@nsc.com>

	* elf32-crx.c (elf32_crx_relax_delete_bytes): Add 'struct bfd_link_info *' to prototype, to make hash info available.
	Prevent wrapped symbols from being adjusted twice.
@
text
@d1186 3
a1188 1
	       && (code & 0xfff0) != 0x31d0 && (code & 0xfff0) != 0x31e0)
@


1.3
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d33 1
a33 1
  (bfd *, asection *, bfd_vma, int);
d576 2
a577 2
elf32_crx_relax_delete_bytes (bfd *abfd, asection *sec,
			      bfd_vma addr, int count)
d589 1
d666 1
a666 1
  sym_hashes = elf_sym_hashes (abfd);
d673 25
d1107 1
a1107 1
	      if (!elf32_crx_relax_delete_bytes (abfd, sec,
d1152 1
a1152 1
	      if (!elf32_crx_relax_delete_bytes (abfd, sec,
d1202 1
a1202 1
	      if (!elf32_crx_relax_delete_bytes (abfd, sec,
d1243 1
a1243 1
	      if (!elf32_crx_relax_delete_bytes (abfd, sec,
@


1.2
log
@Add CRX insns: pushx, popx
Add support to GAS for expressions which are the difference of two symbols
@
text
@d871 3
a873 2
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
@


1.2.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@@


1.1
log
@Add new port: crx-elf
@
text
@d80 4
a83 1
  {BFD_RELOC_CRX_IMM32,	    R_CRX_IMM32}
d338 52
a389 1
	 FALSE)			/* pcrel_offset */
d463 7
d547 1
a547 1
       if (r_type == R_CRX_NUM32)
d626 34
a659 1
	isym->st_value -= count;
@

